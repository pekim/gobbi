[
{
	"uri": "/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " gobbi gobject bindings\ngobbi is a set of generated Go bindings for gobject based libraries. There are bindings, with varying degrees of completeness, for gtk, gdk, gdkpixbuf, gio, gobject, and glib.\nThe intention is to provide the bindings required for writing gtk applications. So the focus is on supporting functions in the higher level libraries such as gtk, gdk, gdkpixbuf and gio. Much of the functionality provided by the lower level libraries, such as glib and gobject, is adequately supported in Go core packages.\n"
},
{
	"uri": "/getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": " pre-requisites  go 1.11 or later libraries  debian/ubuntu packages - libatk1.0-dev libcairo2-dev libglib2.0-dev libgtk-3-dev libpango1.0-dev note that dev libraries are required because pkg-config and headers are necessary  C compiler, and a linker  required because of the use of cgo for debian based distributions the build-essential package should suffice   running examples  git clone https://github.com/pekim/gobbi.git cd gobbi ./gobbi example simple_window  Be patient. The first go build or go run will take quite a while, perhaps a few minutes. Subsequent builds of applications will be a lot quicker as cached gobbi packages will be used by the Go commands.   Run ./gobbi examples for a list of the available examples.\nuse in a application Using gobbi in an application in no different to using most other libraries.\nTo add gobbi to a project that make use of go modules use go get.\ngo get github.com/pekim/gobbi Then import a package such as gtk.\nimport \u0026#34;github.com/pekim/gobbi/lib/gtk\u0026#34; build tags It will often be necessary to build gobbi applications with build tags.\n"
},
{
	"uri": "/application-lifecycle/",
	"title": "Application lifecycle",
	"tags": [],
	"description": "",
	"content": " main thread The main function, and therefore the main loop, should run on the main thread.\nfunc init() { // Ensure that the ui\u0026#39;s main thread is  // locked to the main thread.  runtime.LockOSThread() } initialisation Call gtk.Init (or gtk.InitChack) before calling any other gtk functions. Typically the program\u0026rsquo;s command-line arguments will be passed to gtk.Init.\ngtk.Init(os.Args) window creation Most applications will create a window when initialising.\nwindow := gtk.WindowNew(gtk.GTK_WINDOW_TOPLEVEL) termination If an application has only one window, then it might terminate when the window is closed.\nwindow.Widget().ConnectDestroy(func() { gtk.MainQuit() }) This may be written more succinctly, like this.\nwindow.Widget().ConnectDestroy(gtk.MainQuit) main loop To run the main loop, call gtk.Main. The function will not return from the main loop until gtk.MainQuit is called.\ngtk.Main() minimal application Putting all of the above together yields a minimal application. A window is created, and the application will exit when the window is closed.\npackage main import ( \u0026#34;github.com/pekim/gobbi/lib/gtk\u0026#34; \u0026#34;os\u0026#34; \u0026#34;runtime\u0026#34; ) func init() { runtime.LockOSThread() } func main() { gtk.Init(os.Args) window := gtk.WindowNew(gtk.GTK_WINDOW_TOPLEVEL) window.Widget().ConnectDestroy(gtk.MainQuit) window.Widget().ShowAll() gtk.Main() } gtk.Application A preferred approach to gtk application and window management is to use gtk.Application. The gtk_application example illustrates this.\n"
},
{
	"uri": "/build-tags/",
	"title": "Build tags",
	"tags": [],
	"description": "",
	"content": " gobbi uses Go build tags to allow targetting of specific library versions. This means that when using Go build tools (such as go build and go run) to build a gobbi application, use of the -tags flag will usually be necessary.\nSee How to use conditional compilation with the go build tool for more background about build tags.\nno tags If a gobbi application is built with no tags specified, the only apis available will be those present in all version of the various gnome libraries.\ntags targetting versions To use an api that is only available from a specific version onwards, use a tag constructed from the library name and the version.\nFor example gtk_builder_new_from_file is only available from gtk 3.10 onwards. So to use it, a tag specifying 3.10 (or a later version) is required.\ngo build -tags gtk_3.10 my_app.go  typical tags If targetting Ubuntu 16.04 (Xenial Xerus) or later, the following tags would be a good starting point.\ngo build -tags \u0026quot;glib_2.48 gdk_3.4 gdkpixbuf_2.32 gio_2.32 gtk_3.18\u0026quot; my_app.go  editors \u0026amp; IDEs Editors and IDE can provide better completion and error feedback if they are aware of the build tags that an application is to be built with.\nvs code The relevant setting is Go: Build Tags.\ngoland In the Settings... dialog, the relevant setting can be found under - Go - Vendoring \u0026amp; Build Tags - Custom tags\n"
},
{
	"uri": "/downcasting-upcasting/",
	"title": "Casting",
	"tags": [],
	"description": "",
	"content": " Gtk classes derive, in a hierarchy, from the GObject class.\nIn gobbi\u0026rsquo;s implementation of GOBject\u0026rsquo;s classes, each class does not directly extend its ancestor classes. Instead, for an class instance it is possible to get a reference to a ancestor class instance for the same gtk object.\nupcasting In a gtk application there will frequently be a need to access members of an object\u0026rsquo;s ancestor class.\nFor example when adding a Label to a Container, this will not work.\nwindow := gtk.WindowNew(gtk.GTK_WINDOW_TOPLEVEL) label := gtk.LabelNew(\u0026#34;a label\u0026#34;) window.Add(label) gtk.Window does not directly have a Add method. The Add method is a member of gtk.Container, which is an ancestor of gtk.Window.\nThe gtk.Window\u0026rsquo;s Container may be obtained by calling the Container() method.\nAnd as the Add method expects a gtk.Widget, the gtk.Label\u0026rsquo;s Widget method is called.\nwindow := gtk.WindowNew(gtk.GTK_WINDOW_TOPLEVEL) label := gtk.LabelNew(\u0026#34;a label\u0026#34;) window.Container().Add(label.Widget()) downcasting Downcasting operates in the other direction, from a class to a derived class,\nDowncasting is less common that upcasting. It is potentially quite dangerous, in that it makes it very easy to assert that a widget is something that it is not.\nTo downcast an instance, call one of its CastTo... methods.\nA typically use is when obtaining an object from a builder.\nbuilder := gtk.BuilderNewFromString(...) buttonObject := builder.GetObject(\u0026#34;some-button\u0026#34;) button := gtk.CastToButton(buttonObject) button.ConnectClicked(...) See the builder example to see this in an application.\n"
},
{
	"uri": "/goroutines/",
	"title": "Goroutines",
	"tags": [],
	"description": "",
	"content": "All calls to gtk functions should be performed on the main thread. To perform such a call from a goroutine, use glib.IdleAdd to schedule invocation of a callback function on the main thread.\nglib.IdleAdd(func() bool { someLabel.SetText(\u0026#34;some text\u0026#34;) return glib.SOURCE_REMOVE }) Return glib.SOURCE_REMOVE to ensure the function is not called again next time the main loop is idle. Alternatively return glib.SOURCE_CONTINUE to have the function called again.\n"
},
{
	"uri": "/gvalue/",
	"title": "gobject.Value",
	"tags": [],
	"description": "",
	"content": "The gobject library\u0026rsquo;s GValue type is represented by gobject.Value.\nSee the list example for an example of its use.\n"
},
{
	"uri": "/api/",
	"title": "APIs",
	"tags": [],
	"description": "",
	"content": " There is currently very little Godoc api documentation for gobbi. As most apis are relatively direct mappings of the C library APIs, the Gnome libraries documentation should provide enough information to gain some understanding of how to use the Go apis in gobbi.\npackages There is one go package for each Gnome library.\nout params Out parameters are mapped as return values in Go functions. Inout parameters are not yet supported, but when they are the will be exposed as both parameters and return values in Go functions.\ninout params Inout parameters are not yet supported.\nfunctions returning GError Functions that have a GError out parameter, may return a Go error. The error (if not nil) will be a glib.Error, which has fields containing details of the error.\nvariadic functions Variadic api functions are not supported.\narray functions In many cases the library provides an equivalent array based function that can be used instead. The names of the array-based functions often end in a \u0026lsquo;v\u0026rsquo;.\nThe C arrays are represented as Go slices.\nIn the case of such functions that accept two slice, be certain that they are both of the same length. The behaviour when they are not is undefined.\nsingle item functions In other cases, instead of a variadic function that would operate on multiple values at once, there will be a supported function that operates on a single item at a time.\ncairo \u0026amp; pango These libraries currently have very little support, as the introspection date available for them is inadequate. Support may be added later, with manually generated bindings.\n"
},
{
	"uri": "/signal-handling/",
	"title": "Signal handling",
	"tags": [],
	"description": "",
	"content": " connecting To connect an object to a signal that it emits, call one of the object\u0026rsquo;s Connect... methods.\nThe connect methods all accept a handler argument that is a function with a specific signature. Some handlers have no parameters, others have one or more parameters that provide event-specific information.\nbutton := gtk.ButtonNewWithLabel(\u0026#34;a button\u0026#34;) button.Widget().SetEvents(int32(gdk.GDK_POINTER_MOTION_MASK)) button.Widget().ConnectMotionNotifyEvent( func(event *gdk.EventMotion) bool { fmt.Println(event.Y, event.Y) return false }) Remember that it may be necessary to upcast to access the desired connect method.\ndisconnecting All of the Connect... methods return a handler id. The id may be used later to disconnect the handler.\nconnectId := button.ConnectClicked(func() { ... }) ... button.DisconnectClicked(connectId)"
},
{
	"uri": "/stuff/",
	"title": "st title",
	"tags": [],
	"description": "",
	"content": " st "
},
{
	"uri": "/stuff/other/",
	"title": "st-other",
	"tags": [],
	"description": "",
	"content": " Other other stuff "
},
{
	"uri": "/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "gobbi\n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/dir-2/",
	"title": "Dir-2s",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/dir-2/d2-f1/",
	"title": "d2 --- f2",
	"tags": [],
	"description": "",
	"content": ""
}]