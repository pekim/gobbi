[
{
	"uri": "https://pekim.github.io/gobbi/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " gobbi gobject bindings\ngobbi is a set of generated Go bindings for gobject based libraries. There are bindings, with varying degrees of completeness, for gtk, gdk, gdkpixbuf, gio, gobject, and glib.\nThe intention is to provide the bindings required for writing gtk applications. So the focus is on supporting functions in the higher level libraries such as gtk, gdk, gdkpixbuf and gio. Much of the functionality provided by the lower level libraries, such as glib and gobject, is adequately supported in Go core packages.\n"
},
{
	"uri": "https://pekim.github.io/gobbi/getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": " pre-requisites  go 1.11 or later libraries  debian/ubuntu packages - libatk1.0-dev libcairo2-dev libglib2.0-dev libgtk-3-dev libpango1.0-dev note that dev libraries are required because pkg-config and headers are necessary  C compiler, and a linker  required because of the use of cgo for debian based distributions the build-essential package should suffice   running examples  git clone https://github.com/pekim/gobbi.git cd gobbi ./gobbi example simple_window  Be patient. The first go build or go run will take quite a while, perhaps a few minutes. Subsequent builds of applications will be a lot quicker as cached gobbi packages will be used by the Go commands.   Run ./gobbi examples for a list of the available examples.\nuse in a application Using gobbi in an application in no different to using most other libraries.\nTo add gobbi to a project that make use of go modules use go get.\ngo get github.com/pekim/gobbi Then import a package such as gtk.\nimport \u0026#34;github.com/pekim/gobbi/lib/gtk\u0026#34; build tags It will often be necessary to build gobbi applications with build tags.\n"
},
{
	"uri": "https://pekim.github.io/gobbi/application-lifecycle/",
	"title": "Application lifecycle",
	"tags": [],
	"description": "",
	"content": " main thread The main function, and therefore the main loop, should run on the main thread.\nfunc init() { // Ensure that the ui\u0026#39;s main thread is  // locked to the main thread.  runtime.LockOSThread() } initialisation Call gtk.Init (or gtk.InitChack) before calling any other gtk functions. Typically the program\u0026rsquo;s command-line arguments will be passed to gtk.Init.\ngtk.Init(os.Args) window creation Most applications will create a window when initialising.\nwindow := gtk.WindowNew(gtk.GTK_WINDOW_TOPLEVEL) termination If an application has only one window, then it might terminate when the window is closed.\nwindow.Widget().ConnectDestroy(func() { gtk.MainQuit() }) This may be written more succinctly, like this.\nwindow.Widget().ConnectDestroy(gtk.MainQuit) main loop To run the main loop, call gtk.Main. The function will not return from the main loop until gtk.MainQuit is called.\ngtk.Main() minimal application Putting all of the above together yields a minimal application. A window is created, and the application will exit when the window is closed.\npackage main import ( \u0026#34;github.com/pekim/gobbi/lib/gtk\u0026#34; \u0026#34;os\u0026#34; \u0026#34;runtime\u0026#34; ) func init() { runtime.LockOSThread() } func main() { gtk.Init(os.Args) window := gtk.WindowNew(gtk.GTK_WINDOW_TOPLEVEL) window.Widget().ConnectDestroy(gtk.MainQuit) window.Widget().ShowAll() gtk.Main() } gtk.Application A preferred approach to gtk application and window management is to use gtk.Application. The gtk_application example illustrates this.\n"
},
{
	"uri": "https://pekim.github.io/gobbi/build-tags/",
	"title": "Build tags",
	"tags": [],
	"description": "",
	"content": " gobbi uses Go build tags to allow targetting of specific library versions. This means that when using Go build tools (such as go build and go run) to build a gobbi application, use of the -tags flag will usually be necessary.\nSee How to use conditional compilation with the go build tool for more background about build tags.\nno tags If a gobbi application is built with no tags specified, the only apis available will be those present in all version of the various gnome libraries.\ntags targetting versions To use an api that is only available from a specific version onwards, use a tag constructed from the library name and the version.\nFor example gtk_builder_new_from_file is only available from gtk 3.10 onwards. So to use it, a tag specifying 3.10 (or a later version) is required.\ngo build -tags gtk_3.10 my_app.go  typical tags If targetting Ubuntu 16.04 (Xenial Xerus) or later, the following tags would be a good starting point.\ngo build -tags \u0026quot; \\ glib_2.48 \\ gdk_3.4 \\ gdkpixbuf_2.32 \\ gio_2.32 \\ gtk_3.18\u0026quot; \\ my_app.go  editors \u0026amp; IDEs Editors and IDE can provide better completion and error feedback if they are aware of the build tags that an application is to be built with.\nvs code The relevant setting is Go: Build Tags.\ngoland In the Settings... dialog, the relevant setting can be found under - Go - Vendoring \u0026amp; Build Tags - Custom tags\n"
},
{
	"uri": "https://pekim.github.io/gobbi/goroutines/",
	"title": "Goroutines",
	"tags": [],
	"description": "",
	"content": "All calls to gtk functions should be performed on the main thread. To perform such a call from a goroutine, use glib.IdleAdd to schedule invocation of a callback function on the main thread.\nglib.IdleAdd(func() bool { someLabel.SetText(\u0026#34;some text\u0026#34;) return glib.SOURCE_REMOVE }) Return glib.SOURCE_REMOVE to ensure the function is not called again next time the main loop is idle. Alternatively return glib.SOURCE_CONTINUE to have the function called again.\n"
},
{
	"uri": "https://pekim.github.io/gobbi/gvalue/",
	"title": "gobject.Value",
	"tags": [],
	"description": "",
	"content": "The gobject library\u0026rsquo;s GValue type is represented by gobject.Value.\nSee the list example for an example of its use.\n"
},
{
	"uri": "https://pekim.github.io/gobbi/casting/",
	"title": "Casting",
	"tags": [],
	"description": "",
	"content": " Gtk classes derive in a hierarchy from the GObject class.\nIn gobbi\u0026rsquo;s implementation of GOBject\u0026rsquo;s classes, each class does not directly extend (or embed in Go terms) its ancestor classes. Instead, for an class instance it is possible to get a reference to an ancestor or descendant class instance for the same gtk object.\nupcasting In a gtk application there will frequently be a need to access members of an object\u0026rsquo;s ancestor class.\nFor example when adding a Label to a Container, this will not work.\nwindow := gtk.WindowNew(gtk.GTK_WINDOW_TOPLEVEL) label := gtk.LabelNew(\u0026#34;a label\u0026#34;) window.Add(label) // \u0026lt;-- ERROR gtk.Window does not directly have a Add method. The Add method is a member of gtk.Container, which is an ancestor of gtk.Window.\nThe gtk.Window\u0026rsquo;s Container may be obtained by calling the Container() method.\nAnd as the Add method expects a gtk.Widget, the gtk.Label\u0026rsquo;s Widget method is called to cast to a gtk.Widget.\nwindow := gtk.WindowNew(gtk.GTK_WINDOW_TOPLEVEL) label := gtk.LabelNew(\u0026#34;a label\u0026#34;) window.Container().Add(label.Widget()) All derived classes have receiver functions for directly casting to all ancestor types.\n// This will work, but is unnecessary. widget1 := gtk.WindowNew().Bin().Container().Widget() // This will achieve the same end result. widget2 := gtk.WindowNew().Widget() downcasting Downcasting operates in the other direction, from a class to a derived class,\nDowncasting is less common that upcasting. It is potentially quite dangerous, in that it makes it very easy to assert that a widget is something that it is not.\nTo downcast an instance, call one of the CastTo... methods.\nA typically use is when obtaining an object from a builder.\nbuilder := gtk.BuilderNewFromString(...) buttonObject := builder.GetObject(\u0026#34;some-button\u0026#34;) button := gtk.CastToButton(buttonObject) button.ConnectClicked(...) See the builder example to see this in an application.\n"
},
{
	"uri": "https://pekim.github.io/gobbi/signal-handling/",
	"title": "Signal handling",
	"tags": [],
	"description": "",
	"content": " connecting To connect an object to a signal that it emits, call one of the object\u0026rsquo;s Connect... methods.\nThe connect methods all accept a handler argument that is a function with a specific signature. Some handlers have no parameters, others have one or more parameters that provide event-specific information.\nbutton := gtk.ButtonNewWithLabel(\u0026#34;a button\u0026#34;) button.Widget().SetEvents(int32(gdk.GDK_POINTER_MOTION_MASK)) button.Widget().ConnectMotionNotifyEvent( func(event *gdk.EventMotion) bool { fmt.Println(event.Y, event.Y) return false }) Remember that it may be necessary to upcast to access the desired connect method.\ndisconnecting All of the Connect... methods return a handler id. The id may be used later to disconnect the handler.\nconnectId := button.ConnectClicked(func() { ... }) ... button.DisconnectClicked(connectId)"
},
{
	"uri": "https://pekim.github.io/gobbi/format-functions/",
	"title": "Format functions",
	"tags": [],
	"description": "",
	"content": "Some C library variadic functions accept trailing arguments that include a printf style format string followed by arguments to insert in to the format string. gtk_message_dialog_new is an example of such a function.\nThe equivalent functions in gobbi accept fmt package compatible arguments. This is because fmt.Sprint is used to format a string before passing it as the last argument to the wrapped C function.\nA much simplified representation of such a function might help to make this clearer.\nfunc SomeRepresentativeFunction( a string, b int, format string, args ...interface{}, ) { c_a := C.String(a) c_b := C.int(b) formattedString := fmt.Sprintf(format, args...) c_formattedString := C.String(formattedString) C.some_representative_function(c_a, c_b, c_formattedString) }"
},
{
	"uri": "https://pekim.github.io/gobbi/reference-counting/",
	"title": "Reference counting",
	"tags": [],
	"description": "",
	"content": " The gobject library implements Object memory management, including reference counting, for GObject derived classes. When gobbi creates such an object and a Go object referencing it, it will increment the reference count on the object. When the Go object is finalized, gobbi will decrement the GObject\u0026rsquo;s reference count.\nThe behaviour is slightly different between objects that are initially owned and those that are initially unowned. In both cases gobbi attempts to do the right thing with regard to reference counting.\nCopying gobbi objects Unless there is a compelling reason, gobbi created objects should not be copied or cloned directly by applications, as this would result in references to GObjects without the necessary reference count.\nIf a copy of a gobbi Object derived class is required, it can be achieved as a side effect of a suitable cast like this. As the new object is gobbi managed is will be reference counted correctly.\nlabel1 := gtk.LabelNew(\u0026#34;some text\u0026#34;) label2 := gtk.CastToLabel(label1.Object()) However in most cases even that will not be required, and passing around the pointer to the gobbi object will be sufficient for an application.\n"
},
{
	"uri": "https://pekim.github.io/gobbi/api/",
	"title": "API Docs",
	"tags": [],
	"description": "",
	"content": " Minimal API docs are generated, and are available at https://godoc.org/github.com/pekim/gobbi.\nlibrary functions For most library API functions the generated documentation says little more than what function is being wrapped. The Gnome API Reference documentation should be referenced for details of the APIs.\ngobbi-specific functions The documentation for gobbi-specific functions should be of some use.\n"
},
{
	"uri": "https://pekim.github.io/gobbi/summary-base/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Summary  Introduction Getting started Application lifecycle\n Build tags (library versions)\n Casting\n Goroutines\n gobject.Value\n Signal handling API  "
},
{
	"uri": "https://pekim.github.io/gobbi/_footer/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pekim.github.io/gobbi/_header/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "gobbi\n"
},
{
	"uri": "https://pekim.github.io/gobbi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pekim.github.io/gobbi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]