<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GObject" version="2.0"/>
  <package name="gobject-introspection-1.0"/>
  <c:include name="girepository.h"/>
  <namespace name="GIRepository"
             version="2.0"
             shared-library="libgirepository-1.0.so.1"
             c:identifier-prefixes="GI"
             c:symbol-prefixes="g">
    <alias name="ArgInfo" c:type="GIArgInfo">
      <doc xml:space="preserve">Represents an argument.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="CallableInfo" c:type="GICallableInfo">
      <doc xml:space="preserve">Represents a callable, either #GIFunctionInfo, #GICallbackInfo or
#GIVFuncInfo.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="CallbackInfo" c:type="GICallbackInfo">
      <doc xml:space="preserve">Represents a callback, eg arguments and return value.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="ConstantInfo" c:type="GIConstantInfo">
      <doc xml:space="preserve">Represents a constant.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="EnumInfo" c:type="GIEnumInfo">
      <doc xml:space="preserve">Represents an enum or a flag.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="FieldInfo" c:type="GIFieldInfo">
      <doc xml:space="preserve">Represents a field of a #GIStructInfo or a #GIUnionInfo.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="FunctionInfo" c:type="GIFunctionInfo">
      <doc xml:space="preserve">Represents a function, eg arguments and return value.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="InterfaceInfo" c:type="GIInterfaceInfo">
      <doc xml:space="preserve">Represents an interface.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="ObjectInfo" c:type="GIObjectInfo">
      <doc xml:space="preserve">Represents an object.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="PropertyInfo" c:type="GIPropertyInfo">
      <doc xml:space="preserve">Represents a property of a #GIObjectInfo or a #GIInterfaceInfo.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="RegisteredTypeInfo" c:type="GIRegisteredTypeInfo">
      <doc xml:space="preserve">Represent a registered type.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="SignalInfo" c:type="GISignalInfo">
      <doc xml:space="preserve">Represents a signal.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="StructInfo" c:type="GIStructInfo">
      <doc xml:space="preserve">Represents a struct.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="TypeInfo" c:type="GITypeInfo">
      <doc xml:space="preserve">Represents type information, direction, transfer etc.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="UnionInfo" c:type="GIUnionInfo">
      <doc xml:space="preserve">Represents a union.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="VFuncInfo" c:type="GIVFuncInfo">
      <doc xml:space="preserve">Represents a virtual function.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <alias name="ValueInfo" c:type="GIValueInfo">
      <doc xml:space="preserve">Represents a enum value of a #GIEnumInfo.</doc>
      <type name="BaseInfo" c:type="GIBaseInfo"/>
    </alias>
    <union name="Argument" c:type="GIArgument">
      <doc xml:space="preserve">Stores an argument of varying type</doc>
      <field name="v_boolean" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gboolean" c:type="gboolean"/>
      </field>
      <field name="v_int8" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gint8" c:type="gint8"/>
      </field>
      <field name="v_uint8" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="guint8" c:type="guint8"/>
      </field>
      <field name="v_int16" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gint16" c:type="gint16"/>
      </field>
      <field name="v_uint16" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="guint16" c:type="guint16"/>
      </field>
      <field name="v_int32" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gint32" c:type="gint32"/>
      </field>
      <field name="v_uint32" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="v_int64" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gint64" c:type="gint64"/>
      </field>
      <field name="v_uint64" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="guint64" c:type="guint64"/>
      </field>
      <field name="v_float" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gfloat" c:type="gfloat"/>
      </field>
      <field name="v_double" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gdouble" c:type="gdouble"/>
      </field>
      <field name="v_short" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gshort" c:type="gshort"/>
      </field>
      <field name="v_ushort" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gushort" c:type="gushort"/>
      </field>
      <field name="v_int" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gint" c:type="gint"/>
      </field>
      <field name="v_uint" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="guint" c:type="guint"/>
      </field>
      <field name="v_long" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="glong" c:type="glong"/>
      </field>
      <field name="v_ulong" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gulong" c:type="gulong"/>
      </field>
      <field name="v_ssize" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gssize" c:type="gssize"/>
      </field>
      <field name="v_size" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gsize" c:type="gsize"/>
      </field>
      <field name="v_string" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="utf8" c:type="gchar*"/>
      </field>
      <field name="v_pointer" writable="1">
        <doc xml:space="preserve">TODO</doc>
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </union>
    <enumeration name="ArrayType" c:type="GIArrayType">
      <doc xml:space="preserve">The type of array in a #GITypeInfo.</doc>
      <member name="c" value="0" c:identifier="GI_ARRAY_TYPE_C">
        <doc xml:space="preserve">a C array, char[] for instance</doc>
      </member>
      <member name="array" value="1" c:identifier="GI_ARRAY_TYPE_ARRAY">
        <doc xml:space="preserve">a @GArray array</doc>
      </member>
      <member name="ptr_array"
              value="2"
              c:identifier="GI_ARRAY_TYPE_PTR_ARRAY">
        <doc xml:space="preserve">a #GPtrArray array</doc>
      </member>
      <member name="byte_array"
              value="3"
              c:identifier="GI_ARRAY_TYPE_BYTE_ARRAY">
        <doc xml:space="preserve">a #GByteArray array</doc>
      </member>
    </enumeration>
    <record name="AttributeIter" c:type="GIAttributeIter">
      <doc xml:space="preserve">An opaque structure used to iterate over attributes
in a #GIBaseInfo struct.</doc>
      <field name="data" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="data2" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="data3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="data4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
    </record>
    <record name="BaseInfo"
            c:type="GIBaseInfo"
            glib:type-name="GIBaseInfo"
            glib:get-type="g_base_info_gtype_get_type"
            c:symbol-prefix="base_info_gtype">
      <doc xml:space="preserve">GIBaseInfo is the common base struct of all other *Info structs
accessible through the #GIRepository API.
All other structs can be casted to a #GIBaseInfo, for instance:
&lt;example&gt;
&lt;title&gt;Casting a #GIFunctionInfo to #GIBaseInfo&lt;/title&gt;
&lt;programlisting&gt;
   GIFunctionInfo *function_info = ...;
   GIBaseInfo *info = (GIBaseInfo*)function_info;
&lt;/programlisting&gt;
&lt;/example&gt;
Most #GIRepository APIs returning a #GIBaseInfo is actually creating a new struct, in other
words, g_base_info_unref() has to be called when done accessing the data.
GIBaseInfos are normally accessed by calling either
g_irepository_find_by_name(), g_irepository_find_by_gtype() or g_irepository_get_info().

&lt;example&gt;
&lt;title&gt;Getting the Button of the Gtk typelib&lt;/title&gt;
&lt;programlisting&gt;
   GIBaseInfo *button_info = g_irepository_find_by_name(NULL, "Gtk", "Button");
   ... use button_info ...
   g_base_info_unref(button_info);
&lt;/programlisting&gt;
&lt;/example&gt;

&lt;refsect1 id="gi-gibaseinfo.struct-hierarchy" role="struct_hierarchy"&gt;
&lt;title role="struct_hierarchy.title"&gt;Struct hierarchy&lt;/title&gt;
&lt;synopsis&gt;
  GIBaseInfo
   +----&lt;link linkend="gi-GIArgInfo"&gt;GIArgInfo&lt;/link&gt;
   +----&lt;link linkend="gi-GICallableInfo"&gt;GICallableInfo&lt;/link&gt;
   +----&lt;link linkend="gi-GIConstantInfo"&gt;GIConstantInfo&lt;/link&gt;
   +----&lt;link linkend="gi-GIFieldInfo"&gt;GIFieldInfo&lt;/link&gt;
   +----&lt;link linkend="gi-GIPropertyInfo"&gt;GIPropertyInfo&lt;/link&gt;
   +----&lt;link linkend="gi-GIRegisteredTypeInfo"&gt;GIRegisteredTypeInfo&lt;/link&gt;
   +----&lt;link linkend="gi-GITypeInfo"&gt;GITypeInfo&lt;/link&gt;
&lt;/synopsis&gt;
&lt;/refsect1&gt;</doc>
      <field name="dummy1" readable="0" private="1">
        <type name="gint32" c:type="gint32"/>
      </field>
      <field name="dummy2" readable="0" private="1">
        <type name="gint32" c:type="gint32"/>
      </field>
      <field name="dummy3" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy4" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy5" readable="0" private="1">
        <type name="gpointer" c:type="gpointer"/>
      </field>
      <field name="dummy6" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="dummy7" readable="0" private="1">
        <type name="guint32" c:type="guint32"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="4">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
      <method name="equal" c:identifier="g_base_info_equal">
        <doc xml:space="preserve">Compare two #GIBaseInfo.

Using pointer comparison is not practical since many functions return
different instances of #GIBaseInfo that refers to the same part of the
TypeLib; use this function instead to do #GIBaseInfo comparisons.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if and only if @info1 equals @info2.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info1" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
          <parameter name="info2" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_attribute" c:identifier="g_base_info_get_attribute">
        <doc xml:space="preserve">Retrieve an arbitrary attribute associated with this node.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The value of the attribute, or %NULL if no such attribute exists</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">a freeform string naming an attribute</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_container" c:identifier="g_base_info_get_container">
        <doc xml:space="preserve">Obtain the container of the @info. The container is the parent
GIBaseInfo. For instance, the parent of a #GIFunctionInfo is an
#GIObjectInfo or #GIInterfaceInfo.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the container</doc>
          <type name="BaseInfo" c:type="GIBaseInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="g_base_info_get_name">
        <doc xml:space="preserve">Obtain the name of the @info. What the name represents depends on
the #GIInfoType of the @info. For instance for #GIFunctionInfo it is
the name of the function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the name of @info or %NULL if it lacks a name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_namespace" c:identifier="g_base_info_get_namespace">
        <doc xml:space="preserve">Obtain the namespace of @info.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the namespace</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_type" c:identifier="g_base_info_get_type">
        <doc xml:space="preserve">Obtain the info type of the GIBaseInfo.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the info type of @info</doc>
          <type name="InfoType" c:type="GIInfoType"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_typelib" c:identifier="g_base_info_get_typelib">
        <doc xml:space="preserve">Obtain the typelib this @info belongs to</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the typelib.</doc>
          <type name="Typelib" c:type="GITypelib*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_deprecated" c:identifier="g_base_info_is_deprecated">
        <doc xml:space="preserve">Obtain whether the @info is represents a metadata which is
deprecated or not.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if deprecated</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="iterate_attributes"
              c:identifier="g_base_info_iterate_attributes">
        <doc xml:space="preserve">Iterate over all attributes associated with this node.  The iterator
structure is typically stack allocated, and must have its first
member initialized to %NULL.  Attributes are arbitrary namespaced key–value
pairs which can be attached to almost any item.  They are intended for use
by software higher in the toolchain than bindings, and are distinct from
normal GIR annotations.

Both the @name and @value should be treated as constants
and must not be freed.

&lt;example&gt;
&lt;title&gt;Iterating over attributes&lt;/title&gt;
&lt;programlisting&gt;
void
print_attributes (GIBaseInfo *info)
{
  GIAttributeIter iter = { 0, };
  char *name;
  char *value;
  while (g_base_info_iterate_attributes (info, &amp;iter, &amp;name, &amp;value))
    {
      g_print ("attribute name: %s value: %s", name, value);
    }
}
&lt;/programlisting&gt;
&lt;/example&gt;</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if there are more attributes</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
          <parameter name="iterator"
                     direction="inout"
                     caller-allocates="0"
                     transfer-ownership="full">
            <doc xml:space="preserve">a #GIAttributeIter structure, must be initialized; see below</doc>
            <type name="AttributeIter" c:type="GIAttributeIter*"/>
          </parameter>
          <parameter name="name"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">Returned name, must not be freed</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
          <parameter name="value"
                     direction="out"
                     caller-allocates="0"
                     transfer-ownership="none">
            <doc xml:space="preserve">Returned name, must not be freed</doc>
            <type name="utf8" c:type="char**"/>
          </parameter>
        </parameters>
      </method>
      <method name="ref" c:identifier="g_base_info_ref" introspectable="0">
        <doc xml:space="preserve">Increases the reference count of @info.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the same @info.</doc>
          <type name="BaseInfo" c:type="GIBaseInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="unref" c:identifier="g_base_info_unref" introspectable="0">
        <doc xml:space="preserve">Decreases the reference count of @info. When its reference count
drops to 0, the info is freed.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #GIBaseInfo</doc>
            <type name="BaseInfo" c:type="GIBaseInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
    </record>
    <enumeration name="Direction" c:type="GIDirection">
      <doc xml:space="preserve">The direction of a #GIArgInfo.</doc>
      <member name="in" value="0" c:identifier="GI_DIRECTION_IN">
        <doc xml:space="preserve">in argument.</doc>
      </member>
      <member name="out" value="1" c:identifier="GI_DIRECTION_OUT">
        <doc xml:space="preserve">out argument.</doc>
      </member>
      <member name="inout" value="2" c:identifier="GI_DIRECTION_INOUT">
        <doc xml:space="preserve">in and out argument.</doc>
      </member>
    </enumeration>
    <bitfield name="FieldInfoFlags" c:type="GIFieldInfoFlags">
      <doc xml:space="preserve">Flags for a #GIFieldInfo.</doc>
      <member name="readable" value="1" c:identifier="GI_FIELD_IS_READABLE">
        <doc xml:space="preserve">field is readable.</doc>
      </member>
      <member name="writable" value="2" c:identifier="GI_FIELD_IS_WRITABLE">
        <doc xml:space="preserve">field is writable.</doc>
      </member>
    </bitfield>
    <bitfield name="FunctionInfoFlags" c:type="GIFunctionInfoFlags">
      <doc xml:space="preserve">Flags for a #GIFunctionInfo struct.</doc>
      <member name="is_method" value="1" c:identifier="GI_FUNCTION_IS_METHOD">
        <doc xml:space="preserve">is a method.</doc>
      </member>
      <member name="is_constructor"
              value="2"
              c:identifier="GI_FUNCTION_IS_CONSTRUCTOR">
        <doc xml:space="preserve">is a constructor.</doc>
      </member>
      <member name="is_getter" value="4" c:identifier="GI_FUNCTION_IS_GETTER">
        <doc xml:space="preserve">is a getter of a #GIPropertyInfo.</doc>
      </member>
      <member name="is_setter" value="8" c:identifier="GI_FUNCTION_IS_SETTER">
        <doc xml:space="preserve">is a setter of a #GIPropertyInfo.</doc>
      </member>
      <member name="wraps_vfunc"
              value="16"
              c:identifier="GI_FUNCTION_WRAPS_VFUNC">
        <doc xml:space="preserve">represents a virtual function.</doc>
      </member>
      <member name="throws" value="32" c:identifier="GI_FUNCTION_THROWS">
        <doc xml:space="preserve">the function may throw an error.</doc>
      </member>
    </bitfield>
    <enumeration name="InfoType" c:type="GIInfoType">
      <doc xml:space="preserve">The type of a GIBaseInfo struct.</doc>
      <member name="invalid" value="0" c:identifier="GI_INFO_TYPE_INVALID">
        <doc xml:space="preserve">invalid type</doc>
      </member>
      <member name="function" value="1" c:identifier="GI_INFO_TYPE_FUNCTION">
        <doc xml:space="preserve">function, see #GIFunctionInfo</doc>
      </member>
      <member name="callback" value="2" c:identifier="GI_INFO_TYPE_CALLBACK">
        <doc xml:space="preserve">callback, see #GIFunctionInfo</doc>
      </member>
      <member name="struct" value="3" c:identifier="GI_INFO_TYPE_STRUCT">
        <doc xml:space="preserve">struct, see #GIStructInfo</doc>
      </member>
      <member name="boxed" value="4" c:identifier="GI_INFO_TYPE_BOXED">
        <doc xml:space="preserve">boxed, see #GIStructInfo or #GIUnionInfo</doc>
      </member>
      <member name="enum" value="5" c:identifier="GI_INFO_TYPE_ENUM">
        <doc xml:space="preserve">enum, see #GIEnumInfo</doc>
      </member>
      <member name="flags" value="6" c:identifier="GI_INFO_TYPE_FLAGS">
        <doc xml:space="preserve">flags, see #GIEnumInfo</doc>
      </member>
      <member name="object" value="7" c:identifier="GI_INFO_TYPE_OBJECT">
        <doc xml:space="preserve">object, see #GIObjectInfo</doc>
      </member>
      <member name="interface" value="8" c:identifier="GI_INFO_TYPE_INTERFACE">
        <doc xml:space="preserve">interface, see #GIInterfaceInfo</doc>
      </member>
      <member name="constant" value="9" c:identifier="GI_INFO_TYPE_CONSTANT">
        <doc xml:space="preserve">contant, see #GIConstantInfo</doc>
      </member>
      <member name="invalid_0"
              value="10"
              c:identifier="GI_INFO_TYPE_INVALID_0">
        <doc xml:space="preserve">deleted, used to be GI_INFO_TYPE_ERROR_DOMAIN.</doc>
      </member>
      <member name="union" value="11" c:identifier="GI_INFO_TYPE_UNION">
        <doc xml:space="preserve">union, see #GIUnionInfo</doc>
      </member>
      <member name="value" value="12" c:identifier="GI_INFO_TYPE_VALUE">
        <doc xml:space="preserve">enum value, see #GIValueInfo</doc>
      </member>
      <member name="signal" value="13" c:identifier="GI_INFO_TYPE_SIGNAL">
        <doc xml:space="preserve">signal, see #GISignalInfo</doc>
      </member>
      <member name="vfunc" value="14" c:identifier="GI_INFO_TYPE_VFUNC">
        <doc xml:space="preserve">virtual function, see #GIVFuncInfo</doc>
      </member>
      <member name="property" value="15" c:identifier="GI_INFO_TYPE_PROPERTY">
        <doc xml:space="preserve">GObject property, see #GIPropertyInfo</doc>
      </member>
      <member name="field" value="16" c:identifier="GI_INFO_TYPE_FIELD">
        <doc xml:space="preserve">struct or union field, see #GIFieldInfo</doc>
      </member>
      <member name="arg" value="17" c:identifier="GI_INFO_TYPE_ARG">
        <doc xml:space="preserve">argument of a function or callback, see #GIArgInfo</doc>
      </member>
      <member name="type" value="18" c:identifier="GI_INFO_TYPE_TYPE">
        <doc xml:space="preserve">type information, see #GITypeInfo</doc>
      </member>
      <member name="unresolved"
              value="19"
              c:identifier="GI_INFO_TYPE_UNRESOLVED">
        <doc xml:space="preserve">unresolved type, a type which is not present in
  the typelib, or any of its dependencies.</doc>
      </member>
    </enumeration>
    <callback name="ObjectInfoGetValueFunction"
              c:type="GIObjectInfoGetValueFunction"
              introspectable="0">
      <doc xml:space="preserve">Extract an object instance out of @value</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the object instance</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="const GValue*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ObjectInfoRefFunction"
              c:type="GIObjectInfoRefFunction"
              introspectable="0">
      <doc xml:space="preserve">Increases the reference count of an object instance.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">the object instance</doc>
        <type name="gpointer" c:type="void*"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">object instance pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ObjectInfoSetValueFunction"
              c:type="GIObjectInfoSetValueFunction"
              introspectable="0">
      <doc xml:space="preserve">Update @value and attach the object instance pointer @object to it.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GValue</doc>
          <type name="GObject.Value" c:type="GValue*"/>
        </parameter>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">object instance pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <callback name="ObjectInfoUnrefFunction"
              c:type="GIObjectInfoUnrefFunction"
              introspectable="0">
      <doc xml:space="preserve">Decreases the reference count of an object instance.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="object"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">object instance pointer</doc>
          <type name="gpointer" c:type="void*"/>
        </parameter>
      </parameters>
    </callback>
    <class name="Repository"
           c:symbol-prefix="irepository"
           c:type="GIRepository"
           parent="GObject.Object"
           glib:type-name="GIRepository"
           glib:get-type="g_irepository_get_type"
           glib:type-struct="RepositoryClass">
      <doc xml:space="preserve">#GIRepository is used to manage repositories of namespaces. Namespaces
are represented on disk by type libraries (.typelib files).</doc>
      <function name="dump" c:identifier="g_irepository_dump" throws="1">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <parameter name="arg" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="error_quark" c:identifier="g_irepository_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
      <function name="get_default" c:identifier="g_irepository_get_default">
        <doc xml:space="preserve">Returns the singleton process-global default #GIRepository. It is
not currently supported to have multiple repositories in a
particular process, but this function is provided in the unlikely
eventuality that it would become possible, and as a convenience for
higher level language bindings to conform to the GObject method
call conventions.

All methods on #GIRepository also accept %NULL as an instance
parameter to mean this default repository, which is usually more
convenient for C.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">The global singleton #GIRepository</doc>
          <type name="Repository" c:type="GIRepository*"/>
        </return-value>
      </function>
      <function name="get_option_group"
                c:identifier="g_irepository_get_option_group"
                introspectable="0">
        <doc xml:space="preserve">Obtain the option group for girepository, it's used
by the dumper and for programs that wants to provide
introspection information</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the option group</doc>
          <type name="GLib.OptionGroup" c:type="GOptionGroup*"/>
        </return-value>
      </function>
      <function name="get_search_path"
                c:identifier="g_irepository_get_search_path">
        <doc xml:space="preserve">Returns the current search path #GIRepository will use when loading
typelib files. The list is internal to #GIRespository and should not
be freed, nor should its string elements.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">#GSList of strings</doc>
          <type name="GLib.SList" c:type="GSList*">
            <type name="filename"/>
          </type>
        </return-value>
      </function>
      <function name="prepend_library_path"
                c:identifier="g_irepository_prepend_library_path">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="directory" transfer-ownership="none">
            <type name="utf8" c:type="const char*"/>
          </parameter>
        </parameters>
      </function>
      <function name="prepend_search_path"
                c:identifier="g_irepository_prepend_search_path">
        <doc xml:space="preserve">Prepends @directory to the typelib search path.
See g_irepository_get_search_path().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="directory" transfer-ownership="none">
            <doc xml:space="preserve">directory name to prepend to the typelib
  search path</doc>
            <type name="filename" c:type="char*"/>
          </parameter>
        </parameters>
      </function>
      <method name="enumerate_versions"
              c:identifier="g_irepository_enumerate_versions">
        <doc xml:space="preserve">Obtain an unordered list of versions (either currently loaded or
available) for @namespace_ in this @repository.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">the array of versions.</doc>
          <type name="GLib.List" c:type="GList*">
            <type name="utf8"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">GI namespace, e.g. "Gtk"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_by_error_domain"
              c:identifier="g_irepository_find_by_error_domain"
              version="1.29.17">
        <doc xml:space="preserve">Searches for the enum type corresponding to the given #GError
domain. Before calling this function for a particular namespace,
you must call g_irepository_require() once to load the namespace, or
otherwise ensure the namespace has already been loaded.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GIEnumInfo representing metadata about @domain's
enum type, or %NULL</doc>
          <type name="EnumInfo" c:type="GIEnumInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="domain" transfer-ownership="none">
            <doc xml:space="preserve">a #GError domain</doc>
            <type name="GLib.Quark" c:type="GQuark"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_by_gtype" c:identifier="g_irepository_find_by_gtype">
        <doc xml:space="preserve">Searches all loaded namespaces for a particular #GType.  Note that
in order to locate the metadata, the namespace corresponding to
the type must first have been loaded.  There is currently no
mechanism for determining the namespace which corresponds to an
arbitrary GType - thus, this function will operate most reliably
when you know the GType to originate from be from a loaded namespace.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GIBaseInfo representing metadata about @type, or %NULL</doc>
          <type name="BaseInfo" c:type="GIBaseInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="gtype" transfer-ownership="none">
            <doc xml:space="preserve">GType to search for</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="find_by_name" c:identifier="g_irepository_find_by_name">
        <doc xml:space="preserve">Searches for a particular entry in a namespace.  Before calling
this function for a particular namespace, you must call
g_irepository_require() once to load the namespace, or otherwise
ensure the namespace has already been loaded.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GIBaseInfo representing metadata about @name, or %NULL</doc>
          <type name="BaseInfo" c:type="GIBaseInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace which will be searched</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="name" transfer-ownership="none">
            <doc xml:space="preserve">Entry name to find</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_c_prefix" c:identifier="g_irepository_get_c_prefix">
        <doc xml:space="preserve">This function returns the "C prefix", or the C level namespace
associated with the given introspection namespace.  Each C symbol
starts with this prefix, as well each #GType in the library.

Note: The namespace must have already been loaded using a function
such as g_irepository_require() before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">C namespace prefix, or %NULL if none associated</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace to inspect</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_dependencies"
              c:identifier="g_irepository_get_dependencies">
        <doc xml:space="preserve">Return an array of all (transitive) versioned dependencies for
@namespace_. Returned strings are of the form
&lt;code&gt;namespace-version&lt;/code&gt;.

Note: @namespace_ must have already been loaded using a function
such as g_irepository_require() before calling this function.

To get only the immediate dependencies for @namespace_, use
g_irepository_get_immediate_dependencies().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Zero-terminated string array of all versioned
  dependencies</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace of interest</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_immediate_dependencies"
              c:identifier="g_irepository_get_immediate_dependencies"
              version="1.44">
        <doc xml:space="preserve">Return an array of the immediate versioned dependencies for @namespace_.
Returned strings are of the form &lt;code&gt;namespace-version&lt;/code&gt;.

Note: @namespace_ must have already been loaded using a function
such as g_irepository_require() before calling this function.

To get the transitive closure of dependencies for @namespace_, use
g_irepository_get_dependencies().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">Zero-terminated string array of immediate versioned
  dependencies</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace of interest</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_info" c:identifier="g_irepository_get_info">
        <doc xml:space="preserve">This function returns a particular metadata entry in the
given namespace @namespace_.  The namespace must have
already been loaded before calling this function.
See g_irepository_get_n_infos() to find the maximum number of
entries.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">#GIBaseInfo containing metadata</doc>
          <type name="BaseInfo" c:type="GIBaseInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace to inspect</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="index" transfer-ownership="none">
            <doc xml:space="preserve">0-based offset into namespace metadata for entry</doc>
            <type name="gint" c:type="gint"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_loaded_namespaces"
              c:identifier="g_irepository_get_loaded_namespaces">
        <doc xml:space="preserve">Return the list of currently loaded namespaces.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">List of namespaces</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_n_infos" c:identifier="g_irepository_get_n_infos">
        <doc xml:space="preserve">This function returns the number of metadata entries in
given namespace @namespace_.  The namespace must have
already been loaded before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">number of metadata entries</doc>
          <type name="gint" c:type="gint"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace to inspect</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_shared_library"
              c:identifier="g_irepository_get_shared_library">
        <doc xml:space="preserve">This function returns a comma-separated list of paths to the
shared C libraries associated with the given namespace @namespace_.
There may be no shared library path associated, in which case this
function will return %NULL.

Note: The namespace must have already been loaded using a function
such as g_irepository_require() before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Comma-separated list of paths to shared libraries,
  or %NULL if none are associated</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace to inspect</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_typelib_path"
              c:identifier="g_irepository_get_typelib_path">
        <doc xml:space="preserve">If namespace @namespace_ is loaded, return the full path to the
.typelib file it was loaded from.  If the typelib for
namespace @namespace_ was included in a shared library, return
the special string "&amp;lt;builtin&amp;gt;".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Filesystem path (or $lt;builtin$gt;) if successful, %NULL if namespace is not loaded</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">GI namespace to use, e.g. "Gtk"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_version" c:identifier="g_irepository_get_version">
        <doc xml:space="preserve">This function returns the loaded version associated with the given
namespace @namespace_.

Note: The namespace must have already been loaded using a function
such as g_irepository_require() before calling this function.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">Loaded version</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace to inspect</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_registered" c:identifier="g_irepository_is_registered">
        <doc xml:space="preserve">Check whether a particular namespace (and optionally, a specific
version thereof) is currently loaded.  This function is likely to
only be useful in unusual circumstances; in order to act upon
metadata in the namespace, you should call g_irepository_require()
instead which will ensure the namespace is loaded, and return as
quickly as this function will if it has already been loaded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if namespace-version is loaded, %FALSE otherwise</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">Namespace of interest</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="version"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Required version, may be %NULL for latest</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="load_typelib"
              c:identifier="g_irepository_load_typelib"
              throws="1">
        <doc xml:space="preserve">TODO</doc>
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const char*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="typelib" transfer-ownership="none">
            <doc xml:space="preserve">TODO</doc>
            <type name="Typelib" c:type="GITypelib*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">TODO</doc>
            <type name="RepositoryLoadFlags" c:type="GIRepositoryLoadFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="require" c:identifier="g_irepository_require" throws="1">
        <doc xml:space="preserve">Force the namespace @namespace_ to be loaded if it isn't already.
If @namespace_ is not loaded, this function will search for a
".typelib" file using the repository search path.  In addition, a
version @version of namespace may be specified.  If @version is
not specified, the latest will be used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the #GITypelib if successful, %NULL otherwise</doc>
          <type name="Typelib" c:type="GITypelib*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">GI namespace to use, e.g. "Gtk"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="version"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Version of namespace, may be %NULL for latest</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Set of %GIRepositoryLoadFlags, may be 0</doc>
            <type name="RepositoryLoadFlags" c:type="GIRepositoryLoadFlags"/>
          </parameter>
        </parameters>
      </method>
      <method name="require_private"
              c:identifier="g_irepository_require_private"
              throws="1">
        <doc xml:space="preserve">Force the namespace @namespace_ to be loaded if it isn't already.
If @namespace_ is not loaded, this function will search for a
".typelib" file within the private directory only. In addition, a
version @version of namespace should be specified.  If @version is
not specified, the latest will be used.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a pointer to the #GITypelib if successful, %NULL otherwise</doc>
          <type name="Typelib" c:type="GITypelib*"/>
        </return-value>
        <parameters>
          <instance-parameter name="repository"
                              transfer-ownership="none"
                              nullable="1"
                              allow-none="1">
            <doc xml:space="preserve">A #GIRepository or %NULL for the singleton
  process-global default #GIRepository</doc>
            <type name="Repository" c:type="GIRepository*"/>
          </instance-parameter>
          <parameter name="typelib_dir" transfer-ownership="none">
            <doc xml:space="preserve">Private directory where to find the requested typelib</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="namespace_" transfer-ownership="none">
            <doc xml:space="preserve">GI namespace to use, e.g. "Gtk"</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="version"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Version of namespace, may be %NULL for latest</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Set of %GIRepositoryLoadFlags, may be 0</doc>
            <type name="RepositoryLoadFlags" c:type="GIRepositoryLoadFlags"/>
          </parameter>
        </parameters>
      </method>
      <field name="parent" readable="0" private="1">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="RepositoryPrivate" c:type="GIRepositoryPrivate*"/>
      </field>
    </class>
    <record name="RepositoryClass"
            c:type="GIRepositoryClass"
            glib:is-gtype-struct-for="Repository">
      <field name="parent" readable="0" private="1">
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
    </record>
    <enumeration name="RepositoryError" c:type="GIRepositoryError">
      <doc xml:space="preserve">An error code used with #G_IREPOSITORY_ERROR in a #GError returned
from a #GIRepository routine.</doc>
      <member name="typelib_not_found"
              value="0"
              c:identifier="G_IREPOSITORY_ERROR_TYPELIB_NOT_FOUND">
        <doc xml:space="preserve">the typelib could not be found.</doc>
      </member>
      <member name="namespace_mismatch"
              value="1"
              c:identifier="G_IREPOSITORY_ERROR_NAMESPACE_MISMATCH">
        <doc xml:space="preserve">the namespace does not match the
  requested namespace.</doc>
      </member>
      <member name="namespace_version_conflict"
              value="2"
              c:identifier="G_IREPOSITORY_ERROR_NAMESPACE_VERSION_CONFLICT">
        <doc xml:space="preserve">the version of the
  typelib does not match the requested version.</doc>
      </member>
      <member name="library_not_found"
              value="3"
              c:identifier="G_IREPOSITORY_ERROR_LIBRARY_NOT_FOUND">
        <doc xml:space="preserve">the library used by the typelib
  could not be found.</doc>
      </member>
    </enumeration>
    <bitfield name="RepositoryLoadFlags" c:type="GIRepositoryLoadFlags">
      <doc xml:space="preserve">Flags that control how a typelib is loaded.</doc>
      <member name="irepository_load_flag_lazy"
              value="1"
              c:identifier="G_IREPOSITORY_LOAD_FLAG_LAZY">
        <doc xml:space="preserve">Lazily load the typelib.</doc>
      </member>
    </bitfield>
    <record name="RepositoryPrivate"
            c:type="GIRepositoryPrivate"
            disguised="1">
    </record>
    <enumeration name="ScopeType" c:type="GIScopeType">
      <doc xml:space="preserve">Scope type of a #GIArgInfo representing callback, determines how the
callback is invoked and is used to decided when the invoke structs
can be freed.</doc>
      <member name="invalid" value="0" c:identifier="GI_SCOPE_TYPE_INVALID">
        <doc xml:space="preserve">The argument is not of callback type.</doc>
      </member>
      <member name="call" value="1" c:identifier="GI_SCOPE_TYPE_CALL">
        <doc xml:space="preserve">The callback and associated user_data is only
used during the call to this function.</doc>
      </member>
      <member name="async" value="2" c:identifier="GI_SCOPE_TYPE_ASYNC">
        <doc xml:space="preserve">The callback and associated user_data is
only used until the callback is invoked, and the callback.
is invoked always exactly once.</doc>
      </member>
      <member name="notified" value="3" c:identifier="GI_SCOPE_TYPE_NOTIFIED">
        <doc xml:space="preserve">The callback and and associated
user_data is used until the caller is notfied via the destroy_notify.</doc>
      </member>
    </enumeration>
    <enumeration name="Transfer" c:type="GITransfer">
      <doc xml:space="preserve">The transfer is the exchange of data between two parts, from the callee to
the caller. The callee is either a function/method/signal or an
object/interface where a property is defined. The caller is the side
accessing a property or calling a function.
#GITransfer specifies who's responsible for freeing the resources after the
ownership transfer is complete. In case of a containing type such as a list,
an array or a hash table the container itself is specified differently from
the items within the container itself. Each container is freed differently,
check the documentation for the types themselves for information on how to
free them.</doc>
      <member name="nothing" value="0" c:identifier="GI_TRANSFER_NOTHING">
        <doc xml:space="preserve">transfer nothing from the callee (function or the type
instance the property belongs to) to the caller. The callee retains the
ownership of the transfer and the caller doesn't need to do anything to free
up the resources of this transfer.</doc>
      </member>
      <member name="container" value="1" c:identifier="GI_TRANSFER_CONTAINER">
        <doc xml:space="preserve">transfer the container (list, array, hash table) from
the callee to the caller. The callee retains the ownership of the individual
items in the container and the caller has to free up the container resources
(g_list_free()/g_hash_table_destroy() etc) of this transfer.</doc>
      </member>
      <member name="everything"
              value="2"
              c:identifier="GI_TRANSFER_EVERYTHING">
        <doc xml:space="preserve">transfer everything, eg the container and its
contents from the callee to the caller. This is the case when the callee
creates a copy of all the data it returns. The caller is responsible for
cleaning up the container and item resources of this transfer.</doc>
      </member>
    </enumeration>
    <enumeration name="TypeTag" c:type="GITypeTag">
      <doc xml:space="preserve">The type tag of a #GITypeInfo.</doc>
      <member name="void" value="0" c:identifier="GI_TYPE_TAG_VOID">
        <doc xml:space="preserve">void</doc>
      </member>
      <member name="boolean" value="1" c:identifier="GI_TYPE_TAG_BOOLEAN">
        <doc xml:space="preserve">boolean</doc>
      </member>
      <member name="int8" value="2" c:identifier="GI_TYPE_TAG_INT8">
        <doc xml:space="preserve">8-bit signed integer</doc>
      </member>
      <member name="uint8" value="3" c:identifier="GI_TYPE_TAG_UINT8">
        <doc xml:space="preserve">8-bit unsigned integer</doc>
      </member>
      <member name="int16" value="4" c:identifier="GI_TYPE_TAG_INT16">
        <doc xml:space="preserve">16-bit signed integer</doc>
      </member>
      <member name="uint16" value="5" c:identifier="GI_TYPE_TAG_UINT16">
        <doc xml:space="preserve">16-bit unsigned integer</doc>
      </member>
      <member name="int32" value="6" c:identifier="GI_TYPE_TAG_INT32">
        <doc xml:space="preserve">32-bit signed integer</doc>
      </member>
      <member name="uint32" value="7" c:identifier="GI_TYPE_TAG_UINT32">
        <doc xml:space="preserve">32-bit unsigned integer</doc>
      </member>
      <member name="int64" value="8" c:identifier="GI_TYPE_TAG_INT64">
        <doc xml:space="preserve">64-bit signed integer</doc>
      </member>
      <member name="uint64" value="9" c:identifier="GI_TYPE_TAG_UINT64">
        <doc xml:space="preserve">64-bit unsigned integer</doc>
      </member>
      <member name="float" value="10" c:identifier="GI_TYPE_TAG_FLOAT">
        <doc xml:space="preserve">float</doc>
      </member>
      <member name="double" value="11" c:identifier="GI_TYPE_TAG_DOUBLE">
        <doc xml:space="preserve">double floating point</doc>
      </member>
      <member name="gtype" value="12" c:identifier="GI_TYPE_TAG_GTYPE">
        <doc xml:space="preserve">a #GType</doc>
      </member>
      <member name="utf8" value="13" c:identifier="GI_TYPE_TAG_UTF8">
        <doc xml:space="preserve">a UTF-8 encoded string</doc>
      </member>
      <member name="filename" value="14" c:identifier="GI_TYPE_TAG_FILENAME">
        <doc xml:space="preserve">a filename, encoded in the same encoding
  as the native filesystem is using.</doc>
      </member>
      <member name="array" value="15" c:identifier="GI_TYPE_TAG_ARRAY">
        <doc xml:space="preserve">an array</doc>
      </member>
      <member name="interface" value="16" c:identifier="GI_TYPE_TAG_INTERFACE">
        <doc xml:space="preserve">an extended interface object</doc>
      </member>
      <member name="glist" value="17" c:identifier="GI_TYPE_TAG_GLIST">
        <doc xml:space="preserve">a #GList</doc>
      </member>
      <member name="gslist" value="18" c:identifier="GI_TYPE_TAG_GSLIST">
        <doc xml:space="preserve">a #GSList</doc>
      </member>
      <member name="ghash" value="19" c:identifier="GI_TYPE_TAG_GHASH">
        <doc xml:space="preserve">a #GHashTable</doc>
      </member>
      <member name="error" value="20" c:identifier="GI_TYPE_TAG_ERROR">
        <doc xml:space="preserve">a #GError</doc>
      </member>
      <member name="unichar" value="21" c:identifier="GI_TYPE_TAG_UNICHAR">
        <doc xml:space="preserve">Unicode character</doc>
      </member>
    </enumeration>
    <record name="Typelib" c:type="GITypelib" disguised="1">
      <doc xml:space="preserve">TODO</doc>
      <method name="free" c:identifier="g_typelib_free">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="typelib" transfer-ownership="none">
            <type name="Typelib" c:type="GITypelib*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_namespace" c:identifier="g_typelib_get_namespace">
        <return-value transfer-ownership="none">
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="typelib" transfer-ownership="none">
            <type name="Typelib" c:type="GITypelib*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="symbol" c:identifier="g_typelib_symbol">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="typelib" transfer-ownership="none">
            <type name="Typelib" c:type="GITypelib*"/>
          </instance-parameter>
          <parameter name="symbol_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="symbol"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <type name="gpointer" c:type="gpointer*"/>
          </parameter>
        </parameters>
      </method>
      <function name="new_from_const_memory"
                c:identifier="g_typelib_new_from_const_memory"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="Typelib" c:type="GITypelib*"/>
        </return-value>
        <parameters>
          <parameter name="memory" transfer-ownership="none">
            <type name="guint8" c:type="const guint8*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_mapped_file"
                c:identifier="g_typelib_new_from_mapped_file"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="Typelib" c:type="GITypelib*"/>
        </return-value>
        <parameters>
          <parameter name="mfile" transfer-ownership="none">
            <type name="GLib.MappedFile" c:type="GMappedFile*"/>
          </parameter>
        </parameters>
      </function>
      <function name="new_from_memory"
                c:identifier="g_typelib_new_from_memory"
                introspectable="0"
                throws="1">
        <return-value>
          <type name="Typelib" c:type="GITypelib*"/>
        </return-value>
        <parameters>
          <parameter name="memory" transfer-ownership="none">
            <type name="guint8" c:type="guint8*"/>
          </parameter>
          <parameter name="len" transfer-ownership="none">
            <type name="gsize" c:type="gsize"/>
          </parameter>
        </parameters>
      </function>
    </record>
    <record name="UnresolvedInfo" c:type="GIUnresolvedInfo" disguised="1">
      <doc xml:space="preserve">Represents a unresolved type in a typelib.</doc>
    </record>
    <bitfield name="VFuncInfoFlags" c:type="GIVFuncInfoFlags">
      <doc xml:space="preserve">Flags of a #GIVFuncInfo struct.</doc>
      <member name="must_chain_up"
              value="1"
              c:identifier="GI_VFUNC_MUST_CHAIN_UP">
        <doc xml:space="preserve">chains up to the parent type</doc>
      </member>
      <member name="must_override"
              value="2"
              c:identifier="GI_VFUNC_MUST_OVERRIDE">
        <doc xml:space="preserve">overrides</doc>
      </member>
      <member name="must_not_override"
              value="4"
              c:identifier="GI_VFUNC_MUST_NOT_OVERRIDE">
        <doc xml:space="preserve">does not override</doc>
      </member>
      <member name="throws" value="8" c:identifier="GI_VFUNC_THROWS">
        <doc xml:space="preserve">Includes a #GError</doc>
      </member>
    </bitfield>
    <function name="arg_info_get_closure"
              c:identifier="g_arg_info_get_closure">
      <doc xml:space="preserve">Obtain the index of the user data argument. This is only valid
for arguments which are callbacks.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">index of the user data argument or -1 if there is none</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_get_destroy"
              c:identifier="g_arg_info_get_destroy">
      <doc xml:space="preserve">Obtains the index of the #GDestroyNotify argument. This is only valid
for arguments which are callbacks.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">index of the #GDestroyNotify argument or -1 if there is none</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_get_direction"
              c:identifier="g_arg_info_get_direction">
      <doc xml:space="preserve">Obtain the direction of the argument. Check #GIDirection for possible
direction values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the direction</doc>
        <type name="Direction" c:type="GIDirection"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_get_ownership_transfer"
              c:identifier="g_arg_info_get_ownership_transfer">
      <doc xml:space="preserve">Obtain the ownership transfer for this argument.
#GITransfer contains a list of possible values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the transfer</doc>
        <type name="Transfer" c:type="GITransfer"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_get_scope" c:identifier="g_arg_info_get_scope">
      <doc xml:space="preserve">Obtain the scope type for this argument. The scope type explains
how a callback is going to be invoked, most importantly when
the resources required to invoke it can be freed.
#GIScopeType contains a list of possible values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the scope type</doc>
        <type name="ScopeType" c:type="GIScopeType"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_get_type" c:identifier="g_arg_info_get_type">
      <doc xml:space="preserve">Obtain the type information for @info.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GITypeInfo holding the type
  information for @info, free it with g_base_info_unref()
  when done.</doc>
        <type name="TypeInfo" c:type="GITypeInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_is_caller_allocates"
              c:identifier="g_arg_info_is_caller_allocates">
      <doc xml:space="preserve">Obtain if the argument is a pointer to a struct or object that will
receive an output of a function.  The default assumption for
%GI_DIRECTION_OUT arguments which have allocation is that the
callee allocates; if this is %TRUE, then the caller must allocate.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if caller is required to have allocated the argument</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_is_optional"
              c:identifier="g_arg_info_is_optional">
      <doc xml:space="preserve">Obtain if the argument is optional.  For 'out' arguments this means
that you can pass %NULL in order to ignore the result.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if it is an optional argument</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_is_return_value"
              c:identifier="g_arg_info_is_return_value">
      <doc xml:space="preserve">Obtain if the argument is a return value. It can either be a
parameter or a return value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if it is a return value</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_is_skip"
              c:identifier="g_arg_info_is_skip"
              version="1.29.0">
      <doc xml:space="preserve">Obtain if an argument is only useful in C.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if argument is only useful in C.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_load_type" c:identifier="g_arg_info_load_type">
      <doc xml:space="preserve">Obtain information about a the type of given argument @info; this
function is a variant of g_arg_info_get_type() designed for stack
allocation.

The initialized @type must not be referenced after @info is deallocated.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
        <parameter name="type"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">Initialized with information about type of @info</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="arg_info_may_be_null"
              c:identifier="g_arg_info_may_be_null">
      <doc xml:space="preserve">Obtain if the type of the argument includes the possibility of %NULL.
For 'in' values this means that %NULL is a valid value.  For 'out'
values, this means that %NULL may be returned.

See also g_arg_info_is_optional().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the value may be %NULL</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgInfo</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_can_throw_gerror"
              c:identifier="g_callable_info_can_throw_gerror"
              version="1.34">
      <doc xml:space="preserve">TODO</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if this #GICallableInfo can throw a #GError</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_get_arg"
              c:identifier="g_callable_info_get_arg">
      <doc xml:space="preserve">Obtain information about a particular argument of this callable.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIArgInfo. Free it with
g_base_info_unref() when done.</doc>
        <type name="ArgInfo" c:type="GIArgInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the argument index to fetch</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_get_caller_owns"
              c:identifier="g_callable_info_get_caller_owns">
      <doc xml:space="preserve">See whether the caller owns the return value of this callable.
#GITransfer contains a list of possible transfer values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the transfer mode for the return value of the callable</doc>
        <type name="Transfer" c:type="GITransfer"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_get_instance_ownership_transfer"
              c:identifier="g_callable_info_get_instance_ownership_transfer">
      <doc xml:space="preserve">Obtains the ownership transfer for the instance argument.
#GITransfer contains a list of possible transfer values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the transfer mode of the instance argument</doc>
        <type name="Transfer" c:type="GITransfer"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_get_n_args"
              c:identifier="g_callable_info_get_n_args">
      <doc xml:space="preserve">Obtain the number of arguments (both IN and OUT) for this callable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The number of arguments this callable expects.</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_get_return_attribute"
              c:identifier="g_callable_info_get_return_attribute">
      <doc xml:space="preserve">Retrieve an arbitrary attribute associated with the return value.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">The value of the attribute, or %NULL if no such attribute exists</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a freeform string naming an attribute</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_get_return_type"
              c:identifier="g_callable_info_get_return_type">
      <doc xml:space="preserve">Obtain the return type of a callable item as a #GITypeInfo.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GITypeInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="TypeInfo" c:type="GITypeInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_invoke"
              c:identifier="g_callable_info_invoke"
              throws="1">
      <doc xml:space="preserve">TODO</doc>
      <return-value transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
        <parameter name="function"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">TODO</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="in_args" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <array length="3" zero-terminated="0" c:type="GIArgument*">
            <type name="Argument" c:type="GIArgument"/>
          </array>
        </parameter>
        <parameter name="n_in_args" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="out_args" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <array length="5" zero-terminated="0" c:type="GIArgument*">
            <type name="Argument" c:type="GIArgument"/>
          </array>
        </parameter>
        <parameter name="n_out_args" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="Argument" c:type="GIArgument*"/>
        </parameter>
        <parameter name="is_method" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
        <parameter name="throws" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_is_method"
              c:identifier="g_callable_info_is_method"
              version="1.34">
      <doc xml:space="preserve">Determines if the callable info is a method. For #GIVFuncInfo&lt;!-- --&gt;s,
#GICallbackInfo&lt;!-- --&gt;s, and #GISignalInfo&lt;!-- --&gt;s,
this is always true. Otherwise, this looks at the %GI_FUNCTION_IS_METHOD
flag on the #GIFunctionInfo.

Concretely, this function returns whether g_callable_info_get_n_args()
matches the number of arguments in the raw C method. For methods, there
is one more C argument than is exposed by introspection: the "self"
or "this" object.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if @info is a method, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_iterate_return_attributes"
              c:identifier="g_callable_info_iterate_return_attributes">
      <doc xml:space="preserve">Iterate over all attributes associated with the return value.  The
iterator structure is typically stack allocated, and must have its
first member initialized to %NULL.

Both the @name and @value should be treated as constants
and must not be freed.

See g_base_info_iterate_attributes() for an example of how to use a
similar API.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if there are more attributes</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
        <parameter name="iterator"
                   direction="inout"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">a #GIAttributeIter structure, must be initialized; see below</doc>
          <type name="AttributeIter" c:type="GIAttributeIter*"/>
        </parameter>
        <parameter name="name"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">Returned name, must not be freed</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
        <parameter name="value"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="none">
          <doc xml:space="preserve">Returned name, must not be freed</doc>
          <type name="utf8" c:type="char**"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_load_arg"
              c:identifier="g_callable_info_load_arg">
      <doc xml:space="preserve">Obtain information about a particular argument of this callable; this
function is a variant of g_callable_info_get_arg() designed for stack
allocation.

The initialized @arg must not be referenced after @info is deallocated.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">the argument index to fetch</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="arg"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">Initialize with argument number @n</doc>
          <type name="ArgInfo" c:type="GIArgInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_load_return_type"
              c:identifier="g_callable_info_load_return_type">
      <doc xml:space="preserve">Obtain information about a return value of callable; this
function is a variant of g_callable_info_get_return_type() designed for stack
allocation.

The initialized @type must not be referenced after @info is deallocated.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
        <parameter name="type"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">Initialized with return type of @info</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_may_return_null"
              c:identifier="g_callable_info_may_return_null">
      <doc xml:space="preserve">See if a callable could return %NULL.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if callable could return %NULL</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="callable_info_skip_return"
              c:identifier="g_callable_info_skip_return">
      <doc xml:space="preserve">See if a callable's return value is only useful in C.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if return value is only useful in C.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GICallableInfo</doc>
          <type name="CallableInfo" c:type="GICallableInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="constant_info_free_value"
              c:identifier="g_constant_info_free_value"
              version="1.30.1"
              introspectable="0">
      <doc xml:space="preserve">Free the value returned from g_constant_info_get_value().</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIConstantInfo</doc>
          <type name="ConstantInfo" c:type="GIConstantInfo*"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">the argument</doc>
          <type name="Argument" c:type="GIArgument*"/>
        </parameter>
      </parameters>
    </function>
    <function name="constant_info_get_type"
              c:identifier="g_constant_info_get_type">
      <doc xml:space="preserve">Obtain the type of the constant as a #GITypeInfo.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GITypeInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="TypeInfo" c:type="GITypeInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIConstantInfo</doc>
          <type name="ConstantInfo" c:type="GIConstantInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="constant_info_get_value"
              c:identifier="g_constant_info_get_value"
              introspectable="0">
      <doc xml:space="preserve">Obtain the value associated with the #GIConstantInfo and store it in the
@value parameter. @argument needs to be allocated before passing it in.
The size of the constant value stored in @argument will be returned.
Free the value with g_constant_info_free_value().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">size of the constant</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIConstantInfo</doc>
          <type name="ConstantInfo" c:type="GIConstantInfo*"/>
        </parameter>
        <parameter name="value"
                   direction="out"
                   caller-allocates="1"
                   transfer-ownership="none">
          <doc xml:space="preserve">an argument</doc>
          <type name="Argument" c:type="GIArgument*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_info_get_error_domain"
              c:identifier="g_enum_info_get_error_domain"
              version="1.29.17">
      <doc xml:space="preserve">Obtain the string form of the quark for the error domain associated with
this enum, if any.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the string form of the error domain associated
with this enum, or %NULL.</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIEnumInfo</doc>
          <type name="EnumInfo" c:type="GIEnumInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_info_get_method"
              c:identifier="g_enum_info_get_method"
              version="1.29.17">
      <doc xml:space="preserve">Obtain an enum type method at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIEnumInfo</doc>
          <type name="EnumInfo" c:type="GIEnumInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of method to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_info_get_n_methods"
              c:identifier="g_enum_info_get_n_methods"
              version="1.29.17">
      <doc xml:space="preserve">Obtain the number of methods that this enum type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of methods</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIEnumInfo</doc>
          <type name="EnumInfo" c:type="GIEnumInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_info_get_n_values"
              c:identifier="g_enum_info_get_n_values">
      <doc xml:space="preserve">Obtain the number of values this enumeration contains.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the number of enumeration values</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIEnumInfo</doc>
          <type name="EnumInfo" c:type="GIEnumInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_info_get_storage_type"
              c:identifier="g_enum_info_get_storage_type">
      <doc xml:space="preserve">Obtain the tag of the type used for the enum in the C ABI. This will
will be a signed or unsigned integral type.

Note that in the current implementation the width of the type is
computed correctly, but the signed or unsigned nature of the type
may not match the sign of the type used by the C compiler.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the storage type for the enumeration</doc>
        <type name="TypeTag" c:type="GITypeTag"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIEnumInfo</doc>
          <type name="EnumInfo" c:type="GIEnumInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="enum_info_get_value" c:identifier="g_enum_info_get_value">
      <doc xml:space="preserve">Obtain a value for this enumeration.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the enumeration value or %NULL if type tag is wrong,
free the struct with g_base_info_unref() when done.</doc>
        <type name="ValueInfo" c:type="GIValueInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIEnumInfo</doc>
          <type name="EnumInfo" c:type="GIEnumInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of value to fetch</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="field_info_get_field"
              c:identifier="g_field_info_get_field"
              introspectable="0">
      <doc xml:space="preserve">Reads a field identified by a #GIFieldInfo from a C structure or
union.  This only handles fields of simple C types. It will fail
for a field of a composite type like a nested structure or union
even if that is actually readable.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if reading the field succeeded, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="field_info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFieldInfo</doc>
          <type name="FieldInfo" c:type="GIFieldInfo*"/>
        </parameter>
        <parameter name="mem"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to a block of memory representing a C structure or union</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgument into which to store the value retrieved</doc>
          <type name="Argument" c:type="GIArgument*"/>
        </parameter>
      </parameters>
    </function>
    <function name="field_info_get_flags"
              c:identifier="g_field_info_get_flags">
      <doc xml:space="preserve">Obtain the flags for this #GIFieldInfo. See #GIFieldInfoFlags for possible
flag values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the flags</doc>
        <type name="FieldInfoFlags" c:type="GIFieldInfoFlags"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFieldInfo</doc>
          <type name="FieldInfo" c:type="GIFieldInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="field_info_get_offset"
              c:identifier="g_field_info_get_offset">
      <doc xml:space="preserve">Obtain the offset in bits of the field member, this is relative
to the beginning of the struct or union.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the field offset</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFieldInfo</doc>
          <type name="FieldInfo" c:type="GIFieldInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="field_info_get_size" c:identifier="g_field_info_get_size">
      <doc xml:space="preserve">Obtain the size in bits of the field member, this is how
much space you need to allocate to store the field.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the field size</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFieldInfo</doc>
          <type name="FieldInfo" c:type="GIFieldInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="field_info_get_type" c:identifier="g_field_info_get_type">
      <doc xml:space="preserve">Obtain the type of a field as a #GITypeInfo.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GITypeInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="TypeInfo" c:type="GITypeInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFieldInfo</doc>
          <type name="FieldInfo" c:type="GIFieldInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="field_info_set_field"
              c:identifier="g_field_info_set_field"
              introspectable="0">
      <doc xml:space="preserve">Writes a field identified by a #GIFieldInfo to a C structure or
union.  This only handles fields of simple C types. It will fail
for a field of a composite type like a nested structure or union
even if that is actually writable. Note also that that it will refuse
to write fields where memory management would by required. A field
with a type such as 'char *' must be set with a setter function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if writing the field succeeded, otherwise %FALSE</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="field_info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFieldInfo</doc>
          <type name="FieldInfo" c:type="GIFieldInfo*"/>
        </parameter>
        <parameter name="mem"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">pointer to a block of memory representing a C structure or union</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="value" transfer-ownership="none">
          <doc xml:space="preserve">a #GIArgument holding the value to store</doc>
          <type name="Argument" c:type="const GIArgument*"/>
        </parameter>
      </parameters>
    </function>
    <function name="function_info_get_flags"
              c:identifier="g_function_info_get_flags">
      <doc xml:space="preserve">Obtain the #GIFunctionInfoFlags for the @info.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the flags</doc>
        <type name="FunctionInfoFlags" c:type="GIFunctionInfoFlags"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFunctionInfo</doc>
          <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="function_info_get_property"
              c:identifier="g_function_info_get_property">
      <doc xml:space="preserve">Obtain the property associated with this #GIFunctionInfo.
Only #GIFunctionInfo with the flag %GI_FUNCTION_IS_GETTER or
%GI_FUNCTION_IS_SETTER have a property set. For other cases,
%NULL will be returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the property or %NULL if not set. Free it with
g_base_info_unref() when done.</doc>
        <type name="PropertyInfo" c:type="GIPropertyInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFunctionInfo</doc>
          <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="function_info_get_symbol"
              c:identifier="g_function_info_get_symbol">
      <doc xml:space="preserve">Obtain the symbol of the function. The symbol is the name of the
exported function, suitable to be used as an argument to
g_module_symbol().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the symbol</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFunctionInfo</doc>
          <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="function_info_get_vfunc"
              c:identifier="g_function_info_get_vfunc">
      <doc xml:space="preserve">Obtain the virtual function associated with this #GIFunctionInfo.
Only #GIFunctionInfo with the flag %GI_FUNCTION_WRAPS_VFUNC has
a virtual function set. For other cases, %NULL will be returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the virtual function or %NULL if not set.
Free it by calling g_base_info_unref() when done.</doc>
        <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFunctionInfo</doc>
          <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="function_info_invoke"
              c:identifier="g_function_info_invoke"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Invokes the function described in @info with the given
arguments. Note that inout parameters must appear in both
argument lists. This function uses dlsym() to obtain a pointer
to the function, so the library or shared object containing the
described function must either be linked to the caller, or must
have been g_module_symbol()&lt;!-- --&gt;ed before calling this function.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the function has been invoked, %FALSE if an
  error occurred.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIFunctionInfo describing the function to invoke</doc>
          <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
        </parameter>
        <parameter name="in_args" transfer-ownership="none">
          <doc xml:space="preserve">an array of #GIArgument&lt;!-- --&gt;s, one for each in
   parameter of @info. If there are no in parameter, @in_args
   can be %NULL</doc>
          <array length="2" zero-terminated="0" c:type="GIArgument*">
            <type name="Argument" c:type="GIArgument"/>
          </array>
        </parameter>
        <parameter name="n_in_args" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @in_args array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="out_args" transfer-ownership="none">
          <doc xml:space="preserve">an array of #GIArgument&lt;!-- --&gt;s, one for each out
   parameter of @info. If there are no out parameters, @out_args
   may be %NULL</doc>
          <array length="4" zero-terminated="0" c:type="GIArgument*">
            <type name="Argument" c:type="GIArgument"/>
          </array>
        </parameter>
        <parameter name="n_out_args" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @out_args array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">return location for the return value of the
   function. If the function returns void, @return_value may be
   %NULL</doc>
          <type name="Argument" c:type="GIArgument*"/>
        </parameter>
      </parameters>
    </function>
    <function name="info_new" c:identifier="g_info_new">
      <doc xml:space="preserve">TODO</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">TODO</doc>
        <type name="BaseInfo" c:type="GIBaseInfo*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="InfoType" c:type="GIInfoType"/>
        </parameter>
        <parameter name="container" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="BaseInfo" c:type="GIBaseInfo*"/>
        </parameter>
        <parameter name="typelib" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="Typelib" c:type="GITypelib*"/>
        </parameter>
        <parameter name="offset" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="guint32" c:type="guint32"/>
        </parameter>
      </parameters>
    </function>
    <function name="info_type_to_string" c:identifier="g_info_type_to_string">
      <doc xml:space="preserve">Obtain a string representation of @type</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the info type</doc>
          <type name="InfoType" c:type="GIInfoType"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_find_method"
              c:identifier="g_interface_info_find_method">
      <doc xml:space="preserve">Obtain a method of the interface type given a @name. %NULL will be
returned if there's no method available with that name.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo or %NULL if none found.
Free the struct by calling g_base_info_unref() when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name of method to obtain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_find_signal"
              c:identifier="g_interface_info_find_signal"
              version="1.34">
      <doc xml:space="preserve">TODO</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Info for the signal with name @name in @info, or
%NULL on failure.</doc>
        <type name="SignalInfo" c:type="GISignalInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">Name of signal</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_find_vfunc"
              c:identifier="g_interface_info_find_vfunc">
      <doc xml:space="preserve">Locate a virtual function slot with name @name. See the documentation
for g_object_info_find_vfunc() for more information on virtuals.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIVFuncInfo, or %NULL. Free it with
g_base_info_unref() when done.</doc>
        <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name of a virtual function to find.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_constant"
              c:identifier="g_interface_info_get_constant">
      <doc xml:space="preserve">Obtain an interface type constant at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIConstantInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="ConstantInfo" c:type="GIConstantInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of constant to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_iface_struct"
              c:identifier="g_interface_info_get_iface_struct">
      <doc xml:space="preserve">Returns the layout C structure associated with this #GInterface.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIStructInfo or %NULL. Free it with
g_base_info_unref() when done.</doc>
        <type name="StructInfo" c:type="GIStructInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_method"
              c:identifier="g_interface_info_get_method">
      <doc xml:space="preserve">Obtain an interface type method at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of method to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_n_constants"
              c:identifier="g_interface_info_get_n_constants">
      <doc xml:space="preserve">Obtain the number of constants that this interface type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of constants</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_n_methods"
              c:identifier="g_interface_info_get_n_methods">
      <doc xml:space="preserve">Obtain the number of methods that this interface type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of methods</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_n_prerequisites"
              c:identifier="g_interface_info_get_n_prerequisites">
      <doc xml:space="preserve">Obtain the number of prerequisites for this interface type.
A prerequisites is another interface that needs to be implemented for
interface, similar to an base class for GObjects.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of prerequisites</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_n_properties"
              c:identifier="g_interface_info_get_n_properties">
      <doc xml:space="preserve">Obtain the number of properties that this interface type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of properties</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_n_signals"
              c:identifier="g_interface_info_get_n_signals">
      <doc xml:space="preserve">Obtain the number of signals that this interface type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of signals</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_n_vfuncs"
              c:identifier="g_interface_info_get_n_vfuncs">
      <doc xml:space="preserve">Obtain the number of virtual functions that this interface type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of virtual functions</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_prerequisite"
              c:identifier="g_interface_info_get_prerequisite">
      <doc xml:space="preserve">Obtain an interface type prerequisites index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the prerequisites as a #GIBaseInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="BaseInfo" c:type="GIBaseInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of prerequisites to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_property"
              c:identifier="g_interface_info_get_property">
      <doc xml:space="preserve">Obtain an interface type property at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIPropertyInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="PropertyInfo" c:type="GIPropertyInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of property to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_signal"
              c:identifier="g_interface_info_get_signal">
      <doc xml:space="preserve">Obtain an interface type signal at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GISignalInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="SignalInfo" c:type="GISignalInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of signal to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="interface_info_get_vfunc"
              c:identifier="g_interface_info_get_vfunc">
      <doc xml:space="preserve">Obtain an interface type virtual function at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIVFuncInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIInterfaceInfo</doc>
          <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of virtual function to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="invoke_error_quark" c:identifier="g_invoke_error_quark">
      <doc xml:space="preserve">TODO</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">TODO</doc>
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <enumeration name="nvokeError" c:type="GInvokeError">
      <doc xml:space="preserve">An error occuring while invoking a function via
g_function_info_invoke().</doc>
      <member name="failed" value="0" c:identifier="G_INVOKE_ERROR_FAILED">
        <doc xml:space="preserve">invokation failed, unknown error.</doc>
      </member>
      <member name="symbol_not_found"
              value="1"
              c:identifier="G_INVOKE_ERROR_SYMBOL_NOT_FOUND">
        <doc xml:space="preserve">symbol couldn't be found in any of the
libraries associated with the typelib of the function.</doc>
      </member>
      <member name="argument_mismatch"
              value="2"
              c:identifier="G_INVOKE_ERROR_ARGUMENT_MISMATCH">
        <doc xml:space="preserve">the arguments provided didn't match
the expected arguments for the functions type signature.</doc>
      </member>
    </enumeration>
    <function name="object_info_find_method"
              c:identifier="g_object_info_find_method">
      <doc xml:space="preserve">Obtain a method of the object type given a @name. %NULL will be
returned if there's no method available with that name.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name of method to obtain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_find_method_using_interfaces"
              c:identifier="g_object_info_find_method_using_interfaces">
      <doc xml:space="preserve">Obtain a method of the object given a @name, searching both the
object @info and any interfaces it implements.  %NULL will be
returned if there's no method available with that name.

Note that this function does *not* search parent classes; you will have
to chain up if that's desired.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name of method to obtain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="implementor"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">The implementor of the interface</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo**"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_find_signal"
              c:identifier="g_object_info_find_signal">
      <doc xml:space="preserve">TODO</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">Info for the signal with name @name in @info, or %NULL on failure.</doc>
        <type name="SignalInfo" c:type="GISignalInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">Name of signal</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_find_vfunc"
              c:identifier="g_object_info_find_vfunc">
      <doc xml:space="preserve">Locate a virtual function slot with name @name. Note that the namespace
for virtuals is distinct from that of methods; there may or may not be
a concrete method associated for a virtual. If there is one, it may
be retrieved using g_vfunc_info_get_invoker(), otherwise %NULL will be
returned.
See the documentation for g_vfunc_info_get_invoker() for more
information on invoking virtuals.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIVFuncInfo, or %NULL. Free it with
g_base_info_unref() when done.</doc>
        <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">The name of a virtual function to find.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_find_vfunc_using_interfaces"
              c:identifier="g_object_info_find_vfunc_using_interfaces">
      <doc xml:space="preserve">Locate a virtual function slot with name @name, searching both the object
@info and any interfaces it implements.  Note that the namespace for
virtuals is distinct from that of methods; there may or may not be a
concrete method associated for a virtual. If there is one, it may be
retrieved using g_vfunc_info_get_invoker(), otherwise %NULL will be
returned.

Note that this function does *not* search parent classes; you will have
to chain up if that's desired.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">name of method to obtain</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
        <parameter name="implementor"
                   direction="out"
                   caller-allocates="0"
                   transfer-ownership="full">
          <doc xml:space="preserve">The implementor of the interface</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo**"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_abstract"
              c:identifier="g_object_info_get_abstract">
      <doc xml:space="preserve">Obtain if the object type is an abstract type, eg if it cannot be
instantiated</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the object type is abstract</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_class_struct"
              c:identifier="g_object_info_get_class_struct">
      <doc xml:space="preserve">Every #GObject has two structures; an instance structure and a class
structure.  This function returns the metadata for the class structure.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIStructInfo or %NULL. Free with
g_base_info_unref() when done.</doc>
        <type name="StructInfo" c:type="GIStructInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_constant"
              c:identifier="g_object_info_get_constant">
      <doc xml:space="preserve">Obtain an object type constant at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIConstantInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="ConstantInfo" c:type="GIConstantInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of constant to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_field"
              c:identifier="g_object_info_get_field">
      <doc xml:space="preserve">Obtain an object type field at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFieldInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="FieldInfo" c:type="GIFieldInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of field to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_fundamental"
              c:identifier="g_object_info_get_fundamental">
      <doc xml:space="preserve">Obtain if the object type is of a fundamental type which is not
G_TYPE_OBJECT. This is mostly for supporting GstMiniObject.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the object type is a fundamental type</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_get_value_function"
              c:identifier="g_object_info_get_get_value_function">
      <doc xml:space="preserve">Obtain the symbol name of the function that should be called to convert
an object instance pointer of this object type to a GValue.
I's mainly used fundamental types. The type signature for the symbol
is %GIObjectInfoGetValueFunction, to fetch the function pointer
see g_object_info_get_get_value_function().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the symbol or %NULL</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_get_value_function_pointer"
              c:identifier="g_object_info_get_get_value_function_pointer"
              introspectable="0">
      <doc xml:space="preserve">Obtain a pointer to a function which can be used to
extract an instance of this object type out of a GValue.
This takes derivation into account and will reversely traverse
the base classes of this type, starting at the top type.</doc>
      <return-value>
        <doc xml:space="preserve">the function pointer or %NULL</doc>
        <type name="ObjectInfoGetValueFunction"
              c:type="GIObjectInfoGetValueFunction"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_interface"
              c:identifier="g_object_info_get_interface">
      <doc xml:space="preserve">Obtain an object type interface at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIInterfaceInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="InterfaceInfo" c:type="GIInterfaceInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of interface to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_method"
              c:identifier="g_object_info_get_method">
      <doc xml:space="preserve">Obtain an object type method at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of method to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_n_constants"
              c:identifier="g_object_info_get_n_constants">
      <doc xml:space="preserve">Obtain the number of constants that this object type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of constants</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_n_fields"
              c:identifier="g_object_info_get_n_fields">
      <doc xml:space="preserve">Obtain the number of fields that this object type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of fields</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_n_interfaces"
              c:identifier="g_object_info_get_n_interfaces">
      <doc xml:space="preserve">Obtain the number of interfaces that this object type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of interfaces</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_n_methods"
              c:identifier="g_object_info_get_n_methods">
      <doc xml:space="preserve">Obtain the number of methods that this object type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of methods</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_n_properties"
              c:identifier="g_object_info_get_n_properties">
      <doc xml:space="preserve">Obtain the number of properties that this object type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of properties</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_n_signals"
              c:identifier="g_object_info_get_n_signals">
      <doc xml:space="preserve">Obtain the number of signals that this object type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of signals</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_n_vfuncs"
              c:identifier="g_object_info_get_n_vfuncs">
      <doc xml:space="preserve">Obtain the number of virtual functions that this object type has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of virtual functions</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_parent"
              c:identifier="g_object_info_get_parent">
      <doc xml:space="preserve">Obtain the parent of the object type.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIObjectInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="ObjectInfo" c:type="GIObjectInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_property"
              c:identifier="g_object_info_get_property">
      <doc xml:space="preserve">Obtain an object type property at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIPropertyInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="PropertyInfo" c:type="GIPropertyInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of property to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_ref_function"
              c:identifier="g_object_info_get_ref_function">
      <doc xml:space="preserve">Obtain the symbol name of the function that should be called to ref this
object type. It's mainly used fundamental types. The type signature for
the symbol is %GIObjectInfoRefFunction, to fetch the function pointer
see g_object_info_get_ref_function().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the symbol or %NULL</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_ref_function_pointer"
              c:identifier="g_object_info_get_ref_function_pointer"
              introspectable="0">
      <doc xml:space="preserve">Obtain a pointer to a function which can be used to
increase the reference count an instance of this object type.
This takes derivation into account and will reversely traverse
the base classes of this type, starting at the top type.</doc>
      <return-value>
        <doc xml:space="preserve">the function pointer or %NULL</doc>
        <type name="ObjectInfoRefFunction" c:type="GIObjectInfoRefFunction"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_set_value_function"
              c:identifier="g_object_info_get_set_value_function">
      <doc xml:space="preserve">Obtain the symbol name of the function that should be called to convert
set a GValue giving an object instance pointer of this object type.
I's mainly used fundamental types. The type signature for the symbol
is %GIObjectInfoSetValueFunction, to fetch the function pointer
see g_object_info_get_set_value_function().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the symbol or %NULL</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_set_value_function_pointer"
              c:identifier="g_object_info_get_set_value_function_pointer"
              introspectable="0">
      <doc xml:space="preserve">Obtain a pointer to a function which can be used to
set a GValue given an instance of this object type.
This takes derivation into account and will reversely traverse
the base classes of this type, starting at the top type.</doc>
      <return-value>
        <doc xml:space="preserve">the function pointer or %NULL</doc>
        <type name="ObjectInfoSetValueFunction"
              c:type="GIObjectInfoSetValueFunction"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_signal"
              c:identifier="g_object_info_get_signal">
      <doc xml:space="preserve">Obtain an object type signal at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GISignalInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="SignalInfo" c:type="GISignalInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of signal to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_type_init"
              c:identifier="g_object_info_get_type_init">
      <doc xml:space="preserve">Obtain the function which when called will return the GType
function for which this object type is registered.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the type init function</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_type_name"
              c:identifier="g_object_info_get_type_name">
      <doc xml:space="preserve">Obtain the name of the objects class/type.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">name of the objects type</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_unref_function"
              c:identifier="g_object_info_get_unref_function">
      <doc xml:space="preserve">Obtain the symbol name of the function that should be called to unref this
object type. It's mainly used fundamental types. The type signature for
the symbol is %GIObjectInfoUnrefFunction, to fetch the function pointer
see g_object_info_get_unref_function().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the symbol or %NULL</doc>
        <type name="utf8" c:type="const char*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_unref_function_pointer"
              c:identifier="g_object_info_get_unref_function_pointer"
              introspectable="0">
      <doc xml:space="preserve">Obtain a pointer to a function which can be used to
decrease the reference count an instance of this object type.
This takes derivation into account and will reversely traverse
the base classes of this type, starting at the top type.</doc>
      <return-value>
        <doc xml:space="preserve">the function pointer or %NULL</doc>
        <type name="ObjectInfoUnrefFunction"
              c:type="GIObjectInfoUnrefFunction"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="object_info_get_vfunc"
              c:identifier="g_object_info_get_vfunc">
      <doc xml:space="preserve">Obtain an object type virtual function at index @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIVFuncInfo. Free the struct by calling
g_base_info_unref() when done.</doc>
        <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIObjectInfo</doc>
          <type name="ObjectInfo" c:type="GIObjectInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of virtual function to get</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="property_info_get_flags"
              c:identifier="g_property_info_get_flags">
      <doc xml:space="preserve">Obtain the flags for this property info. See #GParamFlags for
more information about possible flag values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the flags</doc>
        <type name="GObject.ParamFlags" c:type="GParamFlags"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIPropertyInfo</doc>
          <type name="PropertyInfo" c:type="GIPropertyInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="property_info_get_ownership_transfer"
              c:identifier="g_property_info_get_ownership_transfer">
      <doc xml:space="preserve">Obtain the ownership transfer for this property. See #GITransfer for more
information about transfer values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the transfer</doc>
        <type name="Transfer" c:type="GITransfer"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIPropertyInfo</doc>
          <type name="PropertyInfo" c:type="GIPropertyInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="property_info_get_type"
              c:identifier="g_property_info_get_type">
      <doc xml:space="preserve">Obtain the type information for the property @info.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GITypeInfo, free it with
g_base_info_unref() when done.</doc>
        <type name="TypeInfo" c:type="GITypeInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIPropertyInfo</doc>
          <type name="PropertyInfo" c:type="GIPropertyInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="registered_type_info_get_g_type"
              c:identifier="g_registered_type_info_get_g_type">
      <doc xml:space="preserve">Obtain the #GType for this registered type or G_TYPE_NONE which a special meaning.
It means that either there is no type information associated with this @info or
that the shared library which provides the type_init function for this
@info cannot be called.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the #GType.</doc>
        <type name="GType" c:type="GType"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIRegisteredTypeInfo</doc>
          <type name="RegisteredTypeInfo" c:type="GIRegisteredTypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="registered_type_info_get_type_init"
              c:identifier="g_registered_type_info_get_type_init">
      <doc xml:space="preserve">Obtain the type init function for @info. The type init function is the
function which will register the GType within the GObject type system.
Usually this is not called by langauge bindings or applications, use
g_registered_type_info_get_g_type() directly instead.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the symbol name of the type init function, suitable for
passing into g_module_symbol().</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIRegisteredTypeInfo</doc>
          <type name="RegisteredTypeInfo" c:type="GIRegisteredTypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="registered_type_info_get_type_name"
              c:identifier="g_registered_type_info_get_type_name">
      <doc xml:space="preserve">Obtain the type name of the struct within the GObject type system.
This type can be passed to g_type_name() to get a #GType.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the type name</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIRegisteredTypeInfo</doc>
          <type name="RegisteredTypeInfo" c:type="GIRegisteredTypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_info_get_class_closure"
              c:identifier="g_signal_info_get_class_closure">
      <doc xml:space="preserve">Obtain the class closure for this signal if one is set. The class
closure is a virtual function on the type that the signal belongs to.
If the signal lacks a closure %NULL will be returned.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the class closure or %NULL</doc>
        <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GISignalInfo</doc>
          <type name="SignalInfo" c:type="GISignalInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_info_get_flags"
              c:identifier="g_signal_info_get_flags">
      <doc xml:space="preserve">Obtain the flags for this signal info. See #GSignalFlags for
more information about possible flag values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the flags</doc>
        <type name="GObject.SignalFlags" c:type="GSignalFlags"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GISignalInfo</doc>
          <type name="SignalInfo" c:type="GISignalInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_info_true_stops_emit"
              c:identifier="g_signal_info_true_stops_emit">
      <doc xml:space="preserve">Obtain if the returning true in the signal handler will
stop the emission of the signal.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if returning true stops the signal emission</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GISignalInfo</doc>
          <type name="SignalInfo" c:type="GISignalInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_find_field"
              c:identifier="g_struct_info_find_field">
      <doc xml:space="preserve">Obtain the type information for field named @name.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFieldInfo or %NULL if not found,
free it with g_base_info_unref() when done.</doc>
        <type name="FieldInfo" c:type="GIFieldInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a field name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_find_method"
              c:identifier="g_struct_info_find_method">
      <doc xml:space="preserve">Obtain the type information for method named @name.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo, free it with g_base_info_unref()
when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a method name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_get_alignment"
              c:identifier="g_struct_info_get_alignment">
      <doc xml:space="preserve">Obtain the required alignment of the structure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">required alignment in bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_get_field"
              c:identifier="g_struct_info_get_field">
      <doc xml:space="preserve">Obtain the type information for field with specified index.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFieldInfo, free it with g_base_info_unref()
when done.</doc>
        <type name="FieldInfo" c:type="GIFieldInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">a field index</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_get_method"
              c:identifier="g_struct_info_get_method">
      <doc xml:space="preserve">Obtain the type information for method with specified index.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo, free it with g_base_info_unref()
when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">a method index</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_get_n_fields"
              c:identifier="g_struct_info_get_n_fields">
      <doc xml:space="preserve">Obtain the number of fields this structure has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of fields</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_get_n_methods"
              c:identifier="g_struct_info_get_n_methods">
      <doc xml:space="preserve">Obtain the number of methods this structure has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of methods</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_get_size"
              c:identifier="g_struct_info_get_size">
      <doc xml:space="preserve">Obtain the total size of the structure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">size of the structure in bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_is_foreign"
              c:identifier="g_struct_info_is_foreign">
      <doc xml:space="preserve">TODO</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">TODO</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">TODO</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="struct_info_is_gtype_struct"
              c:identifier="g_struct_info_is_gtype_struct">
      <doc xml:space="preserve">Return true if this structure represents the "class structure" for some
#GObject or #GInterface.  This function is mainly useful to hide this kind of structure
from generated public APIs.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if this is a class struct, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIStructInfo</doc>
          <type name="StructInfo" c:type="GIStructInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_info_get_array_fixed_size"
              c:identifier="g_type_info_get_array_fixed_size">
      <doc xml:space="preserve">Obtain the fixed array size of the type. The type tag must be a
#GI_TYPE_TAG_ARRAY or -1 will returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the size or -1 if it's not an array</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GITypeInfo</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_info_get_array_length"
              c:identifier="g_type_info_get_array_length">
      <doc xml:space="preserve">Obtain the array length of the type. The type tag must be a
#GI_TYPE_TAG_ARRAY or -1 will returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the array length, or -1 if the type is not an array</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GITypeInfo</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_info_get_array_type"
              c:identifier="g_type_info_get_array_type">
      <doc xml:space="preserve">Obtain the array type for this type. See #GIArrayType for a list of
possible values. If the type tag of this type is not array, -1 will be
returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the array type or -1</doc>
        <type name="ArrayType" c:type="GIArrayType"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GITypeInfo</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_info_get_interface"
              c:identifier="g_type_info_get_interface">
      <doc xml:space="preserve">For types which have #GI_TYPE_TAG_INTERFACE such as GObjects and boxed values,
this function returns full information about the referenced type.  You can then
inspect the type of the returned #GIBaseInfo to further query whether it is
a concrete GObject, a GInterface, a structure, etc. using g_base_info_get_type().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIBaseInfo, or %NULL. Free it with
g_base_info_unref() when done.</doc>
        <type name="BaseInfo" c:type="GIBaseInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GITypeInfo</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_info_get_param_type"
              c:identifier="g_type_info_get_param_type">
      <doc xml:space="preserve">Obtain the parameter type @n.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the param type info</doc>
        <type name="TypeInfo" c:type="GITypeInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GITypeInfo</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">index of the parameter</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_info_get_tag" c:identifier="g_type_info_get_tag">
      <doc xml:space="preserve">Obtain the type tag for the type. See #GITypeTag for a list
of type tags.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the type tag</doc>
        <type name="TypeTag" c:type="GITypeTag"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GITypeInfo</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_info_is_pointer"
              c:identifier="g_type_info_is_pointer">
      <doc xml:space="preserve">Obtain if the type is passed as a reference.

Note that the types of %GI_DIRECTION_OUT and %GI_DIRECTION_INOUT parameters
will only be pointers if the underlying type being transferred is a pointer
(i.e. only if the type of the C function’s formal parameter is a pointer to a
pointer).</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if it is a pointer</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GITypeInfo</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_info_is_zero_terminated"
              c:identifier="g_type_info_is_zero_terminated">
      <doc xml:space="preserve">Obtain if the last element of the array is %NULL. The type tag must be a
#GI_TYPE_TAG_ARRAY or %FALSE will returned.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if zero terminated</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GITypeInfo</doc>
          <type name="TypeInfo" c:type="GITypeInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="type_tag_to_string" c:identifier="g_type_tag_to_string">
      <doc xml:space="preserve">Obtain a string representation of @type</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the string</doc>
        <type name="utf8" c:type="const gchar*"/>
      </return-value>
      <parameters>
        <parameter name="type" transfer-ownership="none">
          <doc xml:space="preserve">the type_tag</doc>
          <type name="TypeTag" c:type="GITypeTag"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_find_method"
              c:identifier="g_union_info_find_method">
      <doc xml:space="preserve">Obtain the type information for method named @name.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo, free it with g_base_info_unref()
when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
        <parameter name="name" transfer-ownership="none">
          <doc xml:space="preserve">a method name</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_alignment"
              c:identifier="g_union_info_get_alignment">
      <doc xml:space="preserve">Obtain the required alignment of the union.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">required alignment in bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_discriminator"
              c:identifier="g_union_info_get_discriminator">
      <doc xml:space="preserve">Obtain discriminator value assigned for n-th union field, i.e. n-th
union field is the active one if discriminator contains this
constant.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIConstantInfo, free it with g_base_info_unref()
when done.</doc>
        <type name="ConstantInfo" c:type="GIConstantInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">a union field index</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_discriminator_offset"
              c:identifier="g_union_info_get_discriminator_offset">
      <doc xml:space="preserve">Returns offset of the discriminator field in the structure.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">offset in bytes of the discriminator</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_discriminator_type"
              c:identifier="g_union_info_get_discriminator_type">
      <doc xml:space="preserve">Obtain the type information of the union discriminator.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GITypeInfo, free it with g_base_info_unref()
when done.</doc>
        <type name="TypeInfo" c:type="GITypeInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_field"
              c:identifier="g_union_info_get_field">
      <doc xml:space="preserve">Obtain the type information for field with specified index.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFieldInfo, free it with g_base_info_unref()
when done.</doc>
        <type name="FieldInfo" c:type="GIFieldInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">a field index</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_method"
              c:identifier="g_union_info_get_method">
      <doc xml:space="preserve">Obtain the type information for method with specified index.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIFunctionInfo, free it with g_base_info_unref()
when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
        <parameter name="n" transfer-ownership="none">
          <doc xml:space="preserve">a method index</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_n_fields"
              c:identifier="g_union_info_get_n_fields">
      <doc xml:space="preserve">Obtain the number of fields this union has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of fields</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_n_methods"
              c:identifier="g_union_info_get_n_methods">
      <doc xml:space="preserve">Obtain the number of methods this union has.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">number of methods</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_get_size" c:identifier="g_union_info_get_size">
      <doc xml:space="preserve">Obtain the total size of the union.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">size of the union in bytes</doc>
        <type name="gsize" c:type="gsize"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="union_info_is_discriminated"
              c:identifier="g_union_info_is_discriminated">
      <doc xml:space="preserve">Return true if this union contains discriminator field.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if this is a discriminated union, %FALSE otherwise</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIUnionInfo</doc>
          <type name="UnionInfo" c:type="GIUnionInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="value_info_get_value"
              c:identifier="g_value_info_get_value">
      <doc xml:space="preserve">Obtain the enumeration value of the #GIValueInfo.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the enumeration value. This will always be representable
  as a 32-bit signed or unsigned value. The use of gint64 as the
  return type is to allow both.</doc>
        <type name="gint64" c:type="gint64"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIValueInfo</doc>
          <type name="ValueInfo" c:type="GIValueInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vfunc_info_get_address"
              c:identifier="g_vfunc_info_get_address"
              throws="1">
      <doc xml:space="preserve">This method will look up where inside the type struct of @implementor_gtype
is the implementation for @info.</doc>
      <return-value transfer-ownership="none" nullable="1">
        <doc xml:space="preserve">address to a function or %NULL if an error happened</doc>
        <type name="gpointer" c:type="gpointer"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIVFuncInfo</doc>
          <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
        </parameter>
        <parameter name="implementor_gtype" transfer-ownership="none">
          <doc xml:space="preserve">#GType implementing this virtual function</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
      </parameters>
    </function>
    <function name="vfunc_info_get_flags"
              c:identifier="g_vfunc_info_get_flags">
      <doc xml:space="preserve">Obtain the flags for this virtual function info. See #GIVFuncInfoFlags for
more information about possible flag values.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the flags</doc>
        <type name="VFuncInfoFlags" c:type="GIVFuncInfoFlags"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIVFuncInfo</doc>
          <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vfunc_info_get_invoker"
              c:identifier="g_vfunc_info_get_invoker">
      <doc xml:space="preserve">If this virtual function has an associated invoker method, this
method will return it.  An invoker method is a C entry point.

Not all virtuals will have invokers.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the #GIVFuncInfo or %NULL. Free it with
g_base_info_unref() when done.</doc>
        <type name="FunctionInfo" c:type="GIFunctionInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIVFuncInfo</doc>
          <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vfunc_info_get_offset"
              c:identifier="g_vfunc_info_get_offset">
      <doc xml:space="preserve">Obtain the offset of the function pointer in the class struct. The value
0xFFFF indicates that the struct offset is unknown.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the struct offset or 0xFFFF if it's unknown</doc>
        <type name="gint" c:type="gint"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIVFuncInfo</doc>
          <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vfunc_info_get_signal"
              c:identifier="g_vfunc_info_get_signal">
      <doc xml:space="preserve">Obtain the signal for the virtual function if one is set.
The signal comes from the object or interface to which
this virtual function belongs.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the signal or %NULL if none set</doc>
        <type name="SignalInfo" c:type="GISignalInfo*"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIVFuncInfo</doc>
          <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
        </parameter>
      </parameters>
    </function>
    <function name="vfunc_info_invoke"
              c:identifier="g_vfunc_info_invoke"
              introspectable="0"
              throws="1">
      <doc xml:space="preserve">Invokes the function described in @info with the given
arguments. Note that inout parameters must appear in both
argument lists.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if the function has been invoked, %FALSE if an
  error occurred.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">a #GIVFuncInfo describing the virtual function to invoke</doc>
          <type name="VFuncInfo" c:type="GIVFuncInfo*"/>
        </parameter>
        <parameter name="implementor" transfer-ownership="none">
          <doc xml:space="preserve">#GType of the type that implements this virtual function</doc>
          <type name="GType" c:type="GType"/>
        </parameter>
        <parameter name="in_args" transfer-ownership="none">
          <doc xml:space="preserve">an array of #GIArgument&lt;!-- --&gt;s, one for each in
   parameter of @info. If there are no in parameter, @in_args
   can be %NULL</doc>
          <array length="3" zero-terminated="0" c:type="GIArgument*">
            <type name="Argument" c:type="GIArgument"/>
          </array>
        </parameter>
        <parameter name="n_in_args" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @in_args array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="out_args" transfer-ownership="none">
          <doc xml:space="preserve">an array of #GIArgument&lt;!-- --&gt;s, one for each out
   parameter of @info. If there are no out parameters, @out_args
   may be %NULL</doc>
          <array length="5" zero-terminated="0" c:type="GIArgument*">
            <type name="Argument" c:type="GIArgument"/>
          </array>
        </parameter>
        <parameter name="n_out_args" transfer-ownership="none">
          <doc xml:space="preserve">the length of the @out_args array</doc>
          <type name="gint" c:type="int"/>
        </parameter>
        <parameter name="return_value" transfer-ownership="none">
          <doc xml:space="preserve">return location for the return value of the
   function. If the function returns void, @return_value may be
   %NULL</doc>
          <type name="Argument" c:type="GIArgument*"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
