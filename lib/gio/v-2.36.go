// Code generated - DO NOT EDIT.
// +build gio_2.36

package gio

import (
	"fmt"
	glib "github.com/pekim/gobbi/lib/glib"
	gobject "github.com/pekim/gobbi/lib/gobject"
	"runtime"
	"sync"
	"unsafe"
)

// #cgo CFLAGS: -Wno-deprecated-declarations
// #cgo CFLAGS: -Wno-format-security
// #cgo CFLAGS: -Wno-incompatible-pointer-types
// #include <gio/gdesktopappinfo.h>
// #include <gio/gfiledescriptorbased.h>
// #include <gio/gio.h>
// #include <gio/gunixconnection.h>
// #include <gio/gunixcredentialsmessage.h>
// #include <gio/gunixfdlist.h>
// #include <gio/gunixfdmessage.h>
// #include <gio/gunixinputstream.h>
// #include <gio/gunixmounts.h>
// #include <gio/gunixoutputstream.h>
// #include <gio/gunixsocketaddress.h>
// #include <gio/gnetworking.h>
// #include <stdlib.h>
/*

	void applaunchcontext_launchFailedHandler(GObject *, gchar*, gpointer);

	static gulong AppLaunchContext_signal_connect_launch_failed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "launch-failed", G_CALLBACK(applaunchcontext_launchFailedHandler), data);
	}

*/
/*

	void applaunchcontext_launchedHandler(GObject *, GAppInfo *, GVariant *, gpointer);

	static gulong AppLaunchContext_signal_connect_launched(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "launched", G_CALLBACK(applaunchcontext_launchedHandler), data);
	}

*/
/*

	void application_activateHandler(GObject *, gpointer);

	static gulong Application_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(application_activateHandler), data);
	}

*/
/*

	gint application_commandLineHandler(GObject *, GApplicationCommandLine *, gpointer);

	static gulong Application_signal_connect_command_line(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "command-line", G_CALLBACK(application_commandLineHandler), data);
	}

*/
/*

	void application_openHandler(GObject *, gpointer, gint, gchar*, gpointer);

	static gulong Application_signal_connect_open(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "open", G_CALLBACK(application_openHandler), data);
	}

*/
/*

	void application_shutdownHandler(GObject *, gpointer);

	static gulong Application_signal_connect_shutdown(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "shutdown", G_CALLBACK(application_shutdownHandler), data);
	}

*/
/*

	void application_startupHandler(GObject *, gpointer);

	static gulong Application_signal_connect_startup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "startup", G_CALLBACK(application_startupHandler), data);
	}

*/
/*

	static void _g_application_command_line_print(GApplicationCommandLine* cmdline, const gchar* format) {
		return g_application_command_line_print(cmdline, format);
    }
*/
/*

	static void _g_application_command_line_printerr(GApplicationCommandLine* cmdline, const gchar* format) {
		return g_application_command_line_printerr(cmdline, format);
    }
*/
/*

	void cancellable_cancelledHandler(GObject *, gpointer);

	static gulong Cancellable_signal_connect_cancelled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cancelled", G_CALLBACK(cancellable_cancelledHandler), data);
	}

*/
/*

	gboolean dbusauthobserver_allowMechanismHandler(GObject *, gchar*, gpointer);

	static gulong DBusAuthObserver_signal_connect_allow_mechanism(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "allow-mechanism", G_CALLBACK(dbusauthobserver_allowMechanismHandler), data);
	}

*/
/*

	gboolean dbusauthobserver_authorizeAuthenticatedPeerHandler(GObject *, GIOStream *, GCredentials *, gpointer);

	static gulong DBusAuthObserver_signal_connect_authorize_authenticated_peer(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "authorize-authenticated-peer", G_CALLBACK(dbusauthobserver_authorizeAuthenticatedPeerHandler), data);
	}

*/
/*

	void dbusconnection_closedHandler(GObject *, gboolean, GError *, gpointer);

	static gulong DBusConnection_signal_connect_closed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "closed", G_CALLBACK(dbusconnection_closedHandler), data);
	}

*/
/*

	gboolean dbusinterfaceskeleton_gAuthorizeMethodHandler(GObject *, GDBusMethodInvocation *, gpointer);

	static gulong DBusInterfaceSkeleton_signal_connect_g_authorize_method(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "g-authorize-method", G_CALLBACK(dbusinterfaceskeleton_gAuthorizeMethodHandler), data);
	}

*/
/*

	static GDBusMessage* _g_dbus_message_new_method_error(GDBusMessage* method_call_message, const gchar* error_name, const gchar* error_message_format) {
		return g_dbus_message_new_method_error(method_call_message, error_name, error_message_format);
    }
*/
/*

	static void _g_dbus_method_invocation_return_error(GDBusMethodInvocation* invocation, GQuark domain, gint code, const gchar* format) {
		return g_dbus_method_invocation_return_error(invocation, domain, code, format);
    }
*/
/*

	void dbusobjectmanagerclient_interfaceProxySignalHandler(GObject *, GDBusObjectProxy *, GDBusProxy *, gchar*, gchar*, GVariant *, gpointer);

	static gulong DBusObjectManagerClient_signal_connect_interface_proxy_signal(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "interface-proxy-signal", G_CALLBACK(dbusobjectmanagerclient_interfaceProxySignalHandler), data);
	}

*/
/*

	gboolean dbusobjectskeleton_authorizeMethodHandler(GObject *, GDBusInterfaceSkeleton *, GDBusMethodInvocation *, gpointer);

	static gulong DBusObjectSkeleton_signal_connect_authorize_method(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "authorize-method", G_CALLBACK(dbusobjectskeleton_authorizeMethodHandler), data);
	}

*/
/*

	void dbusproxy_gSignalHandler(GObject *, gchar*, gchar*, GVariant *, gpointer);

	static gulong DBusProxy_signal_connect_g_signal(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "g-signal", G_CALLBACK(dbusproxy_gSignalHandler), data);
	}

*/
/*

	gboolean dbusserver_newConnectionHandler(GObject *, GDBusConnection *, gpointer);

	static gulong DBusServer_signal_connect_new_connection(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "new-connection", G_CALLBACK(dbusserver_newConnectionHandler), data);
	}

*/
/*

	void filemonitor_changedHandler(GObject *, GFile *, GFile *, GFileMonitorEvent, gpointer);

	static gulong FileMonitor_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(filemonitor_changedHandler), data);
	}

*/
/*

	void filenamecompleter_gotCompletionDataHandler(GObject *, gpointer);

	static gulong FilenameCompleter_signal_connect_got_completion_data(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "got-completion-data", G_CALLBACK(filenamecompleter_gotCompletionDataHandler), data);
	}

*/
/*

	static gboolean _g_menu_item_get_attribute(GMenuItem* menu_item, const gchar* attribute, const gchar* format_string) {
		return g_menu_item_get_attribute(menu_item, attribute, format_string);
    }
*/
/*

	static void _g_menu_item_set_action_and_target(GMenuItem* menu_item, const gchar* action, const gchar* format_string) {
		return g_menu_item_set_action_and_target(menu_item, action, format_string);
    }
*/
/*

	static void _g_menu_item_set_attribute(GMenuItem* menu_item, const gchar* attribute, const gchar* format_string) {
		return g_menu_item_set_attribute(menu_item, attribute, format_string);
    }
*/
/*

	void menumodel_itemsChangedHandler(GObject *, gint, gint, gint, gpointer);

	static gulong MenuModel_signal_connect_items_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "items-changed", G_CALLBACK(menumodel_itemsChangedHandler), data);
	}

*/
/*

	static gboolean _g_menu_model_get_item_attribute(GMenuModel* model, gint item_index, const gchar* attribute, const gchar* format_string) {
		return g_menu_model_get_item_attribute(model, item_index, attribute, format_string);
    }
*/
/*

	void mountoperation_abortedHandler(GObject *, gpointer);

	static gulong MountOperation_signal_connect_aborted(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "aborted", G_CALLBACK(mountoperation_abortedHandler), data);
	}

*/
/*

	void mountoperation_askPasswordHandler(GObject *, gchar*, gchar*, gchar*, GAskPasswordFlags, gpointer);

	static gulong MountOperation_signal_connect_ask_password(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "ask-password", G_CALLBACK(mountoperation_askPasswordHandler), data);
	}

*/
/*

	void mountoperation_replyHandler(GObject *, GMountOperationResult, gpointer);

	static gulong MountOperation_signal_connect_reply(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "reply", G_CALLBACK(mountoperation_replyHandler), data);
	}

*/
/*

	void mountoperation_showUnmountProgressHandler(GObject *, gchar*, gint64, gint64, gpointer);

	static gulong MountOperation_signal_connect_show_unmount_progress(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-unmount-progress", G_CALLBACK(mountoperation_showUnmountProgressHandler), data);
	}

*/
/*

	void resolver_reloadHandler(GObject *, gpointer);

	static gulong Resolver_signal_connect_reload(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "reload", G_CALLBACK(resolver_reloadHandler), data);
	}

*/
/*

	void settings_changedHandler(GObject *, gchar*, gpointer);

	static gulong Settings_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(settings_changedHandler), data);
	}

*/
/*

	gboolean settings_writableChangeEventHandler(GObject *, guint, gpointer);

	static gulong Settings_signal_connect_writable_change_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "writable-change-event", G_CALLBACK(settings_writableChangeEventHandler), data);
	}

*/
/*

	void settings_writableChangedHandler(GObject *, gchar*, gpointer);

	static gulong Settings_signal_connect_writable_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "writable-changed", G_CALLBACK(settings_writableChangedHandler), data);
	}

*/
/*

	static void _g_settings_get(GSettings* settings, const gchar* key, const gchar* format) {
		return g_settings_get(settings, key, format);
    }
*/
/*

	static gboolean _g_settings_set(GSettings* settings, const gchar* key, const gchar* format) {
		return g_settings_set(settings, key, format);
    }
*/
/*

	void simpleaction_activateHandler(GObject *, GVariant *, gpointer);

	static gulong SimpleAction_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(simpleaction_activateHandler), data);
	}

*/
/*

	void simpleaction_changeStateHandler(GObject *, GVariant *, gpointer);

	static gulong SimpleAction_signal_connect_change_state(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "change-state", G_CALLBACK(simpleaction_changeStateHandler), data);
	}

*/
/*

	static void _g_simple_async_result_set_error(GSimpleAsyncResult* simple, GQuark domain, gint code, const char* format) {
		return g_simple_async_result_set_error(simple, domain, code, format);
    }
*/
/*

	void socketclient_eventHandler(GObject *, GSocketClientEvent, GSocketConnectable *, GIOStream *, gpointer);

	static gulong SocketClient_signal_connect_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "event", G_CALLBACK(socketclient_eventHandler), data);
	}

*/
/*

	gboolean socketservice_incomingHandler(GObject *, GSocketConnection *, GObject *, gpointer);

	static gulong SocketService_signal_connect_incoming(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "incoming", G_CALLBACK(socketservice_incomingHandler), data);
	}

*/
/*

	static void _g_task_return_new_error(GTask* task, GQuark domain, gint code, const char* format) {
		return g_task_return_new_error(task, domain, code, format);
    }
*/
/*

	gboolean threadedsocketservice_runHandler(GObject *, GSocketConnection *, GObject *, gpointer);

	static gulong ThreadedSocketService_signal_connect_run(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "run", G_CALLBACK(threadedsocketservice_runHandler), data);
	}

*/
/*

	gboolean tlsconnection_acceptCertificateHandler(GObject *, GTlsCertificate *, GTlsCertificateFlags, gpointer);

	static gulong TlsConnection_signal_connect_accept_certificate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accept-certificate", G_CALLBACK(tlsconnection_acceptCertificateHandler), data);
	}

*/
/*

	void unixmountmonitor_mountpointsChangedHandler(GObject *, gpointer);

	static gulong UnixMountMonitor_signal_connect_mountpoints_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mountpoints-changed", G_CALLBACK(unixmountmonitor_mountpointsChangedHandler), data);
	}

*/
/*

	void unixmountmonitor_mountsChangedHandler(GObject *, gpointer);

	static gulong UnixMountMonitor_signal_connect_mounts_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mounts-changed", G_CALLBACK(unixmountmonitor_mountsChangedHandler), data);
	}

*/
/*

	void volumemonitor_driveChangedHandler(GObject *, GDrive *, gpointer);

	static gulong VolumeMonitor_signal_connect_drive_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drive-changed", G_CALLBACK(volumemonitor_driveChangedHandler), data);
	}

*/
/*

	void volumemonitor_driveConnectedHandler(GObject *, GDrive *, gpointer);

	static gulong VolumeMonitor_signal_connect_drive_connected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drive-connected", G_CALLBACK(volumemonitor_driveConnectedHandler), data);
	}

*/
/*

	void volumemonitor_driveDisconnectedHandler(GObject *, GDrive *, gpointer);

	static gulong VolumeMonitor_signal_connect_drive_disconnected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drive-disconnected", G_CALLBACK(volumemonitor_driveDisconnectedHandler), data);
	}

*/
/*

	void volumemonitor_driveEjectButtonHandler(GObject *, GDrive *, gpointer);

	static gulong VolumeMonitor_signal_connect_drive_eject_button(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drive-eject-button", G_CALLBACK(volumemonitor_driveEjectButtonHandler), data);
	}

*/
/*

	void volumemonitor_driveStopButtonHandler(GObject *, GDrive *, gpointer);

	static gulong VolumeMonitor_signal_connect_drive_stop_button(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drive-stop-button", G_CALLBACK(volumemonitor_driveStopButtonHandler), data);
	}

*/
/*

	void volumemonitor_mountAddedHandler(GObject *, GMount *, gpointer);

	static gulong VolumeMonitor_signal_connect_mount_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mount-added", G_CALLBACK(volumemonitor_mountAddedHandler), data);
	}

*/
/*

	void volumemonitor_mountChangedHandler(GObject *, GMount *, gpointer);

	static gulong VolumeMonitor_signal_connect_mount_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mount-changed", G_CALLBACK(volumemonitor_mountChangedHandler), data);
	}

*/
/*

	void volumemonitor_mountPreUnmountHandler(GObject *, GMount *, gpointer);

	static gulong VolumeMonitor_signal_connect_mount_pre_unmount(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mount-pre-unmount", G_CALLBACK(volumemonitor_mountPreUnmountHandler), data);
	}

*/
/*

	void volumemonitor_mountRemovedHandler(GObject *, GMount *, gpointer);

	static gulong VolumeMonitor_signal_connect_mount_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mount-removed", G_CALLBACK(volumemonitor_mountRemovedHandler), data);
	}

*/
/*

	void volumemonitor_volumeAddedHandler(GObject *, GVolume *, gpointer);

	static gulong VolumeMonitor_signal_connect_volume_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "volume-added", G_CALLBACK(volumemonitor_volumeAddedHandler), data);
	}

*/
/*

	void volumemonitor_volumeChangedHandler(GObject *, GVolume *, gpointer);

	static gulong VolumeMonitor_signal_connect_volume_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "volume-changed", G_CALLBACK(volumemonitor_volumeChangedHandler), data);
	}

*/
/*

	void volumemonitor_volumeRemovedHandler(GObject *, GVolume *, gpointer);

	static gulong VolumeMonitor_signal_connect_volume_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "volume-removed", G_CALLBACK(volumemonitor_volumeRemovedHandler), data);
	}

*/
/*

	static void _g_dbus_error_set_dbus_error(GError** error, const gchar* dbus_error_name, const gchar* dbus_error_message, const gchar* format) {
		return g_dbus_error_set_dbus_error(error, dbus_error_name, dbus_error_message, format);
    }
*/
/*

	void actiongroup_actionAddedHandler(GObject *, gchar*, gpointer);

	static gulong ActionGroup_signal_connect_action_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "action-added", G_CALLBACK(actiongroup_actionAddedHandler), data);
	}

*/
/*

	void actiongroup_actionEnabledChangedHandler(GObject *, gchar*, gboolean, gpointer);

	static gulong ActionGroup_signal_connect_action_enabled_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "action-enabled-changed", G_CALLBACK(actiongroup_actionEnabledChangedHandler), data);
	}

*/
/*

	void actiongroup_actionRemovedHandler(GObject *, gchar*, gpointer);

	static gulong ActionGroup_signal_connect_action_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "action-removed", G_CALLBACK(actiongroup_actionRemovedHandler), data);
	}

*/
/*

	void actiongroup_actionStateChangedHandler(GObject *, gchar*, GVariant *, gpointer);

	static gulong ActionGroup_signal_connect_action_state_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "action-state-changed", G_CALLBACK(actiongroup_actionStateChangedHandler), data);
	}

*/
/*

	void dbusobject_interfaceAddedHandler(GObject *, GDBusInterface *, gpointer);

	static gulong DBusObject_signal_connect_interface_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "interface-added", G_CALLBACK(dbusobject_interfaceAddedHandler), data);
	}

*/
/*

	void dbusobject_interfaceRemovedHandler(GObject *, GDBusInterface *, gpointer);

	static gulong DBusObject_signal_connect_interface_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "interface-removed", G_CALLBACK(dbusobject_interfaceRemovedHandler), data);
	}

*/
/*

	void dbusobjectmanager_interfaceAddedHandler(GObject *, GDBusObject *, GDBusInterface *, gpointer);

	static gulong DBusObjectManager_signal_connect_interface_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "interface-added", G_CALLBACK(dbusobjectmanager_interfaceAddedHandler), data);
	}

*/
/*

	void dbusobjectmanager_interfaceRemovedHandler(GObject *, GDBusObject *, GDBusInterface *, gpointer);

	static gulong DBusObjectManager_signal_connect_interface_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "interface-removed", G_CALLBACK(dbusobjectmanager_interfaceRemovedHandler), data);
	}

*/
/*

	void dbusobjectmanager_objectAddedHandler(GObject *, GDBusObject *, gpointer);

	static gulong DBusObjectManager_signal_connect_object_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "object-added", G_CALLBACK(dbusobjectmanager_objectAddedHandler), data);
	}

*/
/*

	void dbusobjectmanager_objectRemovedHandler(GObject *, GDBusObject *, gpointer);

	static gulong DBusObjectManager_signal_connect_object_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "object-removed", G_CALLBACK(dbusobjectmanager_objectRemovedHandler), data);
	}

*/
/*

	void drive_changedHandler(GObject *, gpointer);

	static gulong Drive_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(drive_changedHandler), data);
	}

*/
/*

	void drive_disconnectedHandler(GObject *, gpointer);

	static gulong Drive_signal_connect_disconnected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "disconnected", G_CALLBACK(drive_disconnectedHandler), data);
	}

*/
/*

	void drive_ejectButtonHandler(GObject *, gpointer);

	static gulong Drive_signal_connect_eject_button(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "eject-button", G_CALLBACK(drive_ejectButtonHandler), data);
	}

*/
/*

	void drive_stopButtonHandler(GObject *, gpointer);

	static gulong Drive_signal_connect_stop_button(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "stop-button", G_CALLBACK(drive_stopButtonHandler), data);
	}

*/
/*

	static gpointer _g_initable_new(GType object_type, GCancellable* cancellable, GError** error) {
		return g_initable_new(object_type, cancellable, error, NULL, NULL);
    }
*/
/*

	void mount_changedHandler(GObject *, gpointer);

	static gulong Mount_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(mount_changedHandler), data);
	}

*/
/*

	void mount_preUnmountHandler(GObject *, gpointer);

	static gulong Mount_signal_connect_pre_unmount(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "pre-unmount", G_CALLBACK(mount_preUnmountHandler), data);
	}

*/
/*

	void mount_unmountedHandler(GObject *, gpointer);

	static gulong Mount_signal_connect_unmounted(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmounted", G_CALLBACK(mount_unmountedHandler), data);
	}

*/
/*

	void networkmonitor_networkChangedHandler(GObject *, gboolean, gpointer);

	static gulong NetworkMonitor_signal_connect_network_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "network-changed", G_CALLBACK(networkmonitor_networkChangedHandler), data);
	}

*/
/*

	void volume_changedHandler(GObject *, gpointer);

	static gulong Volume_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(volume_changedHandler), data);
	}

*/
/*

	void volume_removedHandler(GObject *, gpointer);

	static gulong Volume_signal_connect_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "removed", G_CALLBACK(volume_removedHandler), data);
	}

*/
import "C"

type AppInfoCreateFlags C.GAppInfoCreateFlags

const (
	APP_INFO_CREATE_NONE                          AppInfoCreateFlags = 0
	APP_INFO_CREATE_NEEDS_TERMINAL                AppInfoCreateFlags = 1
	APP_INFO_CREATE_SUPPORTS_URIS                 AppInfoCreateFlags = 2
	APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION AppInfoCreateFlags = 4
)

type ApplicationFlags C.GApplicationFlags

const (
	APPLICATION_FLAGS_NONE           ApplicationFlags = 0
	APPLICATION_IS_SERVICE           ApplicationFlags = 1
	APPLICATION_IS_LAUNCHER          ApplicationFlags = 2
	APPLICATION_HANDLES_OPEN         ApplicationFlags = 4
	APPLICATION_HANDLES_COMMAND_LINE ApplicationFlags = 8
	APPLICATION_SEND_ENVIRONMENT     ApplicationFlags = 16
	APPLICATION_NON_UNIQUE           ApplicationFlags = 32
	APPLICATION_CAN_OVERRIDE_APP_ID  ApplicationFlags = 64
)

type AskPasswordFlags C.GAskPasswordFlags

const (
	ASK_PASSWORD_NEED_PASSWORD       AskPasswordFlags = 1
	ASK_PASSWORD_NEED_USERNAME       AskPasswordFlags = 2
	ASK_PASSWORD_NEED_DOMAIN         AskPasswordFlags = 4
	ASK_PASSWORD_SAVING_SUPPORTED    AskPasswordFlags = 8
	ASK_PASSWORD_ANONYMOUS_SUPPORTED AskPasswordFlags = 16
)

type BusNameOwnerFlags C.GBusNameOwnerFlags

const (
	BUS_NAME_OWNER_FLAGS_NONE              BusNameOwnerFlags = 0
	BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT BusNameOwnerFlags = 1
	BUS_NAME_OWNER_FLAGS_REPLACE           BusNameOwnerFlags = 2
	BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE      BusNameOwnerFlags = 4
)

type BusNameWatcherFlags C.GBusNameWatcherFlags

const (
	BUS_NAME_WATCHER_FLAGS_NONE       BusNameWatcherFlags = 0
	BUS_NAME_WATCHER_FLAGS_AUTO_START BusNameWatcherFlags = 1
)

type ConverterFlags C.GConverterFlags

const (
	CONVERTER_NO_FLAGS     ConverterFlags = 0
	CONVERTER_INPUT_AT_END ConverterFlags = 1
	CONVERTER_FLUSH        ConverterFlags = 2
)

type DBusCallFlags C.GDBusCallFlags

const (
	DBUS_CALL_FLAGS_NONE                            DBusCallFlags = 0
	DBUS_CALL_FLAGS_NO_AUTO_START                   DBusCallFlags = 1
	DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION DBusCallFlags = 2
)

type DBusCapabilityFlags C.GDBusCapabilityFlags

const (
	DBUS_CAPABILITY_FLAGS_NONE            DBusCapabilityFlags = 0
	DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING DBusCapabilityFlags = 1
)

type DBusConnectionFlags C.GDBusConnectionFlags

const (
	DBUS_CONNECTION_FLAGS_NONE                           DBusConnectionFlags = 0
	DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT          DBusConnectionFlags = 1
	DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER          DBusConnectionFlags = 2
	DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS DBusConnectionFlags = 4
	DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION         DBusConnectionFlags = 8
	DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING       DBusConnectionFlags = 16
)

type DBusInterfaceSkeletonFlags C.GDBusInterfaceSkeletonFlags

const (
	DBUS_INTERFACE_SKELETON_FLAGS_NONE                                DBusInterfaceSkeletonFlags = 0
	DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD DBusInterfaceSkeletonFlags = 1
)

type DBusMessageFlags C.GDBusMessageFlags

const (
	DBUS_MESSAGE_FLAGS_NONE                            DBusMessageFlags = 0
	DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED               DBusMessageFlags = 1
	DBUS_MESSAGE_FLAGS_NO_AUTO_START                   DBusMessageFlags = 2
	DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION DBusMessageFlags = 4
)

type DBusObjectManagerClientFlags C.GDBusObjectManagerClientFlags

const (
	DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE              DBusObjectManagerClientFlags = 0
	DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START DBusObjectManagerClientFlags = 1
)

type DBusPropertyInfoFlags C.GDBusPropertyInfoFlags

const (
	DBUS_PROPERTY_INFO_FLAGS_NONE     DBusPropertyInfoFlags = 0
	DBUS_PROPERTY_INFO_FLAGS_READABLE DBusPropertyInfoFlags = 1
	DBUS_PROPERTY_INFO_FLAGS_WRITABLE DBusPropertyInfoFlags = 2
)

type DBusProxyFlags C.GDBusProxyFlags

const (
	DBUS_PROXY_FLAGS_NONE                              DBusProxyFlags = 0
	DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES            DBusProxyFlags = 1
	DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS            DBusProxyFlags = 2
	DBUS_PROXY_FLAGS_DO_NOT_AUTO_START                 DBusProxyFlags = 4
	DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES        DBusProxyFlags = 8
	DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION DBusProxyFlags = 16
)

type DBusSendMessageFlags C.GDBusSendMessageFlags

const (
	DBUS_SEND_MESSAGE_FLAGS_NONE            DBusSendMessageFlags = 0
	DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL DBusSendMessageFlags = 1
)

type DBusServerFlags C.GDBusServerFlags

const (
	DBUS_SERVER_FLAGS_NONE                           DBusServerFlags = 0
	DBUS_SERVER_FLAGS_RUN_IN_THREAD                  DBusServerFlags = 1
	DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS DBusServerFlags = 2
)

type DBusSignalFlags C.GDBusSignalFlags

const (
	DBUS_SIGNAL_FLAGS_NONE                 DBusSignalFlags = 0
	DBUS_SIGNAL_FLAGS_NO_MATCH_RULE        DBusSignalFlags = 1
	DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE DBusSignalFlags = 2
	DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH      DBusSignalFlags = 4
)

type DBusSubtreeFlags C.GDBusSubtreeFlags

const (
	DBUS_SUBTREE_FLAGS_NONE                           DBusSubtreeFlags = 0
	DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES DBusSubtreeFlags = 1
)

type DriveStartFlags C.GDriveStartFlags

const (
	DRIVE_START_NONE DriveStartFlags = 0
)

type FileAttributeInfoFlags C.GFileAttributeInfoFlags

const (
	FILE_ATTRIBUTE_INFO_NONE            FileAttributeInfoFlags = 0
	FILE_ATTRIBUTE_INFO_COPY_WITH_FILE  FileAttributeInfoFlags = 1
	FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED FileAttributeInfoFlags = 2
)

type FileCopyFlags C.GFileCopyFlags

const (
	FILE_COPY_NONE                 FileCopyFlags = 0
	FILE_COPY_OVERWRITE            FileCopyFlags = 1
	FILE_COPY_BACKUP               FileCopyFlags = 2
	FILE_COPY_NOFOLLOW_SYMLINKS    FileCopyFlags = 4
	FILE_COPY_ALL_METADATA         FileCopyFlags = 8
	FILE_COPY_NO_FALLBACK_FOR_MOVE FileCopyFlags = 16
	FILE_COPY_TARGET_DEFAULT_PERMS FileCopyFlags = 32
)

type FileCreateFlags C.GFileCreateFlags

const (
	FILE_CREATE_NONE                FileCreateFlags = 0
	FILE_CREATE_PRIVATE             FileCreateFlags = 1
	FILE_CREATE_REPLACE_DESTINATION FileCreateFlags = 2
)

type FileMonitorFlags C.GFileMonitorFlags

const (
	FILE_MONITOR_NONE             FileMonitorFlags = 0
	FILE_MONITOR_WATCH_MOUNTS     FileMonitorFlags = 1
	FILE_MONITOR_SEND_MOVED       FileMonitorFlags = 2
	FILE_MONITOR_WATCH_HARD_LINKS FileMonitorFlags = 4
	FILE_MONITOR_WATCH_MOVES      FileMonitorFlags = 8
)

type FileQueryInfoFlags C.GFileQueryInfoFlags

const (
	FILE_QUERY_INFO_NONE              FileQueryInfoFlags = 0
	FILE_QUERY_INFO_NOFOLLOW_SYMLINKS FileQueryInfoFlags = 1
)

type IOStreamSpliceFlags C.GIOStreamSpliceFlags

const (
	IO_STREAM_SPLICE_NONE          IOStreamSpliceFlags = 0
	IO_STREAM_SPLICE_CLOSE_STREAM1 IOStreamSpliceFlags = 1
	IO_STREAM_SPLICE_CLOSE_STREAM2 IOStreamSpliceFlags = 2
	IO_STREAM_SPLICE_WAIT_FOR_BOTH IOStreamSpliceFlags = 4
)

type MountMountFlags C.GMountMountFlags

const (
	MOUNT_MOUNT_NONE MountMountFlags = 0
)

type MountUnmountFlags C.GMountUnmountFlags

const (
	MOUNT_UNMOUNT_NONE  MountUnmountFlags = 0
	MOUNT_UNMOUNT_FORCE MountUnmountFlags = 1
)

type OutputStreamSpliceFlags C.GOutputStreamSpliceFlags

const (
	OUTPUT_STREAM_SPLICE_NONE         OutputStreamSpliceFlags = 0
	OUTPUT_STREAM_SPLICE_CLOSE_SOURCE OutputStreamSpliceFlags = 1
	OUTPUT_STREAM_SPLICE_CLOSE_TARGET OutputStreamSpliceFlags = 2
)

type ResourceFlags C.GResourceFlags

const (
	RESOURCE_FLAGS_NONE       ResourceFlags = 0
	RESOURCE_FLAGS_COMPRESSED ResourceFlags = 1
)

type ResourceLookupFlags C.GResourceLookupFlags

const (
	RESOURCE_LOOKUP_FLAGS_NONE ResourceLookupFlags = 0
)

type SettingsBindFlags C.GSettingsBindFlags

const (
	SETTINGS_BIND_DEFAULT        SettingsBindFlags = 0
	SETTINGS_BIND_GET            SettingsBindFlags = 1
	SETTINGS_BIND_SET            SettingsBindFlags = 2
	SETTINGS_BIND_NO_SENSITIVITY SettingsBindFlags = 4
	SETTINGS_BIND_GET_NO_CHANGES SettingsBindFlags = 8
	SETTINGS_BIND_INVERT_BOOLEAN SettingsBindFlags = 16
)

type SocketMsgFlags C.GSocketMsgFlags

const (
	SOCKET_MSG_NONE      SocketMsgFlags = 0
	SOCKET_MSG_OOB       SocketMsgFlags = 1
	SOCKET_MSG_PEEK      SocketMsgFlags = 2
	SOCKET_MSG_DONTROUTE SocketMsgFlags = 4
)

type TestDBusFlags C.GTestDBusFlags

const (
	TEST_DBUS_NONE TestDBusFlags = 0
)

type TlsCertificateFlags C.GTlsCertificateFlags

const (
	TLS_CERTIFICATE_UNKNOWN_CA    TlsCertificateFlags = 1
	TLS_CERTIFICATE_BAD_IDENTITY  TlsCertificateFlags = 2
	TLS_CERTIFICATE_NOT_ACTIVATED TlsCertificateFlags = 4
	TLS_CERTIFICATE_EXPIRED       TlsCertificateFlags = 8
	TLS_CERTIFICATE_REVOKED       TlsCertificateFlags = 16
	TLS_CERTIFICATE_INSECURE      TlsCertificateFlags = 32
	TLS_CERTIFICATE_GENERIC_ERROR TlsCertificateFlags = 64
	TLS_CERTIFICATE_VALIDATE_ALL  TlsCertificateFlags = 127
)

type TlsDatabaseVerifyFlags C.GTlsDatabaseVerifyFlags

const (
	TLS_DATABASE_VERIFY_NONE TlsDatabaseVerifyFlags = 0
)

type TlsPasswordFlags C.GTlsPasswordFlags

const (
	TLS_PASSWORD_NONE       TlsPasswordFlags = 0
	TLS_PASSWORD_RETRY      TlsPasswordFlags = 2
	TLS_PASSWORD_MANY_TRIES TlsPasswordFlags = 4
	TLS_PASSWORD_FINAL_TRY  TlsPasswordFlags = 8
)

// AppLaunchContext is a wrapper around the C record GAppLaunchContext.
type AppLaunchContext struct {
	native *C.GAppLaunchContext
	// parent_instance : record
	// Private : priv
}

func AppLaunchContextNewFromC(u unsafe.Pointer) *AppLaunchContext {
	c := (*C.GAppLaunchContext)(u)
	if c == nil {
		return nil
	}

	g := &AppLaunchContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AppLaunchContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AppLaunchContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppLaunchContext with another AppLaunchContext, and returns true if they represent the same GObject.
func (recv *AppLaunchContext) Equals(other *AppLaunchContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *AppLaunchContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to AppLaunchContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppLaunchContext.
func CastToAppLaunchContext(object *gobject.Object) *AppLaunchContext {
	return AppLaunchContextNewFromC(object.ToC())
}

type signalAppLaunchContextLaunchFailedDetail struct {
	callback  AppLaunchContextSignalLaunchFailedCallback
	handlerID C.gulong
}

var signalAppLaunchContextLaunchFailedId int
var signalAppLaunchContextLaunchFailedMap = make(map[int]signalAppLaunchContextLaunchFailedDetail)
var signalAppLaunchContextLaunchFailedLock sync.RWMutex

// AppLaunchContextSignalLaunchFailedCallback is a callback function for a 'launch-failed' signal emitted from a AppLaunchContext.
type AppLaunchContextSignalLaunchFailedCallback func(startupNotifyId string)

/*
ConnectLaunchFailed connects the callback to the 'launch-failed' signal for the AppLaunchContext.

The returned value represents the connection, and may be passed to DisconnectLaunchFailed to remove it.
*/
func (recv *AppLaunchContext) ConnectLaunchFailed(callback AppLaunchContextSignalLaunchFailedCallback) int {
	signalAppLaunchContextLaunchFailedLock.Lock()
	defer signalAppLaunchContextLaunchFailedLock.Unlock()

	signalAppLaunchContextLaunchFailedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppLaunchContext_signal_connect_launch_failed(instance, C.gpointer(uintptr(signalAppLaunchContextLaunchFailedId)))

	detail := signalAppLaunchContextLaunchFailedDetail{callback, handlerID}
	signalAppLaunchContextLaunchFailedMap[signalAppLaunchContextLaunchFailedId] = detail

	return signalAppLaunchContextLaunchFailedId
}

/*
DisconnectLaunchFailed disconnects a callback from the 'launch-failed' signal for the AppLaunchContext.

The connectionID should be a value returned from a call to ConnectLaunchFailed.
*/
func (recv *AppLaunchContext) DisconnectLaunchFailed(connectionID int) {
	signalAppLaunchContextLaunchFailedLock.Lock()
	defer signalAppLaunchContextLaunchFailedLock.Unlock()

	detail, exists := signalAppLaunchContextLaunchFailedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppLaunchContextLaunchFailedMap, connectionID)
}

//export applaunchcontext_launchFailedHandler
func applaunchcontext_launchFailedHandler(_ *C.GObject, c_startup_notify_id *C.gchar, data C.gpointer) {
	signalAppLaunchContextLaunchFailedLock.RLock()
	defer signalAppLaunchContextLaunchFailedLock.RUnlock()

	startupNotifyId := C.GoString(c_startup_notify_id)

	index := int(uintptr(data))
	callback := signalAppLaunchContextLaunchFailedMap[index].callback
	callback(startupNotifyId)
}

type signalAppLaunchContextLaunchedDetail struct {
	callback  AppLaunchContextSignalLaunchedCallback
	handlerID C.gulong
}

var signalAppLaunchContextLaunchedId int
var signalAppLaunchContextLaunchedMap = make(map[int]signalAppLaunchContextLaunchedDetail)
var signalAppLaunchContextLaunchedLock sync.RWMutex

// AppLaunchContextSignalLaunchedCallback is a callback function for a 'launched' signal emitted from a AppLaunchContext.
type AppLaunchContextSignalLaunchedCallback func(info *AppInfo, platformData *glib.Variant)

/*
ConnectLaunched connects the callback to the 'launched' signal for the AppLaunchContext.

The returned value represents the connection, and may be passed to DisconnectLaunched to remove it.
*/
func (recv *AppLaunchContext) ConnectLaunched(callback AppLaunchContextSignalLaunchedCallback) int {
	signalAppLaunchContextLaunchedLock.Lock()
	defer signalAppLaunchContextLaunchedLock.Unlock()

	signalAppLaunchContextLaunchedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppLaunchContext_signal_connect_launched(instance, C.gpointer(uintptr(signalAppLaunchContextLaunchedId)))

	detail := signalAppLaunchContextLaunchedDetail{callback, handlerID}
	signalAppLaunchContextLaunchedMap[signalAppLaunchContextLaunchedId] = detail

	return signalAppLaunchContextLaunchedId
}

/*
DisconnectLaunched disconnects a callback from the 'launched' signal for the AppLaunchContext.

The connectionID should be a value returned from a call to ConnectLaunched.
*/
func (recv *AppLaunchContext) DisconnectLaunched(connectionID int) {
	signalAppLaunchContextLaunchedLock.Lock()
	defer signalAppLaunchContextLaunchedLock.Unlock()

	detail, exists := signalAppLaunchContextLaunchedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppLaunchContextLaunchedMap, connectionID)
}

//export applaunchcontext_launchedHandler
func applaunchcontext_launchedHandler(_ *C.GObject, c_info *C.GAppInfo, c_platform_data *C.GVariant, data C.gpointer) {
	signalAppLaunchContextLaunchedLock.RLock()
	defer signalAppLaunchContextLaunchedLock.RUnlock()

	info := AppInfoNewFromC(unsafe.Pointer(c_info))

	platformData := glib.VariantNewFromC(unsafe.Pointer(c_platform_data))

	index := int(uintptr(data))
	callback := signalAppLaunchContextLaunchedMap[index].callback
	callback(info, platformData)
}

// AppLaunchContextNew is a wrapper around the C function g_app_launch_context_new.
func AppLaunchContextNew() *AppLaunchContext {
	retC := C.g_app_launch_context_new()
	retGo := AppLaunchContextNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetDisplay is a wrapper around the C function g_app_launch_context_get_display.
func (recv *AppLaunchContext) GetDisplay(info *AppInfo, files *glib.List) string {
	c_info := (*C.GAppInfo)(info.ToC())

	c_files := (*C.GList)(C.NULL)
	if files != nil {
		c_files = (*C.GList)(files.ToC())
	}

	retC := C.g_app_launch_context_get_display((*C.GAppLaunchContext)(recv.native), c_info, c_files)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetEnvironment is a wrapper around the C function g_app_launch_context_get_environment.
func (recv *AppLaunchContext) GetEnvironment() []string {
	retC := C.g_app_launch_context_get_environment((*C.GAppLaunchContext)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// GetStartupNotifyId is a wrapper around the C function g_app_launch_context_get_startup_notify_id.
func (recv *AppLaunchContext) GetStartupNotifyId(info *AppInfo, files *glib.List) string {
	c_info := (*C.GAppInfo)(info.ToC())

	c_files := (*C.GList)(C.NULL)
	if files != nil {
		c_files = (*C.GList)(files.ToC())
	}

	retC := C.g_app_launch_context_get_startup_notify_id((*C.GAppLaunchContext)(recv.native), c_info, c_files)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// LaunchFailed is a wrapper around the C function g_app_launch_context_launch_failed.
func (recv *AppLaunchContext) LaunchFailed(startupNotifyId string) {
	c_startup_notify_id := C.CString(startupNotifyId)
	defer C.free(unsafe.Pointer(c_startup_notify_id))

	C.g_app_launch_context_launch_failed((*C.GAppLaunchContext)(recv.native), c_startup_notify_id)

	return
}

// Setenv is a wrapper around the C function g_app_launch_context_setenv.
func (recv *AppLaunchContext) Setenv(variable string, value string) {
	c_variable := C.CString(variable)
	defer C.free(unsafe.Pointer(c_variable))

	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.g_app_launch_context_setenv((*C.GAppLaunchContext)(recv.native), c_variable, c_value)

	return
}

// Unsetenv is a wrapper around the C function g_app_launch_context_unsetenv.
func (recv *AppLaunchContext) Unsetenv(variable string) {
	c_variable := C.CString(variable)
	defer C.free(unsafe.Pointer(c_variable))

	C.g_app_launch_context_unsetenv((*C.GAppLaunchContext)(recv.native), c_variable)

	return
}

// Application is a wrapper around the C record GApplication.
type Application struct {
	native *C.GApplication
	// Private : parent_instance
	// Private : priv
}

func ApplicationNewFromC(u unsafe.Pointer) *Application {
	c := (*C.GApplication)(u)
	if c == nil {
		return nil
	}

	g := &Application{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Application) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Application) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Application with another Application, and returns true if they represent the same GObject.
func (recv *Application) Equals(other *Application) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Application) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Application.
// Exercise care, as this is a potentially dangerous function if the Object is not a Application.
func CastToApplication(object *gobject.Object) *Application {
	return ApplicationNewFromC(object.ToC())
}

type signalApplicationActivateDetail struct {
	callback  ApplicationSignalActivateCallback
	handlerID C.gulong
}

var signalApplicationActivateId int
var signalApplicationActivateMap = make(map[int]signalApplicationActivateDetail)
var signalApplicationActivateLock sync.RWMutex

// ApplicationSignalActivateCallback is a callback function for a 'activate' signal emitted from a Application.
type ApplicationSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Application.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Application) ConnectActivate(callback ApplicationSignalActivateCallback) int {
	signalApplicationActivateLock.Lock()
	defer signalApplicationActivateLock.Unlock()

	signalApplicationActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Application_signal_connect_activate(instance, C.gpointer(uintptr(signalApplicationActivateId)))

	detail := signalApplicationActivateDetail{callback, handlerID}
	signalApplicationActivateMap[signalApplicationActivateId] = detail

	return signalApplicationActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Application.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Application) DisconnectActivate(connectionID int) {
	signalApplicationActivateLock.Lock()
	defer signalApplicationActivateLock.Unlock()

	detail, exists := signalApplicationActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalApplicationActivateMap, connectionID)
}

//export application_activateHandler
func application_activateHandler(_ *C.GObject, data C.gpointer) {
	signalApplicationActivateLock.RLock()
	defer signalApplicationActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalApplicationActivateMap[index].callback
	callback()
}

type signalApplicationCommandLineDetail struct {
	callback  ApplicationSignalCommandLineCallback
	handlerID C.gulong
}

var signalApplicationCommandLineId int
var signalApplicationCommandLineMap = make(map[int]signalApplicationCommandLineDetail)
var signalApplicationCommandLineLock sync.RWMutex

// ApplicationSignalCommandLineCallback is a callback function for a 'command-line' signal emitted from a Application.
type ApplicationSignalCommandLineCallback func(commandLine *ApplicationCommandLine) int32

/*
ConnectCommandLine connects the callback to the 'command-line' signal for the Application.

The returned value represents the connection, and may be passed to DisconnectCommandLine to remove it.
*/
func (recv *Application) ConnectCommandLine(callback ApplicationSignalCommandLineCallback) int {
	signalApplicationCommandLineLock.Lock()
	defer signalApplicationCommandLineLock.Unlock()

	signalApplicationCommandLineId++
	instance := C.gpointer(recv.native)
	handlerID := C.Application_signal_connect_command_line(instance, C.gpointer(uintptr(signalApplicationCommandLineId)))

	detail := signalApplicationCommandLineDetail{callback, handlerID}
	signalApplicationCommandLineMap[signalApplicationCommandLineId] = detail

	return signalApplicationCommandLineId
}

/*
DisconnectCommandLine disconnects a callback from the 'command-line' signal for the Application.

The connectionID should be a value returned from a call to ConnectCommandLine.
*/
func (recv *Application) DisconnectCommandLine(connectionID int) {
	signalApplicationCommandLineLock.Lock()
	defer signalApplicationCommandLineLock.Unlock()

	detail, exists := signalApplicationCommandLineMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalApplicationCommandLineMap, connectionID)
}

//export application_commandLineHandler
func application_commandLineHandler(_ *C.GObject, c_command_line *C.GApplicationCommandLine, data C.gpointer) C.gint {
	signalApplicationCommandLineLock.RLock()
	defer signalApplicationCommandLineLock.RUnlock()

	commandLine := ApplicationCommandLineNewFromC(unsafe.Pointer(c_command_line))

	index := int(uintptr(data))
	callback := signalApplicationCommandLineMap[index].callback
	retGo := callback(commandLine)
	retC :=
		(C.gint)(retGo)
	return retC
}

type signalApplicationOpenDetail struct {
	callback  ApplicationSignalOpenCallback
	handlerID C.gulong
}

var signalApplicationOpenId int
var signalApplicationOpenMap = make(map[int]signalApplicationOpenDetail)
var signalApplicationOpenLock sync.RWMutex

// ApplicationSignalOpenCallback is a callback function for a 'open' signal emitted from a Application.
type ApplicationSignalOpenCallback func(files []*File, hint string)

/*
ConnectOpen connects the callback to the 'open' signal for the Application.

The returned value represents the connection, and may be passed to DisconnectOpen to remove it.
*/
func (recv *Application) ConnectOpen(callback ApplicationSignalOpenCallback) int {
	signalApplicationOpenLock.Lock()
	defer signalApplicationOpenLock.Unlock()

	signalApplicationOpenId++
	instance := C.gpointer(recv.native)
	handlerID := C.Application_signal_connect_open(instance, C.gpointer(uintptr(signalApplicationOpenId)))

	detail := signalApplicationOpenDetail{callback, handlerID}
	signalApplicationOpenMap[signalApplicationOpenId] = detail

	return signalApplicationOpenId
}

/*
DisconnectOpen disconnects a callback from the 'open' signal for the Application.

The connectionID should be a value returned from a call to ConnectOpen.
*/
func (recv *Application) DisconnectOpen(connectionID int) {
	signalApplicationOpenLock.Lock()
	defer signalApplicationOpenLock.Unlock()

	detail, exists := signalApplicationOpenMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalApplicationOpenMap, connectionID)
}

//export application_openHandler
func application_openHandler(_ *C.GObject, c_files C.gpointer, c_n_files C.gint, c_hint *C.gchar, data C.gpointer) {
	signalApplicationOpenLock.RLock()
	defer signalApplicationOpenLock.RUnlock()

	files := make([]*File, int(c_n_files), int(c_n_files))
	for i := 0; i < int(c_n_files); i++ {
		_item := FileNewFromC(unsafe.Pointer(*(*C.gpointer)(c_files)))
		files[i] = _item
		c_files = C.gpointer(uintptr(c_files) + uintptr(C.sizeof_gpointer))
	}

	hint := C.GoString(c_hint)

	index := int(uintptr(data))
	callback := signalApplicationOpenMap[index].callback
	callback(files, hint)
}

type signalApplicationShutdownDetail struct {
	callback  ApplicationSignalShutdownCallback
	handlerID C.gulong
}

var signalApplicationShutdownId int
var signalApplicationShutdownMap = make(map[int]signalApplicationShutdownDetail)
var signalApplicationShutdownLock sync.RWMutex

// ApplicationSignalShutdownCallback is a callback function for a 'shutdown' signal emitted from a Application.
type ApplicationSignalShutdownCallback func()

/*
ConnectShutdown connects the callback to the 'shutdown' signal for the Application.

The returned value represents the connection, and may be passed to DisconnectShutdown to remove it.
*/
func (recv *Application) ConnectShutdown(callback ApplicationSignalShutdownCallback) int {
	signalApplicationShutdownLock.Lock()
	defer signalApplicationShutdownLock.Unlock()

	signalApplicationShutdownId++
	instance := C.gpointer(recv.native)
	handlerID := C.Application_signal_connect_shutdown(instance, C.gpointer(uintptr(signalApplicationShutdownId)))

	detail := signalApplicationShutdownDetail{callback, handlerID}
	signalApplicationShutdownMap[signalApplicationShutdownId] = detail

	return signalApplicationShutdownId
}

/*
DisconnectShutdown disconnects a callback from the 'shutdown' signal for the Application.

The connectionID should be a value returned from a call to ConnectShutdown.
*/
func (recv *Application) DisconnectShutdown(connectionID int) {
	signalApplicationShutdownLock.Lock()
	defer signalApplicationShutdownLock.Unlock()

	detail, exists := signalApplicationShutdownMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalApplicationShutdownMap, connectionID)
}

//export application_shutdownHandler
func application_shutdownHandler(_ *C.GObject, data C.gpointer) {
	signalApplicationShutdownLock.RLock()
	defer signalApplicationShutdownLock.RUnlock()

	index := int(uintptr(data))
	callback := signalApplicationShutdownMap[index].callback
	callback()
}

type signalApplicationStartupDetail struct {
	callback  ApplicationSignalStartupCallback
	handlerID C.gulong
}

var signalApplicationStartupId int
var signalApplicationStartupMap = make(map[int]signalApplicationStartupDetail)
var signalApplicationStartupLock sync.RWMutex

// ApplicationSignalStartupCallback is a callback function for a 'startup' signal emitted from a Application.
type ApplicationSignalStartupCallback func()

/*
ConnectStartup connects the callback to the 'startup' signal for the Application.

The returned value represents the connection, and may be passed to DisconnectStartup to remove it.
*/
func (recv *Application) ConnectStartup(callback ApplicationSignalStartupCallback) int {
	signalApplicationStartupLock.Lock()
	defer signalApplicationStartupLock.Unlock()

	signalApplicationStartupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Application_signal_connect_startup(instance, C.gpointer(uintptr(signalApplicationStartupId)))

	detail := signalApplicationStartupDetail{callback, handlerID}
	signalApplicationStartupMap[signalApplicationStartupId] = detail

	return signalApplicationStartupId
}

/*
DisconnectStartup disconnects a callback from the 'startup' signal for the Application.

The connectionID should be a value returned from a call to ConnectStartup.
*/
func (recv *Application) DisconnectStartup(connectionID int) {
	signalApplicationStartupLock.Lock()
	defer signalApplicationStartupLock.Unlock()

	detail, exists := signalApplicationStartupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalApplicationStartupMap, connectionID)
}

//export application_startupHandler
func application_startupHandler(_ *C.GObject, data C.gpointer) {
	signalApplicationStartupLock.RLock()
	defer signalApplicationStartupLock.RUnlock()

	index := int(uintptr(data))
	callback := signalApplicationStartupMap[index].callback
	callback()
}

// ApplicationNew is a wrapper around the C function g_application_new.
func ApplicationNew(applicationId string, flags ApplicationFlags) *Application {
	c_application_id := C.CString(applicationId)
	defer C.free(unsafe.Pointer(c_application_id))

	c_flags := (C.GApplicationFlags)(flags)

	retC := C.g_application_new(c_application_id, c_flags)
	retGo := ApplicationNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// ApplicationGetDefault is a wrapper around the C function g_application_get_default.
func ApplicationGetDefault() *Application {
	retC := C.g_application_get_default()
	retGo := ApplicationNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ApplicationIdIsValid is a wrapper around the C function g_application_id_is_valid.
func ApplicationIdIsValid(applicationId string) bool {
	c_application_id := C.CString(applicationId)
	defer C.free(unsafe.Pointer(c_application_id))

	retC := C.g_application_id_is_valid(c_application_id)
	retGo := retC == C.TRUE

	return retGo
}

// Activate is a wrapper around the C function g_application_activate.
func (recv *Application) Activate() {
	C.g_application_activate((*C.GApplication)(recv.native))

	return
}

// GetApplicationId is a wrapper around the C function g_application_get_application_id.
func (recv *Application) GetApplicationId() string {
	retC := C.g_application_get_application_id((*C.GApplication)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDbusConnection is a wrapper around the C function g_application_get_dbus_connection.
func (recv *Application) GetDbusConnection() *DBusConnection {
	retC := C.g_application_get_dbus_connection((*C.GApplication)(recv.native))
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDbusObjectPath is a wrapper around the C function g_application_get_dbus_object_path.
func (recv *Application) GetDbusObjectPath() string {
	retC := C.g_application_get_dbus_object_path((*C.GApplication)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetFlags is a wrapper around the C function g_application_get_flags.
func (recv *Application) GetFlags() ApplicationFlags {
	retC := C.g_application_get_flags((*C.GApplication)(recv.native))
	retGo := (ApplicationFlags)(retC)

	return retGo
}

// GetInactivityTimeout is a wrapper around the C function g_application_get_inactivity_timeout.
func (recv *Application) GetInactivityTimeout() uint32 {
	retC := C.g_application_get_inactivity_timeout((*C.GApplication)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetIsRegistered is a wrapper around the C function g_application_get_is_registered.
func (recv *Application) GetIsRegistered() bool {
	retC := C.g_application_get_is_registered((*C.GApplication)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsRemote is a wrapper around the C function g_application_get_is_remote.
func (recv *Application) GetIsRemote() bool {
	retC := C.g_application_get_is_remote((*C.GApplication)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Hold is a wrapper around the C function g_application_hold.
func (recv *Application) Hold() {
	C.g_application_hold((*C.GApplication)(recv.native))

	return
}

// Unsupported : g_application_open : unsupported parameter files :

// Quit is a wrapper around the C function g_application_quit.
func (recv *Application) Quit() {
	C.g_application_quit((*C.GApplication)(recv.native))

	return
}

// Register is a wrapper around the C function g_application_register.
func (recv *Application) Register(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_application_register((*C.GApplication)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Release is a wrapper around the C function g_application_release.
func (recv *Application) Release() {
	C.g_application_release((*C.GApplication)(recv.native))

	return
}

// Run is a wrapper around the C function g_application_run.
func (recv *Application) Run(args []string) int32 {
	cArgc, cArgv := argsIn(args)

	retC := C.g_application_run((*C.GApplication)(recv.native), cArgc, cArgv)
	retGo := (int32)(retC)

	return retGo
}

// SetActionGroup is a wrapper around the C function g_application_set_action_group.
func (recv *Application) SetActionGroup(actionGroup *ActionGroup) {
	c_action_group := (*C.GActionGroup)(actionGroup.ToC())

	C.g_application_set_action_group((*C.GApplication)(recv.native), c_action_group)

	return
}

// SetApplicationId is a wrapper around the C function g_application_set_application_id.
func (recv *Application) SetApplicationId(applicationId string) {
	c_application_id := C.CString(applicationId)
	defer C.free(unsafe.Pointer(c_application_id))

	C.g_application_set_application_id((*C.GApplication)(recv.native), c_application_id)

	return
}

// SetDefault is a wrapper around the C function g_application_set_default.
func (recv *Application) SetDefault() {
	C.g_application_set_default((*C.GApplication)(recv.native))

	return
}

// SetFlags is a wrapper around the C function g_application_set_flags.
func (recv *Application) SetFlags(flags ApplicationFlags) {
	c_flags := (C.GApplicationFlags)(flags)

	C.g_application_set_flags((*C.GApplication)(recv.native), c_flags)

	return
}

// SetInactivityTimeout is a wrapper around the C function g_application_set_inactivity_timeout.
func (recv *Application) SetInactivityTimeout(inactivityTimeout uint32) {
	c_inactivity_timeout := (C.guint)(inactivityTimeout)

	C.g_application_set_inactivity_timeout((*C.GApplication)(recv.native), c_inactivity_timeout)

	return
}

// ActionGroup returns the ActionGroup interface implemented by Application
func (recv *Application) ActionGroup() *ActionGroup {
	return ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by Application
func (recv *Application) ActionMap() *ActionMap {
	return ActionMapNewFromC(recv.ToC())
}

// ApplicationCommandLine is a wrapper around the C record GApplicationCommandLine.
type ApplicationCommandLine struct {
	native *C.GApplicationCommandLine
	// Private : parent_instance
	// Private : priv
}

func ApplicationCommandLineNewFromC(u unsafe.Pointer) *ApplicationCommandLine {
	c := (*C.GApplicationCommandLine)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationCommandLine{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ApplicationCommandLine) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ApplicationCommandLine) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationCommandLine with another ApplicationCommandLine, and returns true if they represent the same GObject.
func (recv *ApplicationCommandLine) Equals(other *ApplicationCommandLine) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ApplicationCommandLine) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ApplicationCommandLine.
// Exercise care, as this is a potentially dangerous function if the Object is not a ApplicationCommandLine.
func CastToApplicationCommandLine(object *gobject.Object) *ApplicationCommandLine {
	return ApplicationCommandLineNewFromC(object.ToC())
}

// CreateFileForArg is a wrapper around the C function g_application_command_line_create_file_for_arg.
func (recv *ApplicationCommandLine) CreateFileForArg(arg string) *File {
	c_arg := C.CString(arg)
	defer C.free(unsafe.Pointer(c_arg))

	retC := C.g_application_command_line_create_file_for_arg((*C.GApplicationCommandLine)(recv.native), c_arg)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetArguments is a wrapper around the C function g_application_command_line_get_arguments.
func (recv *ApplicationCommandLine) GetArguments() ([]string, int32) {
	var c_argc C.int

	retC := C.g_application_command_line_get_arguments((*C.GApplicationCommandLine)(recv.native), &c_argc)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	argc := (int32)(c_argc)

	return retGo, argc
}

// GetCwd is a wrapper around the C function g_application_command_line_get_cwd.
func (recv *ApplicationCommandLine) GetCwd() string {
	retC := C.g_application_command_line_get_cwd((*C.GApplicationCommandLine)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetEnviron is a wrapper around the C function g_application_command_line_get_environ.
func (recv *ApplicationCommandLine) GetEnviron() []string {
	retC := C.g_application_command_line_get_environ((*C.GApplicationCommandLine)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// GetExitStatus is a wrapper around the C function g_application_command_line_get_exit_status.
func (recv *ApplicationCommandLine) GetExitStatus() int32 {
	retC := C.g_application_command_line_get_exit_status((*C.GApplicationCommandLine)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetIsRemote is a wrapper around the C function g_application_command_line_get_is_remote.
func (recv *ApplicationCommandLine) GetIsRemote() bool {
	retC := C.g_application_command_line_get_is_remote((*C.GApplicationCommandLine)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPlatformData is a wrapper around the C function g_application_command_line_get_platform_data.
func (recv *ApplicationCommandLine) GetPlatformData() *glib.Variant {
	retC := C.g_application_command_line_get_platform_data((*C.GApplicationCommandLine)(recv.native))
	var retGo (*glib.Variant)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetStdin is a wrapper around the C function g_application_command_line_get_stdin.
func (recv *ApplicationCommandLine) GetStdin() *InputStream {
	retC := C.g_application_command_line_get_stdin((*C.GApplicationCommandLine)(recv.native))
	retGo := InputStreamNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Getenv is a wrapper around the C function g_application_command_line_getenv.
func (recv *ApplicationCommandLine) Getenv(name string) string {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_application_command_line_getenv((*C.GApplicationCommandLine)(recv.native), c_name)
	retGo := C.GoString(retC)

	return retGo
}

// Print is a wrapper around the C function g_application_command_line_print.
func (recv *ApplicationCommandLine) Print(format string, args ...interface{}) {
	goFormattedString := fmt.Sprintf(format, args...)
	c_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format))

	C._g_application_command_line_print((*C.GApplicationCommandLine)(recv.native), c_format)

	return
}

// Printerr is a wrapper around the C function g_application_command_line_printerr.
func (recv *ApplicationCommandLine) Printerr(format string, args ...interface{}) {
	goFormattedString := fmt.Sprintf(format, args...)
	c_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format))

	C._g_application_command_line_printerr((*C.GApplicationCommandLine)(recv.native), c_format)

	return
}

// SetExitStatus is a wrapper around the C function g_application_command_line_set_exit_status.
func (recv *ApplicationCommandLine) SetExitStatus(exitStatus int32) {
	c_exit_status := (C.int)(exitStatus)

	C.g_application_command_line_set_exit_status((*C.GApplicationCommandLine)(recv.native), c_exit_status)

	return
}

// BufferedInputStream is a wrapper around the C record GBufferedInputStream.
type BufferedInputStream struct {
	native *C.GBufferedInputStream
	// parent_instance : record
	// Private : priv
}

func BufferedInputStreamNewFromC(u unsafe.Pointer) *BufferedInputStream {
	c := (*C.GBufferedInputStream)(u)
	if c == nil {
		return nil
	}

	g := &BufferedInputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *BufferedInputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *BufferedInputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BufferedInputStream with another BufferedInputStream, and returns true if they represent the same GObject.
func (recv *BufferedInputStream) Equals(other *BufferedInputStream) bool {
	return other.ToC() == recv.ToC()
}

// FilterInputStream upcasts to *FilterInputStream
func (recv *BufferedInputStream) FilterInputStream() *FilterInputStream {
	return FilterInputStreamNewFromC(unsafe.Pointer(recv.native))
}

// InputStream upcasts to *InputStream
func (recv *BufferedInputStream) InputStream() *InputStream {
	return recv.FilterInputStream().InputStream()
}

// Object upcasts to *Object
func (recv *BufferedInputStream) Object() *gobject.Object {
	return recv.FilterInputStream().Object()
}

// CastToWidget down casts any arbitrary Object to BufferedInputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a BufferedInputStream.
func CastToBufferedInputStream(object *gobject.Object) *BufferedInputStream {
	return BufferedInputStreamNewFromC(object.ToC())
}

// BufferedInputStreamNew is a wrapper around the C function g_buffered_input_stream_new.
func BufferedInputStreamNew(baseStream *InputStream) *BufferedInputStream {
	c_base_stream := (*C.GInputStream)(C.NULL)
	if baseStream != nil {
		c_base_stream = (*C.GInputStream)(baseStream.ToC())
	}

	retC := C.g_buffered_input_stream_new(c_base_stream)
	retGo := BufferedInputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// BufferedInputStreamNewSized is a wrapper around the C function g_buffered_input_stream_new_sized.
func BufferedInputStreamNewSized(baseStream *InputStream, size uint64) *BufferedInputStream {
	c_base_stream := (*C.GInputStream)(C.NULL)
	if baseStream != nil {
		c_base_stream = (*C.GInputStream)(baseStream.ToC())
	}

	c_size := (C.gsize)(size)

	retC := C.g_buffered_input_stream_new_sized(c_base_stream, c_size)
	retGo := BufferedInputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Fill is a wrapper around the C function g_buffered_input_stream_fill.
func (recv *BufferedInputStream) Fill(count int64, cancellable *Cancellable) (int64, error) {
	c_count := (C.gssize)(count)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_buffered_input_stream_fill((*C.GBufferedInputStream)(recv.native), c_count, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_buffered_input_stream_fill_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// FillFinish is a wrapper around the C function g_buffered_input_stream_fill_finish.
func (recv *BufferedInputStream) FillFinish(result *AsyncResult) (int64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_buffered_input_stream_fill_finish((*C.GBufferedInputStream)(recv.native), c_result, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetAvailable is a wrapper around the C function g_buffered_input_stream_get_available.
func (recv *BufferedInputStream) GetAvailable() uint64 {
	retC := C.g_buffered_input_stream_get_available((*C.GBufferedInputStream)(recv.native))
	retGo := (uint64)(retC)

	return retGo
}

// GetBufferSize is a wrapper around the C function g_buffered_input_stream_get_buffer_size.
func (recv *BufferedInputStream) GetBufferSize() uint64 {
	retC := C.g_buffered_input_stream_get_buffer_size((*C.GBufferedInputStream)(recv.native))
	retGo := (uint64)(retC)

	return retGo
}

// Peek is a wrapper around the C function g_buffered_input_stream_peek.
func (recv *BufferedInputStream) Peek(buffer []uint8, offset uint64) uint64 {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_offset := (C.gsize)(offset)

	c_count := (C.gsize)(len(buffer))

	retC := C.g_buffered_input_stream_peek((*C.GBufferedInputStream)(recv.native), c_buffer, c_offset, c_count)
	retGo := (uint64)(retC)

	return retGo
}

// Unsupported : g_buffered_input_stream_peek_buffer : array return type :

// ReadByte is a wrapper around the C function g_buffered_input_stream_read_byte.
func (recv *BufferedInputStream) ReadByte(cancellable *Cancellable) (int32, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_buffered_input_stream_read_byte((*C.GBufferedInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := (int32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetBufferSize is a wrapper around the C function g_buffered_input_stream_set_buffer_size.
func (recv *BufferedInputStream) SetBufferSize(size uint64) {
	c_size := (C.gsize)(size)

	C.g_buffered_input_stream_set_buffer_size((*C.GBufferedInputStream)(recv.native), c_size)

	return
}

// Seekable returns the Seekable interface implemented by BufferedInputStream
func (recv *BufferedInputStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// BufferedOutputStream is a wrapper around the C record GBufferedOutputStream.
type BufferedOutputStream struct {
	native *C.GBufferedOutputStream
	// parent_instance : record
	// priv : record
}

func BufferedOutputStreamNewFromC(u unsafe.Pointer) *BufferedOutputStream {
	c := (*C.GBufferedOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &BufferedOutputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *BufferedOutputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *BufferedOutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BufferedOutputStream with another BufferedOutputStream, and returns true if they represent the same GObject.
func (recv *BufferedOutputStream) Equals(other *BufferedOutputStream) bool {
	return other.ToC() == recv.ToC()
}

// FilterOutputStream upcasts to *FilterOutputStream
func (recv *BufferedOutputStream) FilterOutputStream() *FilterOutputStream {
	return FilterOutputStreamNewFromC(unsafe.Pointer(recv.native))
}

// OutputStream upcasts to *OutputStream
func (recv *BufferedOutputStream) OutputStream() *OutputStream {
	return recv.FilterOutputStream().OutputStream()
}

// Object upcasts to *Object
func (recv *BufferedOutputStream) Object() *gobject.Object {
	return recv.FilterOutputStream().Object()
}

// CastToWidget down casts any arbitrary Object to BufferedOutputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a BufferedOutputStream.
func CastToBufferedOutputStream(object *gobject.Object) *BufferedOutputStream {
	return BufferedOutputStreamNewFromC(object.ToC())
}

// BufferedOutputStreamNew is a wrapper around the C function g_buffered_output_stream_new.
func BufferedOutputStreamNew(baseStream *OutputStream) *BufferedOutputStream {
	c_base_stream := (*C.GOutputStream)(C.NULL)
	if baseStream != nil {
		c_base_stream = (*C.GOutputStream)(baseStream.ToC())
	}

	retC := C.g_buffered_output_stream_new(c_base_stream)
	retGo := BufferedOutputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// BufferedOutputStreamNewSized is a wrapper around the C function g_buffered_output_stream_new_sized.
func BufferedOutputStreamNewSized(baseStream *OutputStream, size uint64) *BufferedOutputStream {
	c_base_stream := (*C.GOutputStream)(C.NULL)
	if baseStream != nil {
		c_base_stream = (*C.GOutputStream)(baseStream.ToC())
	}

	c_size := (C.gsize)(size)

	retC := C.g_buffered_output_stream_new_sized(c_base_stream, c_size)
	retGo := BufferedOutputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetAutoGrow is a wrapper around the C function g_buffered_output_stream_get_auto_grow.
func (recv *BufferedOutputStream) GetAutoGrow() bool {
	retC := C.g_buffered_output_stream_get_auto_grow((*C.GBufferedOutputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetBufferSize is a wrapper around the C function g_buffered_output_stream_get_buffer_size.
func (recv *BufferedOutputStream) GetBufferSize() uint64 {
	retC := C.g_buffered_output_stream_get_buffer_size((*C.GBufferedOutputStream)(recv.native))
	retGo := (uint64)(retC)

	return retGo
}

// SetAutoGrow is a wrapper around the C function g_buffered_output_stream_set_auto_grow.
func (recv *BufferedOutputStream) SetAutoGrow(autoGrow bool) {
	c_auto_grow :=
		boolToGboolean(autoGrow)

	C.g_buffered_output_stream_set_auto_grow((*C.GBufferedOutputStream)(recv.native), c_auto_grow)

	return
}

// SetBufferSize is a wrapper around the C function g_buffered_output_stream_set_buffer_size.
func (recv *BufferedOutputStream) SetBufferSize(size uint64) {
	c_size := (C.gsize)(size)

	C.g_buffered_output_stream_set_buffer_size((*C.GBufferedOutputStream)(recv.native), c_size)

	return
}

// Seekable returns the Seekable interface implemented by BufferedOutputStream
func (recv *BufferedOutputStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// BytesIcon is a wrapper around the C record GBytesIcon.
type BytesIcon struct {
	native *C.GBytesIcon
}

func BytesIconNewFromC(u unsafe.Pointer) *BytesIcon {
	c := (*C.GBytesIcon)(u)
	if c == nil {
		return nil
	}

	g := &BytesIcon{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *BytesIcon) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *BytesIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BytesIcon with another BytesIcon, and returns true if they represent the same GObject.
func (recv *BytesIcon) Equals(other *BytesIcon) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *BytesIcon) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to BytesIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a BytesIcon.
func CastToBytesIcon(object *gobject.Object) *BytesIcon {
	return BytesIconNewFromC(object.ToC())
}

// Icon returns the Icon interface implemented by BytesIcon
func (recv *BytesIcon) Icon() *Icon {
	return IconNewFromC(recv.ToC())
}

// LoadableIcon returns the LoadableIcon interface implemented by BytesIcon
func (recv *BytesIcon) LoadableIcon() *LoadableIcon {
	return LoadableIconNewFromC(recv.ToC())
}

// Cancellable is a wrapper around the C record GCancellable.
type Cancellable struct {
	native *C.GCancellable
	// parent_instance : record
	// Private : priv
}

func CancellableNewFromC(u unsafe.Pointer) *Cancellable {
	c := (*C.GCancellable)(u)
	if c == nil {
		return nil
	}

	g := &Cancellable{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Cancellable) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Cancellable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Cancellable with another Cancellable, and returns true if they represent the same GObject.
func (recv *Cancellable) Equals(other *Cancellable) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Cancellable) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Cancellable.
// Exercise care, as this is a potentially dangerous function if the Object is not a Cancellable.
func CastToCancellable(object *gobject.Object) *Cancellable {
	return CancellableNewFromC(object.ToC())
}

type signalCancellableCancelledDetail struct {
	callback  CancellableSignalCancelledCallback
	handlerID C.gulong
}

var signalCancellableCancelledId int
var signalCancellableCancelledMap = make(map[int]signalCancellableCancelledDetail)
var signalCancellableCancelledLock sync.RWMutex

// CancellableSignalCancelledCallback is a callback function for a 'cancelled' signal emitted from a Cancellable.
type CancellableSignalCancelledCallback func()

/*
ConnectCancelled connects the callback to the 'cancelled' signal for the Cancellable.

The returned value represents the connection, and may be passed to DisconnectCancelled to remove it.
*/
func (recv *Cancellable) ConnectCancelled(callback CancellableSignalCancelledCallback) int {
	signalCancellableCancelledLock.Lock()
	defer signalCancellableCancelledLock.Unlock()

	signalCancellableCancelledId++
	instance := C.gpointer(recv.native)
	handlerID := C.Cancellable_signal_connect_cancelled(instance, C.gpointer(uintptr(signalCancellableCancelledId)))

	detail := signalCancellableCancelledDetail{callback, handlerID}
	signalCancellableCancelledMap[signalCancellableCancelledId] = detail

	return signalCancellableCancelledId
}

/*
DisconnectCancelled disconnects a callback from the 'cancelled' signal for the Cancellable.

The connectionID should be a value returned from a call to ConnectCancelled.
*/
func (recv *Cancellable) DisconnectCancelled(connectionID int) {
	signalCancellableCancelledLock.Lock()
	defer signalCancellableCancelledLock.Unlock()

	detail, exists := signalCancellableCancelledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCancellableCancelledMap, connectionID)
}

//export cancellable_cancelledHandler
func cancellable_cancelledHandler(_ *C.GObject, data C.gpointer) {
	signalCancellableCancelledLock.RLock()
	defer signalCancellableCancelledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCancellableCancelledMap[index].callback
	callback()
}

// CancellableNew is a wrapper around the C function g_cancellable_new.
func CancellableNew() *Cancellable {
	retC := C.g_cancellable_new()
	retGo := CancellableNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// CancellableGetCurrent is a wrapper around the C function g_cancellable_get_current.
func CancellableGetCurrent() *Cancellable {
	retC := C.g_cancellable_get_current()
	var retGo (*Cancellable)
	if retC == nil {
		retGo = nil
	} else {
		retGo = CancellableNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Cancel is a wrapper around the C function g_cancellable_cancel.
func (recv *Cancellable) Cancel() {
	C.g_cancellable_cancel((*C.GCancellable)(recv.native))

	return
}

// Unsupported : g_cancellable_connect : unsupported parameter callback : no type generator for GObject.Callback (GCallback) for param callback

// Disconnect is a wrapper around the C function g_cancellable_disconnect.
func (recv *Cancellable) Disconnect(handlerId uint64) {
	c_handler_id := (C.gulong)(handlerId)

	C.g_cancellable_disconnect((*C.GCancellable)(recv.native), c_handler_id)

	return
}

// GetFd is a wrapper around the C function g_cancellable_get_fd.
func (recv *Cancellable) GetFd() int32 {
	retC := C.g_cancellable_get_fd((*C.GCancellable)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// IsCancelled is a wrapper around the C function g_cancellable_is_cancelled.
func (recv *Cancellable) IsCancelled() bool {
	retC := C.g_cancellable_is_cancelled((*C.GCancellable)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// MakePollfd is a wrapper around the C function g_cancellable_make_pollfd.
func (recv *Cancellable) MakePollfd(pollfd *glib.PollFD) bool {
	c_pollfd := (*C.GPollFD)(C.NULL)
	if pollfd != nil {
		c_pollfd = (*C.GPollFD)(pollfd.ToC())
	}

	retC := C.g_cancellable_make_pollfd((*C.GCancellable)(recv.native), c_pollfd)
	retGo := retC == C.TRUE

	return retGo
}

// PopCurrent is a wrapper around the C function g_cancellable_pop_current.
func (recv *Cancellable) PopCurrent() {
	C.g_cancellable_pop_current((*C.GCancellable)(recv.native))

	return
}

// PushCurrent is a wrapper around the C function g_cancellable_push_current.
func (recv *Cancellable) PushCurrent() {
	C.g_cancellable_push_current((*C.GCancellable)(recv.native))

	return
}

// ReleaseFd is a wrapper around the C function g_cancellable_release_fd.
func (recv *Cancellable) ReleaseFd() {
	C.g_cancellable_release_fd((*C.GCancellable)(recv.native))

	return
}

// Reset is a wrapper around the C function g_cancellable_reset.
func (recv *Cancellable) Reset() {
	C.g_cancellable_reset((*C.GCancellable)(recv.native))

	return
}

// SetErrorIfCancelled is a wrapper around the C function g_cancellable_set_error_if_cancelled.
func (recv *Cancellable) SetErrorIfCancelled() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_cancellable_set_error_if_cancelled((*C.GCancellable)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SourceNew is a wrapper around the C function g_cancellable_source_new.
func (recv *Cancellable) SourceNew() *glib.Source {
	retC := C.g_cancellable_source_new((*C.GCancellable)(recv.native))
	retGo := glib.SourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CharsetConverter is a wrapper around the C record GCharsetConverter.
type CharsetConverter struct {
	native *C.GCharsetConverter
}

func CharsetConverterNewFromC(u unsafe.Pointer) *CharsetConverter {
	c := (*C.GCharsetConverter)(u)
	if c == nil {
		return nil
	}

	g := &CharsetConverter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CharsetConverter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CharsetConverter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CharsetConverter with another CharsetConverter, and returns true if they represent the same GObject.
func (recv *CharsetConverter) Equals(other *CharsetConverter) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *CharsetConverter) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to CharsetConverter.
// Exercise care, as this is a potentially dangerous function if the Object is not a CharsetConverter.
func CastToCharsetConverter(object *gobject.Object) *CharsetConverter {
	return CharsetConverterNewFromC(object.ToC())
}

// CharsetConverterNew is a wrapper around the C function g_charset_converter_new.
func CharsetConverterNew(toCharset string, fromCharset string) (*CharsetConverter, error) {
	c_to_charset := C.CString(toCharset)
	defer C.free(unsafe.Pointer(c_to_charset))

	c_from_charset := C.CString(fromCharset)
	defer C.free(unsafe.Pointer(c_from_charset))

	var cThrowableError *C.GError

	retC := C.g_charset_converter_new(c_to_charset, c_from_charset, &cThrowableError)
	retGo := CharsetConverterNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetNumFallbacks is a wrapper around the C function g_charset_converter_get_num_fallbacks.
func (recv *CharsetConverter) GetNumFallbacks() uint32 {
	retC := C.g_charset_converter_get_num_fallbacks((*C.GCharsetConverter)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetUseFallback is a wrapper around the C function g_charset_converter_get_use_fallback.
func (recv *CharsetConverter) GetUseFallback() bool {
	retC := C.g_charset_converter_get_use_fallback((*C.GCharsetConverter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetUseFallback is a wrapper around the C function g_charset_converter_set_use_fallback.
func (recv *CharsetConverter) SetUseFallback(useFallback bool) {
	c_use_fallback :=
		boolToGboolean(useFallback)

	C.g_charset_converter_set_use_fallback((*C.GCharsetConverter)(recv.native), c_use_fallback)

	return
}

// Converter returns the Converter interface implemented by CharsetConverter
func (recv *CharsetConverter) Converter() *Converter {
	return ConverterNewFromC(recv.ToC())
}

// Initable returns the Initable interface implemented by CharsetConverter
func (recv *CharsetConverter) Initable() *Initable {
	return InitableNewFromC(recv.ToC())
}

// ConverterInputStream is a wrapper around the C record GConverterInputStream.
type ConverterInputStream struct {
	native *C.GConverterInputStream
	// parent_instance : record
	// Private : priv
}

func ConverterInputStreamNewFromC(u unsafe.Pointer) *ConverterInputStream {
	c := (*C.GConverterInputStream)(u)
	if c == nil {
		return nil
	}

	g := &ConverterInputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ConverterInputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ConverterInputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ConverterInputStream with another ConverterInputStream, and returns true if they represent the same GObject.
func (recv *ConverterInputStream) Equals(other *ConverterInputStream) bool {
	return other.ToC() == recv.ToC()
}

// FilterInputStream upcasts to *FilterInputStream
func (recv *ConverterInputStream) FilterInputStream() *FilterInputStream {
	return FilterInputStreamNewFromC(unsafe.Pointer(recv.native))
}

// InputStream upcasts to *InputStream
func (recv *ConverterInputStream) InputStream() *InputStream {
	return recv.FilterInputStream().InputStream()
}

// Object upcasts to *Object
func (recv *ConverterInputStream) Object() *gobject.Object {
	return recv.FilterInputStream().Object()
}

// CastToWidget down casts any arbitrary Object to ConverterInputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a ConverterInputStream.
func CastToConverterInputStream(object *gobject.Object) *ConverterInputStream {
	return ConverterInputStreamNewFromC(object.ToC())
}

// ConverterInputStreamNew is a wrapper around the C function g_converter_input_stream_new.
func ConverterInputStreamNew(baseStream *InputStream, converter *Converter) *ConverterInputStream {
	c_base_stream := (*C.GInputStream)(C.NULL)
	if baseStream != nil {
		c_base_stream = (*C.GInputStream)(baseStream.ToC())
	}

	c_converter := (*C.GConverter)(converter.ToC())

	retC := C.g_converter_input_stream_new(c_base_stream, c_converter)
	retGo := ConverterInputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetConverter is a wrapper around the C function g_converter_input_stream_get_converter.
func (recv *ConverterInputStream) GetConverter() *Converter {
	retC := C.g_converter_input_stream_get_converter((*C.GConverterInputStream)(recv.native))
	retGo := ConverterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// PollableInputStream returns the PollableInputStream interface implemented by ConverterInputStream
func (recv *ConverterInputStream) PollableInputStream() *PollableInputStream {
	return PollableInputStreamNewFromC(recv.ToC())
}

// ConverterOutputStream is a wrapper around the C record GConverterOutputStream.
type ConverterOutputStream struct {
	native *C.GConverterOutputStream
	// parent_instance : record
	// Private : priv
}

func ConverterOutputStreamNewFromC(u unsafe.Pointer) *ConverterOutputStream {
	c := (*C.GConverterOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &ConverterOutputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ConverterOutputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ConverterOutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ConverterOutputStream with another ConverterOutputStream, and returns true if they represent the same GObject.
func (recv *ConverterOutputStream) Equals(other *ConverterOutputStream) bool {
	return other.ToC() == recv.ToC()
}

// FilterOutputStream upcasts to *FilterOutputStream
func (recv *ConverterOutputStream) FilterOutputStream() *FilterOutputStream {
	return FilterOutputStreamNewFromC(unsafe.Pointer(recv.native))
}

// OutputStream upcasts to *OutputStream
func (recv *ConverterOutputStream) OutputStream() *OutputStream {
	return recv.FilterOutputStream().OutputStream()
}

// Object upcasts to *Object
func (recv *ConverterOutputStream) Object() *gobject.Object {
	return recv.FilterOutputStream().Object()
}

// CastToWidget down casts any arbitrary Object to ConverterOutputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a ConverterOutputStream.
func CastToConverterOutputStream(object *gobject.Object) *ConverterOutputStream {
	return ConverterOutputStreamNewFromC(object.ToC())
}

// ConverterOutputStreamNew is a wrapper around the C function g_converter_output_stream_new.
func ConverterOutputStreamNew(baseStream *OutputStream, converter *Converter) *ConverterOutputStream {
	c_base_stream := (*C.GOutputStream)(C.NULL)
	if baseStream != nil {
		c_base_stream = (*C.GOutputStream)(baseStream.ToC())
	}

	c_converter := (*C.GConverter)(converter.ToC())

	retC := C.g_converter_output_stream_new(c_base_stream, c_converter)
	retGo := ConverterOutputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetConverter is a wrapper around the C function g_converter_output_stream_get_converter.
func (recv *ConverterOutputStream) GetConverter() *Converter {
	retC := C.g_converter_output_stream_get_converter((*C.GConverterOutputStream)(recv.native))
	retGo := ConverterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// PollableOutputStream returns the PollableOutputStream interface implemented by ConverterOutputStream
func (recv *ConverterOutputStream) PollableOutputStream() *PollableOutputStream {
	return PollableOutputStreamNewFromC(recv.ToC())
}

// Credentials is a wrapper around the C record GCredentials.
type Credentials struct {
	native *C.GCredentials
}

func CredentialsNewFromC(u unsafe.Pointer) *Credentials {
	c := (*C.GCredentials)(u)
	if c == nil {
		return nil
	}

	g := &Credentials{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Credentials) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Credentials) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Credentials with another Credentials, and returns true if they represent the same GObject.
func (recv *Credentials) Equals(other *Credentials) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Credentials) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Credentials.
// Exercise care, as this is a potentially dangerous function if the Object is not a Credentials.
func CastToCredentials(object *gobject.Object) *Credentials {
	return CredentialsNewFromC(object.ToC())
}

// CredentialsNew is a wrapper around the C function g_credentials_new.
func CredentialsNew() *Credentials {
	retC := C.g_credentials_new()
	retGo := CredentialsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetNative is a wrapper around the C function g_credentials_get_native.
func (recv *Credentials) GetNative(nativeType CredentialsType) uintptr {
	c_native_type := (C.GCredentialsType)(nativeType)

	retC := C.g_credentials_get_native((*C.GCredentials)(recv.native), c_native_type)
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// GetUnixPid is a wrapper around the C function g_credentials_get_unix_pid.
func (recv *Credentials) GetUnixPid() (int32, error) {
	var cThrowableError *C.GError

	retC := C.g_credentials_get_unix_pid((*C.GCredentials)(recv.native), &cThrowableError)
	retGo := (int32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetUnixUser is a wrapper around the C function g_credentials_get_unix_user.
func (recv *Credentials) GetUnixUser() (uint32, error) {
	var cThrowableError *C.GError

	retC := C.g_credentials_get_unix_user((*C.GCredentials)(recv.native), &cThrowableError)
	retGo := (uint32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// IsSameUser is a wrapper around the C function g_credentials_is_same_user.
func (recv *Credentials) IsSameUser(otherCredentials *Credentials) (bool, error) {
	c_other_credentials := (*C.GCredentials)(C.NULL)
	if otherCredentials != nil {
		c_other_credentials = (*C.GCredentials)(otherCredentials.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_credentials_is_same_user((*C.GCredentials)(recv.native), c_other_credentials, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetNative is a wrapper around the C function g_credentials_set_native.
func (recv *Credentials) SetNative(nativeType CredentialsType, native uintptr) {
	c_native_type := (C.GCredentialsType)(nativeType)

	c_native := (C.gpointer)(native)

	C.g_credentials_set_native((*C.GCredentials)(recv.native), c_native_type, c_native)

	return
}

// SetUnixUser is a wrapper around the C function g_credentials_set_unix_user.
func (recv *Credentials) SetUnixUser(uid uint32) (bool, error) {
	c_uid := (C.uid_t)(uid)

	var cThrowableError *C.GError

	retC := C.g_credentials_set_unix_user((*C.GCredentials)(recv.native), c_uid, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ToString is a wrapper around the C function g_credentials_to_string.
func (recv *Credentials) ToString() string {
	retC := C.g_credentials_to_string((*C.GCredentials)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// DBusActionGroup is a wrapper around the C record GDBusActionGroup.
type DBusActionGroup struct {
	native *C.GDBusActionGroup
}

func DBusActionGroupNewFromC(u unsafe.Pointer) *DBusActionGroup {
	c := (*C.GDBusActionGroup)(u)
	if c == nil {
		return nil
	}

	g := &DBusActionGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusActionGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusActionGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusActionGroup with another DBusActionGroup, and returns true if they represent the same GObject.
func (recv *DBusActionGroup) Equals(other *DBusActionGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusActionGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusActionGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusActionGroup.
func CastToDBusActionGroup(object *gobject.Object) *DBusActionGroup {
	return DBusActionGroupNewFromC(object.ToC())
}

// DBusActionGroupGet is a wrapper around the C function g_dbus_action_group_get.
func DBusActionGroupGet(connection *DBusConnection, busName string, objectPath string) *DBusActionGroup {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	c_bus_name := C.CString(busName)
	defer C.free(unsafe.Pointer(c_bus_name))

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	retC := C.g_dbus_action_group_get(c_connection, c_bus_name, c_object_path)
	retGo := DBusActionGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ActionGroup returns the ActionGroup interface implemented by DBusActionGroup
func (recv *DBusActionGroup) ActionGroup() *ActionGroup {
	return ActionGroupNewFromC(recv.ToC())
}

// RemoteActionGroup returns the RemoteActionGroup interface implemented by DBusActionGroup
func (recv *DBusActionGroup) RemoteActionGroup() *RemoteActionGroup {
	return RemoteActionGroupNewFromC(recv.ToC())
}

// DBusAuthObserver is a wrapper around the C record GDBusAuthObserver.
type DBusAuthObserver struct {
	native *C.GDBusAuthObserver
}

func DBusAuthObserverNewFromC(u unsafe.Pointer) *DBusAuthObserver {
	c := (*C.GDBusAuthObserver)(u)
	if c == nil {
		return nil
	}

	g := &DBusAuthObserver{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusAuthObserver) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusAuthObserver) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusAuthObserver with another DBusAuthObserver, and returns true if they represent the same GObject.
func (recv *DBusAuthObserver) Equals(other *DBusAuthObserver) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusAuthObserver) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusAuthObserver.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusAuthObserver.
func CastToDBusAuthObserver(object *gobject.Object) *DBusAuthObserver {
	return DBusAuthObserverNewFromC(object.ToC())
}

type signalDBusAuthObserverAllowMechanismDetail struct {
	callback  DBusAuthObserverSignalAllowMechanismCallback
	handlerID C.gulong
}

var signalDBusAuthObserverAllowMechanismId int
var signalDBusAuthObserverAllowMechanismMap = make(map[int]signalDBusAuthObserverAllowMechanismDetail)
var signalDBusAuthObserverAllowMechanismLock sync.RWMutex

// DBusAuthObserverSignalAllowMechanismCallback is a callback function for a 'allow-mechanism' signal emitted from a DBusAuthObserver.
type DBusAuthObserverSignalAllowMechanismCallback func(mechanism string) bool

/*
ConnectAllowMechanism connects the callback to the 'allow-mechanism' signal for the DBusAuthObserver.

The returned value represents the connection, and may be passed to DisconnectAllowMechanism to remove it.
*/
func (recv *DBusAuthObserver) ConnectAllowMechanism(callback DBusAuthObserverSignalAllowMechanismCallback) int {
	signalDBusAuthObserverAllowMechanismLock.Lock()
	defer signalDBusAuthObserverAllowMechanismLock.Unlock()

	signalDBusAuthObserverAllowMechanismId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusAuthObserver_signal_connect_allow_mechanism(instance, C.gpointer(uintptr(signalDBusAuthObserverAllowMechanismId)))

	detail := signalDBusAuthObserverAllowMechanismDetail{callback, handlerID}
	signalDBusAuthObserverAllowMechanismMap[signalDBusAuthObserverAllowMechanismId] = detail

	return signalDBusAuthObserverAllowMechanismId
}

/*
DisconnectAllowMechanism disconnects a callback from the 'allow-mechanism' signal for the DBusAuthObserver.

The connectionID should be a value returned from a call to ConnectAllowMechanism.
*/
func (recv *DBusAuthObserver) DisconnectAllowMechanism(connectionID int) {
	signalDBusAuthObserverAllowMechanismLock.Lock()
	defer signalDBusAuthObserverAllowMechanismLock.Unlock()

	detail, exists := signalDBusAuthObserverAllowMechanismMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusAuthObserverAllowMechanismMap, connectionID)
}

//export dbusauthobserver_allowMechanismHandler
func dbusauthobserver_allowMechanismHandler(_ *C.GObject, c_mechanism *C.gchar, data C.gpointer) C.gboolean {
	signalDBusAuthObserverAllowMechanismLock.RLock()
	defer signalDBusAuthObserverAllowMechanismLock.RUnlock()

	mechanism := C.GoString(c_mechanism)

	index := int(uintptr(data))
	callback := signalDBusAuthObserverAllowMechanismMap[index].callback
	retGo := callback(mechanism)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalDBusAuthObserverAuthorizeAuthenticatedPeerDetail struct {
	callback  DBusAuthObserverSignalAuthorizeAuthenticatedPeerCallback
	handlerID C.gulong
}

var signalDBusAuthObserverAuthorizeAuthenticatedPeerId int
var signalDBusAuthObserverAuthorizeAuthenticatedPeerMap = make(map[int]signalDBusAuthObserverAuthorizeAuthenticatedPeerDetail)
var signalDBusAuthObserverAuthorizeAuthenticatedPeerLock sync.RWMutex

// DBusAuthObserverSignalAuthorizeAuthenticatedPeerCallback is a callback function for a 'authorize-authenticated-peer' signal emitted from a DBusAuthObserver.
type DBusAuthObserverSignalAuthorizeAuthenticatedPeerCallback func(stream *IOStream, credentials *Credentials) bool

/*
ConnectAuthorizeAuthenticatedPeer connects the callback to the 'authorize-authenticated-peer' signal for the DBusAuthObserver.

The returned value represents the connection, and may be passed to DisconnectAuthorizeAuthenticatedPeer to remove it.
*/
func (recv *DBusAuthObserver) ConnectAuthorizeAuthenticatedPeer(callback DBusAuthObserverSignalAuthorizeAuthenticatedPeerCallback) int {
	signalDBusAuthObserverAuthorizeAuthenticatedPeerLock.Lock()
	defer signalDBusAuthObserverAuthorizeAuthenticatedPeerLock.Unlock()

	signalDBusAuthObserverAuthorizeAuthenticatedPeerId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusAuthObserver_signal_connect_authorize_authenticated_peer(instance, C.gpointer(uintptr(signalDBusAuthObserverAuthorizeAuthenticatedPeerId)))

	detail := signalDBusAuthObserverAuthorizeAuthenticatedPeerDetail{callback, handlerID}
	signalDBusAuthObserverAuthorizeAuthenticatedPeerMap[signalDBusAuthObserverAuthorizeAuthenticatedPeerId] = detail

	return signalDBusAuthObserverAuthorizeAuthenticatedPeerId
}

/*
DisconnectAuthorizeAuthenticatedPeer disconnects a callback from the 'authorize-authenticated-peer' signal for the DBusAuthObserver.

The connectionID should be a value returned from a call to ConnectAuthorizeAuthenticatedPeer.
*/
func (recv *DBusAuthObserver) DisconnectAuthorizeAuthenticatedPeer(connectionID int) {
	signalDBusAuthObserverAuthorizeAuthenticatedPeerLock.Lock()
	defer signalDBusAuthObserverAuthorizeAuthenticatedPeerLock.Unlock()

	detail, exists := signalDBusAuthObserverAuthorizeAuthenticatedPeerMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusAuthObserverAuthorizeAuthenticatedPeerMap, connectionID)
}

//export dbusauthobserver_authorizeAuthenticatedPeerHandler
func dbusauthobserver_authorizeAuthenticatedPeerHandler(_ *C.GObject, c_stream *C.GIOStream, c_credentials *C.GCredentials, data C.gpointer) C.gboolean {
	signalDBusAuthObserverAuthorizeAuthenticatedPeerLock.RLock()
	defer signalDBusAuthObserverAuthorizeAuthenticatedPeerLock.RUnlock()

	stream := IOStreamNewFromC(unsafe.Pointer(c_stream))

	credentials := CredentialsNewFromC(unsafe.Pointer(c_credentials))

	index := int(uintptr(data))
	callback := signalDBusAuthObserverAuthorizeAuthenticatedPeerMap[index].callback
	retGo := callback(stream, credentials)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// DBusAuthObserverNew is a wrapper around the C function g_dbus_auth_observer_new.
func DBusAuthObserverNew() *DBusAuthObserver {
	retC := C.g_dbus_auth_observer_new()
	retGo := DBusAuthObserverNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AllowMechanism is a wrapper around the C function g_dbus_auth_observer_allow_mechanism.
func (recv *DBusAuthObserver) AllowMechanism(mechanism string) bool {
	c_mechanism := C.CString(mechanism)
	defer C.free(unsafe.Pointer(c_mechanism))

	retC := C.g_dbus_auth_observer_allow_mechanism((*C.GDBusAuthObserver)(recv.native), c_mechanism)
	retGo := retC == C.TRUE

	return retGo
}

// AuthorizeAuthenticatedPeer is a wrapper around the C function g_dbus_auth_observer_authorize_authenticated_peer.
func (recv *DBusAuthObserver) AuthorizeAuthenticatedPeer(stream *IOStream, credentials *Credentials) bool {
	c_stream := (*C.GIOStream)(C.NULL)
	if stream != nil {
		c_stream = (*C.GIOStream)(stream.ToC())
	}

	c_credentials := (*C.GCredentials)(C.NULL)
	if credentials != nil {
		c_credentials = (*C.GCredentials)(credentials.ToC())
	}

	retC := C.g_dbus_auth_observer_authorize_authenticated_peer((*C.GDBusAuthObserver)(recv.native), c_stream, c_credentials)
	retGo := retC == C.TRUE

	return retGo
}

// DBusConnection is a wrapper around the C record GDBusConnection.
type DBusConnection struct {
	native *C.GDBusConnection
}

func DBusConnectionNewFromC(u unsafe.Pointer) *DBusConnection {
	c := (*C.GDBusConnection)(u)
	if c == nil {
		return nil
	}

	g := &DBusConnection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusConnection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusConnection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusConnection with another DBusConnection, and returns true if they represent the same GObject.
func (recv *DBusConnection) Equals(other *DBusConnection) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusConnection) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusConnection.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusConnection.
func CastToDBusConnection(object *gobject.Object) *DBusConnection {
	return DBusConnectionNewFromC(object.ToC())
}

type signalDBusConnectionClosedDetail struct {
	callback  DBusConnectionSignalClosedCallback
	handlerID C.gulong
}

var signalDBusConnectionClosedId int
var signalDBusConnectionClosedMap = make(map[int]signalDBusConnectionClosedDetail)
var signalDBusConnectionClosedLock sync.RWMutex

// DBusConnectionSignalClosedCallback is a callback function for a 'closed' signal emitted from a DBusConnection.
type DBusConnectionSignalClosedCallback func(remotePeerVanished bool, error_ *glib.Error)

/*
ConnectClosed connects the callback to the 'closed' signal for the DBusConnection.

The returned value represents the connection, and may be passed to DisconnectClosed to remove it.
*/
func (recv *DBusConnection) ConnectClosed(callback DBusConnectionSignalClosedCallback) int {
	signalDBusConnectionClosedLock.Lock()
	defer signalDBusConnectionClosedLock.Unlock()

	signalDBusConnectionClosedId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusConnection_signal_connect_closed(instance, C.gpointer(uintptr(signalDBusConnectionClosedId)))

	detail := signalDBusConnectionClosedDetail{callback, handlerID}
	signalDBusConnectionClosedMap[signalDBusConnectionClosedId] = detail

	return signalDBusConnectionClosedId
}

/*
DisconnectClosed disconnects a callback from the 'closed' signal for the DBusConnection.

The connectionID should be a value returned from a call to ConnectClosed.
*/
func (recv *DBusConnection) DisconnectClosed(connectionID int) {
	signalDBusConnectionClosedLock.Lock()
	defer signalDBusConnectionClosedLock.Unlock()

	detail, exists := signalDBusConnectionClosedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusConnectionClosedMap, connectionID)
}

//export dbusconnection_closedHandler
func dbusconnection_closedHandler(_ *C.GObject, c_remote_peer_vanished C.gboolean, c_error *C.GError, data C.gpointer) {
	signalDBusConnectionClosedLock.RLock()
	defer signalDBusConnectionClosedLock.RUnlock()

	remotePeerVanished := c_remote_peer_vanished == C.TRUE

	error_ := glib.ErrorNewFromC(unsafe.Pointer(c_error))

	index := int(uintptr(data))
	callback := signalDBusConnectionClosedMap[index].callback
	callback(remotePeerVanished, error_)
}

// DBusConnectionNewFinish is a wrapper around the C function g_dbus_connection_new_finish.
func DBusConnectionNewFinish(res *AsyncResult) (*DBusConnection, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_new_finish(c_res, &cThrowableError)
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusConnectionNewForAddressFinish is a wrapper around the C function g_dbus_connection_new_for_address_finish.
func DBusConnectionNewForAddressFinish(res *AsyncResult) (*DBusConnection, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_new_for_address_finish(c_res, &cThrowableError)
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusConnectionNewForAddressSync is a wrapper around the C function g_dbus_connection_new_for_address_sync.
func DBusConnectionNewForAddressSync(address string, flags DBusConnectionFlags, observer *DBusAuthObserver, cancellable *Cancellable) (*DBusConnection, error) {
	c_address := C.CString(address)
	defer C.free(unsafe.Pointer(c_address))

	c_flags := (C.GDBusConnectionFlags)(flags)

	c_observer := (*C.GDBusAuthObserver)(C.NULL)
	if observer != nil {
		c_observer = (*C.GDBusAuthObserver)(observer.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_new_for_address_sync(c_address, c_flags, c_observer, c_cancellable, &cThrowableError)
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusConnectionNewSync is a wrapper around the C function g_dbus_connection_new_sync.
func DBusConnectionNewSync(stream *IOStream, guid string, flags DBusConnectionFlags, observer *DBusAuthObserver, cancellable *Cancellable) (*DBusConnection, error) {
	c_stream := (*C.GIOStream)(C.NULL)
	if stream != nil {
		c_stream = (*C.GIOStream)(stream.ToC())
	}

	c_guid := C.CString(guid)
	defer C.free(unsafe.Pointer(c_guid))

	c_flags := (C.GDBusConnectionFlags)(flags)

	c_observer := (*C.GDBusAuthObserver)(C.NULL)
	if observer != nil {
		c_observer = (*C.GDBusAuthObserver)(observer.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_new_sync(c_stream, c_guid, c_flags, c_observer, c_cancellable, &cThrowableError)
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// g_dbus_connection_new : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback
// g_dbus_connection_new_for_address : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback
// Unsupported : g_dbus_connection_add_filter : unsupported parameter filter_function : no type generator for DBusMessageFilterFunction (GDBusMessageFilterFunction) for param filter_function

// Unsupported : g_dbus_connection_call : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CallFinish is a wrapper around the C function g_dbus_connection_call_finish.
func (recv *DBusConnection) CallFinish(res *AsyncResult) (*glib.Variant, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_call_finish((*C.GDBusConnection)(recv.native), c_res, &cThrowableError)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// CallSync is a wrapper around the C function g_dbus_connection_call_sync.
func (recv *DBusConnection) CallSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int32, cancellable *Cancellable) (*glib.Variant, error) {
	c_bus_name := C.CString(busName)
	defer C.free(unsafe.Pointer(c_bus_name))

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	c_interface_name := C.CString(interfaceName)
	defer C.free(unsafe.Pointer(c_interface_name))

	c_method_name := C.CString(methodName)
	defer C.free(unsafe.Pointer(c_method_name))

	c_parameters := (*C.GVariant)(C.NULL)
	if parameters != nil {
		c_parameters = (*C.GVariant)(parameters.ToC())
	}

	c_reply_type := (*C.GVariantType)(C.NULL)
	if replyType != nil {
		c_reply_type = (*C.GVariantType)(replyType.ToC())
	}

	c_flags := (C.GDBusCallFlags)(flags)

	c_timeout_msec := (C.gint)(timeoutMsec)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_call_sync((*C.GDBusConnection)(recv.native), c_bus_name, c_object_path, c_interface_name, c_method_name, c_parameters, c_reply_type, c_flags, c_timeout_msec, c_cancellable, &cThrowableError)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_dbus_connection_call_with_unix_fd_list : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CallWithUnixFdListFinish is a wrapper around the C function g_dbus_connection_call_with_unix_fd_list_finish.
func (recv *DBusConnection) CallWithUnixFdListFinish(res *AsyncResult) (*glib.Variant, *UnixFDList, error) {
	var c_out_fd_list *C.GUnixFDList

	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_call_with_unix_fd_list_finish((*C.GDBusConnection)(recv.native), &c_out_fd_list, c_res, &cThrowableError)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	outFdList := UnixFDListNewFromC(unsafe.Pointer(c_out_fd_list))

	return retGo, outFdList, goError
}

// CallWithUnixFdListSync is a wrapper around the C function g_dbus_connection_call_with_unix_fd_list_sync.
func (recv *DBusConnection) CallWithUnixFdListSync(busName string, objectPath string, interfaceName string, methodName string, parameters *glib.Variant, replyType *glib.VariantType, flags DBusCallFlags, timeoutMsec int32, fdList *UnixFDList, cancellable *Cancellable) (*glib.Variant, *UnixFDList, error) {
	c_bus_name := C.CString(busName)
	defer C.free(unsafe.Pointer(c_bus_name))

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	c_interface_name := C.CString(interfaceName)
	defer C.free(unsafe.Pointer(c_interface_name))

	c_method_name := C.CString(methodName)
	defer C.free(unsafe.Pointer(c_method_name))

	c_parameters := (*C.GVariant)(C.NULL)
	if parameters != nil {
		c_parameters = (*C.GVariant)(parameters.ToC())
	}

	c_reply_type := (*C.GVariantType)(C.NULL)
	if replyType != nil {
		c_reply_type = (*C.GVariantType)(replyType.ToC())
	}

	c_flags := (C.GDBusCallFlags)(flags)

	c_timeout_msec := (C.gint)(timeoutMsec)

	c_fd_list := (*C.GUnixFDList)(C.NULL)
	if fdList != nil {
		c_fd_list = (*C.GUnixFDList)(fdList.ToC())
	}

	var c_out_fd_list *C.GUnixFDList

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_call_with_unix_fd_list_sync((*C.GDBusConnection)(recv.native), c_bus_name, c_object_path, c_interface_name, c_method_name, c_parameters, c_reply_type, c_flags, c_timeout_msec, c_fd_list, &c_out_fd_list, c_cancellable, &cThrowableError)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	outFdList := UnixFDListNewFromC(unsafe.Pointer(c_out_fd_list))

	return retGo, outFdList, goError
}

// Unsupported : g_dbus_connection_close : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CloseFinish is a wrapper around the C function g_dbus_connection_close_finish.
func (recv *DBusConnection) CloseFinish(res *AsyncResult) (bool, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_close_finish((*C.GDBusConnection)(recv.native), c_res, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// CloseSync is a wrapper around the C function g_dbus_connection_close_sync.
func (recv *DBusConnection) CloseSync(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_close_sync((*C.GDBusConnection)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// EmitSignal is a wrapper around the C function g_dbus_connection_emit_signal.
func (recv *DBusConnection) EmitSignal(destinationBusName string, objectPath string, interfaceName string, signalName string, parameters *glib.Variant) (bool, error) {
	c_destination_bus_name := C.CString(destinationBusName)
	defer C.free(unsafe.Pointer(c_destination_bus_name))

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	c_interface_name := C.CString(interfaceName)
	defer C.free(unsafe.Pointer(c_interface_name))

	c_signal_name := C.CString(signalName)
	defer C.free(unsafe.Pointer(c_signal_name))

	c_parameters := (*C.GVariant)(C.NULL)
	if parameters != nil {
		c_parameters = (*C.GVariant)(parameters.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_emit_signal((*C.GDBusConnection)(recv.native), c_destination_bus_name, c_object_path, c_interface_name, c_signal_name, c_parameters, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ExportActionGroup is a wrapper around the C function g_dbus_connection_export_action_group.
func (recv *DBusConnection) ExportActionGroup(objectPath string, actionGroup *ActionGroup) (uint32, error) {
	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	c_action_group := (*C.GActionGroup)(actionGroup.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_export_action_group((*C.GDBusConnection)(recv.native), c_object_path, c_action_group, &cThrowableError)
	retGo := (uint32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ExportMenuModel is a wrapper around the C function g_dbus_connection_export_menu_model.
func (recv *DBusConnection) ExportMenuModel(objectPath string, menu *MenuModel) (uint32, error) {
	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	c_menu := (*C.GMenuModel)(C.NULL)
	if menu != nil {
		c_menu = (*C.GMenuModel)(menu.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_export_menu_model((*C.GDBusConnection)(recv.native), c_object_path, c_menu, &cThrowableError)
	retGo := (uint32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_dbus_connection_flush : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// FlushFinish is a wrapper around the C function g_dbus_connection_flush_finish.
func (recv *DBusConnection) FlushFinish(res *AsyncResult) (bool, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_flush_finish((*C.GDBusConnection)(recv.native), c_res, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// FlushSync is a wrapper around the C function g_dbus_connection_flush_sync.
func (recv *DBusConnection) FlushSync(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_flush_sync((*C.GDBusConnection)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetCapabilities is a wrapper around the C function g_dbus_connection_get_capabilities.
func (recv *DBusConnection) GetCapabilities() DBusCapabilityFlags {
	retC := C.g_dbus_connection_get_capabilities((*C.GDBusConnection)(recv.native))
	retGo := (DBusCapabilityFlags)(retC)

	return retGo
}

// GetExitOnClose is a wrapper around the C function g_dbus_connection_get_exit_on_close.
func (recv *DBusConnection) GetExitOnClose() bool {
	retC := C.g_dbus_connection_get_exit_on_close((*C.GDBusConnection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetGuid is a wrapper around the C function g_dbus_connection_get_guid.
func (recv *DBusConnection) GetGuid() string {
	retC := C.g_dbus_connection_get_guid((*C.GDBusConnection)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetLastSerial is a wrapper around the C function g_dbus_connection_get_last_serial.
func (recv *DBusConnection) GetLastSerial() uint32 {
	retC := C.g_dbus_connection_get_last_serial((*C.GDBusConnection)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetPeerCredentials is a wrapper around the C function g_dbus_connection_get_peer_credentials.
func (recv *DBusConnection) GetPeerCredentials() *Credentials {
	retC := C.g_dbus_connection_get_peer_credentials((*C.GDBusConnection)(recv.native))
	var retGo (*Credentials)
	if retC == nil {
		retGo = nil
	} else {
		retGo = CredentialsNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetStream is a wrapper around the C function g_dbus_connection_get_stream.
func (recv *DBusConnection) GetStream() *IOStream {
	retC := C.g_dbus_connection_get_stream((*C.GDBusConnection)(recv.native))
	retGo := IOStreamNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetUniqueName is a wrapper around the C function g_dbus_connection_get_unique_name.
func (recv *DBusConnection) GetUniqueName() string {
	retC := C.g_dbus_connection_get_unique_name((*C.GDBusConnection)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// IsClosed is a wrapper around the C function g_dbus_connection_is_closed.
func (recv *DBusConnection) IsClosed() bool {
	retC := C.g_dbus_connection_is_closed((*C.GDBusConnection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_dbus_connection_register_object : unsupported parameter user_data_free_func : no type generator for GLib.DestroyNotify (GDestroyNotify) for param user_data_free_func

// Unsupported : g_dbus_connection_register_subtree : unsupported parameter user_data_free_func : no type generator for GLib.DestroyNotify (GDestroyNotify) for param user_data_free_func

// RemoveFilter is a wrapper around the C function g_dbus_connection_remove_filter.
func (recv *DBusConnection) RemoveFilter(filterId uint32) {
	c_filter_id := (C.guint)(filterId)

	C.g_dbus_connection_remove_filter((*C.GDBusConnection)(recv.native), c_filter_id)

	return
}

// SendMessage is a wrapper around the C function g_dbus_connection_send_message.
func (recv *DBusConnection) SendMessage(message *DBusMessage, flags DBusSendMessageFlags) (bool, uint32, error) {
	c_message := (*C.GDBusMessage)(C.NULL)
	if message != nil {
		c_message = (*C.GDBusMessage)(message.ToC())
	}

	c_flags := (C.GDBusSendMessageFlags)(flags)

	var c_out_serial C.guint32

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_send_message((*C.GDBusConnection)(recv.native), c_message, c_flags, &c_out_serial, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	outSerial := (uint32)(c_out_serial)

	return retGo, outSerial, goError
}

// Unsupported : g_dbus_connection_send_message_with_reply : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// SendMessageWithReplyFinish is a wrapper around the C function g_dbus_connection_send_message_with_reply_finish.
func (recv *DBusConnection) SendMessageWithReplyFinish(res *AsyncResult) (*DBusMessage, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_send_message_with_reply_finish((*C.GDBusConnection)(recv.native), c_res, &cThrowableError)
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SendMessageWithReplySync is a wrapper around the C function g_dbus_connection_send_message_with_reply_sync.
func (recv *DBusConnection) SendMessageWithReplySync(message *DBusMessage, flags DBusSendMessageFlags, timeoutMsec int32, cancellable *Cancellable) (*DBusMessage, uint32, error) {
	c_message := (*C.GDBusMessage)(C.NULL)
	if message != nil {
		c_message = (*C.GDBusMessage)(message.ToC())
	}

	c_flags := (C.GDBusSendMessageFlags)(flags)

	c_timeout_msec := (C.gint)(timeoutMsec)

	var c_out_serial C.guint32

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_connection_send_message_with_reply_sync((*C.GDBusConnection)(recv.native), c_message, c_flags, c_timeout_msec, &c_out_serial, c_cancellable, &cThrowableError)
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	outSerial := (uint32)(c_out_serial)

	return retGo, outSerial, goError
}

// SetExitOnClose is a wrapper around the C function g_dbus_connection_set_exit_on_close.
func (recv *DBusConnection) SetExitOnClose(exitOnClose bool) {
	c_exit_on_close :=
		boolToGboolean(exitOnClose)

	C.g_dbus_connection_set_exit_on_close((*C.GDBusConnection)(recv.native), c_exit_on_close)

	return
}

// Unsupported : g_dbus_connection_signal_subscribe : unsupported parameter callback : no type generator for DBusSignalCallback (GDBusSignalCallback) for param callback

// SignalUnsubscribe is a wrapper around the C function g_dbus_connection_signal_unsubscribe.
func (recv *DBusConnection) SignalUnsubscribe(subscriptionId uint32) {
	c_subscription_id := (C.guint)(subscriptionId)

	C.g_dbus_connection_signal_unsubscribe((*C.GDBusConnection)(recv.native), c_subscription_id)

	return
}

// StartMessageProcessing is a wrapper around the C function g_dbus_connection_start_message_processing.
func (recv *DBusConnection) StartMessageProcessing() {
	C.g_dbus_connection_start_message_processing((*C.GDBusConnection)(recv.native))

	return
}

// UnexportActionGroup is a wrapper around the C function g_dbus_connection_unexport_action_group.
func (recv *DBusConnection) UnexportActionGroup(exportId uint32) {
	c_export_id := (C.guint)(exportId)

	C.g_dbus_connection_unexport_action_group((*C.GDBusConnection)(recv.native), c_export_id)

	return
}

// UnexportMenuModel is a wrapper around the C function g_dbus_connection_unexport_menu_model.
func (recv *DBusConnection) UnexportMenuModel(exportId uint32) {
	c_export_id := (C.guint)(exportId)

	C.g_dbus_connection_unexport_menu_model((*C.GDBusConnection)(recv.native), c_export_id)

	return
}

// UnregisterObject is a wrapper around the C function g_dbus_connection_unregister_object.
func (recv *DBusConnection) UnregisterObject(registrationId uint32) bool {
	c_registration_id := (C.guint)(registrationId)

	retC := C.g_dbus_connection_unregister_object((*C.GDBusConnection)(recv.native), c_registration_id)
	retGo := retC == C.TRUE

	return retGo
}

// UnregisterSubtree is a wrapper around the C function g_dbus_connection_unregister_subtree.
func (recv *DBusConnection) UnregisterSubtree(registrationId uint32) bool {
	c_registration_id := (C.guint)(registrationId)

	retC := C.g_dbus_connection_unregister_subtree((*C.GDBusConnection)(recv.native), c_registration_id)
	retGo := retC == C.TRUE

	return retGo
}

// AsyncInitable returns the AsyncInitable interface implemented by DBusConnection
func (recv *DBusConnection) AsyncInitable() *AsyncInitable {
	return AsyncInitableNewFromC(recv.ToC())
}

// Initable returns the Initable interface implemented by DBusConnection
func (recv *DBusConnection) Initable() *Initable {
	return InitableNewFromC(recv.ToC())
}

// DBusInterfaceSkeleton is a wrapper around the C record GDBusInterfaceSkeleton.
type DBusInterfaceSkeleton struct {
	native *C.GDBusInterfaceSkeleton
	// Private : parent_instance
	// Private : priv
}

func DBusInterfaceSkeletonNewFromC(u unsafe.Pointer) *DBusInterfaceSkeleton {
	c := (*C.GDBusInterfaceSkeleton)(u)
	if c == nil {
		return nil
	}

	g := &DBusInterfaceSkeleton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusInterfaceSkeleton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusInterfaceSkeleton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusInterfaceSkeleton with another DBusInterfaceSkeleton, and returns true if they represent the same GObject.
func (recv *DBusInterfaceSkeleton) Equals(other *DBusInterfaceSkeleton) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusInterfaceSkeleton) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusInterfaceSkeleton.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusInterfaceSkeleton.
func CastToDBusInterfaceSkeleton(object *gobject.Object) *DBusInterfaceSkeleton {
	return DBusInterfaceSkeletonNewFromC(object.ToC())
}

type signalDBusInterfaceSkeletonGAuthorizeMethodDetail struct {
	callback  DBusInterfaceSkeletonSignalGAuthorizeMethodCallback
	handlerID C.gulong
}

var signalDBusInterfaceSkeletonGAuthorizeMethodId int
var signalDBusInterfaceSkeletonGAuthorizeMethodMap = make(map[int]signalDBusInterfaceSkeletonGAuthorizeMethodDetail)
var signalDBusInterfaceSkeletonGAuthorizeMethodLock sync.RWMutex

// DBusInterfaceSkeletonSignalGAuthorizeMethodCallback is a callback function for a 'g-authorize-method' signal emitted from a DBusInterfaceSkeleton.
type DBusInterfaceSkeletonSignalGAuthorizeMethodCallback func(invocation *DBusMethodInvocation) bool

/*
ConnectGAuthorizeMethod connects the callback to the 'g-authorize-method' signal for the DBusInterfaceSkeleton.

The returned value represents the connection, and may be passed to DisconnectGAuthorizeMethod to remove it.
*/
func (recv *DBusInterfaceSkeleton) ConnectGAuthorizeMethod(callback DBusInterfaceSkeletonSignalGAuthorizeMethodCallback) int {
	signalDBusInterfaceSkeletonGAuthorizeMethodLock.Lock()
	defer signalDBusInterfaceSkeletonGAuthorizeMethodLock.Unlock()

	signalDBusInterfaceSkeletonGAuthorizeMethodId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusInterfaceSkeleton_signal_connect_g_authorize_method(instance, C.gpointer(uintptr(signalDBusInterfaceSkeletonGAuthorizeMethodId)))

	detail := signalDBusInterfaceSkeletonGAuthorizeMethodDetail{callback, handlerID}
	signalDBusInterfaceSkeletonGAuthorizeMethodMap[signalDBusInterfaceSkeletonGAuthorizeMethodId] = detail

	return signalDBusInterfaceSkeletonGAuthorizeMethodId
}

/*
DisconnectGAuthorizeMethod disconnects a callback from the 'g-authorize-method' signal for the DBusInterfaceSkeleton.

The connectionID should be a value returned from a call to ConnectGAuthorizeMethod.
*/
func (recv *DBusInterfaceSkeleton) DisconnectGAuthorizeMethod(connectionID int) {
	signalDBusInterfaceSkeletonGAuthorizeMethodLock.Lock()
	defer signalDBusInterfaceSkeletonGAuthorizeMethodLock.Unlock()

	detail, exists := signalDBusInterfaceSkeletonGAuthorizeMethodMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusInterfaceSkeletonGAuthorizeMethodMap, connectionID)
}

//export dbusinterfaceskeleton_gAuthorizeMethodHandler
func dbusinterfaceskeleton_gAuthorizeMethodHandler(_ *C.GObject, c_invocation *C.GDBusMethodInvocation, data C.gpointer) C.gboolean {
	signalDBusInterfaceSkeletonGAuthorizeMethodLock.RLock()
	defer signalDBusInterfaceSkeletonGAuthorizeMethodLock.RUnlock()

	invocation := DBusMethodInvocationNewFromC(unsafe.Pointer(c_invocation))

	index := int(uintptr(data))
	callback := signalDBusInterfaceSkeletonGAuthorizeMethodMap[index].callback
	retGo := callback(invocation)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Export is a wrapper around the C function g_dbus_interface_skeleton_export.
func (recv *DBusInterfaceSkeleton) Export(connection *DBusConnection, objectPath string) (bool, error) {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	var cThrowableError *C.GError

	retC := C.g_dbus_interface_skeleton_export((*C.GDBusInterfaceSkeleton)(recv.native), c_connection, c_object_path, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Flush is a wrapper around the C function g_dbus_interface_skeleton_flush.
func (recv *DBusInterfaceSkeleton) Flush() {
	C.g_dbus_interface_skeleton_flush((*C.GDBusInterfaceSkeleton)(recv.native))

	return
}

// GetConnection is a wrapper around the C function g_dbus_interface_skeleton_get_connection.
func (recv *DBusInterfaceSkeleton) GetConnection() *DBusConnection {
	retC := C.g_dbus_interface_skeleton_get_connection((*C.GDBusInterfaceSkeleton)(recv.native))
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetConnections is a wrapper around the C function g_dbus_interface_skeleton_get_connections.
func (recv *DBusInterfaceSkeleton) GetConnections() *glib.List {
	retC := C.g_dbus_interface_skeleton_get_connections((*C.GDBusInterfaceSkeleton)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFlags is a wrapper around the C function g_dbus_interface_skeleton_get_flags.
func (recv *DBusInterfaceSkeleton) GetFlags() DBusInterfaceSkeletonFlags {
	retC := C.g_dbus_interface_skeleton_get_flags((*C.GDBusInterfaceSkeleton)(recv.native))
	retGo := (DBusInterfaceSkeletonFlags)(retC)

	return retGo
}

// GetInfo is a wrapper around the C function g_dbus_interface_skeleton_get_info.
func (recv *DBusInterfaceSkeleton) GetInfo() *DBusInterfaceInfo {
	retC := C.g_dbus_interface_skeleton_get_info((*C.GDBusInterfaceSkeleton)(recv.native))
	retGo := DBusInterfaceInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetObjectPath is a wrapper around the C function g_dbus_interface_skeleton_get_object_path.
func (recv *DBusInterfaceSkeleton) GetObjectPath() string {
	retC := C.g_dbus_interface_skeleton_get_object_path((*C.GDBusInterfaceSkeleton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetProperties is a wrapper around the C function g_dbus_interface_skeleton_get_properties.
func (recv *DBusInterfaceSkeleton) GetProperties() *glib.Variant {
	retC := C.g_dbus_interface_skeleton_get_properties((*C.GDBusInterfaceSkeleton)(recv.native))
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetVtable is a wrapper around the C function g_dbus_interface_skeleton_get_vtable.
func (recv *DBusInterfaceSkeleton) GetVtable() *DBusInterfaceVTable {
	retC := C.g_dbus_interface_skeleton_get_vtable((*C.GDBusInterfaceSkeleton)(recv.native))
	retGo := DBusInterfaceVTableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// HasConnection is a wrapper around the C function g_dbus_interface_skeleton_has_connection.
func (recv *DBusInterfaceSkeleton) HasConnection(connection *DBusConnection) bool {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	retC := C.g_dbus_interface_skeleton_has_connection((*C.GDBusInterfaceSkeleton)(recv.native), c_connection)
	retGo := retC == C.TRUE

	return retGo
}

// SetFlags is a wrapper around the C function g_dbus_interface_skeleton_set_flags.
func (recv *DBusInterfaceSkeleton) SetFlags(flags DBusInterfaceSkeletonFlags) {
	c_flags := (C.GDBusInterfaceSkeletonFlags)(flags)

	C.g_dbus_interface_skeleton_set_flags((*C.GDBusInterfaceSkeleton)(recv.native), c_flags)

	return
}

// Unexport is a wrapper around the C function g_dbus_interface_skeleton_unexport.
func (recv *DBusInterfaceSkeleton) Unexport() {
	C.g_dbus_interface_skeleton_unexport((*C.GDBusInterfaceSkeleton)(recv.native))

	return
}

// UnexportFromConnection is a wrapper around the C function g_dbus_interface_skeleton_unexport_from_connection.
func (recv *DBusInterfaceSkeleton) UnexportFromConnection(connection *DBusConnection) {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	C.g_dbus_interface_skeleton_unexport_from_connection((*C.GDBusInterfaceSkeleton)(recv.native), c_connection)

	return
}

// DBusInterface returns the DBusInterface interface implemented by DBusInterfaceSkeleton
func (recv *DBusInterfaceSkeleton) DBusInterface() *DBusInterface {
	return DBusInterfaceNewFromC(recv.ToC())
}

// DBusMenuModel is a wrapper around the C record GDBusMenuModel.
type DBusMenuModel struct {
	native *C.GDBusMenuModel
}

func DBusMenuModelNewFromC(u unsafe.Pointer) *DBusMenuModel {
	c := (*C.GDBusMenuModel)(u)
	if c == nil {
		return nil
	}

	g := &DBusMenuModel{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusMenuModel) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusMenuModel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusMenuModel with another DBusMenuModel, and returns true if they represent the same GObject.
func (recv *DBusMenuModel) Equals(other *DBusMenuModel) bool {
	return other.ToC() == recv.ToC()
}

// MenuModel upcasts to *MenuModel
func (recv *DBusMenuModel) MenuModel() *MenuModel {
	return MenuModelNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *DBusMenuModel) Object() *gobject.Object {
	return recv.MenuModel().Object()
}

// CastToWidget down casts any arbitrary Object to DBusMenuModel.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusMenuModel.
func CastToDBusMenuModel(object *gobject.Object) *DBusMenuModel {
	return DBusMenuModelNewFromC(object.ToC())
}

// DBusMenuModelGet is a wrapper around the C function g_dbus_menu_model_get.
func DBusMenuModelGet(connection *DBusConnection, busName string, objectPath string) *DBusMenuModel {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	c_bus_name := C.CString(busName)
	defer C.free(unsafe.Pointer(c_bus_name))

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	retC := C.g_dbus_menu_model_get(c_connection, c_bus_name, c_object_path)
	retGo := DBusMenuModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DBusMessage is a wrapper around the C record GDBusMessage.
type DBusMessage struct {
	native *C.GDBusMessage
}

func DBusMessageNewFromC(u unsafe.Pointer) *DBusMessage {
	c := (*C.GDBusMessage)(u)
	if c == nil {
		return nil
	}

	g := &DBusMessage{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusMessage) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusMessage) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusMessage with another DBusMessage, and returns true if they represent the same GObject.
func (recv *DBusMessage) Equals(other *DBusMessage) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusMessage) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusMessage.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusMessage.
func CastToDBusMessage(object *gobject.Object) *DBusMessage {
	return DBusMessageNewFromC(object.ToC())
}

// DBusMessageNew is a wrapper around the C function g_dbus_message_new.
func DBusMessageNew() *DBusMessage {
	retC := C.g_dbus_message_new()
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// DBusMessageNewFromBlob is a wrapper around the C function g_dbus_message_new_from_blob.
func DBusMessageNewFromBlob(blob []uint8, capabilities DBusCapabilityFlags) (*DBusMessage, error) {
	c_blob_array := make([]C.guint8, len(blob)+1, len(blob)+1)
	for i, item := range blob {
		c := (C.guint8)(item)
		c_blob_array[i] = c
	}
	c_blob_array[len(blob)] = 0
	c_blob_arrayPtr := &c_blob_array[0]
	c_blob := (*C.guchar)(unsafe.Pointer(c_blob_arrayPtr))

	c_blob_len := (C.gsize)(len(blob))

	c_capabilities := (C.GDBusCapabilityFlags)(capabilities)

	var cThrowableError *C.GError

	retC := C.g_dbus_message_new_from_blob(c_blob, c_blob_len, c_capabilities, &cThrowableError)
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusMessageNewMethodCall is a wrapper around the C function g_dbus_message_new_method_call.
func DBusMessageNewMethodCall(name string, path string, interface_ string, method string) *DBusMessage {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_interface_ := C.CString(interface_)
	defer C.free(unsafe.Pointer(c_interface_))

	c_method := C.CString(method)
	defer C.free(unsafe.Pointer(c_method))

	retC := C.g_dbus_message_new_method_call(c_name, c_path, c_interface_, c_method)
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// DBusMessageNewSignal is a wrapper around the C function g_dbus_message_new_signal.
func DBusMessageNewSignal(path string, interface_ string, signal string) *DBusMessage {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_interface_ := C.CString(interface_)
	defer C.free(unsafe.Pointer(c_interface_))

	c_signal := C.CString(signal)
	defer C.free(unsafe.Pointer(c_signal))

	retC := C.g_dbus_message_new_signal(c_path, c_interface_, c_signal)
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// DBusMessageBytesNeeded is a wrapper around the C function g_dbus_message_bytes_needed.
func DBusMessageBytesNeeded(blob []uint8) (int64, error) {
	c_blob_array := make([]C.guint8, len(blob)+1, len(blob)+1)
	for i, item := range blob {
		c := (C.guint8)(item)
		c_blob_array[i] = c
	}
	c_blob_array[len(blob)] = 0
	c_blob_arrayPtr := &c_blob_array[0]
	c_blob := (*C.guchar)(unsafe.Pointer(c_blob_arrayPtr))

	c_blob_len := (C.gsize)(len(blob))

	var cThrowableError *C.GError

	retC := C.g_dbus_message_bytes_needed(c_blob, c_blob_len, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Copy is a wrapper around the C function g_dbus_message_copy.
func (recv *DBusMessage) Copy() (*DBusMessage, error) {
	var cThrowableError *C.GError

	retC := C.g_dbus_message_copy((*C.GDBusMessage)(recv.native), &cThrowableError)
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetArg0 is a wrapper around the C function g_dbus_message_get_arg0.
func (recv *DBusMessage) GetArg0() string {
	retC := C.g_dbus_message_get_arg0((*C.GDBusMessage)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetBody is a wrapper around the C function g_dbus_message_get_body.
func (recv *DBusMessage) GetBody() *glib.Variant {
	retC := C.g_dbus_message_get_body((*C.GDBusMessage)(recv.native))
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetByteOrder is a wrapper around the C function g_dbus_message_get_byte_order.
func (recv *DBusMessage) GetByteOrder() DBusMessageByteOrder {
	retC := C.g_dbus_message_get_byte_order((*C.GDBusMessage)(recv.native))
	retGo := (DBusMessageByteOrder)(retC)

	return retGo
}

// GetDestination is a wrapper around the C function g_dbus_message_get_destination.
func (recv *DBusMessage) GetDestination() string {
	retC := C.g_dbus_message_get_destination((*C.GDBusMessage)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetErrorName is a wrapper around the C function g_dbus_message_get_error_name.
func (recv *DBusMessage) GetErrorName() string {
	retC := C.g_dbus_message_get_error_name((*C.GDBusMessage)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetFlags is a wrapper around the C function g_dbus_message_get_flags.
func (recv *DBusMessage) GetFlags() DBusMessageFlags {
	retC := C.g_dbus_message_get_flags((*C.GDBusMessage)(recv.native))
	retGo := (DBusMessageFlags)(retC)

	return retGo
}

// GetHeader is a wrapper around the C function g_dbus_message_get_header.
func (recv *DBusMessage) GetHeader(headerField DBusMessageHeaderField) *glib.Variant {
	c_header_field := (C.GDBusMessageHeaderField)(headerField)

	retC := C.g_dbus_message_get_header((*C.GDBusMessage)(recv.native), c_header_field)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : g_dbus_message_get_header_fields : array return type :

// GetInterface is a wrapper around the C function g_dbus_message_get_interface.
func (recv *DBusMessage) GetInterface() string {
	retC := C.g_dbus_message_get_interface((*C.GDBusMessage)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetLocked is a wrapper around the C function g_dbus_message_get_locked.
func (recv *DBusMessage) GetLocked() bool {
	retC := C.g_dbus_message_get_locked((*C.GDBusMessage)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetMember is a wrapper around the C function g_dbus_message_get_member.
func (recv *DBusMessage) GetMember() string {
	retC := C.g_dbus_message_get_member((*C.GDBusMessage)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetMessageType is a wrapper around the C function g_dbus_message_get_message_type.
func (recv *DBusMessage) GetMessageType() DBusMessageType {
	retC := C.g_dbus_message_get_message_type((*C.GDBusMessage)(recv.native))
	retGo := (DBusMessageType)(retC)

	return retGo
}

// GetNumUnixFds is a wrapper around the C function g_dbus_message_get_num_unix_fds.
func (recv *DBusMessage) GetNumUnixFds() uint32 {
	retC := C.g_dbus_message_get_num_unix_fds((*C.GDBusMessage)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetPath is a wrapper around the C function g_dbus_message_get_path.
func (recv *DBusMessage) GetPath() string {
	retC := C.g_dbus_message_get_path((*C.GDBusMessage)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetReplySerial is a wrapper around the C function g_dbus_message_get_reply_serial.
func (recv *DBusMessage) GetReplySerial() uint32 {
	retC := C.g_dbus_message_get_reply_serial((*C.GDBusMessage)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetSender is a wrapper around the C function g_dbus_message_get_sender.
func (recv *DBusMessage) GetSender() string {
	retC := C.g_dbus_message_get_sender((*C.GDBusMessage)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetSerial is a wrapper around the C function g_dbus_message_get_serial.
func (recv *DBusMessage) GetSerial() uint32 {
	retC := C.g_dbus_message_get_serial((*C.GDBusMessage)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetSignature is a wrapper around the C function g_dbus_message_get_signature.
func (recv *DBusMessage) GetSignature() string {
	retC := C.g_dbus_message_get_signature((*C.GDBusMessage)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUnixFdList is a wrapper around the C function g_dbus_message_get_unix_fd_list.
func (recv *DBusMessage) GetUnixFdList() *UnixFDList {
	retC := C.g_dbus_message_get_unix_fd_list((*C.GDBusMessage)(recv.native))
	retGo := UnixFDListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Lock is a wrapper around the C function g_dbus_message_lock.
func (recv *DBusMessage) Lock() {
	C.g_dbus_message_lock((*C.GDBusMessage)(recv.native))

	return
}

// NewMethodError is a wrapper around the C function g_dbus_message_new_method_error.
func (recv *DBusMessage) NewMethodError(errorName string, errorMessageFormat string, args ...interface{}) *DBusMessage {
	c_error_name := C.CString(errorName)
	defer C.free(unsafe.Pointer(c_error_name))

	goFormattedString := fmt.Sprintf(errorMessageFormat, args...)
	c_error_message_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_error_message_format))

	retC := C._g_dbus_message_new_method_error((*C.GDBusMessage)(recv.native), c_error_name, c_error_message_format)
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// NewMethodErrorLiteral is a wrapper around the C function g_dbus_message_new_method_error_literal.
func (recv *DBusMessage) NewMethodErrorLiteral(errorName string, errorMessage string) *DBusMessage {
	c_error_name := C.CString(errorName)
	defer C.free(unsafe.Pointer(c_error_name))

	c_error_message := C.CString(errorMessage)
	defer C.free(unsafe.Pointer(c_error_message))

	retC := C.g_dbus_message_new_method_error_literal((*C.GDBusMessage)(recv.native), c_error_name, c_error_message)
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : g_dbus_message_new_method_error_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// NewMethodReply is a wrapper around the C function g_dbus_message_new_method_reply.
func (recv *DBusMessage) NewMethodReply() *DBusMessage {
	retC := C.g_dbus_message_new_method_reply((*C.GDBusMessage)(recv.native))
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Print is a wrapper around the C function g_dbus_message_print.
func (recv *DBusMessage) Print(indent uint32) string {
	c_indent := (C.guint)(indent)

	retC := C.g_dbus_message_print((*C.GDBusMessage)(recv.native), c_indent)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// SetBody is a wrapper around the C function g_dbus_message_set_body.
func (recv *DBusMessage) SetBody(body *glib.Variant) {
	c_body := (*C.GVariant)(C.NULL)
	if body != nil {
		c_body = (*C.GVariant)(body.ToC())
	}

	C.g_dbus_message_set_body((*C.GDBusMessage)(recv.native), c_body)

	return
}

// SetByteOrder is a wrapper around the C function g_dbus_message_set_byte_order.
func (recv *DBusMessage) SetByteOrder(byteOrder DBusMessageByteOrder) {
	c_byte_order := (C.GDBusMessageByteOrder)(byteOrder)

	C.g_dbus_message_set_byte_order((*C.GDBusMessage)(recv.native), c_byte_order)

	return
}

// SetDestination is a wrapper around the C function g_dbus_message_set_destination.
func (recv *DBusMessage) SetDestination(value string) {
	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.g_dbus_message_set_destination((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetErrorName is a wrapper around the C function g_dbus_message_set_error_name.
func (recv *DBusMessage) SetErrorName(value string) {
	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.g_dbus_message_set_error_name((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetFlags is a wrapper around the C function g_dbus_message_set_flags.
func (recv *DBusMessage) SetFlags(flags DBusMessageFlags) {
	c_flags := (C.GDBusMessageFlags)(flags)

	C.g_dbus_message_set_flags((*C.GDBusMessage)(recv.native), c_flags)

	return
}

// SetHeader is a wrapper around the C function g_dbus_message_set_header.
func (recv *DBusMessage) SetHeader(headerField DBusMessageHeaderField, value *glib.Variant) {
	c_header_field := (C.GDBusMessageHeaderField)(headerField)

	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	C.g_dbus_message_set_header((*C.GDBusMessage)(recv.native), c_header_field, c_value)

	return
}

// SetInterface is a wrapper around the C function g_dbus_message_set_interface.
func (recv *DBusMessage) SetInterface(value string) {
	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.g_dbus_message_set_interface((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetMember is a wrapper around the C function g_dbus_message_set_member.
func (recv *DBusMessage) SetMember(value string) {
	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.g_dbus_message_set_member((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetMessageType is a wrapper around the C function g_dbus_message_set_message_type.
func (recv *DBusMessage) SetMessageType(type_ DBusMessageType) {
	c_type := (C.GDBusMessageType)(type_)

	C.g_dbus_message_set_message_type((*C.GDBusMessage)(recv.native), c_type)

	return
}

// SetNumUnixFds is a wrapper around the C function g_dbus_message_set_num_unix_fds.
func (recv *DBusMessage) SetNumUnixFds(value uint32) {
	c_value := (C.guint32)(value)

	C.g_dbus_message_set_num_unix_fds((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetPath is a wrapper around the C function g_dbus_message_set_path.
func (recv *DBusMessage) SetPath(value string) {
	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.g_dbus_message_set_path((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetReplySerial is a wrapper around the C function g_dbus_message_set_reply_serial.
func (recv *DBusMessage) SetReplySerial(value uint32) {
	c_value := (C.guint32)(value)

	C.g_dbus_message_set_reply_serial((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetSender is a wrapper around the C function g_dbus_message_set_sender.
func (recv *DBusMessage) SetSender(value string) {
	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.g_dbus_message_set_sender((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetSerial is a wrapper around the C function g_dbus_message_set_serial.
func (recv *DBusMessage) SetSerial(serial uint32) {
	c_serial := (C.guint32)(serial)

	C.g_dbus_message_set_serial((*C.GDBusMessage)(recv.native), c_serial)

	return
}

// SetSignature is a wrapper around the C function g_dbus_message_set_signature.
func (recv *DBusMessage) SetSignature(value string) {
	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.g_dbus_message_set_signature((*C.GDBusMessage)(recv.native), c_value)

	return
}

// SetUnixFdList is a wrapper around the C function g_dbus_message_set_unix_fd_list.
func (recv *DBusMessage) SetUnixFdList(fdList *UnixFDList) {
	c_fd_list := (*C.GUnixFDList)(C.NULL)
	if fdList != nil {
		c_fd_list = (*C.GUnixFDList)(fdList.ToC())
	}

	C.g_dbus_message_set_unix_fd_list((*C.GDBusMessage)(recv.native), c_fd_list)

	return
}

// Unsupported : g_dbus_message_to_blob : array return type :

// ToGerror is a wrapper around the C function g_dbus_message_to_gerror.
func (recv *DBusMessage) ToGerror() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_dbus_message_to_gerror((*C.GDBusMessage)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusMethodInvocation is a wrapper around the C record GDBusMethodInvocation.
type DBusMethodInvocation struct {
	native *C.GDBusMethodInvocation
}

func DBusMethodInvocationNewFromC(u unsafe.Pointer) *DBusMethodInvocation {
	c := (*C.GDBusMethodInvocation)(u)
	if c == nil {
		return nil
	}

	g := &DBusMethodInvocation{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusMethodInvocation) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusMethodInvocation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusMethodInvocation with another DBusMethodInvocation, and returns true if they represent the same GObject.
func (recv *DBusMethodInvocation) Equals(other *DBusMethodInvocation) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusMethodInvocation) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusMethodInvocation.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusMethodInvocation.
func CastToDBusMethodInvocation(object *gobject.Object) *DBusMethodInvocation {
	return DBusMethodInvocationNewFromC(object.ToC())
}

// GetConnection is a wrapper around the C function g_dbus_method_invocation_get_connection.
func (recv *DBusMethodInvocation) GetConnection() *DBusConnection {
	retC := C.g_dbus_method_invocation_get_connection((*C.GDBusMethodInvocation)(recv.native))
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetInterfaceName is a wrapper around the C function g_dbus_method_invocation_get_interface_name.
func (recv *DBusMethodInvocation) GetInterfaceName() string {
	retC := C.g_dbus_method_invocation_get_interface_name((*C.GDBusMethodInvocation)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetMessage is a wrapper around the C function g_dbus_method_invocation_get_message.
func (recv *DBusMethodInvocation) GetMessage() *DBusMessage {
	retC := C.g_dbus_method_invocation_get_message((*C.GDBusMethodInvocation)(recv.native))
	retGo := DBusMessageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetMethodInfo is a wrapper around the C function g_dbus_method_invocation_get_method_info.
func (recv *DBusMethodInvocation) GetMethodInfo() *DBusMethodInfo {
	retC := C.g_dbus_method_invocation_get_method_info((*C.GDBusMethodInvocation)(recv.native))
	retGo := DBusMethodInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetMethodName is a wrapper around the C function g_dbus_method_invocation_get_method_name.
func (recv *DBusMethodInvocation) GetMethodName() string {
	retC := C.g_dbus_method_invocation_get_method_name((*C.GDBusMethodInvocation)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetObjectPath is a wrapper around the C function g_dbus_method_invocation_get_object_path.
func (recv *DBusMethodInvocation) GetObjectPath() string {
	retC := C.g_dbus_method_invocation_get_object_path((*C.GDBusMethodInvocation)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetParameters is a wrapper around the C function g_dbus_method_invocation_get_parameters.
func (recv *DBusMethodInvocation) GetParameters() *glib.Variant {
	retC := C.g_dbus_method_invocation_get_parameters((*C.GDBusMethodInvocation)(recv.native))
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSender is a wrapper around the C function g_dbus_method_invocation_get_sender.
func (recv *DBusMethodInvocation) GetSender() string {
	retC := C.g_dbus_method_invocation_get_sender((*C.GDBusMethodInvocation)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUserData is a wrapper around the C function g_dbus_method_invocation_get_user_data.
func (recv *DBusMethodInvocation) GetUserData() uintptr {
	retC := C.g_dbus_method_invocation_get_user_data((*C.GDBusMethodInvocation)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// ReturnDbusError is a wrapper around the C function g_dbus_method_invocation_return_dbus_error.
func (recv *DBusMethodInvocation) ReturnDbusError(errorName string, errorMessage string) {
	c_error_name := C.CString(errorName)
	defer C.free(unsafe.Pointer(c_error_name))

	c_error_message := C.CString(errorMessage)
	defer C.free(unsafe.Pointer(c_error_message))

	C.g_dbus_method_invocation_return_dbus_error((*C.GDBusMethodInvocation)(recv.native), c_error_name, c_error_message)

	return
}

// ReturnError is a wrapper around the C function g_dbus_method_invocation_return_error.
func (recv *DBusMethodInvocation) ReturnError(domain glib.Quark, code int32, format string, args ...interface{}) {
	c_domain := (C.GQuark)(domain)

	c_code := (C.gint)(code)

	goFormattedString := fmt.Sprintf(format, args...)
	c_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format))

	C._g_dbus_method_invocation_return_error((*C.GDBusMethodInvocation)(recv.native), c_domain, c_code, c_format)

	return
}

// ReturnErrorLiteral is a wrapper around the C function g_dbus_method_invocation_return_error_literal.
func (recv *DBusMethodInvocation) ReturnErrorLiteral(domain glib.Quark, code int32, message string) {
	c_domain := (C.GQuark)(domain)

	c_code := (C.gint)(code)

	c_message := C.CString(message)
	defer C.free(unsafe.Pointer(c_message))

	C.g_dbus_method_invocation_return_error_literal((*C.GDBusMethodInvocation)(recv.native), c_domain, c_code, c_message)

	return
}

// Unsupported : g_dbus_method_invocation_return_error_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// ReturnGerror is a wrapper around the C function g_dbus_method_invocation_return_gerror.
func (recv *DBusMethodInvocation) ReturnGerror(error_ *glib.Error) {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	C.g_dbus_method_invocation_return_gerror((*C.GDBusMethodInvocation)(recv.native), c_error)

	return
}

// ReturnValue is a wrapper around the C function g_dbus_method_invocation_return_value.
func (recv *DBusMethodInvocation) ReturnValue(parameters *glib.Variant) {
	c_parameters := (*C.GVariant)(C.NULL)
	if parameters != nil {
		c_parameters = (*C.GVariant)(parameters.ToC())
	}

	C.g_dbus_method_invocation_return_value((*C.GDBusMethodInvocation)(recv.native), c_parameters)

	return
}

// ReturnValueWithUnixFdList is a wrapper around the C function g_dbus_method_invocation_return_value_with_unix_fd_list.
func (recv *DBusMethodInvocation) ReturnValueWithUnixFdList(parameters *glib.Variant, fdList *UnixFDList) {
	c_parameters := (*C.GVariant)(C.NULL)
	if parameters != nil {
		c_parameters = (*C.GVariant)(parameters.ToC())
	}

	c_fd_list := (*C.GUnixFDList)(C.NULL)
	if fdList != nil {
		c_fd_list = (*C.GUnixFDList)(fdList.ToC())
	}

	C.g_dbus_method_invocation_return_value_with_unix_fd_list((*C.GDBusMethodInvocation)(recv.native), c_parameters, c_fd_list)

	return
}

// TakeError is a wrapper around the C function g_dbus_method_invocation_take_error.
func (recv *DBusMethodInvocation) TakeError(error_ *glib.Error) {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	C.g_dbus_method_invocation_take_error((*C.GDBusMethodInvocation)(recv.native), c_error)

	return
}

// DBusObjectManagerClient is a wrapper around the C record GDBusObjectManagerClient.
type DBusObjectManagerClient struct {
	native *C.GDBusObjectManagerClient
	// Private : parent_instance
	// Private : priv
}

func DBusObjectManagerClientNewFromC(u unsafe.Pointer) *DBusObjectManagerClient {
	c := (*C.GDBusObjectManagerClient)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectManagerClient{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusObjectManagerClient) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusObjectManagerClient) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectManagerClient with another DBusObjectManagerClient, and returns true if they represent the same GObject.
func (recv *DBusObjectManagerClient) Equals(other *DBusObjectManagerClient) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusObjectManagerClient) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusObjectManagerClient.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusObjectManagerClient.
func CastToDBusObjectManagerClient(object *gobject.Object) *DBusObjectManagerClient {
	return DBusObjectManagerClientNewFromC(object.ToC())
}

// Unsupported signal 'interface-proxy-properties-changed' for DBusObjectManagerClient : unsupported parameter invalidated_properties :

type signalDBusObjectManagerClientInterfaceProxySignalDetail struct {
	callback  DBusObjectManagerClientSignalInterfaceProxySignalCallback
	handlerID C.gulong
}

var signalDBusObjectManagerClientInterfaceProxySignalId int
var signalDBusObjectManagerClientInterfaceProxySignalMap = make(map[int]signalDBusObjectManagerClientInterfaceProxySignalDetail)
var signalDBusObjectManagerClientInterfaceProxySignalLock sync.RWMutex

// DBusObjectManagerClientSignalInterfaceProxySignalCallback is a callback function for a 'interface-proxy-signal' signal emitted from a DBusObjectManagerClient.
type DBusObjectManagerClientSignalInterfaceProxySignalCallback func(objectProxy *DBusObjectProxy, interfaceProxy *DBusProxy, senderName string, signalName string, parameters *glib.Variant)

/*
ConnectInterfaceProxySignal connects the callback to the 'interface-proxy-signal' signal for the DBusObjectManagerClient.

The returned value represents the connection, and may be passed to DisconnectInterfaceProxySignal to remove it.
*/
func (recv *DBusObjectManagerClient) ConnectInterfaceProxySignal(callback DBusObjectManagerClientSignalInterfaceProxySignalCallback) int {
	signalDBusObjectManagerClientInterfaceProxySignalLock.Lock()
	defer signalDBusObjectManagerClientInterfaceProxySignalLock.Unlock()

	signalDBusObjectManagerClientInterfaceProxySignalId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusObjectManagerClient_signal_connect_interface_proxy_signal(instance, C.gpointer(uintptr(signalDBusObjectManagerClientInterfaceProxySignalId)))

	detail := signalDBusObjectManagerClientInterfaceProxySignalDetail{callback, handlerID}
	signalDBusObjectManagerClientInterfaceProxySignalMap[signalDBusObjectManagerClientInterfaceProxySignalId] = detail

	return signalDBusObjectManagerClientInterfaceProxySignalId
}

/*
DisconnectInterfaceProxySignal disconnects a callback from the 'interface-proxy-signal' signal for the DBusObjectManagerClient.

The connectionID should be a value returned from a call to ConnectInterfaceProxySignal.
*/
func (recv *DBusObjectManagerClient) DisconnectInterfaceProxySignal(connectionID int) {
	signalDBusObjectManagerClientInterfaceProxySignalLock.Lock()
	defer signalDBusObjectManagerClientInterfaceProxySignalLock.Unlock()

	detail, exists := signalDBusObjectManagerClientInterfaceProxySignalMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusObjectManagerClientInterfaceProxySignalMap, connectionID)
}

//export dbusobjectmanagerclient_interfaceProxySignalHandler
func dbusobjectmanagerclient_interfaceProxySignalHandler(_ *C.GObject, c_object_proxy *C.GDBusObjectProxy, c_interface_proxy *C.GDBusProxy, c_sender_name *C.gchar, c_signal_name *C.gchar, c_parameters *C.GVariant, data C.gpointer) {
	signalDBusObjectManagerClientInterfaceProxySignalLock.RLock()
	defer signalDBusObjectManagerClientInterfaceProxySignalLock.RUnlock()

	objectProxy := DBusObjectProxyNewFromC(unsafe.Pointer(c_object_proxy))

	interfaceProxy := DBusProxyNewFromC(unsafe.Pointer(c_interface_proxy))

	senderName := C.GoString(c_sender_name)

	signalName := C.GoString(c_signal_name)

	parameters := glib.VariantNewFromC(unsafe.Pointer(c_parameters))

	index := int(uintptr(data))
	callback := signalDBusObjectManagerClientInterfaceProxySignalMap[index].callback
	callback(objectProxy, interfaceProxy, senderName, signalName, parameters)
}

// DBusObjectManagerClientNewFinish is a wrapper around the C function g_dbus_object_manager_client_new_finish.
func DBusObjectManagerClientNewFinish(res *AsyncResult) (*DBusObjectManagerClient, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_object_manager_client_new_finish(c_res, &cThrowableError)
	retGo := DBusObjectManagerClientNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusObjectManagerClientNewForBusFinish is a wrapper around the C function g_dbus_object_manager_client_new_for_bus_finish.
func DBusObjectManagerClientNewForBusFinish(res *AsyncResult) (*DBusObjectManagerClient, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_object_manager_client_new_for_bus_finish(c_res, &cThrowableError)
	retGo := DBusObjectManagerClientNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_dbus_object_manager_client_new_for_bus_sync : unsupported parameter get_proxy_type_func : no type generator for DBusProxyTypeFunc (GDBusProxyTypeFunc) for param get_proxy_type_func

// Unsupported : g_dbus_object_manager_client_new_sync : unsupported parameter get_proxy_type_func : no type generator for DBusProxyTypeFunc (GDBusProxyTypeFunc) for param get_proxy_type_func

// g_dbus_object_manager_client_new : unsupported parameter get_proxy_type_func : no type generator for DBusProxyTypeFunc (GDBusProxyTypeFunc) for param get_proxy_type_func
// g_dbus_object_manager_client_new_for_bus : unsupported parameter get_proxy_type_func : no type generator for DBusProxyTypeFunc (GDBusProxyTypeFunc) for param get_proxy_type_func
// GetConnection is a wrapper around the C function g_dbus_object_manager_client_get_connection.
func (recv *DBusObjectManagerClient) GetConnection() *DBusConnection {
	retC := C.g_dbus_object_manager_client_get_connection((*C.GDBusObjectManagerClient)(recv.native))
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFlags is a wrapper around the C function g_dbus_object_manager_client_get_flags.
func (recv *DBusObjectManagerClient) GetFlags() DBusObjectManagerClientFlags {
	retC := C.g_dbus_object_manager_client_get_flags((*C.GDBusObjectManagerClient)(recv.native))
	retGo := (DBusObjectManagerClientFlags)(retC)

	return retGo
}

// GetName is a wrapper around the C function g_dbus_object_manager_client_get_name.
func (recv *DBusObjectManagerClient) GetName() string {
	retC := C.g_dbus_object_manager_client_get_name((*C.GDBusObjectManagerClient)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetNameOwner is a wrapper around the C function g_dbus_object_manager_client_get_name_owner.
func (recv *DBusObjectManagerClient) GetNameOwner() string {
	retC := C.g_dbus_object_manager_client_get_name_owner((*C.GDBusObjectManagerClient)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// AsyncInitable returns the AsyncInitable interface implemented by DBusObjectManagerClient
func (recv *DBusObjectManagerClient) AsyncInitable() *AsyncInitable {
	return AsyncInitableNewFromC(recv.ToC())
}

// DBusObjectManager returns the DBusObjectManager interface implemented by DBusObjectManagerClient
func (recv *DBusObjectManagerClient) DBusObjectManager() *DBusObjectManager {
	return DBusObjectManagerNewFromC(recv.ToC())
}

// Initable returns the Initable interface implemented by DBusObjectManagerClient
func (recv *DBusObjectManagerClient) Initable() *Initable {
	return InitableNewFromC(recv.ToC())
}

// DBusObjectManagerServer is a wrapper around the C record GDBusObjectManagerServer.
type DBusObjectManagerServer struct {
	native *C.GDBusObjectManagerServer
	// Private : parent_instance
	// Private : priv
}

func DBusObjectManagerServerNewFromC(u unsafe.Pointer) *DBusObjectManagerServer {
	c := (*C.GDBusObjectManagerServer)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectManagerServer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusObjectManagerServer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusObjectManagerServer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectManagerServer with another DBusObjectManagerServer, and returns true if they represent the same GObject.
func (recv *DBusObjectManagerServer) Equals(other *DBusObjectManagerServer) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusObjectManagerServer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusObjectManagerServer.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusObjectManagerServer.
func CastToDBusObjectManagerServer(object *gobject.Object) *DBusObjectManagerServer {
	return DBusObjectManagerServerNewFromC(object.ToC())
}

// DBusObjectManagerServerNew is a wrapper around the C function g_dbus_object_manager_server_new.
func DBusObjectManagerServerNew(objectPath string) *DBusObjectManagerServer {
	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	retC := C.g_dbus_object_manager_server_new(c_object_path)
	retGo := DBusObjectManagerServerNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Export is a wrapper around the C function g_dbus_object_manager_server_export.
func (recv *DBusObjectManagerServer) Export(object *DBusObjectSkeleton) {
	c_object := (*C.GDBusObjectSkeleton)(C.NULL)
	if object != nil {
		c_object = (*C.GDBusObjectSkeleton)(object.ToC())
	}

	C.g_dbus_object_manager_server_export((*C.GDBusObjectManagerServer)(recv.native), c_object)

	return
}

// ExportUniquely is a wrapper around the C function g_dbus_object_manager_server_export_uniquely.
func (recv *DBusObjectManagerServer) ExportUniquely(object *DBusObjectSkeleton) {
	c_object := (*C.GDBusObjectSkeleton)(C.NULL)
	if object != nil {
		c_object = (*C.GDBusObjectSkeleton)(object.ToC())
	}

	C.g_dbus_object_manager_server_export_uniquely((*C.GDBusObjectManagerServer)(recv.native), c_object)

	return
}

// GetConnection is a wrapper around the C function g_dbus_object_manager_server_get_connection.
func (recv *DBusObjectManagerServer) GetConnection() *DBusConnection {
	retC := C.g_dbus_object_manager_server_get_connection((*C.GDBusObjectManagerServer)(recv.native))
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IsExported is a wrapper around the C function g_dbus_object_manager_server_is_exported.
func (recv *DBusObjectManagerServer) IsExported(object *DBusObjectSkeleton) bool {
	c_object := (*C.GDBusObjectSkeleton)(C.NULL)
	if object != nil {
		c_object = (*C.GDBusObjectSkeleton)(object.ToC())
	}

	retC := C.g_dbus_object_manager_server_is_exported((*C.GDBusObjectManagerServer)(recv.native), c_object)
	retGo := retC == C.TRUE

	return retGo
}

// SetConnection is a wrapper around the C function g_dbus_object_manager_server_set_connection.
func (recv *DBusObjectManagerServer) SetConnection(connection *DBusConnection) {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	C.g_dbus_object_manager_server_set_connection((*C.GDBusObjectManagerServer)(recv.native), c_connection)

	return
}

// Unexport is a wrapper around the C function g_dbus_object_manager_server_unexport.
func (recv *DBusObjectManagerServer) Unexport(objectPath string) bool {
	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	retC := C.g_dbus_object_manager_server_unexport((*C.GDBusObjectManagerServer)(recv.native), c_object_path)
	retGo := retC == C.TRUE

	return retGo
}

// DBusObjectManager returns the DBusObjectManager interface implemented by DBusObjectManagerServer
func (recv *DBusObjectManagerServer) DBusObjectManager() *DBusObjectManager {
	return DBusObjectManagerNewFromC(recv.ToC())
}

// DBusObjectProxy is a wrapper around the C record GDBusObjectProxy.
type DBusObjectProxy struct {
	native *C.GDBusObjectProxy
	// Private : parent_instance
	// Private : priv
}

func DBusObjectProxyNewFromC(u unsafe.Pointer) *DBusObjectProxy {
	c := (*C.GDBusObjectProxy)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectProxy{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusObjectProxy) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusObjectProxy) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectProxy with another DBusObjectProxy, and returns true if they represent the same GObject.
func (recv *DBusObjectProxy) Equals(other *DBusObjectProxy) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusObjectProxy) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusObjectProxy.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusObjectProxy.
func CastToDBusObjectProxy(object *gobject.Object) *DBusObjectProxy {
	return DBusObjectProxyNewFromC(object.ToC())
}

// DBusObjectProxyNew is a wrapper around the C function g_dbus_object_proxy_new.
func DBusObjectProxyNew(connection *DBusConnection, objectPath string) *DBusObjectProxy {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	retC := C.g_dbus_object_proxy_new(c_connection, c_object_path)
	retGo := DBusObjectProxyNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetConnection is a wrapper around the C function g_dbus_object_proxy_get_connection.
func (recv *DBusObjectProxy) GetConnection() *DBusConnection {
	retC := C.g_dbus_object_proxy_get_connection((*C.GDBusObjectProxy)(recv.native))
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DBusObject returns the DBusObject interface implemented by DBusObjectProxy
func (recv *DBusObjectProxy) DBusObject() *DBusObject {
	return DBusObjectNewFromC(recv.ToC())
}

// DBusObjectSkeleton is a wrapper around the C record GDBusObjectSkeleton.
type DBusObjectSkeleton struct {
	native *C.GDBusObjectSkeleton
	// Private : parent_instance
	// Private : priv
}

func DBusObjectSkeletonNewFromC(u unsafe.Pointer) *DBusObjectSkeleton {
	c := (*C.GDBusObjectSkeleton)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectSkeleton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusObjectSkeleton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusObjectSkeleton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectSkeleton with another DBusObjectSkeleton, and returns true if they represent the same GObject.
func (recv *DBusObjectSkeleton) Equals(other *DBusObjectSkeleton) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusObjectSkeleton) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusObjectSkeleton.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusObjectSkeleton.
func CastToDBusObjectSkeleton(object *gobject.Object) *DBusObjectSkeleton {
	return DBusObjectSkeletonNewFromC(object.ToC())
}

type signalDBusObjectSkeletonAuthorizeMethodDetail struct {
	callback  DBusObjectSkeletonSignalAuthorizeMethodCallback
	handlerID C.gulong
}

var signalDBusObjectSkeletonAuthorizeMethodId int
var signalDBusObjectSkeletonAuthorizeMethodMap = make(map[int]signalDBusObjectSkeletonAuthorizeMethodDetail)
var signalDBusObjectSkeletonAuthorizeMethodLock sync.RWMutex

// DBusObjectSkeletonSignalAuthorizeMethodCallback is a callback function for a 'authorize-method' signal emitted from a DBusObjectSkeleton.
type DBusObjectSkeletonSignalAuthorizeMethodCallback func(interface_ *DBusInterfaceSkeleton, invocation *DBusMethodInvocation) bool

/*
ConnectAuthorizeMethod connects the callback to the 'authorize-method' signal for the DBusObjectSkeleton.

The returned value represents the connection, and may be passed to DisconnectAuthorizeMethod to remove it.
*/
func (recv *DBusObjectSkeleton) ConnectAuthorizeMethod(callback DBusObjectSkeletonSignalAuthorizeMethodCallback) int {
	signalDBusObjectSkeletonAuthorizeMethodLock.Lock()
	defer signalDBusObjectSkeletonAuthorizeMethodLock.Unlock()

	signalDBusObjectSkeletonAuthorizeMethodId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusObjectSkeleton_signal_connect_authorize_method(instance, C.gpointer(uintptr(signalDBusObjectSkeletonAuthorizeMethodId)))

	detail := signalDBusObjectSkeletonAuthorizeMethodDetail{callback, handlerID}
	signalDBusObjectSkeletonAuthorizeMethodMap[signalDBusObjectSkeletonAuthorizeMethodId] = detail

	return signalDBusObjectSkeletonAuthorizeMethodId
}

/*
DisconnectAuthorizeMethod disconnects a callback from the 'authorize-method' signal for the DBusObjectSkeleton.

The connectionID should be a value returned from a call to ConnectAuthorizeMethod.
*/
func (recv *DBusObjectSkeleton) DisconnectAuthorizeMethod(connectionID int) {
	signalDBusObjectSkeletonAuthorizeMethodLock.Lock()
	defer signalDBusObjectSkeletonAuthorizeMethodLock.Unlock()

	detail, exists := signalDBusObjectSkeletonAuthorizeMethodMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusObjectSkeletonAuthorizeMethodMap, connectionID)
}

//export dbusobjectskeleton_authorizeMethodHandler
func dbusobjectskeleton_authorizeMethodHandler(_ *C.GObject, c_interface *C.GDBusInterfaceSkeleton, c_invocation *C.GDBusMethodInvocation, data C.gpointer) C.gboolean {
	signalDBusObjectSkeletonAuthorizeMethodLock.RLock()
	defer signalDBusObjectSkeletonAuthorizeMethodLock.RUnlock()

	interface_ := DBusInterfaceSkeletonNewFromC(unsafe.Pointer(c_interface))

	invocation := DBusMethodInvocationNewFromC(unsafe.Pointer(c_invocation))

	index := int(uintptr(data))
	callback := signalDBusObjectSkeletonAuthorizeMethodMap[index].callback
	retGo := callback(interface_, invocation)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// DBusObjectSkeletonNew is a wrapper around the C function g_dbus_object_skeleton_new.
func DBusObjectSkeletonNew(objectPath string) *DBusObjectSkeleton {
	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	retC := C.g_dbus_object_skeleton_new(c_object_path)
	retGo := DBusObjectSkeletonNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddInterface is a wrapper around the C function g_dbus_object_skeleton_add_interface.
func (recv *DBusObjectSkeleton) AddInterface(interface_ *DBusInterfaceSkeleton) {
	c_interface_ := (*C.GDBusInterfaceSkeleton)(C.NULL)
	if interface_ != nil {
		c_interface_ = (*C.GDBusInterfaceSkeleton)(interface_.ToC())
	}

	C.g_dbus_object_skeleton_add_interface((*C.GDBusObjectSkeleton)(recv.native), c_interface_)

	return
}

// Flush is a wrapper around the C function g_dbus_object_skeleton_flush.
func (recv *DBusObjectSkeleton) Flush() {
	C.g_dbus_object_skeleton_flush((*C.GDBusObjectSkeleton)(recv.native))

	return
}

// RemoveInterface is a wrapper around the C function g_dbus_object_skeleton_remove_interface.
func (recv *DBusObjectSkeleton) RemoveInterface(interface_ *DBusInterfaceSkeleton) {
	c_interface_ := (*C.GDBusInterfaceSkeleton)(C.NULL)
	if interface_ != nil {
		c_interface_ = (*C.GDBusInterfaceSkeleton)(interface_.ToC())
	}

	C.g_dbus_object_skeleton_remove_interface((*C.GDBusObjectSkeleton)(recv.native), c_interface_)

	return
}

// RemoveInterfaceByName is a wrapper around the C function g_dbus_object_skeleton_remove_interface_by_name.
func (recv *DBusObjectSkeleton) RemoveInterfaceByName(interfaceName string) {
	c_interface_name := C.CString(interfaceName)
	defer C.free(unsafe.Pointer(c_interface_name))

	C.g_dbus_object_skeleton_remove_interface_by_name((*C.GDBusObjectSkeleton)(recv.native), c_interface_name)

	return
}

// SetObjectPath is a wrapper around the C function g_dbus_object_skeleton_set_object_path.
func (recv *DBusObjectSkeleton) SetObjectPath(objectPath string) {
	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	C.g_dbus_object_skeleton_set_object_path((*C.GDBusObjectSkeleton)(recv.native), c_object_path)

	return
}

// DBusObject returns the DBusObject interface implemented by DBusObjectSkeleton
func (recv *DBusObjectSkeleton) DBusObject() *DBusObject {
	return DBusObjectNewFromC(recv.ToC())
}

// DBusProxy is a wrapper around the C record GDBusProxy.
type DBusProxy struct {
	native *C.GDBusProxy
	// Private : parent_instance
	// Private : priv
}

func DBusProxyNewFromC(u unsafe.Pointer) *DBusProxy {
	c := (*C.GDBusProxy)(u)
	if c == nil {
		return nil
	}

	g := &DBusProxy{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusProxy) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusProxy) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusProxy with another DBusProxy, and returns true if they represent the same GObject.
func (recv *DBusProxy) Equals(other *DBusProxy) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusProxy) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusProxy.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusProxy.
func CastToDBusProxy(object *gobject.Object) *DBusProxy {
	return DBusProxyNewFromC(object.ToC())
}

// Unsupported signal 'g-properties-changed' for DBusProxy : unsupported parameter invalidated_properties :

type signalDBusProxyGSignalDetail struct {
	callback  DBusProxySignalGSignalCallback
	handlerID C.gulong
}

var signalDBusProxyGSignalId int
var signalDBusProxyGSignalMap = make(map[int]signalDBusProxyGSignalDetail)
var signalDBusProxyGSignalLock sync.RWMutex

// DBusProxySignalGSignalCallback is a callback function for a 'g-signal' signal emitted from a DBusProxy.
type DBusProxySignalGSignalCallback func(senderName string, signalName string, parameters *glib.Variant)

/*
ConnectGSignal connects the callback to the 'g-signal' signal for the DBusProxy.

The returned value represents the connection, and may be passed to DisconnectGSignal to remove it.
*/
func (recv *DBusProxy) ConnectGSignal(callback DBusProxySignalGSignalCallback) int {
	signalDBusProxyGSignalLock.Lock()
	defer signalDBusProxyGSignalLock.Unlock()

	signalDBusProxyGSignalId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusProxy_signal_connect_g_signal(instance, C.gpointer(uintptr(signalDBusProxyGSignalId)))

	detail := signalDBusProxyGSignalDetail{callback, handlerID}
	signalDBusProxyGSignalMap[signalDBusProxyGSignalId] = detail

	return signalDBusProxyGSignalId
}

/*
DisconnectGSignal disconnects a callback from the 'g-signal' signal for the DBusProxy.

The connectionID should be a value returned from a call to ConnectGSignal.
*/
func (recv *DBusProxy) DisconnectGSignal(connectionID int) {
	signalDBusProxyGSignalLock.Lock()
	defer signalDBusProxyGSignalLock.Unlock()

	detail, exists := signalDBusProxyGSignalMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusProxyGSignalMap, connectionID)
}

//export dbusproxy_gSignalHandler
func dbusproxy_gSignalHandler(_ *C.GObject, c_sender_name *C.gchar, c_signal_name *C.gchar, c_parameters *C.GVariant, data C.gpointer) {
	signalDBusProxyGSignalLock.RLock()
	defer signalDBusProxyGSignalLock.RUnlock()

	senderName := C.GoString(c_sender_name)

	signalName := C.GoString(c_signal_name)

	parameters := glib.VariantNewFromC(unsafe.Pointer(c_parameters))

	index := int(uintptr(data))
	callback := signalDBusProxyGSignalMap[index].callback
	callback(senderName, signalName, parameters)
}

// DBusProxyNewFinish is a wrapper around the C function g_dbus_proxy_new_finish.
func DBusProxyNewFinish(res *AsyncResult) (*DBusProxy, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_proxy_new_finish(c_res, &cThrowableError)
	retGo := DBusProxyNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusProxyNewForBusFinish is a wrapper around the C function g_dbus_proxy_new_for_bus_finish.
func DBusProxyNewForBusFinish(res *AsyncResult) (*DBusProxy, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_proxy_new_for_bus_finish(c_res, &cThrowableError)
	retGo := DBusProxyNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusProxyNewForBusSync is a wrapper around the C function g_dbus_proxy_new_for_bus_sync.
func DBusProxyNewForBusSync(busType BusType, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable *Cancellable) (*DBusProxy, error) {
	c_bus_type := (C.GBusType)(busType)

	c_flags := (C.GDBusProxyFlags)(flags)

	c_info := (*C.GDBusInterfaceInfo)(C.NULL)
	if info != nil {
		c_info = (*C.GDBusInterfaceInfo)(info.ToC())
	}

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	c_interface_name := C.CString(interfaceName)
	defer C.free(unsafe.Pointer(c_interface_name))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_proxy_new_for_bus_sync(c_bus_type, c_flags, c_info, c_name, c_object_path, c_interface_name, c_cancellable, &cThrowableError)
	retGo := DBusProxyNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DBusProxyNewSync is a wrapper around the C function g_dbus_proxy_new_sync.
func DBusProxyNewSync(connection *DBusConnection, flags DBusProxyFlags, info *DBusInterfaceInfo, name string, objectPath string, interfaceName string, cancellable *Cancellable) (*DBusProxy, error) {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	c_flags := (C.GDBusProxyFlags)(flags)

	c_info := (*C.GDBusInterfaceInfo)(C.NULL)
	if info != nil {
		c_info = (*C.GDBusInterfaceInfo)(info.ToC())
	}

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	c_interface_name := C.CString(interfaceName)
	defer C.free(unsafe.Pointer(c_interface_name))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_proxy_new_sync(c_connection, c_flags, c_info, c_name, c_object_path, c_interface_name, c_cancellable, &cThrowableError)
	retGo := DBusProxyNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// g_dbus_proxy_new : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback
// g_dbus_proxy_new_for_bus : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback
// Unsupported : g_dbus_proxy_call : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CallFinish is a wrapper around the C function g_dbus_proxy_call_finish.
func (recv *DBusProxy) CallFinish(res *AsyncResult) (*glib.Variant, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_proxy_call_finish((*C.GDBusProxy)(recv.native), c_res, &cThrowableError)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// CallSync is a wrapper around the C function g_dbus_proxy_call_sync.
func (recv *DBusProxy) CallSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int32, cancellable *Cancellable) (*glib.Variant, error) {
	c_method_name := C.CString(methodName)
	defer C.free(unsafe.Pointer(c_method_name))

	c_parameters := (*C.GVariant)(C.NULL)
	if parameters != nil {
		c_parameters = (*C.GVariant)(parameters.ToC())
	}

	c_flags := (C.GDBusCallFlags)(flags)

	c_timeout_msec := (C.gint)(timeoutMsec)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_proxy_call_sync((*C.GDBusProxy)(recv.native), c_method_name, c_parameters, c_flags, c_timeout_msec, c_cancellable, &cThrowableError)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_dbus_proxy_call_with_unix_fd_list : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CallWithUnixFdListFinish is a wrapper around the C function g_dbus_proxy_call_with_unix_fd_list_finish.
func (recv *DBusProxy) CallWithUnixFdListFinish(res *AsyncResult) (*glib.Variant, *UnixFDList, error) {
	var c_out_fd_list *C.GUnixFDList

	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_dbus_proxy_call_with_unix_fd_list_finish((*C.GDBusProxy)(recv.native), &c_out_fd_list, c_res, &cThrowableError)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	outFdList := UnixFDListNewFromC(unsafe.Pointer(c_out_fd_list))

	return retGo, outFdList, goError
}

// CallWithUnixFdListSync is a wrapper around the C function g_dbus_proxy_call_with_unix_fd_list_sync.
func (recv *DBusProxy) CallWithUnixFdListSync(methodName string, parameters *glib.Variant, flags DBusCallFlags, timeoutMsec int32, fdList *UnixFDList, cancellable *Cancellable) (*glib.Variant, *UnixFDList, error) {
	c_method_name := C.CString(methodName)
	defer C.free(unsafe.Pointer(c_method_name))

	c_parameters := (*C.GVariant)(C.NULL)
	if parameters != nil {
		c_parameters = (*C.GVariant)(parameters.ToC())
	}

	c_flags := (C.GDBusCallFlags)(flags)

	c_timeout_msec := (C.gint)(timeoutMsec)

	c_fd_list := (*C.GUnixFDList)(C.NULL)
	if fdList != nil {
		c_fd_list = (*C.GUnixFDList)(fdList.ToC())
	}

	var c_out_fd_list *C.GUnixFDList

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_proxy_call_with_unix_fd_list_sync((*C.GDBusProxy)(recv.native), c_method_name, c_parameters, c_flags, c_timeout_msec, c_fd_list, &c_out_fd_list, c_cancellable, &cThrowableError)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	outFdList := UnixFDListNewFromC(unsafe.Pointer(c_out_fd_list))

	return retGo, outFdList, goError
}

// GetCachedProperty is a wrapper around the C function g_dbus_proxy_get_cached_property.
func (recv *DBusProxy) GetCachedProperty(propertyName string) *glib.Variant {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	retC := C.g_dbus_proxy_get_cached_property((*C.GDBusProxy)(recv.native), c_property_name)
	var retGo (*glib.Variant)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetCachedPropertyNames is a wrapper around the C function g_dbus_proxy_get_cached_property_names.
func (recv *DBusProxy) GetCachedPropertyNames() []string {
	retC := C.g_dbus_proxy_get_cached_property_names((*C.GDBusProxy)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// GetConnection is a wrapper around the C function g_dbus_proxy_get_connection.
func (recv *DBusProxy) GetConnection() *DBusConnection {
	retC := C.g_dbus_proxy_get_connection((*C.GDBusProxy)(recv.native))
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDefaultTimeout is a wrapper around the C function g_dbus_proxy_get_default_timeout.
func (recv *DBusProxy) GetDefaultTimeout() int32 {
	retC := C.g_dbus_proxy_get_default_timeout((*C.GDBusProxy)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetFlags is a wrapper around the C function g_dbus_proxy_get_flags.
func (recv *DBusProxy) GetFlags() DBusProxyFlags {
	retC := C.g_dbus_proxy_get_flags((*C.GDBusProxy)(recv.native))
	retGo := (DBusProxyFlags)(retC)

	return retGo
}

// GetInterfaceInfo is a wrapper around the C function g_dbus_proxy_get_interface_info.
func (recv *DBusProxy) GetInterfaceInfo() *DBusInterfaceInfo {
	retC := C.g_dbus_proxy_get_interface_info((*C.GDBusProxy)(recv.native))
	var retGo (*DBusInterfaceInfo)
	if retC == nil {
		retGo = nil
	} else {
		retGo = DBusInterfaceInfoNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetInterfaceName is a wrapper around the C function g_dbus_proxy_get_interface_name.
func (recv *DBusProxy) GetInterfaceName() string {
	retC := C.g_dbus_proxy_get_interface_name((*C.GDBusProxy)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetName is a wrapper around the C function g_dbus_proxy_get_name.
func (recv *DBusProxy) GetName() string {
	retC := C.g_dbus_proxy_get_name((*C.GDBusProxy)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetNameOwner is a wrapper around the C function g_dbus_proxy_get_name_owner.
func (recv *DBusProxy) GetNameOwner() string {
	retC := C.g_dbus_proxy_get_name_owner((*C.GDBusProxy)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetObjectPath is a wrapper around the C function g_dbus_proxy_get_object_path.
func (recv *DBusProxy) GetObjectPath() string {
	retC := C.g_dbus_proxy_get_object_path((*C.GDBusProxy)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SetCachedProperty is a wrapper around the C function g_dbus_proxy_set_cached_property.
func (recv *DBusProxy) SetCachedProperty(propertyName string, value *glib.Variant) {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	C.g_dbus_proxy_set_cached_property((*C.GDBusProxy)(recv.native), c_property_name, c_value)

	return
}

// SetDefaultTimeout is a wrapper around the C function g_dbus_proxy_set_default_timeout.
func (recv *DBusProxy) SetDefaultTimeout(timeoutMsec int32) {
	c_timeout_msec := (C.gint)(timeoutMsec)

	C.g_dbus_proxy_set_default_timeout((*C.GDBusProxy)(recv.native), c_timeout_msec)

	return
}

// SetInterfaceInfo is a wrapper around the C function g_dbus_proxy_set_interface_info.
func (recv *DBusProxy) SetInterfaceInfo(info *DBusInterfaceInfo) {
	c_info := (*C.GDBusInterfaceInfo)(C.NULL)
	if info != nil {
		c_info = (*C.GDBusInterfaceInfo)(info.ToC())
	}

	C.g_dbus_proxy_set_interface_info((*C.GDBusProxy)(recv.native), c_info)

	return
}

// AsyncInitable returns the AsyncInitable interface implemented by DBusProxy
func (recv *DBusProxy) AsyncInitable() *AsyncInitable {
	return AsyncInitableNewFromC(recv.ToC())
}

// DBusInterface returns the DBusInterface interface implemented by DBusProxy
func (recv *DBusProxy) DBusInterface() *DBusInterface {
	return DBusInterfaceNewFromC(recv.ToC())
}

// Initable returns the Initable interface implemented by DBusProxy
func (recv *DBusProxy) Initable() *Initable {
	return InitableNewFromC(recv.ToC())
}

// DBusServer is a wrapper around the C record GDBusServer.
type DBusServer struct {
	native *C.GDBusServer
}

func DBusServerNewFromC(u unsafe.Pointer) *DBusServer {
	c := (*C.GDBusServer)(u)
	if c == nil {
		return nil
	}

	g := &DBusServer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DBusServer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DBusServer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusServer with another DBusServer, and returns true if they represent the same GObject.
func (recv *DBusServer) Equals(other *DBusServer) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DBusServer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DBusServer.
// Exercise care, as this is a potentially dangerous function if the Object is not a DBusServer.
func CastToDBusServer(object *gobject.Object) *DBusServer {
	return DBusServerNewFromC(object.ToC())
}

type signalDBusServerNewConnectionDetail struct {
	callback  DBusServerSignalNewConnectionCallback
	handlerID C.gulong
}

var signalDBusServerNewConnectionId int
var signalDBusServerNewConnectionMap = make(map[int]signalDBusServerNewConnectionDetail)
var signalDBusServerNewConnectionLock sync.RWMutex

// DBusServerSignalNewConnectionCallback is a callback function for a 'new-connection' signal emitted from a DBusServer.
type DBusServerSignalNewConnectionCallback func(connection *DBusConnection) bool

/*
ConnectNewConnection connects the callback to the 'new-connection' signal for the DBusServer.

The returned value represents the connection, and may be passed to DisconnectNewConnection to remove it.
*/
func (recv *DBusServer) ConnectNewConnection(callback DBusServerSignalNewConnectionCallback) int {
	signalDBusServerNewConnectionLock.Lock()
	defer signalDBusServerNewConnectionLock.Unlock()

	signalDBusServerNewConnectionId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusServer_signal_connect_new_connection(instance, C.gpointer(uintptr(signalDBusServerNewConnectionId)))

	detail := signalDBusServerNewConnectionDetail{callback, handlerID}
	signalDBusServerNewConnectionMap[signalDBusServerNewConnectionId] = detail

	return signalDBusServerNewConnectionId
}

/*
DisconnectNewConnection disconnects a callback from the 'new-connection' signal for the DBusServer.

The connectionID should be a value returned from a call to ConnectNewConnection.
*/
func (recv *DBusServer) DisconnectNewConnection(connectionID int) {
	signalDBusServerNewConnectionLock.Lock()
	defer signalDBusServerNewConnectionLock.Unlock()

	detail, exists := signalDBusServerNewConnectionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusServerNewConnectionMap, connectionID)
}

//export dbusserver_newConnectionHandler
func dbusserver_newConnectionHandler(_ *C.GObject, c_connection *C.GDBusConnection, data C.gpointer) C.gboolean {
	signalDBusServerNewConnectionLock.RLock()
	defer signalDBusServerNewConnectionLock.RUnlock()

	connection := DBusConnectionNewFromC(unsafe.Pointer(c_connection))

	index := int(uintptr(data))
	callback := signalDBusServerNewConnectionMap[index].callback
	retGo := callback(connection)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// DBusServerNewSync is a wrapper around the C function g_dbus_server_new_sync.
func DBusServerNewSync(address string, flags DBusServerFlags, guid string, observer *DBusAuthObserver, cancellable *Cancellable) (*DBusServer, error) {
	c_address := C.CString(address)
	defer C.free(unsafe.Pointer(c_address))

	c_flags := (C.GDBusServerFlags)(flags)

	c_guid := C.CString(guid)
	defer C.free(unsafe.Pointer(c_guid))

	c_observer := (*C.GDBusAuthObserver)(C.NULL)
	if observer != nil {
		c_observer = (*C.GDBusAuthObserver)(observer.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_server_new_sync(c_address, c_flags, c_guid, c_observer, c_cancellable, &cThrowableError)
	retGo := DBusServerNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetClientAddress is a wrapper around the C function g_dbus_server_get_client_address.
func (recv *DBusServer) GetClientAddress() string {
	retC := C.g_dbus_server_get_client_address((*C.GDBusServer)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetFlags is a wrapper around the C function g_dbus_server_get_flags.
func (recv *DBusServer) GetFlags() DBusServerFlags {
	retC := C.g_dbus_server_get_flags((*C.GDBusServer)(recv.native))
	retGo := (DBusServerFlags)(retC)

	return retGo
}

// GetGuid is a wrapper around the C function g_dbus_server_get_guid.
func (recv *DBusServer) GetGuid() string {
	retC := C.g_dbus_server_get_guid((*C.GDBusServer)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// IsActive is a wrapper around the C function g_dbus_server_is_active.
func (recv *DBusServer) IsActive() bool {
	retC := C.g_dbus_server_is_active((*C.GDBusServer)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Start is a wrapper around the C function g_dbus_server_start.
func (recv *DBusServer) Start() {
	C.g_dbus_server_start((*C.GDBusServer)(recv.native))

	return
}

// Stop is a wrapper around the C function g_dbus_server_stop.
func (recv *DBusServer) Stop() {
	C.g_dbus_server_stop((*C.GDBusServer)(recv.native))

	return
}

// Initable returns the Initable interface implemented by DBusServer
func (recv *DBusServer) Initable() *Initable {
	return InitableNewFromC(recv.ToC())
}

// DataInputStream is a wrapper around the C record GDataInputStream.
type DataInputStream struct {
	native *C.GDataInputStream
	// parent_instance : record
	// Private : priv
}

func DataInputStreamNewFromC(u unsafe.Pointer) *DataInputStream {
	c := (*C.GDataInputStream)(u)
	if c == nil {
		return nil
	}

	g := &DataInputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DataInputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DataInputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DataInputStream with another DataInputStream, and returns true if they represent the same GObject.
func (recv *DataInputStream) Equals(other *DataInputStream) bool {
	return other.ToC() == recv.ToC()
}

// BufferedInputStream upcasts to *BufferedInputStream
func (recv *DataInputStream) BufferedInputStream() *BufferedInputStream {
	return BufferedInputStreamNewFromC(unsafe.Pointer(recv.native))
}

// FilterInputStream upcasts to *FilterInputStream
func (recv *DataInputStream) FilterInputStream() *FilterInputStream {
	return recv.BufferedInputStream().FilterInputStream()
}

// InputStream upcasts to *InputStream
func (recv *DataInputStream) InputStream() *InputStream {
	return recv.BufferedInputStream().InputStream()
}

// Object upcasts to *Object
func (recv *DataInputStream) Object() *gobject.Object {
	return recv.BufferedInputStream().Object()
}

// CastToWidget down casts any arbitrary Object to DataInputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a DataInputStream.
func CastToDataInputStream(object *gobject.Object) *DataInputStream {
	return DataInputStreamNewFromC(object.ToC())
}

// DataInputStreamNew is a wrapper around the C function g_data_input_stream_new.
func DataInputStreamNew(baseStream *InputStream) *DataInputStream {
	c_base_stream := (*C.GInputStream)(C.NULL)
	if baseStream != nil {
		c_base_stream = (*C.GInputStream)(baseStream.ToC())
	}

	retC := C.g_data_input_stream_new(c_base_stream)
	retGo := DataInputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetByteOrder is a wrapper around the C function g_data_input_stream_get_byte_order.
func (recv *DataInputStream) GetByteOrder() DataStreamByteOrder {
	retC := C.g_data_input_stream_get_byte_order((*C.GDataInputStream)(recv.native))
	retGo := (DataStreamByteOrder)(retC)

	return retGo
}

// GetNewlineType is a wrapper around the C function g_data_input_stream_get_newline_type.
func (recv *DataInputStream) GetNewlineType() DataStreamNewlineType {
	retC := C.g_data_input_stream_get_newline_type((*C.GDataInputStream)(recv.native))
	retGo := (DataStreamNewlineType)(retC)

	return retGo
}

// ReadByte is a wrapper around the C function g_data_input_stream_read_byte.
func (recv *DataInputStream) ReadByte(cancellable *Cancellable) (uint8, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_byte((*C.GDataInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := (uint8)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReadInt16 is a wrapper around the C function g_data_input_stream_read_int16.
func (recv *DataInputStream) ReadInt16(cancellable *Cancellable) (int16, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_int16((*C.GDataInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := (int16)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReadInt32 is a wrapper around the C function g_data_input_stream_read_int32.
func (recv *DataInputStream) ReadInt32(cancellable *Cancellable) (int32, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_int32((*C.GDataInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := (int32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReadInt64 is a wrapper around the C function g_data_input_stream_read_int64.
func (recv *DataInputStream) ReadInt64(cancellable *Cancellable) (int64, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_int64((*C.GDataInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_data_input_stream_read_line : array return type :

// Unsupported : g_data_input_stream_read_line_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Unsupported : g_data_input_stream_read_line_finish : array return type :

// ReadLineFinishUtf8 is a wrapper around the C function g_data_input_stream_read_line_finish_utf8.
func (recv *DataInputStream) ReadLineFinishUtf8(result *AsyncResult) (string, uint64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var c_length C.gsize

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_line_finish_utf8((*C.GDataInputStream)(recv.native), c_result, &c_length, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	length := (uint64)(c_length)

	return retGo, length, goError
}

// ReadLineUtf8 is a wrapper around the C function g_data_input_stream_read_line_utf8.
func (recv *DataInputStream) ReadLineUtf8(cancellable *Cancellable) (string, uint64, error) {
	var c_length C.gsize

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_line_utf8((*C.GDataInputStream)(recv.native), &c_length, c_cancellable, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	length := (uint64)(c_length)

	return retGo, length, goError
}

// ReadUint16 is a wrapper around the C function g_data_input_stream_read_uint16.
func (recv *DataInputStream) ReadUint16(cancellable *Cancellable) (uint16, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_uint16((*C.GDataInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := (uint16)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReadUint32 is a wrapper around the C function g_data_input_stream_read_uint32.
func (recv *DataInputStream) ReadUint32(cancellable *Cancellable) (uint32, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_uint32((*C.GDataInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := (uint32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReadUint64 is a wrapper around the C function g_data_input_stream_read_uint64.
func (recv *DataInputStream) ReadUint64(cancellable *Cancellable) (uint64, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_uint64((*C.GDataInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := (uint64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReadUntil is a wrapper around the C function g_data_input_stream_read_until.
func (recv *DataInputStream) ReadUntil(stopChars string, cancellable *Cancellable) (string, uint64, error) {
	c_stop_chars := C.CString(stopChars)
	defer C.free(unsafe.Pointer(c_stop_chars))

	var c_length C.gsize

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_until((*C.GDataInputStream)(recv.native), c_stop_chars, &c_length, c_cancellable, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	length := (uint64)(c_length)

	return retGo, length, goError
}

// Unsupported : g_data_input_stream_read_until_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReadUntilFinish is a wrapper around the C function g_data_input_stream_read_until_finish.
func (recv *DataInputStream) ReadUntilFinish(result *AsyncResult) (string, uint64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var c_length C.gsize

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_until_finish((*C.GDataInputStream)(recv.native), c_result, &c_length, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	length := (uint64)(c_length)

	return retGo, length, goError
}

// ReadUpto is a wrapper around the C function g_data_input_stream_read_upto.
func (recv *DataInputStream) ReadUpto(stopChars string, stopCharsLen int64, cancellable *Cancellable) (string, uint64, error) {
	c_stop_chars := C.CString(stopChars)
	defer C.free(unsafe.Pointer(c_stop_chars))

	c_stop_chars_len := (C.gssize)(stopCharsLen)

	var c_length C.gsize

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_upto((*C.GDataInputStream)(recv.native), c_stop_chars, c_stop_chars_len, &c_length, c_cancellable, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	length := (uint64)(c_length)

	return retGo, length, goError
}

// Unsupported : g_data_input_stream_read_upto_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReadUptoFinish is a wrapper around the C function g_data_input_stream_read_upto_finish.
func (recv *DataInputStream) ReadUptoFinish(result *AsyncResult) (string, uint64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var c_length C.gsize

	var cThrowableError *C.GError

	retC := C.g_data_input_stream_read_upto_finish((*C.GDataInputStream)(recv.native), c_result, &c_length, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	length := (uint64)(c_length)

	return retGo, length, goError
}

// SetByteOrder is a wrapper around the C function g_data_input_stream_set_byte_order.
func (recv *DataInputStream) SetByteOrder(order DataStreamByteOrder) {
	c_order := (C.GDataStreamByteOrder)(order)

	C.g_data_input_stream_set_byte_order((*C.GDataInputStream)(recv.native), c_order)

	return
}

// SetNewlineType is a wrapper around the C function g_data_input_stream_set_newline_type.
func (recv *DataInputStream) SetNewlineType(type_ DataStreamNewlineType) {
	c_type := (C.GDataStreamNewlineType)(type_)

	C.g_data_input_stream_set_newline_type((*C.GDataInputStream)(recv.native), c_type)

	return
}

// Seekable returns the Seekable interface implemented by DataInputStream
func (recv *DataInputStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// DataOutputStream is a wrapper around the C record GDataOutputStream.
type DataOutputStream struct {
	native *C.GDataOutputStream
	// parent_instance : record
	// Private : priv
}

func DataOutputStreamNewFromC(u unsafe.Pointer) *DataOutputStream {
	c := (*C.GDataOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &DataOutputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DataOutputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DataOutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DataOutputStream with another DataOutputStream, and returns true if they represent the same GObject.
func (recv *DataOutputStream) Equals(other *DataOutputStream) bool {
	return other.ToC() == recv.ToC()
}

// FilterOutputStream upcasts to *FilterOutputStream
func (recv *DataOutputStream) FilterOutputStream() *FilterOutputStream {
	return FilterOutputStreamNewFromC(unsafe.Pointer(recv.native))
}

// OutputStream upcasts to *OutputStream
func (recv *DataOutputStream) OutputStream() *OutputStream {
	return recv.FilterOutputStream().OutputStream()
}

// Object upcasts to *Object
func (recv *DataOutputStream) Object() *gobject.Object {
	return recv.FilterOutputStream().Object()
}

// CastToWidget down casts any arbitrary Object to DataOutputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a DataOutputStream.
func CastToDataOutputStream(object *gobject.Object) *DataOutputStream {
	return DataOutputStreamNewFromC(object.ToC())
}

// DataOutputStreamNew is a wrapper around the C function g_data_output_stream_new.
func DataOutputStreamNew(baseStream *OutputStream) *DataOutputStream {
	c_base_stream := (*C.GOutputStream)(C.NULL)
	if baseStream != nil {
		c_base_stream = (*C.GOutputStream)(baseStream.ToC())
	}

	retC := C.g_data_output_stream_new(c_base_stream)
	retGo := DataOutputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetByteOrder is a wrapper around the C function g_data_output_stream_get_byte_order.
func (recv *DataOutputStream) GetByteOrder() DataStreamByteOrder {
	retC := C.g_data_output_stream_get_byte_order((*C.GDataOutputStream)(recv.native))
	retGo := (DataStreamByteOrder)(retC)

	return retGo
}

// PutByte is a wrapper around the C function g_data_output_stream_put_byte.
func (recv *DataOutputStream) PutByte(data uint8, cancellable *Cancellable) (bool, error) {
	c_data := (C.guchar)(data)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_output_stream_put_byte((*C.GDataOutputStream)(recv.native), c_data, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PutInt16 is a wrapper around the C function g_data_output_stream_put_int16.
func (recv *DataOutputStream) PutInt16(data int16, cancellable *Cancellable) (bool, error) {
	c_data := (C.gint16)(data)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_output_stream_put_int16((*C.GDataOutputStream)(recv.native), c_data, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PutInt32 is a wrapper around the C function g_data_output_stream_put_int32.
func (recv *DataOutputStream) PutInt32(data int32, cancellable *Cancellable) (bool, error) {
	c_data := (C.gint32)(data)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_output_stream_put_int32((*C.GDataOutputStream)(recv.native), c_data, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PutInt64 is a wrapper around the C function g_data_output_stream_put_int64.
func (recv *DataOutputStream) PutInt64(data int64, cancellable *Cancellable) (bool, error) {
	c_data := (C.gint64)(data)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_output_stream_put_int64((*C.GDataOutputStream)(recv.native), c_data, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PutString is a wrapper around the C function g_data_output_stream_put_string.
func (recv *DataOutputStream) PutString(str string, cancellable *Cancellable) (bool, error) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_output_stream_put_string((*C.GDataOutputStream)(recv.native), c_str, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PutUint16 is a wrapper around the C function g_data_output_stream_put_uint16.
func (recv *DataOutputStream) PutUint16(data uint16, cancellable *Cancellable) (bool, error) {
	c_data := (C.guint16)(data)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_output_stream_put_uint16((*C.GDataOutputStream)(recv.native), c_data, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PutUint32 is a wrapper around the C function g_data_output_stream_put_uint32.
func (recv *DataOutputStream) PutUint32(data uint32, cancellable *Cancellable) (bool, error) {
	c_data := (C.guint32)(data)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_output_stream_put_uint32((*C.GDataOutputStream)(recv.native), c_data, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PutUint64 is a wrapper around the C function g_data_output_stream_put_uint64.
func (recv *DataOutputStream) PutUint64(data uint64, cancellable *Cancellable) (bool, error) {
	c_data := (C.guint64)(data)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_data_output_stream_put_uint64((*C.GDataOutputStream)(recv.native), c_data, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetByteOrder is a wrapper around the C function g_data_output_stream_set_byte_order.
func (recv *DataOutputStream) SetByteOrder(order DataStreamByteOrder) {
	c_order := (C.GDataStreamByteOrder)(order)

	C.g_data_output_stream_set_byte_order((*C.GDataOutputStream)(recv.native), c_order)

	return
}

// Seekable returns the Seekable interface implemented by DataOutputStream
func (recv *DataOutputStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// DesktopAppInfo is a wrapper around the C record GDesktopAppInfo.
type DesktopAppInfo struct {
	native *C.GDesktopAppInfo
}

func DesktopAppInfoNewFromC(u unsafe.Pointer) *DesktopAppInfo {
	c := (*C.GDesktopAppInfo)(u)
	if c == nil {
		return nil
	}

	g := &DesktopAppInfo{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DesktopAppInfo) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DesktopAppInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DesktopAppInfo with another DesktopAppInfo, and returns true if they represent the same GObject.
func (recv *DesktopAppInfo) Equals(other *DesktopAppInfo) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *DesktopAppInfo) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to DesktopAppInfo.
// Exercise care, as this is a potentially dangerous function if the Object is not a DesktopAppInfo.
func CastToDesktopAppInfo(object *gobject.Object) *DesktopAppInfo {
	return DesktopAppInfoNewFromC(object.ToC())
}

// DesktopAppInfoNew is a wrapper around the C function g_desktop_app_info_new.
func DesktopAppInfoNew(desktopId string) *DesktopAppInfo {
	c_desktop_id := C.CString(desktopId)
	defer C.free(unsafe.Pointer(c_desktop_id))

	retC := C.g_desktop_app_info_new(c_desktop_id)
	retGo := DesktopAppInfoNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// DesktopAppInfoNewFromFilename is a wrapper around the C function g_desktop_app_info_new_from_filename.
func DesktopAppInfoNewFromFilename(filename string) *DesktopAppInfo {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.g_desktop_app_info_new_from_filename(c_filename)
	retGo := DesktopAppInfoNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// DesktopAppInfoNewFromKeyfile is a wrapper around the C function g_desktop_app_info_new_from_keyfile.
func DesktopAppInfoNewFromKeyfile(keyFile *glib.KeyFile) *DesktopAppInfo {
	c_key_file := (*C.GKeyFile)(C.NULL)
	if keyFile != nil {
		c_key_file = (*C.GKeyFile)(keyFile.ToC())
	}

	retC := C.g_desktop_app_info_new_from_keyfile(c_key_file)
	retGo := DesktopAppInfoNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// g_desktop_app_info_search : no type for array return
// DesktopAppInfoSetDesktopEnv is a wrapper around the C function g_desktop_app_info_set_desktop_env.
func DesktopAppInfoSetDesktopEnv(desktopEnv string) {
	c_desktop_env := C.CString(desktopEnv)
	defer C.free(unsafe.Pointer(c_desktop_env))

	C.g_desktop_app_info_set_desktop_env(c_desktop_env)

	return
}

// GetBoolean is a wrapper around the C function g_desktop_app_info_get_boolean.
func (recv *DesktopAppInfo) GetBoolean(key string) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_desktop_app_info_get_boolean((*C.GDesktopAppInfo)(recv.native), c_key)
	retGo := retC == C.TRUE

	return retGo
}

// GetCategories is a wrapper around the C function g_desktop_app_info_get_categories.
func (recv *DesktopAppInfo) GetCategories() string {
	retC := C.g_desktop_app_info_get_categories((*C.GDesktopAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetFilename is a wrapper around the C function g_desktop_app_info_get_filename.
func (recv *DesktopAppInfo) GetFilename() string {
	retC := C.g_desktop_app_info_get_filename((*C.GDesktopAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetGenericName is a wrapper around the C function g_desktop_app_info_get_generic_name.
func (recv *DesktopAppInfo) GetGenericName() string {
	retC := C.g_desktop_app_info_get_generic_name((*C.GDesktopAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetIsHidden is a wrapper around the C function g_desktop_app_info_get_is_hidden.
func (recv *DesktopAppInfo) GetIsHidden() bool {
	retC := C.g_desktop_app_info_get_is_hidden((*C.GDesktopAppInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetKeywords is a wrapper around the C function g_desktop_app_info_get_keywords.
func (recv *DesktopAppInfo) GetKeywords() []string {
	retC := C.g_desktop_app_info_get_keywords((*C.GDesktopAppInfo)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// GetNodisplay is a wrapper around the C function g_desktop_app_info_get_nodisplay.
func (recv *DesktopAppInfo) GetNodisplay() bool {
	retC := C.g_desktop_app_info_get_nodisplay((*C.GDesktopAppInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowIn is a wrapper around the C function g_desktop_app_info_get_show_in.
func (recv *DesktopAppInfo) GetShowIn(desktopEnv string) bool {
	c_desktop_env := C.CString(desktopEnv)
	defer C.free(unsafe.Pointer(c_desktop_env))

	retC := C.g_desktop_app_info_get_show_in((*C.GDesktopAppInfo)(recv.native), c_desktop_env)
	retGo := retC == C.TRUE

	return retGo
}

// GetStartupWmClass is a wrapper around the C function g_desktop_app_info_get_startup_wm_class.
func (recv *DesktopAppInfo) GetStartupWmClass() string {
	retC := C.g_desktop_app_info_get_startup_wm_class((*C.GDesktopAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetString is a wrapper around the C function g_desktop_app_info_get_string.
func (recv *DesktopAppInfo) GetString(key string) string {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_desktop_app_info_get_string((*C.GDesktopAppInfo)(recv.native), c_key)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// HasKey is a wrapper around the C function g_desktop_app_info_has_key.
func (recv *DesktopAppInfo) HasKey(key string) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_desktop_app_info_has_key((*C.GDesktopAppInfo)(recv.native), c_key)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_desktop_app_info_launch_uris_as_manager : unsupported parameter user_setup : no type generator for GLib.SpawnChildSetupFunc (GSpawnChildSetupFunc) for param user_setup

// AppInfo returns the AppInfo interface implemented by DesktopAppInfo
func (recv *DesktopAppInfo) AppInfo() *AppInfo {
	return AppInfoNewFromC(recv.ToC())
}

// Emblem is a wrapper around the C record GEmblem.
type Emblem struct {
	native *C.GEmblem
}

func EmblemNewFromC(u unsafe.Pointer) *Emblem {
	c := (*C.GEmblem)(u)
	if c == nil {
		return nil
	}

	g := &Emblem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Emblem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Emblem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Emblem with another Emblem, and returns true if they represent the same GObject.
func (recv *Emblem) Equals(other *Emblem) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Emblem) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Emblem.
// Exercise care, as this is a potentially dangerous function if the Object is not a Emblem.
func CastToEmblem(object *gobject.Object) *Emblem {
	return EmblemNewFromC(object.ToC())
}

// EmblemNew is a wrapper around the C function g_emblem_new.
func EmblemNew(icon *Icon) *Emblem {
	c_icon := (*C.GIcon)(icon.ToC())

	retC := C.g_emblem_new(c_icon)
	retGo := EmblemNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// EmblemNewWithOrigin is a wrapper around the C function g_emblem_new_with_origin.
func EmblemNewWithOrigin(icon *Icon, origin EmblemOrigin) *Emblem {
	c_icon := (*C.GIcon)(icon.ToC())

	c_origin := (C.GEmblemOrigin)(origin)

	retC := C.g_emblem_new_with_origin(c_icon, c_origin)
	retGo := EmblemNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetIcon is a wrapper around the C function g_emblem_get_icon.
func (recv *Emblem) GetIcon() *Icon {
	retC := C.g_emblem_get_icon((*C.GEmblem)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetOrigin is a wrapper around the C function g_emblem_get_origin.
func (recv *Emblem) GetOrigin() EmblemOrigin {
	retC := C.g_emblem_get_origin((*C.GEmblem)(recv.native))
	retGo := (EmblemOrigin)(retC)

	return retGo
}

// Icon returns the Icon interface implemented by Emblem
func (recv *Emblem) Icon() *Icon {
	return IconNewFromC(recv.ToC())
}

// EmblemedIcon is a wrapper around the C record GEmblemedIcon.
type EmblemedIcon struct {
	native *C.GEmblemedIcon
	// parent_instance : record
	// Private : priv
}

func EmblemedIconNewFromC(u unsafe.Pointer) *EmblemedIcon {
	c := (*C.GEmblemedIcon)(u)
	if c == nil {
		return nil
	}

	g := &EmblemedIcon{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EmblemedIcon) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EmblemedIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EmblemedIcon with another EmblemedIcon, and returns true if they represent the same GObject.
func (recv *EmblemedIcon) Equals(other *EmblemedIcon) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *EmblemedIcon) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to EmblemedIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a EmblemedIcon.
func CastToEmblemedIcon(object *gobject.Object) *EmblemedIcon {
	return EmblemedIconNewFromC(object.ToC())
}

// EmblemedIconNew is a wrapper around the C function g_emblemed_icon_new.
func EmblemedIconNew(icon *Icon, emblem *Emblem) *EmblemedIcon {
	c_icon := (*C.GIcon)(icon.ToC())

	c_emblem := (*C.GEmblem)(C.NULL)
	if emblem != nil {
		c_emblem = (*C.GEmblem)(emblem.ToC())
	}

	retC := C.g_emblemed_icon_new(c_icon, c_emblem)
	retGo := EmblemedIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddEmblem is a wrapper around the C function g_emblemed_icon_add_emblem.
func (recv *EmblemedIcon) AddEmblem(emblem *Emblem) {
	c_emblem := (*C.GEmblem)(C.NULL)
	if emblem != nil {
		c_emblem = (*C.GEmblem)(emblem.ToC())
	}

	C.g_emblemed_icon_add_emblem((*C.GEmblemedIcon)(recv.native), c_emblem)

	return
}

// ClearEmblems is a wrapper around the C function g_emblemed_icon_clear_emblems.
func (recv *EmblemedIcon) ClearEmblems() {
	C.g_emblemed_icon_clear_emblems((*C.GEmblemedIcon)(recv.native))

	return
}

// GetEmblems is a wrapper around the C function g_emblemed_icon_get_emblems.
func (recv *EmblemedIcon) GetEmblems() *glib.List {
	retC := C.g_emblemed_icon_get_emblems((*C.GEmblemedIcon)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIcon is a wrapper around the C function g_emblemed_icon_get_icon.
func (recv *EmblemedIcon) GetIcon() *Icon {
	retC := C.g_emblemed_icon_get_icon((*C.GEmblemedIcon)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Icon returns the Icon interface implemented by EmblemedIcon
func (recv *EmblemedIcon) Icon() *Icon {
	return IconNewFromC(recv.ToC())
}

// FileEnumerator is a wrapper around the C record GFileEnumerator.
type FileEnumerator struct {
	native *C.GFileEnumerator
	// parent_instance : record
	// Private : priv
}

func FileEnumeratorNewFromC(u unsafe.Pointer) *FileEnumerator {
	c := (*C.GFileEnumerator)(u)
	if c == nil {
		return nil
	}

	g := &FileEnumerator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileEnumerator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileEnumerator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileEnumerator with another FileEnumerator, and returns true if they represent the same GObject.
func (recv *FileEnumerator) Equals(other *FileEnumerator) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *FileEnumerator) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to FileEnumerator.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileEnumerator.
func CastToFileEnumerator(object *gobject.Object) *FileEnumerator {
	return FileEnumeratorNewFromC(object.ToC())
}

// Close is a wrapper around the C function g_file_enumerator_close.
func (recv *FileEnumerator) Close(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_enumerator_close((*C.GFileEnumerator)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_enumerator_close_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CloseFinish is a wrapper around the C function g_file_enumerator_close_finish.
func (recv *FileEnumerator) CloseFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_enumerator_close_finish((*C.GFileEnumerator)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetChild is a wrapper around the C function g_file_enumerator_get_child.
func (recv *FileEnumerator) GetChild(info *FileInfo) *File {
	c_info := (*C.GFileInfo)(C.NULL)
	if info != nil {
		c_info = (*C.GFileInfo)(info.ToC())
	}

	retC := C.g_file_enumerator_get_child((*C.GFileEnumerator)(recv.native), c_info)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetContainer is a wrapper around the C function g_file_enumerator_get_container.
func (recv *FileEnumerator) GetContainer() *File {
	retC := C.g_file_enumerator_get_container((*C.GFileEnumerator)(recv.native))
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// HasPending is a wrapper around the C function g_file_enumerator_has_pending.
func (recv *FileEnumerator) HasPending() bool {
	retC := C.g_file_enumerator_has_pending((*C.GFileEnumerator)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsClosed is a wrapper around the C function g_file_enumerator_is_closed.
func (recv *FileEnumerator) IsClosed() bool {
	retC := C.g_file_enumerator_is_closed((*C.GFileEnumerator)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// NextFile is a wrapper around the C function g_file_enumerator_next_file.
func (recv *FileEnumerator) NextFile(cancellable *Cancellable) (*FileInfo, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_enumerator_next_file((*C.GFileEnumerator)(recv.native), c_cancellable, &cThrowableError)
	var retGo (*FileInfo)
	if retC == nil {
		retGo = nil
	} else {
		retGo = FileInfoNewFromC(unsafe.Pointer(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_enumerator_next_files_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// NextFilesFinish is a wrapper around the C function g_file_enumerator_next_files_finish.
func (recv *FileEnumerator) NextFilesFinish(result *AsyncResult) (*glib.List, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_enumerator_next_files_finish((*C.GFileEnumerator)(recv.native), c_result, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetPending is a wrapper around the C function g_file_enumerator_set_pending.
func (recv *FileEnumerator) SetPending(pending bool) {
	c_pending :=
		boolToGboolean(pending)

	C.g_file_enumerator_set_pending((*C.GFileEnumerator)(recv.native), c_pending)

	return
}

// FileIOStream is a wrapper around the C record GFileIOStream.
type FileIOStream struct {
	native *C.GFileIOStream
	// parent_instance : record
	// Private : priv
}

func FileIOStreamNewFromC(u unsafe.Pointer) *FileIOStream {
	c := (*C.GFileIOStream)(u)
	if c == nil {
		return nil
	}

	g := &FileIOStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileIOStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileIOStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileIOStream with another FileIOStream, and returns true if they represent the same GObject.
func (recv *FileIOStream) Equals(other *FileIOStream) bool {
	return other.ToC() == recv.ToC()
}

// IOStream upcasts to *IOStream
func (recv *FileIOStream) IOStream() *IOStream {
	return IOStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FileIOStream) Object() *gobject.Object {
	return recv.IOStream().Object()
}

// CastToWidget down casts any arbitrary Object to FileIOStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileIOStream.
func CastToFileIOStream(object *gobject.Object) *FileIOStream {
	return FileIOStreamNewFromC(object.ToC())
}

// GetEtag is a wrapper around the C function g_file_io_stream_get_etag.
func (recv *FileIOStream) GetEtag() string {
	retC := C.g_file_io_stream_get_etag((*C.GFileIOStream)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// QueryInfo is a wrapper around the C function g_file_io_stream_query_info.
func (recv *FileIOStream) QueryInfo(attributes string, cancellable *Cancellable) (*FileInfo, error) {
	c_attributes := C.CString(attributes)
	defer C.free(unsafe.Pointer(c_attributes))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_io_stream_query_info((*C.GFileIOStream)(recv.native), c_attributes, c_cancellable, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_io_stream_query_info_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// QueryInfoFinish is a wrapper around the C function g_file_io_stream_query_info_finish.
func (recv *FileIOStream) QueryInfoFinish(result *AsyncResult) (*FileInfo, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_io_stream_query_info_finish((*C.GFileIOStream)(recv.native), c_result, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Seekable returns the Seekable interface implemented by FileIOStream
func (recv *FileIOStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// FileIcon is a wrapper around the C record GFileIcon.
type FileIcon struct {
	native *C.GFileIcon
}

func FileIconNewFromC(u unsafe.Pointer) *FileIcon {
	c := (*C.GFileIcon)(u)
	if c == nil {
		return nil
	}

	g := &FileIcon{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileIcon) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileIcon with another FileIcon, and returns true if they represent the same GObject.
func (recv *FileIcon) Equals(other *FileIcon) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *FileIcon) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to FileIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileIcon.
func CastToFileIcon(object *gobject.Object) *FileIcon {
	return FileIconNewFromC(object.ToC())
}

// FileIconNew is a wrapper around the C function g_file_icon_new.
func FileIconNew(file *File) *FileIcon {
	c_file := (*C.GFile)(file.ToC())

	retC := C.g_file_icon_new(c_file)
	retGo := FileIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetFile is a wrapper around the C function g_file_icon_get_file.
func (recv *FileIcon) GetFile() *File {
	retC := C.g_file_icon_get_file((*C.GFileIcon)(recv.native))
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Icon returns the Icon interface implemented by FileIcon
func (recv *FileIcon) Icon() *Icon {
	return IconNewFromC(recv.ToC())
}

// LoadableIcon returns the LoadableIcon interface implemented by FileIcon
func (recv *FileIcon) LoadableIcon() *LoadableIcon {
	return LoadableIconNewFromC(recv.ToC())
}

// FileInfo is a wrapper around the C record GFileInfo.
type FileInfo struct {
	native *C.GFileInfo
}

func FileInfoNewFromC(u unsafe.Pointer) *FileInfo {
	c := (*C.GFileInfo)(u)
	if c == nil {
		return nil
	}

	g := &FileInfo{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileInfo) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileInfo with another FileInfo, and returns true if they represent the same GObject.
func (recv *FileInfo) Equals(other *FileInfo) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *FileInfo) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to FileInfo.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileInfo.
func CastToFileInfo(object *gobject.Object) *FileInfo {
	return FileInfoNewFromC(object.ToC())
}

// FileInfoNew is a wrapper around the C function g_file_info_new.
func FileInfoNew() *FileInfo {
	retC := C.g_file_info_new()
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// ClearStatus is a wrapper around the C function g_file_info_clear_status.
func (recv *FileInfo) ClearStatus() {
	C.g_file_info_clear_status((*C.GFileInfo)(recv.native))

	return
}

// CopyInto is a wrapper around the C function g_file_info_copy_into.
func (recv *FileInfo) CopyInto(destInfo *FileInfo) {
	c_dest_info := (*C.GFileInfo)(C.NULL)
	if destInfo != nil {
		c_dest_info = (*C.GFileInfo)(destInfo.ToC())
	}

	C.g_file_info_copy_into((*C.GFileInfo)(recv.native), c_dest_info)

	return
}

// Dup is a wrapper around the C function g_file_info_dup.
func (recv *FileInfo) Dup() *FileInfo {
	retC := C.g_file_info_dup((*C.GFileInfo)(recv.native))
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAttributeAsString is a wrapper around the C function g_file_info_get_attribute_as_string.
func (recv *FileInfo) GetAttributeAsString(attribute string) string {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_as_string((*C.GFileInfo)(recv.native), c_attribute)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetAttributeBoolean is a wrapper around the C function g_file_info_get_attribute_boolean.
func (recv *FileInfo) GetAttributeBoolean(attribute string) bool {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_boolean((*C.GFileInfo)(recv.native), c_attribute)
	retGo := retC == C.TRUE

	return retGo
}

// GetAttributeByteString is a wrapper around the C function g_file_info_get_attribute_byte_string.
func (recv *FileInfo) GetAttributeByteString(attribute string) string {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_byte_string((*C.GFileInfo)(recv.native), c_attribute)
	retGo := C.GoString(retC)

	return retGo
}

// GetAttributeData is a wrapper around the C function g_file_info_get_attribute_data.
func (recv *FileInfo) GetAttributeData(attribute string) (bool, FileAttributeType, uintptr, FileAttributeStatus) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	var c_type C.GFileAttributeType

	var c_value_pp C.gpointer

	var c_status C.GFileAttributeStatus

	retC := C.g_file_info_get_attribute_data((*C.GFileInfo)(recv.native), c_attribute, &c_type, &c_value_pp, &c_status)
	retGo := retC == C.TRUE

	type_ := (FileAttributeType)(c_type)

	valuePp := (uintptr)(unsafe.Pointer(&c_value_pp))

	status := (FileAttributeStatus)(c_status)

	return retGo, type_, valuePp, status
}

// GetAttributeInt32 is a wrapper around the C function g_file_info_get_attribute_int32.
func (recv *FileInfo) GetAttributeInt32(attribute string) int32 {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_int32((*C.GFileInfo)(recv.native), c_attribute)
	retGo := (int32)(retC)

	return retGo
}

// GetAttributeInt64 is a wrapper around the C function g_file_info_get_attribute_int64.
func (recv *FileInfo) GetAttributeInt64(attribute string) int64 {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_int64((*C.GFileInfo)(recv.native), c_attribute)
	retGo := (int64)(retC)

	return retGo
}

// GetAttributeObject is a wrapper around the C function g_file_info_get_attribute_object.
func (recv *FileInfo) GetAttributeObject(attribute string) *gobject.Object {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_object((*C.GFileInfo)(recv.native), c_attribute)
	retGo := gobject.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAttributeStatus is a wrapper around the C function g_file_info_get_attribute_status.
func (recv *FileInfo) GetAttributeStatus(attribute string) FileAttributeStatus {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_status((*C.GFileInfo)(recv.native), c_attribute)
	retGo := (FileAttributeStatus)(retC)

	return retGo
}

// GetAttributeString is a wrapper around the C function g_file_info_get_attribute_string.
func (recv *FileInfo) GetAttributeString(attribute string) string {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_string((*C.GFileInfo)(recv.native), c_attribute)
	retGo := C.GoString(retC)

	return retGo
}

// GetAttributeStringv is a wrapper around the C function g_file_info_get_attribute_stringv.
func (recv *FileInfo) GetAttributeStringv(attribute string) []string {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_stringv((*C.GFileInfo)(recv.native), c_attribute)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// GetAttributeType is a wrapper around the C function g_file_info_get_attribute_type.
func (recv *FileInfo) GetAttributeType(attribute string) FileAttributeType {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_type((*C.GFileInfo)(recv.native), c_attribute)
	retGo := (FileAttributeType)(retC)

	return retGo
}

// GetAttributeUint32 is a wrapper around the C function g_file_info_get_attribute_uint32.
func (recv *FileInfo) GetAttributeUint32(attribute string) uint32 {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_uint32((*C.GFileInfo)(recv.native), c_attribute)
	retGo := (uint32)(retC)

	return retGo
}

// GetAttributeUint64 is a wrapper around the C function g_file_info_get_attribute_uint64.
func (recv *FileInfo) GetAttributeUint64(attribute string) uint64 {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_get_attribute_uint64((*C.GFileInfo)(recv.native), c_attribute)
	retGo := (uint64)(retC)

	return retGo
}

// GetContentType is a wrapper around the C function g_file_info_get_content_type.
func (recv *FileInfo) GetContentType() string {
	retC := C.g_file_info_get_content_type((*C.GFileInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDeletionDate is a wrapper around the C function g_file_info_get_deletion_date.
func (recv *FileInfo) GetDeletionDate() *glib.DateTime {
	retC := C.g_file_info_get_deletion_date((*C.GFileInfo)(recv.native))
	retGo := glib.DateTimeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDisplayName is a wrapper around the C function g_file_info_get_display_name.
func (recv *FileInfo) GetDisplayName() string {
	retC := C.g_file_info_get_display_name((*C.GFileInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetEditName is a wrapper around the C function g_file_info_get_edit_name.
func (recv *FileInfo) GetEditName() string {
	retC := C.g_file_info_get_edit_name((*C.GFileInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetEtag is a wrapper around the C function g_file_info_get_etag.
func (recv *FileInfo) GetEtag() string {
	retC := C.g_file_info_get_etag((*C.GFileInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetFileType is a wrapper around the C function g_file_info_get_file_type.
func (recv *FileInfo) GetFileType() FileType {
	retC := C.g_file_info_get_file_type((*C.GFileInfo)(recv.native))
	retGo := (FileType)(retC)

	return retGo
}

// GetIcon is a wrapper around the C function g_file_info_get_icon.
func (recv *FileInfo) GetIcon() *Icon {
	retC := C.g_file_info_get_icon((*C.GFileInfo)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIsBackup is a wrapper around the C function g_file_info_get_is_backup.
func (recv *FileInfo) GetIsBackup() bool {
	retC := C.g_file_info_get_is_backup((*C.GFileInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsHidden is a wrapper around the C function g_file_info_get_is_hidden.
func (recv *FileInfo) GetIsHidden() bool {
	retC := C.g_file_info_get_is_hidden((*C.GFileInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsSymlink is a wrapper around the C function g_file_info_get_is_symlink.
func (recv *FileInfo) GetIsSymlink() bool {
	retC := C.g_file_info_get_is_symlink((*C.GFileInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetModificationTime is a wrapper around the C function g_file_info_get_modification_time.
func (recv *FileInfo) GetModificationTime() *glib.TimeVal {
	var c_result C.GTimeVal

	C.g_file_info_get_modification_time((*C.GFileInfo)(recv.native), &c_result)

	result := glib.TimeValNewFromC(unsafe.Pointer(&c_result))

	return result
}

// GetName is a wrapper around the C function g_file_info_get_name.
func (recv *FileInfo) GetName() string {
	retC := C.g_file_info_get_name((*C.GFileInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetSize is a wrapper around the C function g_file_info_get_size.
func (recv *FileInfo) GetSize() int64 {
	retC := C.g_file_info_get_size((*C.GFileInfo)(recv.native))
	retGo := (int64)(retC)

	return retGo
}

// GetSortOrder is a wrapper around the C function g_file_info_get_sort_order.
func (recv *FileInfo) GetSortOrder() int32 {
	retC := C.g_file_info_get_sort_order((*C.GFileInfo)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetSymbolicIcon is a wrapper around the C function g_file_info_get_symbolic_icon.
func (recv *FileInfo) GetSymbolicIcon() *Icon {
	retC := C.g_file_info_get_symbolic_icon((*C.GFileInfo)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSymlinkTarget is a wrapper around the C function g_file_info_get_symlink_target.
func (recv *FileInfo) GetSymlinkTarget() string {
	retC := C.g_file_info_get_symlink_target((*C.GFileInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// HasAttribute is a wrapper around the C function g_file_info_has_attribute.
func (recv *FileInfo) HasAttribute(attribute string) bool {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_info_has_attribute((*C.GFileInfo)(recv.native), c_attribute)
	retGo := retC == C.TRUE

	return retGo
}

// HasNamespace is a wrapper around the C function g_file_info_has_namespace.
func (recv *FileInfo) HasNamespace(nameSpace string) bool {
	c_name_space := C.CString(nameSpace)
	defer C.free(unsafe.Pointer(c_name_space))

	retC := C.g_file_info_has_namespace((*C.GFileInfo)(recv.native), c_name_space)
	retGo := retC == C.TRUE

	return retGo
}

// ListAttributes is a wrapper around the C function g_file_info_list_attributes.
func (recv *FileInfo) ListAttributes(nameSpace string) []string {
	c_name_space := C.CString(nameSpace)
	defer C.free(unsafe.Pointer(c_name_space))

	retC := C.g_file_info_list_attributes((*C.GFileInfo)(recv.native), c_name_space)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// RemoveAttribute is a wrapper around the C function g_file_info_remove_attribute.
func (recv *FileInfo) RemoveAttribute(attribute string) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	C.g_file_info_remove_attribute((*C.GFileInfo)(recv.native), c_attribute)

	return
}

// SetAttribute is a wrapper around the C function g_file_info_set_attribute.
func (recv *FileInfo) SetAttribute(attribute string, type_ FileAttributeType, valueP uintptr) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_type := (C.GFileAttributeType)(type_)

	c_value_p := (C.gpointer)(valueP)

	C.g_file_info_set_attribute((*C.GFileInfo)(recv.native), c_attribute, c_type, c_value_p)

	return
}

// SetAttributeBoolean is a wrapper around the C function g_file_info_set_attribute_boolean.
func (recv *FileInfo) SetAttributeBoolean(attribute string, attrValue bool) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value :=
		boolToGboolean(attrValue)

	C.g_file_info_set_attribute_boolean((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetAttributeByteString is a wrapper around the C function g_file_info_set_attribute_byte_string.
func (recv *FileInfo) SetAttributeByteString(attribute string, attrValue string) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value := C.CString(attrValue)
	defer C.free(unsafe.Pointer(c_attr_value))

	C.g_file_info_set_attribute_byte_string((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetAttributeInt32 is a wrapper around the C function g_file_info_set_attribute_int32.
func (recv *FileInfo) SetAttributeInt32(attribute string, attrValue int32) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value := (C.gint32)(attrValue)

	C.g_file_info_set_attribute_int32((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetAttributeInt64 is a wrapper around the C function g_file_info_set_attribute_int64.
func (recv *FileInfo) SetAttributeInt64(attribute string, attrValue int64) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value := (C.gint64)(attrValue)

	C.g_file_info_set_attribute_int64((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetAttributeMask is a wrapper around the C function g_file_info_set_attribute_mask.
func (recv *FileInfo) SetAttributeMask(mask *FileAttributeMatcher) {
	c_mask := (*C.GFileAttributeMatcher)(C.NULL)
	if mask != nil {
		c_mask = (*C.GFileAttributeMatcher)(mask.ToC())
	}

	C.g_file_info_set_attribute_mask((*C.GFileInfo)(recv.native), c_mask)

	return
}

// SetAttributeObject is a wrapper around the C function g_file_info_set_attribute_object.
func (recv *FileInfo) SetAttributeObject(attribute string, attrValue *gobject.Object) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value := (*C.GObject)(C.NULL)
	if attrValue != nil {
		c_attr_value = (*C.GObject)(attrValue.ToC())
	}

	C.g_file_info_set_attribute_object((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetAttributeStatus is a wrapper around the C function g_file_info_set_attribute_status.
func (recv *FileInfo) SetAttributeStatus(attribute string, status FileAttributeStatus) bool {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_status := (C.GFileAttributeStatus)(status)

	retC := C.g_file_info_set_attribute_status((*C.GFileInfo)(recv.native), c_attribute, c_status)
	retGo := retC == C.TRUE

	return retGo
}

// SetAttributeString is a wrapper around the C function g_file_info_set_attribute_string.
func (recv *FileInfo) SetAttributeString(attribute string, attrValue string) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value := C.CString(attrValue)
	defer C.free(unsafe.Pointer(c_attr_value))

	C.g_file_info_set_attribute_string((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetAttributeStringv is a wrapper around the C function g_file_info_set_attribute_stringv.
func (recv *FileInfo) SetAttributeStringv(attribute string, attrValue []string) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value_array := make([]*C.gchar, len(attrValue)+1, len(attrValue)+1)
	for i, item := range attrValue {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_attr_value_array[i] = c
	}
	c_attr_value_array[len(attrValue)] = nil
	c_attr_value_arrayPtr := &c_attr_value_array[0]
	c_attr_value := (**C.char)(unsafe.Pointer(c_attr_value_arrayPtr))

	C.g_file_info_set_attribute_stringv((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetAttributeUint32 is a wrapper around the C function g_file_info_set_attribute_uint32.
func (recv *FileInfo) SetAttributeUint32(attribute string, attrValue uint32) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value := (C.guint32)(attrValue)

	C.g_file_info_set_attribute_uint32((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetAttributeUint64 is a wrapper around the C function g_file_info_set_attribute_uint64.
func (recv *FileInfo) SetAttributeUint64(attribute string, attrValue uint64) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_attr_value := (C.guint64)(attrValue)

	C.g_file_info_set_attribute_uint64((*C.GFileInfo)(recv.native), c_attribute, c_attr_value)

	return
}

// SetContentType is a wrapper around the C function g_file_info_set_content_type.
func (recv *FileInfo) SetContentType(contentType string) {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	C.g_file_info_set_content_type((*C.GFileInfo)(recv.native), c_content_type)

	return
}

// SetDisplayName is a wrapper around the C function g_file_info_set_display_name.
func (recv *FileInfo) SetDisplayName(displayName string) {
	c_display_name := C.CString(displayName)
	defer C.free(unsafe.Pointer(c_display_name))

	C.g_file_info_set_display_name((*C.GFileInfo)(recv.native), c_display_name)

	return
}

// SetEditName is a wrapper around the C function g_file_info_set_edit_name.
func (recv *FileInfo) SetEditName(editName string) {
	c_edit_name := C.CString(editName)
	defer C.free(unsafe.Pointer(c_edit_name))

	C.g_file_info_set_edit_name((*C.GFileInfo)(recv.native), c_edit_name)

	return
}

// SetFileType is a wrapper around the C function g_file_info_set_file_type.
func (recv *FileInfo) SetFileType(type_ FileType) {
	c_type := (C.GFileType)(type_)

	C.g_file_info_set_file_type((*C.GFileInfo)(recv.native), c_type)

	return
}

// SetIcon is a wrapper around the C function g_file_info_set_icon.
func (recv *FileInfo) SetIcon(icon *Icon) {
	c_icon := (*C.GIcon)(icon.ToC())

	C.g_file_info_set_icon((*C.GFileInfo)(recv.native), c_icon)

	return
}

// SetIsHidden is a wrapper around the C function g_file_info_set_is_hidden.
func (recv *FileInfo) SetIsHidden(isHidden bool) {
	c_is_hidden :=
		boolToGboolean(isHidden)

	C.g_file_info_set_is_hidden((*C.GFileInfo)(recv.native), c_is_hidden)

	return
}

// SetIsSymlink is a wrapper around the C function g_file_info_set_is_symlink.
func (recv *FileInfo) SetIsSymlink(isSymlink bool) {
	c_is_symlink :=
		boolToGboolean(isSymlink)

	C.g_file_info_set_is_symlink((*C.GFileInfo)(recv.native), c_is_symlink)

	return
}

// SetModificationTime is a wrapper around the C function g_file_info_set_modification_time.
func (recv *FileInfo) SetModificationTime(mtime *glib.TimeVal) {
	c_mtime := (*C.GTimeVal)(C.NULL)
	if mtime != nil {
		c_mtime = (*C.GTimeVal)(mtime.ToC())
	}

	C.g_file_info_set_modification_time((*C.GFileInfo)(recv.native), c_mtime)

	return
}

// SetName is a wrapper around the C function g_file_info_set_name.
func (recv *FileInfo) SetName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.g_file_info_set_name((*C.GFileInfo)(recv.native), c_name)

	return
}

// SetSize is a wrapper around the C function g_file_info_set_size.
func (recv *FileInfo) SetSize(size int64) {
	c_size := (C.goffset)(size)

	C.g_file_info_set_size((*C.GFileInfo)(recv.native), c_size)

	return
}

// SetSortOrder is a wrapper around the C function g_file_info_set_sort_order.
func (recv *FileInfo) SetSortOrder(sortOrder int32) {
	c_sort_order := (C.gint32)(sortOrder)

	C.g_file_info_set_sort_order((*C.GFileInfo)(recv.native), c_sort_order)

	return
}

// SetSymbolicIcon is a wrapper around the C function g_file_info_set_symbolic_icon.
func (recv *FileInfo) SetSymbolicIcon(icon *Icon) {
	c_icon := (*C.GIcon)(icon.ToC())

	C.g_file_info_set_symbolic_icon((*C.GFileInfo)(recv.native), c_icon)

	return
}

// SetSymlinkTarget is a wrapper around the C function g_file_info_set_symlink_target.
func (recv *FileInfo) SetSymlinkTarget(symlinkTarget string) {
	c_symlink_target := C.CString(symlinkTarget)
	defer C.free(unsafe.Pointer(c_symlink_target))

	C.g_file_info_set_symlink_target((*C.GFileInfo)(recv.native), c_symlink_target)

	return
}

// UnsetAttributeMask is a wrapper around the C function g_file_info_unset_attribute_mask.
func (recv *FileInfo) UnsetAttributeMask() {
	C.g_file_info_unset_attribute_mask((*C.GFileInfo)(recv.native))

	return
}

// FileInputStream is a wrapper around the C record GFileInputStream.
type FileInputStream struct {
	native *C.GFileInputStream
	// parent_instance : record
	// Private : priv
}

func FileInputStreamNewFromC(u unsafe.Pointer) *FileInputStream {
	c := (*C.GFileInputStream)(u)
	if c == nil {
		return nil
	}

	g := &FileInputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileInputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileInputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileInputStream with another FileInputStream, and returns true if they represent the same GObject.
func (recv *FileInputStream) Equals(other *FileInputStream) bool {
	return other.ToC() == recv.ToC()
}

// InputStream upcasts to *InputStream
func (recv *FileInputStream) InputStream() *InputStream {
	return InputStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FileInputStream) Object() *gobject.Object {
	return recv.InputStream().Object()
}

// CastToWidget down casts any arbitrary Object to FileInputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileInputStream.
func CastToFileInputStream(object *gobject.Object) *FileInputStream {
	return FileInputStreamNewFromC(object.ToC())
}

// QueryInfo is a wrapper around the C function g_file_input_stream_query_info.
func (recv *FileInputStream) QueryInfo(attributes string, cancellable *Cancellable) (*FileInfo, error) {
	c_attributes := C.CString(attributes)
	defer C.free(unsafe.Pointer(c_attributes))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_input_stream_query_info((*C.GFileInputStream)(recv.native), c_attributes, c_cancellable, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_input_stream_query_info_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// QueryInfoFinish is a wrapper around the C function g_file_input_stream_query_info_finish.
func (recv *FileInputStream) QueryInfoFinish(result *AsyncResult) (*FileInfo, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_input_stream_query_info_finish((*C.GFileInputStream)(recv.native), c_result, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Seekable returns the Seekable interface implemented by FileInputStream
func (recv *FileInputStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// FileMonitor is a wrapper around the C record GFileMonitor.
type FileMonitor struct {
	native *C.GFileMonitor
	// parent_instance : record
	// Private : priv
}

func FileMonitorNewFromC(u unsafe.Pointer) *FileMonitor {
	c := (*C.GFileMonitor)(u)
	if c == nil {
		return nil
	}

	g := &FileMonitor{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileMonitor) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileMonitor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileMonitor with another FileMonitor, and returns true if they represent the same GObject.
func (recv *FileMonitor) Equals(other *FileMonitor) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *FileMonitor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to FileMonitor.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileMonitor.
func CastToFileMonitor(object *gobject.Object) *FileMonitor {
	return FileMonitorNewFromC(object.ToC())
}

type signalFileMonitorChangedDetail struct {
	callback  FileMonitorSignalChangedCallback
	handlerID C.gulong
}

var signalFileMonitorChangedId int
var signalFileMonitorChangedMap = make(map[int]signalFileMonitorChangedDetail)
var signalFileMonitorChangedLock sync.RWMutex

// FileMonitorSignalChangedCallback is a callback function for a 'changed' signal emitted from a FileMonitor.
type FileMonitorSignalChangedCallback func(file *File, otherFile *File, eventType FileMonitorEvent)

/*
ConnectChanged connects the callback to the 'changed' signal for the FileMonitor.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *FileMonitor) ConnectChanged(callback FileMonitorSignalChangedCallback) int {
	signalFileMonitorChangedLock.Lock()
	defer signalFileMonitorChangedLock.Unlock()

	signalFileMonitorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileMonitor_signal_connect_changed(instance, C.gpointer(uintptr(signalFileMonitorChangedId)))

	detail := signalFileMonitorChangedDetail{callback, handlerID}
	signalFileMonitorChangedMap[signalFileMonitorChangedId] = detail

	return signalFileMonitorChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the FileMonitor.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *FileMonitor) DisconnectChanged(connectionID int) {
	signalFileMonitorChangedLock.Lock()
	defer signalFileMonitorChangedLock.Unlock()

	detail, exists := signalFileMonitorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileMonitorChangedMap, connectionID)
}

//export filemonitor_changedHandler
func filemonitor_changedHandler(_ *C.GObject, c_file *C.GFile, c_other_file *C.GFile, c_event_type C.GFileMonitorEvent, data C.gpointer) {
	signalFileMonitorChangedLock.RLock()
	defer signalFileMonitorChangedLock.RUnlock()

	file := FileNewFromC(unsafe.Pointer(c_file))

	otherFile := FileNewFromC(unsafe.Pointer(c_other_file))

	eventType := FileMonitorEvent(c_event_type)

	index := int(uintptr(data))
	callback := signalFileMonitorChangedMap[index].callback
	callback(file, otherFile, eventType)
}

// Cancel is a wrapper around the C function g_file_monitor_cancel.
func (recv *FileMonitor) Cancel() bool {
	retC := C.g_file_monitor_cancel((*C.GFileMonitor)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// EmitEvent is a wrapper around the C function g_file_monitor_emit_event.
func (recv *FileMonitor) EmitEvent(child *File, otherFile *File, eventType FileMonitorEvent) {
	c_child := (*C.GFile)(child.ToC())

	c_other_file := (*C.GFile)(otherFile.ToC())

	c_event_type := (C.GFileMonitorEvent)(eventType)

	C.g_file_monitor_emit_event((*C.GFileMonitor)(recv.native), c_child, c_other_file, c_event_type)

	return
}

// IsCancelled is a wrapper around the C function g_file_monitor_is_cancelled.
func (recv *FileMonitor) IsCancelled() bool {
	retC := C.g_file_monitor_is_cancelled((*C.GFileMonitor)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetRateLimit is a wrapper around the C function g_file_monitor_set_rate_limit.
func (recv *FileMonitor) SetRateLimit(limitMsecs int32) {
	c_limit_msecs := (C.gint)(limitMsecs)

	C.g_file_monitor_set_rate_limit((*C.GFileMonitor)(recv.native), c_limit_msecs)

	return
}

// FileOutputStream is a wrapper around the C record GFileOutputStream.
type FileOutputStream struct {
	native *C.GFileOutputStream
	// parent_instance : record
	// Private : priv
}

func FileOutputStreamNewFromC(u unsafe.Pointer) *FileOutputStream {
	c := (*C.GFileOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &FileOutputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileOutputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileOutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileOutputStream with another FileOutputStream, and returns true if they represent the same GObject.
func (recv *FileOutputStream) Equals(other *FileOutputStream) bool {
	return other.ToC() == recv.ToC()
}

// OutputStream upcasts to *OutputStream
func (recv *FileOutputStream) OutputStream() *OutputStream {
	return OutputStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FileOutputStream) Object() *gobject.Object {
	return recv.OutputStream().Object()
}

// CastToWidget down casts any arbitrary Object to FileOutputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileOutputStream.
func CastToFileOutputStream(object *gobject.Object) *FileOutputStream {
	return FileOutputStreamNewFromC(object.ToC())
}

// GetEtag is a wrapper around the C function g_file_output_stream_get_etag.
func (recv *FileOutputStream) GetEtag() string {
	retC := C.g_file_output_stream_get_etag((*C.GFileOutputStream)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// QueryInfo is a wrapper around the C function g_file_output_stream_query_info.
func (recv *FileOutputStream) QueryInfo(attributes string, cancellable *Cancellable) (*FileInfo, error) {
	c_attributes := C.CString(attributes)
	defer C.free(unsafe.Pointer(c_attributes))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_output_stream_query_info((*C.GFileOutputStream)(recv.native), c_attributes, c_cancellable, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_output_stream_query_info_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// QueryInfoFinish is a wrapper around the C function g_file_output_stream_query_info_finish.
func (recv *FileOutputStream) QueryInfoFinish(result *AsyncResult) (*FileInfo, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_output_stream_query_info_finish((*C.GFileOutputStream)(recv.native), c_result, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Seekable returns the Seekable interface implemented by FileOutputStream
func (recv *FileOutputStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// FilenameCompleter is a wrapper around the C record GFilenameCompleter.
type FilenameCompleter struct {
	native *C.GFilenameCompleter
}

func FilenameCompleterNewFromC(u unsafe.Pointer) *FilenameCompleter {
	c := (*C.GFilenameCompleter)(u)
	if c == nil {
		return nil
	}

	g := &FilenameCompleter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FilenameCompleter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FilenameCompleter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FilenameCompleter with another FilenameCompleter, and returns true if they represent the same GObject.
func (recv *FilenameCompleter) Equals(other *FilenameCompleter) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *FilenameCompleter) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to FilenameCompleter.
// Exercise care, as this is a potentially dangerous function if the Object is not a FilenameCompleter.
func CastToFilenameCompleter(object *gobject.Object) *FilenameCompleter {
	return FilenameCompleterNewFromC(object.ToC())
}

type signalFilenameCompleterGotCompletionDataDetail struct {
	callback  FilenameCompleterSignalGotCompletionDataCallback
	handlerID C.gulong
}

var signalFilenameCompleterGotCompletionDataId int
var signalFilenameCompleterGotCompletionDataMap = make(map[int]signalFilenameCompleterGotCompletionDataDetail)
var signalFilenameCompleterGotCompletionDataLock sync.RWMutex

// FilenameCompleterSignalGotCompletionDataCallback is a callback function for a 'got-completion-data' signal emitted from a FilenameCompleter.
type FilenameCompleterSignalGotCompletionDataCallback func()

/*
ConnectGotCompletionData connects the callback to the 'got-completion-data' signal for the FilenameCompleter.

The returned value represents the connection, and may be passed to DisconnectGotCompletionData to remove it.
*/
func (recv *FilenameCompleter) ConnectGotCompletionData(callback FilenameCompleterSignalGotCompletionDataCallback) int {
	signalFilenameCompleterGotCompletionDataLock.Lock()
	defer signalFilenameCompleterGotCompletionDataLock.Unlock()

	signalFilenameCompleterGotCompletionDataId++
	instance := C.gpointer(recv.native)
	handlerID := C.FilenameCompleter_signal_connect_got_completion_data(instance, C.gpointer(uintptr(signalFilenameCompleterGotCompletionDataId)))

	detail := signalFilenameCompleterGotCompletionDataDetail{callback, handlerID}
	signalFilenameCompleterGotCompletionDataMap[signalFilenameCompleterGotCompletionDataId] = detail

	return signalFilenameCompleterGotCompletionDataId
}

/*
DisconnectGotCompletionData disconnects a callback from the 'got-completion-data' signal for the FilenameCompleter.

The connectionID should be a value returned from a call to ConnectGotCompletionData.
*/
func (recv *FilenameCompleter) DisconnectGotCompletionData(connectionID int) {
	signalFilenameCompleterGotCompletionDataLock.Lock()
	defer signalFilenameCompleterGotCompletionDataLock.Unlock()

	detail, exists := signalFilenameCompleterGotCompletionDataMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFilenameCompleterGotCompletionDataMap, connectionID)
}

//export filenamecompleter_gotCompletionDataHandler
func filenamecompleter_gotCompletionDataHandler(_ *C.GObject, data C.gpointer) {
	signalFilenameCompleterGotCompletionDataLock.RLock()
	defer signalFilenameCompleterGotCompletionDataLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFilenameCompleterGotCompletionDataMap[index].callback
	callback()
}

// FilenameCompleterNew is a wrapper around the C function g_filename_completer_new.
func FilenameCompleterNew() *FilenameCompleter {
	retC := C.g_filename_completer_new()
	retGo := FilenameCompleterNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetCompletionSuffix is a wrapper around the C function g_filename_completer_get_completion_suffix.
func (recv *FilenameCompleter) GetCompletionSuffix(initialText string) string {
	c_initial_text := C.CString(initialText)
	defer C.free(unsafe.Pointer(c_initial_text))

	retC := C.g_filename_completer_get_completion_suffix((*C.GFilenameCompleter)(recv.native), c_initial_text)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetCompletions is a wrapper around the C function g_filename_completer_get_completions.
func (recv *FilenameCompleter) GetCompletions(initialText string) []string {
	c_initial_text := C.CString(initialText)
	defer C.free(unsafe.Pointer(c_initial_text))

	retC := C.g_filename_completer_get_completions((*C.GFilenameCompleter)(recv.native), c_initial_text)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// SetDirsOnly is a wrapper around the C function g_filename_completer_set_dirs_only.
func (recv *FilenameCompleter) SetDirsOnly(dirsOnly bool) {
	c_dirs_only :=
		boolToGboolean(dirsOnly)

	C.g_filename_completer_set_dirs_only((*C.GFilenameCompleter)(recv.native), c_dirs_only)

	return
}

// FilterInputStream is a wrapper around the C record GFilterInputStream.
type FilterInputStream struct {
	native *C.GFilterInputStream
	// parent_instance : record
	// base_stream : record
}

func FilterInputStreamNewFromC(u unsafe.Pointer) *FilterInputStream {
	c := (*C.GFilterInputStream)(u)
	if c == nil {
		return nil
	}

	g := &FilterInputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FilterInputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FilterInputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FilterInputStream with another FilterInputStream, and returns true if they represent the same GObject.
func (recv *FilterInputStream) Equals(other *FilterInputStream) bool {
	return other.ToC() == recv.ToC()
}

// InputStream upcasts to *InputStream
func (recv *FilterInputStream) InputStream() *InputStream {
	return InputStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FilterInputStream) Object() *gobject.Object {
	return recv.InputStream().Object()
}

// CastToWidget down casts any arbitrary Object to FilterInputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a FilterInputStream.
func CastToFilterInputStream(object *gobject.Object) *FilterInputStream {
	return FilterInputStreamNewFromC(object.ToC())
}

// GetBaseStream is a wrapper around the C function g_filter_input_stream_get_base_stream.
func (recv *FilterInputStream) GetBaseStream() *InputStream {
	retC := C.g_filter_input_stream_get_base_stream((*C.GFilterInputStream)(recv.native))
	retGo := InputStreamNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCloseBaseStream is a wrapper around the C function g_filter_input_stream_get_close_base_stream.
func (recv *FilterInputStream) GetCloseBaseStream() bool {
	retC := C.g_filter_input_stream_get_close_base_stream((*C.GFilterInputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetCloseBaseStream is a wrapper around the C function g_filter_input_stream_set_close_base_stream.
func (recv *FilterInputStream) SetCloseBaseStream(closeBase bool) {
	c_close_base :=
		boolToGboolean(closeBase)

	C.g_filter_input_stream_set_close_base_stream((*C.GFilterInputStream)(recv.native), c_close_base)

	return
}

// FilterOutputStream is a wrapper around the C record GFilterOutputStream.
type FilterOutputStream struct {
	native *C.GFilterOutputStream
	// parent_instance : record
	// base_stream : record
}

func FilterOutputStreamNewFromC(u unsafe.Pointer) *FilterOutputStream {
	c := (*C.GFilterOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &FilterOutputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FilterOutputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FilterOutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FilterOutputStream with another FilterOutputStream, and returns true if they represent the same GObject.
func (recv *FilterOutputStream) Equals(other *FilterOutputStream) bool {
	return other.ToC() == recv.ToC()
}

// OutputStream upcasts to *OutputStream
func (recv *FilterOutputStream) OutputStream() *OutputStream {
	return OutputStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FilterOutputStream) Object() *gobject.Object {
	return recv.OutputStream().Object()
}

// CastToWidget down casts any arbitrary Object to FilterOutputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a FilterOutputStream.
func CastToFilterOutputStream(object *gobject.Object) *FilterOutputStream {
	return FilterOutputStreamNewFromC(object.ToC())
}

// GetBaseStream is a wrapper around the C function g_filter_output_stream_get_base_stream.
func (recv *FilterOutputStream) GetBaseStream() *OutputStream {
	retC := C.g_filter_output_stream_get_base_stream((*C.GFilterOutputStream)(recv.native))
	retGo := OutputStreamNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCloseBaseStream is a wrapper around the C function g_filter_output_stream_get_close_base_stream.
func (recv *FilterOutputStream) GetCloseBaseStream() bool {
	retC := C.g_filter_output_stream_get_close_base_stream((*C.GFilterOutputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetCloseBaseStream is a wrapper around the C function g_filter_output_stream_set_close_base_stream.
func (recv *FilterOutputStream) SetCloseBaseStream(closeBase bool) {
	c_close_base :=
		boolToGboolean(closeBase)

	C.g_filter_output_stream_set_close_base_stream((*C.GFilterOutputStream)(recv.native), c_close_base)

	return
}

// IOModule is a wrapper around the C record GIOModule.
type IOModule struct {
	native *C.GIOModule
}

func IOModuleNewFromC(u unsafe.Pointer) *IOModule {
	c := (*C.GIOModule)(u)
	if c == nil {
		return nil
	}

	g := &IOModule{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IOModule) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IOModule) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOModule with another IOModule, and returns true if they represent the same GObject.
func (recv *IOModule) Equals(other *IOModule) bool {
	return other.ToC() == recv.ToC()
}

// CastToWidget down casts any arbitrary Object to IOModule.
// Exercise care, as this is a potentially dangerous function if the Object is not a IOModule.
func CastToIOModule(object *gobject.Object) *IOModule {
	return IOModuleNewFromC(object.ToC())
}

// IOModuleNew is a wrapper around the C function g_io_module_new.
func IOModuleNew(filename string) *IOModule {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.g_io_module_new(c_filename)
	retGo := IOModuleNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Blacklisted : g_io_module_query

// Blacklisted : g_io_module_load

// Blacklisted : g_io_module_unload

// TypePlugin returns the TypePlugin interface implemented by IOModule
func (recv *IOModule) TypePlugin() *gobject.TypePlugin {
	return gobject.TypePluginNewFromC(recv.ToC())
}

// IOStream is a wrapper around the C record GIOStream.
type IOStream struct {
	native *C.GIOStream
	// parent_instance : record
	// Private : priv
}

func IOStreamNewFromC(u unsafe.Pointer) *IOStream {
	c := (*C.GIOStream)(u)
	if c == nil {
		return nil
	}

	g := &IOStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IOStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IOStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOStream with another IOStream, and returns true if they represent the same GObject.
func (recv *IOStream) Equals(other *IOStream) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IOStream) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IOStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a IOStream.
func CastToIOStream(object *gobject.Object) *IOStream {
	return IOStreamNewFromC(object.ToC())
}

// IOStreamSpliceFinish is a wrapper around the C function g_io_stream_splice_finish.
func IOStreamSpliceFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_io_stream_splice_finish(c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ClearPending is a wrapper around the C function g_io_stream_clear_pending.
func (recv *IOStream) ClearPending() {
	C.g_io_stream_clear_pending((*C.GIOStream)(recv.native))

	return
}

// Close is a wrapper around the C function g_io_stream_close.
func (recv *IOStream) Close(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_io_stream_close((*C.GIOStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_io_stream_close_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CloseFinish is a wrapper around the C function g_io_stream_close_finish.
func (recv *IOStream) CloseFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_io_stream_close_finish((*C.GIOStream)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetInputStream is a wrapper around the C function g_io_stream_get_input_stream.
func (recv *IOStream) GetInputStream() *InputStream {
	retC := C.g_io_stream_get_input_stream((*C.GIOStream)(recv.native))
	retGo := InputStreamNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetOutputStream is a wrapper around the C function g_io_stream_get_output_stream.
func (recv *IOStream) GetOutputStream() *OutputStream {
	retC := C.g_io_stream_get_output_stream((*C.GIOStream)(recv.native))
	retGo := OutputStreamNewFromC(unsafe.Pointer(retC))

	return retGo
}

// HasPending is a wrapper around the C function g_io_stream_has_pending.
func (recv *IOStream) HasPending() bool {
	retC := C.g_io_stream_has_pending((*C.GIOStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsClosed is a wrapper around the C function g_io_stream_is_closed.
func (recv *IOStream) IsClosed() bool {
	retC := C.g_io_stream_is_closed((*C.GIOStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetPending is a wrapper around the C function g_io_stream_set_pending.
func (recv *IOStream) SetPending() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_io_stream_set_pending((*C.GIOStream)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_io_stream_splice_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// InetAddress is a wrapper around the C record GInetAddress.
type InetAddress struct {
	native *C.GInetAddress
	// parent_instance : record
	// Private : priv
}

func InetAddressNewFromC(u unsafe.Pointer) *InetAddress {
	c := (*C.GInetAddress)(u)
	if c == nil {
		return nil
	}

	g := &InetAddress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *InetAddress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *InetAddress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetAddress with another InetAddress, and returns true if they represent the same GObject.
func (recv *InetAddress) Equals(other *InetAddress) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *InetAddress) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to InetAddress.
// Exercise care, as this is a potentially dangerous function if the Object is not a InetAddress.
func CastToInetAddress(object *gobject.Object) *InetAddress {
	return InetAddressNewFromC(object.ToC())
}

// InetAddressNewAny is a wrapper around the C function g_inet_address_new_any.
func InetAddressNewAny(family SocketFamily) *InetAddress {
	c_family := (C.GSocketFamily)(family)

	retC := C.g_inet_address_new_any(c_family)
	retGo := InetAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// InetAddressNewFromBytes is a wrapper around the C function g_inet_address_new_from_bytes.
func InetAddressNewFromBytes(bytes []uint8, family SocketFamily) *InetAddress {
	c_bytes_array := make([]C.guint8, len(bytes)+1, len(bytes)+1)
	for i, item := range bytes {
		c := (C.guint8)(item)
		c_bytes_array[i] = c
	}
	c_bytes_array[len(bytes)] = 0
	c_bytes_arrayPtr := &c_bytes_array[0]
	c_bytes := (*C.guint8)(unsafe.Pointer(c_bytes_arrayPtr))

	c_family := (C.GSocketFamily)(family)

	retC := C.g_inet_address_new_from_bytes(c_bytes, c_family)
	retGo := InetAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// InetAddressNewFromString is a wrapper around the C function g_inet_address_new_from_string.
func InetAddressNewFromString(string_ string) *InetAddress {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.g_inet_address_new_from_string(c_string)
	retGo := InetAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// InetAddressNewLoopback is a wrapper around the C function g_inet_address_new_loopback.
func InetAddressNewLoopback(family SocketFamily) *InetAddress {
	c_family := (C.GSocketFamily)(family)

	retC := C.g_inet_address_new_loopback(c_family)
	retGo := InetAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Equal is a wrapper around the C function g_inet_address_equal.
func (recv *InetAddress) Equal(otherAddress *InetAddress) bool {
	c_other_address := (*C.GInetAddress)(C.NULL)
	if otherAddress != nil {
		c_other_address = (*C.GInetAddress)(otherAddress.ToC())
	}

	retC := C.g_inet_address_equal((*C.GInetAddress)(recv.native), c_other_address)
	retGo := retC == C.TRUE

	return retGo
}

// GetFamily is a wrapper around the C function g_inet_address_get_family.
func (recv *InetAddress) GetFamily() SocketFamily {
	retC := C.g_inet_address_get_family((*C.GInetAddress)(recv.native))
	retGo := (SocketFamily)(retC)

	return retGo
}

// GetIsAny is a wrapper around the C function g_inet_address_get_is_any.
func (recv *InetAddress) GetIsAny() bool {
	retC := C.g_inet_address_get_is_any((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsLinkLocal is a wrapper around the C function g_inet_address_get_is_link_local.
func (recv *InetAddress) GetIsLinkLocal() bool {
	retC := C.g_inet_address_get_is_link_local((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsLoopback is a wrapper around the C function g_inet_address_get_is_loopback.
func (recv *InetAddress) GetIsLoopback() bool {
	retC := C.g_inet_address_get_is_loopback((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsMcGlobal is a wrapper around the C function g_inet_address_get_is_mc_global.
func (recv *InetAddress) GetIsMcGlobal() bool {
	retC := C.g_inet_address_get_is_mc_global((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsMcLinkLocal is a wrapper around the C function g_inet_address_get_is_mc_link_local.
func (recv *InetAddress) GetIsMcLinkLocal() bool {
	retC := C.g_inet_address_get_is_mc_link_local((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsMcNodeLocal is a wrapper around the C function g_inet_address_get_is_mc_node_local.
func (recv *InetAddress) GetIsMcNodeLocal() bool {
	retC := C.g_inet_address_get_is_mc_node_local((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsMcOrgLocal is a wrapper around the C function g_inet_address_get_is_mc_org_local.
func (recv *InetAddress) GetIsMcOrgLocal() bool {
	retC := C.g_inet_address_get_is_mc_org_local((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsMcSiteLocal is a wrapper around the C function g_inet_address_get_is_mc_site_local.
func (recv *InetAddress) GetIsMcSiteLocal() bool {
	retC := C.g_inet_address_get_is_mc_site_local((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsMulticast is a wrapper around the C function g_inet_address_get_is_multicast.
func (recv *InetAddress) GetIsMulticast() bool {
	retC := C.g_inet_address_get_is_multicast((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIsSiteLocal is a wrapper around the C function g_inet_address_get_is_site_local.
func (recv *InetAddress) GetIsSiteLocal() bool {
	retC := C.g_inet_address_get_is_site_local((*C.GInetAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetNativeSize is a wrapper around the C function g_inet_address_get_native_size.
func (recv *InetAddress) GetNativeSize() uint64 {
	retC := C.g_inet_address_get_native_size((*C.GInetAddress)(recv.native))
	retGo := (uint64)(retC)

	return retGo
}

// Blacklisted : g_inet_address_to_bytes

// ToString is a wrapper around the C function g_inet_address_to_string.
func (recv *InetAddress) ToString() string {
	retC := C.g_inet_address_to_string((*C.GInetAddress)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// InetAddressMask is a wrapper around the C record GInetAddressMask.
type InetAddressMask struct {
	native *C.GInetAddressMask
	// parent_instance : record
	// Private : priv
}

func InetAddressMaskNewFromC(u unsafe.Pointer) *InetAddressMask {
	c := (*C.GInetAddressMask)(u)
	if c == nil {
		return nil
	}

	g := &InetAddressMask{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *InetAddressMask) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *InetAddressMask) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetAddressMask with another InetAddressMask, and returns true if they represent the same GObject.
func (recv *InetAddressMask) Equals(other *InetAddressMask) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *InetAddressMask) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to InetAddressMask.
// Exercise care, as this is a potentially dangerous function if the Object is not a InetAddressMask.
func CastToInetAddressMask(object *gobject.Object) *InetAddressMask {
	return InetAddressMaskNewFromC(object.ToC())
}

// InetAddressMaskNew is a wrapper around the C function g_inet_address_mask_new.
func InetAddressMaskNew(addr *InetAddress, length uint32) (*InetAddressMask, error) {
	c_addr := (*C.GInetAddress)(C.NULL)
	if addr != nil {
		c_addr = (*C.GInetAddress)(addr.ToC())
	}

	c_length := (C.guint)(length)

	var cThrowableError *C.GError

	retC := C.g_inet_address_mask_new(c_addr, c_length, &cThrowableError)
	retGo := InetAddressMaskNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// InetAddressMaskNewFromString is a wrapper around the C function g_inet_address_mask_new_from_string.
func InetAddressMaskNewFromString(maskString string) (*InetAddressMask, error) {
	c_mask_string := C.CString(maskString)
	defer C.free(unsafe.Pointer(c_mask_string))

	var cThrowableError *C.GError

	retC := C.g_inet_address_mask_new_from_string(c_mask_string, &cThrowableError)
	retGo := InetAddressMaskNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Equal is a wrapper around the C function g_inet_address_mask_equal.
func (recv *InetAddressMask) Equal(mask2 *InetAddressMask) bool {
	c_mask2 := (*C.GInetAddressMask)(C.NULL)
	if mask2 != nil {
		c_mask2 = (*C.GInetAddressMask)(mask2.ToC())
	}

	retC := C.g_inet_address_mask_equal((*C.GInetAddressMask)(recv.native), c_mask2)
	retGo := retC == C.TRUE

	return retGo
}

// GetAddress is a wrapper around the C function g_inet_address_mask_get_address.
func (recv *InetAddressMask) GetAddress() *InetAddress {
	retC := C.g_inet_address_mask_get_address((*C.GInetAddressMask)(recv.native))
	retGo := InetAddressNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFamily is a wrapper around the C function g_inet_address_mask_get_family.
func (recv *InetAddressMask) GetFamily() SocketFamily {
	retC := C.g_inet_address_mask_get_family((*C.GInetAddressMask)(recv.native))
	retGo := (SocketFamily)(retC)

	return retGo
}

// GetLength is a wrapper around the C function g_inet_address_mask_get_length.
func (recv *InetAddressMask) GetLength() uint32 {
	retC := C.g_inet_address_mask_get_length((*C.GInetAddressMask)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Matches is a wrapper around the C function g_inet_address_mask_matches.
func (recv *InetAddressMask) Matches(address *InetAddress) bool {
	c_address := (*C.GInetAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GInetAddress)(address.ToC())
	}

	retC := C.g_inet_address_mask_matches((*C.GInetAddressMask)(recv.native), c_address)
	retGo := retC == C.TRUE

	return retGo
}

// ToString is a wrapper around the C function g_inet_address_mask_to_string.
func (recv *InetAddressMask) ToString() string {
	retC := C.g_inet_address_mask_to_string((*C.GInetAddressMask)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Initable returns the Initable interface implemented by InetAddressMask
func (recv *InetAddressMask) Initable() *Initable {
	return InitableNewFromC(recv.ToC())
}

// InetSocketAddress is a wrapper around the C record GInetSocketAddress.
type InetSocketAddress struct {
	native *C.GInetSocketAddress
	// parent_instance : record
	// Private : priv
}

func InetSocketAddressNewFromC(u unsafe.Pointer) *InetSocketAddress {
	c := (*C.GInetSocketAddress)(u)
	if c == nil {
		return nil
	}

	g := &InetSocketAddress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *InetSocketAddress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *InetSocketAddress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetSocketAddress with another InetSocketAddress, and returns true if they represent the same GObject.
func (recv *InetSocketAddress) Equals(other *InetSocketAddress) bool {
	return other.ToC() == recv.ToC()
}

// SocketAddress upcasts to *SocketAddress
func (recv *InetSocketAddress) SocketAddress() *SocketAddress {
	return SocketAddressNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *InetSocketAddress) Object() *gobject.Object {
	return recv.SocketAddress().Object()
}

// CastToWidget down casts any arbitrary Object to InetSocketAddress.
// Exercise care, as this is a potentially dangerous function if the Object is not a InetSocketAddress.
func CastToInetSocketAddress(object *gobject.Object) *InetSocketAddress {
	return InetSocketAddressNewFromC(object.ToC())
}

// InetSocketAddressNew is a wrapper around the C function g_inet_socket_address_new.
func InetSocketAddressNew(address *InetAddress, port uint16) *InetSocketAddress {
	c_address := (*C.GInetAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GInetAddress)(address.ToC())
	}

	c_port := (C.guint16)(port)

	retC := C.g_inet_socket_address_new(c_address, c_port)
	retGo := InetSocketAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetAddress is a wrapper around the C function g_inet_socket_address_get_address.
func (recv *InetSocketAddress) GetAddress() *InetAddress {
	retC := C.g_inet_socket_address_get_address((*C.GInetSocketAddress)(recv.native))
	retGo := InetAddressNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFlowinfo is a wrapper around the C function g_inet_socket_address_get_flowinfo.
func (recv *InetSocketAddress) GetFlowinfo() uint32 {
	retC := C.g_inet_socket_address_get_flowinfo((*C.GInetSocketAddress)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetPort is a wrapper around the C function g_inet_socket_address_get_port.
func (recv *InetSocketAddress) GetPort() uint16 {
	retC := C.g_inet_socket_address_get_port((*C.GInetSocketAddress)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// GetScopeId is a wrapper around the C function g_inet_socket_address_get_scope_id.
func (recv *InetSocketAddress) GetScopeId() uint32 {
	retC := C.g_inet_socket_address_get_scope_id((*C.GInetSocketAddress)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// SocketConnectable returns the SocketConnectable interface implemented by InetSocketAddress
func (recv *InetSocketAddress) SocketConnectable() *SocketConnectable {
	return SocketConnectableNewFromC(recv.ToC())
}

// InputStream is a wrapper around the C record GInputStream.
type InputStream struct {
	native *C.GInputStream
	// parent_instance : record
	// Private : priv
}

func InputStreamNewFromC(u unsafe.Pointer) *InputStream {
	c := (*C.GInputStream)(u)
	if c == nil {
		return nil
	}

	g := &InputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *InputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *InputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InputStream with another InputStream, and returns true if they represent the same GObject.
func (recv *InputStream) Equals(other *InputStream) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *InputStream) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to InputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a InputStream.
func CastToInputStream(object *gobject.Object) *InputStream {
	return InputStreamNewFromC(object.ToC())
}

// ClearPending is a wrapper around the C function g_input_stream_clear_pending.
func (recv *InputStream) ClearPending() {
	C.g_input_stream_clear_pending((*C.GInputStream)(recv.native))

	return
}

// Close is a wrapper around the C function g_input_stream_close.
func (recv *InputStream) Close(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_input_stream_close((*C.GInputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_input_stream_close_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CloseFinish is a wrapper around the C function g_input_stream_close_finish.
func (recv *InputStream) CloseFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_input_stream_close_finish((*C.GInputStream)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// HasPending is a wrapper around the C function g_input_stream_has_pending.
func (recv *InputStream) HasPending() bool {
	retC := C.g_input_stream_has_pending((*C.GInputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsClosed is a wrapper around the C function g_input_stream_is_closed.
func (recv *InputStream) IsClosed() bool {
	retC := C.g_input_stream_is_closed((*C.GInputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Read is a wrapper around the C function g_input_stream_read.
func (recv *InputStream) Read(buffer []uint8, cancellable *Cancellable) (int64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_input_stream_read((*C.GInputStream)(recv.native), c_buffer, c_count, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReadAll is a wrapper around the C function g_input_stream_read_all.
func (recv *InputStream) ReadAll(buffer []uint8, cancellable *Cancellable) (bool, uint64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	var c_bytes_read C.gsize

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_input_stream_read_all((*C.GInputStream)(recv.native), c_buffer, c_count, &c_bytes_read, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	bytesRead := (uint64)(c_bytes_read)

	return retGo, bytesRead, goError
}

// Unsupported : g_input_stream_read_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReadBytes is a wrapper around the C function g_input_stream_read_bytes.
func (recv *InputStream) ReadBytes(count uint64, cancellable *Cancellable) (*glib.Bytes, error) {
	c_count := (C.gsize)(count)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_input_stream_read_bytes((*C.GInputStream)(recv.native), c_count, c_cancellable, &cThrowableError)
	retGo := glib.BytesNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_input_stream_read_bytes_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReadBytesFinish is a wrapper around the C function g_input_stream_read_bytes_finish.
func (recv *InputStream) ReadBytesFinish(result *AsyncResult) (*glib.Bytes, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_input_stream_read_bytes_finish((*C.GInputStream)(recv.native), c_result, &cThrowableError)
	retGo := glib.BytesNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReadFinish is a wrapper around the C function g_input_stream_read_finish.
func (recv *InputStream) ReadFinish(result *AsyncResult) (int64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_input_stream_read_finish((*C.GInputStream)(recv.native), c_result, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetPending is a wrapper around the C function g_input_stream_set_pending.
func (recv *InputStream) SetPending() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_input_stream_set_pending((*C.GInputStream)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Skip is a wrapper around the C function g_input_stream_skip.
func (recv *InputStream) Skip(count uint64, cancellable *Cancellable) (int64, error) {
	c_count := (C.gsize)(count)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_input_stream_skip((*C.GInputStream)(recv.native), c_count, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_input_stream_skip_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// SkipFinish is a wrapper around the C function g_input_stream_skip_finish.
func (recv *InputStream) SkipFinish(result *AsyncResult) (int64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_input_stream_skip_finish((*C.GInputStream)(recv.native), c_result, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ListStore is a wrapper around the C record GListStore.
type ListStore struct {
	native *C.GListStore
}

func ListStoreNewFromC(u unsafe.Pointer) *ListStore {
	c := (*C.GListStore)(u)
	if c == nil {
		return nil
	}

	g := &ListStore{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListStore) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListStore with another ListStore, and returns true if they represent the same GObject.
func (recv *ListStore) Equals(other *ListStore) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ListStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ListStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListStore.
func CastToListStore(object *gobject.Object) *ListStore {
	return ListStoreNewFromC(object.ToC())
}

// ListModel returns the ListModel interface implemented by ListStore
func (recv *ListStore) ListModel() *ListModel {
	return ListModelNewFromC(recv.ToC())
}

// MemoryInputStream is a wrapper around the C record GMemoryInputStream.
type MemoryInputStream struct {
	native *C.GMemoryInputStream
	// parent_instance : record
	// Private : priv
}

func MemoryInputStreamNewFromC(u unsafe.Pointer) *MemoryInputStream {
	c := (*C.GMemoryInputStream)(u)
	if c == nil {
		return nil
	}

	g := &MemoryInputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MemoryInputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MemoryInputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MemoryInputStream with another MemoryInputStream, and returns true if they represent the same GObject.
func (recv *MemoryInputStream) Equals(other *MemoryInputStream) bool {
	return other.ToC() == recv.ToC()
}

// InputStream upcasts to *InputStream
func (recv *MemoryInputStream) InputStream() *InputStream {
	return InputStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *MemoryInputStream) Object() *gobject.Object {
	return recv.InputStream().Object()
}

// CastToWidget down casts any arbitrary Object to MemoryInputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a MemoryInputStream.
func CastToMemoryInputStream(object *gobject.Object) *MemoryInputStream {
	return MemoryInputStreamNewFromC(object.ToC())
}

// MemoryInputStreamNew is a wrapper around the C function g_memory_input_stream_new.
func MemoryInputStreamNew() *MemoryInputStream {
	retC := C.g_memory_input_stream_new()
	retGo := MemoryInputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// MemoryInputStreamNewFromBytes is a wrapper around the C function g_memory_input_stream_new_from_bytes.
func MemoryInputStreamNewFromBytes(bytes *glib.Bytes) *MemoryInputStream {
	c_bytes := (*C.GBytes)(C.NULL)
	if bytes != nil {
		c_bytes = (*C.GBytes)(bytes.ToC())
	}

	retC := C.g_memory_input_stream_new_from_bytes(c_bytes)
	retGo := MemoryInputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Unsupported : g_memory_input_stream_new_from_data : unsupported parameter destroy : no type generator for GLib.DestroyNotify (GDestroyNotify) for param destroy

// AddBytes is a wrapper around the C function g_memory_input_stream_add_bytes.
func (recv *MemoryInputStream) AddBytes(bytes *glib.Bytes) {
	c_bytes := (*C.GBytes)(C.NULL)
	if bytes != nil {
		c_bytes = (*C.GBytes)(bytes.ToC())
	}

	C.g_memory_input_stream_add_bytes((*C.GMemoryInputStream)(recv.native), c_bytes)

	return
}

// Unsupported : g_memory_input_stream_add_data : unsupported parameter destroy : no type generator for GLib.DestroyNotify (GDestroyNotify) for param destroy

// PollableInputStream returns the PollableInputStream interface implemented by MemoryInputStream
func (recv *MemoryInputStream) PollableInputStream() *PollableInputStream {
	return PollableInputStreamNewFromC(recv.ToC())
}

// Seekable returns the Seekable interface implemented by MemoryInputStream
func (recv *MemoryInputStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// MemoryOutputStream is a wrapper around the C record GMemoryOutputStream.
type MemoryOutputStream struct {
	native *C.GMemoryOutputStream
	// parent_instance : record
	// Private : priv
}

func MemoryOutputStreamNewFromC(u unsafe.Pointer) *MemoryOutputStream {
	c := (*C.GMemoryOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &MemoryOutputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MemoryOutputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MemoryOutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MemoryOutputStream with another MemoryOutputStream, and returns true if they represent the same GObject.
func (recv *MemoryOutputStream) Equals(other *MemoryOutputStream) bool {
	return other.ToC() == recv.ToC()
}

// OutputStream upcasts to *OutputStream
func (recv *MemoryOutputStream) OutputStream() *OutputStream {
	return OutputStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *MemoryOutputStream) Object() *gobject.Object {
	return recv.OutputStream().Object()
}

// CastToWidget down casts any arbitrary Object to MemoryOutputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a MemoryOutputStream.
func CastToMemoryOutputStream(object *gobject.Object) *MemoryOutputStream {
	return MemoryOutputStreamNewFromC(object.ToC())
}

// Unsupported : g_memory_output_stream_new : unsupported parameter realloc_function : no type generator for ReallocFunc (GReallocFunc) for param realloc_function

// MemoryOutputStreamNewResizable is a wrapper around the C function g_memory_output_stream_new_resizable.
func MemoryOutputStreamNewResizable() *MemoryOutputStream {
	retC := C.g_memory_output_stream_new_resizable()
	retGo := MemoryOutputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetData is a wrapper around the C function g_memory_output_stream_get_data.
func (recv *MemoryOutputStream) GetData() uintptr {
	retC := C.g_memory_output_stream_get_data((*C.GMemoryOutputStream)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// GetDataSize is a wrapper around the C function g_memory_output_stream_get_data_size.
func (recv *MemoryOutputStream) GetDataSize() uint64 {
	retC := C.g_memory_output_stream_get_data_size((*C.GMemoryOutputStream)(recv.native))
	retGo := (uint64)(retC)

	return retGo
}

// GetSize is a wrapper around the C function g_memory_output_stream_get_size.
func (recv *MemoryOutputStream) GetSize() uint64 {
	retC := C.g_memory_output_stream_get_size((*C.GMemoryOutputStream)(recv.native))
	retGo := (uint64)(retC)

	return retGo
}

// StealAsBytes is a wrapper around the C function g_memory_output_stream_steal_as_bytes.
func (recv *MemoryOutputStream) StealAsBytes() *glib.Bytes {
	retC := C.g_memory_output_stream_steal_as_bytes((*C.GMemoryOutputStream)(recv.native))
	retGo := glib.BytesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// StealData is a wrapper around the C function g_memory_output_stream_steal_data.
func (recv *MemoryOutputStream) StealData() uintptr {
	retC := C.g_memory_output_stream_steal_data((*C.GMemoryOutputStream)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// PollableOutputStream returns the PollableOutputStream interface implemented by MemoryOutputStream
func (recv *MemoryOutputStream) PollableOutputStream() *PollableOutputStream {
	return PollableOutputStreamNewFromC(recv.ToC())
}

// Seekable returns the Seekable interface implemented by MemoryOutputStream
func (recv *MemoryOutputStream) Seekable() *Seekable {
	return SeekableNewFromC(recv.ToC())
}

// Menu is a wrapper around the C record GMenu.
type Menu struct {
	native *C.GMenu
}

func MenuNewFromC(u unsafe.Pointer) *Menu {
	c := (*C.GMenu)(u)
	if c == nil {
		return nil
	}

	g := &Menu{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Menu) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Menu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Menu with another Menu, and returns true if they represent the same GObject.
func (recv *Menu) Equals(other *Menu) bool {
	return other.ToC() == recv.ToC()
}

// MenuModel upcasts to *MenuModel
func (recv *Menu) MenuModel() *MenuModel {
	return MenuModelNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Menu) Object() *gobject.Object {
	return recv.MenuModel().Object()
}

// CastToWidget down casts any arbitrary Object to Menu.
// Exercise care, as this is a potentially dangerous function if the Object is not a Menu.
func CastToMenu(object *gobject.Object) *Menu {
	return MenuNewFromC(object.ToC())
}

// MenuNew is a wrapper around the C function g_menu_new.
func MenuNew() *Menu {
	retC := C.g_menu_new()
	retGo := MenuNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Append is a wrapper around the C function g_menu_append.
func (recv *Menu) Append(label string, detailedAction string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_detailed_action := C.CString(detailedAction)
	defer C.free(unsafe.Pointer(c_detailed_action))

	C.g_menu_append((*C.GMenu)(recv.native), c_label, c_detailed_action)

	return
}

// AppendItem is a wrapper around the C function g_menu_append_item.
func (recv *Menu) AppendItem(item *MenuItem) {
	c_item := (*C.GMenuItem)(C.NULL)
	if item != nil {
		c_item = (*C.GMenuItem)(item.ToC())
	}

	C.g_menu_append_item((*C.GMenu)(recv.native), c_item)

	return
}

// AppendSection is a wrapper around the C function g_menu_append_section.
func (recv *Menu) AppendSection(label string, section *MenuModel) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_section := (*C.GMenuModel)(C.NULL)
	if section != nil {
		c_section = (*C.GMenuModel)(section.ToC())
	}

	C.g_menu_append_section((*C.GMenu)(recv.native), c_label, c_section)

	return
}

// AppendSubmenu is a wrapper around the C function g_menu_append_submenu.
func (recv *Menu) AppendSubmenu(label string, submenu *MenuModel) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_submenu := (*C.GMenuModel)(C.NULL)
	if submenu != nil {
		c_submenu = (*C.GMenuModel)(submenu.ToC())
	}

	C.g_menu_append_submenu((*C.GMenu)(recv.native), c_label, c_submenu)

	return
}

// Freeze is a wrapper around the C function g_menu_freeze.
func (recv *Menu) Freeze() {
	C.g_menu_freeze((*C.GMenu)(recv.native))

	return
}

// Insert is a wrapper around the C function g_menu_insert.
func (recv *Menu) Insert(position int32, label string, detailedAction string) {
	c_position := (C.gint)(position)

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_detailed_action := C.CString(detailedAction)
	defer C.free(unsafe.Pointer(c_detailed_action))

	C.g_menu_insert((*C.GMenu)(recv.native), c_position, c_label, c_detailed_action)

	return
}

// InsertItem is a wrapper around the C function g_menu_insert_item.
func (recv *Menu) InsertItem(position int32, item *MenuItem) {
	c_position := (C.gint)(position)

	c_item := (*C.GMenuItem)(C.NULL)
	if item != nil {
		c_item = (*C.GMenuItem)(item.ToC())
	}

	C.g_menu_insert_item((*C.GMenu)(recv.native), c_position, c_item)

	return
}

// InsertSection is a wrapper around the C function g_menu_insert_section.
func (recv *Menu) InsertSection(position int32, label string, section *MenuModel) {
	c_position := (C.gint)(position)

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_section := (*C.GMenuModel)(C.NULL)
	if section != nil {
		c_section = (*C.GMenuModel)(section.ToC())
	}

	C.g_menu_insert_section((*C.GMenu)(recv.native), c_position, c_label, c_section)

	return
}

// InsertSubmenu is a wrapper around the C function g_menu_insert_submenu.
func (recv *Menu) InsertSubmenu(position int32, label string, submenu *MenuModel) {
	c_position := (C.gint)(position)

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_submenu := (*C.GMenuModel)(C.NULL)
	if submenu != nil {
		c_submenu = (*C.GMenuModel)(submenu.ToC())
	}

	C.g_menu_insert_submenu((*C.GMenu)(recv.native), c_position, c_label, c_submenu)

	return
}

// Prepend is a wrapper around the C function g_menu_prepend.
func (recv *Menu) Prepend(label string, detailedAction string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_detailed_action := C.CString(detailedAction)
	defer C.free(unsafe.Pointer(c_detailed_action))

	C.g_menu_prepend((*C.GMenu)(recv.native), c_label, c_detailed_action)

	return
}

// PrependItem is a wrapper around the C function g_menu_prepend_item.
func (recv *Menu) PrependItem(item *MenuItem) {
	c_item := (*C.GMenuItem)(C.NULL)
	if item != nil {
		c_item = (*C.GMenuItem)(item.ToC())
	}

	C.g_menu_prepend_item((*C.GMenu)(recv.native), c_item)

	return
}

// PrependSection is a wrapper around the C function g_menu_prepend_section.
func (recv *Menu) PrependSection(label string, section *MenuModel) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_section := (*C.GMenuModel)(C.NULL)
	if section != nil {
		c_section = (*C.GMenuModel)(section.ToC())
	}

	C.g_menu_prepend_section((*C.GMenu)(recv.native), c_label, c_section)

	return
}

// PrependSubmenu is a wrapper around the C function g_menu_prepend_submenu.
func (recv *Menu) PrependSubmenu(label string, submenu *MenuModel) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_submenu := (*C.GMenuModel)(C.NULL)
	if submenu != nil {
		c_submenu = (*C.GMenuModel)(submenu.ToC())
	}

	C.g_menu_prepend_submenu((*C.GMenu)(recv.native), c_label, c_submenu)

	return
}

// Remove is a wrapper around the C function g_menu_remove.
func (recv *Menu) Remove(position int32) {
	c_position := (C.gint)(position)

	C.g_menu_remove((*C.GMenu)(recv.native), c_position)

	return
}

// MenuAttributeIter is a wrapper around the C record GMenuAttributeIter.
type MenuAttributeIter struct {
	native *C.GMenuAttributeIter
	// parent_instance : record
	// priv : record
}

func MenuAttributeIterNewFromC(u unsafe.Pointer) *MenuAttributeIter {
	c := (*C.GMenuAttributeIter)(u)
	if c == nil {
		return nil
	}

	g := &MenuAttributeIter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuAttributeIter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuAttributeIter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuAttributeIter with another MenuAttributeIter, and returns true if they represent the same GObject.
func (recv *MenuAttributeIter) Equals(other *MenuAttributeIter) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *MenuAttributeIter) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to MenuAttributeIter.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuAttributeIter.
func CastToMenuAttributeIter(object *gobject.Object) *MenuAttributeIter {
	return MenuAttributeIterNewFromC(object.ToC())
}

// GetName is a wrapper around the C function g_menu_attribute_iter_get_name.
func (recv *MenuAttributeIter) GetName() string {
	retC := C.g_menu_attribute_iter_get_name((*C.GMenuAttributeIter)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetNext is a wrapper around the C function g_menu_attribute_iter_get_next.
func (recv *MenuAttributeIter) GetNext() (bool, string, *glib.Variant) {
	var c_out_name *C.gchar

	var c_value *C.GVariant

	retC := C.g_menu_attribute_iter_get_next((*C.GMenuAttributeIter)(recv.native), &c_out_name, &c_value)
	retGo := retC == C.TRUE

	outName := C.GoString(c_out_name)

	value := glib.VariantNewFromC(unsafe.Pointer(c_value))

	return retGo, outName, value
}

// GetValue is a wrapper around the C function g_menu_attribute_iter_get_value.
func (recv *MenuAttributeIter) GetValue() *glib.Variant {
	retC := C.g_menu_attribute_iter_get_value((*C.GMenuAttributeIter)(recv.native))
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Next is a wrapper around the C function g_menu_attribute_iter_next.
func (recv *MenuAttributeIter) Next() bool {
	retC := C.g_menu_attribute_iter_next((*C.GMenuAttributeIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// MenuItem is a wrapper around the C record GMenuItem.
type MenuItem struct {
	native *C.GMenuItem
}

func MenuItemNewFromC(u unsafe.Pointer) *MenuItem {
	c := (*C.GMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &MenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItem with another MenuItem, and returns true if they represent the same GObject.
func (recv *MenuItem) Equals(other *MenuItem) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *MenuItem) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to MenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItem.
func CastToMenuItem(object *gobject.Object) *MenuItem {
	return MenuItemNewFromC(object.ToC())
}

// MenuItemNew is a wrapper around the C function g_menu_item_new.
func MenuItemNew(label string, detailedAction string) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_detailed_action := C.CString(detailedAction)
	defer C.free(unsafe.Pointer(c_detailed_action))

	retC := C.g_menu_item_new(c_label, c_detailed_action)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// MenuItemNewFromModel is a wrapper around the C function g_menu_item_new_from_model.
func MenuItemNewFromModel(model *MenuModel, itemIndex int32) *MenuItem {
	c_model := (*C.GMenuModel)(C.NULL)
	if model != nil {
		c_model = (*C.GMenuModel)(model.ToC())
	}

	c_item_index := (C.gint)(itemIndex)

	retC := C.g_menu_item_new_from_model(c_model, c_item_index)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// MenuItemNewSection is a wrapper around the C function g_menu_item_new_section.
func MenuItemNewSection(label string, section *MenuModel) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_section := (*C.GMenuModel)(C.NULL)
	if section != nil {
		c_section = (*C.GMenuModel)(section.ToC())
	}

	retC := C.g_menu_item_new_section(c_label, c_section)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// MenuItemNewSubmenu is a wrapper around the C function g_menu_item_new_submenu.
func MenuItemNewSubmenu(label string, submenu *MenuModel) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_submenu := (*C.GMenuModel)(C.NULL)
	if submenu != nil {
		c_submenu = (*C.GMenuModel)(submenu.ToC())
	}

	retC := C.g_menu_item_new_submenu(c_label, c_submenu)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetAttribute is a wrapper around the C function g_menu_item_get_attribute.
func (recv *MenuItem) GetAttribute(attribute string, formatString string, args ...interface{}) bool {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	goFormattedString := fmt.Sprintf(formatString, args...)
	c_format_string := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format_string))

	retC := C._g_menu_item_get_attribute((*C.GMenuItem)(recv.native), c_attribute, c_format_string)
	retGo := retC == C.TRUE

	return retGo
}

// GetAttributeValue is a wrapper around the C function g_menu_item_get_attribute_value.
func (recv *MenuItem) GetAttributeValue(attribute string, expectedType *glib.VariantType) *glib.Variant {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_expected_type := (*C.GVariantType)(C.NULL)
	if expectedType != nil {
		c_expected_type = (*C.GVariantType)(expectedType.ToC())
	}

	retC := C.g_menu_item_get_attribute_value((*C.GMenuItem)(recv.native), c_attribute, c_expected_type)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLink is a wrapper around the C function g_menu_item_get_link.
func (recv *MenuItem) GetLink(link string) *MenuModel {
	c_link := C.CString(link)
	defer C.free(unsafe.Pointer(c_link))

	retC := C.g_menu_item_get_link((*C.GMenuItem)(recv.native), c_link)
	retGo := MenuModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetActionAndTarget is a wrapper around the C function g_menu_item_set_action_and_target.
func (recv *MenuItem) SetActionAndTarget(action string, formatString string, args ...interface{}) {
	c_action := C.CString(action)
	defer C.free(unsafe.Pointer(c_action))

	goFormattedString := fmt.Sprintf(formatString, args...)
	c_format_string := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format_string))

	C._g_menu_item_set_action_and_target((*C.GMenuItem)(recv.native), c_action, c_format_string)

	return
}

// SetActionAndTargetValue is a wrapper around the C function g_menu_item_set_action_and_target_value.
func (recv *MenuItem) SetActionAndTargetValue(action string, targetValue *glib.Variant) {
	c_action := C.CString(action)
	defer C.free(unsafe.Pointer(c_action))

	c_target_value := (*C.GVariant)(C.NULL)
	if targetValue != nil {
		c_target_value = (*C.GVariant)(targetValue.ToC())
	}

	C.g_menu_item_set_action_and_target_value((*C.GMenuItem)(recv.native), c_action, c_target_value)

	return
}

// SetAttribute is a wrapper around the C function g_menu_item_set_attribute.
func (recv *MenuItem) SetAttribute(attribute string, formatString string, args ...interface{}) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	goFormattedString := fmt.Sprintf(formatString, args...)
	c_format_string := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format_string))

	C._g_menu_item_set_attribute((*C.GMenuItem)(recv.native), c_attribute, c_format_string)

	return
}

// SetAttributeValue is a wrapper around the C function g_menu_item_set_attribute_value.
func (recv *MenuItem) SetAttributeValue(attribute string, value *glib.Variant) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	C.g_menu_item_set_attribute_value((*C.GMenuItem)(recv.native), c_attribute, c_value)

	return
}

// SetDetailedAction is a wrapper around the C function g_menu_item_set_detailed_action.
func (recv *MenuItem) SetDetailedAction(detailedAction string) {
	c_detailed_action := C.CString(detailedAction)
	defer C.free(unsafe.Pointer(c_detailed_action))

	C.g_menu_item_set_detailed_action((*C.GMenuItem)(recv.native), c_detailed_action)

	return
}

// SetLabel is a wrapper around the C function g_menu_item_set_label.
func (recv *MenuItem) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.g_menu_item_set_label((*C.GMenuItem)(recv.native), c_label)

	return
}

// SetLink is a wrapper around the C function g_menu_item_set_link.
func (recv *MenuItem) SetLink(link string, model *MenuModel) {
	c_link := C.CString(link)
	defer C.free(unsafe.Pointer(c_link))

	c_model := (*C.GMenuModel)(C.NULL)
	if model != nil {
		c_model = (*C.GMenuModel)(model.ToC())
	}

	C.g_menu_item_set_link((*C.GMenuItem)(recv.native), c_link, c_model)

	return
}

// SetSection is a wrapper around the C function g_menu_item_set_section.
func (recv *MenuItem) SetSection(section *MenuModel) {
	c_section := (*C.GMenuModel)(C.NULL)
	if section != nil {
		c_section = (*C.GMenuModel)(section.ToC())
	}

	C.g_menu_item_set_section((*C.GMenuItem)(recv.native), c_section)

	return
}

// SetSubmenu is a wrapper around the C function g_menu_item_set_submenu.
func (recv *MenuItem) SetSubmenu(submenu *MenuModel) {
	c_submenu := (*C.GMenuModel)(C.NULL)
	if submenu != nil {
		c_submenu = (*C.GMenuModel)(submenu.ToC())
	}

	C.g_menu_item_set_submenu((*C.GMenuItem)(recv.native), c_submenu)

	return
}

// MenuLinkIter is a wrapper around the C record GMenuLinkIter.
type MenuLinkIter struct {
	native *C.GMenuLinkIter
	// parent_instance : record
	// priv : record
}

func MenuLinkIterNewFromC(u unsafe.Pointer) *MenuLinkIter {
	c := (*C.GMenuLinkIter)(u)
	if c == nil {
		return nil
	}

	g := &MenuLinkIter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuLinkIter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuLinkIter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuLinkIter with another MenuLinkIter, and returns true if they represent the same GObject.
func (recv *MenuLinkIter) Equals(other *MenuLinkIter) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *MenuLinkIter) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to MenuLinkIter.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuLinkIter.
func CastToMenuLinkIter(object *gobject.Object) *MenuLinkIter {
	return MenuLinkIterNewFromC(object.ToC())
}

// GetName is a wrapper around the C function g_menu_link_iter_get_name.
func (recv *MenuLinkIter) GetName() string {
	retC := C.g_menu_link_iter_get_name((*C.GMenuLinkIter)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetNext is a wrapper around the C function g_menu_link_iter_get_next.
func (recv *MenuLinkIter) GetNext() (bool, string, *MenuModel) {
	var c_out_link *C.gchar

	var c_value *C.GMenuModel

	retC := C.g_menu_link_iter_get_next((*C.GMenuLinkIter)(recv.native), &c_out_link, &c_value)
	retGo := retC == C.TRUE

	outLink := C.GoString(c_out_link)

	value := MenuModelNewFromC(unsafe.Pointer(c_value))

	return retGo, outLink, value
}

// GetValue is a wrapper around the C function g_menu_link_iter_get_value.
func (recv *MenuLinkIter) GetValue() *MenuModel {
	retC := C.g_menu_link_iter_get_value((*C.GMenuLinkIter)(recv.native))
	retGo := MenuModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Next is a wrapper around the C function g_menu_link_iter_next.
func (recv *MenuLinkIter) Next() bool {
	retC := C.g_menu_link_iter_next((*C.GMenuLinkIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// MenuModel is a wrapper around the C record GMenuModel.
type MenuModel struct {
	native *C.GMenuModel
	// parent_instance : record
	// priv : record
}

func MenuModelNewFromC(u unsafe.Pointer) *MenuModel {
	c := (*C.GMenuModel)(u)
	if c == nil {
		return nil
	}

	g := &MenuModel{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuModel) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuModel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuModel with another MenuModel, and returns true if they represent the same GObject.
func (recv *MenuModel) Equals(other *MenuModel) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *MenuModel) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to MenuModel.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuModel.
func CastToMenuModel(object *gobject.Object) *MenuModel {
	return MenuModelNewFromC(object.ToC())
}

type signalMenuModelItemsChangedDetail struct {
	callback  MenuModelSignalItemsChangedCallback
	handlerID C.gulong
}

var signalMenuModelItemsChangedId int
var signalMenuModelItemsChangedMap = make(map[int]signalMenuModelItemsChangedDetail)
var signalMenuModelItemsChangedLock sync.RWMutex

// MenuModelSignalItemsChangedCallback is a callback function for a 'items-changed' signal emitted from a MenuModel.
type MenuModelSignalItemsChangedCallback func(position int32, removed int32, added int32)

/*
ConnectItemsChanged connects the callback to the 'items-changed' signal for the MenuModel.

The returned value represents the connection, and may be passed to DisconnectItemsChanged to remove it.
*/
func (recv *MenuModel) ConnectItemsChanged(callback MenuModelSignalItemsChangedCallback) int {
	signalMenuModelItemsChangedLock.Lock()
	defer signalMenuModelItemsChangedLock.Unlock()

	signalMenuModelItemsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuModel_signal_connect_items_changed(instance, C.gpointer(uintptr(signalMenuModelItemsChangedId)))

	detail := signalMenuModelItemsChangedDetail{callback, handlerID}
	signalMenuModelItemsChangedMap[signalMenuModelItemsChangedId] = detail

	return signalMenuModelItemsChangedId
}

/*
DisconnectItemsChanged disconnects a callback from the 'items-changed' signal for the MenuModel.

The connectionID should be a value returned from a call to ConnectItemsChanged.
*/
func (recv *MenuModel) DisconnectItemsChanged(connectionID int) {
	signalMenuModelItemsChangedLock.Lock()
	defer signalMenuModelItemsChangedLock.Unlock()

	detail, exists := signalMenuModelItemsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuModelItemsChangedMap, connectionID)
}

//export menumodel_itemsChangedHandler
func menumodel_itemsChangedHandler(_ *C.GObject, c_position C.gint, c_removed C.gint, c_added C.gint, data C.gpointer) {
	signalMenuModelItemsChangedLock.RLock()
	defer signalMenuModelItemsChangedLock.RUnlock()

	position := int32(c_position)

	removed := int32(c_removed)

	added := int32(c_added)

	index := int(uintptr(data))
	callback := signalMenuModelItemsChangedMap[index].callback
	callback(position, removed, added)
}

// GetItemAttribute is a wrapper around the C function g_menu_model_get_item_attribute.
func (recv *MenuModel) GetItemAttribute(itemIndex int32, attribute string, formatString string, args ...interface{}) bool {
	c_item_index := (C.gint)(itemIndex)

	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	goFormattedString := fmt.Sprintf(formatString, args...)
	c_format_string := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format_string))

	retC := C._g_menu_model_get_item_attribute((*C.GMenuModel)(recv.native), c_item_index, c_attribute, c_format_string)
	retGo := retC == C.TRUE

	return retGo
}

// GetItemAttributeValue is a wrapper around the C function g_menu_model_get_item_attribute_value.
func (recv *MenuModel) GetItemAttributeValue(itemIndex int32, attribute string, expectedType *glib.VariantType) *glib.Variant {
	c_item_index := (C.gint)(itemIndex)

	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_expected_type := (*C.GVariantType)(C.NULL)
	if expectedType != nil {
		c_expected_type = (*C.GVariantType)(expectedType.ToC())
	}

	retC := C.g_menu_model_get_item_attribute_value((*C.GMenuModel)(recv.native), c_item_index, c_attribute, c_expected_type)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetItemLink is a wrapper around the C function g_menu_model_get_item_link.
func (recv *MenuModel) GetItemLink(itemIndex int32, link string) *MenuModel {
	c_item_index := (C.gint)(itemIndex)

	c_link := C.CString(link)
	defer C.free(unsafe.Pointer(c_link))

	retC := C.g_menu_model_get_item_link((*C.GMenuModel)(recv.native), c_item_index, c_link)
	retGo := MenuModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetNItems is a wrapper around the C function g_menu_model_get_n_items.
func (recv *MenuModel) GetNItems() int32 {
	retC := C.g_menu_model_get_n_items((*C.GMenuModel)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// IsMutable is a wrapper around the C function g_menu_model_is_mutable.
func (recv *MenuModel) IsMutable() bool {
	retC := C.g_menu_model_is_mutable((*C.GMenuModel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ItemsChanged is a wrapper around the C function g_menu_model_items_changed.
func (recv *MenuModel) ItemsChanged(position int32, removed int32, added int32) {
	c_position := (C.gint)(position)

	c_removed := (C.gint)(removed)

	c_added := (C.gint)(added)

	C.g_menu_model_items_changed((*C.GMenuModel)(recv.native), c_position, c_removed, c_added)

	return
}

// IterateItemAttributes is a wrapper around the C function g_menu_model_iterate_item_attributes.
func (recv *MenuModel) IterateItemAttributes(itemIndex int32) *MenuAttributeIter {
	c_item_index := (C.gint)(itemIndex)

	retC := C.g_menu_model_iterate_item_attributes((*C.GMenuModel)(recv.native), c_item_index)
	retGo := MenuAttributeIterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IterateItemLinks is a wrapper around the C function g_menu_model_iterate_item_links.
func (recv *MenuModel) IterateItemLinks(itemIndex int32) *MenuLinkIter {
	c_item_index := (C.gint)(itemIndex)

	retC := C.g_menu_model_iterate_item_links((*C.GMenuModel)(recv.native), c_item_index)
	retGo := MenuLinkIterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// MountOperation is a wrapper around the C record GMountOperation.
type MountOperation struct {
	native *C.GMountOperation
	// parent_instance : record
	// priv : record
}

func MountOperationNewFromC(u unsafe.Pointer) *MountOperation {
	c := (*C.GMountOperation)(u)
	if c == nil {
		return nil
	}

	g := &MountOperation{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MountOperation) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MountOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MountOperation with another MountOperation, and returns true if they represent the same GObject.
func (recv *MountOperation) Equals(other *MountOperation) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *MountOperation) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to MountOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a MountOperation.
func CastToMountOperation(object *gobject.Object) *MountOperation {
	return MountOperationNewFromC(object.ToC())
}

type signalMountOperationAbortedDetail struct {
	callback  MountOperationSignalAbortedCallback
	handlerID C.gulong
}

var signalMountOperationAbortedId int
var signalMountOperationAbortedMap = make(map[int]signalMountOperationAbortedDetail)
var signalMountOperationAbortedLock sync.RWMutex

// MountOperationSignalAbortedCallback is a callback function for a 'aborted' signal emitted from a MountOperation.
type MountOperationSignalAbortedCallback func()

/*
ConnectAborted connects the callback to the 'aborted' signal for the MountOperation.

The returned value represents the connection, and may be passed to DisconnectAborted to remove it.
*/
func (recv *MountOperation) ConnectAborted(callback MountOperationSignalAbortedCallback) int {
	signalMountOperationAbortedLock.Lock()
	defer signalMountOperationAbortedLock.Unlock()

	signalMountOperationAbortedId++
	instance := C.gpointer(recv.native)
	handlerID := C.MountOperation_signal_connect_aborted(instance, C.gpointer(uintptr(signalMountOperationAbortedId)))

	detail := signalMountOperationAbortedDetail{callback, handlerID}
	signalMountOperationAbortedMap[signalMountOperationAbortedId] = detail

	return signalMountOperationAbortedId
}

/*
DisconnectAborted disconnects a callback from the 'aborted' signal for the MountOperation.

The connectionID should be a value returned from a call to ConnectAborted.
*/
func (recv *MountOperation) DisconnectAborted(connectionID int) {
	signalMountOperationAbortedLock.Lock()
	defer signalMountOperationAbortedLock.Unlock()

	detail, exists := signalMountOperationAbortedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMountOperationAbortedMap, connectionID)
}

//export mountoperation_abortedHandler
func mountoperation_abortedHandler(_ *C.GObject, data C.gpointer) {
	signalMountOperationAbortedLock.RLock()
	defer signalMountOperationAbortedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMountOperationAbortedMap[index].callback
	callback()
}

type signalMountOperationAskPasswordDetail struct {
	callback  MountOperationSignalAskPasswordCallback
	handlerID C.gulong
}

var signalMountOperationAskPasswordId int
var signalMountOperationAskPasswordMap = make(map[int]signalMountOperationAskPasswordDetail)
var signalMountOperationAskPasswordLock sync.RWMutex

// MountOperationSignalAskPasswordCallback is a callback function for a 'ask-password' signal emitted from a MountOperation.
type MountOperationSignalAskPasswordCallback func(message string, defaultUser string, defaultDomain string, flags AskPasswordFlags)

/*
ConnectAskPassword connects the callback to the 'ask-password' signal for the MountOperation.

The returned value represents the connection, and may be passed to DisconnectAskPassword to remove it.
*/
func (recv *MountOperation) ConnectAskPassword(callback MountOperationSignalAskPasswordCallback) int {
	signalMountOperationAskPasswordLock.Lock()
	defer signalMountOperationAskPasswordLock.Unlock()

	signalMountOperationAskPasswordId++
	instance := C.gpointer(recv.native)
	handlerID := C.MountOperation_signal_connect_ask_password(instance, C.gpointer(uintptr(signalMountOperationAskPasswordId)))

	detail := signalMountOperationAskPasswordDetail{callback, handlerID}
	signalMountOperationAskPasswordMap[signalMountOperationAskPasswordId] = detail

	return signalMountOperationAskPasswordId
}

/*
DisconnectAskPassword disconnects a callback from the 'ask-password' signal for the MountOperation.

The connectionID should be a value returned from a call to ConnectAskPassword.
*/
func (recv *MountOperation) DisconnectAskPassword(connectionID int) {
	signalMountOperationAskPasswordLock.Lock()
	defer signalMountOperationAskPasswordLock.Unlock()

	detail, exists := signalMountOperationAskPasswordMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMountOperationAskPasswordMap, connectionID)
}

//export mountoperation_askPasswordHandler
func mountoperation_askPasswordHandler(_ *C.GObject, c_message *C.gchar, c_default_user *C.gchar, c_default_domain *C.gchar, c_flags C.GAskPasswordFlags, data C.gpointer) {
	signalMountOperationAskPasswordLock.RLock()
	defer signalMountOperationAskPasswordLock.RUnlock()

	message := C.GoString(c_message)

	defaultUser := C.GoString(c_default_user)

	defaultDomain := C.GoString(c_default_domain)

	flags := AskPasswordFlags(c_flags)

	index := int(uintptr(data))
	callback := signalMountOperationAskPasswordMap[index].callback
	callback(message, defaultUser, defaultDomain, flags)
}

// Unsupported signal 'ask-question' for MountOperation : unsupported parameter choices :

type signalMountOperationReplyDetail struct {
	callback  MountOperationSignalReplyCallback
	handlerID C.gulong
}

var signalMountOperationReplyId int
var signalMountOperationReplyMap = make(map[int]signalMountOperationReplyDetail)
var signalMountOperationReplyLock sync.RWMutex

// MountOperationSignalReplyCallback is a callback function for a 'reply' signal emitted from a MountOperation.
type MountOperationSignalReplyCallback func(result MountOperationResult)

/*
ConnectReply connects the callback to the 'reply' signal for the MountOperation.

The returned value represents the connection, and may be passed to DisconnectReply to remove it.
*/
func (recv *MountOperation) ConnectReply(callback MountOperationSignalReplyCallback) int {
	signalMountOperationReplyLock.Lock()
	defer signalMountOperationReplyLock.Unlock()

	signalMountOperationReplyId++
	instance := C.gpointer(recv.native)
	handlerID := C.MountOperation_signal_connect_reply(instance, C.gpointer(uintptr(signalMountOperationReplyId)))

	detail := signalMountOperationReplyDetail{callback, handlerID}
	signalMountOperationReplyMap[signalMountOperationReplyId] = detail

	return signalMountOperationReplyId
}

/*
DisconnectReply disconnects a callback from the 'reply' signal for the MountOperation.

The connectionID should be a value returned from a call to ConnectReply.
*/
func (recv *MountOperation) DisconnectReply(connectionID int) {
	signalMountOperationReplyLock.Lock()
	defer signalMountOperationReplyLock.Unlock()

	detail, exists := signalMountOperationReplyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMountOperationReplyMap, connectionID)
}

//export mountoperation_replyHandler
func mountoperation_replyHandler(_ *C.GObject, c_result C.GMountOperationResult, data C.gpointer) {
	signalMountOperationReplyLock.RLock()
	defer signalMountOperationReplyLock.RUnlock()

	result := MountOperationResult(c_result)

	index := int(uintptr(data))
	callback := signalMountOperationReplyMap[index].callback
	callback(result)
}

// Unsupported signal 'show-processes' for MountOperation : unsupported parameter processes :

type signalMountOperationShowUnmountProgressDetail struct {
	callback  MountOperationSignalShowUnmountProgressCallback
	handlerID C.gulong
}

var signalMountOperationShowUnmountProgressId int
var signalMountOperationShowUnmountProgressMap = make(map[int]signalMountOperationShowUnmountProgressDetail)
var signalMountOperationShowUnmountProgressLock sync.RWMutex

// MountOperationSignalShowUnmountProgressCallback is a callback function for a 'show-unmount-progress' signal emitted from a MountOperation.
type MountOperationSignalShowUnmountProgressCallback func(message string, timeLeft int64, bytesLeft int64)

/*
ConnectShowUnmountProgress connects the callback to the 'show-unmount-progress' signal for the MountOperation.

The returned value represents the connection, and may be passed to DisconnectShowUnmountProgress to remove it.
*/
func (recv *MountOperation) ConnectShowUnmountProgress(callback MountOperationSignalShowUnmountProgressCallback) int {
	signalMountOperationShowUnmountProgressLock.Lock()
	defer signalMountOperationShowUnmountProgressLock.Unlock()

	signalMountOperationShowUnmountProgressId++
	instance := C.gpointer(recv.native)
	handlerID := C.MountOperation_signal_connect_show_unmount_progress(instance, C.gpointer(uintptr(signalMountOperationShowUnmountProgressId)))

	detail := signalMountOperationShowUnmountProgressDetail{callback, handlerID}
	signalMountOperationShowUnmountProgressMap[signalMountOperationShowUnmountProgressId] = detail

	return signalMountOperationShowUnmountProgressId
}

/*
DisconnectShowUnmountProgress disconnects a callback from the 'show-unmount-progress' signal for the MountOperation.

The connectionID should be a value returned from a call to ConnectShowUnmountProgress.
*/
func (recv *MountOperation) DisconnectShowUnmountProgress(connectionID int) {
	signalMountOperationShowUnmountProgressLock.Lock()
	defer signalMountOperationShowUnmountProgressLock.Unlock()

	detail, exists := signalMountOperationShowUnmountProgressMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMountOperationShowUnmountProgressMap, connectionID)
}

//export mountoperation_showUnmountProgressHandler
func mountoperation_showUnmountProgressHandler(_ *C.GObject, c_message *C.gchar, c_time_left C.gint64, c_bytes_left C.gint64, data C.gpointer) {
	signalMountOperationShowUnmountProgressLock.RLock()
	defer signalMountOperationShowUnmountProgressLock.RUnlock()

	message := C.GoString(c_message)

	timeLeft := int64(c_time_left)

	bytesLeft := int64(c_bytes_left)

	index := int(uintptr(data))
	callback := signalMountOperationShowUnmountProgressMap[index].callback
	callback(message, timeLeft, bytesLeft)
}

// MountOperationNew is a wrapper around the C function g_mount_operation_new.
func MountOperationNew() *MountOperation {
	retC := C.g_mount_operation_new()
	retGo := MountOperationNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetAnonymous is a wrapper around the C function g_mount_operation_get_anonymous.
func (recv *MountOperation) GetAnonymous() bool {
	retC := C.g_mount_operation_get_anonymous((*C.GMountOperation)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetChoice is a wrapper around the C function g_mount_operation_get_choice.
func (recv *MountOperation) GetChoice() int32 {
	retC := C.g_mount_operation_get_choice((*C.GMountOperation)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetDomain is a wrapper around the C function g_mount_operation_get_domain.
func (recv *MountOperation) GetDomain() string {
	retC := C.g_mount_operation_get_domain((*C.GMountOperation)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPassword is a wrapper around the C function g_mount_operation_get_password.
func (recv *MountOperation) GetPassword() string {
	retC := C.g_mount_operation_get_password((*C.GMountOperation)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPasswordSave is a wrapper around the C function g_mount_operation_get_password_save.
func (recv *MountOperation) GetPasswordSave() PasswordSave {
	retC := C.g_mount_operation_get_password_save((*C.GMountOperation)(recv.native))
	retGo := (PasswordSave)(retC)

	return retGo
}

// GetUsername is a wrapper around the C function g_mount_operation_get_username.
func (recv *MountOperation) GetUsername() string {
	retC := C.g_mount_operation_get_username((*C.GMountOperation)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Reply is a wrapper around the C function g_mount_operation_reply.
func (recv *MountOperation) Reply(result MountOperationResult) {
	c_result := (C.GMountOperationResult)(result)

	C.g_mount_operation_reply((*C.GMountOperation)(recv.native), c_result)

	return
}

// SetAnonymous is a wrapper around the C function g_mount_operation_set_anonymous.
func (recv *MountOperation) SetAnonymous(anonymous bool) {
	c_anonymous :=
		boolToGboolean(anonymous)

	C.g_mount_operation_set_anonymous((*C.GMountOperation)(recv.native), c_anonymous)

	return
}

// SetChoice is a wrapper around the C function g_mount_operation_set_choice.
func (recv *MountOperation) SetChoice(choice int32) {
	c_choice := (C.int)(choice)

	C.g_mount_operation_set_choice((*C.GMountOperation)(recv.native), c_choice)

	return
}

// SetDomain is a wrapper around the C function g_mount_operation_set_domain.
func (recv *MountOperation) SetDomain(domain string) {
	c_domain := C.CString(domain)
	defer C.free(unsafe.Pointer(c_domain))

	C.g_mount_operation_set_domain((*C.GMountOperation)(recv.native), c_domain)

	return
}

// SetPassword is a wrapper around the C function g_mount_operation_set_password.
func (recv *MountOperation) SetPassword(password string) {
	c_password := C.CString(password)
	defer C.free(unsafe.Pointer(c_password))

	C.g_mount_operation_set_password((*C.GMountOperation)(recv.native), c_password)

	return
}

// SetPasswordSave is a wrapper around the C function g_mount_operation_set_password_save.
func (recv *MountOperation) SetPasswordSave(save PasswordSave) {
	c_save := (C.GPasswordSave)(save)

	C.g_mount_operation_set_password_save((*C.GMountOperation)(recv.native), c_save)

	return
}

// SetUsername is a wrapper around the C function g_mount_operation_set_username.
func (recv *MountOperation) SetUsername(username string) {
	c_username := C.CString(username)
	defer C.free(unsafe.Pointer(c_username))

	C.g_mount_operation_set_username((*C.GMountOperation)(recv.native), c_username)

	return
}

// NativeVolumeMonitor is a wrapper around the C record GNativeVolumeMonitor.
type NativeVolumeMonitor struct {
	native *C.GNativeVolumeMonitor
	// parent_instance : record
}

func NativeVolumeMonitorNewFromC(u unsafe.Pointer) *NativeVolumeMonitor {
	c := (*C.GNativeVolumeMonitor)(u)
	if c == nil {
		return nil
	}

	g := &NativeVolumeMonitor{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NativeVolumeMonitor) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NativeVolumeMonitor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NativeVolumeMonitor with another NativeVolumeMonitor, and returns true if they represent the same GObject.
func (recv *NativeVolumeMonitor) Equals(other *NativeVolumeMonitor) bool {
	return other.ToC() == recv.ToC()
}

// VolumeMonitor upcasts to *VolumeMonitor
func (recv *NativeVolumeMonitor) VolumeMonitor() *VolumeMonitor {
	return VolumeMonitorNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *NativeVolumeMonitor) Object() *gobject.Object {
	return recv.VolumeMonitor().Object()
}

// CastToWidget down casts any arbitrary Object to NativeVolumeMonitor.
// Exercise care, as this is a potentially dangerous function if the Object is not a NativeVolumeMonitor.
func CastToNativeVolumeMonitor(object *gobject.Object) *NativeVolumeMonitor {
	return NativeVolumeMonitorNewFromC(object.ToC())
}

// NetworkAddress is a wrapper around the C record GNetworkAddress.
type NetworkAddress struct {
	native *C.GNetworkAddress
	// parent_instance : record
	// Private : priv
}

func NetworkAddressNewFromC(u unsafe.Pointer) *NetworkAddress {
	c := (*C.GNetworkAddress)(u)
	if c == nil {
		return nil
	}

	g := &NetworkAddress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NetworkAddress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NetworkAddress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NetworkAddress with another NetworkAddress, and returns true if they represent the same GObject.
func (recv *NetworkAddress) Equals(other *NetworkAddress) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *NetworkAddress) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to NetworkAddress.
// Exercise care, as this is a potentially dangerous function if the Object is not a NetworkAddress.
func CastToNetworkAddress(object *gobject.Object) *NetworkAddress {
	return NetworkAddressNewFromC(object.ToC())
}

// NetworkAddressNew is a wrapper around the C function g_network_address_new.
func NetworkAddressNew(hostname string, port uint16) *NetworkAddress {
	c_hostname := C.CString(hostname)
	defer C.free(unsafe.Pointer(c_hostname))

	c_port := (C.guint16)(port)

	retC := C.g_network_address_new(c_hostname, c_port)
	retGo := NetworkAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// NetworkAddressParse is a wrapper around the C function g_network_address_parse.
func NetworkAddressParse(hostAndPort string, defaultPort uint16) (*NetworkAddress, error) {
	c_host_and_port := C.CString(hostAndPort)
	defer C.free(unsafe.Pointer(c_host_and_port))

	c_default_port := (C.guint16)(defaultPort)

	var cThrowableError *C.GError

	retC := C.g_network_address_parse(c_host_and_port, c_default_port, &cThrowableError)
	retGo := NetworkAddressNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// NetworkAddressParseUri is a wrapper around the C function g_network_address_parse_uri.
func NetworkAddressParseUri(uri string, defaultPort uint16) (*NetworkAddress, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	c_default_port := (C.guint16)(defaultPort)

	var cThrowableError *C.GError

	retC := C.g_network_address_parse_uri(c_uri, c_default_port, &cThrowableError)
	retGo := NetworkAddressNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetHostname is a wrapper around the C function g_network_address_get_hostname.
func (recv *NetworkAddress) GetHostname() string {
	retC := C.g_network_address_get_hostname((*C.GNetworkAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPort is a wrapper around the C function g_network_address_get_port.
func (recv *NetworkAddress) GetPort() uint16 {
	retC := C.g_network_address_get_port((*C.GNetworkAddress)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// GetScheme is a wrapper around the C function g_network_address_get_scheme.
func (recv *NetworkAddress) GetScheme() string {
	retC := C.g_network_address_get_scheme((*C.GNetworkAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SocketConnectable returns the SocketConnectable interface implemented by NetworkAddress
func (recv *NetworkAddress) SocketConnectable() *SocketConnectable {
	return SocketConnectableNewFromC(recv.ToC())
}

// NetworkService is a wrapper around the C record GNetworkService.
type NetworkService struct {
	native *C.GNetworkService
	// parent_instance : record
	// Private : priv
}

func NetworkServiceNewFromC(u unsafe.Pointer) *NetworkService {
	c := (*C.GNetworkService)(u)
	if c == nil {
		return nil
	}

	g := &NetworkService{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NetworkService) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NetworkService) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NetworkService with another NetworkService, and returns true if they represent the same GObject.
func (recv *NetworkService) Equals(other *NetworkService) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *NetworkService) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to NetworkService.
// Exercise care, as this is a potentially dangerous function if the Object is not a NetworkService.
func CastToNetworkService(object *gobject.Object) *NetworkService {
	return NetworkServiceNewFromC(object.ToC())
}

// NetworkServiceNew is a wrapper around the C function g_network_service_new.
func NetworkServiceNew(service string, protocol string, domain string) *NetworkService {
	c_service := C.CString(service)
	defer C.free(unsafe.Pointer(c_service))

	c_protocol := C.CString(protocol)
	defer C.free(unsafe.Pointer(c_protocol))

	c_domain := C.CString(domain)
	defer C.free(unsafe.Pointer(c_domain))

	retC := C.g_network_service_new(c_service, c_protocol, c_domain)
	retGo := NetworkServiceNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetDomain is a wrapper around the C function g_network_service_get_domain.
func (recv *NetworkService) GetDomain() string {
	retC := C.g_network_service_get_domain((*C.GNetworkService)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetProtocol is a wrapper around the C function g_network_service_get_protocol.
func (recv *NetworkService) GetProtocol() string {
	retC := C.g_network_service_get_protocol((*C.GNetworkService)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetScheme is a wrapper around the C function g_network_service_get_scheme.
func (recv *NetworkService) GetScheme() string {
	retC := C.g_network_service_get_scheme((*C.GNetworkService)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetService is a wrapper around the C function g_network_service_get_service.
func (recv *NetworkService) GetService() string {
	retC := C.g_network_service_get_service((*C.GNetworkService)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SetScheme is a wrapper around the C function g_network_service_set_scheme.
func (recv *NetworkService) SetScheme(scheme string) {
	c_scheme := C.CString(scheme)
	defer C.free(unsafe.Pointer(c_scheme))

	C.g_network_service_set_scheme((*C.GNetworkService)(recv.native), c_scheme)

	return
}

// SocketConnectable returns the SocketConnectable interface implemented by NetworkService
func (recv *NetworkService) SocketConnectable() *SocketConnectable {
	return SocketConnectableNewFromC(recv.ToC())
}

// OutputStream is a wrapper around the C record GOutputStream.
type OutputStream struct {
	native *C.GOutputStream
	// parent_instance : record
	// Private : priv
}

func OutputStreamNewFromC(u unsafe.Pointer) *OutputStream {
	c := (*C.GOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &OutputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *OutputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *OutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OutputStream with another OutputStream, and returns true if they represent the same GObject.
func (recv *OutputStream) Equals(other *OutputStream) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *OutputStream) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to OutputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a OutputStream.
func CastToOutputStream(object *gobject.Object) *OutputStream {
	return OutputStreamNewFromC(object.ToC())
}

// ClearPending is a wrapper around the C function g_output_stream_clear_pending.
func (recv *OutputStream) ClearPending() {
	C.g_output_stream_clear_pending((*C.GOutputStream)(recv.native))

	return
}

// Close is a wrapper around the C function g_output_stream_close.
func (recv *OutputStream) Close(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_output_stream_close((*C.GOutputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_output_stream_close_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CloseFinish is a wrapper around the C function g_output_stream_close_finish.
func (recv *OutputStream) CloseFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_output_stream_close_finish((*C.GOutputStream)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Flush is a wrapper around the C function g_output_stream_flush.
func (recv *OutputStream) Flush(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_output_stream_flush((*C.GOutputStream)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_output_stream_flush_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// FlushFinish is a wrapper around the C function g_output_stream_flush_finish.
func (recv *OutputStream) FlushFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_output_stream_flush_finish((*C.GOutputStream)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// HasPending is a wrapper around the C function g_output_stream_has_pending.
func (recv *OutputStream) HasPending() bool {
	retC := C.g_output_stream_has_pending((*C.GOutputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsClosed is a wrapper around the C function g_output_stream_is_closed.
func (recv *OutputStream) IsClosed() bool {
	retC := C.g_output_stream_is_closed((*C.GOutputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsClosing is a wrapper around the C function g_output_stream_is_closing.
func (recv *OutputStream) IsClosing() bool {
	retC := C.g_output_stream_is_closing((*C.GOutputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetPending is a wrapper around the C function g_output_stream_set_pending.
func (recv *OutputStream) SetPending() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_output_stream_set_pending((*C.GOutputStream)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Splice is a wrapper around the C function g_output_stream_splice.
func (recv *OutputStream) Splice(source *InputStream, flags OutputStreamSpliceFlags, cancellable *Cancellable) (int64, error) {
	c_source := (*C.GInputStream)(C.NULL)
	if source != nil {
		c_source = (*C.GInputStream)(source.ToC())
	}

	c_flags := (C.GOutputStreamSpliceFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_output_stream_splice((*C.GOutputStream)(recv.native), c_source, c_flags, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_output_stream_splice_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// SpliceFinish is a wrapper around the C function g_output_stream_splice_finish.
func (recv *OutputStream) SpliceFinish(result *AsyncResult) (int64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_output_stream_splice_finish((*C.GOutputStream)(recv.native), c_result, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Write is a wrapper around the C function g_output_stream_write.
func (recv *OutputStream) Write(buffer []uint8, cancellable *Cancellable) (int64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_output_stream_write((*C.GOutputStream)(recv.native), c_buffer, c_count, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// WriteAll is a wrapper around the C function g_output_stream_write_all.
func (recv *OutputStream) WriteAll(buffer []uint8, cancellable *Cancellable) (bool, uint64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	var c_bytes_written C.gsize

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_output_stream_write_all((*C.GOutputStream)(recv.native), c_buffer, c_count, &c_bytes_written, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	bytesWritten := (uint64)(c_bytes_written)

	return retGo, bytesWritten, goError
}

// Unsupported : g_output_stream_write_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Blacklisted : g_output_stream_write_bytes

// Unsupported : g_output_stream_write_bytes_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// WriteBytesFinish is a wrapper around the C function g_output_stream_write_bytes_finish.
func (recv *OutputStream) WriteBytesFinish(result *AsyncResult) (int64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_output_stream_write_bytes_finish((*C.GOutputStream)(recv.native), c_result, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// WriteFinish is a wrapper around the C function g_output_stream_write_finish.
func (recv *OutputStream) WriteFinish(result *AsyncResult) (int64, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_output_stream_write_finish((*C.GOutputStream)(recv.native), c_result, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Permission is a wrapper around the C record GPermission.
type Permission struct {
	native *C.GPermission
	// parent_instance : record
	// Private : priv
}

func PermissionNewFromC(u unsafe.Pointer) *Permission {
	c := (*C.GPermission)(u)
	if c == nil {
		return nil
	}

	g := &Permission{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Permission) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Permission) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Permission with another Permission, and returns true if they represent the same GObject.
func (recv *Permission) Equals(other *Permission) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Permission) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Permission.
// Exercise care, as this is a potentially dangerous function if the Object is not a Permission.
func CastToPermission(object *gobject.Object) *Permission {
	return PermissionNewFromC(object.ToC())
}

// Acquire is a wrapper around the C function g_permission_acquire.
func (recv *Permission) Acquire(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_permission_acquire((*C.GPermission)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_permission_acquire_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// AcquireFinish is a wrapper around the C function g_permission_acquire_finish.
func (recv *Permission) AcquireFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_permission_acquire_finish((*C.GPermission)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetAllowed is a wrapper around the C function g_permission_get_allowed.
func (recv *Permission) GetAllowed() bool {
	retC := C.g_permission_get_allowed((*C.GPermission)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetCanAcquire is a wrapper around the C function g_permission_get_can_acquire.
func (recv *Permission) GetCanAcquire() bool {
	retC := C.g_permission_get_can_acquire((*C.GPermission)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetCanRelease is a wrapper around the C function g_permission_get_can_release.
func (recv *Permission) GetCanRelease() bool {
	retC := C.g_permission_get_can_release((*C.GPermission)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ImplUpdate is a wrapper around the C function g_permission_impl_update.
func (recv *Permission) ImplUpdate(allowed bool, canAcquire bool, canRelease bool) {
	c_allowed :=
		boolToGboolean(allowed)

	c_can_acquire :=
		boolToGboolean(canAcquire)

	c_can_release :=
		boolToGboolean(canRelease)

	C.g_permission_impl_update((*C.GPermission)(recv.native), c_allowed, c_can_acquire, c_can_release)

	return
}

// Release is a wrapper around the C function g_permission_release.
func (recv *Permission) Release(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_permission_release((*C.GPermission)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_permission_release_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReleaseFinish is a wrapper around the C function g_permission_release_finish.
func (recv *Permission) ReleaseFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_permission_release_finish((*C.GPermission)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ProxyAddress is a wrapper around the C record GProxyAddress.
type ProxyAddress struct {
	native *C.GProxyAddress
	// parent_instance : record
	// Private : priv
}

func ProxyAddressNewFromC(u unsafe.Pointer) *ProxyAddress {
	c := (*C.GProxyAddress)(u)
	if c == nil {
		return nil
	}

	g := &ProxyAddress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ProxyAddress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ProxyAddress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyAddress with another ProxyAddress, and returns true if they represent the same GObject.
func (recv *ProxyAddress) Equals(other *ProxyAddress) bool {
	return other.ToC() == recv.ToC()
}

// InetSocketAddress upcasts to *InetSocketAddress
func (recv *ProxyAddress) InetSocketAddress() *InetSocketAddress {
	return InetSocketAddressNewFromC(unsafe.Pointer(recv.native))
}

// SocketAddress upcasts to *SocketAddress
func (recv *ProxyAddress) SocketAddress() *SocketAddress {
	return recv.InetSocketAddress().SocketAddress()
}

// Object upcasts to *Object
func (recv *ProxyAddress) Object() *gobject.Object {
	return recv.InetSocketAddress().Object()
}

// CastToWidget down casts any arbitrary Object to ProxyAddress.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProxyAddress.
func CastToProxyAddress(object *gobject.Object) *ProxyAddress {
	return ProxyAddressNewFromC(object.ToC())
}

// ProxyAddressNew is a wrapper around the C function g_proxy_address_new.
func ProxyAddressNew(inetaddr *InetAddress, port uint16, protocol string, destHostname string, destPort uint16, username string, password string) *ProxyAddress {
	c_inetaddr := (*C.GInetAddress)(C.NULL)
	if inetaddr != nil {
		c_inetaddr = (*C.GInetAddress)(inetaddr.ToC())
	}

	c_port := (C.guint16)(port)

	c_protocol := C.CString(protocol)
	defer C.free(unsafe.Pointer(c_protocol))

	c_dest_hostname := C.CString(destHostname)
	defer C.free(unsafe.Pointer(c_dest_hostname))

	c_dest_port := (C.guint16)(destPort)

	c_username := C.CString(username)
	defer C.free(unsafe.Pointer(c_username))

	c_password := C.CString(password)
	defer C.free(unsafe.Pointer(c_password))

	retC := C.g_proxy_address_new(c_inetaddr, c_port, c_protocol, c_dest_hostname, c_dest_port, c_username, c_password)
	retGo := ProxyAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetDestinationHostname is a wrapper around the C function g_proxy_address_get_destination_hostname.
func (recv *ProxyAddress) GetDestinationHostname() string {
	retC := C.g_proxy_address_get_destination_hostname((*C.GProxyAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDestinationPort is a wrapper around the C function g_proxy_address_get_destination_port.
func (recv *ProxyAddress) GetDestinationPort() uint16 {
	retC := C.g_proxy_address_get_destination_port((*C.GProxyAddress)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// GetDestinationProtocol is a wrapper around the C function g_proxy_address_get_destination_protocol.
func (recv *ProxyAddress) GetDestinationProtocol() string {
	retC := C.g_proxy_address_get_destination_protocol((*C.GProxyAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPassword is a wrapper around the C function g_proxy_address_get_password.
func (recv *ProxyAddress) GetPassword() string {
	retC := C.g_proxy_address_get_password((*C.GProxyAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetProtocol is a wrapper around the C function g_proxy_address_get_protocol.
func (recv *ProxyAddress) GetProtocol() string {
	retC := C.g_proxy_address_get_protocol((*C.GProxyAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUri is a wrapper around the C function g_proxy_address_get_uri.
func (recv *ProxyAddress) GetUri() string {
	retC := C.g_proxy_address_get_uri((*C.GProxyAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUsername is a wrapper around the C function g_proxy_address_get_username.
func (recv *ProxyAddress) GetUsername() string {
	retC := C.g_proxy_address_get_username((*C.GProxyAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SocketConnectable returns the SocketConnectable interface implemented by ProxyAddress
func (recv *ProxyAddress) SocketConnectable() *SocketConnectable {
	return SocketConnectableNewFromC(recv.ToC())
}

// ProxyAddressEnumerator is a wrapper around the C record GProxyAddressEnumerator.
type ProxyAddressEnumerator struct {
	native *C.GProxyAddressEnumerator
	// parent_instance : record
	// priv : record
}

func ProxyAddressEnumeratorNewFromC(u unsafe.Pointer) *ProxyAddressEnumerator {
	c := (*C.GProxyAddressEnumerator)(u)
	if c == nil {
		return nil
	}

	g := &ProxyAddressEnumerator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ProxyAddressEnumerator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ProxyAddressEnumerator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyAddressEnumerator with another ProxyAddressEnumerator, and returns true if they represent the same GObject.
func (recv *ProxyAddressEnumerator) Equals(other *ProxyAddressEnumerator) bool {
	return other.ToC() == recv.ToC()
}

// SocketAddressEnumerator upcasts to *SocketAddressEnumerator
func (recv *ProxyAddressEnumerator) SocketAddressEnumerator() *SocketAddressEnumerator {
	return SocketAddressEnumeratorNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *ProxyAddressEnumerator) Object() *gobject.Object {
	return recv.SocketAddressEnumerator().Object()
}

// CastToWidget down casts any arbitrary Object to ProxyAddressEnumerator.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProxyAddressEnumerator.
func CastToProxyAddressEnumerator(object *gobject.Object) *ProxyAddressEnumerator {
	return ProxyAddressEnumeratorNewFromC(object.ToC())
}

// Resolver is a wrapper around the C record GResolver.
type Resolver struct {
	native *C.GResolver
	// parent_instance : record
	// priv : record
}

func ResolverNewFromC(u unsafe.Pointer) *Resolver {
	c := (*C.GResolver)(u)
	if c == nil {
		return nil
	}

	g := &Resolver{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Resolver) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Resolver) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Resolver with another Resolver, and returns true if they represent the same GObject.
func (recv *Resolver) Equals(other *Resolver) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Resolver) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Resolver.
// Exercise care, as this is a potentially dangerous function if the Object is not a Resolver.
func CastToResolver(object *gobject.Object) *Resolver {
	return ResolverNewFromC(object.ToC())
}

type signalResolverReloadDetail struct {
	callback  ResolverSignalReloadCallback
	handlerID C.gulong
}

var signalResolverReloadId int
var signalResolverReloadMap = make(map[int]signalResolverReloadDetail)
var signalResolverReloadLock sync.RWMutex

// ResolverSignalReloadCallback is a callback function for a 'reload' signal emitted from a Resolver.
type ResolverSignalReloadCallback func()

/*
ConnectReload connects the callback to the 'reload' signal for the Resolver.

The returned value represents the connection, and may be passed to DisconnectReload to remove it.
*/
func (recv *Resolver) ConnectReload(callback ResolverSignalReloadCallback) int {
	signalResolverReloadLock.Lock()
	defer signalResolverReloadLock.Unlock()

	signalResolverReloadId++
	instance := C.gpointer(recv.native)
	handlerID := C.Resolver_signal_connect_reload(instance, C.gpointer(uintptr(signalResolverReloadId)))

	detail := signalResolverReloadDetail{callback, handlerID}
	signalResolverReloadMap[signalResolverReloadId] = detail

	return signalResolverReloadId
}

/*
DisconnectReload disconnects a callback from the 'reload' signal for the Resolver.

The connectionID should be a value returned from a call to ConnectReload.
*/
func (recv *Resolver) DisconnectReload(connectionID int) {
	signalResolverReloadLock.Lock()
	defer signalResolverReloadLock.Unlock()

	detail, exists := signalResolverReloadMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalResolverReloadMap, connectionID)
}

//export resolver_reloadHandler
func resolver_reloadHandler(_ *C.GObject, data C.gpointer) {
	signalResolverReloadLock.RLock()
	defer signalResolverReloadLock.RUnlock()

	index := int(uintptr(data))
	callback := signalResolverReloadMap[index].callback
	callback()
}

// ResolverFreeAddresses is a wrapper around the C function g_resolver_free_addresses.
func ResolverFreeAddresses(addresses *glib.List) {
	c_addresses := (*C.GList)(C.NULL)
	if addresses != nil {
		c_addresses = (*C.GList)(addresses.ToC())
	}

	C.g_resolver_free_addresses(c_addresses)

	return
}

// ResolverFreeTargets is a wrapper around the C function g_resolver_free_targets.
func ResolverFreeTargets(targets *glib.List) {
	c_targets := (*C.GList)(C.NULL)
	if targets != nil {
		c_targets = (*C.GList)(targets.ToC())
	}

	C.g_resolver_free_targets(c_targets)

	return
}

// ResolverGetDefault is a wrapper around the C function g_resolver_get_default.
func ResolverGetDefault() *Resolver {
	retC := C.g_resolver_get_default()
	retGo := ResolverNewFromC(unsafe.Pointer(retC))

	return retGo
}

// LookupByAddress is a wrapper around the C function g_resolver_lookup_by_address.
func (recv *Resolver) LookupByAddress(address *InetAddress, cancellable *Cancellable) (string, error) {
	c_address := (*C.GInetAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GInetAddress)(address.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_resolver_lookup_by_address((*C.GResolver)(recv.native), c_address, c_cancellable, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_resolver_lookup_by_address_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LookupByAddressFinish is a wrapper around the C function g_resolver_lookup_by_address_finish.
func (recv *Resolver) LookupByAddressFinish(result *AsyncResult) (string, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_resolver_lookup_by_address_finish((*C.GResolver)(recv.native), c_result, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LookupByName is a wrapper around the C function g_resolver_lookup_by_name.
func (recv *Resolver) LookupByName(hostname string, cancellable *Cancellable) (*glib.List, error) {
	c_hostname := C.CString(hostname)
	defer C.free(unsafe.Pointer(c_hostname))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_resolver_lookup_by_name((*C.GResolver)(recv.native), c_hostname, c_cancellable, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_resolver_lookup_by_name_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LookupByNameFinish is a wrapper around the C function g_resolver_lookup_by_name_finish.
func (recv *Resolver) LookupByNameFinish(result *AsyncResult) (*glib.List, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_resolver_lookup_by_name_finish((*C.GResolver)(recv.native), c_result, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LookupRecords is a wrapper around the C function g_resolver_lookup_records.
func (recv *Resolver) LookupRecords(rrname string, recordType ResolverRecordType, cancellable *Cancellable) (*glib.List, error) {
	c_rrname := C.CString(rrname)
	defer C.free(unsafe.Pointer(c_rrname))

	c_record_type := (C.GResolverRecordType)(recordType)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_resolver_lookup_records((*C.GResolver)(recv.native), c_rrname, c_record_type, c_cancellable, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_resolver_lookup_records_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LookupRecordsFinish is a wrapper around the C function g_resolver_lookup_records_finish.
func (recv *Resolver) LookupRecordsFinish(result *AsyncResult) (*glib.List, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_resolver_lookup_records_finish((*C.GResolver)(recv.native), c_result, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LookupService is a wrapper around the C function g_resolver_lookup_service.
func (recv *Resolver) LookupService(service string, protocol string, domain string, cancellable *Cancellable) (*glib.List, error) {
	c_service := C.CString(service)
	defer C.free(unsafe.Pointer(c_service))

	c_protocol := C.CString(protocol)
	defer C.free(unsafe.Pointer(c_protocol))

	c_domain := C.CString(domain)
	defer C.free(unsafe.Pointer(c_domain))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_resolver_lookup_service((*C.GResolver)(recv.native), c_service, c_protocol, c_domain, c_cancellable, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_resolver_lookup_service_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LookupServiceFinish is a wrapper around the C function g_resolver_lookup_service_finish.
func (recv *Resolver) LookupServiceFinish(result *AsyncResult) (*glib.List, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_resolver_lookup_service_finish((*C.GResolver)(recv.native), c_result, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetDefault is a wrapper around the C function g_resolver_set_default.
func (recv *Resolver) SetDefault() {
	C.g_resolver_set_default((*C.GResolver)(recv.native))

	return
}

// Settings is a wrapper around the C record GSettings.
type Settings struct {
	native *C.GSettings
	// parent_instance : record
	// priv : record
}

func SettingsNewFromC(u unsafe.Pointer) *Settings {
	c := (*C.GSettings)(u)
	if c == nil {
		return nil
	}

	g := &Settings{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Settings) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Settings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Settings with another Settings, and returns true if they represent the same GObject.
func (recv *Settings) Equals(other *Settings) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Settings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Settings.
// Exercise care, as this is a potentially dangerous function if the Object is not a Settings.
func CastToSettings(object *gobject.Object) *Settings {
	return SettingsNewFromC(object.ToC())
}

// Unsupported signal 'change-event' for Settings : unsupported parameter keys :

type signalSettingsChangedDetail struct {
	callback  SettingsSignalChangedCallback
	handlerID C.gulong
}

var signalSettingsChangedId int
var signalSettingsChangedMap = make(map[int]signalSettingsChangedDetail)
var signalSettingsChangedLock sync.RWMutex

// SettingsSignalChangedCallback is a callback function for a 'changed' signal emitted from a Settings.
type SettingsSignalChangedCallback func(key string)

/*
ConnectChanged connects the callback to the 'changed' signal for the Settings.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Settings) ConnectChanged(callback SettingsSignalChangedCallback) int {
	signalSettingsChangedLock.Lock()
	defer signalSettingsChangedLock.Unlock()

	signalSettingsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Settings_signal_connect_changed(instance, C.gpointer(uintptr(signalSettingsChangedId)))

	detail := signalSettingsChangedDetail{callback, handlerID}
	signalSettingsChangedMap[signalSettingsChangedId] = detail

	return signalSettingsChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Settings.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Settings) DisconnectChanged(connectionID int) {
	signalSettingsChangedLock.Lock()
	defer signalSettingsChangedLock.Unlock()

	detail, exists := signalSettingsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSettingsChangedMap, connectionID)
}

//export settings_changedHandler
func settings_changedHandler(_ *C.GObject, c_key *C.gchar, data C.gpointer) {
	signalSettingsChangedLock.RLock()
	defer signalSettingsChangedLock.RUnlock()

	key := C.GoString(c_key)

	index := int(uintptr(data))
	callback := signalSettingsChangedMap[index].callback
	callback(key)
}

type signalSettingsWritableChangeEventDetail struct {
	callback  SettingsSignalWritableChangeEventCallback
	handlerID C.gulong
}

var signalSettingsWritableChangeEventId int
var signalSettingsWritableChangeEventMap = make(map[int]signalSettingsWritableChangeEventDetail)
var signalSettingsWritableChangeEventLock sync.RWMutex

// SettingsSignalWritableChangeEventCallback is a callback function for a 'writable-change-event' signal emitted from a Settings.
type SettingsSignalWritableChangeEventCallback func(key uint32) bool

/*
ConnectWritableChangeEvent connects the callback to the 'writable-change-event' signal for the Settings.

The returned value represents the connection, and may be passed to DisconnectWritableChangeEvent to remove it.
*/
func (recv *Settings) ConnectWritableChangeEvent(callback SettingsSignalWritableChangeEventCallback) int {
	signalSettingsWritableChangeEventLock.Lock()
	defer signalSettingsWritableChangeEventLock.Unlock()

	signalSettingsWritableChangeEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Settings_signal_connect_writable_change_event(instance, C.gpointer(uintptr(signalSettingsWritableChangeEventId)))

	detail := signalSettingsWritableChangeEventDetail{callback, handlerID}
	signalSettingsWritableChangeEventMap[signalSettingsWritableChangeEventId] = detail

	return signalSettingsWritableChangeEventId
}

/*
DisconnectWritableChangeEvent disconnects a callback from the 'writable-change-event' signal for the Settings.

The connectionID should be a value returned from a call to ConnectWritableChangeEvent.
*/
func (recv *Settings) DisconnectWritableChangeEvent(connectionID int) {
	signalSettingsWritableChangeEventLock.Lock()
	defer signalSettingsWritableChangeEventLock.Unlock()

	detail, exists := signalSettingsWritableChangeEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSettingsWritableChangeEventMap, connectionID)
}

//export settings_writableChangeEventHandler
func settings_writableChangeEventHandler(_ *C.GObject, c_key C.guint, data C.gpointer) C.gboolean {
	signalSettingsWritableChangeEventLock.RLock()
	defer signalSettingsWritableChangeEventLock.RUnlock()

	key := uint32(c_key)

	index := int(uintptr(data))
	callback := signalSettingsWritableChangeEventMap[index].callback
	retGo := callback(key)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalSettingsWritableChangedDetail struct {
	callback  SettingsSignalWritableChangedCallback
	handlerID C.gulong
}

var signalSettingsWritableChangedId int
var signalSettingsWritableChangedMap = make(map[int]signalSettingsWritableChangedDetail)
var signalSettingsWritableChangedLock sync.RWMutex

// SettingsSignalWritableChangedCallback is a callback function for a 'writable-changed' signal emitted from a Settings.
type SettingsSignalWritableChangedCallback func(key string)

/*
ConnectWritableChanged connects the callback to the 'writable-changed' signal for the Settings.

The returned value represents the connection, and may be passed to DisconnectWritableChanged to remove it.
*/
func (recv *Settings) ConnectWritableChanged(callback SettingsSignalWritableChangedCallback) int {
	signalSettingsWritableChangedLock.Lock()
	defer signalSettingsWritableChangedLock.Unlock()

	signalSettingsWritableChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Settings_signal_connect_writable_changed(instance, C.gpointer(uintptr(signalSettingsWritableChangedId)))

	detail := signalSettingsWritableChangedDetail{callback, handlerID}
	signalSettingsWritableChangedMap[signalSettingsWritableChangedId] = detail

	return signalSettingsWritableChangedId
}

/*
DisconnectWritableChanged disconnects a callback from the 'writable-changed' signal for the Settings.

The connectionID should be a value returned from a call to ConnectWritableChanged.
*/
func (recv *Settings) DisconnectWritableChanged(connectionID int) {
	signalSettingsWritableChangedLock.Lock()
	defer signalSettingsWritableChangedLock.Unlock()

	detail, exists := signalSettingsWritableChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSettingsWritableChangedMap, connectionID)
}

//export settings_writableChangedHandler
func settings_writableChangedHandler(_ *C.GObject, c_key *C.gchar, data C.gpointer) {
	signalSettingsWritableChangedLock.RLock()
	defer signalSettingsWritableChangedLock.RUnlock()

	key := C.GoString(c_key)

	index := int(uintptr(data))
	callback := signalSettingsWritableChangedMap[index].callback
	callback(key)
}

// SettingsNew is a wrapper around the C function g_settings_new.
func SettingsNew(schemaId string) *Settings {
	c_schema_id := C.CString(schemaId)
	defer C.free(unsafe.Pointer(c_schema_id))

	retC := C.g_settings_new(c_schema_id)
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SettingsNewFull is a wrapper around the C function g_settings_new_full.
func SettingsNewFull(schema *SettingsSchema, backend *SettingsBackend, path string) *Settings {
	c_schema := (*C.GSettingsSchema)(C.NULL)
	if schema != nil {
		c_schema = (*C.GSettingsSchema)(schema.ToC())
	}

	c_backend := (*C.GSettingsBackend)(C.NULL)
	if backend != nil {
		c_backend = (*C.GSettingsBackend)(backend.ToC())
	}

	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.g_settings_new_full(c_schema, c_backend, c_path)
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SettingsNewWithBackend is a wrapper around the C function g_settings_new_with_backend.
func SettingsNewWithBackend(schemaId string, backend *SettingsBackend) *Settings {
	c_schema_id := C.CString(schemaId)
	defer C.free(unsafe.Pointer(c_schema_id))

	c_backend := (*C.GSettingsBackend)(C.NULL)
	if backend != nil {
		c_backend = (*C.GSettingsBackend)(backend.ToC())
	}

	retC := C.g_settings_new_with_backend(c_schema_id, c_backend)
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SettingsNewWithBackendAndPath is a wrapper around the C function g_settings_new_with_backend_and_path.
func SettingsNewWithBackendAndPath(schemaId string, backend *SettingsBackend, path string) *Settings {
	c_schema_id := C.CString(schemaId)
	defer C.free(unsafe.Pointer(c_schema_id))

	c_backend := (*C.GSettingsBackend)(C.NULL)
	if backend != nil {
		c_backend = (*C.GSettingsBackend)(backend.ToC())
	}

	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.g_settings_new_with_backend_and_path(c_schema_id, c_backend, c_path)
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SettingsNewWithPath is a wrapper around the C function g_settings_new_with_path.
func SettingsNewWithPath(schemaId string, path string) *Settings {
	c_schema_id := C.CString(schemaId)
	defer C.free(unsafe.Pointer(c_schema_id))

	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.g_settings_new_with_path(c_schema_id, c_path)
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SettingsListRelocatableSchemas is a wrapper around the C function g_settings_list_relocatable_schemas.
func SettingsListRelocatableSchemas() []string {
	retC := C.g_settings_list_relocatable_schemas()
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// SettingsListSchemas is a wrapper around the C function g_settings_list_schemas.
func SettingsListSchemas() []string {
	retC := C.g_settings_list_schemas()
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// SettingsSync is a wrapper around the C function g_settings_sync.
func SettingsSync() {
	C.g_settings_sync()

	return
}

// SettingsUnbind is a wrapper around the C function g_settings_unbind.
func SettingsUnbind(object *gobject.Object, property string) {
	c_object := (C.gpointer)(C.NULL)
	if object != nil {
		c_object = (C.gpointer)(object.ToC())
	}

	c_property := C.CString(property)
	defer C.free(unsafe.Pointer(c_property))

	C.g_settings_unbind(c_object, c_property)

	return
}

// Apply is a wrapper around the C function g_settings_apply.
func (recv *Settings) Apply() {
	C.g_settings_apply((*C.GSettings)(recv.native))

	return
}

// Bind is a wrapper around the C function g_settings_bind.
func (recv *Settings) Bind(key string, object *gobject.Object, property string, flags SettingsBindFlags) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_object := (C.gpointer)(C.NULL)
	if object != nil {
		c_object = (C.gpointer)(object.ToC())
	}

	c_property := C.CString(property)
	defer C.free(unsafe.Pointer(c_property))

	c_flags := (C.GSettingsBindFlags)(flags)

	C.g_settings_bind((*C.GSettings)(recv.native), c_key, c_object, c_property, c_flags)

	return
}

// Unsupported : g_settings_bind_with_mapping : unsupported parameter get_mapping : no type generator for SettingsBindGetMapping (GSettingsBindGetMapping) for param get_mapping

// BindWritable is a wrapper around the C function g_settings_bind_writable.
func (recv *Settings) BindWritable(key string, object *gobject.Object, property string, inverted bool) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_object := (C.gpointer)(C.NULL)
	if object != nil {
		c_object = (C.gpointer)(object.ToC())
	}

	c_property := C.CString(property)
	defer C.free(unsafe.Pointer(c_property))

	c_inverted :=
		boolToGboolean(inverted)

	C.g_settings_bind_writable((*C.GSettings)(recv.native), c_key, c_object, c_property, c_inverted)

	return
}

// CreateAction is a wrapper around the C function g_settings_create_action.
func (recv *Settings) CreateAction(key string) *Action {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_create_action((*C.GSettings)(recv.native), c_key)
	retGo := ActionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Delay is a wrapper around the C function g_settings_delay.
func (recv *Settings) Delay() {
	C.g_settings_delay((*C.GSettings)(recv.native))

	return
}

// Get is a wrapper around the C function g_settings_get.
func (recv *Settings) Get(key string, format string, args ...interface{}) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	goFormattedString := fmt.Sprintf(format, args...)
	c_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format))

	C._g_settings_get((*C.GSettings)(recv.native), c_key, c_format)

	return
}

// GetBoolean is a wrapper around the C function g_settings_get_boolean.
func (recv *Settings) GetBoolean(key string) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_boolean((*C.GSettings)(recv.native), c_key)
	retGo := retC == C.TRUE

	return retGo
}

// GetChild is a wrapper around the C function g_settings_get_child.
func (recv *Settings) GetChild(name string) *Settings {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_settings_get_child((*C.GSettings)(recv.native), c_name)
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDouble is a wrapper around the C function g_settings_get_double.
func (recv *Settings) GetDouble(key string) float64 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_double((*C.GSettings)(recv.native), c_key)
	retGo := (float64)(retC)

	return retGo
}

// GetEnum is a wrapper around the C function g_settings_get_enum.
func (recv *Settings) GetEnum(key string) int32 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_enum((*C.GSettings)(recv.native), c_key)
	retGo := (int32)(retC)

	return retGo
}

// GetFlags is a wrapper around the C function g_settings_get_flags.
func (recv *Settings) GetFlags(key string) uint32 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_flags((*C.GSettings)(recv.native), c_key)
	retGo := (uint32)(retC)

	return retGo
}

// GetHasUnapplied is a wrapper around the C function g_settings_get_has_unapplied.
func (recv *Settings) GetHasUnapplied() bool {
	retC := C.g_settings_get_has_unapplied((*C.GSettings)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetInt is a wrapper around the C function g_settings_get_int.
func (recv *Settings) GetInt(key string) int32 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_int((*C.GSettings)(recv.native), c_key)
	retGo := (int32)(retC)

	return retGo
}

// Unsupported : g_settings_get_mapped : unsupported parameter mapping : no type generator for SettingsGetMapping (GSettingsGetMapping) for param mapping

// GetRange is a wrapper around the C function g_settings_get_range.
func (recv *Settings) GetRange(key string) *glib.Variant {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_range((*C.GSettings)(recv.native), c_key)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetString is a wrapper around the C function g_settings_get_string.
func (recv *Settings) GetString(key string) string {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_string((*C.GSettings)(recv.native), c_key)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetStrv is a wrapper around the C function g_settings_get_strv.
func (recv *Settings) GetStrv(key string) []string {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_strv((*C.GSettings)(recv.native), c_key)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// GetUint is a wrapper around the C function g_settings_get_uint.
func (recv *Settings) GetUint(key string) uint32 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_uint((*C.GSettings)(recv.native), c_key)
	retGo := (uint32)(retC)

	return retGo
}

// GetValue is a wrapper around the C function g_settings_get_value.
func (recv *Settings) GetValue(key string) *glib.Variant {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.g_settings_get_value((*C.GSettings)(recv.native), c_key)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IsWritable is a wrapper around the C function g_settings_is_writable.
func (recv *Settings) IsWritable(name string) bool {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_settings_is_writable((*C.GSettings)(recv.native), c_name)
	retGo := retC == C.TRUE

	return retGo
}

// ListChildren is a wrapper around the C function g_settings_list_children.
func (recv *Settings) ListChildren() []string {
	retC := C.g_settings_list_children((*C.GSettings)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// ListKeys is a wrapper around the C function g_settings_list_keys.
func (recv *Settings) ListKeys() []string {
	retC := C.g_settings_list_keys((*C.GSettings)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// RangeCheck is a wrapper around the C function g_settings_range_check.
func (recv *Settings) RangeCheck(key string, value *glib.Variant) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	retC := C.g_settings_range_check((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// Reset is a wrapper around the C function g_settings_reset.
func (recv *Settings) Reset(key string) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	C.g_settings_reset((*C.GSettings)(recv.native), c_key)

	return
}

// Revert is a wrapper around the C function g_settings_revert.
func (recv *Settings) Revert() {
	C.g_settings_revert((*C.GSettings)(recv.native))

	return
}

// Set is a wrapper around the C function g_settings_set.
func (recv *Settings) Set(key string, format string, args ...interface{}) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	goFormattedString := fmt.Sprintf(format, args...)
	c_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format))

	retC := C._g_settings_set((*C.GSettings)(recv.native), c_key, c_format)
	retGo := retC == C.TRUE

	return retGo
}

// SetBoolean is a wrapper around the C function g_settings_set_boolean.
func (recv *Settings) SetBoolean(key string, value bool) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value :=
		boolToGboolean(value)

	retC := C.g_settings_set_boolean((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SetDouble is a wrapper around the C function g_settings_set_double.
func (recv *Settings) SetDouble(key string, value float64) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (C.gdouble)(value)

	retC := C.g_settings_set_double((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SetEnum is a wrapper around the C function g_settings_set_enum.
func (recv *Settings) SetEnum(key string, value int32) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (C.gint)(value)

	retC := C.g_settings_set_enum((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SetFlags is a wrapper around the C function g_settings_set_flags.
func (recv *Settings) SetFlags(key string, value uint32) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (C.guint)(value)

	retC := C.g_settings_set_flags((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SetInt is a wrapper around the C function g_settings_set_int.
func (recv *Settings) SetInt(key string, value int32) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (C.gint)(value)

	retC := C.g_settings_set_int((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SetString is a wrapper around the C function g_settings_set_string.
func (recv *Settings) SetString(key string, value string) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	retC := C.g_settings_set_string((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SetStrv is a wrapper around the C function g_settings_set_strv.
func (recv *Settings) SetStrv(key string, value []string) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value_array := make([]*C.gchar, len(value)+1, len(value)+1)
	for i, item := range value {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_value_array[i] = c
	}
	c_value_array[len(value)] = nil
	c_value_arrayPtr := &c_value_array[0]
	c_value := (**C.gchar)(unsafe.Pointer(c_value_arrayPtr))

	retC := C.g_settings_set_strv((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SetUint is a wrapper around the C function g_settings_set_uint.
func (recv *Settings) SetUint(key string, value uint32) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (C.guint)(value)

	retC := C.g_settings_set_uint((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SetValue is a wrapper around the C function g_settings_set_value.
func (recv *Settings) SetValue(key string, value *glib.Variant) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	retC := C.g_settings_set_value((*C.GSettings)(recv.native), c_key, c_value)
	retGo := retC == C.TRUE

	return retGo
}

// SettingsBackend is a wrapper around the C record GSettingsBackend.
type SettingsBackend struct {
	native *C.GSettingsBackend
	// parent_instance : record
	// Private : priv
}

func SettingsBackendNewFromC(u unsafe.Pointer) *SettingsBackend {
	c := (*C.GSettingsBackend)(u)
	if c == nil {
		return nil
	}

	g := &SettingsBackend{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SettingsBackend) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SettingsBackend) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsBackend with another SettingsBackend, and returns true if they represent the same GObject.
func (recv *SettingsBackend) Equals(other *SettingsBackend) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SettingsBackend) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SettingsBackend.
// Exercise care, as this is a potentially dangerous function if the Object is not a SettingsBackend.
func CastToSettingsBackend(object *gobject.Object) *SettingsBackend {
	return SettingsBackendNewFromC(object.ToC())
}

// g_settings_backend_flatten_tree : unsupported parameter keys : output array param keys
// Blacklisted : g_settings_backend_get_default

// Blacklisted : g_settings_backend_changed

// Blacklisted : g_settings_backend_changed_tree

// Blacklisted : g_settings_backend_keys_changed

// Blacklisted : g_settings_backend_path_changed

// Blacklisted : g_settings_backend_path_writable_changed

// Blacklisted : g_settings_backend_writable_changed

// SimpleAction is a wrapper around the C record GSimpleAction.
type SimpleAction struct {
	native *C.GSimpleAction
}

func SimpleActionNewFromC(u unsafe.Pointer) *SimpleAction {
	c := (*C.GSimpleAction)(u)
	if c == nil {
		return nil
	}

	g := &SimpleAction{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SimpleAction) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SimpleAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleAction with another SimpleAction, and returns true if they represent the same GObject.
func (recv *SimpleAction) Equals(other *SimpleAction) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SimpleAction) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SimpleAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a SimpleAction.
func CastToSimpleAction(object *gobject.Object) *SimpleAction {
	return SimpleActionNewFromC(object.ToC())
}

type signalSimpleActionActivateDetail struct {
	callback  SimpleActionSignalActivateCallback
	handlerID C.gulong
}

var signalSimpleActionActivateId int
var signalSimpleActionActivateMap = make(map[int]signalSimpleActionActivateDetail)
var signalSimpleActionActivateLock sync.RWMutex

// SimpleActionSignalActivateCallback is a callback function for a 'activate' signal emitted from a SimpleAction.
type SimpleActionSignalActivateCallback func(parameter *glib.Variant)

/*
ConnectActivate connects the callback to the 'activate' signal for the SimpleAction.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *SimpleAction) ConnectActivate(callback SimpleActionSignalActivateCallback) int {
	signalSimpleActionActivateLock.Lock()
	defer signalSimpleActionActivateLock.Unlock()

	signalSimpleActionActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.SimpleAction_signal_connect_activate(instance, C.gpointer(uintptr(signalSimpleActionActivateId)))

	detail := signalSimpleActionActivateDetail{callback, handlerID}
	signalSimpleActionActivateMap[signalSimpleActionActivateId] = detail

	return signalSimpleActionActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the SimpleAction.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *SimpleAction) DisconnectActivate(connectionID int) {
	signalSimpleActionActivateLock.Lock()
	defer signalSimpleActionActivateLock.Unlock()

	detail, exists := signalSimpleActionActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSimpleActionActivateMap, connectionID)
}

//export simpleaction_activateHandler
func simpleaction_activateHandler(_ *C.GObject, c_parameter *C.GVariant, data C.gpointer) {
	signalSimpleActionActivateLock.RLock()
	defer signalSimpleActionActivateLock.RUnlock()

	parameter := glib.VariantNewFromC(unsafe.Pointer(c_parameter))

	index := int(uintptr(data))
	callback := signalSimpleActionActivateMap[index].callback
	callback(parameter)
}

type signalSimpleActionChangeStateDetail struct {
	callback  SimpleActionSignalChangeStateCallback
	handlerID C.gulong
}

var signalSimpleActionChangeStateId int
var signalSimpleActionChangeStateMap = make(map[int]signalSimpleActionChangeStateDetail)
var signalSimpleActionChangeStateLock sync.RWMutex

// SimpleActionSignalChangeStateCallback is a callback function for a 'change-state' signal emitted from a SimpleAction.
type SimpleActionSignalChangeStateCallback func(value *glib.Variant)

/*
ConnectChangeState connects the callback to the 'change-state' signal for the SimpleAction.

The returned value represents the connection, and may be passed to DisconnectChangeState to remove it.
*/
func (recv *SimpleAction) ConnectChangeState(callback SimpleActionSignalChangeStateCallback) int {
	signalSimpleActionChangeStateLock.Lock()
	defer signalSimpleActionChangeStateLock.Unlock()

	signalSimpleActionChangeStateId++
	instance := C.gpointer(recv.native)
	handlerID := C.SimpleAction_signal_connect_change_state(instance, C.gpointer(uintptr(signalSimpleActionChangeStateId)))

	detail := signalSimpleActionChangeStateDetail{callback, handlerID}
	signalSimpleActionChangeStateMap[signalSimpleActionChangeStateId] = detail

	return signalSimpleActionChangeStateId
}

/*
DisconnectChangeState disconnects a callback from the 'change-state' signal for the SimpleAction.

The connectionID should be a value returned from a call to ConnectChangeState.
*/
func (recv *SimpleAction) DisconnectChangeState(connectionID int) {
	signalSimpleActionChangeStateLock.Lock()
	defer signalSimpleActionChangeStateLock.Unlock()

	detail, exists := signalSimpleActionChangeStateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSimpleActionChangeStateMap, connectionID)
}

//export simpleaction_changeStateHandler
func simpleaction_changeStateHandler(_ *C.GObject, c_value *C.GVariant, data C.gpointer) {
	signalSimpleActionChangeStateLock.RLock()
	defer signalSimpleActionChangeStateLock.RUnlock()

	value := glib.VariantNewFromC(unsafe.Pointer(c_value))

	index := int(uintptr(data))
	callback := signalSimpleActionChangeStateMap[index].callback
	callback(value)
}

// SimpleActionNew is a wrapper around the C function g_simple_action_new.
func SimpleActionNew(name string, parameterType *glib.VariantType) *SimpleAction {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_parameter_type := (*C.GVariantType)(C.NULL)
	if parameterType != nil {
		c_parameter_type = (*C.GVariantType)(parameterType.ToC())
	}

	retC := C.g_simple_action_new(c_name, c_parameter_type)
	retGo := SimpleActionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SimpleActionNewStateful is a wrapper around the C function g_simple_action_new_stateful.
func SimpleActionNewStateful(name string, parameterType *glib.VariantType, state *glib.Variant) *SimpleAction {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_parameter_type := (*C.GVariantType)(C.NULL)
	if parameterType != nil {
		c_parameter_type = (*C.GVariantType)(parameterType.ToC())
	}

	c_state := (*C.GVariant)(C.NULL)
	if state != nil {
		c_state = (*C.GVariant)(state.ToC())
	}

	retC := C.g_simple_action_new_stateful(c_name, c_parameter_type, c_state)
	retGo := SimpleActionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SetEnabled is a wrapper around the C function g_simple_action_set_enabled.
func (recv *SimpleAction) SetEnabled(enabled bool) {
	c_enabled :=
		boolToGboolean(enabled)

	C.g_simple_action_set_enabled((*C.GSimpleAction)(recv.native), c_enabled)

	return
}

// SetState is a wrapper around the C function g_simple_action_set_state.
func (recv *SimpleAction) SetState(value *glib.Variant) {
	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	C.g_simple_action_set_state((*C.GSimpleAction)(recv.native), c_value)

	return
}

// Action returns the Action interface implemented by SimpleAction
func (recv *SimpleAction) Action() *Action {
	return ActionNewFromC(recv.ToC())
}

// SimpleActionGroup is a wrapper around the C record GSimpleActionGroup.
type SimpleActionGroup struct {
	native *C.GSimpleActionGroup
	// Private : parent_instance
	// Private : priv
}

func SimpleActionGroupNewFromC(u unsafe.Pointer) *SimpleActionGroup {
	c := (*C.GSimpleActionGroup)(u)
	if c == nil {
		return nil
	}

	g := &SimpleActionGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SimpleActionGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SimpleActionGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleActionGroup with another SimpleActionGroup, and returns true if they represent the same GObject.
func (recv *SimpleActionGroup) Equals(other *SimpleActionGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SimpleActionGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SimpleActionGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a SimpleActionGroup.
func CastToSimpleActionGroup(object *gobject.Object) *SimpleActionGroup {
	return SimpleActionGroupNewFromC(object.ToC())
}

// SimpleActionGroupNew is a wrapper around the C function g_simple_action_group_new.
func SimpleActionGroupNew() *SimpleActionGroup {
	retC := C.g_simple_action_group_new()
	retGo := SimpleActionGroupNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Unsupported : g_simple_action_group_add_entries : unsupported parameter entries :

// Insert is a wrapper around the C function g_simple_action_group_insert.
func (recv *SimpleActionGroup) Insert(action *Action) {
	c_action := (*C.GAction)(action.ToC())

	C.g_simple_action_group_insert((*C.GSimpleActionGroup)(recv.native), c_action)

	return
}

// Lookup is a wrapper around the C function g_simple_action_group_lookup.
func (recv *SimpleActionGroup) Lookup(actionName string) *Action {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.g_simple_action_group_lookup((*C.GSimpleActionGroup)(recv.native), c_action_name)
	retGo := ActionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Remove is a wrapper around the C function g_simple_action_group_remove.
func (recv *SimpleActionGroup) Remove(actionName string) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	C.g_simple_action_group_remove((*C.GSimpleActionGroup)(recv.native), c_action_name)

	return
}

// ActionGroup returns the ActionGroup interface implemented by SimpleActionGroup
func (recv *SimpleActionGroup) ActionGroup() *ActionGroup {
	return ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by SimpleActionGroup
func (recv *SimpleActionGroup) ActionMap() *ActionMap {
	return ActionMapNewFromC(recv.ToC())
}

// SimpleAsyncResult is a wrapper around the C record GSimpleAsyncResult.
type SimpleAsyncResult struct {
	native *C.GSimpleAsyncResult
}

func SimpleAsyncResultNewFromC(u unsafe.Pointer) *SimpleAsyncResult {
	c := (*C.GSimpleAsyncResult)(u)
	if c == nil {
		return nil
	}

	g := &SimpleAsyncResult{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SimpleAsyncResult) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SimpleAsyncResult) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleAsyncResult with another SimpleAsyncResult, and returns true if they represent the same GObject.
func (recv *SimpleAsyncResult) Equals(other *SimpleAsyncResult) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SimpleAsyncResult) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SimpleAsyncResult.
// Exercise care, as this is a potentially dangerous function if the Object is not a SimpleAsyncResult.
func CastToSimpleAsyncResult(object *gobject.Object) *SimpleAsyncResult {
	return SimpleAsyncResultNewFromC(object.ToC())
}

// Unsupported : g_simple_async_result_new : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Unsupported : g_simple_async_result_new_error : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Unsupported : g_simple_async_result_new_from_error : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Unsupported : g_simple_async_result_new_take_error : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// SimpleAsyncResultIsValid is a wrapper around the C function g_simple_async_result_is_valid.
func SimpleAsyncResultIsValid(result *AsyncResult, source *gobject.Object, sourceTag uintptr) bool {
	c_result := (*C.GAsyncResult)(result.ToC())

	c_source := (*C.GObject)(C.NULL)
	if source != nil {
		c_source = (*C.GObject)(source.ToC())
	}

	c_source_tag := (C.gpointer)(sourceTag)

	retC := C.g_simple_async_result_is_valid(c_result, c_source, c_source_tag)
	retGo := retC == C.TRUE

	return retGo
}

// Complete is a wrapper around the C function g_simple_async_result_complete.
func (recv *SimpleAsyncResult) Complete() {
	C.g_simple_async_result_complete((*C.GSimpleAsyncResult)(recv.native))

	return
}

// CompleteInIdle is a wrapper around the C function g_simple_async_result_complete_in_idle.
func (recv *SimpleAsyncResult) CompleteInIdle() {
	C.g_simple_async_result_complete_in_idle((*C.GSimpleAsyncResult)(recv.native))

	return
}

// GetOpResGboolean is a wrapper around the C function g_simple_async_result_get_op_res_gboolean.
func (recv *SimpleAsyncResult) GetOpResGboolean() bool {
	retC := C.g_simple_async_result_get_op_res_gboolean((*C.GSimpleAsyncResult)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetOpResGpointer is a wrapper around the C function g_simple_async_result_get_op_res_gpointer.
func (recv *SimpleAsyncResult) GetOpResGpointer() uintptr {
	retC := C.g_simple_async_result_get_op_res_gpointer((*C.GSimpleAsyncResult)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// GetOpResGssize is a wrapper around the C function g_simple_async_result_get_op_res_gssize.
func (recv *SimpleAsyncResult) GetOpResGssize() int64 {
	retC := C.g_simple_async_result_get_op_res_gssize((*C.GSimpleAsyncResult)(recv.native))
	retGo := (int64)(retC)

	return retGo
}

// GetSourceTag is a wrapper around the C function g_simple_async_result_get_source_tag.
func (recv *SimpleAsyncResult) GetSourceTag() uintptr {
	retC := C.g_simple_async_result_get_source_tag((*C.GSimpleAsyncResult)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// PropagateError is a wrapper around the C function g_simple_async_result_propagate_error.
func (recv *SimpleAsyncResult) PropagateError() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_simple_async_result_propagate_error((*C.GSimpleAsyncResult)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_simple_async_result_run_in_thread : unsupported parameter func : no type generator for SimpleAsyncThreadFunc (GSimpleAsyncThreadFunc) for param func

// SetCheckCancellable is a wrapper around the C function g_simple_async_result_set_check_cancellable.
func (recv *SimpleAsyncResult) SetCheckCancellable(checkCancellable *Cancellable) {
	c_check_cancellable := (*C.GCancellable)(C.NULL)
	if checkCancellable != nil {
		c_check_cancellable = (*C.GCancellable)(checkCancellable.ToC())
	}

	C.g_simple_async_result_set_check_cancellable((*C.GSimpleAsyncResult)(recv.native), c_check_cancellable)

	return
}

// SetError is a wrapper around the C function g_simple_async_result_set_error.
func (recv *SimpleAsyncResult) SetError(domain glib.Quark, code int32, format string, args ...interface{}) {
	c_domain := (C.GQuark)(domain)

	c_code := (C.gint)(code)

	goFormattedString := fmt.Sprintf(format, args...)
	c_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format))

	C._g_simple_async_result_set_error((*C.GSimpleAsyncResult)(recv.native), c_domain, c_code, c_format)

	return
}

// Unsupported : g_simple_async_result_set_error_va : unsupported parameter args : no type generator for va_list (va_list) for param args

// SetFromError is a wrapper around the C function g_simple_async_result_set_from_error.
func (recv *SimpleAsyncResult) SetFromError(error_ *glib.Error) {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	C.g_simple_async_result_set_from_error((*C.GSimpleAsyncResult)(recv.native), c_error)

	return
}

// SetHandleCancellation is a wrapper around the C function g_simple_async_result_set_handle_cancellation.
func (recv *SimpleAsyncResult) SetHandleCancellation(handleCancellation bool) {
	c_handle_cancellation :=
		boolToGboolean(handleCancellation)

	C.g_simple_async_result_set_handle_cancellation((*C.GSimpleAsyncResult)(recv.native), c_handle_cancellation)

	return
}

// SetOpResGboolean is a wrapper around the C function g_simple_async_result_set_op_res_gboolean.
func (recv *SimpleAsyncResult) SetOpResGboolean(opRes bool) {
	c_op_res :=
		boolToGboolean(opRes)

	C.g_simple_async_result_set_op_res_gboolean((*C.GSimpleAsyncResult)(recv.native), c_op_res)

	return
}

// Unsupported : g_simple_async_result_set_op_res_gpointer : unsupported parameter destroy_op_res : no type generator for GLib.DestroyNotify (GDestroyNotify) for param destroy_op_res

// SetOpResGssize is a wrapper around the C function g_simple_async_result_set_op_res_gssize.
func (recv *SimpleAsyncResult) SetOpResGssize(opRes int64) {
	c_op_res := (C.gssize)(opRes)

	C.g_simple_async_result_set_op_res_gssize((*C.GSimpleAsyncResult)(recv.native), c_op_res)

	return
}

// TakeError is a wrapper around the C function g_simple_async_result_take_error.
func (recv *SimpleAsyncResult) TakeError(error_ *glib.Error) {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	C.g_simple_async_result_take_error((*C.GSimpleAsyncResult)(recv.native), c_error)

	return
}

// AsyncResult returns the AsyncResult interface implemented by SimpleAsyncResult
func (recv *SimpleAsyncResult) AsyncResult() *AsyncResult {
	return AsyncResultNewFromC(recv.ToC())
}

// SimplePermission is a wrapper around the C record GSimplePermission.
type SimplePermission struct {
	native *C.GSimplePermission
}

func SimplePermissionNewFromC(u unsafe.Pointer) *SimplePermission {
	c := (*C.GSimplePermission)(u)
	if c == nil {
		return nil
	}

	g := &SimplePermission{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SimplePermission) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SimplePermission) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimplePermission with another SimplePermission, and returns true if they represent the same GObject.
func (recv *SimplePermission) Equals(other *SimplePermission) bool {
	return other.ToC() == recv.ToC()
}

// Permission upcasts to *Permission
func (recv *SimplePermission) Permission() *Permission {
	return PermissionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *SimplePermission) Object() *gobject.Object {
	return recv.Permission().Object()
}

// CastToWidget down casts any arbitrary Object to SimplePermission.
// Exercise care, as this is a potentially dangerous function if the Object is not a SimplePermission.
func CastToSimplePermission(object *gobject.Object) *SimplePermission {
	return SimplePermissionNewFromC(object.ToC())
}

// SimplePermissionNew is a wrapper around the C function g_simple_permission_new.
func SimplePermissionNew(allowed bool) *SimplePermission {
	c_allowed :=
		boolToGboolean(allowed)

	retC := C.g_simple_permission_new(c_allowed)
	retGo := SimplePermissionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SimpleProxyResolver is a wrapper around the C record GSimpleProxyResolver.
type SimpleProxyResolver struct {
	native *C.GSimpleProxyResolver
	// parent_instance : record
	// Private : priv
}

func SimpleProxyResolverNewFromC(u unsafe.Pointer) *SimpleProxyResolver {
	c := (*C.GSimpleProxyResolver)(u)
	if c == nil {
		return nil
	}

	g := &SimpleProxyResolver{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SimpleProxyResolver) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SimpleProxyResolver) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleProxyResolver with another SimpleProxyResolver, and returns true if they represent the same GObject.
func (recv *SimpleProxyResolver) Equals(other *SimpleProxyResolver) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SimpleProxyResolver) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SimpleProxyResolver.
// Exercise care, as this is a potentially dangerous function if the Object is not a SimpleProxyResolver.
func CastToSimpleProxyResolver(object *gobject.Object) *SimpleProxyResolver {
	return SimpleProxyResolverNewFromC(object.ToC())
}

// g_simple_proxy_resolver_new : unsupported parameter ignore_hosts : in string with indirection level of 2
// SetDefaultProxy is a wrapper around the C function g_simple_proxy_resolver_set_default_proxy.
func (recv *SimpleProxyResolver) SetDefaultProxy(defaultProxy string) {
	c_default_proxy := C.CString(defaultProxy)
	defer C.free(unsafe.Pointer(c_default_proxy))

	C.g_simple_proxy_resolver_set_default_proxy((*C.GSimpleProxyResolver)(recv.native), c_default_proxy)

	return
}

// Unsupported : g_simple_proxy_resolver_set_ignore_hosts : unsupported parameter ignore_hosts : in string with indirection level of 2

// SetUriProxy is a wrapper around the C function g_simple_proxy_resolver_set_uri_proxy.
func (recv *SimpleProxyResolver) SetUriProxy(uriScheme string, proxy string) {
	c_uri_scheme := C.CString(uriScheme)
	defer C.free(unsafe.Pointer(c_uri_scheme))

	c_proxy := C.CString(proxy)
	defer C.free(unsafe.Pointer(c_proxy))

	C.g_simple_proxy_resolver_set_uri_proxy((*C.GSimpleProxyResolver)(recv.native), c_uri_scheme, c_proxy)

	return
}

// ProxyResolver returns the ProxyResolver interface implemented by SimpleProxyResolver
func (recv *SimpleProxyResolver) ProxyResolver() *ProxyResolver {
	return ProxyResolverNewFromC(recv.ToC())
}

// Socket is a wrapper around the C record GSocket.
type Socket struct {
	native *C.GSocket
	// parent_instance : record
	// priv : record
}

func SocketNewFromC(u unsafe.Pointer) *Socket {
	c := (*C.GSocket)(u)
	if c == nil {
		return nil
	}

	g := &Socket{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Socket) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Socket) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Socket with another Socket, and returns true if they represent the same GObject.
func (recv *Socket) Equals(other *Socket) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Socket) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Socket.
// Exercise care, as this is a potentially dangerous function if the Object is not a Socket.
func CastToSocket(object *gobject.Object) *Socket {
	return SocketNewFromC(object.ToC())
}

// SocketNew is a wrapper around the C function g_socket_new.
func SocketNew(family SocketFamily, type_ SocketType, protocol SocketProtocol) (*Socket, error) {
	c_family := (C.GSocketFamily)(family)

	c_type := (C.GSocketType)(type_)

	c_protocol := (C.GSocketProtocol)(protocol)

	var cThrowableError *C.GError

	retC := C.g_socket_new(c_family, c_type, c_protocol, &cThrowableError)
	retGo := SocketNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SocketNewFromFd is a wrapper around the C function g_socket_new_from_fd.
func SocketNewFromFd(fd int32) (*Socket, error) {
	c_fd := (C.gint)(fd)

	var cThrowableError *C.GError

	retC := C.g_socket_new_from_fd(c_fd, &cThrowableError)
	retGo := SocketNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Accept is a wrapper around the C function g_socket_accept.
func (recv *Socket) Accept(cancellable *Cancellable) (*Socket, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_accept((*C.GSocket)(recv.native), c_cancellable, &cThrowableError)
	retGo := SocketNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Bind is a wrapper around the C function g_socket_bind.
func (recv *Socket) Bind(address *SocketAddress, allowReuse bool) (bool, error) {
	c_address := (*C.GSocketAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GSocketAddress)(address.ToC())
	}

	c_allow_reuse :=
		boolToGboolean(allowReuse)

	var cThrowableError *C.GError

	retC := C.g_socket_bind((*C.GSocket)(recv.native), c_address, c_allow_reuse, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// CheckConnectResult is a wrapper around the C function g_socket_check_connect_result.
func (recv *Socket) CheckConnectResult() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_socket_check_connect_result((*C.GSocket)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Close is a wrapper around the C function g_socket_close.
func (recv *Socket) Close() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_socket_close((*C.GSocket)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ConditionCheck is a wrapper around the C function g_socket_condition_check.
func (recv *Socket) ConditionCheck(condition glib.IOCondition) glib.IOCondition {
	c_condition := (C.GIOCondition)(condition)

	retC := C.g_socket_condition_check((*C.GSocket)(recv.native), c_condition)
	retGo := (glib.IOCondition)(retC)

	return retGo
}

// ConditionTimedWait is a wrapper around the C function g_socket_condition_timed_wait.
func (recv *Socket) ConditionTimedWait(condition glib.IOCondition, timeout int64, cancellable *Cancellable) (bool, error) {
	c_condition := (C.GIOCondition)(condition)

	c_timeout := (C.gint64)(timeout)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_condition_timed_wait((*C.GSocket)(recv.native), c_condition, c_timeout, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ConditionWait is a wrapper around the C function g_socket_condition_wait.
func (recv *Socket) ConditionWait(condition glib.IOCondition, cancellable *Cancellable) (bool, error) {
	c_condition := (C.GIOCondition)(condition)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_condition_wait((*C.GSocket)(recv.native), c_condition, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Connect is a wrapper around the C function g_socket_connect.
func (recv *Socket) Connect(address *SocketAddress, cancellable *Cancellable) (bool, error) {
	c_address := (*C.GSocketAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GSocketAddress)(address.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_connect((*C.GSocket)(recv.native), c_address, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ConnectionFactoryCreateConnection is a wrapper around the C function g_socket_connection_factory_create_connection.
func (recv *Socket) ConnectionFactoryCreateConnection() *SocketConnection {
	retC := C.g_socket_connection_factory_create_connection((*C.GSocket)(recv.native))
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CreateSource is a wrapper around the C function g_socket_create_source.
func (recv *Socket) CreateSource(condition glib.IOCondition, cancellable *Cancellable) *glib.Source {
	c_condition := (C.GIOCondition)(condition)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	retC := C.g_socket_create_source((*C.GSocket)(recv.native), c_condition, c_cancellable)
	retGo := glib.SourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAvailableBytes is a wrapper around the C function g_socket_get_available_bytes.
func (recv *Socket) GetAvailableBytes() int64 {
	retC := C.g_socket_get_available_bytes((*C.GSocket)(recv.native))
	retGo := (int64)(retC)

	return retGo
}

// GetBlocking is a wrapper around the C function g_socket_get_blocking.
func (recv *Socket) GetBlocking() bool {
	retC := C.g_socket_get_blocking((*C.GSocket)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetBroadcast is a wrapper around the C function g_socket_get_broadcast.
func (recv *Socket) GetBroadcast() bool {
	retC := C.g_socket_get_broadcast((*C.GSocket)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetCredentials is a wrapper around the C function g_socket_get_credentials.
func (recv *Socket) GetCredentials() (*Credentials, error) {
	var cThrowableError *C.GError

	retC := C.g_socket_get_credentials((*C.GSocket)(recv.native), &cThrowableError)
	retGo := CredentialsNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetFamily is a wrapper around the C function g_socket_get_family.
func (recv *Socket) GetFamily() SocketFamily {
	retC := C.g_socket_get_family((*C.GSocket)(recv.native))
	retGo := (SocketFamily)(retC)

	return retGo
}

// GetFd is a wrapper around the C function g_socket_get_fd.
func (recv *Socket) GetFd() int32 {
	retC := C.g_socket_get_fd((*C.GSocket)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetKeepalive is a wrapper around the C function g_socket_get_keepalive.
func (recv *Socket) GetKeepalive() bool {
	retC := C.g_socket_get_keepalive((*C.GSocket)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetListenBacklog is a wrapper around the C function g_socket_get_listen_backlog.
func (recv *Socket) GetListenBacklog() int32 {
	retC := C.g_socket_get_listen_backlog((*C.GSocket)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Blacklisted : g_socket_get_local_address

// GetMulticastLoopback is a wrapper around the C function g_socket_get_multicast_loopback.
func (recv *Socket) GetMulticastLoopback() bool {
	retC := C.g_socket_get_multicast_loopback((*C.GSocket)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetMulticastTtl is a wrapper around the C function g_socket_get_multicast_ttl.
func (recv *Socket) GetMulticastTtl() uint32 {
	retC := C.g_socket_get_multicast_ttl((*C.GSocket)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetOption is a wrapper around the C function g_socket_get_option.
func (recv *Socket) GetOption(level int32, optname int32) (bool, int32, error) {
	c_level := (C.gint)(level)

	c_optname := (C.gint)(optname)

	var c_value C.gint

	var cThrowableError *C.GError

	retC := C.g_socket_get_option((*C.GSocket)(recv.native), c_level, c_optname, &c_value, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	value := (int32)(c_value)

	return retGo, value, goError
}

// GetProtocol is a wrapper around the C function g_socket_get_protocol.
func (recv *Socket) GetProtocol() SocketProtocol {
	retC := C.g_socket_get_protocol((*C.GSocket)(recv.native))
	retGo := (SocketProtocol)(retC)

	return retGo
}

// GetRemoteAddress is a wrapper around the C function g_socket_get_remote_address.
func (recv *Socket) GetRemoteAddress() (*SocketAddress, error) {
	var cThrowableError *C.GError

	retC := C.g_socket_get_remote_address((*C.GSocket)(recv.native), &cThrowableError)
	retGo := SocketAddressNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetSocketType is a wrapper around the C function g_socket_get_socket_type.
func (recv *Socket) GetSocketType() SocketType {
	retC := C.g_socket_get_socket_type((*C.GSocket)(recv.native))
	retGo := (SocketType)(retC)

	return retGo
}

// GetTimeout is a wrapper around the C function g_socket_get_timeout.
func (recv *Socket) GetTimeout() uint32 {
	retC := C.g_socket_get_timeout((*C.GSocket)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetTtl is a wrapper around the C function g_socket_get_ttl.
func (recv *Socket) GetTtl() uint32 {
	retC := C.g_socket_get_ttl((*C.GSocket)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// IsClosed is a wrapper around the C function g_socket_is_closed.
func (recv *Socket) IsClosed() bool {
	retC := C.g_socket_is_closed((*C.GSocket)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsConnected is a wrapper around the C function g_socket_is_connected.
func (recv *Socket) IsConnected() bool {
	retC := C.g_socket_is_connected((*C.GSocket)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// JoinMulticastGroup is a wrapper around the C function g_socket_join_multicast_group.
func (recv *Socket) JoinMulticastGroup(group *InetAddress, sourceSpecific bool, iface string) (bool, error) {
	c_group := (*C.GInetAddress)(C.NULL)
	if group != nil {
		c_group = (*C.GInetAddress)(group.ToC())
	}

	c_source_specific :=
		boolToGboolean(sourceSpecific)

	c_iface := C.CString(iface)
	defer C.free(unsafe.Pointer(c_iface))

	var cThrowableError *C.GError

	retC := C.g_socket_join_multicast_group((*C.GSocket)(recv.native), c_group, c_source_specific, c_iface, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LeaveMulticastGroup is a wrapper around the C function g_socket_leave_multicast_group.
func (recv *Socket) LeaveMulticastGroup(group *InetAddress, sourceSpecific bool, iface string) (bool, error) {
	c_group := (*C.GInetAddress)(C.NULL)
	if group != nil {
		c_group = (*C.GInetAddress)(group.ToC())
	}

	c_source_specific :=
		boolToGboolean(sourceSpecific)

	c_iface := C.CString(iface)
	defer C.free(unsafe.Pointer(c_iface))

	var cThrowableError *C.GError

	retC := C.g_socket_leave_multicast_group((*C.GSocket)(recv.native), c_group, c_source_specific, c_iface, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Listen is a wrapper around the C function g_socket_listen.
func (recv *Socket) Listen() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_socket_listen((*C.GSocket)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Receive is a wrapper around the C function g_socket_receive.
func (recv *Socket) Receive(buffer []uint8, cancellable *Cancellable) (int64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (*C.gchar)(unsafe.Pointer(c_buffer_arrayPtr))

	c_size := (C.gsize)(len(buffer))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_receive((*C.GSocket)(recv.native), c_buffer, c_size, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReceiveFrom is a wrapper around the C function g_socket_receive_from.
func (recv *Socket) ReceiveFrom(buffer []uint8, cancellable *Cancellable) (int64, *SocketAddress, error) {
	var c_address *C.GSocketAddress

	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (*C.gchar)(unsafe.Pointer(c_buffer_arrayPtr))

	c_size := (C.gsize)(len(buffer))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_receive_from((*C.GSocket)(recv.native), &c_address, c_buffer, c_size, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	address := SocketAddressNewFromC(unsafe.Pointer(c_address))

	return retGo, address, goError
}

// Unsupported : g_socket_receive_message : unsupported parameter vectors :

// ReceiveWithBlocking is a wrapper around the C function g_socket_receive_with_blocking.
func (recv *Socket) ReceiveWithBlocking(buffer []uint8, blocking bool, cancellable *Cancellable) (int64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (*C.gchar)(unsafe.Pointer(c_buffer_arrayPtr))

	c_size := (C.gsize)(len(buffer))

	c_blocking :=
		boolToGboolean(blocking)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_receive_with_blocking((*C.GSocket)(recv.native), c_buffer, c_size, c_blocking, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Send is a wrapper around the C function g_socket_send.
func (recv *Socket) Send(buffer []uint8, cancellable *Cancellable) (int64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (*C.gchar)(unsafe.Pointer(c_buffer_arrayPtr))

	c_size := (C.gsize)(len(buffer))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_send((*C.GSocket)(recv.native), c_buffer, c_size, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_socket_send_message : unsupported parameter vectors :

// SendTo is a wrapper around the C function g_socket_send_to.
func (recv *Socket) SendTo(address *SocketAddress, buffer []uint8, cancellable *Cancellable) (int64, error) {
	c_address := (*C.GSocketAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GSocketAddress)(address.ToC())
	}

	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (*C.gchar)(unsafe.Pointer(c_buffer_arrayPtr))

	c_size := (C.gsize)(len(buffer))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_send_to((*C.GSocket)(recv.native), c_address, c_buffer, c_size, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SendWithBlocking is a wrapper around the C function g_socket_send_with_blocking.
func (recv *Socket) SendWithBlocking(buffer []uint8, blocking bool, cancellable *Cancellable) (int64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (*C.gchar)(unsafe.Pointer(c_buffer_arrayPtr))

	c_size := (C.gsize)(len(buffer))

	c_blocking :=
		boolToGboolean(blocking)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_send_with_blocking((*C.GSocket)(recv.native), c_buffer, c_size, c_blocking, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetBlocking is a wrapper around the C function g_socket_set_blocking.
func (recv *Socket) SetBlocking(blocking bool) {
	c_blocking :=
		boolToGboolean(blocking)

	C.g_socket_set_blocking((*C.GSocket)(recv.native), c_blocking)

	return
}

// SetBroadcast is a wrapper around the C function g_socket_set_broadcast.
func (recv *Socket) SetBroadcast(broadcast bool) {
	c_broadcast :=
		boolToGboolean(broadcast)

	C.g_socket_set_broadcast((*C.GSocket)(recv.native), c_broadcast)

	return
}

// SetKeepalive is a wrapper around the C function g_socket_set_keepalive.
func (recv *Socket) SetKeepalive(keepalive bool) {
	c_keepalive :=
		boolToGboolean(keepalive)

	C.g_socket_set_keepalive((*C.GSocket)(recv.native), c_keepalive)

	return
}

// SetListenBacklog is a wrapper around the C function g_socket_set_listen_backlog.
func (recv *Socket) SetListenBacklog(backlog int32) {
	c_backlog := (C.gint)(backlog)

	C.g_socket_set_listen_backlog((*C.GSocket)(recv.native), c_backlog)

	return
}

// SetMulticastLoopback is a wrapper around the C function g_socket_set_multicast_loopback.
func (recv *Socket) SetMulticastLoopback(loopback bool) {
	c_loopback :=
		boolToGboolean(loopback)

	C.g_socket_set_multicast_loopback((*C.GSocket)(recv.native), c_loopback)

	return
}

// SetMulticastTtl is a wrapper around the C function g_socket_set_multicast_ttl.
func (recv *Socket) SetMulticastTtl(ttl uint32) {
	c_ttl := (C.guint)(ttl)

	C.g_socket_set_multicast_ttl((*C.GSocket)(recv.native), c_ttl)

	return
}

// SetOption is a wrapper around the C function g_socket_set_option.
func (recv *Socket) SetOption(level int32, optname int32, value int32) (bool, error) {
	c_level := (C.gint)(level)

	c_optname := (C.gint)(optname)

	c_value := (C.gint)(value)

	var cThrowableError *C.GError

	retC := C.g_socket_set_option((*C.GSocket)(recv.native), c_level, c_optname, c_value, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetTimeout is a wrapper around the C function g_socket_set_timeout.
func (recv *Socket) SetTimeout(timeout uint32) {
	c_timeout := (C.guint)(timeout)

	C.g_socket_set_timeout((*C.GSocket)(recv.native), c_timeout)

	return
}

// SetTtl is a wrapper around the C function g_socket_set_ttl.
func (recv *Socket) SetTtl(ttl uint32) {
	c_ttl := (C.guint)(ttl)

	C.g_socket_set_ttl((*C.GSocket)(recv.native), c_ttl)

	return
}

// Shutdown is a wrapper around the C function g_socket_shutdown.
func (recv *Socket) Shutdown(shutdownRead bool, shutdownWrite bool) (bool, error) {
	c_shutdown_read :=
		boolToGboolean(shutdownRead)

	c_shutdown_write :=
		boolToGboolean(shutdownWrite)

	var cThrowableError *C.GError

	retC := C.g_socket_shutdown((*C.GSocket)(recv.native), c_shutdown_read, c_shutdown_write, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SpeaksIpv4 is a wrapper around the C function g_socket_speaks_ipv4.
func (recv *Socket) SpeaksIpv4() bool {
	retC := C.g_socket_speaks_ipv4((*C.GSocket)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Initable returns the Initable interface implemented by Socket
func (recv *Socket) Initable() *Initable {
	return InitableNewFromC(recv.ToC())
}

// SocketAddress is a wrapper around the C record GSocketAddress.
type SocketAddress struct {
	native *C.GSocketAddress
	// parent_instance : record
}

func SocketAddressNewFromC(u unsafe.Pointer) *SocketAddress {
	c := (*C.GSocketAddress)(u)
	if c == nil {
		return nil
	}

	g := &SocketAddress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SocketAddress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SocketAddress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketAddress with another SocketAddress, and returns true if they represent the same GObject.
func (recv *SocketAddress) Equals(other *SocketAddress) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SocketAddress) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SocketAddress.
// Exercise care, as this is a potentially dangerous function if the Object is not a SocketAddress.
func CastToSocketAddress(object *gobject.Object) *SocketAddress {
	return SocketAddressNewFromC(object.ToC())
}

// SocketAddressNewFromNative is a wrapper around the C function g_socket_address_new_from_native.
func SocketAddressNewFromNative(native uintptr, len uint64) *SocketAddress {
	c_native := (C.gpointer)(native)

	c_len := (C.gsize)(len)

	retC := C.g_socket_address_new_from_native(c_native, c_len)
	retGo := SocketAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetFamily is a wrapper around the C function g_socket_address_get_family.
func (recv *SocketAddress) GetFamily() SocketFamily {
	retC := C.g_socket_address_get_family((*C.GSocketAddress)(recv.native))
	retGo := (SocketFamily)(retC)

	return retGo
}

// GetNativeSize is a wrapper around the C function g_socket_address_get_native_size.
func (recv *SocketAddress) GetNativeSize() int64 {
	retC := C.g_socket_address_get_native_size((*C.GSocketAddress)(recv.native))
	retGo := (int64)(retC)

	return retGo
}

// ToNative is a wrapper around the C function g_socket_address_to_native.
func (recv *SocketAddress) ToNative(dest uintptr, destlen uint64) (bool, error) {
	c_dest := (C.gpointer)(dest)

	c_destlen := (C.gsize)(destlen)

	var cThrowableError *C.GError

	retC := C.g_socket_address_to_native((*C.GSocketAddress)(recv.native), c_dest, c_destlen, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SocketConnectable returns the SocketConnectable interface implemented by SocketAddress
func (recv *SocketAddress) SocketConnectable() *SocketConnectable {
	return SocketConnectableNewFromC(recv.ToC())
}

// SocketAddressEnumerator is a wrapper around the C record GSocketAddressEnumerator.
type SocketAddressEnumerator struct {
	native *C.GSocketAddressEnumerator
	// parent_instance : record
}

func SocketAddressEnumeratorNewFromC(u unsafe.Pointer) *SocketAddressEnumerator {
	c := (*C.GSocketAddressEnumerator)(u)
	if c == nil {
		return nil
	}

	g := &SocketAddressEnumerator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SocketAddressEnumerator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SocketAddressEnumerator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketAddressEnumerator with another SocketAddressEnumerator, and returns true if they represent the same GObject.
func (recv *SocketAddressEnumerator) Equals(other *SocketAddressEnumerator) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SocketAddressEnumerator) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SocketAddressEnumerator.
// Exercise care, as this is a potentially dangerous function if the Object is not a SocketAddressEnumerator.
func CastToSocketAddressEnumerator(object *gobject.Object) *SocketAddressEnumerator {
	return SocketAddressEnumeratorNewFromC(object.ToC())
}

// Next is a wrapper around the C function g_socket_address_enumerator_next.
func (recv *SocketAddressEnumerator) Next(cancellable *Cancellable) (*SocketAddress, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_address_enumerator_next((*C.GSocketAddressEnumerator)(recv.native), c_cancellable, &cThrowableError)
	retGo := SocketAddressNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_socket_address_enumerator_next_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// NextFinish is a wrapper around the C function g_socket_address_enumerator_next_finish.
func (recv *SocketAddressEnumerator) NextFinish(result *AsyncResult) (*SocketAddress, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_socket_address_enumerator_next_finish((*C.GSocketAddressEnumerator)(recv.native), c_result, &cThrowableError)
	retGo := SocketAddressNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SocketClient is a wrapper around the C record GSocketClient.
type SocketClient struct {
	native *C.GSocketClient
	// parent_instance : record
	// priv : record
}

func SocketClientNewFromC(u unsafe.Pointer) *SocketClient {
	c := (*C.GSocketClient)(u)
	if c == nil {
		return nil
	}

	g := &SocketClient{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SocketClient) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SocketClient) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketClient with another SocketClient, and returns true if they represent the same GObject.
func (recv *SocketClient) Equals(other *SocketClient) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SocketClient) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SocketClient.
// Exercise care, as this is a potentially dangerous function if the Object is not a SocketClient.
func CastToSocketClient(object *gobject.Object) *SocketClient {
	return SocketClientNewFromC(object.ToC())
}

type signalSocketClientEventDetail struct {
	callback  SocketClientSignalEventCallback
	handlerID C.gulong
}

var signalSocketClientEventId int
var signalSocketClientEventMap = make(map[int]signalSocketClientEventDetail)
var signalSocketClientEventLock sync.RWMutex

// SocketClientSignalEventCallback is a callback function for a 'event' signal emitted from a SocketClient.
type SocketClientSignalEventCallback func(event SocketClientEvent, connectable *SocketConnectable, connection *IOStream)

/*
ConnectEvent connects the callback to the 'event' signal for the SocketClient.

The returned value represents the connection, and may be passed to DisconnectEvent to remove it.
*/
func (recv *SocketClient) ConnectEvent(callback SocketClientSignalEventCallback) int {
	signalSocketClientEventLock.Lock()
	defer signalSocketClientEventLock.Unlock()

	signalSocketClientEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.SocketClient_signal_connect_event(instance, C.gpointer(uintptr(signalSocketClientEventId)))

	detail := signalSocketClientEventDetail{callback, handlerID}
	signalSocketClientEventMap[signalSocketClientEventId] = detail

	return signalSocketClientEventId
}

/*
DisconnectEvent disconnects a callback from the 'event' signal for the SocketClient.

The connectionID should be a value returned from a call to ConnectEvent.
*/
func (recv *SocketClient) DisconnectEvent(connectionID int) {
	signalSocketClientEventLock.Lock()
	defer signalSocketClientEventLock.Unlock()

	detail, exists := signalSocketClientEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSocketClientEventMap, connectionID)
}

//export socketclient_eventHandler
func socketclient_eventHandler(_ *C.GObject, c_event C.GSocketClientEvent, c_connectable *C.GSocketConnectable, c_connection *C.GIOStream, data C.gpointer) {
	signalSocketClientEventLock.RLock()
	defer signalSocketClientEventLock.RUnlock()

	event := SocketClientEvent(c_event)

	connectable := SocketConnectableNewFromC(unsafe.Pointer(c_connectable))

	connection := IOStreamNewFromC(unsafe.Pointer(c_connection))

	index := int(uintptr(data))
	callback := signalSocketClientEventMap[index].callback
	callback(event, connectable, connection)
}

// SocketClientNew is a wrapper around the C function g_socket_client_new.
func SocketClientNew() *SocketClient {
	retC := C.g_socket_client_new()
	retGo := SocketClientNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddApplicationProxy is a wrapper around the C function g_socket_client_add_application_proxy.
func (recv *SocketClient) AddApplicationProxy(protocol string) {
	c_protocol := C.CString(protocol)
	defer C.free(unsafe.Pointer(c_protocol))

	C.g_socket_client_add_application_proxy((*C.GSocketClient)(recv.native), c_protocol)

	return
}

// Connect is a wrapper around the C function g_socket_client_connect.
func (recv *SocketClient) Connect(connectable *SocketConnectable, cancellable *Cancellable) (*SocketConnection, error) {
	c_connectable := (*C.GSocketConnectable)(connectable.ToC())

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_client_connect((*C.GSocketClient)(recv.native), c_connectable, c_cancellable, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_socket_client_connect_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ConnectFinish is a wrapper around the C function g_socket_client_connect_finish.
func (recv *SocketClient) ConnectFinish(result *AsyncResult) (*SocketConnection, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_socket_client_connect_finish((*C.GSocketClient)(recv.native), c_result, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ConnectToHost is a wrapper around the C function g_socket_client_connect_to_host.
func (recv *SocketClient) ConnectToHost(hostAndPort string, defaultPort uint16, cancellable *Cancellable) (*SocketConnection, error) {
	c_host_and_port := C.CString(hostAndPort)
	defer C.free(unsafe.Pointer(c_host_and_port))

	c_default_port := (C.guint16)(defaultPort)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_client_connect_to_host((*C.GSocketClient)(recv.native), c_host_and_port, c_default_port, c_cancellable, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_socket_client_connect_to_host_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ConnectToHostFinish is a wrapper around the C function g_socket_client_connect_to_host_finish.
func (recv *SocketClient) ConnectToHostFinish(result *AsyncResult) (*SocketConnection, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_socket_client_connect_to_host_finish((*C.GSocketClient)(recv.native), c_result, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ConnectToService is a wrapper around the C function g_socket_client_connect_to_service.
func (recv *SocketClient) ConnectToService(domain string, service string, cancellable *Cancellable) (*SocketConnection, error) {
	c_domain := C.CString(domain)
	defer C.free(unsafe.Pointer(c_domain))

	c_service := C.CString(service)
	defer C.free(unsafe.Pointer(c_service))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_client_connect_to_service((*C.GSocketClient)(recv.native), c_domain, c_service, c_cancellable, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_socket_client_connect_to_service_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ConnectToServiceFinish is a wrapper around the C function g_socket_client_connect_to_service_finish.
func (recv *SocketClient) ConnectToServiceFinish(result *AsyncResult) (*SocketConnection, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_socket_client_connect_to_service_finish((*C.GSocketClient)(recv.native), c_result, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ConnectToUri is a wrapper around the C function g_socket_client_connect_to_uri.
func (recv *SocketClient) ConnectToUri(uri string, defaultPort uint16, cancellable *Cancellable) (*SocketConnection, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	c_default_port := (C.guint16)(defaultPort)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_client_connect_to_uri((*C.GSocketClient)(recv.native), c_uri, c_default_port, c_cancellable, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_socket_client_connect_to_uri_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ConnectToUriFinish is a wrapper around the C function g_socket_client_connect_to_uri_finish.
func (recv *SocketClient) ConnectToUriFinish(result *AsyncResult) (*SocketConnection, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_socket_client_connect_to_uri_finish((*C.GSocketClient)(recv.native), c_result, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetEnableProxy is a wrapper around the C function g_socket_client_get_enable_proxy.
func (recv *SocketClient) GetEnableProxy() bool {
	retC := C.g_socket_client_get_enable_proxy((*C.GSocketClient)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetFamily is a wrapper around the C function g_socket_client_get_family.
func (recv *SocketClient) GetFamily() SocketFamily {
	retC := C.g_socket_client_get_family((*C.GSocketClient)(recv.native))
	retGo := (SocketFamily)(retC)

	return retGo
}

// GetLocalAddress is a wrapper around the C function g_socket_client_get_local_address.
func (recv *SocketClient) GetLocalAddress() *SocketAddress {
	retC := C.g_socket_client_get_local_address((*C.GSocketClient)(recv.native))
	retGo := SocketAddressNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetProtocol is a wrapper around the C function g_socket_client_get_protocol.
func (recv *SocketClient) GetProtocol() SocketProtocol {
	retC := C.g_socket_client_get_protocol((*C.GSocketClient)(recv.native))
	retGo := (SocketProtocol)(retC)

	return retGo
}

// GetProxyResolver is a wrapper around the C function g_socket_client_get_proxy_resolver.
func (recv *SocketClient) GetProxyResolver() *ProxyResolver {
	retC := C.g_socket_client_get_proxy_resolver((*C.GSocketClient)(recv.native))
	retGo := ProxyResolverNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSocketType is a wrapper around the C function g_socket_client_get_socket_type.
func (recv *SocketClient) GetSocketType() SocketType {
	retC := C.g_socket_client_get_socket_type((*C.GSocketClient)(recv.native))
	retGo := (SocketType)(retC)

	return retGo
}

// GetTimeout is a wrapper around the C function g_socket_client_get_timeout.
func (recv *SocketClient) GetTimeout() uint32 {
	retC := C.g_socket_client_get_timeout((*C.GSocketClient)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetTls is a wrapper around the C function g_socket_client_get_tls.
func (recv *SocketClient) GetTls() bool {
	retC := C.g_socket_client_get_tls((*C.GSocketClient)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTlsValidationFlags is a wrapper around the C function g_socket_client_get_tls_validation_flags.
func (recv *SocketClient) GetTlsValidationFlags() TlsCertificateFlags {
	retC := C.g_socket_client_get_tls_validation_flags((*C.GSocketClient)(recv.native))
	retGo := (TlsCertificateFlags)(retC)

	return retGo
}

// SetEnableProxy is a wrapper around the C function g_socket_client_set_enable_proxy.
func (recv *SocketClient) SetEnableProxy(enable bool) {
	c_enable :=
		boolToGboolean(enable)

	C.g_socket_client_set_enable_proxy((*C.GSocketClient)(recv.native), c_enable)

	return
}

// SetFamily is a wrapper around the C function g_socket_client_set_family.
func (recv *SocketClient) SetFamily(family SocketFamily) {
	c_family := (C.GSocketFamily)(family)

	C.g_socket_client_set_family((*C.GSocketClient)(recv.native), c_family)

	return
}

// SetLocalAddress is a wrapper around the C function g_socket_client_set_local_address.
func (recv *SocketClient) SetLocalAddress(address *SocketAddress) {
	c_address := (*C.GSocketAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GSocketAddress)(address.ToC())
	}

	C.g_socket_client_set_local_address((*C.GSocketClient)(recv.native), c_address)

	return
}

// SetProtocol is a wrapper around the C function g_socket_client_set_protocol.
func (recv *SocketClient) SetProtocol(protocol SocketProtocol) {
	c_protocol := (C.GSocketProtocol)(protocol)

	C.g_socket_client_set_protocol((*C.GSocketClient)(recv.native), c_protocol)

	return
}

// SetProxyResolver is a wrapper around the C function g_socket_client_set_proxy_resolver.
func (recv *SocketClient) SetProxyResolver(proxyResolver *ProxyResolver) {
	c_proxy_resolver := (*C.GProxyResolver)(proxyResolver.ToC())

	C.g_socket_client_set_proxy_resolver((*C.GSocketClient)(recv.native), c_proxy_resolver)

	return
}

// SetSocketType is a wrapper around the C function g_socket_client_set_socket_type.
func (recv *SocketClient) SetSocketType(type_ SocketType) {
	c_type := (C.GSocketType)(type_)

	C.g_socket_client_set_socket_type((*C.GSocketClient)(recv.native), c_type)

	return
}

// SetTimeout is a wrapper around the C function g_socket_client_set_timeout.
func (recv *SocketClient) SetTimeout(timeout uint32) {
	c_timeout := (C.guint)(timeout)

	C.g_socket_client_set_timeout((*C.GSocketClient)(recv.native), c_timeout)

	return
}

// SetTls is a wrapper around the C function g_socket_client_set_tls.
func (recv *SocketClient) SetTls(tls bool) {
	c_tls :=
		boolToGboolean(tls)

	C.g_socket_client_set_tls((*C.GSocketClient)(recv.native), c_tls)

	return
}

// SetTlsValidationFlags is a wrapper around the C function g_socket_client_set_tls_validation_flags.
func (recv *SocketClient) SetTlsValidationFlags(flags TlsCertificateFlags) {
	c_flags := (C.GTlsCertificateFlags)(flags)

	C.g_socket_client_set_tls_validation_flags((*C.GSocketClient)(recv.native), c_flags)

	return
}

// SocketConnection is a wrapper around the C record GSocketConnection.
type SocketConnection struct {
	native *C.GSocketConnection
	// parent_instance : record
	// priv : record
}

func SocketConnectionNewFromC(u unsafe.Pointer) *SocketConnection {
	c := (*C.GSocketConnection)(u)
	if c == nil {
		return nil
	}

	g := &SocketConnection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SocketConnection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SocketConnection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketConnection with another SocketConnection, and returns true if they represent the same GObject.
func (recv *SocketConnection) Equals(other *SocketConnection) bool {
	return other.ToC() == recv.ToC()
}

// IOStream upcasts to *IOStream
func (recv *SocketConnection) IOStream() *IOStream {
	return IOStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *SocketConnection) Object() *gobject.Object {
	return recv.IOStream().Object()
}

// CastToWidget down casts any arbitrary Object to SocketConnection.
// Exercise care, as this is a potentially dangerous function if the Object is not a SocketConnection.
func CastToSocketConnection(object *gobject.Object) *SocketConnection {
	return SocketConnectionNewFromC(object.ToC())
}

// SocketConnectionFactoryLookupType is a wrapper around the C function g_socket_connection_factory_lookup_type.
func SocketConnectionFactoryLookupType(family SocketFamily, type_ SocketType, protocolId int32) gobject.Type {
	c_family := (C.GSocketFamily)(family)

	c_type := (C.GSocketType)(type_)

	c_protocol_id := (C.gint)(protocolId)

	retC := C.g_socket_connection_factory_lookup_type(c_family, c_type, c_protocol_id)
	retGo := (gobject.Type)(retC)

	return retGo
}

// SocketConnectionFactoryRegisterType is a wrapper around the C function g_socket_connection_factory_register_type.
func SocketConnectionFactoryRegisterType(gType gobject.Type, family SocketFamily, type_ SocketType, protocol int32) {
	c_g_type := (C.GType)(gType)

	c_family := (C.GSocketFamily)(family)

	c_type := (C.GSocketType)(type_)

	c_protocol := (C.gint)(protocol)

	C.g_socket_connection_factory_register_type(c_g_type, c_family, c_type, c_protocol)

	return
}

// Connect is a wrapper around the C function g_socket_connection_connect.
func (recv *SocketConnection) Connect(address *SocketAddress, cancellable *Cancellable) (bool, error) {
	c_address := (*C.GSocketAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GSocketAddress)(address.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_connection_connect((*C.GSocketConnection)(recv.native), c_address, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_socket_connection_connect_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ConnectFinish is a wrapper around the C function g_socket_connection_connect_finish.
func (recv *SocketConnection) ConnectFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_socket_connection_connect_finish((*C.GSocketConnection)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetLocalAddress is a wrapper around the C function g_socket_connection_get_local_address.
func (recv *SocketConnection) GetLocalAddress() (*SocketAddress, error) {
	var cThrowableError *C.GError

	retC := C.g_socket_connection_get_local_address((*C.GSocketConnection)(recv.native), &cThrowableError)
	retGo := SocketAddressNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetRemoteAddress is a wrapper around the C function g_socket_connection_get_remote_address.
func (recv *SocketConnection) GetRemoteAddress() (*SocketAddress, error) {
	var cThrowableError *C.GError

	retC := C.g_socket_connection_get_remote_address((*C.GSocketConnection)(recv.native), &cThrowableError)
	retGo := SocketAddressNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetSocket is a wrapper around the C function g_socket_connection_get_socket.
func (recv *SocketConnection) GetSocket() *Socket {
	retC := C.g_socket_connection_get_socket((*C.GSocketConnection)(recv.native))
	retGo := SocketNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IsConnected is a wrapper around the C function g_socket_connection_is_connected.
func (recv *SocketConnection) IsConnected() bool {
	retC := C.g_socket_connection_is_connected((*C.GSocketConnection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SocketControlMessage is a wrapper around the C record GSocketControlMessage.
type SocketControlMessage struct {
	native *C.GSocketControlMessage
	// parent_instance : record
	// priv : record
}

func SocketControlMessageNewFromC(u unsafe.Pointer) *SocketControlMessage {
	c := (*C.GSocketControlMessage)(u)
	if c == nil {
		return nil
	}

	g := &SocketControlMessage{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SocketControlMessage) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SocketControlMessage) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketControlMessage with another SocketControlMessage, and returns true if they represent the same GObject.
func (recv *SocketControlMessage) Equals(other *SocketControlMessage) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SocketControlMessage) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SocketControlMessage.
// Exercise care, as this is a potentially dangerous function if the Object is not a SocketControlMessage.
func CastToSocketControlMessage(object *gobject.Object) *SocketControlMessage {
	return SocketControlMessageNewFromC(object.ToC())
}

// SocketControlMessageDeserialize is a wrapper around the C function g_socket_control_message_deserialize.
func SocketControlMessageDeserialize(level int32, type_ int32, data []uint8) *SocketControlMessage {
	c_level := (C.int)(level)

	c_type := (C.int)(type_)

	c_size := (C.gsize)(len(data))

	c_data_array := make([]C.guint8, len(data)+1, len(data)+1)
	for i, item := range data {
		c := (C.guint8)(item)
		c_data_array[i] = c
	}
	c_data_array[len(data)] = 0
	c_data_arrayPtr := &c_data_array[0]
	c_data := (C.gpointer)(unsafe.Pointer(c_data_arrayPtr))

	retC := C.g_socket_control_message_deserialize(c_level, c_type, c_size, c_data)
	retGo := SocketControlMessageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLevel is a wrapper around the C function g_socket_control_message_get_level.
func (recv *SocketControlMessage) GetLevel() int32 {
	retC := C.g_socket_control_message_get_level((*C.GSocketControlMessage)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMsgType is a wrapper around the C function g_socket_control_message_get_msg_type.
func (recv *SocketControlMessage) GetMsgType() int32 {
	retC := C.g_socket_control_message_get_msg_type((*C.GSocketControlMessage)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetSize is a wrapper around the C function g_socket_control_message_get_size.
func (recv *SocketControlMessage) GetSize() uint64 {
	retC := C.g_socket_control_message_get_size((*C.GSocketControlMessage)(recv.native))
	retGo := (uint64)(retC)

	return retGo
}

// Serialize is a wrapper around the C function g_socket_control_message_serialize.
func (recv *SocketControlMessage) Serialize(data uintptr) {
	c_data := (C.gpointer)(data)

	C.g_socket_control_message_serialize((*C.GSocketControlMessage)(recv.native), c_data)

	return
}

// SocketListener is a wrapper around the C record GSocketListener.
type SocketListener struct {
	native *C.GSocketListener
	// parent_instance : record
	// priv : record
}

func SocketListenerNewFromC(u unsafe.Pointer) *SocketListener {
	c := (*C.GSocketListener)(u)
	if c == nil {
		return nil
	}

	g := &SocketListener{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SocketListener) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SocketListener) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketListener with another SocketListener, and returns true if they represent the same GObject.
func (recv *SocketListener) Equals(other *SocketListener) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SocketListener) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SocketListener.
// Exercise care, as this is a potentially dangerous function if the Object is not a SocketListener.
func CastToSocketListener(object *gobject.Object) *SocketListener {
	return SocketListenerNewFromC(object.ToC())
}

// SocketListenerNew is a wrapper around the C function g_socket_listener_new.
func SocketListenerNew() *SocketListener {
	retC := C.g_socket_listener_new()
	retGo := SocketListenerNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Accept is a wrapper around the C function g_socket_listener_accept.
func (recv *SocketListener) Accept(cancellable *Cancellable) (*SocketConnection, *gobject.Object, error) {
	var c_source_object *C.GObject

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_listener_accept((*C.GSocketListener)(recv.native), &c_source_object, c_cancellable, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	sourceObject := gobject.ObjectNewFromC(unsafe.Pointer(c_source_object))

	return retGo, sourceObject, goError
}

// Unsupported : g_socket_listener_accept_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// AcceptFinish is a wrapper around the C function g_socket_listener_accept_finish.
func (recv *SocketListener) AcceptFinish(result *AsyncResult) (*SocketConnection, *gobject.Object, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var c_source_object *C.GObject

	var cThrowableError *C.GError

	retC := C.g_socket_listener_accept_finish((*C.GSocketListener)(recv.native), c_result, &c_source_object, &cThrowableError)
	retGo := SocketConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	sourceObject := gobject.ObjectNewFromC(unsafe.Pointer(c_source_object))

	return retGo, sourceObject, goError
}

// AcceptSocket is a wrapper around the C function g_socket_listener_accept_socket.
func (recv *SocketListener) AcceptSocket(cancellable *Cancellable) (*Socket, *gobject.Object, error) {
	var c_source_object *C.GObject

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_listener_accept_socket((*C.GSocketListener)(recv.native), &c_source_object, c_cancellable, &cThrowableError)
	retGo := SocketNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	sourceObject := gobject.ObjectNewFromC(unsafe.Pointer(c_source_object))

	return retGo, sourceObject, goError
}

// Unsupported : g_socket_listener_accept_socket_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// AcceptSocketFinish is a wrapper around the C function g_socket_listener_accept_socket_finish.
func (recv *SocketListener) AcceptSocketFinish(result *AsyncResult) (*Socket, *gobject.Object, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var c_source_object *C.GObject

	var cThrowableError *C.GError

	retC := C.g_socket_listener_accept_socket_finish((*C.GSocketListener)(recv.native), c_result, &c_source_object, &cThrowableError)
	retGo := SocketNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	sourceObject := gobject.ObjectNewFromC(unsafe.Pointer(c_source_object))

	return retGo, sourceObject, goError
}

// AddAddress is a wrapper around the C function g_socket_listener_add_address.
func (recv *SocketListener) AddAddress(address *SocketAddress, type_ SocketType, protocol SocketProtocol, sourceObject *gobject.Object) (bool, *SocketAddress, error) {
	c_address := (*C.GSocketAddress)(C.NULL)
	if address != nil {
		c_address = (*C.GSocketAddress)(address.ToC())
	}

	c_type := (C.GSocketType)(type_)

	c_protocol := (C.GSocketProtocol)(protocol)

	c_source_object := (*C.GObject)(C.NULL)
	if sourceObject != nil {
		c_source_object = (*C.GObject)(sourceObject.ToC())
	}

	var c_effective_address *C.GSocketAddress

	var cThrowableError *C.GError

	retC := C.g_socket_listener_add_address((*C.GSocketListener)(recv.native), c_address, c_type, c_protocol, c_source_object, &c_effective_address, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	effectiveAddress := SocketAddressNewFromC(unsafe.Pointer(c_effective_address))

	return retGo, effectiveAddress, goError
}

// AddAnyInetPort is a wrapper around the C function g_socket_listener_add_any_inet_port.
func (recv *SocketListener) AddAnyInetPort(sourceObject *gobject.Object) (uint16, error) {
	c_source_object := (*C.GObject)(C.NULL)
	if sourceObject != nil {
		c_source_object = (*C.GObject)(sourceObject.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_listener_add_any_inet_port((*C.GSocketListener)(recv.native), c_source_object, &cThrowableError)
	retGo := (uint16)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// AddInetPort is a wrapper around the C function g_socket_listener_add_inet_port.
func (recv *SocketListener) AddInetPort(port uint16, sourceObject *gobject.Object) (bool, error) {
	c_port := (C.guint16)(port)

	c_source_object := (*C.GObject)(C.NULL)
	if sourceObject != nil {
		c_source_object = (*C.GObject)(sourceObject.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_listener_add_inet_port((*C.GSocketListener)(recv.native), c_port, c_source_object, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// AddSocket is a wrapper around the C function g_socket_listener_add_socket.
func (recv *SocketListener) AddSocket(socket *Socket, sourceObject *gobject.Object) (bool, error) {
	c_socket := (*C.GSocket)(C.NULL)
	if socket != nil {
		c_socket = (*C.GSocket)(socket.ToC())
	}

	c_source_object := (*C.GObject)(C.NULL)
	if sourceObject != nil {
		c_source_object = (*C.GObject)(sourceObject.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_socket_listener_add_socket((*C.GSocketListener)(recv.native), c_socket, c_source_object, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Close is a wrapper around the C function g_socket_listener_close.
func (recv *SocketListener) Close() {
	C.g_socket_listener_close((*C.GSocketListener)(recv.native))

	return
}

// SetBacklog is a wrapper around the C function g_socket_listener_set_backlog.
func (recv *SocketListener) SetBacklog(listenBacklog int32) {
	c_listen_backlog := (C.int)(listenBacklog)

	C.g_socket_listener_set_backlog((*C.GSocketListener)(recv.native), c_listen_backlog)

	return
}

// SocketService is a wrapper around the C record GSocketService.
type SocketService struct {
	native *C.GSocketService
	// parent_instance : record
	// priv : record
}

func SocketServiceNewFromC(u unsafe.Pointer) *SocketService {
	c := (*C.GSocketService)(u)
	if c == nil {
		return nil
	}

	g := &SocketService{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SocketService) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SocketService) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketService with another SocketService, and returns true if they represent the same GObject.
func (recv *SocketService) Equals(other *SocketService) bool {
	return other.ToC() == recv.ToC()
}

// SocketListener upcasts to *SocketListener
func (recv *SocketService) SocketListener() *SocketListener {
	return SocketListenerNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *SocketService) Object() *gobject.Object {
	return recv.SocketListener().Object()
}

// CastToWidget down casts any arbitrary Object to SocketService.
// Exercise care, as this is a potentially dangerous function if the Object is not a SocketService.
func CastToSocketService(object *gobject.Object) *SocketService {
	return SocketServiceNewFromC(object.ToC())
}

type signalSocketServiceIncomingDetail struct {
	callback  SocketServiceSignalIncomingCallback
	handlerID C.gulong
}

var signalSocketServiceIncomingId int
var signalSocketServiceIncomingMap = make(map[int]signalSocketServiceIncomingDetail)
var signalSocketServiceIncomingLock sync.RWMutex

// SocketServiceSignalIncomingCallback is a callback function for a 'incoming' signal emitted from a SocketService.
type SocketServiceSignalIncomingCallback func(connection *SocketConnection, sourceObject *gobject.Object) bool

/*
ConnectIncoming connects the callback to the 'incoming' signal for the SocketService.

The returned value represents the connection, and may be passed to DisconnectIncoming to remove it.
*/
func (recv *SocketService) ConnectIncoming(callback SocketServiceSignalIncomingCallback) int {
	signalSocketServiceIncomingLock.Lock()
	defer signalSocketServiceIncomingLock.Unlock()

	signalSocketServiceIncomingId++
	instance := C.gpointer(recv.native)
	handlerID := C.SocketService_signal_connect_incoming(instance, C.gpointer(uintptr(signalSocketServiceIncomingId)))

	detail := signalSocketServiceIncomingDetail{callback, handlerID}
	signalSocketServiceIncomingMap[signalSocketServiceIncomingId] = detail

	return signalSocketServiceIncomingId
}

/*
DisconnectIncoming disconnects a callback from the 'incoming' signal for the SocketService.

The connectionID should be a value returned from a call to ConnectIncoming.
*/
func (recv *SocketService) DisconnectIncoming(connectionID int) {
	signalSocketServiceIncomingLock.Lock()
	defer signalSocketServiceIncomingLock.Unlock()

	detail, exists := signalSocketServiceIncomingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSocketServiceIncomingMap, connectionID)
}

//export socketservice_incomingHandler
func socketservice_incomingHandler(_ *C.GObject, c_connection *C.GSocketConnection, c_source_object *C.GObject, data C.gpointer) C.gboolean {
	signalSocketServiceIncomingLock.RLock()
	defer signalSocketServiceIncomingLock.RUnlock()

	connection := SocketConnectionNewFromC(unsafe.Pointer(c_connection))

	sourceObject := gobject.ObjectNewFromC(unsafe.Pointer(c_source_object))

	index := int(uintptr(data))
	callback := signalSocketServiceIncomingMap[index].callback
	retGo := callback(connection, sourceObject)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// SocketServiceNew is a wrapper around the C function g_socket_service_new.
func SocketServiceNew() *SocketService {
	retC := C.g_socket_service_new()
	retGo := SocketServiceNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// IsActive is a wrapper around the C function g_socket_service_is_active.
func (recv *SocketService) IsActive() bool {
	retC := C.g_socket_service_is_active((*C.GSocketService)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Start is a wrapper around the C function g_socket_service_start.
func (recv *SocketService) Start() {
	C.g_socket_service_start((*C.GSocketService)(recv.native))

	return
}

// Stop is a wrapper around the C function g_socket_service_stop.
func (recv *SocketService) Stop() {
	C.g_socket_service_stop((*C.GSocketService)(recv.native))

	return
}

// Task is a wrapper around the C record GTask.
type Task struct {
	native *C.GTask
}

func TaskNewFromC(u unsafe.Pointer) *Task {
	c := (*C.GTask)(u)
	if c == nil {
		return nil
	}

	g := &Task{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Task) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Task) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Task with another Task, and returns true if they represent the same GObject.
func (recv *Task) Equals(other *Task) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Task) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Task.
// Exercise care, as this is a potentially dangerous function if the Object is not a Task.
func CastToTask(object *gobject.Object) *Task {
	return TaskNewFromC(object.ToC())
}

// Unsupported : g_task_new : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// TaskIsValid is a wrapper around the C function g_task_is_valid.
func TaskIsValid(result *AsyncResult, sourceObject *gobject.Object) bool {
	c_result := (C.gpointer)(result.ToC())

	c_source_object := (C.gpointer)(C.NULL)
	if sourceObject != nil {
		c_source_object = (C.gpointer)(sourceObject.ToC())
	}

	retC := C.g_task_is_valid(c_result, c_source_object)
	retGo := retC == C.TRUE

	return retGo
}

// g_task_report_error : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback
// g_task_report_new_error : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback
// Unsupported : g_task_attach_source : unsupported parameter callback : no type generator for GLib.SourceFunc (GSourceFunc) for param callback

// GetCancellable is a wrapper around the C function g_task_get_cancellable.
func (recv *Task) GetCancellable() *Cancellable {
	retC := C.g_task_get_cancellable((*C.GTask)(recv.native))
	retGo := CancellableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCheckCancellable is a wrapper around the C function g_task_get_check_cancellable.
func (recv *Task) GetCheckCancellable() bool {
	retC := C.g_task_get_check_cancellable((*C.GTask)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetContext is a wrapper around the C function g_task_get_context.
func (recv *Task) GetContext() *glib.MainContext {
	retC := C.g_task_get_context((*C.GTask)(recv.native))
	retGo := glib.MainContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPriority is a wrapper around the C function g_task_get_priority.
func (recv *Task) GetPriority() int32 {
	retC := C.g_task_get_priority((*C.GTask)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetReturnOnCancel is a wrapper around the C function g_task_get_return_on_cancel.
func (recv *Task) GetReturnOnCancel() bool {
	retC := C.g_task_get_return_on_cancel((*C.GTask)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSourceObject is a wrapper around the C function g_task_get_source_object.
func (recv *Task) GetSourceObject() gobject.Object {
	retC := C.g_task_get_source_object((*C.GTask)(recv.native))
	retGo := *gobject.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSourceTag is a wrapper around the C function g_task_get_source_tag.
func (recv *Task) GetSourceTag() uintptr {
	retC := C.g_task_get_source_tag((*C.GTask)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// GetTaskData is a wrapper around the C function g_task_get_task_data.
func (recv *Task) GetTaskData() uintptr {
	retC := C.g_task_get_task_data((*C.GTask)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// HadError is a wrapper around the C function g_task_had_error.
func (recv *Task) HadError() bool {
	retC := C.g_task_had_error((*C.GTask)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// PropagateBoolean is a wrapper around the C function g_task_propagate_boolean.
func (recv *Task) PropagateBoolean() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_task_propagate_boolean((*C.GTask)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PropagateInt is a wrapper around the C function g_task_propagate_int.
func (recv *Task) PropagateInt() (int64, error) {
	var cThrowableError *C.GError

	retC := C.g_task_propagate_int((*C.GTask)(recv.native), &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PropagatePointer is a wrapper around the C function g_task_propagate_pointer.
func (recv *Task) PropagatePointer() (uintptr, error) {
	var cThrowableError *C.GError

	retC := C.g_task_propagate_pointer((*C.GTask)(recv.native), &cThrowableError)
	retGo := (uintptr)(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReturnBoolean is a wrapper around the C function g_task_return_boolean.
func (recv *Task) ReturnBoolean(result bool) {
	c_result :=
		boolToGboolean(result)

	C.g_task_return_boolean((*C.GTask)(recv.native), c_result)

	return
}

// ReturnError is a wrapper around the C function g_task_return_error.
func (recv *Task) ReturnError(error_ *glib.Error) {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	C.g_task_return_error((*C.GTask)(recv.native), c_error)

	return
}

// ReturnErrorIfCancelled is a wrapper around the C function g_task_return_error_if_cancelled.
func (recv *Task) ReturnErrorIfCancelled() bool {
	retC := C.g_task_return_error_if_cancelled((*C.GTask)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ReturnInt is a wrapper around the C function g_task_return_int.
func (recv *Task) ReturnInt(result int64) {
	c_result := (C.gssize)(result)

	C.g_task_return_int((*C.GTask)(recv.native), c_result)

	return
}

// ReturnNewError is a wrapper around the C function g_task_return_new_error.
func (recv *Task) ReturnNewError(domain glib.Quark, code int32, format string, args ...interface{}) {
	c_domain := (C.GQuark)(domain)

	c_code := (C.gint)(code)

	goFormattedString := fmt.Sprintf(format, args...)
	c_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format))

	C._g_task_return_new_error((*C.GTask)(recv.native), c_domain, c_code, c_format)

	return
}

// Unsupported : g_task_return_pointer : unsupported parameter result_destroy : no type generator for GLib.DestroyNotify (GDestroyNotify) for param result_destroy

// Unsupported : g_task_run_in_thread : unsupported parameter task_func : no type generator for TaskThreadFunc (GTaskThreadFunc) for param task_func

// Unsupported : g_task_run_in_thread_sync : unsupported parameter task_func : no type generator for TaskThreadFunc (GTaskThreadFunc) for param task_func

// SetCheckCancellable is a wrapper around the C function g_task_set_check_cancellable.
func (recv *Task) SetCheckCancellable(checkCancellable bool) {
	c_check_cancellable :=
		boolToGboolean(checkCancellable)

	C.g_task_set_check_cancellable((*C.GTask)(recv.native), c_check_cancellable)

	return
}

// SetPriority is a wrapper around the C function g_task_set_priority.
func (recv *Task) SetPriority(priority int32) {
	c_priority := (C.gint)(priority)

	C.g_task_set_priority((*C.GTask)(recv.native), c_priority)

	return
}

// SetReturnOnCancel is a wrapper around the C function g_task_set_return_on_cancel.
func (recv *Task) SetReturnOnCancel(returnOnCancel bool) bool {
	c_return_on_cancel :=
		boolToGboolean(returnOnCancel)

	retC := C.g_task_set_return_on_cancel((*C.GTask)(recv.native), c_return_on_cancel)
	retGo := retC == C.TRUE

	return retGo
}

// SetSourceTag is a wrapper around the C function g_task_set_source_tag.
func (recv *Task) SetSourceTag(sourceTag uintptr) {
	c_source_tag := (C.gpointer)(sourceTag)

	C.g_task_set_source_tag((*C.GTask)(recv.native), c_source_tag)

	return
}

// Unsupported : g_task_set_task_data : unsupported parameter task_data_destroy : no type generator for GLib.DestroyNotify (GDestroyNotify) for param task_data_destroy

// AsyncResult returns the AsyncResult interface implemented by Task
func (recv *Task) AsyncResult() *AsyncResult {
	return AsyncResultNewFromC(recv.ToC())
}

// TcpConnection is a wrapper around the C record GTcpConnection.
type TcpConnection struct {
	native *C.GTcpConnection
	// parent_instance : record
	// priv : record
}

func TcpConnectionNewFromC(u unsafe.Pointer) *TcpConnection {
	c := (*C.GTcpConnection)(u)
	if c == nil {
		return nil
	}

	g := &TcpConnection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TcpConnection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TcpConnection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TcpConnection with another TcpConnection, and returns true if they represent the same GObject.
func (recv *TcpConnection) Equals(other *TcpConnection) bool {
	return other.ToC() == recv.ToC()
}

// SocketConnection upcasts to *SocketConnection
func (recv *TcpConnection) SocketConnection() *SocketConnection {
	return SocketConnectionNewFromC(unsafe.Pointer(recv.native))
}

// IOStream upcasts to *IOStream
func (recv *TcpConnection) IOStream() *IOStream {
	return recv.SocketConnection().IOStream()
}

// Object upcasts to *Object
func (recv *TcpConnection) Object() *gobject.Object {
	return recv.SocketConnection().Object()
}

// CastToWidget down casts any arbitrary Object to TcpConnection.
// Exercise care, as this is a potentially dangerous function if the Object is not a TcpConnection.
func CastToTcpConnection(object *gobject.Object) *TcpConnection {
	return TcpConnectionNewFromC(object.ToC())
}

// GetGracefulDisconnect is a wrapper around the C function g_tcp_connection_get_graceful_disconnect.
func (recv *TcpConnection) GetGracefulDisconnect() bool {
	retC := C.g_tcp_connection_get_graceful_disconnect((*C.GTcpConnection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetGracefulDisconnect is a wrapper around the C function g_tcp_connection_set_graceful_disconnect.
func (recv *TcpConnection) SetGracefulDisconnect(gracefulDisconnect bool) {
	c_graceful_disconnect :=
		boolToGboolean(gracefulDisconnect)

	C.g_tcp_connection_set_graceful_disconnect((*C.GTcpConnection)(recv.native), c_graceful_disconnect)

	return
}

// TcpWrapperConnection is a wrapper around the C record GTcpWrapperConnection.
type TcpWrapperConnection struct {
	native *C.GTcpWrapperConnection
	// parent_instance : record
	// priv : record
}

func TcpWrapperConnectionNewFromC(u unsafe.Pointer) *TcpWrapperConnection {
	c := (*C.GTcpWrapperConnection)(u)
	if c == nil {
		return nil
	}

	g := &TcpWrapperConnection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TcpWrapperConnection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TcpWrapperConnection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TcpWrapperConnection with another TcpWrapperConnection, and returns true if they represent the same GObject.
func (recv *TcpWrapperConnection) Equals(other *TcpWrapperConnection) bool {
	return other.ToC() == recv.ToC()
}

// TcpConnection upcasts to *TcpConnection
func (recv *TcpWrapperConnection) TcpConnection() *TcpConnection {
	return TcpConnectionNewFromC(unsafe.Pointer(recv.native))
}

// SocketConnection upcasts to *SocketConnection
func (recv *TcpWrapperConnection) SocketConnection() *SocketConnection {
	return recv.TcpConnection().SocketConnection()
}

// IOStream upcasts to *IOStream
func (recv *TcpWrapperConnection) IOStream() *IOStream {
	return recv.TcpConnection().IOStream()
}

// Object upcasts to *Object
func (recv *TcpWrapperConnection) Object() *gobject.Object {
	return recv.TcpConnection().Object()
}

// CastToWidget down casts any arbitrary Object to TcpWrapperConnection.
// Exercise care, as this is a potentially dangerous function if the Object is not a TcpWrapperConnection.
func CastToTcpWrapperConnection(object *gobject.Object) *TcpWrapperConnection {
	return TcpWrapperConnectionNewFromC(object.ToC())
}

// TcpWrapperConnectionNew is a wrapper around the C function g_tcp_wrapper_connection_new.
func TcpWrapperConnectionNew(baseIoStream *IOStream, socket *Socket) *TcpWrapperConnection {
	c_base_io_stream := (*C.GIOStream)(C.NULL)
	if baseIoStream != nil {
		c_base_io_stream = (*C.GIOStream)(baseIoStream.ToC())
	}

	c_socket := (*C.GSocket)(C.NULL)
	if socket != nil {
		c_socket = (*C.GSocket)(socket.ToC())
	}

	retC := C.g_tcp_wrapper_connection_new(c_base_io_stream, c_socket)
	retGo := TcpWrapperConnectionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetBaseIoStream is a wrapper around the C function g_tcp_wrapper_connection_get_base_io_stream.
func (recv *TcpWrapperConnection) GetBaseIoStream() *IOStream {
	retC := C.g_tcp_wrapper_connection_get_base_io_stream((*C.GTcpWrapperConnection)(recv.native))
	retGo := IOStreamNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TestDBus is a wrapper around the C record GTestDBus.
type TestDBus struct {
	native *C.GTestDBus
}

func TestDBusNewFromC(u unsafe.Pointer) *TestDBus {
	c := (*C.GTestDBus)(u)
	if c == nil {
		return nil
	}

	g := &TestDBus{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TestDBus) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TestDBus) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TestDBus with another TestDBus, and returns true if they represent the same GObject.
func (recv *TestDBus) Equals(other *TestDBus) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TestDBus) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TestDBus.
// Exercise care, as this is a potentially dangerous function if the Object is not a TestDBus.
func CastToTestDBus(object *gobject.Object) *TestDBus {
	return TestDBusNewFromC(object.ToC())
}

// TestDBusNew is a wrapper around the C function g_test_dbus_new.
func TestDBusNew(flags TestDBusFlags) *TestDBus {
	c_flags := (C.GTestDBusFlags)(flags)

	retC := C.g_test_dbus_new(c_flags)
	retGo := TestDBusNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// TestDBusUnset is a wrapper around the C function g_test_dbus_unset.
func TestDBusUnset() {
	C.g_test_dbus_unset()

	return
}

// AddServiceDir is a wrapper around the C function g_test_dbus_add_service_dir.
func (recv *TestDBus) AddServiceDir(path string) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	C.g_test_dbus_add_service_dir((*C.GTestDBus)(recv.native), c_path)

	return
}

// Down is a wrapper around the C function g_test_dbus_down.
func (recv *TestDBus) Down() {
	C.g_test_dbus_down((*C.GTestDBus)(recv.native))

	return
}

// GetBusAddress is a wrapper around the C function g_test_dbus_get_bus_address.
func (recv *TestDBus) GetBusAddress() string {
	retC := C.g_test_dbus_get_bus_address((*C.GTestDBus)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetFlags is a wrapper around the C function g_test_dbus_get_flags.
func (recv *TestDBus) GetFlags() TestDBusFlags {
	retC := C.g_test_dbus_get_flags((*C.GTestDBus)(recv.native))
	retGo := (TestDBusFlags)(retC)

	return retGo
}

// Stop is a wrapper around the C function g_test_dbus_stop.
func (recv *TestDBus) Stop() {
	C.g_test_dbus_stop((*C.GTestDBus)(recv.native))

	return
}

// Up is a wrapper around the C function g_test_dbus_up.
func (recv *TestDBus) Up() {
	C.g_test_dbus_up((*C.GTestDBus)(recv.native))

	return
}

// ThemedIcon is a wrapper around the C record GThemedIcon.
type ThemedIcon struct {
	native *C.GThemedIcon
}

func ThemedIconNewFromC(u unsafe.Pointer) *ThemedIcon {
	c := (*C.GThemedIcon)(u)
	if c == nil {
		return nil
	}

	g := &ThemedIcon{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ThemedIcon) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ThemedIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThemedIcon with another ThemedIcon, and returns true if they represent the same GObject.
func (recv *ThemedIcon) Equals(other *ThemedIcon) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ThemedIcon) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ThemedIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a ThemedIcon.
func CastToThemedIcon(object *gobject.Object) *ThemedIcon {
	return ThemedIconNewFromC(object.ToC())
}

// ThemedIconNew is a wrapper around the C function g_themed_icon_new.
func ThemedIconNew(iconname string) *ThemedIcon {
	c_iconname := C.CString(iconname)
	defer C.free(unsafe.Pointer(c_iconname))

	retC := C.g_themed_icon_new(c_iconname)
	retGo := ThemedIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// ThemedIconNewFromNames is a wrapper around the C function g_themed_icon_new_from_names.
func ThemedIconNewFromNames(iconnames []string) *ThemedIcon {
	c_iconnames_array := make([]*C.char, len(iconnames)+1, len(iconnames)+1)
	for i, item := range iconnames {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_iconnames_array[i] = c
	}
	c_iconnames_array[len(iconnames)] = nil
	c_iconnames_arrayPtr := &c_iconnames_array[0]
	c_iconnames := (**C.char)(unsafe.Pointer(c_iconnames_arrayPtr))

	c_len := (C.int)(len(iconnames))

	retC := C.g_themed_icon_new_from_names(c_iconnames, c_len)
	retGo := ThemedIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// ThemedIconNewWithDefaultFallbacks is a wrapper around the C function g_themed_icon_new_with_default_fallbacks.
func ThemedIconNewWithDefaultFallbacks(iconname string) *ThemedIcon {
	c_iconname := C.CString(iconname)
	defer C.free(unsafe.Pointer(c_iconname))

	retC := C.g_themed_icon_new_with_default_fallbacks(c_iconname)
	retGo := ThemedIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AppendName is a wrapper around the C function g_themed_icon_append_name.
func (recv *ThemedIcon) AppendName(iconname string) {
	c_iconname := C.CString(iconname)
	defer C.free(unsafe.Pointer(c_iconname))

	C.g_themed_icon_append_name((*C.GThemedIcon)(recv.native), c_iconname)

	return
}

// GetNames is a wrapper around the C function g_themed_icon_get_names.
func (recv *ThemedIcon) GetNames() []string {
	retC := C.g_themed_icon_get_names((*C.GThemedIcon)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// PrependName is a wrapper around the C function g_themed_icon_prepend_name.
func (recv *ThemedIcon) PrependName(iconname string) {
	c_iconname := C.CString(iconname)
	defer C.free(unsafe.Pointer(c_iconname))

	C.g_themed_icon_prepend_name((*C.GThemedIcon)(recv.native), c_iconname)

	return
}

// Icon returns the Icon interface implemented by ThemedIcon
func (recv *ThemedIcon) Icon() *Icon {
	return IconNewFromC(recv.ToC())
}

// ThreadedSocketService is a wrapper around the C record GThreadedSocketService.
type ThreadedSocketService struct {
	native *C.GThreadedSocketService
	// parent_instance : record
	// priv : record
}

func ThreadedSocketServiceNewFromC(u unsafe.Pointer) *ThreadedSocketService {
	c := (*C.GThreadedSocketService)(u)
	if c == nil {
		return nil
	}

	g := &ThreadedSocketService{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ThreadedSocketService) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ThreadedSocketService) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThreadedSocketService with another ThreadedSocketService, and returns true if they represent the same GObject.
func (recv *ThreadedSocketService) Equals(other *ThreadedSocketService) bool {
	return other.ToC() == recv.ToC()
}

// SocketService upcasts to *SocketService
func (recv *ThreadedSocketService) SocketService() *SocketService {
	return SocketServiceNewFromC(unsafe.Pointer(recv.native))
}

// SocketListener upcasts to *SocketListener
func (recv *ThreadedSocketService) SocketListener() *SocketListener {
	return recv.SocketService().SocketListener()
}

// Object upcasts to *Object
func (recv *ThreadedSocketService) Object() *gobject.Object {
	return recv.SocketService().Object()
}

// CastToWidget down casts any arbitrary Object to ThreadedSocketService.
// Exercise care, as this is a potentially dangerous function if the Object is not a ThreadedSocketService.
func CastToThreadedSocketService(object *gobject.Object) *ThreadedSocketService {
	return ThreadedSocketServiceNewFromC(object.ToC())
}

type signalThreadedSocketServiceRunDetail struct {
	callback  ThreadedSocketServiceSignalRunCallback
	handlerID C.gulong
}

var signalThreadedSocketServiceRunId int
var signalThreadedSocketServiceRunMap = make(map[int]signalThreadedSocketServiceRunDetail)
var signalThreadedSocketServiceRunLock sync.RWMutex

// ThreadedSocketServiceSignalRunCallback is a callback function for a 'run' signal emitted from a ThreadedSocketService.
type ThreadedSocketServiceSignalRunCallback func(connection *SocketConnection, sourceObject *gobject.Object) bool

/*
ConnectRun connects the callback to the 'run' signal for the ThreadedSocketService.

The returned value represents the connection, and may be passed to DisconnectRun to remove it.
*/
func (recv *ThreadedSocketService) ConnectRun(callback ThreadedSocketServiceSignalRunCallback) int {
	signalThreadedSocketServiceRunLock.Lock()
	defer signalThreadedSocketServiceRunLock.Unlock()

	signalThreadedSocketServiceRunId++
	instance := C.gpointer(recv.native)
	handlerID := C.ThreadedSocketService_signal_connect_run(instance, C.gpointer(uintptr(signalThreadedSocketServiceRunId)))

	detail := signalThreadedSocketServiceRunDetail{callback, handlerID}
	signalThreadedSocketServiceRunMap[signalThreadedSocketServiceRunId] = detail

	return signalThreadedSocketServiceRunId
}

/*
DisconnectRun disconnects a callback from the 'run' signal for the ThreadedSocketService.

The connectionID should be a value returned from a call to ConnectRun.
*/
func (recv *ThreadedSocketService) DisconnectRun(connectionID int) {
	signalThreadedSocketServiceRunLock.Lock()
	defer signalThreadedSocketServiceRunLock.Unlock()

	detail, exists := signalThreadedSocketServiceRunMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalThreadedSocketServiceRunMap, connectionID)
}

//export threadedsocketservice_runHandler
func threadedsocketservice_runHandler(_ *C.GObject, c_connection *C.GSocketConnection, c_source_object *C.GObject, data C.gpointer) C.gboolean {
	signalThreadedSocketServiceRunLock.RLock()
	defer signalThreadedSocketServiceRunLock.RUnlock()

	connection := SocketConnectionNewFromC(unsafe.Pointer(c_connection))

	sourceObject := gobject.ObjectNewFromC(unsafe.Pointer(c_source_object))

	index := int(uintptr(data))
	callback := signalThreadedSocketServiceRunMap[index].callback
	retGo := callback(connection, sourceObject)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// ThreadedSocketServiceNew is a wrapper around the C function g_threaded_socket_service_new.
func ThreadedSocketServiceNew(maxThreads int32) *ThreadedSocketService {
	c_max_threads := (C.int)(maxThreads)

	retC := C.g_threaded_socket_service_new(c_max_threads)
	retGo := ThreadedSocketServiceNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// TlsCertificate is a wrapper around the C record GTlsCertificate.
type TlsCertificate struct {
	native *C.GTlsCertificate
	// parent_instance : record
	// priv : record
}

func TlsCertificateNewFromC(u unsafe.Pointer) *TlsCertificate {
	c := (*C.GTlsCertificate)(u)
	if c == nil {
		return nil
	}

	g := &TlsCertificate{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TlsCertificate) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TlsCertificate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsCertificate with another TlsCertificate, and returns true if they represent the same GObject.
func (recv *TlsCertificate) Equals(other *TlsCertificate) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TlsCertificate) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TlsCertificate.
// Exercise care, as this is a potentially dangerous function if the Object is not a TlsCertificate.
func CastToTlsCertificate(object *gobject.Object) *TlsCertificate {
	return TlsCertificateNewFromC(object.ToC())
}

// TlsCertificateNewFromFile is a wrapper around the C function g_tls_certificate_new_from_file.
func TlsCertificateNewFromFile(file string) (*TlsCertificate, error) {
	c_file := C.CString(file)
	defer C.free(unsafe.Pointer(c_file))

	var cThrowableError *C.GError

	retC := C.g_tls_certificate_new_from_file(c_file, &cThrowableError)
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// TlsCertificateNewFromFiles is a wrapper around the C function g_tls_certificate_new_from_files.
func TlsCertificateNewFromFiles(certFile string, keyFile string) (*TlsCertificate, error) {
	c_cert_file := C.CString(certFile)
	defer C.free(unsafe.Pointer(c_cert_file))

	c_key_file := C.CString(keyFile)
	defer C.free(unsafe.Pointer(c_key_file))

	var cThrowableError *C.GError

	retC := C.g_tls_certificate_new_from_files(c_cert_file, c_key_file, &cThrowableError)
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// TlsCertificateNewFromPem is a wrapper around the C function g_tls_certificate_new_from_pem.
func TlsCertificateNewFromPem(data string) (*TlsCertificate, error) {
	c_data := C.CString(data)
	defer C.free(unsafe.Pointer(c_data))

	c_length := (C.gssize)(len(data))

	var cThrowableError *C.GError

	retC := C.g_tls_certificate_new_from_pem(c_data, c_length, &cThrowableError)
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// TlsCertificateListNewFromFile is a wrapper around the C function g_tls_certificate_list_new_from_file.
func TlsCertificateListNewFromFile(file string) (*glib.List, error) {
	c_file := C.CString(file)
	defer C.free(unsafe.Pointer(c_file))

	var cThrowableError *C.GError

	retC := C.g_tls_certificate_list_new_from_file(c_file, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetIssuer is a wrapper around the C function g_tls_certificate_get_issuer.
func (recv *TlsCertificate) GetIssuer() *TlsCertificate {
	retC := C.g_tls_certificate_get_issuer((*C.GTlsCertificate)(recv.native))
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IsSame is a wrapper around the C function g_tls_certificate_is_same.
func (recv *TlsCertificate) IsSame(certTwo *TlsCertificate) bool {
	c_cert_two := (*C.GTlsCertificate)(C.NULL)
	if certTwo != nil {
		c_cert_two = (*C.GTlsCertificate)(certTwo.ToC())
	}

	retC := C.g_tls_certificate_is_same((*C.GTlsCertificate)(recv.native), c_cert_two)
	retGo := retC == C.TRUE

	return retGo
}

// Verify is a wrapper around the C function g_tls_certificate_verify.
func (recv *TlsCertificate) Verify(identity *SocketConnectable, trustedCa *TlsCertificate) TlsCertificateFlags {
	c_identity := (*C.GSocketConnectable)(identity.ToC())

	c_trusted_ca := (*C.GTlsCertificate)(C.NULL)
	if trustedCa != nil {
		c_trusted_ca = (*C.GTlsCertificate)(trustedCa.ToC())
	}

	retC := C.g_tls_certificate_verify((*C.GTlsCertificate)(recv.native), c_identity, c_trusted_ca)
	retGo := (TlsCertificateFlags)(retC)

	return retGo
}

// TlsConnection is a wrapper around the C record GTlsConnection.
type TlsConnection struct {
	native *C.GTlsConnection
	// parent_instance : record
	// priv : record
}

func TlsConnectionNewFromC(u unsafe.Pointer) *TlsConnection {
	c := (*C.GTlsConnection)(u)
	if c == nil {
		return nil
	}

	g := &TlsConnection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TlsConnection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TlsConnection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsConnection with another TlsConnection, and returns true if they represent the same GObject.
func (recv *TlsConnection) Equals(other *TlsConnection) bool {
	return other.ToC() == recv.ToC()
}

// IOStream upcasts to *IOStream
func (recv *TlsConnection) IOStream() *IOStream {
	return IOStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *TlsConnection) Object() *gobject.Object {
	return recv.IOStream().Object()
}

// CastToWidget down casts any arbitrary Object to TlsConnection.
// Exercise care, as this is a potentially dangerous function if the Object is not a TlsConnection.
func CastToTlsConnection(object *gobject.Object) *TlsConnection {
	return TlsConnectionNewFromC(object.ToC())
}

type signalTlsConnectionAcceptCertificateDetail struct {
	callback  TlsConnectionSignalAcceptCertificateCallback
	handlerID C.gulong
}

var signalTlsConnectionAcceptCertificateId int
var signalTlsConnectionAcceptCertificateMap = make(map[int]signalTlsConnectionAcceptCertificateDetail)
var signalTlsConnectionAcceptCertificateLock sync.RWMutex

// TlsConnectionSignalAcceptCertificateCallback is a callback function for a 'accept-certificate' signal emitted from a TlsConnection.
type TlsConnectionSignalAcceptCertificateCallback func(peerCert *TlsCertificate, errors TlsCertificateFlags) bool

/*
ConnectAcceptCertificate connects the callback to the 'accept-certificate' signal for the TlsConnection.

The returned value represents the connection, and may be passed to DisconnectAcceptCertificate to remove it.
*/
func (recv *TlsConnection) ConnectAcceptCertificate(callback TlsConnectionSignalAcceptCertificateCallback) int {
	signalTlsConnectionAcceptCertificateLock.Lock()
	defer signalTlsConnectionAcceptCertificateLock.Unlock()

	signalTlsConnectionAcceptCertificateId++
	instance := C.gpointer(recv.native)
	handlerID := C.TlsConnection_signal_connect_accept_certificate(instance, C.gpointer(uintptr(signalTlsConnectionAcceptCertificateId)))

	detail := signalTlsConnectionAcceptCertificateDetail{callback, handlerID}
	signalTlsConnectionAcceptCertificateMap[signalTlsConnectionAcceptCertificateId] = detail

	return signalTlsConnectionAcceptCertificateId
}

/*
DisconnectAcceptCertificate disconnects a callback from the 'accept-certificate' signal for the TlsConnection.

The connectionID should be a value returned from a call to ConnectAcceptCertificate.
*/
func (recv *TlsConnection) DisconnectAcceptCertificate(connectionID int) {
	signalTlsConnectionAcceptCertificateLock.Lock()
	defer signalTlsConnectionAcceptCertificateLock.Unlock()

	detail, exists := signalTlsConnectionAcceptCertificateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTlsConnectionAcceptCertificateMap, connectionID)
}

//export tlsconnection_acceptCertificateHandler
func tlsconnection_acceptCertificateHandler(_ *C.GObject, c_peer_cert *C.GTlsCertificate, c_errors C.GTlsCertificateFlags, data C.gpointer) C.gboolean {
	signalTlsConnectionAcceptCertificateLock.RLock()
	defer signalTlsConnectionAcceptCertificateLock.RUnlock()

	peerCert := TlsCertificateNewFromC(unsafe.Pointer(c_peer_cert))

	errors := TlsCertificateFlags(c_errors)

	index := int(uintptr(data))
	callback := signalTlsConnectionAcceptCertificateMap[index].callback
	retGo := callback(peerCert, errors)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// EmitAcceptCertificate is a wrapper around the C function g_tls_connection_emit_accept_certificate.
func (recv *TlsConnection) EmitAcceptCertificate(peerCert *TlsCertificate, errors TlsCertificateFlags) bool {
	c_peer_cert := (*C.GTlsCertificate)(C.NULL)
	if peerCert != nil {
		c_peer_cert = (*C.GTlsCertificate)(peerCert.ToC())
	}

	c_errors := (C.GTlsCertificateFlags)(errors)

	retC := C.g_tls_connection_emit_accept_certificate((*C.GTlsConnection)(recv.native), c_peer_cert, c_errors)
	retGo := retC == C.TRUE

	return retGo
}

// GetCertificate is a wrapper around the C function g_tls_connection_get_certificate.
func (recv *TlsConnection) GetCertificate() *TlsCertificate {
	retC := C.g_tls_connection_get_certificate((*C.GTlsConnection)(recv.native))
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDatabase is a wrapper around the C function g_tls_connection_get_database.
func (recv *TlsConnection) GetDatabase() *TlsDatabase {
	retC := C.g_tls_connection_get_database((*C.GTlsConnection)(recv.native))
	retGo := TlsDatabaseNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetInteraction is a wrapper around the C function g_tls_connection_get_interaction.
func (recv *TlsConnection) GetInteraction() *TlsInteraction {
	retC := C.g_tls_connection_get_interaction((*C.GTlsConnection)(recv.native))
	retGo := TlsInteractionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPeerCertificate is a wrapper around the C function g_tls_connection_get_peer_certificate.
func (recv *TlsConnection) GetPeerCertificate() *TlsCertificate {
	retC := C.g_tls_connection_get_peer_certificate((*C.GTlsConnection)(recv.native))
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPeerCertificateErrors is a wrapper around the C function g_tls_connection_get_peer_certificate_errors.
func (recv *TlsConnection) GetPeerCertificateErrors() TlsCertificateFlags {
	retC := C.g_tls_connection_get_peer_certificate_errors((*C.GTlsConnection)(recv.native))
	retGo := (TlsCertificateFlags)(retC)

	return retGo
}

// GetRehandshakeMode is a wrapper around the C function g_tls_connection_get_rehandshake_mode.
func (recv *TlsConnection) GetRehandshakeMode() TlsRehandshakeMode {
	retC := C.g_tls_connection_get_rehandshake_mode((*C.GTlsConnection)(recv.native))
	retGo := (TlsRehandshakeMode)(retC)

	return retGo
}

// GetRequireCloseNotify is a wrapper around the C function g_tls_connection_get_require_close_notify.
func (recv *TlsConnection) GetRequireCloseNotify() bool {
	retC := C.g_tls_connection_get_require_close_notify((*C.GTlsConnection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetUseSystemCertdb is a wrapper around the C function g_tls_connection_get_use_system_certdb.
func (recv *TlsConnection) GetUseSystemCertdb() bool {
	retC := C.g_tls_connection_get_use_system_certdb((*C.GTlsConnection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Handshake is a wrapper around the C function g_tls_connection_handshake.
func (recv *TlsConnection) Handshake(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_tls_connection_handshake((*C.GTlsConnection)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_tls_connection_handshake_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// HandshakeFinish is a wrapper around the C function g_tls_connection_handshake_finish.
func (recv *TlsConnection) HandshakeFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_tls_connection_handshake_finish((*C.GTlsConnection)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetCertificate is a wrapper around the C function g_tls_connection_set_certificate.
func (recv *TlsConnection) SetCertificate(certificate *TlsCertificate) {
	c_certificate := (*C.GTlsCertificate)(C.NULL)
	if certificate != nil {
		c_certificate = (*C.GTlsCertificate)(certificate.ToC())
	}

	C.g_tls_connection_set_certificate((*C.GTlsConnection)(recv.native), c_certificate)

	return
}

// SetDatabase is a wrapper around the C function g_tls_connection_set_database.
func (recv *TlsConnection) SetDatabase(database *TlsDatabase) {
	c_database := (*C.GTlsDatabase)(C.NULL)
	if database != nil {
		c_database = (*C.GTlsDatabase)(database.ToC())
	}

	C.g_tls_connection_set_database((*C.GTlsConnection)(recv.native), c_database)

	return
}

// SetInteraction is a wrapper around the C function g_tls_connection_set_interaction.
func (recv *TlsConnection) SetInteraction(interaction *TlsInteraction) {
	c_interaction := (*C.GTlsInteraction)(C.NULL)
	if interaction != nil {
		c_interaction = (*C.GTlsInteraction)(interaction.ToC())
	}

	C.g_tls_connection_set_interaction((*C.GTlsConnection)(recv.native), c_interaction)

	return
}

// SetRehandshakeMode is a wrapper around the C function g_tls_connection_set_rehandshake_mode.
func (recv *TlsConnection) SetRehandshakeMode(mode TlsRehandshakeMode) {
	c_mode := (C.GTlsRehandshakeMode)(mode)

	C.g_tls_connection_set_rehandshake_mode((*C.GTlsConnection)(recv.native), c_mode)

	return
}

// SetRequireCloseNotify is a wrapper around the C function g_tls_connection_set_require_close_notify.
func (recv *TlsConnection) SetRequireCloseNotify(requireCloseNotify bool) {
	c_require_close_notify :=
		boolToGboolean(requireCloseNotify)

	C.g_tls_connection_set_require_close_notify((*C.GTlsConnection)(recv.native), c_require_close_notify)

	return
}

// SetUseSystemCertdb is a wrapper around the C function g_tls_connection_set_use_system_certdb.
func (recv *TlsConnection) SetUseSystemCertdb(useSystemCertdb bool) {
	c_use_system_certdb :=
		boolToGboolean(useSystemCertdb)

	C.g_tls_connection_set_use_system_certdb((*C.GTlsConnection)(recv.native), c_use_system_certdb)

	return
}

// TlsDatabase is a wrapper around the C record GTlsDatabase.
type TlsDatabase struct {
	native *C.GTlsDatabase
	// parent_instance : record
	// priv : record
}

func TlsDatabaseNewFromC(u unsafe.Pointer) *TlsDatabase {
	c := (*C.GTlsDatabase)(u)
	if c == nil {
		return nil
	}

	g := &TlsDatabase{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TlsDatabase) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TlsDatabase) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsDatabase with another TlsDatabase, and returns true if they represent the same GObject.
func (recv *TlsDatabase) Equals(other *TlsDatabase) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TlsDatabase) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TlsDatabase.
// Exercise care, as this is a potentially dangerous function if the Object is not a TlsDatabase.
func CastToTlsDatabase(object *gobject.Object) *TlsDatabase {
	return TlsDatabaseNewFromC(object.ToC())
}

// CreateCertificateHandle is a wrapper around the C function g_tls_database_create_certificate_handle.
func (recv *TlsDatabase) CreateCertificateHandle(certificate *TlsCertificate) string {
	c_certificate := (*C.GTlsCertificate)(C.NULL)
	if certificate != nil {
		c_certificate = (*C.GTlsCertificate)(certificate.ToC())
	}

	retC := C.g_tls_database_create_certificate_handle((*C.GTlsDatabase)(recv.native), c_certificate)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// LookupCertificateForHandle is a wrapper around the C function g_tls_database_lookup_certificate_for_handle.
func (recv *TlsDatabase) LookupCertificateForHandle(handle string, interaction *TlsInteraction, flags TlsDatabaseLookupFlags, cancellable *Cancellable) (*TlsCertificate, error) {
	c_handle := C.CString(handle)
	defer C.free(unsafe.Pointer(c_handle))

	c_interaction := (*C.GTlsInteraction)(C.NULL)
	if interaction != nil {
		c_interaction = (*C.GTlsInteraction)(interaction.ToC())
	}

	c_flags := (C.GTlsDatabaseLookupFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_tls_database_lookup_certificate_for_handle((*C.GTlsDatabase)(recv.native), c_handle, c_interaction, c_flags, c_cancellable, &cThrowableError)
	var retGo (*TlsCertificate)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TlsCertificateNewFromC(unsafe.Pointer(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_tls_database_lookup_certificate_for_handle_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LookupCertificateForHandleFinish is a wrapper around the C function g_tls_database_lookup_certificate_for_handle_finish.
func (recv *TlsDatabase) LookupCertificateForHandleFinish(result *AsyncResult) (*TlsCertificate, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_tls_database_lookup_certificate_for_handle_finish((*C.GTlsDatabase)(recv.native), c_result, &cThrowableError)
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LookupCertificateIssuer is a wrapper around the C function g_tls_database_lookup_certificate_issuer.
func (recv *TlsDatabase) LookupCertificateIssuer(certificate *TlsCertificate, interaction *TlsInteraction, flags TlsDatabaseLookupFlags, cancellable *Cancellable) (*TlsCertificate, error) {
	c_certificate := (*C.GTlsCertificate)(C.NULL)
	if certificate != nil {
		c_certificate = (*C.GTlsCertificate)(certificate.ToC())
	}

	c_interaction := (*C.GTlsInteraction)(C.NULL)
	if interaction != nil {
		c_interaction = (*C.GTlsInteraction)(interaction.ToC())
	}

	c_flags := (C.GTlsDatabaseLookupFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_tls_database_lookup_certificate_issuer((*C.GTlsDatabase)(recv.native), c_certificate, c_interaction, c_flags, c_cancellable, &cThrowableError)
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_tls_database_lookup_certificate_issuer_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LookupCertificateIssuerFinish is a wrapper around the C function g_tls_database_lookup_certificate_issuer_finish.
func (recv *TlsDatabase) LookupCertificateIssuerFinish(result *AsyncResult) (*TlsCertificate, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_tls_database_lookup_certificate_issuer_finish((*C.GTlsDatabase)(recv.native), c_result, &cThrowableError)
	retGo := TlsCertificateNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LookupCertificatesIssuedBy is a wrapper around the C function g_tls_database_lookup_certificates_issued_by.
func (recv *TlsDatabase) LookupCertificatesIssuedBy(issuerRawDn []uint8, interaction *TlsInteraction, flags TlsDatabaseLookupFlags, cancellable *Cancellable) (*glib.List, error) {
	c_issuer_raw_dn_array := make([]C.guint8, len(issuerRawDn)+1, len(issuerRawDn)+1)
	for i, item := range issuerRawDn {
		c := (C.guint8)(item)
		c_issuer_raw_dn_array[i] = c
	}
	c_issuer_raw_dn_array[len(issuerRawDn)] = 0
	c_issuer_raw_dn_arrayPtr := &c_issuer_raw_dn_array[0]
	c_issuer_raw_dn := (*C.GByteArray)(unsafe.Pointer(c_issuer_raw_dn_arrayPtr))

	c_interaction := (*C.GTlsInteraction)(C.NULL)
	if interaction != nil {
		c_interaction = (*C.GTlsInteraction)(interaction.ToC())
	}

	c_flags := (C.GTlsDatabaseLookupFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_tls_database_lookup_certificates_issued_by((*C.GTlsDatabase)(recv.native), c_issuer_raw_dn, c_interaction, c_flags, c_cancellable, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_tls_database_lookup_certificates_issued_by_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LookupCertificatesIssuedByFinish is a wrapper around the C function g_tls_database_lookup_certificates_issued_by_finish.
func (recv *TlsDatabase) LookupCertificatesIssuedByFinish(result *AsyncResult) (*glib.List, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_tls_database_lookup_certificates_issued_by_finish((*C.GTlsDatabase)(recv.native), c_result, &cThrowableError)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// VerifyChain is a wrapper around the C function g_tls_database_verify_chain.
func (recv *TlsDatabase) VerifyChain(chain *TlsCertificate, purpose string, identity *SocketConnectable, interaction *TlsInteraction, flags TlsDatabaseVerifyFlags, cancellable *Cancellable) (TlsCertificateFlags, error) {
	c_chain := (*C.GTlsCertificate)(C.NULL)
	if chain != nil {
		c_chain = (*C.GTlsCertificate)(chain.ToC())
	}

	c_purpose := C.CString(purpose)
	defer C.free(unsafe.Pointer(c_purpose))

	c_identity := (*C.GSocketConnectable)(identity.ToC())

	c_interaction := (*C.GTlsInteraction)(C.NULL)
	if interaction != nil {
		c_interaction = (*C.GTlsInteraction)(interaction.ToC())
	}

	c_flags := (C.GTlsDatabaseVerifyFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_tls_database_verify_chain((*C.GTlsDatabase)(recv.native), c_chain, c_purpose, c_identity, c_interaction, c_flags, c_cancellable, &cThrowableError)
	retGo := (TlsCertificateFlags)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_tls_database_verify_chain_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// VerifyChainFinish is a wrapper around the C function g_tls_database_verify_chain_finish.
func (recv *TlsDatabase) VerifyChainFinish(result *AsyncResult) (TlsCertificateFlags, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_tls_database_verify_chain_finish((*C.GTlsDatabase)(recv.native), c_result, &cThrowableError)
	retGo := (TlsCertificateFlags)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// TlsInteraction is a wrapper around the C record GTlsInteraction.
type TlsInteraction struct {
	native *C.GTlsInteraction
	// Private : parent_instance
	// Private : priv
}

func TlsInteractionNewFromC(u unsafe.Pointer) *TlsInteraction {
	c := (*C.GTlsInteraction)(u)
	if c == nil {
		return nil
	}

	g := &TlsInteraction{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TlsInteraction) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TlsInteraction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsInteraction with another TlsInteraction, and returns true if they represent the same GObject.
func (recv *TlsInteraction) Equals(other *TlsInteraction) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TlsInteraction) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TlsInteraction.
// Exercise care, as this is a potentially dangerous function if the Object is not a TlsInteraction.
func CastToTlsInteraction(object *gobject.Object) *TlsInteraction {
	return TlsInteractionNewFromC(object.ToC())
}

// AskPassword is a wrapper around the C function g_tls_interaction_ask_password.
func (recv *TlsInteraction) AskPassword(password *TlsPassword, cancellable *Cancellable) (TlsInteractionResult, error) {
	c_password := (*C.GTlsPassword)(C.NULL)
	if password != nil {
		c_password = (*C.GTlsPassword)(password.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_tls_interaction_ask_password((*C.GTlsInteraction)(recv.native), c_password, c_cancellable, &cThrowableError)
	retGo := (TlsInteractionResult)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_tls_interaction_ask_password_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// AskPasswordFinish is a wrapper around the C function g_tls_interaction_ask_password_finish.
func (recv *TlsInteraction) AskPasswordFinish(result *AsyncResult) (TlsInteractionResult, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_tls_interaction_ask_password_finish((*C.GTlsInteraction)(recv.native), c_result, &cThrowableError)
	retGo := (TlsInteractionResult)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// InvokeAskPassword is a wrapper around the C function g_tls_interaction_invoke_ask_password.
func (recv *TlsInteraction) InvokeAskPassword(password *TlsPassword, cancellable *Cancellable) (TlsInteractionResult, error) {
	c_password := (*C.GTlsPassword)(C.NULL)
	if password != nil {
		c_password = (*C.GTlsPassword)(password.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_tls_interaction_invoke_ask_password((*C.GTlsInteraction)(recv.native), c_password, c_cancellable, &cThrowableError)
	retGo := (TlsInteractionResult)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// TlsPassword is a wrapper around the C record GTlsPassword.
type TlsPassword struct {
	native *C.GTlsPassword
	// parent_instance : record
	// priv : record
}

func TlsPasswordNewFromC(u unsafe.Pointer) *TlsPassword {
	c := (*C.GTlsPassword)(u)
	if c == nil {
		return nil
	}

	g := &TlsPassword{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TlsPassword) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TlsPassword) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsPassword with another TlsPassword, and returns true if they represent the same GObject.
func (recv *TlsPassword) Equals(other *TlsPassword) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TlsPassword) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TlsPassword.
// Exercise care, as this is a potentially dangerous function if the Object is not a TlsPassword.
func CastToTlsPassword(object *gobject.Object) *TlsPassword {
	return TlsPasswordNewFromC(object.ToC())
}

// TlsPasswordNew is a wrapper around the C function g_tls_password_new.
func TlsPasswordNew(flags TlsPasswordFlags, description string) *TlsPassword {
	c_flags := (C.GTlsPasswordFlags)(flags)

	c_description := C.CString(description)
	defer C.free(unsafe.Pointer(c_description))

	retC := C.g_tls_password_new(c_flags, c_description)
	retGo := TlsPasswordNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetDescription is a wrapper around the C function g_tls_password_get_description.
func (recv *TlsPassword) GetDescription() string {
	retC := C.g_tls_password_get_description((*C.GTlsPassword)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetFlags is a wrapper around the C function g_tls_password_get_flags.
func (recv *TlsPassword) GetFlags() TlsPasswordFlags {
	retC := C.g_tls_password_get_flags((*C.GTlsPassword)(recv.native))
	retGo := (TlsPasswordFlags)(retC)

	return retGo
}

// Blacklisted : g_tls_password_get_value

// GetWarning is a wrapper around the C function g_tls_password_get_warning.
func (recv *TlsPassword) GetWarning() string {
	retC := C.g_tls_password_get_warning((*C.GTlsPassword)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SetDescription is a wrapper around the C function g_tls_password_set_description.
func (recv *TlsPassword) SetDescription(description string) {
	c_description := C.CString(description)
	defer C.free(unsafe.Pointer(c_description))

	C.g_tls_password_set_description((*C.GTlsPassword)(recv.native), c_description)

	return
}

// SetFlags is a wrapper around the C function g_tls_password_set_flags.
func (recv *TlsPassword) SetFlags(flags TlsPasswordFlags) {
	c_flags := (C.GTlsPasswordFlags)(flags)

	C.g_tls_password_set_flags((*C.GTlsPassword)(recv.native), c_flags)

	return
}

// SetValue is a wrapper around the C function g_tls_password_set_value.
func (recv *TlsPassword) SetValue(value []uint8) {
	c_value_array := make([]C.guchar, len(value)+1, len(value)+1)
	for i, item := range value {
		c := (C.guchar)(item)
		c_value_array[i] = c
	}
	c_value_array[len(value)] = 0
	c_value_arrayPtr := &c_value_array[0]
	c_value := (*C.guchar)(unsafe.Pointer(c_value_arrayPtr))

	c_length := (C.gssize)(len(value))

	C.g_tls_password_set_value((*C.GTlsPassword)(recv.native), c_value, c_length)

	return
}

// Unsupported : g_tls_password_set_value_full : unsupported parameter destroy : no type generator for GLib.DestroyNotify (GDestroyNotify) for param destroy

// SetWarning is a wrapper around the C function g_tls_password_set_warning.
func (recv *TlsPassword) SetWarning(warning string) {
	c_warning := C.CString(warning)
	defer C.free(unsafe.Pointer(c_warning))

	C.g_tls_password_set_warning((*C.GTlsPassword)(recv.native), c_warning)

	return
}

// UnixConnection is a wrapper around the C record GUnixConnection.
type UnixConnection struct {
	native *C.GUnixConnection
	// parent_instance : record
	// priv : record
}

func UnixConnectionNewFromC(u unsafe.Pointer) *UnixConnection {
	c := (*C.GUnixConnection)(u)
	if c == nil {
		return nil
	}

	g := &UnixConnection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UnixConnection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UnixConnection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixConnection with another UnixConnection, and returns true if they represent the same GObject.
func (recv *UnixConnection) Equals(other *UnixConnection) bool {
	return other.ToC() == recv.ToC()
}

// SocketConnection upcasts to *SocketConnection
func (recv *UnixConnection) SocketConnection() *SocketConnection {
	return SocketConnectionNewFromC(unsafe.Pointer(recv.native))
}

// IOStream upcasts to *IOStream
func (recv *UnixConnection) IOStream() *IOStream {
	return recv.SocketConnection().IOStream()
}

// Object upcasts to *Object
func (recv *UnixConnection) Object() *gobject.Object {
	return recv.SocketConnection().Object()
}

// CastToWidget down casts any arbitrary Object to UnixConnection.
// Exercise care, as this is a potentially dangerous function if the Object is not a UnixConnection.
func CastToUnixConnection(object *gobject.Object) *UnixConnection {
	return UnixConnectionNewFromC(object.ToC())
}

// ReceiveCredentials is a wrapper around the C function g_unix_connection_receive_credentials.
func (recv *UnixConnection) ReceiveCredentials(cancellable *Cancellable) (*Credentials, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_unix_connection_receive_credentials((*C.GUnixConnection)(recv.native), c_cancellable, &cThrowableError)
	retGo := CredentialsNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_unix_connection_receive_credentials_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReceiveCredentialsFinish is a wrapper around the C function g_unix_connection_receive_credentials_finish.
func (recv *UnixConnection) ReceiveCredentialsFinish(result *AsyncResult) (*Credentials, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_unix_connection_receive_credentials_finish((*C.GUnixConnection)(recv.native), c_result, &cThrowableError)
	retGo := CredentialsNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReceiveFd is a wrapper around the C function g_unix_connection_receive_fd.
func (recv *UnixConnection) ReceiveFd(cancellable *Cancellable) (int32, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_unix_connection_receive_fd((*C.GUnixConnection)(recv.native), c_cancellable, &cThrowableError)
	retGo := (int32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SendCredentials is a wrapper around the C function g_unix_connection_send_credentials.
func (recv *UnixConnection) SendCredentials(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_unix_connection_send_credentials((*C.GUnixConnection)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_unix_connection_send_credentials_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// SendCredentialsFinish is a wrapper around the C function g_unix_connection_send_credentials_finish.
func (recv *UnixConnection) SendCredentialsFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_unix_connection_send_credentials_finish((*C.GUnixConnection)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SendFd is a wrapper around the C function g_unix_connection_send_fd.
func (recv *UnixConnection) SendFd(fd int32, cancellable *Cancellable) (bool, error) {
	c_fd := (C.gint)(fd)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_unix_connection_send_fd((*C.GUnixConnection)(recv.native), c_fd, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// UnixCredentialsMessage is a wrapper around the C record GUnixCredentialsMessage.
type UnixCredentialsMessage struct {
	native *C.GUnixCredentialsMessage
	// parent_instance : record
	// priv : record
}

func UnixCredentialsMessageNewFromC(u unsafe.Pointer) *UnixCredentialsMessage {
	c := (*C.GUnixCredentialsMessage)(u)
	if c == nil {
		return nil
	}

	g := &UnixCredentialsMessage{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UnixCredentialsMessage) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UnixCredentialsMessage) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixCredentialsMessage with another UnixCredentialsMessage, and returns true if they represent the same GObject.
func (recv *UnixCredentialsMessage) Equals(other *UnixCredentialsMessage) bool {
	return other.ToC() == recv.ToC()
}

// SocketControlMessage upcasts to *SocketControlMessage
func (recv *UnixCredentialsMessage) SocketControlMessage() *SocketControlMessage {
	return SocketControlMessageNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *UnixCredentialsMessage) Object() *gobject.Object {
	return recv.SocketControlMessage().Object()
}

// CastToWidget down casts any arbitrary Object to UnixCredentialsMessage.
// Exercise care, as this is a potentially dangerous function if the Object is not a UnixCredentialsMessage.
func CastToUnixCredentialsMessage(object *gobject.Object) *UnixCredentialsMessage {
	return UnixCredentialsMessageNewFromC(object.ToC())
}

// UnixCredentialsMessageNew is a wrapper around the C function g_unix_credentials_message_new.
func UnixCredentialsMessageNew() *UnixCredentialsMessage {
	retC := C.g_unix_credentials_message_new()
	retGo := UnixCredentialsMessageNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// UnixCredentialsMessageNewWithCredentials is a wrapper around the C function g_unix_credentials_message_new_with_credentials.
func UnixCredentialsMessageNewWithCredentials(credentials *Credentials) *UnixCredentialsMessage {
	c_credentials := (*C.GCredentials)(C.NULL)
	if credentials != nil {
		c_credentials = (*C.GCredentials)(credentials.ToC())
	}

	retC := C.g_unix_credentials_message_new_with_credentials(c_credentials)
	retGo := UnixCredentialsMessageNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// UnixCredentialsMessageIsSupported is a wrapper around the C function g_unix_credentials_message_is_supported.
func UnixCredentialsMessageIsSupported() bool {
	retC := C.g_unix_credentials_message_is_supported()
	retGo := retC == C.TRUE

	return retGo
}

// GetCredentials is a wrapper around the C function g_unix_credentials_message_get_credentials.
func (recv *UnixCredentialsMessage) GetCredentials() *Credentials {
	retC := C.g_unix_credentials_message_get_credentials((*C.GUnixCredentialsMessage)(recv.native))
	retGo := CredentialsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// UnixFDList is a wrapper around the C record GUnixFDList.
type UnixFDList struct {
	native *C.GUnixFDList
	// parent_instance : record
	// priv : record
}

func UnixFDListNewFromC(u unsafe.Pointer) *UnixFDList {
	c := (*C.GUnixFDList)(u)
	if c == nil {
		return nil
	}

	g := &UnixFDList{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UnixFDList) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UnixFDList) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixFDList with another UnixFDList, and returns true if they represent the same GObject.
func (recv *UnixFDList) Equals(other *UnixFDList) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *UnixFDList) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to UnixFDList.
// Exercise care, as this is a potentially dangerous function if the Object is not a UnixFDList.
func CastToUnixFDList(object *gobject.Object) *UnixFDList {
	return UnixFDListNewFromC(object.ToC())
}

// UnixFDListNew is a wrapper around the C function g_unix_fd_list_new.
func UnixFDListNew() *UnixFDList {
	retC := C.g_unix_fd_list_new()
	retGo := UnixFDListNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// UnixFDListNewFromArray is a wrapper around the C function g_unix_fd_list_new_from_array.
func UnixFDListNewFromArray(fds []int32) *UnixFDList {
	c_fds_array := make([]C.gint, len(fds)+1, len(fds)+1)
	for i, item := range fds {
		c := (C.gint)(item)
		c_fds_array[i] = c
	}
	c_fds_array[len(fds)] = 0
	c_fds_arrayPtr := &c_fds_array[0]
	c_fds := (*C.gint)(unsafe.Pointer(c_fds_arrayPtr))

	c_n_fds := (C.gint)(len(fds))

	retC := C.g_unix_fd_list_new_from_array(c_fds, c_n_fds)
	retGo := UnixFDListNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Append is a wrapper around the C function g_unix_fd_list_append.
func (recv *UnixFDList) Append(fd int32) (int32, error) {
	c_fd := (C.gint)(fd)

	var cThrowableError *C.GError

	retC := C.g_unix_fd_list_append((*C.GUnixFDList)(recv.native), c_fd, &cThrowableError)
	retGo := (int32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Get is a wrapper around the C function g_unix_fd_list_get.
func (recv *UnixFDList) Get(index int32) (int32, error) {
	c_index_ := (C.gint)(index)

	var cThrowableError *C.GError

	retC := C.g_unix_fd_list_get((*C.GUnixFDList)(recv.native), c_index_, &cThrowableError)
	retGo := (int32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetLength is a wrapper around the C function g_unix_fd_list_get_length.
func (recv *UnixFDList) GetLength() int32 {
	retC := C.g_unix_fd_list_get_length((*C.GUnixFDList)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Unsupported : g_unix_fd_list_peek_fds : array return type :

// Unsupported : g_unix_fd_list_steal_fds : array return type :

// UnixFDMessage is a wrapper around the C record GUnixFDMessage.
type UnixFDMessage struct {
	native *C.GUnixFDMessage
	// parent_instance : record
	// priv : record
}

func UnixFDMessageNewFromC(u unsafe.Pointer) *UnixFDMessage {
	c := (*C.GUnixFDMessage)(u)
	if c == nil {
		return nil
	}

	g := &UnixFDMessage{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UnixFDMessage) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UnixFDMessage) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixFDMessage with another UnixFDMessage, and returns true if they represent the same GObject.
func (recv *UnixFDMessage) Equals(other *UnixFDMessage) bool {
	return other.ToC() == recv.ToC()
}

// SocketControlMessage upcasts to *SocketControlMessage
func (recv *UnixFDMessage) SocketControlMessage() *SocketControlMessage {
	return SocketControlMessageNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *UnixFDMessage) Object() *gobject.Object {
	return recv.SocketControlMessage().Object()
}

// CastToWidget down casts any arbitrary Object to UnixFDMessage.
// Exercise care, as this is a potentially dangerous function if the Object is not a UnixFDMessage.
func CastToUnixFDMessage(object *gobject.Object) *UnixFDMessage {
	return UnixFDMessageNewFromC(object.ToC())
}

// UnixFDMessageNew is a wrapper around the C function g_unix_fd_message_new.
func UnixFDMessageNew() *UnixFDMessage {
	retC := C.g_unix_fd_message_new()
	retGo := UnixFDMessageNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// UnixFDMessageNewWithFdList is a wrapper around the C function g_unix_fd_message_new_with_fd_list.
func UnixFDMessageNewWithFdList(fdList *UnixFDList) *UnixFDMessage {
	c_fd_list := (*C.GUnixFDList)(C.NULL)
	if fdList != nil {
		c_fd_list = (*C.GUnixFDList)(fdList.ToC())
	}

	retC := C.g_unix_fd_message_new_with_fd_list(c_fd_list)
	retGo := UnixFDMessageNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AppendFd is a wrapper around the C function g_unix_fd_message_append_fd.
func (recv *UnixFDMessage) AppendFd(fd int32) (bool, error) {
	c_fd := (C.gint)(fd)

	var cThrowableError *C.GError

	retC := C.g_unix_fd_message_append_fd((*C.GUnixFDMessage)(recv.native), c_fd, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetFdList is a wrapper around the C function g_unix_fd_message_get_fd_list.
func (recv *UnixFDMessage) GetFdList() *UnixFDList {
	retC := C.g_unix_fd_message_get_fd_list((*C.GUnixFDMessage)(recv.native))
	retGo := UnixFDListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : g_unix_fd_message_steal_fds : array return type :

// UnixInputStream is a wrapper around the C record GUnixInputStream.
type UnixInputStream struct {
	native *C.GUnixInputStream
	// parent_instance : record
	// Private : priv
}

func UnixInputStreamNewFromC(u unsafe.Pointer) *UnixInputStream {
	c := (*C.GUnixInputStream)(u)
	if c == nil {
		return nil
	}

	g := &UnixInputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UnixInputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UnixInputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixInputStream with another UnixInputStream, and returns true if they represent the same GObject.
func (recv *UnixInputStream) Equals(other *UnixInputStream) bool {
	return other.ToC() == recv.ToC()
}

// InputStream upcasts to *InputStream
func (recv *UnixInputStream) InputStream() *InputStream {
	return InputStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *UnixInputStream) Object() *gobject.Object {
	return recv.InputStream().Object()
}

// CastToWidget down casts any arbitrary Object to UnixInputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a UnixInputStream.
func CastToUnixInputStream(object *gobject.Object) *UnixInputStream {
	return UnixInputStreamNewFromC(object.ToC())
}

// UnixInputStreamNew is a wrapper around the C function g_unix_input_stream_new.
func UnixInputStreamNew(fd int32, closeFd bool) *UnixInputStream {
	c_fd := (C.gint)(fd)

	c_close_fd :=
		boolToGboolean(closeFd)

	retC := C.g_unix_input_stream_new(c_fd, c_close_fd)
	retGo := UnixInputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetCloseFd is a wrapper around the C function g_unix_input_stream_get_close_fd.
func (recv *UnixInputStream) GetCloseFd() bool {
	retC := C.g_unix_input_stream_get_close_fd((*C.GUnixInputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetFd is a wrapper around the C function g_unix_input_stream_get_fd.
func (recv *UnixInputStream) GetFd() int32 {
	retC := C.g_unix_input_stream_get_fd((*C.GUnixInputStream)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// SetCloseFd is a wrapper around the C function g_unix_input_stream_set_close_fd.
func (recv *UnixInputStream) SetCloseFd(closeFd bool) {
	c_close_fd :=
		boolToGboolean(closeFd)

	C.g_unix_input_stream_set_close_fd((*C.GUnixInputStream)(recv.native), c_close_fd)

	return
}

// FileDescriptorBased returns the FileDescriptorBased interface implemented by UnixInputStream
func (recv *UnixInputStream) FileDescriptorBased() *FileDescriptorBased {
	return FileDescriptorBasedNewFromC(recv.ToC())
}

// PollableInputStream returns the PollableInputStream interface implemented by UnixInputStream
func (recv *UnixInputStream) PollableInputStream() *PollableInputStream {
	return PollableInputStreamNewFromC(recv.ToC())
}

// UnixMountMonitor is a wrapper around the C record GUnixMountMonitor.
type UnixMountMonitor struct {
	native *C.GUnixMountMonitor
}

func UnixMountMonitorNewFromC(u unsafe.Pointer) *UnixMountMonitor {
	c := (*C.GUnixMountMonitor)(u)
	if c == nil {
		return nil
	}

	g := &UnixMountMonitor{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UnixMountMonitor) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UnixMountMonitor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixMountMonitor with another UnixMountMonitor, and returns true if they represent the same GObject.
func (recv *UnixMountMonitor) Equals(other *UnixMountMonitor) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *UnixMountMonitor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to UnixMountMonitor.
// Exercise care, as this is a potentially dangerous function if the Object is not a UnixMountMonitor.
func CastToUnixMountMonitor(object *gobject.Object) *UnixMountMonitor {
	return UnixMountMonitorNewFromC(object.ToC())
}

type signalUnixMountMonitorMountpointsChangedDetail struct {
	callback  UnixMountMonitorSignalMountpointsChangedCallback
	handlerID C.gulong
}

var signalUnixMountMonitorMountpointsChangedId int
var signalUnixMountMonitorMountpointsChangedMap = make(map[int]signalUnixMountMonitorMountpointsChangedDetail)
var signalUnixMountMonitorMountpointsChangedLock sync.RWMutex

// UnixMountMonitorSignalMountpointsChangedCallback is a callback function for a 'mountpoints-changed' signal emitted from a UnixMountMonitor.
type UnixMountMonitorSignalMountpointsChangedCallback func()

/*
ConnectMountpointsChanged connects the callback to the 'mountpoints-changed' signal for the UnixMountMonitor.

The returned value represents the connection, and may be passed to DisconnectMountpointsChanged to remove it.
*/
func (recv *UnixMountMonitor) ConnectMountpointsChanged(callback UnixMountMonitorSignalMountpointsChangedCallback) int {
	signalUnixMountMonitorMountpointsChangedLock.Lock()
	defer signalUnixMountMonitorMountpointsChangedLock.Unlock()

	signalUnixMountMonitorMountpointsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.UnixMountMonitor_signal_connect_mountpoints_changed(instance, C.gpointer(uintptr(signalUnixMountMonitorMountpointsChangedId)))

	detail := signalUnixMountMonitorMountpointsChangedDetail{callback, handlerID}
	signalUnixMountMonitorMountpointsChangedMap[signalUnixMountMonitorMountpointsChangedId] = detail

	return signalUnixMountMonitorMountpointsChangedId
}

/*
DisconnectMountpointsChanged disconnects a callback from the 'mountpoints-changed' signal for the UnixMountMonitor.

The connectionID should be a value returned from a call to ConnectMountpointsChanged.
*/
func (recv *UnixMountMonitor) DisconnectMountpointsChanged(connectionID int) {
	signalUnixMountMonitorMountpointsChangedLock.Lock()
	defer signalUnixMountMonitorMountpointsChangedLock.Unlock()

	detail, exists := signalUnixMountMonitorMountpointsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalUnixMountMonitorMountpointsChangedMap, connectionID)
}

//export unixmountmonitor_mountpointsChangedHandler
func unixmountmonitor_mountpointsChangedHandler(_ *C.GObject, data C.gpointer) {
	signalUnixMountMonitorMountpointsChangedLock.RLock()
	defer signalUnixMountMonitorMountpointsChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalUnixMountMonitorMountpointsChangedMap[index].callback
	callback()
}

type signalUnixMountMonitorMountsChangedDetail struct {
	callback  UnixMountMonitorSignalMountsChangedCallback
	handlerID C.gulong
}

var signalUnixMountMonitorMountsChangedId int
var signalUnixMountMonitorMountsChangedMap = make(map[int]signalUnixMountMonitorMountsChangedDetail)
var signalUnixMountMonitorMountsChangedLock sync.RWMutex

// UnixMountMonitorSignalMountsChangedCallback is a callback function for a 'mounts-changed' signal emitted from a UnixMountMonitor.
type UnixMountMonitorSignalMountsChangedCallback func()

/*
ConnectMountsChanged connects the callback to the 'mounts-changed' signal for the UnixMountMonitor.

The returned value represents the connection, and may be passed to DisconnectMountsChanged to remove it.
*/
func (recv *UnixMountMonitor) ConnectMountsChanged(callback UnixMountMonitorSignalMountsChangedCallback) int {
	signalUnixMountMonitorMountsChangedLock.Lock()
	defer signalUnixMountMonitorMountsChangedLock.Unlock()

	signalUnixMountMonitorMountsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.UnixMountMonitor_signal_connect_mounts_changed(instance, C.gpointer(uintptr(signalUnixMountMonitorMountsChangedId)))

	detail := signalUnixMountMonitorMountsChangedDetail{callback, handlerID}
	signalUnixMountMonitorMountsChangedMap[signalUnixMountMonitorMountsChangedId] = detail

	return signalUnixMountMonitorMountsChangedId
}

/*
DisconnectMountsChanged disconnects a callback from the 'mounts-changed' signal for the UnixMountMonitor.

The connectionID should be a value returned from a call to ConnectMountsChanged.
*/
func (recv *UnixMountMonitor) DisconnectMountsChanged(connectionID int) {
	signalUnixMountMonitorMountsChangedLock.Lock()
	defer signalUnixMountMonitorMountsChangedLock.Unlock()

	detail, exists := signalUnixMountMonitorMountsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalUnixMountMonitorMountsChangedMap, connectionID)
}

//export unixmountmonitor_mountsChangedHandler
func unixmountmonitor_mountsChangedHandler(_ *C.GObject, data C.gpointer) {
	signalUnixMountMonitorMountsChangedLock.RLock()
	defer signalUnixMountMonitorMountsChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalUnixMountMonitorMountsChangedMap[index].callback
	callback()
}

// UnixMountMonitorNew is a wrapper around the C function g_unix_mount_monitor_new.
func UnixMountMonitorNew() *UnixMountMonitor {
	retC := C.g_unix_mount_monitor_new()
	retGo := UnixMountMonitorNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// SetRateLimit is a wrapper around the C function g_unix_mount_monitor_set_rate_limit.
func (recv *UnixMountMonitor) SetRateLimit(limitMsec int32) {
	c_limit_msec := (C.int)(limitMsec)

	C.g_unix_mount_monitor_set_rate_limit((*C.GUnixMountMonitor)(recv.native), c_limit_msec)

	return
}

// UnixOutputStream is a wrapper around the C record GUnixOutputStream.
type UnixOutputStream struct {
	native *C.GUnixOutputStream
	// parent_instance : record
	// Private : priv
}

func UnixOutputStreamNewFromC(u unsafe.Pointer) *UnixOutputStream {
	c := (*C.GUnixOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &UnixOutputStream{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UnixOutputStream) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UnixOutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixOutputStream with another UnixOutputStream, and returns true if they represent the same GObject.
func (recv *UnixOutputStream) Equals(other *UnixOutputStream) bool {
	return other.ToC() == recv.ToC()
}

// OutputStream upcasts to *OutputStream
func (recv *UnixOutputStream) OutputStream() *OutputStream {
	return OutputStreamNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *UnixOutputStream) Object() *gobject.Object {
	return recv.OutputStream().Object()
}

// CastToWidget down casts any arbitrary Object to UnixOutputStream.
// Exercise care, as this is a potentially dangerous function if the Object is not a UnixOutputStream.
func CastToUnixOutputStream(object *gobject.Object) *UnixOutputStream {
	return UnixOutputStreamNewFromC(object.ToC())
}

// UnixOutputStreamNew is a wrapper around the C function g_unix_output_stream_new.
func UnixOutputStreamNew(fd int32, closeFd bool) *UnixOutputStream {
	c_fd := (C.gint)(fd)

	c_close_fd :=
		boolToGboolean(closeFd)

	retC := C.g_unix_output_stream_new(c_fd, c_close_fd)
	retGo := UnixOutputStreamNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetCloseFd is a wrapper around the C function g_unix_output_stream_get_close_fd.
func (recv *UnixOutputStream) GetCloseFd() bool {
	retC := C.g_unix_output_stream_get_close_fd((*C.GUnixOutputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetFd is a wrapper around the C function g_unix_output_stream_get_fd.
func (recv *UnixOutputStream) GetFd() int32 {
	retC := C.g_unix_output_stream_get_fd((*C.GUnixOutputStream)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// SetCloseFd is a wrapper around the C function g_unix_output_stream_set_close_fd.
func (recv *UnixOutputStream) SetCloseFd(closeFd bool) {
	c_close_fd :=
		boolToGboolean(closeFd)

	C.g_unix_output_stream_set_close_fd((*C.GUnixOutputStream)(recv.native), c_close_fd)

	return
}

// FileDescriptorBased returns the FileDescriptorBased interface implemented by UnixOutputStream
func (recv *UnixOutputStream) FileDescriptorBased() *FileDescriptorBased {
	return FileDescriptorBasedNewFromC(recv.ToC())
}

// PollableOutputStream returns the PollableOutputStream interface implemented by UnixOutputStream
func (recv *UnixOutputStream) PollableOutputStream() *PollableOutputStream {
	return PollableOutputStreamNewFromC(recv.ToC())
}

// UnixSocketAddress is a wrapper around the C record GUnixSocketAddress.
type UnixSocketAddress struct {
	native *C.GUnixSocketAddress
	// parent_instance : record
	// Private : priv
}

func UnixSocketAddressNewFromC(u unsafe.Pointer) *UnixSocketAddress {
	c := (*C.GUnixSocketAddress)(u)
	if c == nil {
		return nil
	}

	g := &UnixSocketAddress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UnixSocketAddress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UnixSocketAddress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixSocketAddress with another UnixSocketAddress, and returns true if they represent the same GObject.
func (recv *UnixSocketAddress) Equals(other *UnixSocketAddress) bool {
	return other.ToC() == recv.ToC()
}

// SocketAddress upcasts to *SocketAddress
func (recv *UnixSocketAddress) SocketAddress() *SocketAddress {
	return SocketAddressNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *UnixSocketAddress) Object() *gobject.Object {
	return recv.SocketAddress().Object()
}

// CastToWidget down casts any arbitrary Object to UnixSocketAddress.
// Exercise care, as this is a potentially dangerous function if the Object is not a UnixSocketAddress.
func CastToUnixSocketAddress(object *gobject.Object) *UnixSocketAddress {
	return UnixSocketAddressNewFromC(object.ToC())
}

// UnixSocketAddressNew is a wrapper around the C function g_unix_socket_address_new.
func UnixSocketAddressNew(path string) *UnixSocketAddress {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.g_unix_socket_address_new(c_path)
	retGo := UnixSocketAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// UnixSocketAddressNewAbstract is a wrapper around the C function g_unix_socket_address_new_abstract.
func UnixSocketAddressNewAbstract(path []rune) *UnixSocketAddress {
	c_path_array := make([]C.gchar, len(path)+1, len(path)+1)
	for i, item := range path {
		c := (C.gchar)(item)
		c_path_array[i] = c
	}
	c_path_array[len(path)] = 0
	c_path_arrayPtr := &c_path_array[0]
	c_path := (*C.gchar)(unsafe.Pointer(c_path_arrayPtr))

	c_path_len := (C.gint)(len(path))

	retC := C.g_unix_socket_address_new_abstract(c_path, c_path_len)
	retGo := UnixSocketAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// UnixSocketAddressNewWithType is a wrapper around the C function g_unix_socket_address_new_with_type.
func UnixSocketAddressNewWithType(path []rune, type_ UnixSocketAddressType) *UnixSocketAddress {
	c_path_array := make([]C.gchar, len(path)+1, len(path)+1)
	for i, item := range path {
		c := (C.gchar)(item)
		c_path_array[i] = c
	}
	c_path_array[len(path)] = 0
	c_path_arrayPtr := &c_path_array[0]
	c_path := (*C.gchar)(unsafe.Pointer(c_path_arrayPtr))

	c_path_len := (C.gint)(len(path))

	c_type := (C.GUnixSocketAddressType)(type_)

	retC := C.g_unix_socket_address_new_with_type(c_path, c_path_len, c_type)
	retGo := UnixSocketAddressNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// UnixSocketAddressAbstractNamesSupported is a wrapper around the C function g_unix_socket_address_abstract_names_supported.
func UnixSocketAddressAbstractNamesSupported() bool {
	retC := C.g_unix_socket_address_abstract_names_supported()
	retGo := retC == C.TRUE

	return retGo
}

// GetAddressType is a wrapper around the C function g_unix_socket_address_get_address_type.
func (recv *UnixSocketAddress) GetAddressType() UnixSocketAddressType {
	retC := C.g_unix_socket_address_get_address_type((*C.GUnixSocketAddress)(recv.native))
	retGo := (UnixSocketAddressType)(retC)

	return retGo
}

// GetIsAbstract is a wrapper around the C function g_unix_socket_address_get_is_abstract.
func (recv *UnixSocketAddress) GetIsAbstract() bool {
	retC := C.g_unix_socket_address_get_is_abstract((*C.GUnixSocketAddress)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPath is a wrapper around the C function g_unix_socket_address_get_path.
func (recv *UnixSocketAddress) GetPath() string {
	retC := C.g_unix_socket_address_get_path((*C.GUnixSocketAddress)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPathLen is a wrapper around the C function g_unix_socket_address_get_path_len.
func (recv *UnixSocketAddress) GetPathLen() uint64 {
	retC := C.g_unix_socket_address_get_path_len((*C.GUnixSocketAddress)(recv.native))
	retGo := (uint64)(retC)

	return retGo
}

// SocketConnectable returns the SocketConnectable interface implemented by UnixSocketAddress
func (recv *UnixSocketAddress) SocketConnectable() *SocketConnectable {
	return SocketConnectableNewFromC(recv.ToC())
}

// Vfs is a wrapper around the C record GVfs.
type Vfs struct {
	native *C.GVfs
	// parent_instance : record
}

func VfsNewFromC(u unsafe.Pointer) *Vfs {
	c := (*C.GVfs)(u)
	if c == nil {
		return nil
	}

	g := &Vfs{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Vfs) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Vfs) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Vfs with another Vfs, and returns true if they represent the same GObject.
func (recv *Vfs) Equals(other *Vfs) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Vfs) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Vfs.
// Exercise care, as this is a potentially dangerous function if the Object is not a Vfs.
func CastToVfs(object *gobject.Object) *Vfs {
	return VfsNewFromC(object.ToC())
}

// VfsGetDefault is a wrapper around the C function g_vfs_get_default.
func VfsGetDefault() *Vfs {
	retC := C.g_vfs_get_default()
	retGo := VfsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// VfsGetLocal is a wrapper around the C function g_vfs_get_local.
func VfsGetLocal() *Vfs {
	retC := C.g_vfs_get_local()
	retGo := VfsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFileForPath is a wrapper around the C function g_vfs_get_file_for_path.
func (recv *Vfs) GetFileForPath(path string) *File {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.g_vfs_get_file_for_path((*C.GVfs)(recv.native), c_path)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFileForUri is a wrapper around the C function g_vfs_get_file_for_uri.
func (recv *Vfs) GetFileForUri(uri string) *File {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	retC := C.g_vfs_get_file_for_uri((*C.GVfs)(recv.native), c_uri)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSupportedUriSchemes is a wrapper around the C function g_vfs_get_supported_uri_schemes.
func (recv *Vfs) GetSupportedUriSchemes() []string {
	retC := C.g_vfs_get_supported_uri_schemes((*C.GVfs)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// IsActive is a wrapper around the C function g_vfs_is_active.
func (recv *Vfs) IsActive() bool {
	retC := C.g_vfs_is_active((*C.GVfs)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ParseName is a wrapper around the C function g_vfs_parse_name.
func (recv *Vfs) ParseName(parseName string) *File {
	c_parse_name := C.CString(parseName)
	defer C.free(unsafe.Pointer(c_parse_name))

	retC := C.g_vfs_parse_name((*C.GVfs)(recv.native), c_parse_name)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// VolumeMonitor is a wrapper around the C record GVolumeMonitor.
type VolumeMonitor struct {
	native *C.GVolumeMonitor
	// parent_instance : record
	// Private : priv
}

func VolumeMonitorNewFromC(u unsafe.Pointer) *VolumeMonitor {
	c := (*C.GVolumeMonitor)(u)
	if c == nil {
		return nil
	}

	g := &VolumeMonitor{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VolumeMonitor) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VolumeMonitor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VolumeMonitor with another VolumeMonitor, and returns true if they represent the same GObject.
func (recv *VolumeMonitor) Equals(other *VolumeMonitor) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *VolumeMonitor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to VolumeMonitor.
// Exercise care, as this is a potentially dangerous function if the Object is not a VolumeMonitor.
func CastToVolumeMonitor(object *gobject.Object) *VolumeMonitor {
	return VolumeMonitorNewFromC(object.ToC())
}

type signalVolumeMonitorDriveChangedDetail struct {
	callback  VolumeMonitorSignalDriveChangedCallback
	handlerID C.gulong
}

var signalVolumeMonitorDriveChangedId int
var signalVolumeMonitorDriveChangedMap = make(map[int]signalVolumeMonitorDriveChangedDetail)
var signalVolumeMonitorDriveChangedLock sync.RWMutex

// VolumeMonitorSignalDriveChangedCallback is a callback function for a 'drive-changed' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalDriveChangedCallback func(drive *Drive)

/*
ConnectDriveChanged connects the callback to the 'drive-changed' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectDriveChanged to remove it.
*/
func (recv *VolumeMonitor) ConnectDriveChanged(callback VolumeMonitorSignalDriveChangedCallback) int {
	signalVolumeMonitorDriveChangedLock.Lock()
	defer signalVolumeMonitorDriveChangedLock.Unlock()

	signalVolumeMonitorDriveChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_drive_changed(instance, C.gpointer(uintptr(signalVolumeMonitorDriveChangedId)))

	detail := signalVolumeMonitorDriveChangedDetail{callback, handlerID}
	signalVolumeMonitorDriveChangedMap[signalVolumeMonitorDriveChangedId] = detail

	return signalVolumeMonitorDriveChangedId
}

/*
DisconnectDriveChanged disconnects a callback from the 'drive-changed' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectDriveChanged.
*/
func (recv *VolumeMonitor) DisconnectDriveChanged(connectionID int) {
	signalVolumeMonitorDriveChangedLock.Lock()
	defer signalVolumeMonitorDriveChangedLock.Unlock()

	detail, exists := signalVolumeMonitorDriveChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorDriveChangedMap, connectionID)
}

//export volumemonitor_driveChangedHandler
func volumemonitor_driveChangedHandler(_ *C.GObject, c_drive *C.GDrive, data C.gpointer) {
	signalVolumeMonitorDriveChangedLock.RLock()
	defer signalVolumeMonitorDriveChangedLock.RUnlock()

	drive := DriveNewFromC(unsafe.Pointer(c_drive))

	index := int(uintptr(data))
	callback := signalVolumeMonitorDriveChangedMap[index].callback
	callback(drive)
}

type signalVolumeMonitorDriveConnectedDetail struct {
	callback  VolumeMonitorSignalDriveConnectedCallback
	handlerID C.gulong
}

var signalVolumeMonitorDriveConnectedId int
var signalVolumeMonitorDriveConnectedMap = make(map[int]signalVolumeMonitorDriveConnectedDetail)
var signalVolumeMonitorDriveConnectedLock sync.RWMutex

// VolumeMonitorSignalDriveConnectedCallback is a callback function for a 'drive-connected' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalDriveConnectedCallback func(drive *Drive)

/*
ConnectDriveConnected connects the callback to the 'drive-connected' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectDriveConnected to remove it.
*/
func (recv *VolumeMonitor) ConnectDriveConnected(callback VolumeMonitorSignalDriveConnectedCallback) int {
	signalVolumeMonitorDriveConnectedLock.Lock()
	defer signalVolumeMonitorDriveConnectedLock.Unlock()

	signalVolumeMonitorDriveConnectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_drive_connected(instance, C.gpointer(uintptr(signalVolumeMonitorDriveConnectedId)))

	detail := signalVolumeMonitorDriveConnectedDetail{callback, handlerID}
	signalVolumeMonitorDriveConnectedMap[signalVolumeMonitorDriveConnectedId] = detail

	return signalVolumeMonitorDriveConnectedId
}

/*
DisconnectDriveConnected disconnects a callback from the 'drive-connected' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectDriveConnected.
*/
func (recv *VolumeMonitor) DisconnectDriveConnected(connectionID int) {
	signalVolumeMonitorDriveConnectedLock.Lock()
	defer signalVolumeMonitorDriveConnectedLock.Unlock()

	detail, exists := signalVolumeMonitorDriveConnectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorDriveConnectedMap, connectionID)
}

//export volumemonitor_driveConnectedHandler
func volumemonitor_driveConnectedHandler(_ *C.GObject, c_drive *C.GDrive, data C.gpointer) {
	signalVolumeMonitorDriveConnectedLock.RLock()
	defer signalVolumeMonitorDriveConnectedLock.RUnlock()

	drive := DriveNewFromC(unsafe.Pointer(c_drive))

	index := int(uintptr(data))
	callback := signalVolumeMonitorDriveConnectedMap[index].callback
	callback(drive)
}

type signalVolumeMonitorDriveDisconnectedDetail struct {
	callback  VolumeMonitorSignalDriveDisconnectedCallback
	handlerID C.gulong
}

var signalVolumeMonitorDriveDisconnectedId int
var signalVolumeMonitorDriveDisconnectedMap = make(map[int]signalVolumeMonitorDriveDisconnectedDetail)
var signalVolumeMonitorDriveDisconnectedLock sync.RWMutex

// VolumeMonitorSignalDriveDisconnectedCallback is a callback function for a 'drive-disconnected' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalDriveDisconnectedCallback func(drive *Drive)

/*
ConnectDriveDisconnected connects the callback to the 'drive-disconnected' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectDriveDisconnected to remove it.
*/
func (recv *VolumeMonitor) ConnectDriveDisconnected(callback VolumeMonitorSignalDriveDisconnectedCallback) int {
	signalVolumeMonitorDriveDisconnectedLock.Lock()
	defer signalVolumeMonitorDriveDisconnectedLock.Unlock()

	signalVolumeMonitorDriveDisconnectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_drive_disconnected(instance, C.gpointer(uintptr(signalVolumeMonitorDriveDisconnectedId)))

	detail := signalVolumeMonitorDriveDisconnectedDetail{callback, handlerID}
	signalVolumeMonitorDriveDisconnectedMap[signalVolumeMonitorDriveDisconnectedId] = detail

	return signalVolumeMonitorDriveDisconnectedId
}

/*
DisconnectDriveDisconnected disconnects a callback from the 'drive-disconnected' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectDriveDisconnected.
*/
func (recv *VolumeMonitor) DisconnectDriveDisconnected(connectionID int) {
	signalVolumeMonitorDriveDisconnectedLock.Lock()
	defer signalVolumeMonitorDriveDisconnectedLock.Unlock()

	detail, exists := signalVolumeMonitorDriveDisconnectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorDriveDisconnectedMap, connectionID)
}

//export volumemonitor_driveDisconnectedHandler
func volumemonitor_driveDisconnectedHandler(_ *C.GObject, c_drive *C.GDrive, data C.gpointer) {
	signalVolumeMonitorDriveDisconnectedLock.RLock()
	defer signalVolumeMonitorDriveDisconnectedLock.RUnlock()

	drive := DriveNewFromC(unsafe.Pointer(c_drive))

	index := int(uintptr(data))
	callback := signalVolumeMonitorDriveDisconnectedMap[index].callback
	callback(drive)
}

type signalVolumeMonitorDriveEjectButtonDetail struct {
	callback  VolumeMonitorSignalDriveEjectButtonCallback
	handlerID C.gulong
}

var signalVolumeMonitorDriveEjectButtonId int
var signalVolumeMonitorDriveEjectButtonMap = make(map[int]signalVolumeMonitorDriveEjectButtonDetail)
var signalVolumeMonitorDriveEjectButtonLock sync.RWMutex

// VolumeMonitorSignalDriveEjectButtonCallback is a callback function for a 'drive-eject-button' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalDriveEjectButtonCallback func(drive *Drive)

/*
ConnectDriveEjectButton connects the callback to the 'drive-eject-button' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectDriveEjectButton to remove it.
*/
func (recv *VolumeMonitor) ConnectDriveEjectButton(callback VolumeMonitorSignalDriveEjectButtonCallback) int {
	signalVolumeMonitorDriveEjectButtonLock.Lock()
	defer signalVolumeMonitorDriveEjectButtonLock.Unlock()

	signalVolumeMonitorDriveEjectButtonId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_drive_eject_button(instance, C.gpointer(uintptr(signalVolumeMonitorDriveEjectButtonId)))

	detail := signalVolumeMonitorDriveEjectButtonDetail{callback, handlerID}
	signalVolumeMonitorDriveEjectButtonMap[signalVolumeMonitorDriveEjectButtonId] = detail

	return signalVolumeMonitorDriveEjectButtonId
}

/*
DisconnectDriveEjectButton disconnects a callback from the 'drive-eject-button' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectDriveEjectButton.
*/
func (recv *VolumeMonitor) DisconnectDriveEjectButton(connectionID int) {
	signalVolumeMonitorDriveEjectButtonLock.Lock()
	defer signalVolumeMonitorDriveEjectButtonLock.Unlock()

	detail, exists := signalVolumeMonitorDriveEjectButtonMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorDriveEjectButtonMap, connectionID)
}

//export volumemonitor_driveEjectButtonHandler
func volumemonitor_driveEjectButtonHandler(_ *C.GObject, c_drive *C.GDrive, data C.gpointer) {
	signalVolumeMonitorDriveEjectButtonLock.RLock()
	defer signalVolumeMonitorDriveEjectButtonLock.RUnlock()

	drive := DriveNewFromC(unsafe.Pointer(c_drive))

	index := int(uintptr(data))
	callback := signalVolumeMonitorDriveEjectButtonMap[index].callback
	callback(drive)
}

type signalVolumeMonitorDriveStopButtonDetail struct {
	callback  VolumeMonitorSignalDriveStopButtonCallback
	handlerID C.gulong
}

var signalVolumeMonitorDriveStopButtonId int
var signalVolumeMonitorDriveStopButtonMap = make(map[int]signalVolumeMonitorDriveStopButtonDetail)
var signalVolumeMonitorDriveStopButtonLock sync.RWMutex

// VolumeMonitorSignalDriveStopButtonCallback is a callback function for a 'drive-stop-button' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalDriveStopButtonCallback func(drive *Drive)

/*
ConnectDriveStopButton connects the callback to the 'drive-stop-button' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectDriveStopButton to remove it.
*/
func (recv *VolumeMonitor) ConnectDriveStopButton(callback VolumeMonitorSignalDriveStopButtonCallback) int {
	signalVolumeMonitorDriveStopButtonLock.Lock()
	defer signalVolumeMonitorDriveStopButtonLock.Unlock()

	signalVolumeMonitorDriveStopButtonId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_drive_stop_button(instance, C.gpointer(uintptr(signalVolumeMonitorDriveStopButtonId)))

	detail := signalVolumeMonitorDriveStopButtonDetail{callback, handlerID}
	signalVolumeMonitorDriveStopButtonMap[signalVolumeMonitorDriveStopButtonId] = detail

	return signalVolumeMonitorDriveStopButtonId
}

/*
DisconnectDriveStopButton disconnects a callback from the 'drive-stop-button' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectDriveStopButton.
*/
func (recv *VolumeMonitor) DisconnectDriveStopButton(connectionID int) {
	signalVolumeMonitorDriveStopButtonLock.Lock()
	defer signalVolumeMonitorDriveStopButtonLock.Unlock()

	detail, exists := signalVolumeMonitorDriveStopButtonMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorDriveStopButtonMap, connectionID)
}

//export volumemonitor_driveStopButtonHandler
func volumemonitor_driveStopButtonHandler(_ *C.GObject, c_drive *C.GDrive, data C.gpointer) {
	signalVolumeMonitorDriveStopButtonLock.RLock()
	defer signalVolumeMonitorDriveStopButtonLock.RUnlock()

	drive := DriveNewFromC(unsafe.Pointer(c_drive))

	index := int(uintptr(data))
	callback := signalVolumeMonitorDriveStopButtonMap[index].callback
	callback(drive)
}

type signalVolumeMonitorMountAddedDetail struct {
	callback  VolumeMonitorSignalMountAddedCallback
	handlerID C.gulong
}

var signalVolumeMonitorMountAddedId int
var signalVolumeMonitorMountAddedMap = make(map[int]signalVolumeMonitorMountAddedDetail)
var signalVolumeMonitorMountAddedLock sync.RWMutex

// VolumeMonitorSignalMountAddedCallback is a callback function for a 'mount-added' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalMountAddedCallback func(mount *Mount)

/*
ConnectMountAdded connects the callback to the 'mount-added' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectMountAdded to remove it.
*/
func (recv *VolumeMonitor) ConnectMountAdded(callback VolumeMonitorSignalMountAddedCallback) int {
	signalVolumeMonitorMountAddedLock.Lock()
	defer signalVolumeMonitorMountAddedLock.Unlock()

	signalVolumeMonitorMountAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_mount_added(instance, C.gpointer(uintptr(signalVolumeMonitorMountAddedId)))

	detail := signalVolumeMonitorMountAddedDetail{callback, handlerID}
	signalVolumeMonitorMountAddedMap[signalVolumeMonitorMountAddedId] = detail

	return signalVolumeMonitorMountAddedId
}

/*
DisconnectMountAdded disconnects a callback from the 'mount-added' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectMountAdded.
*/
func (recv *VolumeMonitor) DisconnectMountAdded(connectionID int) {
	signalVolumeMonitorMountAddedLock.Lock()
	defer signalVolumeMonitorMountAddedLock.Unlock()

	detail, exists := signalVolumeMonitorMountAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorMountAddedMap, connectionID)
}

//export volumemonitor_mountAddedHandler
func volumemonitor_mountAddedHandler(_ *C.GObject, c_mount *C.GMount, data C.gpointer) {
	signalVolumeMonitorMountAddedLock.RLock()
	defer signalVolumeMonitorMountAddedLock.RUnlock()

	mount := MountNewFromC(unsafe.Pointer(c_mount))

	index := int(uintptr(data))
	callback := signalVolumeMonitorMountAddedMap[index].callback
	callback(mount)
}

type signalVolumeMonitorMountChangedDetail struct {
	callback  VolumeMonitorSignalMountChangedCallback
	handlerID C.gulong
}

var signalVolumeMonitorMountChangedId int
var signalVolumeMonitorMountChangedMap = make(map[int]signalVolumeMonitorMountChangedDetail)
var signalVolumeMonitorMountChangedLock sync.RWMutex

// VolumeMonitorSignalMountChangedCallback is a callback function for a 'mount-changed' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalMountChangedCallback func(mount *Mount)

/*
ConnectMountChanged connects the callback to the 'mount-changed' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectMountChanged to remove it.
*/
func (recv *VolumeMonitor) ConnectMountChanged(callback VolumeMonitorSignalMountChangedCallback) int {
	signalVolumeMonitorMountChangedLock.Lock()
	defer signalVolumeMonitorMountChangedLock.Unlock()

	signalVolumeMonitorMountChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_mount_changed(instance, C.gpointer(uintptr(signalVolumeMonitorMountChangedId)))

	detail := signalVolumeMonitorMountChangedDetail{callback, handlerID}
	signalVolumeMonitorMountChangedMap[signalVolumeMonitorMountChangedId] = detail

	return signalVolumeMonitorMountChangedId
}

/*
DisconnectMountChanged disconnects a callback from the 'mount-changed' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectMountChanged.
*/
func (recv *VolumeMonitor) DisconnectMountChanged(connectionID int) {
	signalVolumeMonitorMountChangedLock.Lock()
	defer signalVolumeMonitorMountChangedLock.Unlock()

	detail, exists := signalVolumeMonitorMountChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorMountChangedMap, connectionID)
}

//export volumemonitor_mountChangedHandler
func volumemonitor_mountChangedHandler(_ *C.GObject, c_mount *C.GMount, data C.gpointer) {
	signalVolumeMonitorMountChangedLock.RLock()
	defer signalVolumeMonitorMountChangedLock.RUnlock()

	mount := MountNewFromC(unsafe.Pointer(c_mount))

	index := int(uintptr(data))
	callback := signalVolumeMonitorMountChangedMap[index].callback
	callback(mount)
}

type signalVolumeMonitorMountPreUnmountDetail struct {
	callback  VolumeMonitorSignalMountPreUnmountCallback
	handlerID C.gulong
}

var signalVolumeMonitorMountPreUnmountId int
var signalVolumeMonitorMountPreUnmountMap = make(map[int]signalVolumeMonitorMountPreUnmountDetail)
var signalVolumeMonitorMountPreUnmountLock sync.RWMutex

// VolumeMonitorSignalMountPreUnmountCallback is a callback function for a 'mount-pre-unmount' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalMountPreUnmountCallback func(mount *Mount)

/*
ConnectMountPreUnmount connects the callback to the 'mount-pre-unmount' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectMountPreUnmount to remove it.
*/
func (recv *VolumeMonitor) ConnectMountPreUnmount(callback VolumeMonitorSignalMountPreUnmountCallback) int {
	signalVolumeMonitorMountPreUnmountLock.Lock()
	defer signalVolumeMonitorMountPreUnmountLock.Unlock()

	signalVolumeMonitorMountPreUnmountId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_mount_pre_unmount(instance, C.gpointer(uintptr(signalVolumeMonitorMountPreUnmountId)))

	detail := signalVolumeMonitorMountPreUnmountDetail{callback, handlerID}
	signalVolumeMonitorMountPreUnmountMap[signalVolumeMonitorMountPreUnmountId] = detail

	return signalVolumeMonitorMountPreUnmountId
}

/*
DisconnectMountPreUnmount disconnects a callback from the 'mount-pre-unmount' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectMountPreUnmount.
*/
func (recv *VolumeMonitor) DisconnectMountPreUnmount(connectionID int) {
	signalVolumeMonitorMountPreUnmountLock.Lock()
	defer signalVolumeMonitorMountPreUnmountLock.Unlock()

	detail, exists := signalVolumeMonitorMountPreUnmountMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorMountPreUnmountMap, connectionID)
}

//export volumemonitor_mountPreUnmountHandler
func volumemonitor_mountPreUnmountHandler(_ *C.GObject, c_mount *C.GMount, data C.gpointer) {
	signalVolumeMonitorMountPreUnmountLock.RLock()
	defer signalVolumeMonitorMountPreUnmountLock.RUnlock()

	mount := MountNewFromC(unsafe.Pointer(c_mount))

	index := int(uintptr(data))
	callback := signalVolumeMonitorMountPreUnmountMap[index].callback
	callback(mount)
}

type signalVolumeMonitorMountRemovedDetail struct {
	callback  VolumeMonitorSignalMountRemovedCallback
	handlerID C.gulong
}

var signalVolumeMonitorMountRemovedId int
var signalVolumeMonitorMountRemovedMap = make(map[int]signalVolumeMonitorMountRemovedDetail)
var signalVolumeMonitorMountRemovedLock sync.RWMutex

// VolumeMonitorSignalMountRemovedCallback is a callback function for a 'mount-removed' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalMountRemovedCallback func(mount *Mount)

/*
ConnectMountRemoved connects the callback to the 'mount-removed' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectMountRemoved to remove it.
*/
func (recv *VolumeMonitor) ConnectMountRemoved(callback VolumeMonitorSignalMountRemovedCallback) int {
	signalVolumeMonitorMountRemovedLock.Lock()
	defer signalVolumeMonitorMountRemovedLock.Unlock()

	signalVolumeMonitorMountRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_mount_removed(instance, C.gpointer(uintptr(signalVolumeMonitorMountRemovedId)))

	detail := signalVolumeMonitorMountRemovedDetail{callback, handlerID}
	signalVolumeMonitorMountRemovedMap[signalVolumeMonitorMountRemovedId] = detail

	return signalVolumeMonitorMountRemovedId
}

/*
DisconnectMountRemoved disconnects a callback from the 'mount-removed' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectMountRemoved.
*/
func (recv *VolumeMonitor) DisconnectMountRemoved(connectionID int) {
	signalVolumeMonitorMountRemovedLock.Lock()
	defer signalVolumeMonitorMountRemovedLock.Unlock()

	detail, exists := signalVolumeMonitorMountRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorMountRemovedMap, connectionID)
}

//export volumemonitor_mountRemovedHandler
func volumemonitor_mountRemovedHandler(_ *C.GObject, c_mount *C.GMount, data C.gpointer) {
	signalVolumeMonitorMountRemovedLock.RLock()
	defer signalVolumeMonitorMountRemovedLock.RUnlock()

	mount := MountNewFromC(unsafe.Pointer(c_mount))

	index := int(uintptr(data))
	callback := signalVolumeMonitorMountRemovedMap[index].callback
	callback(mount)
}

type signalVolumeMonitorVolumeAddedDetail struct {
	callback  VolumeMonitorSignalVolumeAddedCallback
	handlerID C.gulong
}

var signalVolumeMonitorVolumeAddedId int
var signalVolumeMonitorVolumeAddedMap = make(map[int]signalVolumeMonitorVolumeAddedDetail)
var signalVolumeMonitorVolumeAddedLock sync.RWMutex

// VolumeMonitorSignalVolumeAddedCallback is a callback function for a 'volume-added' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalVolumeAddedCallback func(volume *Volume)

/*
ConnectVolumeAdded connects the callback to the 'volume-added' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectVolumeAdded to remove it.
*/
func (recv *VolumeMonitor) ConnectVolumeAdded(callback VolumeMonitorSignalVolumeAddedCallback) int {
	signalVolumeMonitorVolumeAddedLock.Lock()
	defer signalVolumeMonitorVolumeAddedLock.Unlock()

	signalVolumeMonitorVolumeAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_volume_added(instance, C.gpointer(uintptr(signalVolumeMonitorVolumeAddedId)))

	detail := signalVolumeMonitorVolumeAddedDetail{callback, handlerID}
	signalVolumeMonitorVolumeAddedMap[signalVolumeMonitorVolumeAddedId] = detail

	return signalVolumeMonitorVolumeAddedId
}

/*
DisconnectVolumeAdded disconnects a callback from the 'volume-added' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectVolumeAdded.
*/
func (recv *VolumeMonitor) DisconnectVolumeAdded(connectionID int) {
	signalVolumeMonitorVolumeAddedLock.Lock()
	defer signalVolumeMonitorVolumeAddedLock.Unlock()

	detail, exists := signalVolumeMonitorVolumeAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorVolumeAddedMap, connectionID)
}

//export volumemonitor_volumeAddedHandler
func volumemonitor_volumeAddedHandler(_ *C.GObject, c_volume *C.GVolume, data C.gpointer) {
	signalVolumeMonitorVolumeAddedLock.RLock()
	defer signalVolumeMonitorVolumeAddedLock.RUnlock()

	volume := VolumeNewFromC(unsafe.Pointer(c_volume))

	index := int(uintptr(data))
	callback := signalVolumeMonitorVolumeAddedMap[index].callback
	callback(volume)
}

type signalVolumeMonitorVolumeChangedDetail struct {
	callback  VolumeMonitorSignalVolumeChangedCallback
	handlerID C.gulong
}

var signalVolumeMonitorVolumeChangedId int
var signalVolumeMonitorVolumeChangedMap = make(map[int]signalVolumeMonitorVolumeChangedDetail)
var signalVolumeMonitorVolumeChangedLock sync.RWMutex

// VolumeMonitorSignalVolumeChangedCallback is a callback function for a 'volume-changed' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalVolumeChangedCallback func(volume *Volume)

/*
ConnectVolumeChanged connects the callback to the 'volume-changed' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectVolumeChanged to remove it.
*/
func (recv *VolumeMonitor) ConnectVolumeChanged(callback VolumeMonitorSignalVolumeChangedCallback) int {
	signalVolumeMonitorVolumeChangedLock.Lock()
	defer signalVolumeMonitorVolumeChangedLock.Unlock()

	signalVolumeMonitorVolumeChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_volume_changed(instance, C.gpointer(uintptr(signalVolumeMonitorVolumeChangedId)))

	detail := signalVolumeMonitorVolumeChangedDetail{callback, handlerID}
	signalVolumeMonitorVolumeChangedMap[signalVolumeMonitorVolumeChangedId] = detail

	return signalVolumeMonitorVolumeChangedId
}

/*
DisconnectVolumeChanged disconnects a callback from the 'volume-changed' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectVolumeChanged.
*/
func (recv *VolumeMonitor) DisconnectVolumeChanged(connectionID int) {
	signalVolumeMonitorVolumeChangedLock.Lock()
	defer signalVolumeMonitorVolumeChangedLock.Unlock()

	detail, exists := signalVolumeMonitorVolumeChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorVolumeChangedMap, connectionID)
}

//export volumemonitor_volumeChangedHandler
func volumemonitor_volumeChangedHandler(_ *C.GObject, c_volume *C.GVolume, data C.gpointer) {
	signalVolumeMonitorVolumeChangedLock.RLock()
	defer signalVolumeMonitorVolumeChangedLock.RUnlock()

	volume := VolumeNewFromC(unsafe.Pointer(c_volume))

	index := int(uintptr(data))
	callback := signalVolumeMonitorVolumeChangedMap[index].callback
	callback(volume)
}

type signalVolumeMonitorVolumeRemovedDetail struct {
	callback  VolumeMonitorSignalVolumeRemovedCallback
	handlerID C.gulong
}

var signalVolumeMonitorVolumeRemovedId int
var signalVolumeMonitorVolumeRemovedMap = make(map[int]signalVolumeMonitorVolumeRemovedDetail)
var signalVolumeMonitorVolumeRemovedLock sync.RWMutex

// VolumeMonitorSignalVolumeRemovedCallback is a callback function for a 'volume-removed' signal emitted from a VolumeMonitor.
type VolumeMonitorSignalVolumeRemovedCallback func(volume *Volume)

/*
ConnectVolumeRemoved connects the callback to the 'volume-removed' signal for the VolumeMonitor.

The returned value represents the connection, and may be passed to DisconnectVolumeRemoved to remove it.
*/
func (recv *VolumeMonitor) ConnectVolumeRemoved(callback VolumeMonitorSignalVolumeRemovedCallback) int {
	signalVolumeMonitorVolumeRemovedLock.Lock()
	defer signalVolumeMonitorVolumeRemovedLock.Unlock()

	signalVolumeMonitorVolumeRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.VolumeMonitor_signal_connect_volume_removed(instance, C.gpointer(uintptr(signalVolumeMonitorVolumeRemovedId)))

	detail := signalVolumeMonitorVolumeRemovedDetail{callback, handlerID}
	signalVolumeMonitorVolumeRemovedMap[signalVolumeMonitorVolumeRemovedId] = detail

	return signalVolumeMonitorVolumeRemovedId
}

/*
DisconnectVolumeRemoved disconnects a callback from the 'volume-removed' signal for the VolumeMonitor.

The connectionID should be a value returned from a call to ConnectVolumeRemoved.
*/
func (recv *VolumeMonitor) DisconnectVolumeRemoved(connectionID int) {
	signalVolumeMonitorVolumeRemovedLock.Lock()
	defer signalVolumeMonitorVolumeRemovedLock.Unlock()

	detail, exists := signalVolumeMonitorVolumeRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeMonitorVolumeRemovedMap, connectionID)
}

//export volumemonitor_volumeRemovedHandler
func volumemonitor_volumeRemovedHandler(_ *C.GObject, c_volume *C.GVolume, data C.gpointer) {
	signalVolumeMonitorVolumeRemovedLock.RLock()
	defer signalVolumeMonitorVolumeRemovedLock.RUnlock()

	volume := VolumeNewFromC(unsafe.Pointer(c_volume))

	index := int(uintptr(data))
	callback := signalVolumeMonitorVolumeRemovedMap[index].callback
	callback(volume)
}

// VolumeMonitorAdoptOrphanMount is a wrapper around the C function g_volume_monitor_adopt_orphan_mount.
func VolumeMonitorAdoptOrphanMount(mount *Mount) *Volume {
	c_mount := (*C.GMount)(mount.ToC())

	retC := C.g_volume_monitor_adopt_orphan_mount(c_mount)
	retGo := VolumeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// VolumeMonitorGet is a wrapper around the C function g_volume_monitor_get.
func VolumeMonitorGet() *VolumeMonitor {
	retC := C.g_volume_monitor_get()
	retGo := VolumeMonitorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetConnectedDrives is a wrapper around the C function g_volume_monitor_get_connected_drives.
func (recv *VolumeMonitor) GetConnectedDrives() *glib.List {
	retC := C.g_volume_monitor_get_connected_drives((*C.GVolumeMonitor)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetMountForUuid is a wrapper around the C function g_volume_monitor_get_mount_for_uuid.
func (recv *VolumeMonitor) GetMountForUuid(uuid string) *Mount {
	c_uuid := C.CString(uuid)
	defer C.free(unsafe.Pointer(c_uuid))

	retC := C.g_volume_monitor_get_mount_for_uuid((*C.GVolumeMonitor)(recv.native), c_uuid)
	retGo := MountNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetMounts is a wrapper around the C function g_volume_monitor_get_mounts.
func (recv *VolumeMonitor) GetMounts() *glib.List {
	retC := C.g_volume_monitor_get_mounts((*C.GVolumeMonitor)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetVolumeForUuid is a wrapper around the C function g_volume_monitor_get_volume_for_uuid.
func (recv *VolumeMonitor) GetVolumeForUuid(uuid string) *Volume {
	c_uuid := C.CString(uuid)
	defer C.free(unsafe.Pointer(c_uuid))

	retC := C.g_volume_monitor_get_volume_for_uuid((*C.GVolumeMonitor)(recv.native), c_uuid)
	retGo := VolumeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetVolumes is a wrapper around the C function g_volume_monitor_get_volumes.
func (recv *VolumeMonitor) GetVolumes() *glib.List {
	retC := C.g_volume_monitor_get_volumes((*C.GVolumeMonitor)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ZlibCompressor is a wrapper around the C record GZlibCompressor.
type ZlibCompressor struct {
	native *C.GZlibCompressor
}

func ZlibCompressorNewFromC(u unsafe.Pointer) *ZlibCompressor {
	c := (*C.GZlibCompressor)(u)
	if c == nil {
		return nil
	}

	g := &ZlibCompressor{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ZlibCompressor) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ZlibCompressor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ZlibCompressor with another ZlibCompressor, and returns true if they represent the same GObject.
func (recv *ZlibCompressor) Equals(other *ZlibCompressor) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ZlibCompressor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ZlibCompressor.
// Exercise care, as this is a potentially dangerous function if the Object is not a ZlibCompressor.
func CastToZlibCompressor(object *gobject.Object) *ZlibCompressor {
	return ZlibCompressorNewFromC(object.ToC())
}

// ZlibCompressorNew is a wrapper around the C function g_zlib_compressor_new.
func ZlibCompressorNew(format ZlibCompressorFormat, level int32) *ZlibCompressor {
	c_format := (C.GZlibCompressorFormat)(format)

	c_level := (C.int)(level)

	retC := C.g_zlib_compressor_new(c_format, c_level)
	retGo := ZlibCompressorNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetFileInfo is a wrapper around the C function g_zlib_compressor_get_file_info.
func (recv *ZlibCompressor) GetFileInfo() *FileInfo {
	retC := C.g_zlib_compressor_get_file_info((*C.GZlibCompressor)(recv.native))
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetFileInfo is a wrapper around the C function g_zlib_compressor_set_file_info.
func (recv *ZlibCompressor) SetFileInfo(fileInfo *FileInfo) {
	c_file_info := (*C.GFileInfo)(C.NULL)
	if fileInfo != nil {
		c_file_info = (*C.GFileInfo)(fileInfo.ToC())
	}

	C.g_zlib_compressor_set_file_info((*C.GZlibCompressor)(recv.native), c_file_info)

	return
}

// Converter returns the Converter interface implemented by ZlibCompressor
func (recv *ZlibCompressor) Converter() *Converter {
	return ConverterNewFromC(recv.ToC())
}

// ZlibDecompressor is a wrapper around the C record GZlibDecompressor.
type ZlibDecompressor struct {
	native *C.GZlibDecompressor
}

func ZlibDecompressorNewFromC(u unsafe.Pointer) *ZlibDecompressor {
	c := (*C.GZlibDecompressor)(u)
	if c == nil {
		return nil
	}

	g := &ZlibDecompressor{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ZlibDecompressor) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ZlibDecompressor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ZlibDecompressor with another ZlibDecompressor, and returns true if they represent the same GObject.
func (recv *ZlibDecompressor) Equals(other *ZlibDecompressor) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ZlibDecompressor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ZlibDecompressor.
// Exercise care, as this is a potentially dangerous function if the Object is not a ZlibDecompressor.
func CastToZlibDecompressor(object *gobject.Object) *ZlibDecompressor {
	return ZlibDecompressorNewFromC(object.ToC())
}

// ZlibDecompressorNew is a wrapper around the C function g_zlib_decompressor_new.
func ZlibDecompressorNew(format ZlibCompressorFormat) *ZlibDecompressor {
	c_format := (C.GZlibCompressorFormat)(format)

	retC := C.g_zlib_decompressor_new(c_format)
	retGo := ZlibDecompressorNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetFileInfo is a wrapper around the C function g_zlib_decompressor_get_file_info.
func (recv *ZlibDecompressor) GetFileInfo() *FileInfo {
	retC := C.g_zlib_decompressor_get_file_info((*C.GZlibDecompressor)(recv.native))
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Converter returns the Converter interface implemented by ZlibDecompressor
func (recv *ZlibDecompressor) Converter() *Converter {
	return ConverterNewFromC(recv.ToC())
}

const DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME string = C.G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME
const FILE_ATTRIBUTE_ACCESS_CAN_DELETE string = C.G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE
const FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE string = C.G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE
const FILE_ATTRIBUTE_ACCESS_CAN_READ string = C.G_FILE_ATTRIBUTE_ACCESS_CAN_READ
const FILE_ATTRIBUTE_ACCESS_CAN_RENAME string = C.G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME
const FILE_ATTRIBUTE_ACCESS_CAN_TRASH string = C.G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH
const FILE_ATTRIBUTE_ACCESS_CAN_WRITE string = C.G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE
const FILE_ATTRIBUTE_DOS_IS_ARCHIVE string = C.G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE
const FILE_ATTRIBUTE_DOS_IS_SYSTEM string = C.G_FILE_ATTRIBUTE_DOS_IS_SYSTEM
const FILE_ATTRIBUTE_ETAG_VALUE string = C.G_FILE_ATTRIBUTE_ETAG_VALUE
const FILE_ATTRIBUTE_FILESYSTEM_FREE string = C.G_FILE_ATTRIBUTE_FILESYSTEM_FREE
const FILE_ATTRIBUTE_FILESYSTEM_READONLY string = C.G_FILE_ATTRIBUTE_FILESYSTEM_READONLY

// Blacklisted : FILE_ATTRIBUTE_FILESYSTEM_REMOTE

const FILE_ATTRIBUTE_FILESYSTEM_SIZE string = C.G_FILE_ATTRIBUTE_FILESYSTEM_SIZE
const FILE_ATTRIBUTE_FILESYSTEM_TYPE string = C.G_FILE_ATTRIBUTE_FILESYSTEM_TYPE
const FILE_ATTRIBUTE_FILESYSTEM_USED string = C.G_FILE_ATTRIBUTE_FILESYSTEM_USED
const FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW string = C.G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW
const FILE_ATTRIBUTE_GVFS_BACKEND string = C.G_FILE_ATTRIBUTE_GVFS_BACKEND
const FILE_ATTRIBUTE_ID_FILE string = C.G_FILE_ATTRIBUTE_ID_FILE
const FILE_ATTRIBUTE_ID_FILESYSTEM string = C.G_FILE_ATTRIBUTE_ID_FILESYSTEM
const FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT string = C.G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT
const FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT string = C.G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT
const FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL string = C.G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START string = C.G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START
const FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED string = C.G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED
const FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP string = C.G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP
const FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT string = C.G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT
const FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI string = C.G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI
const FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC string = C.G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC
const FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE string = C.G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE string = C.G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE
const FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE string = C.G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE
const FILE_ATTRIBUTE_OWNER_GROUP string = C.G_FILE_ATTRIBUTE_OWNER_GROUP
const FILE_ATTRIBUTE_OWNER_USER string = C.G_FILE_ATTRIBUTE_OWNER_USER
const FILE_ATTRIBUTE_OWNER_USER_REAL string = C.G_FILE_ATTRIBUTE_OWNER_USER_REAL
const FILE_ATTRIBUTE_PREVIEW_ICON string = C.G_FILE_ATTRIBUTE_PREVIEW_ICON
const FILE_ATTRIBUTE_SELINUX_CONTEXT string = C.G_FILE_ATTRIBUTE_SELINUX_CONTEXT
const FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE string = C.G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE
const FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE string = C.G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE
const FILE_ATTRIBUTE_STANDARD_COPY_NAME string = C.G_FILE_ATTRIBUTE_STANDARD_COPY_NAME
const FILE_ATTRIBUTE_STANDARD_DESCRIPTION string = C.G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION
const FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME string = C.G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME
const FILE_ATTRIBUTE_STANDARD_EDIT_NAME string = C.G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME
const FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE string = C.G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE
const FILE_ATTRIBUTE_STANDARD_ICON string = C.G_FILE_ATTRIBUTE_STANDARD_ICON
const FILE_ATTRIBUTE_STANDARD_IS_BACKUP string = C.G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP
const FILE_ATTRIBUTE_STANDARD_IS_HIDDEN string = C.G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN
const FILE_ATTRIBUTE_STANDARD_IS_SYMLINK string = C.G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK
const FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL string = C.G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL
const FILE_ATTRIBUTE_STANDARD_NAME string = C.G_FILE_ATTRIBUTE_STANDARD_NAME
const FILE_ATTRIBUTE_STANDARD_SIZE string = C.G_FILE_ATTRIBUTE_STANDARD_SIZE
const FILE_ATTRIBUTE_STANDARD_SORT_ORDER string = C.G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER
const FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON string = C.G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON
const FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET string = C.G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET
const FILE_ATTRIBUTE_STANDARD_TARGET_URI string = C.G_FILE_ATTRIBUTE_STANDARD_TARGET_URI
const FILE_ATTRIBUTE_STANDARD_TYPE string = C.G_FILE_ATTRIBUTE_STANDARD_TYPE
const FILE_ATTRIBUTE_THUMBNAILING_FAILED string = C.G_FILE_ATTRIBUTE_THUMBNAILING_FAILED
const FILE_ATTRIBUTE_THUMBNAIL_PATH string = C.G_FILE_ATTRIBUTE_THUMBNAIL_PATH
const FILE_ATTRIBUTE_TIME_ACCESS string = C.G_FILE_ATTRIBUTE_TIME_ACCESS
const FILE_ATTRIBUTE_TIME_ACCESS_USEC string = C.G_FILE_ATTRIBUTE_TIME_ACCESS_USEC
const FILE_ATTRIBUTE_TIME_CHANGED string = C.G_FILE_ATTRIBUTE_TIME_CHANGED
const FILE_ATTRIBUTE_TIME_CHANGED_USEC string = C.G_FILE_ATTRIBUTE_TIME_CHANGED_USEC
const FILE_ATTRIBUTE_TIME_CREATED string = C.G_FILE_ATTRIBUTE_TIME_CREATED
const FILE_ATTRIBUTE_TIME_CREATED_USEC string = C.G_FILE_ATTRIBUTE_TIME_CREATED_USEC
const FILE_ATTRIBUTE_TIME_MODIFIED string = C.G_FILE_ATTRIBUTE_TIME_MODIFIED
const FILE_ATTRIBUTE_TIME_MODIFIED_USEC string = C.G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC
const FILE_ATTRIBUTE_TRASH_DELETION_DATE string = C.G_FILE_ATTRIBUTE_TRASH_DELETION_DATE
const FILE_ATTRIBUTE_TRASH_ITEM_COUNT string = C.G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT
const FILE_ATTRIBUTE_TRASH_ORIG_PATH string = C.G_FILE_ATTRIBUTE_TRASH_ORIG_PATH
const FILE_ATTRIBUTE_UNIX_BLOCKS string = C.G_FILE_ATTRIBUTE_UNIX_BLOCKS
const FILE_ATTRIBUTE_UNIX_BLOCK_SIZE string = C.G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE
const FILE_ATTRIBUTE_UNIX_DEVICE string = C.G_FILE_ATTRIBUTE_UNIX_DEVICE
const FILE_ATTRIBUTE_UNIX_GID string = C.G_FILE_ATTRIBUTE_UNIX_GID
const FILE_ATTRIBUTE_UNIX_INODE string = C.G_FILE_ATTRIBUTE_UNIX_INODE
const FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT string = C.G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT
const FILE_ATTRIBUTE_UNIX_MODE string = C.G_FILE_ATTRIBUTE_UNIX_MODE
const FILE_ATTRIBUTE_UNIX_NLINK string = C.G_FILE_ATTRIBUTE_UNIX_NLINK
const FILE_ATTRIBUTE_UNIX_RDEV string = C.G_FILE_ATTRIBUTE_UNIX_RDEV
const FILE_ATTRIBUTE_UNIX_UID string = C.G_FILE_ATTRIBUTE_UNIX_UID
const MENU_ATTRIBUTE_ACTION string = C.G_MENU_ATTRIBUTE_ACTION
const MENU_ATTRIBUTE_ACTION_NAMESPACE string = C.G_MENU_ATTRIBUTE_ACTION_NAMESPACE
const MENU_ATTRIBUTE_LABEL string = C.G_MENU_ATTRIBUTE_LABEL
const MENU_ATTRIBUTE_TARGET string = C.G_MENU_ATTRIBUTE_TARGET
const MENU_LINK_SECTION string = C.G_MENU_LINK_SECTION
const MENU_LINK_SUBMENU string = C.G_MENU_LINK_SUBMENU
const NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME string = C.G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME
const NETWORK_MONITOR_EXTENSION_POINT_NAME string = C.G_NETWORK_MONITOR_EXTENSION_POINT_NAME
const PROXY_EXTENSION_POINT_NAME string = C.G_PROXY_EXTENSION_POINT_NAME
const PROXY_RESOLVER_EXTENSION_POINT_NAME string = C.G_PROXY_RESOLVER_EXTENSION_POINT_NAME

// Blacklisted : SETTINGS_BACKEND_EXTENSION_POINT_NAME

const TLS_BACKEND_EXTENSION_POINT_NAME string = C.G_TLS_BACKEND_EXTENSION_POINT_NAME
const TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT string = C.G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT
const TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER string = C.G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER
const VFS_EXTENSION_POINT_NAME string = C.G_VFS_EXTENSION_POINT_NAME
const VOLUME_IDENTIFIER_KIND_CLASS string = C.G_VOLUME_IDENTIFIER_KIND_CLASS
const VOLUME_IDENTIFIER_KIND_HAL_UDI string = C.G_VOLUME_IDENTIFIER_KIND_HAL_UDI
const VOLUME_IDENTIFIER_KIND_LABEL string = C.G_VOLUME_IDENTIFIER_KIND_LABEL
const VOLUME_IDENTIFIER_KIND_NFS_MOUNT string = C.G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT
const VOLUME_IDENTIFIER_KIND_UNIX_DEVICE string = C.G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE
const VOLUME_IDENTIFIER_KIND_UUID string = C.G_VOLUME_IDENTIFIER_KIND_UUID
const VOLUME_MONITOR_EXTENSION_POINT_NAME string = C.G_VOLUME_MONITOR_EXTENSION_POINT_NAME

type BusType C.GBusType

const (
	BUS_TYPE_STARTER BusType = -1
	BUS_TYPE_NONE    BusType = 0
	BUS_TYPE_SYSTEM  BusType = 1
	BUS_TYPE_SESSION BusType = 2
)

type ConverterResult C.GConverterResult

const (
	CONVERTER_ERROR     ConverterResult = 0
	CONVERTER_CONVERTED ConverterResult = 1
	CONVERTER_FINISHED  ConverterResult = 2
	CONVERTER_FLUSHED   ConverterResult = 3
)

type CredentialsType C.GCredentialsType

const (
	CREDENTIALS_TYPE_INVALID              CredentialsType = 0
	CREDENTIALS_TYPE_LINUX_UCRED          CredentialsType = 1
	CREDENTIALS_TYPE_FREEBSD_CMSGCRED     CredentialsType = 2
	CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED CredentialsType = 3
	CREDENTIALS_TYPE_SOLARIS_UCRED        CredentialsType = 4
	CREDENTIALS_TYPE_NETBSD_UNPCBID       CredentialsType = 5
)

type DBusError C.GDBusError

const (
	DBUS_ERROR_FAILED                           DBusError = 0
	DBUS_ERROR_NO_MEMORY                        DBusError = 1
	DBUS_ERROR_SERVICE_UNKNOWN                  DBusError = 2
	DBUS_ERROR_NAME_HAS_NO_OWNER                DBusError = 3
	DBUS_ERROR_NO_REPLY                         DBusError = 4
	DBUS_ERROR_IO_ERROR                         DBusError = 5
	DBUS_ERROR_BAD_ADDRESS                      DBusError = 6
	DBUS_ERROR_NOT_SUPPORTED                    DBusError = 7
	DBUS_ERROR_LIMITS_EXCEEDED                  DBusError = 8
	DBUS_ERROR_ACCESS_DENIED                    DBusError = 9
	DBUS_ERROR_AUTH_FAILED                      DBusError = 10
	DBUS_ERROR_NO_SERVER                        DBusError = 11
	DBUS_ERROR_TIMEOUT                          DBusError = 12
	DBUS_ERROR_NO_NETWORK                       DBusError = 13
	DBUS_ERROR_ADDRESS_IN_USE                   DBusError = 14
	DBUS_ERROR_DISCONNECTED                     DBusError = 15
	DBUS_ERROR_INVALID_ARGS                     DBusError = 16
	DBUS_ERROR_FILE_NOT_FOUND                   DBusError = 17
	DBUS_ERROR_FILE_EXISTS                      DBusError = 18
	DBUS_ERROR_UNKNOWN_METHOD                   DBusError = 19
	DBUS_ERROR_TIMED_OUT                        DBusError = 20
	DBUS_ERROR_MATCH_RULE_NOT_FOUND             DBusError = 21
	DBUS_ERROR_MATCH_RULE_INVALID               DBusError = 22
	DBUS_ERROR_SPAWN_EXEC_FAILED                DBusError = 23
	DBUS_ERROR_SPAWN_FORK_FAILED                DBusError = 24
	DBUS_ERROR_SPAWN_CHILD_EXITED               DBusError = 25
	DBUS_ERROR_SPAWN_CHILD_SIGNALED             DBusError = 26
	DBUS_ERROR_SPAWN_FAILED                     DBusError = 27
	DBUS_ERROR_SPAWN_SETUP_FAILED               DBusError = 28
	DBUS_ERROR_SPAWN_CONFIG_INVALID             DBusError = 29
	DBUS_ERROR_SPAWN_SERVICE_INVALID            DBusError = 30
	DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND          DBusError = 31
	DBUS_ERROR_SPAWN_PERMISSIONS_INVALID        DBusError = 32
	DBUS_ERROR_SPAWN_FILE_INVALID               DBusError = 33
	DBUS_ERROR_SPAWN_NO_MEMORY                  DBusError = 34
	DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN          DBusError = 35
	DBUS_ERROR_INVALID_SIGNATURE                DBusError = 36
	DBUS_ERROR_INVALID_FILE_CONTENT             DBusError = 37
	DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN DBusError = 38
	DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN           DBusError = 39
	DBUS_ERROR_OBJECT_PATH_IN_USE               DBusError = 40
	DBUS_ERROR_UNKNOWN_OBJECT                   DBusError = 41
	DBUS_ERROR_UNKNOWN_INTERFACE                DBusError = 42
	DBUS_ERROR_UNKNOWN_PROPERTY                 DBusError = 43
	DBUS_ERROR_PROPERTY_READ_ONLY               DBusError = 44
)

// DBusErrorEncodeGerror is a wrapper around the C function g_dbus_error_encode_gerror.
func DBusErrorEncodeGerror(error_ *glib.Error) string {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	retC := C.g_dbus_error_encode_gerror(c_error)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// DBusErrorGetRemoteError is a wrapper around the C function g_dbus_error_get_remote_error.
func DBusErrorGetRemoteError(error_ *glib.Error) string {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	retC := C.g_dbus_error_get_remote_error(c_error)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// DBusErrorIsRemoteError is a wrapper around the C function g_dbus_error_is_remote_error.
func DBusErrorIsRemoteError(error_ *glib.Error) bool {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	retC := C.g_dbus_error_is_remote_error(c_error)
	retGo := retC == C.TRUE

	return retGo
}

// DBusErrorNewForDbusError is a wrapper around the C function g_dbus_error_new_for_dbus_error.
func DBusErrorNewForDbusError(dbusErrorName string, dbusErrorMessage string) *glib.Error {
	c_dbus_error_name := C.CString(dbusErrorName)
	defer C.free(unsafe.Pointer(c_dbus_error_name))

	c_dbus_error_message := C.CString(dbusErrorMessage)
	defer C.free(unsafe.Pointer(c_dbus_error_message))

	retC := C.g_dbus_error_new_for_dbus_error(c_dbus_error_name, c_dbus_error_message)
	retGo := glib.ErrorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DBusErrorQuark is a wrapper around the C function g_dbus_error_quark.
func DBusErrorQuark() glib.Quark {
	retC := C.g_dbus_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

// DBusErrorRegisterError is a wrapper around the C function g_dbus_error_register_error.
func DBusErrorRegisterError(errorDomain glib.Quark, errorCode int32, dbusErrorName string) bool {
	c_error_domain := (C.GQuark)(errorDomain)

	c_error_code := (C.gint)(errorCode)

	c_dbus_error_name := C.CString(dbusErrorName)
	defer C.free(unsafe.Pointer(c_dbus_error_name))

	retC := C.g_dbus_error_register_error(c_error_domain, c_error_code, c_dbus_error_name)
	retGo := retC == C.TRUE

	return retGo
}

// g_dbus_error_register_error_domain : unsupported parameter entries :
// DBusErrorSetDbusError is a wrapper around the C function g_dbus_error_set_dbus_error.
func DBusErrorSetDbusError(error_ *glib.Error, dbusErrorName string, dbusErrorMessage string, format string, args ...interface{}) {
	c_error := (**C.GError)(C.NULL)
	if error_ != nil {
		c_error = (**C.GError)(error_.ToC())
	}

	c_dbus_error_name := C.CString(dbusErrorName)
	defer C.free(unsafe.Pointer(c_dbus_error_name))

	c_dbus_error_message := C.CString(dbusErrorMessage)
	defer C.free(unsafe.Pointer(c_dbus_error_message))

	goFormattedString := fmt.Sprintf(format, args...)
	c_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_format))

	C._g_dbus_error_set_dbus_error(c_error, c_dbus_error_name, c_dbus_error_message, c_format)

	return
}

// g_dbus_error_set_dbus_error_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args
// DBusErrorStripRemoteError is a wrapper around the C function g_dbus_error_strip_remote_error.
func DBusErrorStripRemoteError(error_ *glib.Error) bool {
	c_error := (*C.GError)(C.NULL)
	if error_ != nil {
		c_error = (*C.GError)(error_.ToC())
	}

	retC := C.g_dbus_error_strip_remote_error(c_error)
	retGo := retC == C.TRUE

	return retGo
}

// DBusErrorUnregisterError is a wrapper around the C function g_dbus_error_unregister_error.
func DBusErrorUnregisterError(errorDomain glib.Quark, errorCode int32, dbusErrorName string) bool {
	c_error_domain := (C.GQuark)(errorDomain)

	c_error_code := (C.gint)(errorCode)

	c_dbus_error_name := C.CString(dbusErrorName)
	defer C.free(unsafe.Pointer(c_dbus_error_name))

	retC := C.g_dbus_error_unregister_error(c_error_domain, c_error_code, c_dbus_error_name)
	retGo := retC == C.TRUE

	return retGo
}

type DBusMessageByteOrder C.GDBusMessageByteOrder

const (
	DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN    DBusMessageByteOrder = 66
	DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN DBusMessageByteOrder = 108
)

type DBusMessageHeaderField C.GDBusMessageHeaderField

const (
	DBUS_MESSAGE_HEADER_FIELD_INVALID      DBusMessageHeaderField = 0
	DBUS_MESSAGE_HEADER_FIELD_PATH         DBusMessageHeaderField = 1
	DBUS_MESSAGE_HEADER_FIELD_INTERFACE    DBusMessageHeaderField = 2
	DBUS_MESSAGE_HEADER_FIELD_MEMBER       DBusMessageHeaderField = 3
	DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME   DBusMessageHeaderField = 4
	DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL DBusMessageHeaderField = 5
	DBUS_MESSAGE_HEADER_FIELD_DESTINATION  DBusMessageHeaderField = 6
	DBUS_MESSAGE_HEADER_FIELD_SENDER       DBusMessageHeaderField = 7
	DBUS_MESSAGE_HEADER_FIELD_SIGNATURE    DBusMessageHeaderField = 8
	DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS DBusMessageHeaderField = 9
)

type DBusMessageType C.GDBusMessageType

const (
	DBUS_MESSAGE_TYPE_INVALID       DBusMessageType = 0
	DBUS_MESSAGE_TYPE_METHOD_CALL   DBusMessageType = 1
	DBUS_MESSAGE_TYPE_METHOD_RETURN DBusMessageType = 2
	DBUS_MESSAGE_TYPE_ERROR         DBusMessageType = 3
	DBUS_MESSAGE_TYPE_SIGNAL        DBusMessageType = 4
)

type DataStreamByteOrder C.GDataStreamByteOrder

const (
	DATA_STREAM_BYTE_ORDER_BIG_ENDIAN    DataStreamByteOrder = 0
	DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN DataStreamByteOrder = 1
	DATA_STREAM_BYTE_ORDER_HOST_ENDIAN   DataStreamByteOrder = 2
)

type DataStreamNewlineType C.GDataStreamNewlineType

const (
	DATA_STREAM_NEWLINE_TYPE_LF    DataStreamNewlineType = 0
	DATA_STREAM_NEWLINE_TYPE_CR    DataStreamNewlineType = 1
	DATA_STREAM_NEWLINE_TYPE_CR_LF DataStreamNewlineType = 2
	DATA_STREAM_NEWLINE_TYPE_ANY   DataStreamNewlineType = 3
)

type DriveStartStopType C.GDriveStartStopType

const (
	DRIVE_START_STOP_TYPE_UNKNOWN   DriveStartStopType = 0
	DRIVE_START_STOP_TYPE_SHUTDOWN  DriveStartStopType = 1
	DRIVE_START_STOP_TYPE_NETWORK   DriveStartStopType = 2
	DRIVE_START_STOP_TYPE_MULTIDISK DriveStartStopType = 3
	DRIVE_START_STOP_TYPE_PASSWORD  DriveStartStopType = 4
)

type EmblemOrigin C.GEmblemOrigin

const (
	EMBLEM_ORIGIN_UNKNOWN      EmblemOrigin = 0
	EMBLEM_ORIGIN_DEVICE       EmblemOrigin = 1
	EMBLEM_ORIGIN_LIVEMETADATA EmblemOrigin = 2
	EMBLEM_ORIGIN_TAG          EmblemOrigin = 3
)

type FileAttributeStatus C.GFileAttributeStatus

const (
	FILE_ATTRIBUTE_STATUS_UNSET         FileAttributeStatus = 0
	FILE_ATTRIBUTE_STATUS_SET           FileAttributeStatus = 1
	FILE_ATTRIBUTE_STATUS_ERROR_SETTING FileAttributeStatus = 2
)

type FileAttributeType C.GFileAttributeType

const (
	FILE_ATTRIBUTE_TYPE_INVALID     FileAttributeType = 0
	FILE_ATTRIBUTE_TYPE_STRING      FileAttributeType = 1
	FILE_ATTRIBUTE_TYPE_BYTE_STRING FileAttributeType = 2
	FILE_ATTRIBUTE_TYPE_BOOLEAN     FileAttributeType = 3
	FILE_ATTRIBUTE_TYPE_UINT32      FileAttributeType = 4
	FILE_ATTRIBUTE_TYPE_INT32       FileAttributeType = 5
	FILE_ATTRIBUTE_TYPE_UINT64      FileAttributeType = 6
	FILE_ATTRIBUTE_TYPE_INT64       FileAttributeType = 7
	FILE_ATTRIBUTE_TYPE_OBJECT      FileAttributeType = 8
	FILE_ATTRIBUTE_TYPE_STRINGV     FileAttributeType = 9
)

type FileMonitorEvent C.GFileMonitorEvent

const (
	FILE_MONITOR_EVENT_CHANGED           FileMonitorEvent = 0
	FILE_MONITOR_EVENT_CHANGES_DONE_HINT FileMonitorEvent = 1
	FILE_MONITOR_EVENT_DELETED           FileMonitorEvent = 2
	FILE_MONITOR_EVENT_CREATED           FileMonitorEvent = 3
	FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED FileMonitorEvent = 4
	FILE_MONITOR_EVENT_PRE_UNMOUNT       FileMonitorEvent = 5
	FILE_MONITOR_EVENT_UNMOUNTED         FileMonitorEvent = 6
	FILE_MONITOR_EVENT_MOVED             FileMonitorEvent = 7
	FILE_MONITOR_EVENT_RENAMED           FileMonitorEvent = 8
	FILE_MONITOR_EVENT_MOVED_IN          FileMonitorEvent = 9
	FILE_MONITOR_EVENT_MOVED_OUT         FileMonitorEvent = 10
)

type FileType C.GFileType

const (
	FILE_TYPE_UNKNOWN       FileType = 0
	FILE_TYPE_REGULAR       FileType = 1
	FILE_TYPE_DIRECTORY     FileType = 2
	FILE_TYPE_SYMBOLIC_LINK FileType = 3
	FILE_TYPE_SPECIAL       FileType = 4
	FILE_TYPE_SHORTCUT      FileType = 5
	FILE_TYPE_MOUNTABLE     FileType = 6
)

type FilesystemPreviewType C.GFilesystemPreviewType

const (
	FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS FilesystemPreviewType = 0
	FILESYSTEM_PREVIEW_TYPE_IF_LOCAL  FilesystemPreviewType = 1
	FILESYSTEM_PREVIEW_TYPE_NEVER     FilesystemPreviewType = 2
)

type IOErrorEnum C.GIOErrorEnum

const (
	IO_ERROR_FAILED              IOErrorEnum = 0
	IO_ERROR_NOT_FOUND           IOErrorEnum = 1
	IO_ERROR_EXISTS              IOErrorEnum = 2
	IO_ERROR_IS_DIRECTORY        IOErrorEnum = 3
	IO_ERROR_NOT_DIRECTORY       IOErrorEnum = 4
	IO_ERROR_NOT_EMPTY           IOErrorEnum = 5
	IO_ERROR_NOT_REGULAR_FILE    IOErrorEnum = 6
	IO_ERROR_NOT_SYMBOLIC_LINK   IOErrorEnum = 7
	IO_ERROR_NOT_MOUNTABLE_FILE  IOErrorEnum = 8
	IO_ERROR_FILENAME_TOO_LONG   IOErrorEnum = 9
	IO_ERROR_INVALID_FILENAME    IOErrorEnum = 10
	IO_ERROR_TOO_MANY_LINKS      IOErrorEnum = 11
	IO_ERROR_NO_SPACE            IOErrorEnum = 12
	IO_ERROR_INVALID_ARGUMENT    IOErrorEnum = 13
	IO_ERROR_PERMISSION_DENIED   IOErrorEnum = 14
	IO_ERROR_NOT_SUPPORTED       IOErrorEnum = 15
	IO_ERROR_NOT_MOUNTED         IOErrorEnum = 16
	IO_ERROR_ALREADY_MOUNTED     IOErrorEnum = 17
	IO_ERROR_CLOSED              IOErrorEnum = 18
	IO_ERROR_CANCELLED           IOErrorEnum = 19
	IO_ERROR_PENDING             IOErrorEnum = 20
	IO_ERROR_READ_ONLY           IOErrorEnum = 21
	IO_ERROR_CANT_CREATE_BACKUP  IOErrorEnum = 22
	IO_ERROR_WRONG_ETAG          IOErrorEnum = 23
	IO_ERROR_TIMED_OUT           IOErrorEnum = 24
	IO_ERROR_WOULD_RECURSE       IOErrorEnum = 25
	IO_ERROR_BUSY                IOErrorEnum = 26
	IO_ERROR_WOULD_BLOCK         IOErrorEnum = 27
	IO_ERROR_HOST_NOT_FOUND      IOErrorEnum = 28
	IO_ERROR_WOULD_MERGE         IOErrorEnum = 29
	IO_ERROR_FAILED_HANDLED      IOErrorEnum = 30
	IO_ERROR_TOO_MANY_OPEN_FILES IOErrorEnum = 31
	IO_ERROR_NOT_INITIALIZED     IOErrorEnum = 32
	IO_ERROR_ADDRESS_IN_USE      IOErrorEnum = 33
	IO_ERROR_PARTIAL_INPUT       IOErrorEnum = 34
	IO_ERROR_INVALID_DATA        IOErrorEnum = 35
	IO_ERROR_DBUS_ERROR          IOErrorEnum = 36
	IO_ERROR_HOST_UNREACHABLE    IOErrorEnum = 37
	IO_ERROR_NETWORK_UNREACHABLE IOErrorEnum = 38
	IO_ERROR_CONNECTION_REFUSED  IOErrorEnum = 39
	IO_ERROR_PROXY_FAILED        IOErrorEnum = 40
	IO_ERROR_PROXY_AUTH_FAILED   IOErrorEnum = 41
	IO_ERROR_PROXY_NEED_AUTH     IOErrorEnum = 42
	IO_ERROR_PROXY_NOT_ALLOWED   IOErrorEnum = 43
	IO_ERROR_BROKEN_PIPE         IOErrorEnum = 44
	IO_ERROR_CONNECTION_CLOSED   IOErrorEnum = 44
	IO_ERROR_NOT_CONNECTED       IOErrorEnum = 45
	IO_ERROR_MESSAGE_TOO_LARGE   IOErrorEnum = 46
)

type IOModuleScopeFlags C.GIOModuleScopeFlags

const (
	IO_MODULE_SCOPE_NONE             IOModuleScopeFlags = 0
	IO_MODULE_SCOPE_BLOCK_DUPLICATES IOModuleScopeFlags = 1
)

type MountOperationResult C.GMountOperationResult

const (
	MOUNT_OPERATION_HANDLED   MountOperationResult = 0
	MOUNT_OPERATION_ABORTED   MountOperationResult = 1
	MOUNT_OPERATION_UNHANDLED MountOperationResult = 2
)

type PasswordSave C.GPasswordSave

const (
	PASSWORD_SAVE_NEVER       PasswordSave = 0
	PASSWORD_SAVE_FOR_SESSION PasswordSave = 1
	PASSWORD_SAVE_PERMANENTLY PasswordSave = 2
)

type ResolverError C.GResolverError

const (
	RESOLVER_ERROR_NOT_FOUND         ResolverError = 0
	RESOLVER_ERROR_TEMPORARY_FAILURE ResolverError = 1
	RESOLVER_ERROR_INTERNAL          ResolverError = 2
)

// ResolverErrorQuark is a wrapper around the C function g_resolver_error_quark.
func ResolverErrorQuark() glib.Quark {
	retC := C.g_resolver_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type ResolverRecordType C.GResolverRecordType

const (
	RESOLVER_RECORD_SRV ResolverRecordType = 1
	RESOLVER_RECORD_MX  ResolverRecordType = 2
	RESOLVER_RECORD_TXT ResolverRecordType = 3
	RESOLVER_RECORD_SOA ResolverRecordType = 4
	RESOLVER_RECORD_NS  ResolverRecordType = 5
)

type ResourceError C.GResourceError

const (
	RESOURCE_ERROR_NOT_FOUND ResourceError = 0
	RESOURCE_ERROR_INTERNAL  ResourceError = 1
)

// ResourceErrorQuark is a wrapper around the C function g_resource_error_quark.
func ResourceErrorQuark() glib.Quark {
	retC := C.g_resource_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type SocketClientEvent C.GSocketClientEvent

const (
	SOCKET_CLIENT_RESOLVING         SocketClientEvent = 0
	SOCKET_CLIENT_RESOLVED          SocketClientEvent = 1
	SOCKET_CLIENT_CONNECTING        SocketClientEvent = 2
	SOCKET_CLIENT_CONNECTED         SocketClientEvent = 3
	SOCKET_CLIENT_PROXY_NEGOTIATING SocketClientEvent = 4
	SOCKET_CLIENT_PROXY_NEGOTIATED  SocketClientEvent = 5
	SOCKET_CLIENT_TLS_HANDSHAKING   SocketClientEvent = 6
	SOCKET_CLIENT_TLS_HANDSHAKED    SocketClientEvent = 7
	SOCKET_CLIENT_COMPLETE          SocketClientEvent = 8
)

type SocketFamily C.GSocketFamily

const (
	SOCKET_FAMILY_INVALID SocketFamily = 0
	SOCKET_FAMILY_UNIX    SocketFamily = 1
	SOCKET_FAMILY_IPV4    SocketFamily = 2
	SOCKET_FAMILY_IPV6    SocketFamily = 10
)

type SocketProtocol C.GSocketProtocol

const (
	SOCKET_PROTOCOL_UNKNOWN SocketProtocol = -1
	SOCKET_PROTOCOL_DEFAULT SocketProtocol = 0
	SOCKET_PROTOCOL_TCP     SocketProtocol = 6
	SOCKET_PROTOCOL_UDP     SocketProtocol = 17
	SOCKET_PROTOCOL_SCTP    SocketProtocol = 132
)

type SocketType C.GSocketType

const (
	SOCKET_TYPE_INVALID   SocketType = 0
	SOCKET_TYPE_STREAM    SocketType = 1
	SOCKET_TYPE_DATAGRAM  SocketType = 2
	SOCKET_TYPE_SEQPACKET SocketType = 3
)

type TlsAuthenticationMode C.GTlsAuthenticationMode

const (
	TLS_AUTHENTICATION_NONE      TlsAuthenticationMode = 0
	TLS_AUTHENTICATION_REQUESTED TlsAuthenticationMode = 1
	TLS_AUTHENTICATION_REQUIRED  TlsAuthenticationMode = 2
)

type TlsDatabaseLookupFlags C.GTlsDatabaseLookupFlags

const (
	TLS_DATABASE_LOOKUP_NONE    TlsDatabaseLookupFlags = 0
	TLS_DATABASE_LOOKUP_KEYPAIR TlsDatabaseLookupFlags = 1
)

type TlsError C.GTlsError

const (
	TLS_ERROR_UNAVAILABLE          TlsError = 0
	TLS_ERROR_MISC                 TlsError = 1
	TLS_ERROR_BAD_CERTIFICATE      TlsError = 2
	TLS_ERROR_NOT_TLS              TlsError = 3
	TLS_ERROR_HANDSHAKE            TlsError = 4
	TLS_ERROR_CERTIFICATE_REQUIRED TlsError = 5
	TLS_ERROR_EOF                  TlsError = 6
)

// TlsErrorQuark is a wrapper around the C function g_tls_error_quark.
func TlsErrorQuark() glib.Quark {
	retC := C.g_tls_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type TlsInteractionResult C.GTlsInteractionResult

const (
	TLS_INTERACTION_UNHANDLED TlsInteractionResult = 0
	TLS_INTERACTION_HANDLED   TlsInteractionResult = 1
	TLS_INTERACTION_FAILED    TlsInteractionResult = 2
)

type TlsRehandshakeMode C.GTlsRehandshakeMode

const (
	TLS_REHANDSHAKE_NEVER    TlsRehandshakeMode = 0
	TLS_REHANDSHAKE_SAFELY   TlsRehandshakeMode = 1
	TLS_REHANDSHAKE_UNSAFELY TlsRehandshakeMode = 2
)

type UnixSocketAddressType C.GUnixSocketAddressType

const (
	UNIX_SOCKET_ADDRESS_INVALID         UnixSocketAddressType = 0
	UNIX_SOCKET_ADDRESS_ANONYMOUS       UnixSocketAddressType = 1
	UNIX_SOCKET_ADDRESS_PATH            UnixSocketAddressType = 2
	UNIX_SOCKET_ADDRESS_ABSTRACT        UnixSocketAddressType = 3
	UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED UnixSocketAddressType = 4
)

type ZlibCompressorFormat C.GZlibCompressorFormat

const (
	ZLIB_COMPRESSOR_FORMAT_ZLIB ZlibCompressorFormat = 0
	ZLIB_COMPRESSOR_FORMAT_GZIP ZlibCompressorFormat = 1
	ZLIB_COMPRESSOR_FORMAT_RAW  ZlibCompressorFormat = 2
)

// Unsupported : g_async_initable_newv_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Unsupported : g_bus_get : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// BusGetFinish is a wrapper around the C function g_bus_get_finish.
func BusGetFinish(res *AsyncResult) (*DBusConnection, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_bus_get_finish(c_res, &cThrowableError)
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// BusGetSync is a wrapper around the C function g_bus_get_sync.
func BusGetSync(busType BusType, cancellable *Cancellable) (*DBusConnection, error) {
	c_bus_type := (C.GBusType)(busType)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_bus_get_sync(c_bus_type, c_cancellable, &cThrowableError)
	retGo := DBusConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_bus_own_name : unsupported parameter bus_acquired_handler : no type generator for BusAcquiredCallback (GBusAcquiredCallback) for param bus_acquired_handler

// Unsupported : g_bus_own_name_on_connection : unsupported parameter name_acquired_handler : no type generator for BusNameAcquiredCallback (GBusNameAcquiredCallback) for param name_acquired_handler

// BusOwnNameOnConnectionWithClosures is a wrapper around the C function g_bus_own_name_on_connection_with_closures.
func BusOwnNameOnConnectionWithClosures(connection *DBusConnection, name string, flags BusNameOwnerFlags, nameAcquiredClosure *gobject.Closure, nameLostClosure *gobject.Closure) uint32 {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_flags := (C.GBusNameOwnerFlags)(flags)

	c_name_acquired_closure := (*C.GClosure)(C.NULL)
	if nameAcquiredClosure != nil {
		c_name_acquired_closure = (*C.GClosure)(nameAcquiredClosure.ToC())
	}

	c_name_lost_closure := (*C.GClosure)(C.NULL)
	if nameLostClosure != nil {
		c_name_lost_closure = (*C.GClosure)(nameLostClosure.ToC())
	}

	retC := C.g_bus_own_name_on_connection_with_closures(c_connection, c_name, c_flags, c_name_acquired_closure, c_name_lost_closure)
	retGo := (uint32)(retC)

	return retGo
}

// BusOwnNameWithClosures is a wrapper around the C function g_bus_own_name_with_closures.
func BusOwnNameWithClosures(busType BusType, name string, flags BusNameOwnerFlags, busAcquiredClosure *gobject.Closure, nameAcquiredClosure *gobject.Closure, nameLostClosure *gobject.Closure) uint32 {
	c_bus_type := (C.GBusType)(busType)

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_flags := (C.GBusNameOwnerFlags)(flags)

	c_bus_acquired_closure := (*C.GClosure)(C.NULL)
	if busAcquiredClosure != nil {
		c_bus_acquired_closure = (*C.GClosure)(busAcquiredClosure.ToC())
	}

	c_name_acquired_closure := (*C.GClosure)(C.NULL)
	if nameAcquiredClosure != nil {
		c_name_acquired_closure = (*C.GClosure)(nameAcquiredClosure.ToC())
	}

	c_name_lost_closure := (*C.GClosure)(C.NULL)
	if nameLostClosure != nil {
		c_name_lost_closure = (*C.GClosure)(nameLostClosure.ToC())
	}

	retC := C.g_bus_own_name_with_closures(c_bus_type, c_name, c_flags, c_bus_acquired_closure, c_name_acquired_closure, c_name_lost_closure)
	retGo := (uint32)(retC)

	return retGo
}

// BusUnownName is a wrapper around the C function g_bus_unown_name.
func BusUnownName(ownerId uint32) {
	c_owner_id := (C.guint)(ownerId)

	C.g_bus_unown_name(c_owner_id)

	return
}

// BusUnwatchName is a wrapper around the C function g_bus_unwatch_name.
func BusUnwatchName(watcherId uint32) {
	c_watcher_id := (C.guint)(watcherId)

	C.g_bus_unwatch_name(c_watcher_id)

	return
}

// Unsupported : g_bus_watch_name : unsupported parameter name_appeared_handler : no type generator for BusNameAppearedCallback (GBusNameAppearedCallback) for param name_appeared_handler

// Unsupported : g_bus_watch_name_on_connection : unsupported parameter name_appeared_handler : no type generator for BusNameAppearedCallback (GBusNameAppearedCallback) for param name_appeared_handler

// BusWatchNameOnConnectionWithClosures is a wrapper around the C function g_bus_watch_name_on_connection_with_closures.
func BusWatchNameOnConnectionWithClosures(connection *DBusConnection, name string, flags BusNameWatcherFlags, nameAppearedClosure *gobject.Closure, nameVanishedClosure *gobject.Closure) uint32 {
	c_connection := (*C.GDBusConnection)(C.NULL)
	if connection != nil {
		c_connection = (*C.GDBusConnection)(connection.ToC())
	}

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_flags := (C.GBusNameWatcherFlags)(flags)

	c_name_appeared_closure := (*C.GClosure)(C.NULL)
	if nameAppearedClosure != nil {
		c_name_appeared_closure = (*C.GClosure)(nameAppearedClosure.ToC())
	}

	c_name_vanished_closure := (*C.GClosure)(C.NULL)
	if nameVanishedClosure != nil {
		c_name_vanished_closure = (*C.GClosure)(nameVanishedClosure.ToC())
	}

	retC := C.g_bus_watch_name_on_connection_with_closures(c_connection, c_name, c_flags, c_name_appeared_closure, c_name_vanished_closure)
	retGo := (uint32)(retC)

	return retGo
}

// BusWatchNameWithClosures is a wrapper around the C function g_bus_watch_name_with_closures.
func BusWatchNameWithClosures(busType BusType, name string, flags BusNameWatcherFlags, nameAppearedClosure *gobject.Closure, nameVanishedClosure *gobject.Closure) uint32 {
	c_bus_type := (C.GBusType)(busType)

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_flags := (C.GBusNameWatcherFlags)(flags)

	c_name_appeared_closure := (*C.GClosure)(C.NULL)
	if nameAppearedClosure != nil {
		c_name_appeared_closure = (*C.GClosure)(nameAppearedClosure.ToC())
	}

	c_name_vanished_closure := (*C.GClosure)(C.NULL)
	if nameVanishedClosure != nil {
		c_name_vanished_closure = (*C.GClosure)(nameVanishedClosure.ToC())
	}

	retC := C.g_bus_watch_name_with_closures(c_bus_type, c_name, c_flags, c_name_appeared_closure, c_name_vanished_closure)
	retGo := (uint32)(retC)

	return retGo
}

// ContentTypeCanBeExecutable is a wrapper around the C function g_content_type_can_be_executable.
func ContentTypeCanBeExecutable(type_ string) bool {
	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	retC := C.g_content_type_can_be_executable(c_type)
	retGo := retC == C.TRUE

	return retGo
}

// ContentTypeEquals is a wrapper around the C function g_content_type_equals.
func ContentTypeEquals(type1 string, type2 string) bool {
	c_type1 := C.CString(type1)
	defer C.free(unsafe.Pointer(c_type1))

	c_type2 := C.CString(type2)
	defer C.free(unsafe.Pointer(c_type2))

	retC := C.g_content_type_equals(c_type1, c_type2)
	retGo := retC == C.TRUE

	return retGo
}

// ContentTypeFromMimeType is a wrapper around the C function g_content_type_from_mime_type.
func ContentTypeFromMimeType(mimeType string) string {
	c_mime_type := C.CString(mimeType)
	defer C.free(unsafe.Pointer(c_mime_type))

	retC := C.g_content_type_from_mime_type(c_mime_type)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// ContentTypeGetDescription is a wrapper around the C function g_content_type_get_description.
func ContentTypeGetDescription(type_ string) string {
	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	retC := C.g_content_type_get_description(c_type)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// ContentTypeGetGenericIconName is a wrapper around the C function g_content_type_get_generic_icon_name.
func ContentTypeGetGenericIconName(type_ string) string {
	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	retC := C.g_content_type_get_generic_icon_name(c_type)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// ContentTypeGetIcon is a wrapper around the C function g_content_type_get_icon.
func ContentTypeGetIcon(type_ string) *Icon {
	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	retC := C.g_content_type_get_icon(c_type)
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ContentTypeGetMimeType is a wrapper around the C function g_content_type_get_mime_type.
func ContentTypeGetMimeType(type_ string) string {
	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	retC := C.g_content_type_get_mime_type(c_type)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// ContentTypeGetSymbolicIcon is a wrapper around the C function g_content_type_get_symbolic_icon.
func ContentTypeGetSymbolicIcon(type_ string) *Icon {
	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	retC := C.g_content_type_get_symbolic_icon(c_type)
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ContentTypeGuess is a wrapper around the C function g_content_type_guess.
func ContentTypeGuess(filename string, data []uint8) (string, bool) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	c_data_array := make([]C.guchar, len(data)+1, len(data)+1)
	for i, item := range data {
		c := (C.guchar)(item)
		c_data_array[i] = c
	}
	c_data_array[len(data)] = 0
	c_data_arrayPtr := &c_data_array[0]
	c_data := (*C.guchar)(unsafe.Pointer(c_data_arrayPtr))

	c_data_size := (C.gsize)(len(data))

	var c_result_uncertain C.gboolean

	retC := C.g_content_type_guess(c_filename, c_data, c_data_size, &c_result_uncertain)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	resultUncertain := c_result_uncertain == C.TRUE

	return retGo, resultUncertain
}

// ContentTypeGuessForTree is a wrapper around the C function g_content_type_guess_for_tree.
func ContentTypeGuessForTree(root *File) []string {
	c_root := (*C.GFile)(root.ToC())

	retC := C.g_content_type_guess_for_tree(c_root)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// ContentTypeIsA is a wrapper around the C function g_content_type_is_a.
func ContentTypeIsA(type_ string, supertype string) bool {
	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	c_supertype := C.CString(supertype)
	defer C.free(unsafe.Pointer(c_supertype))

	retC := C.g_content_type_is_a(c_type, c_supertype)
	retGo := retC == C.TRUE

	return retGo
}

// ContentTypeIsUnknown is a wrapper around the C function g_content_type_is_unknown.
func ContentTypeIsUnknown(type_ string) bool {
	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	retC := C.g_content_type_is_unknown(c_type)
	retGo := retC == C.TRUE

	return retGo
}

// ContentTypesGetRegistered is a wrapper around the C function g_content_types_get_registered.
func ContentTypesGetRegistered() *glib.List {
	retC := C.g_content_types_get_registered()
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DbusAddressEscapeValue is a wrapper around the C function g_dbus_address_escape_value.
func DbusAddressEscapeValue(string_ string) string {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.g_dbus_address_escape_value(c_string)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// DbusAddressGetForBusSync is a wrapper around the C function g_dbus_address_get_for_bus_sync.
func DbusAddressGetForBusSync(busType BusType, cancellable *Cancellable) (string, error) {
	c_bus_type := (C.GBusType)(busType)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_address_get_for_bus_sync(c_bus_type, c_cancellable, &cThrowableError)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_dbus_address_get_stream : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// DbusAddressGetStreamFinish is a wrapper around the C function g_dbus_address_get_stream_finish.
func DbusAddressGetStreamFinish(res *AsyncResult) (*IOStream, string, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var c_out_guid *C.gchar

	var cThrowableError *C.GError

	retC := C.g_dbus_address_get_stream_finish(c_res, &c_out_guid, &cThrowableError)
	retGo := IOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	outGuid := C.GoString(c_out_guid)
	defer C.free(unsafe.Pointer(c_out_guid))

	return retGo, outGuid, goError
}

// DbusAddressGetStreamSync is a wrapper around the C function g_dbus_address_get_stream_sync.
func DbusAddressGetStreamSync(address string, cancellable *Cancellable) (*IOStream, string, error) {
	c_address := C.CString(address)
	defer C.free(unsafe.Pointer(c_address))

	var c_out_guid *C.gchar

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_dbus_address_get_stream_sync(c_address, &c_out_guid, c_cancellable, &cThrowableError)
	retGo := IOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	outGuid := C.GoString(c_out_guid)
	defer C.free(unsafe.Pointer(c_out_guid))

	return retGo, outGuid, goError
}

// Unsupported : g_dbus_annotation_info_lookup : unsupported parameter annotations :

// Unsupported : g_dbus_error_register_error_domain : unsupported parameter entries :

// DbusGenerateGuid is a wrapper around the C function g_dbus_generate_guid.
func DbusGenerateGuid() string {
	retC := C.g_dbus_generate_guid()
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// DbusGvalueToGvariant is a wrapper around the C function g_dbus_gvalue_to_gvariant.
func DbusGvalueToGvariant(gvalue *gobject.Value, type_ *glib.VariantType) *glib.Variant {
	c_gvalue := (*C.GValue)(C.NULL)
	if gvalue != nil {
		c_gvalue = (*C.GValue)(gvalue.ToC())
	}

	c_type := (*C.GVariantType)(C.NULL)
	if type_ != nil {
		c_type = (*C.GVariantType)(type_.ToC())
	}

	retC := C.g_dbus_gvalue_to_gvariant(c_gvalue, c_type)
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DbusGvariantToGvalue is a wrapper around the C function g_dbus_gvariant_to_gvalue.
func DbusGvariantToGvalue(value *glib.Variant) *gobject.Value {
	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	var c_out_gvalue C.GValue

	C.g_dbus_gvariant_to_gvalue(c_value, &c_out_gvalue)

	outGvalue := gobject.ValueNewFromC(unsafe.Pointer(&c_out_gvalue))

	return outGvalue
}

// DbusIsAddress is a wrapper around the C function g_dbus_is_address.
func DbusIsAddress(string_ string) bool {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.g_dbus_is_address(c_string)
	retGo := retC == C.TRUE

	return retGo
}

// DbusIsGuid is a wrapper around the C function g_dbus_is_guid.
func DbusIsGuid(string_ string) bool {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.g_dbus_is_guid(c_string)
	retGo := retC == C.TRUE

	return retGo
}

// DbusIsInterfaceName is a wrapper around the C function g_dbus_is_interface_name.
func DbusIsInterfaceName(string_ string) bool {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.g_dbus_is_interface_name(c_string)
	retGo := retC == C.TRUE

	return retGo
}

// DbusIsMemberName is a wrapper around the C function g_dbus_is_member_name.
func DbusIsMemberName(string_ string) bool {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.g_dbus_is_member_name(c_string)
	retGo := retC == C.TRUE

	return retGo
}

// DbusIsName is a wrapper around the C function g_dbus_is_name.
func DbusIsName(string_ string) bool {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.g_dbus_is_name(c_string)
	retGo := retC == C.TRUE

	return retGo
}

// DbusIsSupportedAddress is a wrapper around the C function g_dbus_is_supported_address.
func DbusIsSupportedAddress(string_ string) (bool, error) {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	var cThrowableError *C.GError

	retC := C.g_dbus_is_supported_address(c_string, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DbusIsUniqueName is a wrapper around the C function g_dbus_is_unique_name.
func DbusIsUniqueName(string_ string) bool {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.g_dbus_is_unique_name(c_string)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_initable_newv : unsupported parameter parameters :

// IoErrorFromErrno is a wrapper around the C function g_io_error_from_errno.
func IoErrorFromErrno(errNo int32) IOErrorEnum {
	c_err_no := (C.gint)(errNo)

	retC := C.g_io_error_from_errno(c_err_no)
	retGo := (IOErrorEnum)(retC)

	return retGo
}

// IoErrorQuark is a wrapper around the C function g_io_error_quark.
func IoErrorQuark() glib.Quark {
	retC := C.g_io_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

// IoModulesLoadAllInDirectory is a wrapper around the C function g_io_modules_load_all_in_directory.
func IoModulesLoadAllInDirectory(dirname string) *glib.List {
	c_dirname := C.CString(dirname)
	defer C.free(unsafe.Pointer(c_dirname))

	retC := C.g_io_modules_load_all_in_directory(c_dirname)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IoModulesLoadAllInDirectoryWithScope is a wrapper around the C function g_io_modules_load_all_in_directory_with_scope.
func IoModulesLoadAllInDirectoryWithScope(dirname string, scope *IOModuleScope) *glib.List {
	c_dirname := C.CString(dirname)
	defer C.free(unsafe.Pointer(c_dirname))

	c_scope := (*C.GIOModuleScope)(C.NULL)
	if scope != nil {
		c_scope = (*C.GIOModuleScope)(scope.ToC())
	}

	retC := C.g_io_modules_load_all_in_directory_with_scope(c_dirname, c_scope)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IoModulesScanAllInDirectory is a wrapper around the C function g_io_modules_scan_all_in_directory.
func IoModulesScanAllInDirectory(dirname string) {
	c_dirname := C.CString(dirname)
	defer C.free(unsafe.Pointer(c_dirname))

	C.g_io_modules_scan_all_in_directory(c_dirname)

	return
}

// IoModulesScanAllInDirectoryWithScope is a wrapper around the C function g_io_modules_scan_all_in_directory_with_scope.
func IoModulesScanAllInDirectoryWithScope(dirname string, scope *IOModuleScope) {
	c_dirname := C.CString(dirname)
	defer C.free(unsafe.Pointer(c_dirname))

	c_scope := (*C.GIOModuleScope)(C.NULL)
	if scope != nil {
		c_scope = (*C.GIOModuleScope)(scope.ToC())
	}

	C.g_io_modules_scan_all_in_directory_with_scope(c_dirname, c_scope)

	return
}

// IoSchedulerCancelAllJobs is a wrapper around the C function g_io_scheduler_cancel_all_jobs.
func IoSchedulerCancelAllJobs() {
	C.g_io_scheduler_cancel_all_jobs()

	return
}

// Unsupported : g_io_scheduler_push_job : unsupported parameter job_func : no type generator for IOSchedulerJobFunc (GIOSchedulerJobFunc) for param job_func

// Blacklisted : g_keyfile_settings_backend_new

// Blacklisted : g_memory_settings_backend_new

// NetworkingInit is a wrapper around the C function g_networking_init.
func NetworkingInit() {
	C.g_networking_init()

	return
}

// Blacklisted : g_null_settings_backend_new

// PollableSourceNew is a wrapper around the C function g_pollable_source_new.
func PollableSourceNew(pollableStream *gobject.Object) *glib.Source {
	c_pollable_stream := (*C.GObject)(C.NULL)
	if pollableStream != nil {
		c_pollable_stream = (*C.GObject)(pollableStream.ToC())
	}

	retC := C.g_pollable_source_new(c_pollable_stream)
	retGo := glib.SourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// PollableSourceNewFull is a wrapper around the C function g_pollable_source_new_full.
func PollableSourceNewFull(pollableStream *gobject.Object, childSource *glib.Source, cancellable *Cancellable) *glib.Source {
	c_pollable_stream := (C.gpointer)(C.NULL)
	if pollableStream != nil {
		c_pollable_stream = (C.gpointer)(pollableStream.ToC())
	}

	c_child_source := (*C.GSource)(C.NULL)
	if childSource != nil {
		c_child_source = (*C.GSource)(childSource.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	retC := C.g_pollable_source_new_full(c_pollable_stream, c_child_source, c_cancellable)
	retGo := glib.SourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// PollableStreamRead is a wrapper around the C function g_pollable_stream_read.
func PollableStreamRead(stream *InputStream, buffer []uint8, blocking bool, cancellable *Cancellable) (int64, error) {
	c_stream := (*C.GInputStream)(C.NULL)
	if stream != nil {
		c_stream = (*C.GInputStream)(stream.ToC())
	}

	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	c_blocking :=
		boolToGboolean(blocking)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_pollable_stream_read(c_stream, c_buffer, c_count, c_blocking, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PollableStreamWrite is a wrapper around the C function g_pollable_stream_write.
func PollableStreamWrite(stream *OutputStream, buffer []uint8, blocking bool, cancellable *Cancellable) (int64, error) {
	c_stream := (*C.GOutputStream)(C.NULL)
	if stream != nil {
		c_stream = (*C.GOutputStream)(stream.ToC())
	}

	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	c_blocking :=
		boolToGboolean(blocking)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_pollable_stream_write(c_stream, c_buffer, c_count, c_blocking, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PollableStreamWriteAll is a wrapper around the C function g_pollable_stream_write_all.
func PollableStreamWriteAll(stream *OutputStream, buffer []uint8, blocking bool, cancellable *Cancellable) (bool, uint64, error) {
	c_stream := (*C.GOutputStream)(C.NULL)
	if stream != nil {
		c_stream = (*C.GOutputStream)(stream.ToC())
	}

	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	c_blocking :=
		boolToGboolean(blocking)

	var c_bytes_written C.gsize

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_pollable_stream_write_all(c_stream, c_buffer, c_count, c_blocking, &c_bytes_written, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	bytesWritten := (uint64)(c_bytes_written)

	return retGo, bytesWritten, goError
}

// ResourcesEnumerateChildren is a wrapper around the C function g_resources_enumerate_children.
func ResourcesEnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_lookup_flags := (C.GResourceLookupFlags)(lookupFlags)

	var cThrowableError *C.GError

	retC := C.g_resources_enumerate_children(c_path, c_lookup_flags, &cThrowableError)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ResourcesGetInfo is a wrapper around the C function g_resources_get_info.
func ResourcesGetInfo(path string, lookupFlags ResourceLookupFlags) (bool, uint64, uint32, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_lookup_flags := (C.GResourceLookupFlags)(lookupFlags)

	var c_size C.gsize

	var c_flags C.guint32

	var cThrowableError *C.GError

	retC := C.g_resources_get_info(c_path, c_lookup_flags, &c_size, &c_flags, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	size := (uint64)(c_size)

	flags := (uint32)(c_flags)

	return retGo, size, flags, goError
}

// ResourcesLookupData is a wrapper around the C function g_resources_lookup_data.
func ResourcesLookupData(path string, lookupFlags ResourceLookupFlags) (*glib.Bytes, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_lookup_flags := (C.GResourceLookupFlags)(lookupFlags)

	var cThrowableError *C.GError

	retC := C.g_resources_lookup_data(c_path, c_lookup_flags, &cThrowableError)
	retGo := glib.BytesNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ResourcesOpenStream is a wrapper around the C function g_resources_open_stream.
func ResourcesOpenStream(path string, lookupFlags ResourceLookupFlags) (*InputStream, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_lookup_flags := (C.GResourceLookupFlags)(lookupFlags)

	var cThrowableError *C.GError

	retC := C.g_resources_open_stream(c_path, c_lookup_flags, &cThrowableError)
	retGo := InputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ResourcesRegister is a wrapper around the C function g_resources_register.
func ResourcesRegister(resource *Resource) {
	c_resource := (*C.GResource)(C.NULL)
	if resource != nil {
		c_resource = (*C.GResource)(resource.ToC())
	}

	C.g_resources_register(c_resource)

	return
}

// ResourcesUnregister is a wrapper around the C function g_resources_unregister.
func ResourcesUnregister(resource *Resource) {
	c_resource := (*C.GResource)(C.NULL)
	if resource != nil {
		c_resource = (*C.GResource)(resource.ToC())
	}

	C.g_resources_unregister(c_resource)

	return
}

// Unsupported : g_simple_async_report_error_in_idle : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Unsupported : g_simple_async_report_gerror_in_idle : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Unsupported : g_simple_async_report_take_gerror_in_idle : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// UnixIsMountPathSystemInternal is a wrapper around the C function g_unix_is_mount_path_system_internal.
func UnixIsMountPathSystemInternal(mountPath string) bool {
	c_mount_path := C.CString(mountPath)
	defer C.free(unsafe.Pointer(c_mount_path))

	retC := C.g_unix_is_mount_path_system_internal(c_mount_path)
	retGo := retC == C.TRUE

	return retGo
}

// UnixMountAt is a wrapper around the C function g_unix_mount_at.
func UnixMountAt(mountPath string) (*UnixMountEntry, uint64) {
	c_mount_path := C.CString(mountPath)
	defer C.free(unsafe.Pointer(c_mount_path))

	var c_time_read C.guint64

	retC := C.g_unix_mount_at(c_mount_path, &c_time_read)
	retGo := UnixMountEntryNewFromC(unsafe.Pointer(retC))

	timeRead := (uint64)(c_time_read)

	return retGo, timeRead
}

// UnixMountCompare is a wrapper around the C function g_unix_mount_compare.
func UnixMountCompare(mount1 *UnixMountEntry, mount2 *UnixMountEntry) int32 {
	c_mount1 := (*C.GUnixMountEntry)(C.NULL)
	if mount1 != nil {
		c_mount1 = (*C.GUnixMountEntry)(mount1.ToC())
	}

	c_mount2 := (*C.GUnixMountEntry)(C.NULL)
	if mount2 != nil {
		c_mount2 = (*C.GUnixMountEntry)(mount2.ToC())
	}

	retC := C.g_unix_mount_compare(c_mount1, c_mount2)
	retGo := (int32)(retC)

	return retGo
}

// UnixMountFree is a wrapper around the C function g_unix_mount_free.
func UnixMountFree(mountEntry *UnixMountEntry) {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	C.g_unix_mount_free(c_mount_entry)

	return
}

// UnixMountGetDevicePath is a wrapper around the C function g_unix_mount_get_device_path.
func UnixMountGetDevicePath(mountEntry *UnixMountEntry) string {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_get_device_path(c_mount_entry)
	retGo := C.GoString(retC)

	return retGo
}

// UnixMountGetFsType is a wrapper around the C function g_unix_mount_get_fs_type.
func UnixMountGetFsType(mountEntry *UnixMountEntry) string {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_get_fs_type(c_mount_entry)
	retGo := C.GoString(retC)

	return retGo
}

// UnixMountGetMountPath is a wrapper around the C function g_unix_mount_get_mount_path.
func UnixMountGetMountPath(mountEntry *UnixMountEntry) string {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_get_mount_path(c_mount_entry)
	retGo := C.GoString(retC)

	return retGo
}

// UnixMountGuessCanEject is a wrapper around the C function g_unix_mount_guess_can_eject.
func UnixMountGuessCanEject(mountEntry *UnixMountEntry) bool {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_guess_can_eject(c_mount_entry)
	retGo := retC == C.TRUE

	return retGo
}

// UnixMountGuessIcon is a wrapper around the C function g_unix_mount_guess_icon.
func UnixMountGuessIcon(mountEntry *UnixMountEntry) *Icon {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_guess_icon(c_mount_entry)
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// UnixMountGuessName is a wrapper around the C function g_unix_mount_guess_name.
func UnixMountGuessName(mountEntry *UnixMountEntry) string {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_guess_name(c_mount_entry)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// UnixMountGuessShouldDisplay is a wrapper around the C function g_unix_mount_guess_should_display.
func UnixMountGuessShouldDisplay(mountEntry *UnixMountEntry) bool {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_guess_should_display(c_mount_entry)
	retGo := retC == C.TRUE

	return retGo
}

// UnixMountGuessSymbolicIcon is a wrapper around the C function g_unix_mount_guess_symbolic_icon.
func UnixMountGuessSymbolicIcon(mountEntry *UnixMountEntry) *Icon {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_guess_symbolic_icon(c_mount_entry)
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// UnixMountIsReadonly is a wrapper around the C function g_unix_mount_is_readonly.
func UnixMountIsReadonly(mountEntry *UnixMountEntry) bool {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_is_readonly(c_mount_entry)
	retGo := retC == C.TRUE

	return retGo
}

// UnixMountIsSystemInternal is a wrapper around the C function g_unix_mount_is_system_internal.
func UnixMountIsSystemInternal(mountEntry *UnixMountEntry) bool {
	c_mount_entry := (*C.GUnixMountEntry)(C.NULL)
	if mountEntry != nil {
		c_mount_entry = (*C.GUnixMountEntry)(mountEntry.ToC())
	}

	retC := C.g_unix_mount_is_system_internal(c_mount_entry)
	retGo := retC == C.TRUE

	return retGo
}

// UnixMountPointsChangedSince is a wrapper around the C function g_unix_mount_points_changed_since.
func UnixMountPointsChangedSince(time uint64) bool {
	c_time := (C.guint64)(time)

	retC := C.g_unix_mount_points_changed_since(c_time)
	retGo := retC == C.TRUE

	return retGo
}

// UnixMountPointsGet is a wrapper around the C function g_unix_mount_points_get.
func UnixMountPointsGet() (*glib.List, uint64) {
	var c_time_read C.guint64

	retC := C.g_unix_mount_points_get(&c_time_read)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	timeRead := (uint64)(c_time_read)

	return retGo, timeRead
}

// UnixMountsChangedSince is a wrapper around the C function g_unix_mounts_changed_since.
func UnixMountsChangedSince(time uint64) bool {
	c_time := (C.guint64)(time)

	retC := C.g_unix_mounts_changed_since(c_time)
	retGo := retC == C.TRUE

	return retGo
}

// UnixMountsGet is a wrapper around the C function g_unix_mounts_get.
func UnixMountsGet() (*glib.List, uint64) {
	var c_time_read C.guint64

	retC := C.g_unix_mounts_get(&c_time_read)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	timeRead := (uint64)(c_time_read)

	return retGo, timeRead
}

// Action is a wrapper around the C record GAction.
type Action struct {
	native *C.GAction
}

func ActionNewFromC(u unsafe.Pointer) *Action {
	c := (*C.GAction)(u)
	if c == nil {
		return nil
	}

	g := &Action{native: c}

	return g
}

func (recv *Action) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Action with another Action, and returns true if they represent the same GObject.
func (recv *Action) Equals(other *Action) bool {
	return other.ToC() == recv.ToC()
}

// Activate is a wrapper around the C function g_action_activate.
func (recv *Action) Activate(parameter *glib.Variant) {
	c_parameter := (*C.GVariant)(C.NULL)
	if parameter != nil {
		c_parameter = (*C.GVariant)(parameter.ToC())
	}

	C.g_action_activate((*C.GAction)(recv.native), c_parameter)

	return
}

// ChangeState is a wrapper around the C function g_action_change_state.
func (recv *Action) ChangeState(value *glib.Variant) {
	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	C.g_action_change_state((*C.GAction)(recv.native), c_value)

	return
}

// GetEnabled is a wrapper around the C function g_action_get_enabled.
func (recv *Action) GetEnabled() bool {
	retC := C.g_action_get_enabled((*C.GAction)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetName is a wrapper around the C function g_action_get_name.
func (recv *Action) GetName() string {
	retC := C.g_action_get_name((*C.GAction)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetParameterType is a wrapper around the C function g_action_get_parameter_type.
func (recv *Action) GetParameterType() *glib.VariantType {
	retC := C.g_action_get_parameter_type((*C.GAction)(recv.native))
	var retGo (*glib.VariantType)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantTypeNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetState is a wrapper around the C function g_action_get_state.
func (recv *Action) GetState() *glib.Variant {
	retC := C.g_action_get_state((*C.GAction)(recv.native))
	retGo := glib.VariantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetStateHint is a wrapper around the C function g_action_get_state_hint.
func (recv *Action) GetStateHint() *glib.Variant {
	retC := C.g_action_get_state_hint((*C.GAction)(recv.native))
	var retGo (*glib.Variant)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetStateType is a wrapper around the C function g_action_get_state_type.
func (recv *Action) GetStateType() *glib.VariantType {
	retC := C.g_action_get_state_type((*C.GAction)(recv.native))
	var retGo (*glib.VariantType)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantTypeNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ActionGroup is a wrapper around the C record GActionGroup.
type ActionGroup struct {
	native *C.GActionGroup
}

func ActionGroupNewFromC(u unsafe.Pointer) *ActionGroup {
	c := (*C.GActionGroup)(u)
	if c == nil {
		return nil
	}

	g := &ActionGroup{native: c}

	return g
}

func (recv *ActionGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionGroup with another ActionGroup, and returns true if they represent the same GObject.
func (recv *ActionGroup) Equals(other *ActionGroup) bool {
	return other.ToC() == recv.ToC()
}

type signalActionGroupActionAddedDetail struct {
	callback  ActionGroupSignalActionAddedCallback
	handlerID C.gulong
}

var signalActionGroupActionAddedId int
var signalActionGroupActionAddedMap = make(map[int]signalActionGroupActionAddedDetail)
var signalActionGroupActionAddedLock sync.RWMutex

// ActionGroupSignalActionAddedCallback is a callback function for a 'action-added' signal emitted from a ActionGroup.
type ActionGroupSignalActionAddedCallback func(actionName string)

/*
ConnectActionAdded connects the callback to the 'action-added' signal for the ActionGroup.

The returned value represents the connection, and may be passed to DisconnectActionAdded to remove it.
*/
func (recv *ActionGroup) ConnectActionAdded(callback ActionGroupSignalActionAddedCallback) int {
	signalActionGroupActionAddedLock.Lock()
	defer signalActionGroupActionAddedLock.Unlock()

	signalActionGroupActionAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ActionGroup_signal_connect_action_added(instance, C.gpointer(uintptr(signalActionGroupActionAddedId)))

	detail := signalActionGroupActionAddedDetail{callback, handlerID}
	signalActionGroupActionAddedMap[signalActionGroupActionAddedId] = detail

	return signalActionGroupActionAddedId
}

/*
DisconnectActionAdded disconnects a callback from the 'action-added' signal for the ActionGroup.

The connectionID should be a value returned from a call to ConnectActionAdded.
*/
func (recv *ActionGroup) DisconnectActionAdded(connectionID int) {
	signalActionGroupActionAddedLock.Lock()
	defer signalActionGroupActionAddedLock.Unlock()

	detail, exists := signalActionGroupActionAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionGroupActionAddedMap, connectionID)
}

//export actiongroup_actionAddedHandler
func actiongroup_actionAddedHandler(_ *C.GObject, c_action_name *C.gchar, data C.gpointer) {
	signalActionGroupActionAddedLock.RLock()
	defer signalActionGroupActionAddedLock.RUnlock()

	actionName := C.GoString(c_action_name)

	index := int(uintptr(data))
	callback := signalActionGroupActionAddedMap[index].callback
	callback(actionName)
}

type signalActionGroupActionEnabledChangedDetail struct {
	callback  ActionGroupSignalActionEnabledChangedCallback
	handlerID C.gulong
}

var signalActionGroupActionEnabledChangedId int
var signalActionGroupActionEnabledChangedMap = make(map[int]signalActionGroupActionEnabledChangedDetail)
var signalActionGroupActionEnabledChangedLock sync.RWMutex

// ActionGroupSignalActionEnabledChangedCallback is a callback function for a 'action-enabled-changed' signal emitted from a ActionGroup.
type ActionGroupSignalActionEnabledChangedCallback func(actionName string, enabled bool)

/*
ConnectActionEnabledChanged connects the callback to the 'action-enabled-changed' signal for the ActionGroup.

The returned value represents the connection, and may be passed to DisconnectActionEnabledChanged to remove it.
*/
func (recv *ActionGroup) ConnectActionEnabledChanged(callback ActionGroupSignalActionEnabledChangedCallback) int {
	signalActionGroupActionEnabledChangedLock.Lock()
	defer signalActionGroupActionEnabledChangedLock.Unlock()

	signalActionGroupActionEnabledChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ActionGroup_signal_connect_action_enabled_changed(instance, C.gpointer(uintptr(signalActionGroupActionEnabledChangedId)))

	detail := signalActionGroupActionEnabledChangedDetail{callback, handlerID}
	signalActionGroupActionEnabledChangedMap[signalActionGroupActionEnabledChangedId] = detail

	return signalActionGroupActionEnabledChangedId
}

/*
DisconnectActionEnabledChanged disconnects a callback from the 'action-enabled-changed' signal for the ActionGroup.

The connectionID should be a value returned from a call to ConnectActionEnabledChanged.
*/
func (recv *ActionGroup) DisconnectActionEnabledChanged(connectionID int) {
	signalActionGroupActionEnabledChangedLock.Lock()
	defer signalActionGroupActionEnabledChangedLock.Unlock()

	detail, exists := signalActionGroupActionEnabledChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionGroupActionEnabledChangedMap, connectionID)
}

//export actiongroup_actionEnabledChangedHandler
func actiongroup_actionEnabledChangedHandler(_ *C.GObject, c_action_name *C.gchar, c_enabled C.gboolean, data C.gpointer) {
	signalActionGroupActionEnabledChangedLock.RLock()
	defer signalActionGroupActionEnabledChangedLock.RUnlock()

	actionName := C.GoString(c_action_name)

	enabled := c_enabled == C.TRUE

	index := int(uintptr(data))
	callback := signalActionGroupActionEnabledChangedMap[index].callback
	callback(actionName, enabled)
}

type signalActionGroupActionRemovedDetail struct {
	callback  ActionGroupSignalActionRemovedCallback
	handlerID C.gulong
}

var signalActionGroupActionRemovedId int
var signalActionGroupActionRemovedMap = make(map[int]signalActionGroupActionRemovedDetail)
var signalActionGroupActionRemovedLock sync.RWMutex

// ActionGroupSignalActionRemovedCallback is a callback function for a 'action-removed' signal emitted from a ActionGroup.
type ActionGroupSignalActionRemovedCallback func(actionName string)

/*
ConnectActionRemoved connects the callback to the 'action-removed' signal for the ActionGroup.

The returned value represents the connection, and may be passed to DisconnectActionRemoved to remove it.
*/
func (recv *ActionGroup) ConnectActionRemoved(callback ActionGroupSignalActionRemovedCallback) int {
	signalActionGroupActionRemovedLock.Lock()
	defer signalActionGroupActionRemovedLock.Unlock()

	signalActionGroupActionRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ActionGroup_signal_connect_action_removed(instance, C.gpointer(uintptr(signalActionGroupActionRemovedId)))

	detail := signalActionGroupActionRemovedDetail{callback, handlerID}
	signalActionGroupActionRemovedMap[signalActionGroupActionRemovedId] = detail

	return signalActionGroupActionRemovedId
}

/*
DisconnectActionRemoved disconnects a callback from the 'action-removed' signal for the ActionGroup.

The connectionID should be a value returned from a call to ConnectActionRemoved.
*/
func (recv *ActionGroup) DisconnectActionRemoved(connectionID int) {
	signalActionGroupActionRemovedLock.Lock()
	defer signalActionGroupActionRemovedLock.Unlock()

	detail, exists := signalActionGroupActionRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionGroupActionRemovedMap, connectionID)
}

//export actiongroup_actionRemovedHandler
func actiongroup_actionRemovedHandler(_ *C.GObject, c_action_name *C.gchar, data C.gpointer) {
	signalActionGroupActionRemovedLock.RLock()
	defer signalActionGroupActionRemovedLock.RUnlock()

	actionName := C.GoString(c_action_name)

	index := int(uintptr(data))
	callback := signalActionGroupActionRemovedMap[index].callback
	callback(actionName)
}

type signalActionGroupActionStateChangedDetail struct {
	callback  ActionGroupSignalActionStateChangedCallback
	handlerID C.gulong
}

var signalActionGroupActionStateChangedId int
var signalActionGroupActionStateChangedMap = make(map[int]signalActionGroupActionStateChangedDetail)
var signalActionGroupActionStateChangedLock sync.RWMutex

// ActionGroupSignalActionStateChangedCallback is a callback function for a 'action-state-changed' signal emitted from a ActionGroup.
type ActionGroupSignalActionStateChangedCallback func(actionName string, value *glib.Variant)

/*
ConnectActionStateChanged connects the callback to the 'action-state-changed' signal for the ActionGroup.

The returned value represents the connection, and may be passed to DisconnectActionStateChanged to remove it.
*/
func (recv *ActionGroup) ConnectActionStateChanged(callback ActionGroupSignalActionStateChangedCallback) int {
	signalActionGroupActionStateChangedLock.Lock()
	defer signalActionGroupActionStateChangedLock.Unlock()

	signalActionGroupActionStateChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ActionGroup_signal_connect_action_state_changed(instance, C.gpointer(uintptr(signalActionGroupActionStateChangedId)))

	detail := signalActionGroupActionStateChangedDetail{callback, handlerID}
	signalActionGroupActionStateChangedMap[signalActionGroupActionStateChangedId] = detail

	return signalActionGroupActionStateChangedId
}

/*
DisconnectActionStateChanged disconnects a callback from the 'action-state-changed' signal for the ActionGroup.

The connectionID should be a value returned from a call to ConnectActionStateChanged.
*/
func (recv *ActionGroup) DisconnectActionStateChanged(connectionID int) {
	signalActionGroupActionStateChangedLock.Lock()
	defer signalActionGroupActionStateChangedLock.Unlock()

	detail, exists := signalActionGroupActionStateChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionGroupActionStateChangedMap, connectionID)
}

//export actiongroup_actionStateChangedHandler
func actiongroup_actionStateChangedHandler(_ *C.GObject, c_action_name *C.gchar, c_value *C.GVariant, data C.gpointer) {
	signalActionGroupActionStateChangedLock.RLock()
	defer signalActionGroupActionStateChangedLock.RUnlock()

	actionName := C.GoString(c_action_name)

	value := glib.VariantNewFromC(unsafe.Pointer(c_value))

	index := int(uintptr(data))
	callback := signalActionGroupActionStateChangedMap[index].callback
	callback(actionName, value)
}

// ActionAdded is a wrapper around the C function g_action_group_action_added.
func (recv *ActionGroup) ActionAdded(actionName string) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	C.g_action_group_action_added((*C.GActionGroup)(recv.native), c_action_name)

	return
}

// ActionEnabledChanged is a wrapper around the C function g_action_group_action_enabled_changed.
func (recv *ActionGroup) ActionEnabledChanged(actionName string, enabled bool) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	c_enabled :=
		boolToGboolean(enabled)

	C.g_action_group_action_enabled_changed((*C.GActionGroup)(recv.native), c_action_name, c_enabled)

	return
}

// ActionRemoved is a wrapper around the C function g_action_group_action_removed.
func (recv *ActionGroup) ActionRemoved(actionName string) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	C.g_action_group_action_removed((*C.GActionGroup)(recv.native), c_action_name)

	return
}

// ActionStateChanged is a wrapper around the C function g_action_group_action_state_changed.
func (recv *ActionGroup) ActionStateChanged(actionName string, state *glib.Variant) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	c_state := (*C.GVariant)(C.NULL)
	if state != nil {
		c_state = (*C.GVariant)(state.ToC())
	}

	C.g_action_group_action_state_changed((*C.GActionGroup)(recv.native), c_action_name, c_state)

	return
}

// ActivateAction is a wrapper around the C function g_action_group_activate_action.
func (recv *ActionGroup) ActivateAction(actionName string, parameter *glib.Variant) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	c_parameter := (*C.GVariant)(C.NULL)
	if parameter != nil {
		c_parameter = (*C.GVariant)(parameter.ToC())
	}

	C.g_action_group_activate_action((*C.GActionGroup)(recv.native), c_action_name, c_parameter)

	return
}

// ChangeActionState is a wrapper around the C function g_action_group_change_action_state.
func (recv *ActionGroup) ChangeActionState(actionName string, value *glib.Variant) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	C.g_action_group_change_action_state((*C.GActionGroup)(recv.native), c_action_name, c_value)

	return
}

// GetActionEnabled is a wrapper around the C function g_action_group_get_action_enabled.
func (recv *ActionGroup) GetActionEnabled(actionName string) bool {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.g_action_group_get_action_enabled((*C.GActionGroup)(recv.native), c_action_name)
	retGo := retC == C.TRUE

	return retGo
}

// GetActionParameterType is a wrapper around the C function g_action_group_get_action_parameter_type.
func (recv *ActionGroup) GetActionParameterType(actionName string) *glib.VariantType {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.g_action_group_get_action_parameter_type((*C.GActionGroup)(recv.native), c_action_name)
	var retGo (*glib.VariantType)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantTypeNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetActionState is a wrapper around the C function g_action_group_get_action_state.
func (recv *ActionGroup) GetActionState(actionName string) *glib.Variant {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.g_action_group_get_action_state((*C.GActionGroup)(recv.native), c_action_name)
	var retGo (*glib.Variant)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetActionStateHint is a wrapper around the C function g_action_group_get_action_state_hint.
func (recv *ActionGroup) GetActionStateHint(actionName string) *glib.Variant {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.g_action_group_get_action_state_hint((*C.GActionGroup)(recv.native), c_action_name)
	var retGo (*glib.Variant)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetActionStateType is a wrapper around the C function g_action_group_get_action_state_type.
func (recv *ActionGroup) GetActionStateType(actionName string) *glib.VariantType {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.g_action_group_get_action_state_type((*C.GActionGroup)(recv.native), c_action_name)
	var retGo (*glib.VariantType)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.VariantTypeNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// HasAction is a wrapper around the C function g_action_group_has_action.
func (recv *ActionGroup) HasAction(actionName string) bool {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.g_action_group_has_action((*C.GActionGroup)(recv.native), c_action_name)
	retGo := retC == C.TRUE

	return retGo
}

// ListActions is a wrapper around the C function g_action_group_list_actions.
func (recv *ActionGroup) ListActions() []string {
	retC := C.g_action_group_list_actions((*C.GActionGroup)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// QueryAction is a wrapper around the C function g_action_group_query_action.
func (recv *ActionGroup) QueryAction(actionName string) (bool, bool, *glib.VariantType, *glib.VariantType, *glib.Variant, *glib.Variant) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	var c_enabled C.gboolean

	var c_parameter_type *C.GVariantType

	var c_state_type *C.GVariantType

	var c_state_hint *C.GVariant

	var c_state *C.GVariant

	retC := C.g_action_group_query_action((*C.GActionGroup)(recv.native), c_action_name, &c_enabled, &c_parameter_type, &c_state_type, &c_state_hint, &c_state)
	retGo := retC == C.TRUE

	enabled := c_enabled == C.TRUE

	parameterType := glib.VariantTypeNewFromC(unsafe.Pointer(c_parameter_type))

	stateType := glib.VariantTypeNewFromC(unsafe.Pointer(c_state_type))

	stateHint := glib.VariantNewFromC(unsafe.Pointer(c_state_hint))

	state := glib.VariantNewFromC(unsafe.Pointer(c_state))

	return retGo, enabled, parameterType, stateType, stateHint, state
}

// ActionMap is a wrapper around the C record GActionMap.
type ActionMap struct {
	native *C.GActionMap
}

func ActionMapNewFromC(u unsafe.Pointer) *ActionMap {
	c := (*C.GActionMap)(u)
	if c == nil {
		return nil
	}

	g := &ActionMap{native: c}

	return g
}

func (recv *ActionMap) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionMap with another ActionMap, and returns true if they represent the same GObject.
func (recv *ActionMap) Equals(other *ActionMap) bool {
	return other.ToC() == recv.ToC()
}

// AddAction is a wrapper around the C function g_action_map_add_action.
func (recv *ActionMap) AddAction(action *Action) {
	c_action := (*C.GAction)(action.ToC())

	C.g_action_map_add_action((*C.GActionMap)(recv.native), c_action)

	return
}

// Unsupported : g_action_map_add_action_entries : unsupported parameter entries :

// LookupAction is a wrapper around the C function g_action_map_lookup_action.
func (recv *ActionMap) LookupAction(actionName string) *Action {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.g_action_map_lookup_action((*C.GActionMap)(recv.native), c_action_name)
	retGo := ActionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RemoveAction is a wrapper around the C function g_action_map_remove_action.
func (recv *ActionMap) RemoveAction(actionName string) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	C.g_action_map_remove_action((*C.GActionMap)(recv.native), c_action_name)

	return
}

// AppInfo is a wrapper around the C record GAppInfo.
type AppInfo struct {
	native *C.GAppInfo
}

func AppInfoNewFromC(u unsafe.Pointer) *AppInfo {
	c := (*C.GAppInfo)(u)
	if c == nil {
		return nil
	}

	g := &AppInfo{native: c}

	return g
}

func (recv *AppInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppInfo with another AppInfo, and returns true if they represent the same GObject.
func (recv *AppInfo) Equals(other *AppInfo) bool {
	return other.ToC() == recv.ToC()
}

// AppInfoCreateFromCommandline is a wrapper around the C function g_app_info_create_from_commandline.
func AppInfoCreateFromCommandline(commandline string, applicationName string, flags AppInfoCreateFlags) (*AppInfo, error) {
	c_commandline := C.CString(commandline)
	defer C.free(unsafe.Pointer(c_commandline))

	c_application_name := C.CString(applicationName)
	defer C.free(unsafe.Pointer(c_application_name))

	c_flags := (C.GAppInfoCreateFlags)(flags)

	var cThrowableError *C.GError

	retC := C.g_app_info_create_from_commandline(c_commandline, c_application_name, c_flags, &cThrowableError)
	retGo := AppInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// AppInfoGetAll is a wrapper around the C function g_app_info_get_all.
func AppInfoGetAll() *glib.List {
	retC := C.g_app_info_get_all()
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppInfoGetAllForType is a wrapper around the C function g_app_info_get_all_for_type.
func AppInfoGetAllForType(contentType string) *glib.List {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	retC := C.g_app_info_get_all_for_type(c_content_type)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppInfoGetDefaultForType is a wrapper around the C function g_app_info_get_default_for_type.
func AppInfoGetDefaultForType(contentType string, mustSupportUris bool) *AppInfo {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	c_must_support_uris :=
		boolToGboolean(mustSupportUris)

	retC := C.g_app_info_get_default_for_type(c_content_type, c_must_support_uris)
	retGo := AppInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppInfoGetDefaultForUriScheme is a wrapper around the C function g_app_info_get_default_for_uri_scheme.
func AppInfoGetDefaultForUriScheme(uriScheme string) *AppInfo {
	c_uri_scheme := C.CString(uriScheme)
	defer C.free(unsafe.Pointer(c_uri_scheme))

	retC := C.g_app_info_get_default_for_uri_scheme(c_uri_scheme)
	retGo := AppInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppInfoGetFallbackForType is a wrapper around the C function g_app_info_get_fallback_for_type.
func AppInfoGetFallbackForType(contentType string) *glib.List {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	retC := C.g_app_info_get_fallback_for_type(c_content_type)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppInfoGetRecommendedForType is a wrapper around the C function g_app_info_get_recommended_for_type.
func AppInfoGetRecommendedForType(contentType string) *glib.List {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	retC := C.g_app_info_get_recommended_for_type(c_content_type)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppInfoLaunchDefaultForUri is a wrapper around the C function g_app_info_launch_default_for_uri.
func AppInfoLaunchDefaultForUri(uri string, context *AppLaunchContext) (bool, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	c_context := (*C.GAppLaunchContext)(C.NULL)
	if context != nil {
		c_context = (*C.GAppLaunchContext)(context.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_app_info_launch_default_for_uri(c_uri, c_context, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// AppInfoResetTypeAssociations is a wrapper around the C function g_app_info_reset_type_associations.
func AppInfoResetTypeAssociations(contentType string) {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	C.g_app_info_reset_type_associations(c_content_type)

	return
}

// AddSupportsType is a wrapper around the C function g_app_info_add_supports_type.
func (recv *AppInfo) AddSupportsType(contentType string) (bool, error) {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	var cThrowableError *C.GError

	retC := C.g_app_info_add_supports_type((*C.GAppInfo)(recv.native), c_content_type, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// CanDelete is a wrapper around the C function g_app_info_can_delete.
func (recv *AppInfo) CanDelete() bool {
	retC := C.g_app_info_can_delete((*C.GAppInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CanRemoveSupportsType is a wrapper around the C function g_app_info_can_remove_supports_type.
func (recv *AppInfo) CanRemoveSupportsType() bool {
	retC := C.g_app_info_can_remove_supports_type((*C.GAppInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Delete is a wrapper around the C function g_app_info_delete.
func (recv *AppInfo) Delete() bool {
	retC := C.g_app_info_delete((*C.GAppInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Dup is a wrapper around the C function g_app_info_dup.
func (recv *AppInfo) Dup() *AppInfo {
	retC := C.g_app_info_dup((*C.GAppInfo)(recv.native))
	retGo := AppInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Equal is a wrapper around the C function g_app_info_equal.
func (recv *AppInfo) Equal(appinfo2 *AppInfo) bool {
	c_appinfo2 := (*C.GAppInfo)(appinfo2.ToC())

	retC := C.g_app_info_equal((*C.GAppInfo)(recv.native), c_appinfo2)
	retGo := retC == C.TRUE

	return retGo
}

// GetCommandline is a wrapper around the C function g_app_info_get_commandline.
func (recv *AppInfo) GetCommandline() string {
	retC := C.g_app_info_get_commandline((*C.GAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDescription is a wrapper around the C function g_app_info_get_description.
func (recv *AppInfo) GetDescription() string {
	retC := C.g_app_info_get_description((*C.GAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDisplayName is a wrapper around the C function g_app_info_get_display_name.
func (recv *AppInfo) GetDisplayName() string {
	retC := C.g_app_info_get_display_name((*C.GAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetExecutable is a wrapper around the C function g_app_info_get_executable.
func (recv *AppInfo) GetExecutable() string {
	retC := C.g_app_info_get_executable((*C.GAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetIcon is a wrapper around the C function g_app_info_get_icon.
func (recv *AppInfo) GetIcon() *Icon {
	retC := C.g_app_info_get_icon((*C.GAppInfo)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetId is a wrapper around the C function g_app_info_get_id.
func (recv *AppInfo) GetId() string {
	retC := C.g_app_info_get_id((*C.GAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetName is a wrapper around the C function g_app_info_get_name.
func (recv *AppInfo) GetName() string {
	retC := C.g_app_info_get_name((*C.GAppInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetSupportedTypes is a wrapper around the C function g_app_info_get_supported_types.
func (recv *AppInfo) GetSupportedTypes() []string {
	retC := C.g_app_info_get_supported_types((*C.GAppInfo)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// Launch is a wrapper around the C function g_app_info_launch.
func (recv *AppInfo) Launch(files *glib.List, context *AppLaunchContext) (bool, error) {
	c_files := (*C.GList)(C.NULL)
	if files != nil {
		c_files = (*C.GList)(files.ToC())
	}

	c_context := (*C.GAppLaunchContext)(C.NULL)
	if context != nil {
		c_context = (*C.GAppLaunchContext)(context.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_app_info_launch((*C.GAppInfo)(recv.native), c_files, c_context, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LaunchUris is a wrapper around the C function g_app_info_launch_uris.
func (recv *AppInfo) LaunchUris(uris *glib.List, context *AppLaunchContext) (bool, error) {
	c_uris := (*C.GList)(C.NULL)
	if uris != nil {
		c_uris = (*C.GList)(uris.ToC())
	}

	c_context := (*C.GAppLaunchContext)(C.NULL)
	if context != nil {
		c_context = (*C.GAppLaunchContext)(context.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_app_info_launch_uris((*C.GAppInfo)(recv.native), c_uris, c_context, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// RemoveSupportsType is a wrapper around the C function g_app_info_remove_supports_type.
func (recv *AppInfo) RemoveSupportsType(contentType string) (bool, error) {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	var cThrowableError *C.GError

	retC := C.g_app_info_remove_supports_type((*C.GAppInfo)(recv.native), c_content_type, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAsDefaultForExtension is a wrapper around the C function g_app_info_set_as_default_for_extension.
func (recv *AppInfo) SetAsDefaultForExtension(extension string) (bool, error) {
	c_extension := C.CString(extension)
	defer C.free(unsafe.Pointer(c_extension))

	var cThrowableError *C.GError

	retC := C.g_app_info_set_as_default_for_extension((*C.GAppInfo)(recv.native), c_extension, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAsDefaultForType is a wrapper around the C function g_app_info_set_as_default_for_type.
func (recv *AppInfo) SetAsDefaultForType(contentType string) (bool, error) {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	var cThrowableError *C.GError

	retC := C.g_app_info_set_as_default_for_type((*C.GAppInfo)(recv.native), c_content_type, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAsLastUsedForType is a wrapper around the C function g_app_info_set_as_last_used_for_type.
func (recv *AppInfo) SetAsLastUsedForType(contentType string) (bool, error) {
	c_content_type := C.CString(contentType)
	defer C.free(unsafe.Pointer(c_content_type))

	var cThrowableError *C.GError

	retC := C.g_app_info_set_as_last_used_for_type((*C.GAppInfo)(recv.native), c_content_type, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ShouldShow is a wrapper around the C function g_app_info_should_show.
func (recv *AppInfo) ShouldShow() bool {
	retC := C.g_app_info_should_show((*C.GAppInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SupportsFiles is a wrapper around the C function g_app_info_supports_files.
func (recv *AppInfo) SupportsFiles() bool {
	retC := C.g_app_info_supports_files((*C.GAppInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SupportsUris is a wrapper around the C function g_app_info_supports_uris.
func (recv *AppInfo) SupportsUris() bool {
	retC := C.g_app_info_supports_uris((*C.GAppInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// AsyncInitable is a wrapper around the C record GAsyncInitable.
type AsyncInitable struct {
	native *C.GAsyncInitable
}

func AsyncInitableNewFromC(u unsafe.Pointer) *AsyncInitable {
	c := (*C.GAsyncInitable)(u)
	if c == nil {
		return nil
	}

	g := &AsyncInitable{native: c}

	return g
}

func (recv *AsyncInitable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AsyncInitable with another AsyncInitable, and returns true if they represent the same GObject.
func (recv *AsyncInitable) Equals(other *AsyncInitable) bool {
	return other.ToC() == recv.ToC()
}

// g_async_initable_new_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback
// g_async_initable_new_valist_async : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args
// g_async_initable_newv_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback
// Unsupported : g_async_initable_init_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// InitFinish is a wrapper around the C function g_async_initable_init_finish.
func (recv *AsyncInitable) InitFinish(res *AsyncResult) (bool, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_async_initable_init_finish((*C.GAsyncInitable)(recv.native), c_res, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// NewFinish is a wrapper around the C function g_async_initable_new_finish.
func (recv *AsyncInitable) NewFinish(res *AsyncResult) (*gobject.Object, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_async_initable_new_finish((*C.GAsyncInitable)(recv.native), c_res, &cThrowableError)
	retGo := gobject.ObjectNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// AsyncResult is a wrapper around the C record GAsyncResult.
type AsyncResult struct {
	native *C.GAsyncResult
}

func AsyncResultNewFromC(u unsafe.Pointer) *AsyncResult {
	c := (*C.GAsyncResult)(u)
	if c == nil {
		return nil
	}

	g := &AsyncResult{native: c}

	return g
}

func (recv *AsyncResult) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AsyncResult with another AsyncResult, and returns true if they represent the same GObject.
func (recv *AsyncResult) Equals(other *AsyncResult) bool {
	return other.ToC() == recv.ToC()
}

// GetSourceObject is a wrapper around the C function g_async_result_get_source_object.
func (recv *AsyncResult) GetSourceObject() *gobject.Object {
	retC := C.g_async_result_get_source_object((*C.GAsyncResult)(recv.native))
	var retGo (*gobject.Object)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gobject.ObjectNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetUserData is a wrapper around the C function g_async_result_get_user_data.
func (recv *AsyncResult) GetUserData() uintptr {
	retC := C.g_async_result_get_user_data((*C.GAsyncResult)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// IsTagged is a wrapper around the C function g_async_result_is_tagged.
func (recv *AsyncResult) IsTagged(sourceTag uintptr) bool {
	c_source_tag := (C.gpointer)(sourceTag)

	retC := C.g_async_result_is_tagged((*C.GAsyncResult)(recv.native), c_source_tag)
	retGo := retC == C.TRUE

	return retGo
}

// LegacyPropagateError is a wrapper around the C function g_async_result_legacy_propagate_error.
func (recv *AsyncResult) LegacyPropagateError() (bool, error) {
	var cThrowableError *C.GError

	retC := C.g_async_result_legacy_propagate_error((*C.GAsyncResult)(recv.native), &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Converter is a wrapper around the C record GConverter.
type Converter struct {
	native *C.GConverter
}

func ConverterNewFromC(u unsafe.Pointer) *Converter {
	c := (*C.GConverter)(u)
	if c == nil {
		return nil
	}

	g := &Converter{native: c}

	return g
}

func (recv *Converter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Converter with another Converter, and returns true if they represent the same GObject.
func (recv *Converter) Equals(other *Converter) bool {
	return other.ToC() == recv.ToC()
}

// Convert is a wrapper around the C function g_converter_convert.
func (recv *Converter) Convert(inbuf []uint8, outbuf []uint8, flags ConverterFlags) (ConverterResult, uint64, uint64, error) {
	c_inbuf_array := make([]C.guint8, len(inbuf)+1, len(inbuf)+1)
	for i, item := range inbuf {
		c := (C.guint8)(item)
		c_inbuf_array[i] = c
	}
	c_inbuf_array[len(inbuf)] = 0
	c_inbuf_arrayPtr := &c_inbuf_array[0]
	c_inbuf := (unsafe.Pointer(c_inbuf_arrayPtr))

	c_inbuf_size := (C.gsize)(len(inbuf))

	c_outbuf_array := make([]C.guint8, len(outbuf)+1, len(outbuf)+1)
	for i, item := range outbuf {
		c := (C.guint8)(item)
		c_outbuf_array[i] = c
	}
	c_outbuf_array[len(outbuf)] = 0
	c_outbuf_arrayPtr := &c_outbuf_array[0]
	c_outbuf := (unsafe.Pointer(c_outbuf_arrayPtr))

	c_outbuf_size := (C.gsize)(len(outbuf))

	c_flags := (C.GConverterFlags)(flags)

	var c_bytes_read C.gsize

	var c_bytes_written C.gsize

	var cThrowableError *C.GError

	retC := C.g_converter_convert((*C.GConverter)(recv.native), c_inbuf, c_inbuf_size, c_outbuf, c_outbuf_size, c_flags, &c_bytes_read, &c_bytes_written, &cThrowableError)
	retGo := (ConverterResult)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	bytesRead := (uint64)(c_bytes_read)

	bytesWritten := (uint64)(c_bytes_written)

	return retGo, bytesRead, bytesWritten, goError
}

// Reset is a wrapper around the C function g_converter_reset.
func (recv *Converter) Reset() {
	C.g_converter_reset((*C.GConverter)(recv.native))

	return
}

// DBusInterface is a wrapper around the C record GDBusInterface.
type DBusInterface struct {
	native *C.GDBusInterface
}

func DBusInterfaceNewFromC(u unsafe.Pointer) *DBusInterface {
	c := (*C.GDBusInterface)(u)
	if c == nil {
		return nil
	}

	g := &DBusInterface{native: c}

	return g
}

func (recv *DBusInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusInterface with another DBusInterface, and returns true if they represent the same GObject.
func (recv *DBusInterface) Equals(other *DBusInterface) bool {
	return other.ToC() == recv.ToC()
}

// DupObject is a wrapper around the C function g_dbus_interface_dup_object.
func (recv *DBusInterface) DupObject() *DBusObject {
	retC := C.g_dbus_interface_dup_object((*C.GDBusInterface)(recv.native))
	retGo := DBusObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetInfo is a wrapper around the C function g_dbus_interface_get_info.
func (recv *DBusInterface) GetInfo() *DBusInterfaceInfo {
	retC := C.g_dbus_interface_get_info((*C.GDBusInterface)(recv.native))
	retGo := DBusInterfaceInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetObject is a wrapper around the C function g_dbus_interface_get_object.
func (recv *DBusInterface) GetObject() *DBusObject {
	retC := C.g_dbus_interface_get_object((*C.GDBusInterface)(recv.native))
	retGo := DBusObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetObject is a wrapper around the C function g_dbus_interface_set_object.
func (recv *DBusInterface) SetObject(object *DBusObject) {
	c_object := (*C.GDBusObject)(object.ToC())

	C.g_dbus_interface_set_object((*C.GDBusInterface)(recv.native), c_object)

	return
}

// DBusObject is a wrapper around the C record GDBusObject.
type DBusObject struct {
	native *C.GDBusObject
}

func DBusObjectNewFromC(u unsafe.Pointer) *DBusObject {
	c := (*C.GDBusObject)(u)
	if c == nil {
		return nil
	}

	g := &DBusObject{native: c}

	return g
}

func (recv *DBusObject) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObject with another DBusObject, and returns true if they represent the same GObject.
func (recv *DBusObject) Equals(other *DBusObject) bool {
	return other.ToC() == recv.ToC()
}

type signalDBusObjectInterfaceAddedDetail struct {
	callback  DBusObjectSignalInterfaceAddedCallback
	handlerID C.gulong
}

var signalDBusObjectInterfaceAddedId int
var signalDBusObjectInterfaceAddedMap = make(map[int]signalDBusObjectInterfaceAddedDetail)
var signalDBusObjectInterfaceAddedLock sync.RWMutex

// DBusObjectSignalInterfaceAddedCallback is a callback function for a 'interface-added' signal emitted from a DBusObject.
type DBusObjectSignalInterfaceAddedCallback func(interface_ *DBusInterface)

/*
ConnectInterfaceAdded connects the callback to the 'interface-added' signal for the DBusObject.

The returned value represents the connection, and may be passed to DisconnectInterfaceAdded to remove it.
*/
func (recv *DBusObject) ConnectInterfaceAdded(callback DBusObjectSignalInterfaceAddedCallback) int {
	signalDBusObjectInterfaceAddedLock.Lock()
	defer signalDBusObjectInterfaceAddedLock.Unlock()

	signalDBusObjectInterfaceAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusObject_signal_connect_interface_added(instance, C.gpointer(uintptr(signalDBusObjectInterfaceAddedId)))

	detail := signalDBusObjectInterfaceAddedDetail{callback, handlerID}
	signalDBusObjectInterfaceAddedMap[signalDBusObjectInterfaceAddedId] = detail

	return signalDBusObjectInterfaceAddedId
}

/*
DisconnectInterfaceAdded disconnects a callback from the 'interface-added' signal for the DBusObject.

The connectionID should be a value returned from a call to ConnectInterfaceAdded.
*/
func (recv *DBusObject) DisconnectInterfaceAdded(connectionID int) {
	signalDBusObjectInterfaceAddedLock.Lock()
	defer signalDBusObjectInterfaceAddedLock.Unlock()

	detail, exists := signalDBusObjectInterfaceAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusObjectInterfaceAddedMap, connectionID)
}

//export dbusobject_interfaceAddedHandler
func dbusobject_interfaceAddedHandler(_ *C.GObject, c_interface *C.GDBusInterface, data C.gpointer) {
	signalDBusObjectInterfaceAddedLock.RLock()
	defer signalDBusObjectInterfaceAddedLock.RUnlock()

	interface_ := DBusInterfaceNewFromC(unsafe.Pointer(c_interface))

	index := int(uintptr(data))
	callback := signalDBusObjectInterfaceAddedMap[index].callback
	callback(interface_)
}

type signalDBusObjectInterfaceRemovedDetail struct {
	callback  DBusObjectSignalInterfaceRemovedCallback
	handlerID C.gulong
}

var signalDBusObjectInterfaceRemovedId int
var signalDBusObjectInterfaceRemovedMap = make(map[int]signalDBusObjectInterfaceRemovedDetail)
var signalDBusObjectInterfaceRemovedLock sync.RWMutex

// DBusObjectSignalInterfaceRemovedCallback is a callback function for a 'interface-removed' signal emitted from a DBusObject.
type DBusObjectSignalInterfaceRemovedCallback func(interface_ *DBusInterface)

/*
ConnectInterfaceRemoved connects the callback to the 'interface-removed' signal for the DBusObject.

The returned value represents the connection, and may be passed to DisconnectInterfaceRemoved to remove it.
*/
func (recv *DBusObject) ConnectInterfaceRemoved(callback DBusObjectSignalInterfaceRemovedCallback) int {
	signalDBusObjectInterfaceRemovedLock.Lock()
	defer signalDBusObjectInterfaceRemovedLock.Unlock()

	signalDBusObjectInterfaceRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusObject_signal_connect_interface_removed(instance, C.gpointer(uintptr(signalDBusObjectInterfaceRemovedId)))

	detail := signalDBusObjectInterfaceRemovedDetail{callback, handlerID}
	signalDBusObjectInterfaceRemovedMap[signalDBusObjectInterfaceRemovedId] = detail

	return signalDBusObjectInterfaceRemovedId
}

/*
DisconnectInterfaceRemoved disconnects a callback from the 'interface-removed' signal for the DBusObject.

The connectionID should be a value returned from a call to ConnectInterfaceRemoved.
*/
func (recv *DBusObject) DisconnectInterfaceRemoved(connectionID int) {
	signalDBusObjectInterfaceRemovedLock.Lock()
	defer signalDBusObjectInterfaceRemovedLock.Unlock()

	detail, exists := signalDBusObjectInterfaceRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusObjectInterfaceRemovedMap, connectionID)
}

//export dbusobject_interfaceRemovedHandler
func dbusobject_interfaceRemovedHandler(_ *C.GObject, c_interface *C.GDBusInterface, data C.gpointer) {
	signalDBusObjectInterfaceRemovedLock.RLock()
	defer signalDBusObjectInterfaceRemovedLock.RUnlock()

	interface_ := DBusInterfaceNewFromC(unsafe.Pointer(c_interface))

	index := int(uintptr(data))
	callback := signalDBusObjectInterfaceRemovedMap[index].callback
	callback(interface_)
}

// GetInterface is a wrapper around the C function g_dbus_object_get_interface.
func (recv *DBusObject) GetInterface(interfaceName string) *DBusInterface {
	c_interface_name := C.CString(interfaceName)
	defer C.free(unsafe.Pointer(c_interface_name))

	retC := C.g_dbus_object_get_interface((*C.GDBusObject)(recv.native), c_interface_name)
	retGo := DBusInterfaceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetInterfaces is a wrapper around the C function g_dbus_object_get_interfaces.
func (recv *DBusObject) GetInterfaces() *glib.List {
	retC := C.g_dbus_object_get_interfaces((*C.GDBusObject)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetObjectPath is a wrapper around the C function g_dbus_object_get_object_path.
func (recv *DBusObject) GetObjectPath() string {
	retC := C.g_dbus_object_get_object_path((*C.GDBusObject)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// DBusObjectManager is a wrapper around the C record GDBusObjectManager.
type DBusObjectManager struct {
	native *C.GDBusObjectManager
}

func DBusObjectManagerNewFromC(u unsafe.Pointer) *DBusObjectManager {
	c := (*C.GDBusObjectManager)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectManager{native: c}

	return g
}

func (recv *DBusObjectManager) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectManager with another DBusObjectManager, and returns true if they represent the same GObject.
func (recv *DBusObjectManager) Equals(other *DBusObjectManager) bool {
	return other.ToC() == recv.ToC()
}

type signalDBusObjectManagerInterfaceAddedDetail struct {
	callback  DBusObjectManagerSignalInterfaceAddedCallback
	handlerID C.gulong
}

var signalDBusObjectManagerInterfaceAddedId int
var signalDBusObjectManagerInterfaceAddedMap = make(map[int]signalDBusObjectManagerInterfaceAddedDetail)
var signalDBusObjectManagerInterfaceAddedLock sync.RWMutex

// DBusObjectManagerSignalInterfaceAddedCallback is a callback function for a 'interface-added' signal emitted from a DBusObjectManager.
type DBusObjectManagerSignalInterfaceAddedCallback func(object *DBusObject, interface_ *DBusInterface)

/*
ConnectInterfaceAdded connects the callback to the 'interface-added' signal for the DBusObjectManager.

The returned value represents the connection, and may be passed to DisconnectInterfaceAdded to remove it.
*/
func (recv *DBusObjectManager) ConnectInterfaceAdded(callback DBusObjectManagerSignalInterfaceAddedCallback) int {
	signalDBusObjectManagerInterfaceAddedLock.Lock()
	defer signalDBusObjectManagerInterfaceAddedLock.Unlock()

	signalDBusObjectManagerInterfaceAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusObjectManager_signal_connect_interface_added(instance, C.gpointer(uintptr(signalDBusObjectManagerInterfaceAddedId)))

	detail := signalDBusObjectManagerInterfaceAddedDetail{callback, handlerID}
	signalDBusObjectManagerInterfaceAddedMap[signalDBusObjectManagerInterfaceAddedId] = detail

	return signalDBusObjectManagerInterfaceAddedId
}

/*
DisconnectInterfaceAdded disconnects a callback from the 'interface-added' signal for the DBusObjectManager.

The connectionID should be a value returned from a call to ConnectInterfaceAdded.
*/
func (recv *DBusObjectManager) DisconnectInterfaceAdded(connectionID int) {
	signalDBusObjectManagerInterfaceAddedLock.Lock()
	defer signalDBusObjectManagerInterfaceAddedLock.Unlock()

	detail, exists := signalDBusObjectManagerInterfaceAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusObjectManagerInterfaceAddedMap, connectionID)
}

//export dbusobjectmanager_interfaceAddedHandler
func dbusobjectmanager_interfaceAddedHandler(_ *C.GObject, c_object *C.GDBusObject, c_interface *C.GDBusInterface, data C.gpointer) {
	signalDBusObjectManagerInterfaceAddedLock.RLock()
	defer signalDBusObjectManagerInterfaceAddedLock.RUnlock()

	object := DBusObjectNewFromC(unsafe.Pointer(c_object))

	interface_ := DBusInterfaceNewFromC(unsafe.Pointer(c_interface))

	index := int(uintptr(data))
	callback := signalDBusObjectManagerInterfaceAddedMap[index].callback
	callback(object, interface_)
}

type signalDBusObjectManagerInterfaceRemovedDetail struct {
	callback  DBusObjectManagerSignalInterfaceRemovedCallback
	handlerID C.gulong
}

var signalDBusObjectManagerInterfaceRemovedId int
var signalDBusObjectManagerInterfaceRemovedMap = make(map[int]signalDBusObjectManagerInterfaceRemovedDetail)
var signalDBusObjectManagerInterfaceRemovedLock sync.RWMutex

// DBusObjectManagerSignalInterfaceRemovedCallback is a callback function for a 'interface-removed' signal emitted from a DBusObjectManager.
type DBusObjectManagerSignalInterfaceRemovedCallback func(object *DBusObject, interface_ *DBusInterface)

/*
ConnectInterfaceRemoved connects the callback to the 'interface-removed' signal for the DBusObjectManager.

The returned value represents the connection, and may be passed to DisconnectInterfaceRemoved to remove it.
*/
func (recv *DBusObjectManager) ConnectInterfaceRemoved(callback DBusObjectManagerSignalInterfaceRemovedCallback) int {
	signalDBusObjectManagerInterfaceRemovedLock.Lock()
	defer signalDBusObjectManagerInterfaceRemovedLock.Unlock()

	signalDBusObjectManagerInterfaceRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusObjectManager_signal_connect_interface_removed(instance, C.gpointer(uintptr(signalDBusObjectManagerInterfaceRemovedId)))

	detail := signalDBusObjectManagerInterfaceRemovedDetail{callback, handlerID}
	signalDBusObjectManagerInterfaceRemovedMap[signalDBusObjectManagerInterfaceRemovedId] = detail

	return signalDBusObjectManagerInterfaceRemovedId
}

/*
DisconnectInterfaceRemoved disconnects a callback from the 'interface-removed' signal for the DBusObjectManager.

The connectionID should be a value returned from a call to ConnectInterfaceRemoved.
*/
func (recv *DBusObjectManager) DisconnectInterfaceRemoved(connectionID int) {
	signalDBusObjectManagerInterfaceRemovedLock.Lock()
	defer signalDBusObjectManagerInterfaceRemovedLock.Unlock()

	detail, exists := signalDBusObjectManagerInterfaceRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusObjectManagerInterfaceRemovedMap, connectionID)
}

//export dbusobjectmanager_interfaceRemovedHandler
func dbusobjectmanager_interfaceRemovedHandler(_ *C.GObject, c_object *C.GDBusObject, c_interface *C.GDBusInterface, data C.gpointer) {
	signalDBusObjectManagerInterfaceRemovedLock.RLock()
	defer signalDBusObjectManagerInterfaceRemovedLock.RUnlock()

	object := DBusObjectNewFromC(unsafe.Pointer(c_object))

	interface_ := DBusInterfaceNewFromC(unsafe.Pointer(c_interface))

	index := int(uintptr(data))
	callback := signalDBusObjectManagerInterfaceRemovedMap[index].callback
	callback(object, interface_)
}

type signalDBusObjectManagerObjectAddedDetail struct {
	callback  DBusObjectManagerSignalObjectAddedCallback
	handlerID C.gulong
}

var signalDBusObjectManagerObjectAddedId int
var signalDBusObjectManagerObjectAddedMap = make(map[int]signalDBusObjectManagerObjectAddedDetail)
var signalDBusObjectManagerObjectAddedLock sync.RWMutex

// DBusObjectManagerSignalObjectAddedCallback is a callback function for a 'object-added' signal emitted from a DBusObjectManager.
type DBusObjectManagerSignalObjectAddedCallback func(object *DBusObject)

/*
ConnectObjectAdded connects the callback to the 'object-added' signal for the DBusObjectManager.

The returned value represents the connection, and may be passed to DisconnectObjectAdded to remove it.
*/
func (recv *DBusObjectManager) ConnectObjectAdded(callback DBusObjectManagerSignalObjectAddedCallback) int {
	signalDBusObjectManagerObjectAddedLock.Lock()
	defer signalDBusObjectManagerObjectAddedLock.Unlock()

	signalDBusObjectManagerObjectAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusObjectManager_signal_connect_object_added(instance, C.gpointer(uintptr(signalDBusObjectManagerObjectAddedId)))

	detail := signalDBusObjectManagerObjectAddedDetail{callback, handlerID}
	signalDBusObjectManagerObjectAddedMap[signalDBusObjectManagerObjectAddedId] = detail

	return signalDBusObjectManagerObjectAddedId
}

/*
DisconnectObjectAdded disconnects a callback from the 'object-added' signal for the DBusObjectManager.

The connectionID should be a value returned from a call to ConnectObjectAdded.
*/
func (recv *DBusObjectManager) DisconnectObjectAdded(connectionID int) {
	signalDBusObjectManagerObjectAddedLock.Lock()
	defer signalDBusObjectManagerObjectAddedLock.Unlock()

	detail, exists := signalDBusObjectManagerObjectAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusObjectManagerObjectAddedMap, connectionID)
}

//export dbusobjectmanager_objectAddedHandler
func dbusobjectmanager_objectAddedHandler(_ *C.GObject, c_object *C.GDBusObject, data C.gpointer) {
	signalDBusObjectManagerObjectAddedLock.RLock()
	defer signalDBusObjectManagerObjectAddedLock.RUnlock()

	object := DBusObjectNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalDBusObjectManagerObjectAddedMap[index].callback
	callback(object)
}

type signalDBusObjectManagerObjectRemovedDetail struct {
	callback  DBusObjectManagerSignalObjectRemovedCallback
	handlerID C.gulong
}

var signalDBusObjectManagerObjectRemovedId int
var signalDBusObjectManagerObjectRemovedMap = make(map[int]signalDBusObjectManagerObjectRemovedDetail)
var signalDBusObjectManagerObjectRemovedLock sync.RWMutex

// DBusObjectManagerSignalObjectRemovedCallback is a callback function for a 'object-removed' signal emitted from a DBusObjectManager.
type DBusObjectManagerSignalObjectRemovedCallback func(object *DBusObject)

/*
ConnectObjectRemoved connects the callback to the 'object-removed' signal for the DBusObjectManager.

The returned value represents the connection, and may be passed to DisconnectObjectRemoved to remove it.
*/
func (recv *DBusObjectManager) ConnectObjectRemoved(callback DBusObjectManagerSignalObjectRemovedCallback) int {
	signalDBusObjectManagerObjectRemovedLock.Lock()
	defer signalDBusObjectManagerObjectRemovedLock.Unlock()

	signalDBusObjectManagerObjectRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.DBusObjectManager_signal_connect_object_removed(instance, C.gpointer(uintptr(signalDBusObjectManagerObjectRemovedId)))

	detail := signalDBusObjectManagerObjectRemovedDetail{callback, handlerID}
	signalDBusObjectManagerObjectRemovedMap[signalDBusObjectManagerObjectRemovedId] = detail

	return signalDBusObjectManagerObjectRemovedId
}

/*
DisconnectObjectRemoved disconnects a callback from the 'object-removed' signal for the DBusObjectManager.

The connectionID should be a value returned from a call to ConnectObjectRemoved.
*/
func (recv *DBusObjectManager) DisconnectObjectRemoved(connectionID int) {
	signalDBusObjectManagerObjectRemovedLock.Lock()
	defer signalDBusObjectManagerObjectRemovedLock.Unlock()

	detail, exists := signalDBusObjectManagerObjectRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDBusObjectManagerObjectRemovedMap, connectionID)
}

//export dbusobjectmanager_objectRemovedHandler
func dbusobjectmanager_objectRemovedHandler(_ *C.GObject, c_object *C.GDBusObject, data C.gpointer) {
	signalDBusObjectManagerObjectRemovedLock.RLock()
	defer signalDBusObjectManagerObjectRemovedLock.RUnlock()

	object := DBusObjectNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalDBusObjectManagerObjectRemovedMap[index].callback
	callback(object)
}

// GetInterface is a wrapper around the C function g_dbus_object_manager_get_interface.
func (recv *DBusObjectManager) GetInterface(objectPath string, interfaceName string) *DBusInterface {
	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	c_interface_name := C.CString(interfaceName)
	defer C.free(unsafe.Pointer(c_interface_name))

	retC := C.g_dbus_object_manager_get_interface((*C.GDBusObjectManager)(recv.native), c_object_path, c_interface_name)
	retGo := DBusInterfaceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetObject is a wrapper around the C function g_dbus_object_manager_get_object.
func (recv *DBusObjectManager) GetObject(objectPath string) *DBusObject {
	c_object_path := C.CString(objectPath)
	defer C.free(unsafe.Pointer(c_object_path))

	retC := C.g_dbus_object_manager_get_object((*C.GDBusObjectManager)(recv.native), c_object_path)
	retGo := DBusObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetObjectPath is a wrapper around the C function g_dbus_object_manager_get_object_path.
func (recv *DBusObjectManager) GetObjectPath() string {
	retC := C.g_dbus_object_manager_get_object_path((*C.GDBusObjectManager)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetObjects is a wrapper around the C function g_dbus_object_manager_get_objects.
func (recv *DBusObjectManager) GetObjects() *glib.List {
	retC := C.g_dbus_object_manager_get_objects((*C.GDBusObjectManager)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DesktopAppInfoLookup is a wrapper around the C record GDesktopAppInfoLookup.
type DesktopAppInfoLookup struct {
	native *C.GDesktopAppInfoLookup
}

func DesktopAppInfoLookupNewFromC(u unsafe.Pointer) *DesktopAppInfoLookup {
	c := (*C.GDesktopAppInfoLookup)(u)
	if c == nil {
		return nil
	}

	g := &DesktopAppInfoLookup{native: c}

	return g
}

func (recv *DesktopAppInfoLookup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DesktopAppInfoLookup with another DesktopAppInfoLookup, and returns true if they represent the same GObject.
func (recv *DesktopAppInfoLookup) Equals(other *DesktopAppInfoLookup) bool {
	return other.ToC() == recv.ToC()
}

// GetDefaultForUriScheme is a wrapper around the C function g_desktop_app_info_lookup_get_default_for_uri_scheme.
func (recv *DesktopAppInfoLookup) GetDefaultForUriScheme(uriScheme string) *AppInfo {
	c_uri_scheme := C.CString(uriScheme)
	defer C.free(unsafe.Pointer(c_uri_scheme))

	retC := C.g_desktop_app_info_lookup_get_default_for_uri_scheme((*C.GDesktopAppInfoLookup)(recv.native), c_uri_scheme)
	retGo := AppInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Drive is a wrapper around the C record GDrive.
type Drive struct {
	native *C.GDrive
}

func DriveNewFromC(u unsafe.Pointer) *Drive {
	c := (*C.GDrive)(u)
	if c == nil {
		return nil
	}

	g := &Drive{native: c}

	return g
}

func (recv *Drive) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Drive with another Drive, and returns true if they represent the same GObject.
func (recv *Drive) Equals(other *Drive) bool {
	return other.ToC() == recv.ToC()
}

type signalDriveChangedDetail struct {
	callback  DriveSignalChangedCallback
	handlerID C.gulong
}

var signalDriveChangedId int
var signalDriveChangedMap = make(map[int]signalDriveChangedDetail)
var signalDriveChangedLock sync.RWMutex

// DriveSignalChangedCallback is a callback function for a 'changed' signal emitted from a Drive.
type DriveSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the Drive.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Drive) ConnectChanged(callback DriveSignalChangedCallback) int {
	signalDriveChangedLock.Lock()
	defer signalDriveChangedLock.Unlock()

	signalDriveChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Drive_signal_connect_changed(instance, C.gpointer(uintptr(signalDriveChangedId)))

	detail := signalDriveChangedDetail{callback, handlerID}
	signalDriveChangedMap[signalDriveChangedId] = detail

	return signalDriveChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Drive.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Drive) DisconnectChanged(connectionID int) {
	signalDriveChangedLock.Lock()
	defer signalDriveChangedLock.Unlock()

	detail, exists := signalDriveChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDriveChangedMap, connectionID)
}

//export drive_changedHandler
func drive_changedHandler(_ *C.GObject, data C.gpointer) {
	signalDriveChangedLock.RLock()
	defer signalDriveChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalDriveChangedMap[index].callback
	callback()
}

type signalDriveDisconnectedDetail struct {
	callback  DriveSignalDisconnectedCallback
	handlerID C.gulong
}

var signalDriveDisconnectedId int
var signalDriveDisconnectedMap = make(map[int]signalDriveDisconnectedDetail)
var signalDriveDisconnectedLock sync.RWMutex

// DriveSignalDisconnectedCallback is a callback function for a 'disconnected' signal emitted from a Drive.
type DriveSignalDisconnectedCallback func()

/*
ConnectDisconnected connects the callback to the 'disconnected' signal for the Drive.

The returned value represents the connection, and may be passed to DisconnectDisconnected to remove it.
*/
func (recv *Drive) ConnectDisconnected(callback DriveSignalDisconnectedCallback) int {
	signalDriveDisconnectedLock.Lock()
	defer signalDriveDisconnectedLock.Unlock()

	signalDriveDisconnectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Drive_signal_connect_disconnected(instance, C.gpointer(uintptr(signalDriveDisconnectedId)))

	detail := signalDriveDisconnectedDetail{callback, handlerID}
	signalDriveDisconnectedMap[signalDriveDisconnectedId] = detail

	return signalDriveDisconnectedId
}

/*
DisconnectDisconnected disconnects a callback from the 'disconnected' signal for the Drive.

The connectionID should be a value returned from a call to ConnectDisconnected.
*/
func (recv *Drive) DisconnectDisconnected(connectionID int) {
	signalDriveDisconnectedLock.Lock()
	defer signalDriveDisconnectedLock.Unlock()

	detail, exists := signalDriveDisconnectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDriveDisconnectedMap, connectionID)
}

//export drive_disconnectedHandler
func drive_disconnectedHandler(_ *C.GObject, data C.gpointer) {
	signalDriveDisconnectedLock.RLock()
	defer signalDriveDisconnectedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalDriveDisconnectedMap[index].callback
	callback()
}

type signalDriveEjectButtonDetail struct {
	callback  DriveSignalEjectButtonCallback
	handlerID C.gulong
}

var signalDriveEjectButtonId int
var signalDriveEjectButtonMap = make(map[int]signalDriveEjectButtonDetail)
var signalDriveEjectButtonLock sync.RWMutex

// DriveSignalEjectButtonCallback is a callback function for a 'eject-button' signal emitted from a Drive.
type DriveSignalEjectButtonCallback func()

/*
ConnectEjectButton connects the callback to the 'eject-button' signal for the Drive.

The returned value represents the connection, and may be passed to DisconnectEjectButton to remove it.
*/
func (recv *Drive) ConnectEjectButton(callback DriveSignalEjectButtonCallback) int {
	signalDriveEjectButtonLock.Lock()
	defer signalDriveEjectButtonLock.Unlock()

	signalDriveEjectButtonId++
	instance := C.gpointer(recv.native)
	handlerID := C.Drive_signal_connect_eject_button(instance, C.gpointer(uintptr(signalDriveEjectButtonId)))

	detail := signalDriveEjectButtonDetail{callback, handlerID}
	signalDriveEjectButtonMap[signalDriveEjectButtonId] = detail

	return signalDriveEjectButtonId
}

/*
DisconnectEjectButton disconnects a callback from the 'eject-button' signal for the Drive.

The connectionID should be a value returned from a call to ConnectEjectButton.
*/
func (recv *Drive) DisconnectEjectButton(connectionID int) {
	signalDriveEjectButtonLock.Lock()
	defer signalDriveEjectButtonLock.Unlock()

	detail, exists := signalDriveEjectButtonMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDriveEjectButtonMap, connectionID)
}

//export drive_ejectButtonHandler
func drive_ejectButtonHandler(_ *C.GObject, data C.gpointer) {
	signalDriveEjectButtonLock.RLock()
	defer signalDriveEjectButtonLock.RUnlock()

	index := int(uintptr(data))
	callback := signalDriveEjectButtonMap[index].callback
	callback()
}

type signalDriveStopButtonDetail struct {
	callback  DriveSignalStopButtonCallback
	handlerID C.gulong
}

var signalDriveStopButtonId int
var signalDriveStopButtonMap = make(map[int]signalDriveStopButtonDetail)
var signalDriveStopButtonLock sync.RWMutex

// DriveSignalStopButtonCallback is a callback function for a 'stop-button' signal emitted from a Drive.
type DriveSignalStopButtonCallback func()

/*
ConnectStopButton connects the callback to the 'stop-button' signal for the Drive.

The returned value represents the connection, and may be passed to DisconnectStopButton to remove it.
*/
func (recv *Drive) ConnectStopButton(callback DriveSignalStopButtonCallback) int {
	signalDriveStopButtonLock.Lock()
	defer signalDriveStopButtonLock.Unlock()

	signalDriveStopButtonId++
	instance := C.gpointer(recv.native)
	handlerID := C.Drive_signal_connect_stop_button(instance, C.gpointer(uintptr(signalDriveStopButtonId)))

	detail := signalDriveStopButtonDetail{callback, handlerID}
	signalDriveStopButtonMap[signalDriveStopButtonId] = detail

	return signalDriveStopButtonId
}

/*
DisconnectStopButton disconnects a callback from the 'stop-button' signal for the Drive.

The connectionID should be a value returned from a call to ConnectStopButton.
*/
func (recv *Drive) DisconnectStopButton(connectionID int) {
	signalDriveStopButtonLock.Lock()
	defer signalDriveStopButtonLock.Unlock()

	detail, exists := signalDriveStopButtonMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDriveStopButtonMap, connectionID)
}

//export drive_stopButtonHandler
func drive_stopButtonHandler(_ *C.GObject, data C.gpointer) {
	signalDriveStopButtonLock.RLock()
	defer signalDriveStopButtonLock.RUnlock()

	index := int(uintptr(data))
	callback := signalDriveStopButtonMap[index].callback
	callback()
}

// CanEject is a wrapper around the C function g_drive_can_eject.
func (recv *Drive) CanEject() bool {
	retC := C.g_drive_can_eject((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CanPollForMedia is a wrapper around the C function g_drive_can_poll_for_media.
func (recv *Drive) CanPollForMedia() bool {
	retC := C.g_drive_can_poll_for_media((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CanStart is a wrapper around the C function g_drive_can_start.
func (recv *Drive) CanStart() bool {
	retC := C.g_drive_can_start((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CanStartDegraded is a wrapper around the C function g_drive_can_start_degraded.
func (recv *Drive) CanStartDegraded() bool {
	retC := C.g_drive_can_start_degraded((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CanStop is a wrapper around the C function g_drive_can_stop.
func (recv *Drive) CanStop() bool {
	retC := C.g_drive_can_stop((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_drive_eject : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EjectFinish is a wrapper around the C function g_drive_eject_finish.
func (recv *Drive) EjectFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_drive_eject_finish((*C.GDrive)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_drive_eject_with_operation : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EjectWithOperationFinish is a wrapper around the C function g_drive_eject_with_operation_finish.
func (recv *Drive) EjectWithOperationFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_drive_eject_with_operation_finish((*C.GDrive)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// EnumerateIdentifiers is a wrapper around the C function g_drive_enumerate_identifiers.
func (recv *Drive) EnumerateIdentifiers() []string {
	retC := C.g_drive_enumerate_identifiers((*C.GDrive)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// GetIcon is a wrapper around the C function g_drive_get_icon.
func (recv *Drive) GetIcon() *Icon {
	retC := C.g_drive_get_icon((*C.GDrive)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIdentifier is a wrapper around the C function g_drive_get_identifier.
func (recv *Drive) GetIdentifier(kind string) string {
	c_kind := C.CString(kind)
	defer C.free(unsafe.Pointer(c_kind))

	retC := C.g_drive_get_identifier((*C.GDrive)(recv.native), c_kind)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetName is a wrapper around the C function g_drive_get_name.
func (recv *Drive) GetName() string {
	retC := C.g_drive_get_name((*C.GDrive)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetSortKey is a wrapper around the C function g_drive_get_sort_key.
func (recv *Drive) GetSortKey() string {
	retC := C.g_drive_get_sort_key((*C.GDrive)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetStartStopType is a wrapper around the C function g_drive_get_start_stop_type.
func (recv *Drive) GetStartStopType() DriveStartStopType {
	retC := C.g_drive_get_start_stop_type((*C.GDrive)(recv.native))
	retGo := (DriveStartStopType)(retC)

	return retGo
}

// GetSymbolicIcon is a wrapper around the C function g_drive_get_symbolic_icon.
func (recv *Drive) GetSymbolicIcon() *Icon {
	retC := C.g_drive_get_symbolic_icon((*C.GDrive)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetVolumes is a wrapper around the C function g_drive_get_volumes.
func (recv *Drive) GetVolumes() *glib.List {
	retC := C.g_drive_get_volumes((*C.GDrive)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// HasMedia is a wrapper around the C function g_drive_has_media.
func (recv *Drive) HasMedia() bool {
	retC := C.g_drive_has_media((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// HasVolumes is a wrapper around the C function g_drive_has_volumes.
func (recv *Drive) HasVolumes() bool {
	retC := C.g_drive_has_volumes((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsMediaCheckAutomatic is a wrapper around the C function g_drive_is_media_check_automatic.
func (recv *Drive) IsMediaCheckAutomatic() bool {
	retC := C.g_drive_is_media_check_automatic((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsMediaRemovable is a wrapper around the C function g_drive_is_media_removable.
func (recv *Drive) IsMediaRemovable() bool {
	retC := C.g_drive_is_media_removable((*C.GDrive)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_drive_poll_for_media : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// PollForMediaFinish is a wrapper around the C function g_drive_poll_for_media_finish.
func (recv *Drive) PollForMediaFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_drive_poll_for_media_finish((*C.GDrive)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_drive_start : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// StartFinish is a wrapper around the C function g_drive_start_finish.
func (recv *Drive) StartFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_drive_start_finish((*C.GDrive)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_drive_stop : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// StopFinish is a wrapper around the C function g_drive_stop_finish.
func (recv *Drive) StopFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_drive_stop_finish((*C.GDrive)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// File is a wrapper around the C record GFile.
type File struct {
	native *C.GFile
}

func FileNewFromC(u unsafe.Pointer) *File {
	c := (*C.GFile)(u)
	if c == nil {
		return nil
	}

	g := &File{native: c}

	return g
}

func (recv *File) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this File with another File, and returns true if they represent the same GObject.
func (recv *File) Equals(other *File) bool {
	return other.ToC() == recv.ToC()
}

// FileNewForCommandlineArg is a wrapper around the C function g_file_new_for_commandline_arg.
func FileNewForCommandlineArg(arg string) *File {
	c_arg := C.CString(arg)
	defer C.free(unsafe.Pointer(c_arg))

	retC := C.g_file_new_for_commandline_arg(c_arg)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// FileNewForCommandlineArgAndCwd is a wrapper around the C function g_file_new_for_commandline_arg_and_cwd.
func FileNewForCommandlineArgAndCwd(arg string, cwd string) *File {
	c_arg := C.CString(arg)
	defer C.free(unsafe.Pointer(c_arg))

	c_cwd := C.CString(cwd)
	defer C.free(unsafe.Pointer(c_cwd))

	retC := C.g_file_new_for_commandline_arg_and_cwd(c_arg, c_cwd)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// FileNewForPath is a wrapper around the C function g_file_new_for_path.
func FileNewForPath(path string) *File {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.g_file_new_for_path(c_path)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// FileNewForUri is a wrapper around the C function g_file_new_for_uri.
func FileNewForUri(uri string) *File {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	retC := C.g_file_new_for_uri(c_uri)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// FileNewTmp is a wrapper around the C function g_file_new_tmp.
func FileNewTmp(tmpl string) (*File, *FileIOStream, error) {
	c_tmpl := C.CString(tmpl)
	defer C.free(unsafe.Pointer(c_tmpl))

	var c_iostream *C.GFileIOStream

	var cThrowableError *C.GError

	retC := C.g_file_new_tmp(c_tmpl, &c_iostream, &cThrowableError)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	iostream := FileIOStreamNewFromC(unsafe.Pointer(c_iostream))

	return retGo, iostream, goError
}

// FileParseName is a wrapper around the C function g_file_parse_name.
func FileParseName(parseName string) *File {
	c_parse_name := C.CString(parseName)
	defer C.free(unsafe.Pointer(c_parse_name))

	retC := C.g_file_parse_name(c_parse_name)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppendTo is a wrapper around the C function g_file_append_to.
func (recv *File) AppendTo(flags FileCreateFlags, cancellable *Cancellable) (*FileOutputStream, error) {
	c_flags := (C.GFileCreateFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_append_to((*C.GFile)(recv.native), c_flags, c_cancellable, &cThrowableError)
	retGo := FileOutputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_append_to_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// AppendToFinish is a wrapper around the C function g_file_append_to_finish.
func (recv *File) AppendToFinish(res *AsyncResult) (*FileOutputStream, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_append_to_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileOutputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_copy : unsupported parameter progress_callback : no type generator for FileProgressCallback (GFileProgressCallback) for param progress_callback

// Unsupported : g_file_copy_async : unsupported parameter progress_callback : no type generator for FileProgressCallback (GFileProgressCallback) for param progress_callback

// CopyAttributes is a wrapper around the C function g_file_copy_attributes.
func (recv *File) CopyAttributes(destination *File, flags FileCopyFlags, cancellable *Cancellable) (bool, error) {
	c_destination := (*C.GFile)(destination.ToC())

	c_flags := (C.GFileCopyFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_copy_attributes((*C.GFile)(recv.native), c_destination, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// CopyFinish is a wrapper around the C function g_file_copy_finish.
func (recv *File) CopyFinish(res *AsyncResult) (bool, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_copy_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Create is a wrapper around the C function g_file_create.
func (recv *File) Create(flags FileCreateFlags, cancellable *Cancellable) (*FileOutputStream, error) {
	c_flags := (C.GFileCreateFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_create((*C.GFile)(recv.native), c_flags, c_cancellable, &cThrowableError)
	retGo := FileOutputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_create_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CreateFinish is a wrapper around the C function g_file_create_finish.
func (recv *File) CreateFinish(res *AsyncResult) (*FileOutputStream, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_create_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileOutputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// CreateReadwrite is a wrapper around the C function g_file_create_readwrite.
func (recv *File) CreateReadwrite(flags FileCreateFlags, cancellable *Cancellable) (*FileIOStream, error) {
	c_flags := (C.GFileCreateFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_create_readwrite((*C.GFile)(recv.native), c_flags, c_cancellable, &cThrowableError)
	retGo := FileIOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_create_readwrite_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CreateReadwriteFinish is a wrapper around the C function g_file_create_readwrite_finish.
func (recv *File) CreateReadwriteFinish(res *AsyncResult) (*FileIOStream, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_create_readwrite_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileIOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Delete is a wrapper around the C function g_file_delete.
func (recv *File) Delete(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_delete((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_delete_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// DeleteFinish is a wrapper around the C function g_file_delete_finish.
func (recv *File) DeleteFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_delete_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Dup is a wrapper around the C function g_file_dup.
func (recv *File) Dup() *File {
	retC := C.g_file_dup((*C.GFile)(recv.native))
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : g_file_eject_mountable : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EjectMountableFinish is a wrapper around the C function g_file_eject_mountable_finish.
func (recv *File) EjectMountableFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_eject_mountable_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_eject_mountable_with_operation : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EjectMountableWithOperationFinish is a wrapper around the C function g_file_eject_mountable_with_operation_finish.
func (recv *File) EjectMountableWithOperationFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_eject_mountable_with_operation_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// EnumerateChildren is a wrapper around the C function g_file_enumerate_children.
func (recv *File) EnumerateChildren(attributes string, flags FileQueryInfoFlags, cancellable *Cancellable) (*FileEnumerator, error) {
	c_attributes := C.CString(attributes)
	defer C.free(unsafe.Pointer(c_attributes))

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_enumerate_children((*C.GFile)(recv.native), c_attributes, c_flags, c_cancellable, &cThrowableError)
	retGo := FileEnumeratorNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_enumerate_children_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EnumerateChildrenFinish is a wrapper around the C function g_file_enumerate_children_finish.
func (recv *File) EnumerateChildrenFinish(res *AsyncResult) (*FileEnumerator, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_enumerate_children_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileEnumeratorNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Equal is a wrapper around the C function g_file_equal.
func (recv *File) Equal(file2 *File) bool {
	c_file2 := (*C.GFile)(file2.ToC())

	retC := C.g_file_equal((*C.GFile)(recv.native), c_file2)
	retGo := retC == C.TRUE

	return retGo
}

// FindEnclosingMount is a wrapper around the C function g_file_find_enclosing_mount.
func (recv *File) FindEnclosingMount(cancellable *Cancellable) (*Mount, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_find_enclosing_mount((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := MountNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_find_enclosing_mount_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// FindEnclosingMountFinish is a wrapper around the C function g_file_find_enclosing_mount_finish.
func (recv *File) FindEnclosingMountFinish(res *AsyncResult) (*Mount, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_find_enclosing_mount_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := MountNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetBasename is a wrapper around the C function g_file_get_basename.
func (recv *File) GetBasename() string {
	retC := C.g_file_get_basename((*C.GFile)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetChild is a wrapper around the C function g_file_get_child.
func (recv *File) GetChild(name string) *File {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_file_get_child((*C.GFile)(recv.native), c_name)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetChildForDisplayName is a wrapper around the C function g_file_get_child_for_display_name.
func (recv *File) GetChildForDisplayName(displayName string) (*File, error) {
	c_display_name := C.CString(displayName)
	defer C.free(unsafe.Pointer(c_display_name))

	var cThrowableError *C.GError

	retC := C.g_file_get_child_for_display_name((*C.GFile)(recv.native), c_display_name, &cThrowableError)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetParent is a wrapper around the C function g_file_get_parent.
func (recv *File) GetParent() *File {
	retC := C.g_file_get_parent((*C.GFile)(recv.native))
	var retGo (*File)
	if retC == nil {
		retGo = nil
	} else {
		retGo = FileNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetParseName is a wrapper around the C function g_file_get_parse_name.
func (recv *File) GetParseName() string {
	retC := C.g_file_get_parse_name((*C.GFile)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetPath is a wrapper around the C function g_file_get_path.
func (recv *File) GetPath() string {
	retC := C.g_file_get_path((*C.GFile)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetRelativePath is a wrapper around the C function g_file_get_relative_path.
func (recv *File) GetRelativePath(descendant *File) string {
	c_descendant := (*C.GFile)(descendant.ToC())

	retC := C.g_file_get_relative_path((*C.GFile)(recv.native), c_descendant)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetUri is a wrapper around the C function g_file_get_uri.
func (recv *File) GetUri() string {
	retC := C.g_file_get_uri((*C.GFile)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetUriScheme is a wrapper around the C function g_file_get_uri_scheme.
func (recv *File) GetUriScheme() string {
	retC := C.g_file_get_uri_scheme((*C.GFile)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// HasParent is a wrapper around the C function g_file_has_parent.
func (recv *File) HasParent(parent *File) bool {
	c_parent := (*C.GFile)(parent.ToC())

	retC := C.g_file_has_parent((*C.GFile)(recv.native), c_parent)
	retGo := retC == C.TRUE

	return retGo
}

// HasPrefix is a wrapper around the C function g_file_has_prefix.
func (recv *File) HasPrefix(prefix *File) bool {
	c_prefix := (*C.GFile)(prefix.ToC())

	retC := C.g_file_has_prefix((*C.GFile)(recv.native), c_prefix)
	retGo := retC == C.TRUE

	return retGo
}

// HasUriScheme is a wrapper around the C function g_file_has_uri_scheme.
func (recv *File) HasUriScheme(uriScheme string) bool {
	c_uri_scheme := C.CString(uriScheme)
	defer C.free(unsafe.Pointer(c_uri_scheme))

	retC := C.g_file_has_uri_scheme((*C.GFile)(recv.native), c_uri_scheme)
	retGo := retC == C.TRUE

	return retGo
}

// Hash is a wrapper around the C function g_file_hash.
func (recv *File) Hash() uint32 {
	retC := C.g_file_hash((C.gconstpointer)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// IsNative is a wrapper around the C function g_file_is_native.
func (recv *File) IsNative() bool {
	retC := C.g_file_is_native((*C.GFile)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_file_load_contents : unsupported parameter contents : output array param contents

// Unsupported : g_file_load_contents_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// Unsupported : g_file_load_contents_finish : unsupported parameter contents : output array param contents

// Unsupported : g_file_load_partial_contents_async : unsupported parameter read_more_callback : no type generator for FileReadMoreCallback (GFileReadMoreCallback) for param read_more_callback

// Unsupported : g_file_load_partial_contents_finish : unsupported parameter contents : output array param contents

// MakeDirectory is a wrapper around the C function g_file_make_directory.
func (recv *File) MakeDirectory(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_make_directory((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// MakeDirectoryWithParents is a wrapper around the C function g_file_make_directory_with_parents.
func (recv *File) MakeDirectoryWithParents(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_make_directory_with_parents((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// MakeSymbolicLink is a wrapper around the C function g_file_make_symbolic_link.
func (recv *File) MakeSymbolicLink(symlinkValue string, cancellable *Cancellable) (bool, error) {
	c_symlink_value := C.CString(symlinkValue)
	defer C.free(unsafe.Pointer(c_symlink_value))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_make_symbolic_link((*C.GFile)(recv.native), c_symlink_value, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Monitor is a wrapper around the C function g_file_monitor.
func (recv *File) Monitor(flags FileMonitorFlags, cancellable *Cancellable) (*FileMonitor, error) {
	c_flags := (C.GFileMonitorFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_monitor((*C.GFile)(recv.native), c_flags, c_cancellable, &cThrowableError)
	retGo := FileMonitorNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// MonitorDirectory is a wrapper around the C function g_file_monitor_directory.
func (recv *File) MonitorDirectory(flags FileMonitorFlags, cancellable *Cancellable) (*FileMonitor, error) {
	c_flags := (C.GFileMonitorFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_monitor_directory((*C.GFile)(recv.native), c_flags, c_cancellable, &cThrowableError)
	retGo := FileMonitorNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// MonitorFile is a wrapper around the C function g_file_monitor_file.
func (recv *File) MonitorFile(flags FileMonitorFlags, cancellable *Cancellable) (*FileMonitor, error) {
	c_flags := (C.GFileMonitorFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_monitor_file((*C.GFile)(recv.native), c_flags, c_cancellable, &cThrowableError)
	retGo := FileMonitorNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_mount_enclosing_volume : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// MountEnclosingVolumeFinish is a wrapper around the C function g_file_mount_enclosing_volume_finish.
func (recv *File) MountEnclosingVolumeFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_mount_enclosing_volume_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_mount_mountable : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// MountMountableFinish is a wrapper around the C function g_file_mount_mountable_finish.
func (recv *File) MountMountableFinish(result *AsyncResult) (*File, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_mount_mountable_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_move : unsupported parameter progress_callback : no type generator for FileProgressCallback (GFileProgressCallback) for param progress_callback

// OpenReadwrite is a wrapper around the C function g_file_open_readwrite.
func (recv *File) OpenReadwrite(cancellable *Cancellable) (*FileIOStream, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_open_readwrite((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := FileIOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_open_readwrite_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// OpenReadwriteFinish is a wrapper around the C function g_file_open_readwrite_finish.
func (recv *File) OpenReadwriteFinish(res *AsyncResult) (*FileIOStream, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_open_readwrite_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileIOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_poll_mountable : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// PollMountableFinish is a wrapper around the C function g_file_poll_mountable_finish.
func (recv *File) PollMountableFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_poll_mountable_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// QueryDefaultHandler is a wrapper around the C function g_file_query_default_handler.
func (recv *File) QueryDefaultHandler(cancellable *Cancellable) (*AppInfo, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_query_default_handler((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := AppInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// QueryExists is a wrapper around the C function g_file_query_exists.
func (recv *File) QueryExists(cancellable *Cancellable) bool {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	retC := C.g_file_query_exists((*C.GFile)(recv.native), c_cancellable)
	retGo := retC == C.TRUE

	return retGo
}

// QueryFileType is a wrapper around the C function g_file_query_file_type.
func (recv *File) QueryFileType(flags FileQueryInfoFlags, cancellable *Cancellable) FileType {
	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	retC := C.g_file_query_file_type((*C.GFile)(recv.native), c_flags, c_cancellable)
	retGo := (FileType)(retC)

	return retGo
}

// QueryFilesystemInfo is a wrapper around the C function g_file_query_filesystem_info.
func (recv *File) QueryFilesystemInfo(attributes string, cancellable *Cancellable) (*FileInfo, error) {
	c_attributes := C.CString(attributes)
	defer C.free(unsafe.Pointer(c_attributes))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_query_filesystem_info((*C.GFile)(recv.native), c_attributes, c_cancellable, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_query_filesystem_info_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// QueryFilesystemInfoFinish is a wrapper around the C function g_file_query_filesystem_info_finish.
func (recv *File) QueryFilesystemInfoFinish(res *AsyncResult) (*FileInfo, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_query_filesystem_info_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// QueryInfo is a wrapper around the C function g_file_query_info.
func (recv *File) QueryInfo(attributes string, flags FileQueryInfoFlags, cancellable *Cancellable) (*FileInfo, error) {
	c_attributes := C.CString(attributes)
	defer C.free(unsafe.Pointer(c_attributes))

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_query_info((*C.GFile)(recv.native), c_attributes, c_flags, c_cancellable, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_query_info_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// QueryInfoFinish is a wrapper around the C function g_file_query_info_finish.
func (recv *File) QueryInfoFinish(res *AsyncResult) (*FileInfo, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_query_info_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// QuerySettableAttributes is a wrapper around the C function g_file_query_settable_attributes.
func (recv *File) QuerySettableAttributes(cancellable *Cancellable) (*FileAttributeInfoList, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_query_settable_attributes((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := FileAttributeInfoListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// QueryWritableNamespaces is a wrapper around the C function g_file_query_writable_namespaces.
func (recv *File) QueryWritableNamespaces(cancellable *Cancellable) (*FileAttributeInfoList, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_query_writable_namespaces((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := FileAttributeInfoListNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Read is a wrapper around the C function g_file_read.
func (recv *File) Read(cancellable *Cancellable) (*FileInputStream, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_read((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := FileInputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_read_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReadFinish is a wrapper around the C function g_file_read_finish.
func (recv *File) ReadFinish(res *AsyncResult) (*FileInputStream, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_read_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileInputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Replace is a wrapper around the C function g_file_replace.
func (recv *File) Replace(etag string, makeBackup bool, flags FileCreateFlags, cancellable *Cancellable) (*FileOutputStream, error) {
	c_etag := C.CString(etag)
	defer C.free(unsafe.Pointer(c_etag))

	c_make_backup :=
		boolToGboolean(makeBackup)

	c_flags := (C.GFileCreateFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_replace((*C.GFile)(recv.native), c_etag, c_make_backup, c_flags, c_cancellable, &cThrowableError)
	retGo := FileOutputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_replace_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReplaceContents is a wrapper around the C function g_file_replace_contents.
func (recv *File) ReplaceContents(contents []uint8, etag string, makeBackup bool, flags FileCreateFlags, cancellable *Cancellable) (bool, string, error) {
	c_contents_array := make([]C.guint8, len(contents)+1, len(contents)+1)
	for i, item := range contents {
		c := (C.guint8)(item)
		c_contents_array[i] = c
	}
	c_contents_array[len(contents)] = 0
	c_contents_arrayPtr := &c_contents_array[0]
	c_contents := (*C.char)(unsafe.Pointer(c_contents_arrayPtr))

	c_length := (C.gsize)(len(contents))

	c_etag := C.CString(etag)
	defer C.free(unsafe.Pointer(c_etag))

	c_make_backup :=
		boolToGboolean(makeBackup)

	c_flags := (C.GFileCreateFlags)(flags)

	var c_new_etag *C.char

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_replace_contents((*C.GFile)(recv.native), c_contents, c_length, c_etag, c_make_backup, c_flags, &c_new_etag, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	newEtag := C.GoString(c_new_etag)
	defer C.free(unsafe.Pointer(c_new_etag))

	return retGo, newEtag, goError
}

// Unsupported : g_file_replace_contents_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReplaceContentsFinish is a wrapper around the C function g_file_replace_contents_finish.
func (recv *File) ReplaceContentsFinish(res *AsyncResult) (bool, string, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var c_new_etag *C.char

	var cThrowableError *C.GError

	retC := C.g_file_replace_contents_finish((*C.GFile)(recv.native), c_res, &c_new_etag, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	newEtag := C.GoString(c_new_etag)
	defer C.free(unsafe.Pointer(c_new_etag))

	return retGo, newEtag, goError
}

// ReplaceFinish is a wrapper around the C function g_file_replace_finish.
func (recv *File) ReplaceFinish(res *AsyncResult) (*FileOutputStream, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_replace_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileOutputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ReplaceReadwrite is a wrapper around the C function g_file_replace_readwrite.
func (recv *File) ReplaceReadwrite(etag string, makeBackup bool, flags FileCreateFlags, cancellable *Cancellable) (*FileIOStream, error) {
	c_etag := C.CString(etag)
	defer C.free(unsafe.Pointer(c_etag))

	c_make_backup :=
		boolToGboolean(makeBackup)

	c_flags := (C.GFileCreateFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_replace_readwrite((*C.GFile)(recv.native), c_etag, c_make_backup, c_flags, c_cancellable, &cThrowableError)
	retGo := FileIOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_replace_readwrite_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ReplaceReadwriteFinish is a wrapper around the C function g_file_replace_readwrite_finish.
func (recv *File) ReplaceReadwriteFinish(res *AsyncResult) (*FileIOStream, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_replace_readwrite_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileIOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ResolveRelativePath is a wrapper around the C function g_file_resolve_relative_path.
func (recv *File) ResolveRelativePath(relativePath string) *File {
	c_relative_path := C.CString(relativePath)
	defer C.free(unsafe.Pointer(c_relative_path))

	retC := C.g_file_resolve_relative_path((*C.GFile)(recv.native), c_relative_path)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetAttribute is a wrapper around the C function g_file_set_attribute.
func (recv *File) SetAttribute(attribute string, type_ FileAttributeType, valueP uintptr, flags FileQueryInfoFlags, cancellable *Cancellable) (bool, error) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_type := (C.GFileAttributeType)(type_)

	c_value_p := (C.gpointer)(valueP)

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_attribute((*C.GFile)(recv.native), c_attribute, c_type, c_value_p, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAttributeByteString is a wrapper around the C function g_file_set_attribute_byte_string.
func (recv *File) SetAttributeByteString(attribute string, value string, flags FileQueryInfoFlags, cancellable *Cancellable) (bool, error) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_attribute_byte_string((*C.GFile)(recv.native), c_attribute, c_value, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAttributeInt32 is a wrapper around the C function g_file_set_attribute_int32.
func (recv *File) SetAttributeInt32(attribute string, value int32, flags FileQueryInfoFlags, cancellable *Cancellable) (bool, error) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_value := (C.gint32)(value)

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_attribute_int32((*C.GFile)(recv.native), c_attribute, c_value, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAttributeInt64 is a wrapper around the C function g_file_set_attribute_int64.
func (recv *File) SetAttributeInt64(attribute string, value int64, flags FileQueryInfoFlags, cancellable *Cancellable) (bool, error) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_value := (C.gint64)(value)

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_attribute_int64((*C.GFile)(recv.native), c_attribute, c_value, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAttributeString is a wrapper around the C function g_file_set_attribute_string.
func (recv *File) SetAttributeString(attribute string, value string, flags FileQueryInfoFlags, cancellable *Cancellable) (bool, error) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_attribute_string((*C.GFile)(recv.native), c_attribute, c_value, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAttributeUint32 is a wrapper around the C function g_file_set_attribute_uint32.
func (recv *File) SetAttributeUint32(attribute string, value uint32, flags FileQueryInfoFlags, cancellable *Cancellable) (bool, error) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_value := (C.guint32)(value)

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_attribute_uint32((*C.GFile)(recv.native), c_attribute, c_value, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAttributeUint64 is a wrapper around the C function g_file_set_attribute_uint64.
func (recv *File) SetAttributeUint64(attribute string, value uint64, flags FileQueryInfoFlags, cancellable *Cancellable) (bool, error) {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_value := (C.guint64)(value)

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_attribute_uint64((*C.GFile)(recv.native), c_attribute, c_value, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_set_attributes_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// SetAttributesFinish is a wrapper around the C function g_file_set_attributes_finish.
func (recv *File) SetAttributesFinish(result *AsyncResult) (bool, *FileInfo, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var c_info *C.GFileInfo

	var cThrowableError *C.GError

	retC := C.g_file_set_attributes_finish((*C.GFile)(recv.native), c_result, &c_info, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	info := FileInfoNewFromC(unsafe.Pointer(c_info))

	return retGo, info, goError
}

// SetAttributesFromInfo is a wrapper around the C function g_file_set_attributes_from_info.
func (recv *File) SetAttributesFromInfo(info *FileInfo, flags FileQueryInfoFlags, cancellable *Cancellable) (bool, error) {
	c_info := (*C.GFileInfo)(C.NULL)
	if info != nil {
		c_info = (*C.GFileInfo)(info.ToC())
	}

	c_flags := (C.GFileQueryInfoFlags)(flags)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_attributes_from_info((*C.GFile)(recv.native), c_info, c_flags, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetDisplayName is a wrapper around the C function g_file_set_display_name.
func (recv *File) SetDisplayName(displayName string, cancellable *Cancellable) (*File, error) {
	c_display_name := C.CString(displayName)
	defer C.free(unsafe.Pointer(c_display_name))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_set_display_name((*C.GFile)(recv.native), c_display_name, c_cancellable, &cThrowableError)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_set_display_name_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// SetDisplayNameFinish is a wrapper around the C function g_file_set_display_name_finish.
func (recv *File) SetDisplayNameFinish(res *AsyncResult) (*File, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_set_display_name_finish((*C.GFile)(recv.native), c_res, &cThrowableError)
	retGo := FileNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_start_mountable : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// StartMountableFinish is a wrapper around the C function g_file_start_mountable_finish.
func (recv *File) StartMountableFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_start_mountable_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_stop_mountable : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// StopMountableFinish is a wrapper around the C function g_file_stop_mountable_finish.
func (recv *File) StopMountableFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_stop_mountable_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SupportsThreadContexts is a wrapper around the C function g_file_supports_thread_contexts.
func (recv *File) SupportsThreadContexts() bool {
	retC := C.g_file_supports_thread_contexts((*C.GFile)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Trash is a wrapper around the C function g_file_trash.
func (recv *File) Trash(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_file_trash((*C.GFile)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_unmount_mountable : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// UnmountMountableFinish is a wrapper around the C function g_file_unmount_mountable_finish.
func (recv *File) UnmountMountableFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_unmount_mountable_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_file_unmount_mountable_with_operation : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// UnmountMountableWithOperationFinish is a wrapper around the C function g_file_unmount_mountable_with_operation_finish.
func (recv *File) UnmountMountableWithOperationFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_file_unmount_mountable_with_operation_finish((*C.GFile)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// FileDescriptorBased is a wrapper around the C record GFileDescriptorBased.
type FileDescriptorBased struct {
	native *C.GFileDescriptorBased
}

func FileDescriptorBasedNewFromC(u unsafe.Pointer) *FileDescriptorBased {
	c := (*C.GFileDescriptorBased)(u)
	if c == nil {
		return nil
	}

	g := &FileDescriptorBased{native: c}

	return g
}

func (recv *FileDescriptorBased) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileDescriptorBased with another FileDescriptorBased, and returns true if they represent the same GObject.
func (recv *FileDescriptorBased) Equals(other *FileDescriptorBased) bool {
	return other.ToC() == recv.ToC()
}

// GetFd is a wrapper around the C function g_file_descriptor_based_get_fd.
func (recv *FileDescriptorBased) GetFd() int32 {
	retC := C.g_file_descriptor_based_get_fd((*C.GFileDescriptorBased)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Icon is a wrapper around the C record GIcon.
type Icon struct {
	native *C.GIcon
}

func IconNewFromC(u unsafe.Pointer) *Icon {
	c := (*C.GIcon)(u)
	if c == nil {
		return nil
	}

	g := &Icon{native: c}

	return g
}

func (recv *Icon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Icon with another Icon, and returns true if they represent the same GObject.
func (recv *Icon) Equals(other *Icon) bool {
	return other.ToC() == recv.ToC()
}

// IconHash is a wrapper around the C function g_icon_hash.
func IconHash(icon uintptr) uint32 {
	c_icon := (C.gconstpointer)(icon)

	retC := C.g_icon_hash(c_icon)
	retGo := (uint32)(retC)

	return retGo
}

// IconNewForString is a wrapper around the C function g_icon_new_for_string.
func IconNewForString(str string) (*Icon, error) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	var cThrowableError *C.GError

	retC := C.g_icon_new_for_string(c_str, &cThrowableError)
	retGo := IconNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Equal is a wrapper around the C function g_icon_equal.
func (recv *Icon) Equal(icon2 *Icon) bool {
	c_icon2 := (*C.GIcon)(icon2.ToC())

	retC := C.g_icon_equal((*C.GIcon)(recv.native), c_icon2)
	retGo := retC == C.TRUE

	return retGo
}

// ToString is a wrapper around the C function g_icon_to_string.
func (recv *Icon) ToString() string {
	retC := C.g_icon_to_string((*C.GIcon)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Initable is a wrapper around the C record GInitable.
type Initable struct {
	native *C.GInitable
}

func InitableNewFromC(u unsafe.Pointer) *Initable {
	c := (*C.GInitable)(u)
	if c == nil {
		return nil
	}

	g := &Initable{native: c}

	return g
}

func (recv *Initable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Initable with another Initable, and returns true if they represent the same GObject.
func (recv *Initable) Equals(other *Initable) bool {
	return other.ToC() == recv.ToC()
}

// InitableNew is a wrapper around the C function g_initable_new.
func InitableNew(objectType gobject.Type, cancellable *Cancellable, error_ *glib.Error) gobject.Object {
	c_object_type := (C.GType)(objectType)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	c_error := (**C.GError)(C.NULL)
	if error_ != nil {
		c_error = (**C.GError)(error_.ToC())
	}

	retC := C._g_initable_new(c_object_type, c_cancellable, c_error)
	retGo := *gobject.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// g_initable_new_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args
// g_initable_newv : unsupported parameter parameters :
// Init is a wrapper around the C function g_initable_init.
func (recv *Initable) Init(cancellable *Cancellable) (bool, error) {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_initable_init((*C.GInitable)(recv.native), c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ListModel is a wrapper around the C record GListModel.
type ListModel struct {
	native *C.GListModel
}

func ListModelNewFromC(u unsafe.Pointer) *ListModel {
	c := (*C.GListModel)(u)
	if c == nil {
		return nil
	}

	g := &ListModel{native: c}

	return g
}

func (recv *ListModel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListModel with another ListModel, and returns true if they represent the same GObject.
func (recv *ListModel) Equals(other *ListModel) bool {
	return other.ToC() == recv.ToC()
}

// LoadableIcon is a wrapper around the C record GLoadableIcon.
type LoadableIcon struct {
	native *C.GLoadableIcon
}

func LoadableIconNewFromC(u unsafe.Pointer) *LoadableIcon {
	c := (*C.GLoadableIcon)(u)
	if c == nil {
		return nil
	}

	g := &LoadableIcon{native: c}

	return g
}

func (recv *LoadableIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LoadableIcon with another LoadableIcon, and returns true if they represent the same GObject.
func (recv *LoadableIcon) Equals(other *LoadableIcon) bool {
	return other.ToC() == recv.ToC()
}

// Load is a wrapper around the C function g_loadable_icon_load.
func (recv *LoadableIcon) Load(size int32, cancellable *Cancellable) (*InputStream, string, error) {
	c_size := (C.int)(size)

	var c_type *C.char

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_loadable_icon_load((*C.GLoadableIcon)(recv.native), c_size, &c_type, c_cancellable, &cThrowableError)
	retGo := InputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	type_ := C.GoString(c_type)
	defer C.free(unsafe.Pointer(c_type))

	return retGo, type_, goError
}

// Unsupported : g_loadable_icon_load_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LoadFinish is a wrapper around the C function g_loadable_icon_load_finish.
func (recv *LoadableIcon) LoadFinish(res *AsyncResult) (*InputStream, string, error) {
	c_res := (*C.GAsyncResult)(res.ToC())

	var c_type *C.char

	var cThrowableError *C.GError

	retC := C.g_loadable_icon_load_finish((*C.GLoadableIcon)(recv.native), c_res, &c_type, &cThrowableError)
	retGo := InputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	type_ := C.GoString(c_type)
	defer C.free(unsafe.Pointer(c_type))

	return retGo, type_, goError
}

// Mount is a wrapper around the C record GMount.
type Mount struct {
	native *C.GMount
}

func MountNewFromC(u unsafe.Pointer) *Mount {
	c := (*C.GMount)(u)
	if c == nil {
		return nil
	}

	g := &Mount{native: c}

	return g
}

func (recv *Mount) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Mount with another Mount, and returns true if they represent the same GObject.
func (recv *Mount) Equals(other *Mount) bool {
	return other.ToC() == recv.ToC()
}

type signalMountChangedDetail struct {
	callback  MountSignalChangedCallback
	handlerID C.gulong
}

var signalMountChangedId int
var signalMountChangedMap = make(map[int]signalMountChangedDetail)
var signalMountChangedLock sync.RWMutex

// MountSignalChangedCallback is a callback function for a 'changed' signal emitted from a Mount.
type MountSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the Mount.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Mount) ConnectChanged(callback MountSignalChangedCallback) int {
	signalMountChangedLock.Lock()
	defer signalMountChangedLock.Unlock()

	signalMountChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Mount_signal_connect_changed(instance, C.gpointer(uintptr(signalMountChangedId)))

	detail := signalMountChangedDetail{callback, handlerID}
	signalMountChangedMap[signalMountChangedId] = detail

	return signalMountChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Mount.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Mount) DisconnectChanged(connectionID int) {
	signalMountChangedLock.Lock()
	defer signalMountChangedLock.Unlock()

	detail, exists := signalMountChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMountChangedMap, connectionID)
}

//export mount_changedHandler
func mount_changedHandler(_ *C.GObject, data C.gpointer) {
	signalMountChangedLock.RLock()
	defer signalMountChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMountChangedMap[index].callback
	callback()
}

type signalMountPreUnmountDetail struct {
	callback  MountSignalPreUnmountCallback
	handlerID C.gulong
}

var signalMountPreUnmountId int
var signalMountPreUnmountMap = make(map[int]signalMountPreUnmountDetail)
var signalMountPreUnmountLock sync.RWMutex

// MountSignalPreUnmountCallback is a callback function for a 'pre-unmount' signal emitted from a Mount.
type MountSignalPreUnmountCallback func()

/*
ConnectPreUnmount connects the callback to the 'pre-unmount' signal for the Mount.

The returned value represents the connection, and may be passed to DisconnectPreUnmount to remove it.
*/
func (recv *Mount) ConnectPreUnmount(callback MountSignalPreUnmountCallback) int {
	signalMountPreUnmountLock.Lock()
	defer signalMountPreUnmountLock.Unlock()

	signalMountPreUnmountId++
	instance := C.gpointer(recv.native)
	handlerID := C.Mount_signal_connect_pre_unmount(instance, C.gpointer(uintptr(signalMountPreUnmountId)))

	detail := signalMountPreUnmountDetail{callback, handlerID}
	signalMountPreUnmountMap[signalMountPreUnmountId] = detail

	return signalMountPreUnmountId
}

/*
DisconnectPreUnmount disconnects a callback from the 'pre-unmount' signal for the Mount.

The connectionID should be a value returned from a call to ConnectPreUnmount.
*/
func (recv *Mount) DisconnectPreUnmount(connectionID int) {
	signalMountPreUnmountLock.Lock()
	defer signalMountPreUnmountLock.Unlock()

	detail, exists := signalMountPreUnmountMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMountPreUnmountMap, connectionID)
}

//export mount_preUnmountHandler
func mount_preUnmountHandler(_ *C.GObject, data C.gpointer) {
	signalMountPreUnmountLock.RLock()
	defer signalMountPreUnmountLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMountPreUnmountMap[index].callback
	callback()
}

type signalMountUnmountedDetail struct {
	callback  MountSignalUnmountedCallback
	handlerID C.gulong
}

var signalMountUnmountedId int
var signalMountUnmountedMap = make(map[int]signalMountUnmountedDetail)
var signalMountUnmountedLock sync.RWMutex

// MountSignalUnmountedCallback is a callback function for a 'unmounted' signal emitted from a Mount.
type MountSignalUnmountedCallback func()

/*
ConnectUnmounted connects the callback to the 'unmounted' signal for the Mount.

The returned value represents the connection, and may be passed to DisconnectUnmounted to remove it.
*/
func (recv *Mount) ConnectUnmounted(callback MountSignalUnmountedCallback) int {
	signalMountUnmountedLock.Lock()
	defer signalMountUnmountedLock.Unlock()

	signalMountUnmountedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Mount_signal_connect_unmounted(instance, C.gpointer(uintptr(signalMountUnmountedId)))

	detail := signalMountUnmountedDetail{callback, handlerID}
	signalMountUnmountedMap[signalMountUnmountedId] = detail

	return signalMountUnmountedId
}

/*
DisconnectUnmounted disconnects a callback from the 'unmounted' signal for the Mount.

The connectionID should be a value returned from a call to ConnectUnmounted.
*/
func (recv *Mount) DisconnectUnmounted(connectionID int) {
	signalMountUnmountedLock.Lock()
	defer signalMountUnmountedLock.Unlock()

	detail, exists := signalMountUnmountedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMountUnmountedMap, connectionID)
}

//export mount_unmountedHandler
func mount_unmountedHandler(_ *C.GObject, data C.gpointer) {
	signalMountUnmountedLock.RLock()
	defer signalMountUnmountedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMountUnmountedMap[index].callback
	callback()
}

// CanEject is a wrapper around the C function g_mount_can_eject.
func (recv *Mount) CanEject() bool {
	retC := C.g_mount_can_eject((*C.GMount)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CanUnmount is a wrapper around the C function g_mount_can_unmount.
func (recv *Mount) CanUnmount() bool {
	retC := C.g_mount_can_unmount((*C.GMount)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_mount_eject : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EjectFinish is a wrapper around the C function g_mount_eject_finish.
func (recv *Mount) EjectFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_mount_eject_finish((*C.GMount)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_mount_eject_with_operation : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EjectWithOperationFinish is a wrapper around the C function g_mount_eject_with_operation_finish.
func (recv *Mount) EjectWithOperationFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_mount_eject_with_operation_finish((*C.GMount)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetDefaultLocation is a wrapper around the C function g_mount_get_default_location.
func (recv *Mount) GetDefaultLocation() *File {
	retC := C.g_mount_get_default_location((*C.GMount)(recv.native))
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDrive is a wrapper around the C function g_mount_get_drive.
func (recv *Mount) GetDrive() *Drive {
	retC := C.g_mount_get_drive((*C.GMount)(recv.native))
	retGo := DriveNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIcon is a wrapper around the C function g_mount_get_icon.
func (recv *Mount) GetIcon() *Icon {
	retC := C.g_mount_get_icon((*C.GMount)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetName is a wrapper around the C function g_mount_get_name.
func (recv *Mount) GetName() string {
	retC := C.g_mount_get_name((*C.GMount)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetRoot is a wrapper around the C function g_mount_get_root.
func (recv *Mount) GetRoot() *File {
	retC := C.g_mount_get_root((*C.GMount)(recv.native))
	retGo := FileNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSortKey is a wrapper around the C function g_mount_get_sort_key.
func (recv *Mount) GetSortKey() string {
	retC := C.g_mount_get_sort_key((*C.GMount)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetSymbolicIcon is a wrapper around the C function g_mount_get_symbolic_icon.
func (recv *Mount) GetSymbolicIcon() *Icon {
	retC := C.g_mount_get_symbolic_icon((*C.GMount)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetUuid is a wrapper around the C function g_mount_get_uuid.
func (recv *Mount) GetUuid() string {
	retC := C.g_mount_get_uuid((*C.GMount)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetVolume is a wrapper around the C function g_mount_get_volume.
func (recv *Mount) GetVolume() *Volume {
	retC := C.g_mount_get_volume((*C.GMount)(recv.native))
	retGo := VolumeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : g_mount_guess_content_type : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// GuessContentTypeFinish is a wrapper around the C function g_mount_guess_content_type_finish.
func (recv *Mount) GuessContentTypeFinish(result *AsyncResult) ([]string, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_mount_guess_content_type_finish((*C.GMount)(recv.native), c_result, &cThrowableError)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GuessContentTypeSync is a wrapper around the C function g_mount_guess_content_type_sync.
func (recv *Mount) GuessContentTypeSync(forceRescan bool, cancellable *Cancellable) ([]string, error) {
	c_force_rescan :=
		boolToGboolean(forceRescan)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_mount_guess_content_type_sync((*C.GMount)(recv.native), c_force_rescan, c_cancellable, &cThrowableError)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// IsShadowed is a wrapper around the C function g_mount_is_shadowed.
func (recv *Mount) IsShadowed() bool {
	retC := C.g_mount_is_shadowed((*C.GMount)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_mount_remount : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// RemountFinish is a wrapper around the C function g_mount_remount_finish.
func (recv *Mount) RemountFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_mount_remount_finish((*C.GMount)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Shadow is a wrapper around the C function g_mount_shadow.
func (recv *Mount) Shadow() {
	C.g_mount_shadow((*C.GMount)(recv.native))

	return
}

// Unsupported : g_mount_unmount : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// UnmountFinish is a wrapper around the C function g_mount_unmount_finish.
func (recv *Mount) UnmountFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_mount_unmount_finish((*C.GMount)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_mount_unmount_with_operation : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// UnmountWithOperationFinish is a wrapper around the C function g_mount_unmount_with_operation_finish.
func (recv *Mount) UnmountWithOperationFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_mount_unmount_with_operation_finish((*C.GMount)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unshadow is a wrapper around the C function g_mount_unshadow.
func (recv *Mount) Unshadow() {
	C.g_mount_unshadow((*C.GMount)(recv.native))

	return
}

// NetworkMonitor is a wrapper around the C record GNetworkMonitor.
type NetworkMonitor struct {
	native *C.GNetworkMonitor
}

func NetworkMonitorNewFromC(u unsafe.Pointer) *NetworkMonitor {
	c := (*C.GNetworkMonitor)(u)
	if c == nil {
		return nil
	}

	g := &NetworkMonitor{native: c}

	return g
}

func (recv *NetworkMonitor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NetworkMonitor with another NetworkMonitor, and returns true if they represent the same GObject.
func (recv *NetworkMonitor) Equals(other *NetworkMonitor) bool {
	return other.ToC() == recv.ToC()
}

type signalNetworkMonitorNetworkChangedDetail struct {
	callback  NetworkMonitorSignalNetworkChangedCallback
	handlerID C.gulong
}

var signalNetworkMonitorNetworkChangedId int
var signalNetworkMonitorNetworkChangedMap = make(map[int]signalNetworkMonitorNetworkChangedDetail)
var signalNetworkMonitorNetworkChangedLock sync.RWMutex

// NetworkMonitorSignalNetworkChangedCallback is a callback function for a 'network-changed' signal emitted from a NetworkMonitor.
type NetworkMonitorSignalNetworkChangedCallback func(networkAvailable bool)

/*
ConnectNetworkChanged connects the callback to the 'network-changed' signal for the NetworkMonitor.

The returned value represents the connection, and may be passed to DisconnectNetworkChanged to remove it.
*/
func (recv *NetworkMonitor) ConnectNetworkChanged(callback NetworkMonitorSignalNetworkChangedCallback) int {
	signalNetworkMonitorNetworkChangedLock.Lock()
	defer signalNetworkMonitorNetworkChangedLock.Unlock()

	signalNetworkMonitorNetworkChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.NetworkMonitor_signal_connect_network_changed(instance, C.gpointer(uintptr(signalNetworkMonitorNetworkChangedId)))

	detail := signalNetworkMonitorNetworkChangedDetail{callback, handlerID}
	signalNetworkMonitorNetworkChangedMap[signalNetworkMonitorNetworkChangedId] = detail

	return signalNetworkMonitorNetworkChangedId
}

/*
DisconnectNetworkChanged disconnects a callback from the 'network-changed' signal for the NetworkMonitor.

The connectionID should be a value returned from a call to ConnectNetworkChanged.
*/
func (recv *NetworkMonitor) DisconnectNetworkChanged(connectionID int) {
	signalNetworkMonitorNetworkChangedLock.Lock()
	defer signalNetworkMonitorNetworkChangedLock.Unlock()

	detail, exists := signalNetworkMonitorNetworkChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNetworkMonitorNetworkChangedMap, connectionID)
}

//export networkmonitor_networkChangedHandler
func networkmonitor_networkChangedHandler(_ *C.GObject, c_network_available C.gboolean, data C.gpointer) {
	signalNetworkMonitorNetworkChangedLock.RLock()
	defer signalNetworkMonitorNetworkChangedLock.RUnlock()

	networkAvailable := c_network_available == C.TRUE

	index := int(uintptr(data))
	callback := signalNetworkMonitorNetworkChangedMap[index].callback
	callback(networkAvailable)
}

// NetworkMonitorGetDefault is a wrapper around the C function g_network_monitor_get_default.
func NetworkMonitorGetDefault() *NetworkMonitor {
	retC := C.g_network_monitor_get_default()
	retGo := NetworkMonitorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CanReach is a wrapper around the C function g_network_monitor_can_reach.
func (recv *NetworkMonitor) CanReach(connectable *SocketConnectable, cancellable *Cancellable) (bool, error) {
	c_connectable := (*C.GSocketConnectable)(connectable.ToC())

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_network_monitor_can_reach((*C.GNetworkMonitor)(recv.native), c_connectable, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_network_monitor_can_reach_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// CanReachFinish is a wrapper around the C function g_network_monitor_can_reach_finish.
func (recv *NetworkMonitor) CanReachFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_network_monitor_can_reach_finish((*C.GNetworkMonitor)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetNetworkAvailable is a wrapper around the C function g_network_monitor_get_network_available.
func (recv *NetworkMonitor) GetNetworkAvailable() bool {
	retC := C.g_network_monitor_get_network_available((*C.GNetworkMonitor)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// PollableInputStream is a wrapper around the C record GPollableInputStream.
type PollableInputStream struct {
	native *C.GPollableInputStream
}

func PollableInputStreamNewFromC(u unsafe.Pointer) *PollableInputStream {
	c := (*C.GPollableInputStream)(u)
	if c == nil {
		return nil
	}

	g := &PollableInputStream{native: c}

	return g
}

func (recv *PollableInputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PollableInputStream with another PollableInputStream, and returns true if they represent the same GObject.
func (recv *PollableInputStream) Equals(other *PollableInputStream) bool {
	return other.ToC() == recv.ToC()
}

// CanPoll is a wrapper around the C function g_pollable_input_stream_can_poll.
func (recv *PollableInputStream) CanPoll() bool {
	retC := C.g_pollable_input_stream_can_poll((*C.GPollableInputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CreateSource is a wrapper around the C function g_pollable_input_stream_create_source.
func (recv *PollableInputStream) CreateSource(cancellable *Cancellable) *glib.Source {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	retC := C.g_pollable_input_stream_create_source((*C.GPollableInputStream)(recv.native), c_cancellable)
	retGo := glib.SourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IsReadable is a wrapper around the C function g_pollable_input_stream_is_readable.
func (recv *PollableInputStream) IsReadable() bool {
	retC := C.g_pollable_input_stream_is_readable((*C.GPollableInputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ReadNonblocking is a wrapper around the C function g_pollable_input_stream_read_nonblocking.
func (recv *PollableInputStream) ReadNonblocking(buffer []uint8, cancellable *Cancellable) (int64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_pollable_input_stream_read_nonblocking((*C.GPollableInputStream)(recv.native), c_buffer, c_count, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PollableOutputStream is a wrapper around the C record GPollableOutputStream.
type PollableOutputStream struct {
	native *C.GPollableOutputStream
}

func PollableOutputStreamNewFromC(u unsafe.Pointer) *PollableOutputStream {
	c := (*C.GPollableOutputStream)(u)
	if c == nil {
		return nil
	}

	g := &PollableOutputStream{native: c}

	return g
}

func (recv *PollableOutputStream) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PollableOutputStream with another PollableOutputStream, and returns true if they represent the same GObject.
func (recv *PollableOutputStream) Equals(other *PollableOutputStream) bool {
	return other.ToC() == recv.ToC()
}

// CanPoll is a wrapper around the C function g_pollable_output_stream_can_poll.
func (recv *PollableOutputStream) CanPoll() bool {
	retC := C.g_pollable_output_stream_can_poll((*C.GPollableOutputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CreateSource is a wrapper around the C function g_pollable_output_stream_create_source.
func (recv *PollableOutputStream) CreateSource(cancellable *Cancellable) *glib.Source {
	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	retC := C.g_pollable_output_stream_create_source((*C.GPollableOutputStream)(recv.native), c_cancellable)
	retGo := glib.SourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IsWritable is a wrapper around the C function g_pollable_output_stream_is_writable.
func (recv *PollableOutputStream) IsWritable() bool {
	retC := C.g_pollable_output_stream_is_writable((*C.GPollableOutputStream)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// WriteNonblocking is a wrapper around the C function g_pollable_output_stream_write_nonblocking.
func (recv *PollableOutputStream) WriteNonblocking(buffer []uint8, cancellable *Cancellable) (int64, error) {
	c_buffer_array := make([]C.guint8, len(buffer)+1, len(buffer)+1)
	for i, item := range buffer {
		c := (C.guint8)(item)
		c_buffer_array[i] = c
	}
	c_buffer_array[len(buffer)] = 0
	c_buffer_arrayPtr := &c_buffer_array[0]
	c_buffer := (unsafe.Pointer(c_buffer_arrayPtr))

	c_count := (C.gsize)(len(buffer))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_pollable_output_stream_write_nonblocking((*C.GPollableOutputStream)(recv.native), c_buffer, c_count, c_cancellable, &cThrowableError)
	retGo := (int64)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Proxy is a wrapper around the C record GProxy.
type Proxy struct {
	native *C.GProxy
}

func ProxyNewFromC(u unsafe.Pointer) *Proxy {
	c := (*C.GProxy)(u)
	if c == nil {
		return nil
	}

	g := &Proxy{native: c}

	return g
}

func (recv *Proxy) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Proxy with another Proxy, and returns true if they represent the same GObject.
func (recv *Proxy) Equals(other *Proxy) bool {
	return other.ToC() == recv.ToC()
}

// ProxyGetDefaultForProtocol is a wrapper around the C function g_proxy_get_default_for_protocol.
func ProxyGetDefaultForProtocol(protocol string) *Proxy {
	c_protocol := C.CString(protocol)
	defer C.free(unsafe.Pointer(c_protocol))

	retC := C.g_proxy_get_default_for_protocol(c_protocol)
	retGo := ProxyNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Connect is a wrapper around the C function g_proxy_connect.
func (recv *Proxy) Connect(connection *IOStream, proxyAddress *ProxyAddress, cancellable *Cancellable) (*IOStream, error) {
	c_connection := (*C.GIOStream)(C.NULL)
	if connection != nil {
		c_connection = (*C.GIOStream)(connection.ToC())
	}

	c_proxy_address := (*C.GProxyAddress)(C.NULL)
	if proxyAddress != nil {
		c_proxy_address = (*C.GProxyAddress)(proxyAddress.ToC())
	}

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_proxy_connect((*C.GProxy)(recv.native), c_connection, c_proxy_address, c_cancellable, &cThrowableError)
	retGo := IOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_proxy_connect_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// ConnectFinish is a wrapper around the C function g_proxy_connect_finish.
func (recv *Proxy) ConnectFinish(result *AsyncResult) (*IOStream, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_proxy_connect_finish((*C.GProxy)(recv.native), c_result, &cThrowableError)
	retGo := IOStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SupportsHostname is a wrapper around the C function g_proxy_supports_hostname.
func (recv *Proxy) SupportsHostname() bool {
	retC := C.g_proxy_supports_hostname((*C.GProxy)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ProxyResolver is a wrapper around the C record GProxyResolver.
type ProxyResolver struct {
	native *C.GProxyResolver
}

func ProxyResolverNewFromC(u unsafe.Pointer) *ProxyResolver {
	c := (*C.GProxyResolver)(u)
	if c == nil {
		return nil
	}

	g := &ProxyResolver{native: c}

	return g
}

func (recv *ProxyResolver) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyResolver with another ProxyResolver, and returns true if they represent the same GObject.
func (recv *ProxyResolver) Equals(other *ProxyResolver) bool {
	return other.ToC() == recv.ToC()
}

// ProxyResolverGetDefault is a wrapper around the C function g_proxy_resolver_get_default.
func ProxyResolverGetDefault() *ProxyResolver {
	retC := C.g_proxy_resolver_get_default()
	retGo := ProxyResolverNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IsSupported is a wrapper around the C function g_proxy_resolver_is_supported.
func (recv *ProxyResolver) IsSupported() bool {
	retC := C.g_proxy_resolver_is_supported((*C.GProxyResolver)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Lookup is a wrapper around the C function g_proxy_resolver_lookup.
func (recv *ProxyResolver) Lookup(uri string, cancellable *Cancellable) ([]string, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_proxy_resolver_lookup((*C.GProxyResolver)(recv.native), c_uri, c_cancellable, &cThrowableError)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_proxy_resolver_lookup_async : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// LookupFinish is a wrapper around the C function g_proxy_resolver_lookup_finish.
func (recv *ProxyResolver) LookupFinish(result *AsyncResult) ([]string, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_proxy_resolver_lookup_finish((*C.GProxyResolver)(recv.native), c_result, &cThrowableError)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// RemoteActionGroup is a wrapper around the C record GRemoteActionGroup.
type RemoteActionGroup struct {
	native *C.GRemoteActionGroup
}

func RemoteActionGroupNewFromC(u unsafe.Pointer) *RemoteActionGroup {
	c := (*C.GRemoteActionGroup)(u)
	if c == nil {
		return nil
	}

	g := &RemoteActionGroup{native: c}

	return g
}

func (recv *RemoteActionGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RemoteActionGroup with another RemoteActionGroup, and returns true if they represent the same GObject.
func (recv *RemoteActionGroup) Equals(other *RemoteActionGroup) bool {
	return other.ToC() == recv.ToC()
}

// ActivateActionFull is a wrapper around the C function g_remote_action_group_activate_action_full.
func (recv *RemoteActionGroup) ActivateActionFull(actionName string, parameter *glib.Variant, platformData *glib.Variant) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	c_parameter := (*C.GVariant)(C.NULL)
	if parameter != nil {
		c_parameter = (*C.GVariant)(parameter.ToC())
	}

	c_platform_data := (*C.GVariant)(C.NULL)
	if platformData != nil {
		c_platform_data = (*C.GVariant)(platformData.ToC())
	}

	C.g_remote_action_group_activate_action_full((*C.GRemoteActionGroup)(recv.native), c_action_name, c_parameter, c_platform_data)

	return
}

// ChangeActionStateFull is a wrapper around the C function g_remote_action_group_change_action_state_full.
func (recv *RemoteActionGroup) ChangeActionStateFull(actionName string, value *glib.Variant, platformData *glib.Variant) {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	c_value := (*C.GVariant)(C.NULL)
	if value != nil {
		c_value = (*C.GVariant)(value.ToC())
	}

	c_platform_data := (*C.GVariant)(C.NULL)
	if platformData != nil {
		c_platform_data = (*C.GVariant)(platformData.ToC())
	}

	C.g_remote_action_group_change_action_state_full((*C.GRemoteActionGroup)(recv.native), c_action_name, c_value, c_platform_data)

	return
}

// Seekable is a wrapper around the C record GSeekable.
type Seekable struct {
	native *C.GSeekable
}

func SeekableNewFromC(u unsafe.Pointer) *Seekable {
	c := (*C.GSeekable)(u)
	if c == nil {
		return nil
	}

	g := &Seekable{native: c}

	return g
}

func (recv *Seekable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Seekable with another Seekable, and returns true if they represent the same GObject.
func (recv *Seekable) Equals(other *Seekable) bool {
	return other.ToC() == recv.ToC()
}

// CanSeek is a wrapper around the C function g_seekable_can_seek.
func (recv *Seekable) CanSeek() bool {
	retC := C.g_seekable_can_seek((*C.GSeekable)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CanTruncate is a wrapper around the C function g_seekable_can_truncate.
func (recv *Seekable) CanTruncate() bool {
	retC := C.g_seekable_can_truncate((*C.GSeekable)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Seek is a wrapper around the C function g_seekable_seek.
func (recv *Seekable) Seek(offset int64, type_ glib.SeekType, cancellable *Cancellable) (bool, error) {
	c_offset := (C.goffset)(offset)

	c_type := (C.GSeekType)(type_)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_seekable_seek((*C.GSeekable)(recv.native), c_offset, c_type, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Tell is a wrapper around the C function g_seekable_tell.
func (recv *Seekable) Tell() int64 {
	retC := C.g_seekable_tell((*C.GSeekable)(recv.native))
	retGo := (int64)(retC)

	return retGo
}

// Truncate is a wrapper around the C function g_seekable_truncate.
func (recv *Seekable) Truncate(offset int64, cancellable *Cancellable) (bool, error) {
	c_offset := (C.goffset)(offset)

	c_cancellable := (*C.GCancellable)(C.NULL)
	if cancellable != nil {
		c_cancellable = (*C.GCancellable)(cancellable.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_seekable_truncate((*C.GSeekable)(recv.native), c_offset, c_cancellable, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SocketConnectable is a wrapper around the C record GSocketConnectable.
type SocketConnectable struct {
	native *C.GSocketConnectable
}

func SocketConnectableNewFromC(u unsafe.Pointer) *SocketConnectable {
	c := (*C.GSocketConnectable)(u)
	if c == nil {
		return nil
	}

	g := &SocketConnectable{native: c}

	return g
}

func (recv *SocketConnectable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketConnectable with another SocketConnectable, and returns true if they represent the same GObject.
func (recv *SocketConnectable) Equals(other *SocketConnectable) bool {
	return other.ToC() == recv.ToC()
}

// Enumerate is a wrapper around the C function g_socket_connectable_enumerate.
func (recv *SocketConnectable) Enumerate() *SocketAddressEnumerator {
	retC := C.g_socket_connectable_enumerate((*C.GSocketConnectable)(recv.native))
	retGo := SocketAddressEnumeratorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ProxyEnumerate is a wrapper around the C function g_socket_connectable_proxy_enumerate.
func (recv *SocketConnectable) ProxyEnumerate() *SocketAddressEnumerator {
	retC := C.g_socket_connectable_proxy_enumerate((*C.GSocketConnectable)(recv.native))
	retGo := SocketAddressEnumeratorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TlsBackend is a wrapper around the C record GTlsBackend.
type TlsBackend struct {
	native *C.GTlsBackend
}

func TlsBackendNewFromC(u unsafe.Pointer) *TlsBackend {
	c := (*C.GTlsBackend)(u)
	if c == nil {
		return nil
	}

	g := &TlsBackend{native: c}

	return g
}

func (recv *TlsBackend) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsBackend with another TlsBackend, and returns true if they represent the same GObject.
func (recv *TlsBackend) Equals(other *TlsBackend) bool {
	return other.ToC() == recv.ToC()
}

// TlsBackendGetDefault is a wrapper around the C function g_tls_backend_get_default.
func TlsBackendGetDefault() *TlsBackend {
	retC := C.g_tls_backend_get_default()
	retGo := TlsBackendNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCertificateType is a wrapper around the C function g_tls_backend_get_certificate_type.
func (recv *TlsBackend) GetCertificateType() gobject.Type {
	retC := C.g_tls_backend_get_certificate_type((*C.GTlsBackend)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// GetClientConnectionType is a wrapper around the C function g_tls_backend_get_client_connection_type.
func (recv *TlsBackend) GetClientConnectionType() gobject.Type {
	retC := C.g_tls_backend_get_client_connection_type((*C.GTlsBackend)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// GetDefaultDatabase is a wrapper around the C function g_tls_backend_get_default_database.
func (recv *TlsBackend) GetDefaultDatabase() *TlsDatabase {
	retC := C.g_tls_backend_get_default_database((*C.GTlsBackend)(recv.native))
	retGo := TlsDatabaseNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFileDatabaseType is a wrapper around the C function g_tls_backend_get_file_database_type.
func (recv *TlsBackend) GetFileDatabaseType() gobject.Type {
	retC := C.g_tls_backend_get_file_database_type((*C.GTlsBackend)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// GetServerConnectionType is a wrapper around the C function g_tls_backend_get_server_connection_type.
func (recv *TlsBackend) GetServerConnectionType() gobject.Type {
	retC := C.g_tls_backend_get_server_connection_type((*C.GTlsBackend)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// SupportsTls is a wrapper around the C function g_tls_backend_supports_tls.
func (recv *TlsBackend) SupportsTls() bool {
	retC := C.g_tls_backend_supports_tls((*C.GTlsBackend)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// TlsClientConnection is a wrapper around the C record GTlsClientConnection.
type TlsClientConnection struct {
	native *C.GTlsClientConnection
}

func TlsClientConnectionNewFromC(u unsafe.Pointer) *TlsClientConnection {
	c := (*C.GTlsClientConnection)(u)
	if c == nil {
		return nil
	}

	g := &TlsClientConnection{native: c}

	return g
}

func (recv *TlsClientConnection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsClientConnection with another TlsClientConnection, and returns true if they represent the same GObject.
func (recv *TlsClientConnection) Equals(other *TlsClientConnection) bool {
	return other.ToC() == recv.ToC()
}

// TlsClientConnectionNew is a wrapper around the C function g_tls_client_connection_new.
func TlsClientConnectionNew(baseIoStream *IOStream, serverIdentity *SocketConnectable) (*TlsClientConnection, error) {
	c_base_io_stream := (*C.GIOStream)(C.NULL)
	if baseIoStream != nil {
		c_base_io_stream = (*C.GIOStream)(baseIoStream.ToC())
	}

	c_server_identity := (*C.GSocketConnectable)(serverIdentity.ToC())

	var cThrowableError *C.GError

	retC := C.g_tls_client_connection_new(c_base_io_stream, c_server_identity, &cThrowableError)
	retGo := TlsClientConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetAcceptedCas is a wrapper around the C function g_tls_client_connection_get_accepted_cas.
func (recv *TlsClientConnection) GetAcceptedCas() *glib.List {
	retC := C.g_tls_client_connection_get_accepted_cas((*C.GTlsClientConnection)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetServerIdentity is a wrapper around the C function g_tls_client_connection_get_server_identity.
func (recv *TlsClientConnection) GetServerIdentity() *SocketConnectable {
	retC := C.g_tls_client_connection_get_server_identity((*C.GTlsClientConnection)(recv.native))
	retGo := SocketConnectableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetUseSsl3 is a wrapper around the C function g_tls_client_connection_get_use_ssl3.
func (recv *TlsClientConnection) GetUseSsl3() bool {
	retC := C.g_tls_client_connection_get_use_ssl3((*C.GTlsClientConnection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetValidationFlags is a wrapper around the C function g_tls_client_connection_get_validation_flags.
func (recv *TlsClientConnection) GetValidationFlags() TlsCertificateFlags {
	retC := C.g_tls_client_connection_get_validation_flags((*C.GTlsClientConnection)(recv.native))
	retGo := (TlsCertificateFlags)(retC)

	return retGo
}

// SetServerIdentity is a wrapper around the C function g_tls_client_connection_set_server_identity.
func (recv *TlsClientConnection) SetServerIdentity(identity *SocketConnectable) {
	c_identity := (*C.GSocketConnectable)(identity.ToC())

	C.g_tls_client_connection_set_server_identity((*C.GTlsClientConnection)(recv.native), c_identity)

	return
}

// SetUseSsl3 is a wrapper around the C function g_tls_client_connection_set_use_ssl3.
func (recv *TlsClientConnection) SetUseSsl3(useSsl3 bool) {
	c_use_ssl3 :=
		boolToGboolean(useSsl3)

	C.g_tls_client_connection_set_use_ssl3((*C.GTlsClientConnection)(recv.native), c_use_ssl3)

	return
}

// SetValidationFlags is a wrapper around the C function g_tls_client_connection_set_validation_flags.
func (recv *TlsClientConnection) SetValidationFlags(flags TlsCertificateFlags) {
	c_flags := (C.GTlsCertificateFlags)(flags)

	C.g_tls_client_connection_set_validation_flags((*C.GTlsClientConnection)(recv.native), c_flags)

	return
}

// TlsFileDatabase is a wrapper around the C record GTlsFileDatabase.
type TlsFileDatabase struct {
	native *C.GTlsFileDatabase
}

func TlsFileDatabaseNewFromC(u unsafe.Pointer) *TlsFileDatabase {
	c := (*C.GTlsFileDatabase)(u)
	if c == nil {
		return nil
	}

	g := &TlsFileDatabase{native: c}

	return g
}

func (recv *TlsFileDatabase) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsFileDatabase with another TlsFileDatabase, and returns true if they represent the same GObject.
func (recv *TlsFileDatabase) Equals(other *TlsFileDatabase) bool {
	return other.ToC() == recv.ToC()
}

// TlsFileDatabaseNew is a wrapper around the C function g_tls_file_database_new.
func TlsFileDatabaseNew(anchors string) (*TlsFileDatabase, error) {
	c_anchors := C.CString(anchors)
	defer C.free(unsafe.Pointer(c_anchors))

	var cThrowableError *C.GError

	retC := C.g_tls_file_database_new(c_anchors, &cThrowableError)
	retGo := TlsFileDatabaseNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// TlsServerConnection is a wrapper around the C record GTlsServerConnection.
type TlsServerConnection struct {
	native *C.GTlsServerConnection
}

func TlsServerConnectionNewFromC(u unsafe.Pointer) *TlsServerConnection {
	c := (*C.GTlsServerConnection)(u)
	if c == nil {
		return nil
	}

	g := &TlsServerConnection{native: c}

	return g
}

func (recv *TlsServerConnection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsServerConnection with another TlsServerConnection, and returns true if they represent the same GObject.
func (recv *TlsServerConnection) Equals(other *TlsServerConnection) bool {
	return other.ToC() == recv.ToC()
}

// TlsServerConnectionNew is a wrapper around the C function g_tls_server_connection_new.
func TlsServerConnectionNew(baseIoStream *IOStream, certificate *TlsCertificate) (*TlsServerConnection, error) {
	c_base_io_stream := (*C.GIOStream)(C.NULL)
	if baseIoStream != nil {
		c_base_io_stream = (*C.GIOStream)(baseIoStream.ToC())
	}

	c_certificate := (*C.GTlsCertificate)(C.NULL)
	if certificate != nil {
		c_certificate = (*C.GTlsCertificate)(certificate.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_tls_server_connection_new(c_base_io_stream, c_certificate, &cThrowableError)
	retGo := TlsServerConnectionNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Volume is a wrapper around the C record GVolume.
type Volume struct {
	native *C.GVolume
}

func VolumeNewFromC(u unsafe.Pointer) *Volume {
	c := (*C.GVolume)(u)
	if c == nil {
		return nil
	}

	g := &Volume{native: c}

	return g
}

func (recv *Volume) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Volume with another Volume, and returns true if they represent the same GObject.
func (recv *Volume) Equals(other *Volume) bool {
	return other.ToC() == recv.ToC()
}

type signalVolumeChangedDetail struct {
	callback  VolumeSignalChangedCallback
	handlerID C.gulong
}

var signalVolumeChangedId int
var signalVolumeChangedMap = make(map[int]signalVolumeChangedDetail)
var signalVolumeChangedLock sync.RWMutex

// VolumeSignalChangedCallback is a callback function for a 'changed' signal emitted from a Volume.
type VolumeSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the Volume.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Volume) ConnectChanged(callback VolumeSignalChangedCallback) int {
	signalVolumeChangedLock.Lock()
	defer signalVolumeChangedLock.Unlock()

	signalVolumeChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Volume_signal_connect_changed(instance, C.gpointer(uintptr(signalVolumeChangedId)))

	detail := signalVolumeChangedDetail{callback, handlerID}
	signalVolumeChangedMap[signalVolumeChangedId] = detail

	return signalVolumeChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Volume.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Volume) DisconnectChanged(connectionID int) {
	signalVolumeChangedLock.Lock()
	defer signalVolumeChangedLock.Unlock()

	detail, exists := signalVolumeChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeChangedMap, connectionID)
}

//export volume_changedHandler
func volume_changedHandler(_ *C.GObject, data C.gpointer) {
	signalVolumeChangedLock.RLock()
	defer signalVolumeChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalVolumeChangedMap[index].callback
	callback()
}

type signalVolumeRemovedDetail struct {
	callback  VolumeSignalRemovedCallback
	handlerID C.gulong
}

var signalVolumeRemovedId int
var signalVolumeRemovedMap = make(map[int]signalVolumeRemovedDetail)
var signalVolumeRemovedLock sync.RWMutex

// VolumeSignalRemovedCallback is a callback function for a 'removed' signal emitted from a Volume.
type VolumeSignalRemovedCallback func()

/*
ConnectRemoved connects the callback to the 'removed' signal for the Volume.

The returned value represents the connection, and may be passed to DisconnectRemoved to remove it.
*/
func (recv *Volume) ConnectRemoved(callback VolumeSignalRemovedCallback) int {
	signalVolumeRemovedLock.Lock()
	defer signalVolumeRemovedLock.Unlock()

	signalVolumeRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Volume_signal_connect_removed(instance, C.gpointer(uintptr(signalVolumeRemovedId)))

	detail := signalVolumeRemovedDetail{callback, handlerID}
	signalVolumeRemovedMap[signalVolumeRemovedId] = detail

	return signalVolumeRemovedId
}

/*
DisconnectRemoved disconnects a callback from the 'removed' signal for the Volume.

The connectionID should be a value returned from a call to ConnectRemoved.
*/
func (recv *Volume) DisconnectRemoved(connectionID int) {
	signalVolumeRemovedLock.Lock()
	defer signalVolumeRemovedLock.Unlock()

	detail, exists := signalVolumeRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalVolumeRemovedMap, connectionID)
}

//export volume_removedHandler
func volume_removedHandler(_ *C.GObject, data C.gpointer) {
	signalVolumeRemovedLock.RLock()
	defer signalVolumeRemovedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalVolumeRemovedMap[index].callback
	callback()
}

// CanEject is a wrapper around the C function g_volume_can_eject.
func (recv *Volume) CanEject() bool {
	retC := C.g_volume_can_eject((*C.GVolume)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CanMount is a wrapper around the C function g_volume_can_mount.
func (recv *Volume) CanMount() bool {
	retC := C.g_volume_can_mount((*C.GVolume)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : g_volume_eject : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EjectFinish is a wrapper around the C function g_volume_eject_finish.
func (recv *Volume) EjectFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_volume_eject_finish((*C.GVolume)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Unsupported : g_volume_eject_with_operation : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// EjectWithOperationFinish is a wrapper around the C function g_volume_eject_with_operation_finish.
func (recv *Volume) EjectWithOperationFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_volume_eject_with_operation_finish((*C.GVolume)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// EnumerateIdentifiers is a wrapper around the C function g_volume_enumerate_identifiers.
func (recv *Volume) EnumerateIdentifiers() []string {
	retC := C.g_volume_enumerate_identifiers((*C.GVolume)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// GetActivationRoot is a wrapper around the C function g_volume_get_activation_root.
func (recv *Volume) GetActivationRoot() *File {
	retC := C.g_volume_get_activation_root((*C.GVolume)(recv.native))
	var retGo (*File)
	if retC == nil {
		retGo = nil
	} else {
		retGo = FileNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetDrive is a wrapper around the C function g_volume_get_drive.
func (recv *Volume) GetDrive() *Drive {
	retC := C.g_volume_get_drive((*C.GVolume)(recv.native))
	retGo := DriveNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIcon is a wrapper around the C function g_volume_get_icon.
func (recv *Volume) GetIcon() *Icon {
	retC := C.g_volume_get_icon((*C.GVolume)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIdentifier is a wrapper around the C function g_volume_get_identifier.
func (recv *Volume) GetIdentifier(kind string) string {
	c_kind := C.CString(kind)
	defer C.free(unsafe.Pointer(c_kind))

	retC := C.g_volume_get_identifier((*C.GVolume)(recv.native), c_kind)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetMount is a wrapper around the C function g_volume_get_mount.
func (recv *Volume) GetMount() *Mount {
	retC := C.g_volume_get_mount((*C.GVolume)(recv.native))
	retGo := MountNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetName is a wrapper around the C function g_volume_get_name.
func (recv *Volume) GetName() string {
	retC := C.g_volume_get_name((*C.GVolume)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetSortKey is a wrapper around the C function g_volume_get_sort_key.
func (recv *Volume) GetSortKey() string {
	retC := C.g_volume_get_sort_key((*C.GVolume)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetSymbolicIcon is a wrapper around the C function g_volume_get_symbolic_icon.
func (recv *Volume) GetSymbolicIcon() *Icon {
	retC := C.g_volume_get_symbolic_icon((*C.GVolume)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetUuid is a wrapper around the C function g_volume_get_uuid.
func (recv *Volume) GetUuid() string {
	retC := C.g_volume_get_uuid((*C.GVolume)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : g_volume_mount : unsupported parameter callback : no type generator for AsyncReadyCallback (GAsyncReadyCallback) for param callback

// MountFinish is a wrapper around the C function g_volume_mount_finish.
func (recv *Volume) MountFinish(result *AsyncResult) (bool, error) {
	c_result := (*C.GAsyncResult)(result.ToC())

	var cThrowableError *C.GError

	retC := C.g_volume_mount_finish((*C.GVolume)(recv.native), c_result, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ShouldAutomount is a wrapper around the C function g_volume_should_automount.
func (recv *Volume) ShouldAutomount() bool {
	retC := C.g_volume_should_automount((*C.GVolume)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ActionEntry is a wrapper around the C record GActionEntry.
type ActionEntry struct {
	native *C.GActionEntry
	Name   string
	// no type for activate
	ParameterType string
	State         string
	// no type for change_state
	// Private : padding
}

func ActionEntryNewFromC(u unsafe.Pointer) *ActionEntry {
	c := (*C.GActionEntry)(u)
	if c == nil {
		return nil
	}

	g := &ActionEntry{
		Name:          C.GoString(c.name),
		ParameterType: C.GoString(c.parameter_type),
		State:         C.GoString(c.state),
		native:        c,
	}

	return g
}

func (recv *ActionEntry) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native.parameter_type =
		C.CString(recv.ParameterType)
	recv.native.state =
		C.CString(recv.State)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionEntry with another ActionEntry, and returns true if they represent the same GObject.
func (recv *ActionEntry) Equals(other *ActionEntry) bool {
	return other.ToC() == recv.ToC()
}

// ActionGroupInterface is a wrapper around the C record GActionGroupInterface.
type ActionGroupInterface struct {
	native *C.GActionGroupInterface
	// g_iface : record
	// no type for has_action
	// no type for list_actions
	// no type for get_action_enabled
	// no type for get_action_parameter_type
	// no type for get_action_state_type
	// no type for get_action_state_hint
	// no type for get_action_state
	// no type for change_action_state
	// no type for activate_action
	// no type for action_added
	// no type for action_removed
	// no type for action_enabled_changed
	// no type for action_state_changed
	// no type for query_action
}

func ActionGroupInterfaceNewFromC(u unsafe.Pointer) *ActionGroupInterface {
	c := (*C.GActionGroupInterface)(u)
	if c == nil {
		return nil
	}

	g := &ActionGroupInterface{native: c}

	return g
}

func (recv *ActionGroupInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionGroupInterface with another ActionGroupInterface, and returns true if they represent the same GObject.
func (recv *ActionGroupInterface) Equals(other *ActionGroupInterface) bool {
	return other.ToC() == recv.ToC()
}

// ActionInterface is a wrapper around the C record GActionInterface.
type ActionInterface struct {
	native *C.GActionInterface
	// g_iface : record
	// no type for get_name
	// no type for get_parameter_type
	// no type for get_state_type
	// no type for get_state_hint
	// no type for get_enabled
	// no type for get_state
	// no type for change_state
	// no type for activate
}

func ActionInterfaceNewFromC(u unsafe.Pointer) *ActionInterface {
	c := (*C.GActionInterface)(u)
	if c == nil {
		return nil
	}

	g := &ActionInterface{native: c}

	return g
}

func (recv *ActionInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionInterface with another ActionInterface, and returns true if they represent the same GObject.
func (recv *ActionInterface) Equals(other *ActionInterface) bool {
	return other.ToC() == recv.ToC()
}

// ActionMapInterface is a wrapper around the C record GActionMapInterface.
type ActionMapInterface struct {
	native *C.GActionMapInterface
	// g_iface : record
	// no type for lookup_action
	// no type for add_action
	// no type for remove_action
}

func ActionMapInterfaceNewFromC(u unsafe.Pointer) *ActionMapInterface {
	c := (*C.GActionMapInterface)(u)
	if c == nil {
		return nil
	}

	g := &ActionMapInterface{native: c}

	return g
}

func (recv *ActionMapInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionMapInterface with another ActionMapInterface, and returns true if they represent the same GObject.
func (recv *ActionMapInterface) Equals(other *ActionMapInterface) bool {
	return other.ToC() == recv.ToC()
}

// AppInfoIface is a wrapper around the C record GAppInfoIface.
type AppInfoIface struct {
	native *C.GAppInfoIface
	// g_iface : record
	// no type for dup
	// no type for equal
	// no type for get_id
	// no type for get_name
	// no type for get_description
	// no type for get_executable
	// no type for get_icon
	// no type for launch
	// no type for supports_uris
	// no type for supports_files
	// no type for launch_uris
	// no type for should_show
	// no type for set_as_default_for_type
	// no type for set_as_default_for_extension
	// no type for add_supports_type
	// no type for can_remove_supports_type
	// no type for remove_supports_type
	// no type for can_delete
	// no type for do_delete
	// no type for get_commandline
	// no type for get_display_name
	// no type for set_as_last_used_for_type
	// no type for get_supported_types
}

func AppInfoIfaceNewFromC(u unsafe.Pointer) *AppInfoIface {
	c := (*C.GAppInfoIface)(u)
	if c == nil {
		return nil
	}

	g := &AppInfoIface{native: c}

	return g
}

func (recv *AppInfoIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppInfoIface with another AppInfoIface, and returns true if they represent the same GObject.
func (recv *AppInfoIface) Equals(other *AppInfoIface) bool {
	return other.ToC() == recv.ToC()
}

// AppLaunchContextClass is a wrapper around the C record GAppLaunchContextClass.
type AppLaunchContextClass struct {
	native *C.GAppLaunchContextClass
	// parent_class : record
	// no type for get_display
	// no type for get_startup_notify_id
	// no type for launch_failed
	// no type for launched
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
}

func AppLaunchContextClassNewFromC(u unsafe.Pointer) *AppLaunchContextClass {
	c := (*C.GAppLaunchContextClass)(u)
	if c == nil {
		return nil
	}

	g := &AppLaunchContextClass{native: c}

	return g
}

func (recv *AppLaunchContextClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppLaunchContextClass with another AppLaunchContextClass, and returns true if they represent the same GObject.
func (recv *AppLaunchContextClass) Equals(other *AppLaunchContextClass) bool {
	return other.ToC() == recv.ToC()
}

// AppLaunchContextPrivate is a wrapper around the C record GAppLaunchContextPrivate.
type AppLaunchContextPrivate struct {
	native *C.GAppLaunchContextPrivate
}

func AppLaunchContextPrivateNewFromC(u unsafe.Pointer) *AppLaunchContextPrivate {
	c := (*C.GAppLaunchContextPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AppLaunchContextPrivate{native: c}

	return g
}

func (recv *AppLaunchContextPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppLaunchContextPrivate with another AppLaunchContextPrivate, and returns true if they represent the same GObject.
func (recv *AppLaunchContextPrivate) Equals(other *AppLaunchContextPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ApplicationClass is a wrapper around the C record GApplicationClass.
type ApplicationClass struct {
	native *C.GApplicationClass
	// Private : parent_class
	// no type for startup
	// no type for activate
	// no type for open
	// no type for command_line
	// no type for local_command_line
	// no type for before_emit
	// no type for after_emit
	// no type for add_platform_data
	// no type for quit_mainloop
	// no type for run_mainloop
	// no type for shutdown
	// no type for dbus_register
	// no type for dbus_unregister
	// no type for handle_local_options
	// Private : padding
}

func ApplicationClassNewFromC(u unsafe.Pointer) *ApplicationClass {
	c := (*C.GApplicationClass)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationClass{native: c}

	return g
}

func (recv *ApplicationClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationClass with another ApplicationClass, and returns true if they represent the same GObject.
func (recv *ApplicationClass) Equals(other *ApplicationClass) bool {
	return other.ToC() == recv.ToC()
}

// ApplicationCommandLineClass is a wrapper around the C record GApplicationCommandLineClass.
type ApplicationCommandLineClass struct {
	native *C.GApplicationCommandLineClass
	// Private : parent_class
	// no type for print_literal
	// no type for printerr_literal
	// no type for get_stdin
	// Private : padding
}

func ApplicationCommandLineClassNewFromC(u unsafe.Pointer) *ApplicationCommandLineClass {
	c := (*C.GApplicationCommandLineClass)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationCommandLineClass{native: c}

	return g
}

func (recv *ApplicationCommandLineClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationCommandLineClass with another ApplicationCommandLineClass, and returns true if they represent the same GObject.
func (recv *ApplicationCommandLineClass) Equals(other *ApplicationCommandLineClass) bool {
	return other.ToC() == recv.ToC()
}

// ApplicationCommandLinePrivate is a wrapper around the C record GApplicationCommandLinePrivate.
type ApplicationCommandLinePrivate struct {
	native *C.GApplicationCommandLinePrivate
}

func ApplicationCommandLinePrivateNewFromC(u unsafe.Pointer) *ApplicationCommandLinePrivate {
	c := (*C.GApplicationCommandLinePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationCommandLinePrivate{native: c}

	return g
}

func (recv *ApplicationCommandLinePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationCommandLinePrivate with another ApplicationCommandLinePrivate, and returns true if they represent the same GObject.
func (recv *ApplicationCommandLinePrivate) Equals(other *ApplicationCommandLinePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ApplicationPrivate is a wrapper around the C record GApplicationPrivate.
type ApplicationPrivate struct {
	native *C.GApplicationPrivate
}

func ApplicationPrivateNewFromC(u unsafe.Pointer) *ApplicationPrivate {
	c := (*C.GApplicationPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationPrivate{native: c}

	return g
}

func (recv *ApplicationPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationPrivate with another ApplicationPrivate, and returns true if they represent the same GObject.
func (recv *ApplicationPrivate) Equals(other *ApplicationPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AsyncInitableIface is a wrapper around the C record GAsyncInitableIface.
type AsyncInitableIface struct {
	native *C.GAsyncInitableIface
	// g_iface : record
	// no type for init_async
	// no type for init_finish
}

func AsyncInitableIfaceNewFromC(u unsafe.Pointer) *AsyncInitableIface {
	c := (*C.GAsyncInitableIface)(u)
	if c == nil {
		return nil
	}

	g := &AsyncInitableIface{native: c}

	return g
}

func (recv *AsyncInitableIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AsyncInitableIface with another AsyncInitableIface, and returns true if they represent the same GObject.
func (recv *AsyncInitableIface) Equals(other *AsyncInitableIface) bool {
	return other.ToC() == recv.ToC()
}

// AsyncResultIface is a wrapper around the C record GAsyncResultIface.
type AsyncResultIface struct {
	native *C.GAsyncResultIface
	// g_iface : record
	// no type for get_user_data
	// no type for get_source_object
	// no type for is_tagged
}

func AsyncResultIfaceNewFromC(u unsafe.Pointer) *AsyncResultIface {
	c := (*C.GAsyncResultIface)(u)
	if c == nil {
		return nil
	}

	g := &AsyncResultIface{native: c}

	return g
}

func (recv *AsyncResultIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AsyncResultIface with another AsyncResultIface, and returns true if they represent the same GObject.
func (recv *AsyncResultIface) Equals(other *AsyncResultIface) bool {
	return other.ToC() == recv.ToC()
}

// BufferedInputStreamClass is a wrapper around the C record GBufferedInputStreamClass.
type BufferedInputStreamClass struct {
	native *C.GBufferedInputStreamClass
	// parent_class : record
	// no type for fill
	// no type for fill_async
	// no type for fill_finish
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func BufferedInputStreamClassNewFromC(u unsafe.Pointer) *BufferedInputStreamClass {
	c := (*C.GBufferedInputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &BufferedInputStreamClass{native: c}

	return g
}

func (recv *BufferedInputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BufferedInputStreamClass with another BufferedInputStreamClass, and returns true if they represent the same GObject.
func (recv *BufferedInputStreamClass) Equals(other *BufferedInputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// BufferedInputStreamPrivate is a wrapper around the C record GBufferedInputStreamPrivate.
type BufferedInputStreamPrivate struct {
	native *C.GBufferedInputStreamPrivate
}

func BufferedInputStreamPrivateNewFromC(u unsafe.Pointer) *BufferedInputStreamPrivate {
	c := (*C.GBufferedInputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &BufferedInputStreamPrivate{native: c}

	return g
}

func (recv *BufferedInputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BufferedInputStreamPrivate with another BufferedInputStreamPrivate, and returns true if they represent the same GObject.
func (recv *BufferedInputStreamPrivate) Equals(other *BufferedInputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// BufferedOutputStreamClass is a wrapper around the C record GBufferedOutputStreamClass.
type BufferedOutputStreamClass struct {
	native *C.GBufferedOutputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
}

func BufferedOutputStreamClassNewFromC(u unsafe.Pointer) *BufferedOutputStreamClass {
	c := (*C.GBufferedOutputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &BufferedOutputStreamClass{native: c}

	return g
}

func (recv *BufferedOutputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BufferedOutputStreamClass with another BufferedOutputStreamClass, and returns true if they represent the same GObject.
func (recv *BufferedOutputStreamClass) Equals(other *BufferedOutputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// BufferedOutputStreamPrivate is a wrapper around the C record GBufferedOutputStreamPrivate.
type BufferedOutputStreamPrivate struct {
	native *C.GBufferedOutputStreamPrivate
}

func BufferedOutputStreamPrivateNewFromC(u unsafe.Pointer) *BufferedOutputStreamPrivate {
	c := (*C.GBufferedOutputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &BufferedOutputStreamPrivate{native: c}

	return g
}

func (recv *BufferedOutputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BufferedOutputStreamPrivate with another BufferedOutputStreamPrivate, and returns true if they represent the same GObject.
func (recv *BufferedOutputStreamPrivate) Equals(other *BufferedOutputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CancellableClass is a wrapper around the C record GCancellableClass.
type CancellableClass struct {
	native *C.GCancellableClass
	// parent_class : record
	// no type for cancelled
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func CancellableClassNewFromC(u unsafe.Pointer) *CancellableClass {
	c := (*C.GCancellableClass)(u)
	if c == nil {
		return nil
	}

	g := &CancellableClass{native: c}

	return g
}

func (recv *CancellableClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CancellableClass with another CancellableClass, and returns true if they represent the same GObject.
func (recv *CancellableClass) Equals(other *CancellableClass) bool {
	return other.ToC() == recv.ToC()
}

// CancellablePrivate is a wrapper around the C record GCancellablePrivate.
type CancellablePrivate struct {
	native *C.GCancellablePrivate
}

func CancellablePrivateNewFromC(u unsafe.Pointer) *CancellablePrivate {
	c := (*C.GCancellablePrivate)(u)
	if c == nil {
		return nil
	}

	g := &CancellablePrivate{native: c}

	return g
}

func (recv *CancellablePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CancellablePrivate with another CancellablePrivate, and returns true if they represent the same GObject.
func (recv *CancellablePrivate) Equals(other *CancellablePrivate) bool {
	return other.ToC() == recv.ToC()
}

// CharsetConverterClass is a wrapper around the C record GCharsetConverterClass.
type CharsetConverterClass struct {
	native *C.GCharsetConverterClass
	// parent_class : record
}

func CharsetConverterClassNewFromC(u unsafe.Pointer) *CharsetConverterClass {
	c := (*C.GCharsetConverterClass)(u)
	if c == nil {
		return nil
	}

	g := &CharsetConverterClass{native: c}

	return g
}

func (recv *CharsetConverterClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CharsetConverterClass with another CharsetConverterClass, and returns true if they represent the same GObject.
func (recv *CharsetConverterClass) Equals(other *CharsetConverterClass) bool {
	return other.ToC() == recv.ToC()
}

// ConverterIface is a wrapper around the C record GConverterIface.
type ConverterIface struct {
	native *C.GConverterIface
	// g_iface : record
	// no type for convert
	// no type for reset
}

func ConverterIfaceNewFromC(u unsafe.Pointer) *ConverterIface {
	c := (*C.GConverterIface)(u)
	if c == nil {
		return nil
	}

	g := &ConverterIface{native: c}

	return g
}

func (recv *ConverterIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ConverterIface with another ConverterIface, and returns true if they represent the same GObject.
func (recv *ConverterIface) Equals(other *ConverterIface) bool {
	return other.ToC() == recv.ToC()
}

// ConverterInputStreamClass is a wrapper around the C record GConverterInputStreamClass.
type ConverterInputStreamClass struct {
	native *C.GConverterInputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func ConverterInputStreamClassNewFromC(u unsafe.Pointer) *ConverterInputStreamClass {
	c := (*C.GConverterInputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &ConverterInputStreamClass{native: c}

	return g
}

func (recv *ConverterInputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ConverterInputStreamClass with another ConverterInputStreamClass, and returns true if they represent the same GObject.
func (recv *ConverterInputStreamClass) Equals(other *ConverterInputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// ConverterInputStreamPrivate is a wrapper around the C record GConverterInputStreamPrivate.
type ConverterInputStreamPrivate struct {
	native *C.GConverterInputStreamPrivate
}

func ConverterInputStreamPrivateNewFromC(u unsafe.Pointer) *ConverterInputStreamPrivate {
	c := (*C.GConverterInputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ConverterInputStreamPrivate{native: c}

	return g
}

func (recv *ConverterInputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ConverterInputStreamPrivate with another ConverterInputStreamPrivate, and returns true if they represent the same GObject.
func (recv *ConverterInputStreamPrivate) Equals(other *ConverterInputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ConverterOutputStreamClass is a wrapper around the C record GConverterOutputStreamClass.
type ConverterOutputStreamClass struct {
	native *C.GConverterOutputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func ConverterOutputStreamClassNewFromC(u unsafe.Pointer) *ConverterOutputStreamClass {
	c := (*C.GConverterOutputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &ConverterOutputStreamClass{native: c}

	return g
}

func (recv *ConverterOutputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ConverterOutputStreamClass with another ConverterOutputStreamClass, and returns true if they represent the same GObject.
func (recv *ConverterOutputStreamClass) Equals(other *ConverterOutputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// ConverterOutputStreamPrivate is a wrapper around the C record GConverterOutputStreamPrivate.
type ConverterOutputStreamPrivate struct {
	native *C.GConverterOutputStreamPrivate
}

func ConverterOutputStreamPrivateNewFromC(u unsafe.Pointer) *ConverterOutputStreamPrivate {
	c := (*C.GConverterOutputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ConverterOutputStreamPrivate{native: c}

	return g
}

func (recv *ConverterOutputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ConverterOutputStreamPrivate with another ConverterOutputStreamPrivate, and returns true if they represent the same GObject.
func (recv *ConverterOutputStreamPrivate) Equals(other *ConverterOutputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CredentialsClass is a wrapper around the C record GCredentialsClass.
type CredentialsClass struct {
	native *C.GCredentialsClass
}

func CredentialsClassNewFromC(u unsafe.Pointer) *CredentialsClass {
	c := (*C.GCredentialsClass)(u)
	if c == nil {
		return nil
	}

	g := &CredentialsClass{native: c}

	return g
}

func (recv *CredentialsClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CredentialsClass with another CredentialsClass, and returns true if they represent the same GObject.
func (recv *CredentialsClass) Equals(other *CredentialsClass) bool {
	return other.ToC() == recv.ToC()
}

// DBusAnnotationInfo is a wrapper around the C record GDBusAnnotationInfo.
type DBusAnnotationInfo struct {
	native   *C.GDBusAnnotationInfo
	RefCount int32
	Key      string
	Value    string
	// no type for annotations
}

func DBusAnnotationInfoNewFromC(u unsafe.Pointer) *DBusAnnotationInfo {
	c := (*C.GDBusAnnotationInfo)(u)
	if c == nil {
		return nil
	}

	g := &DBusAnnotationInfo{
		Key:      C.GoString(c.key),
		RefCount: (int32)(c.ref_count),
		Value:    C.GoString(c.value),
		native:   c,
	}

	return g
}

func (recv *DBusAnnotationInfo) ToC() unsafe.Pointer {
	recv.native.ref_count =
		(C.gint)(recv.RefCount)
	recv.native.key =
		C.CString(recv.Key)
	recv.native.value =
		C.CString(recv.Value)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusAnnotationInfo with another DBusAnnotationInfo, and returns true if they represent the same GObject.
func (recv *DBusAnnotationInfo) Equals(other *DBusAnnotationInfo) bool {
	return other.ToC() == recv.ToC()
}

// g_dbus_annotation_info_lookup : unsupported parameter annotations :
// Ref is a wrapper around the C function g_dbus_annotation_info_ref.
func (recv *DBusAnnotationInfo) Ref() *DBusAnnotationInfo {
	retC := C.g_dbus_annotation_info_ref((*C.GDBusAnnotationInfo)(recv.native))
	retGo := DBusAnnotationInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_dbus_annotation_info_unref.
func (recv *DBusAnnotationInfo) Unref() {
	C.g_dbus_annotation_info_unref((*C.GDBusAnnotationInfo)(recv.native))

	return
}

// DBusArgInfo is a wrapper around the C record GDBusArgInfo.
type DBusArgInfo struct {
	native    *C.GDBusArgInfo
	RefCount  int32
	Name      string
	Signature string
	// no type for annotations
}

func DBusArgInfoNewFromC(u unsafe.Pointer) *DBusArgInfo {
	c := (*C.GDBusArgInfo)(u)
	if c == nil {
		return nil
	}

	g := &DBusArgInfo{
		Name:      C.GoString(c.name),
		RefCount:  (int32)(c.ref_count),
		Signature: C.GoString(c.signature),
		native:    c,
	}

	return g
}

func (recv *DBusArgInfo) ToC() unsafe.Pointer {
	recv.native.ref_count =
		(C.gint)(recv.RefCount)
	recv.native.name =
		C.CString(recv.Name)
	recv.native.signature =
		C.CString(recv.Signature)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusArgInfo with another DBusArgInfo, and returns true if they represent the same GObject.
func (recv *DBusArgInfo) Equals(other *DBusArgInfo) bool {
	return other.ToC() == recv.ToC()
}

// Ref is a wrapper around the C function g_dbus_arg_info_ref.
func (recv *DBusArgInfo) Ref() *DBusArgInfo {
	retC := C.g_dbus_arg_info_ref((*C.GDBusArgInfo)(recv.native))
	retGo := DBusArgInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_dbus_arg_info_unref.
func (recv *DBusArgInfo) Unref() {
	C.g_dbus_arg_info_unref((*C.GDBusArgInfo)(recv.native))

	return
}

// DBusErrorEntry is a wrapper around the C record GDBusErrorEntry.
type DBusErrorEntry struct {
	native        *C.GDBusErrorEntry
	ErrorCode     int32
	DbusErrorName string
}

func DBusErrorEntryNewFromC(u unsafe.Pointer) *DBusErrorEntry {
	c := (*C.GDBusErrorEntry)(u)
	if c == nil {
		return nil
	}

	g := &DBusErrorEntry{
		DbusErrorName: C.GoString(c.dbus_error_name),
		ErrorCode:     (int32)(c.error_code),
		native:        c,
	}

	return g
}

func (recv *DBusErrorEntry) ToC() unsafe.Pointer {
	recv.native.error_code =
		(C.gint)(recv.ErrorCode)
	recv.native.dbus_error_name =
		C.CString(recv.DbusErrorName)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusErrorEntry with another DBusErrorEntry, and returns true if they represent the same GObject.
func (recv *DBusErrorEntry) Equals(other *DBusErrorEntry) bool {
	return other.ToC() == recv.ToC()
}

// DBusInterfaceIface is a wrapper around the C record GDBusInterfaceIface.
type DBusInterfaceIface struct {
	native *C.GDBusInterfaceIface
	// parent_iface : record
	// no type for get_info
	// no type for get_object
	// no type for set_object
	// no type for dup_object
}

func DBusInterfaceIfaceNewFromC(u unsafe.Pointer) *DBusInterfaceIface {
	c := (*C.GDBusInterfaceIface)(u)
	if c == nil {
		return nil
	}

	g := &DBusInterfaceIface{native: c}

	return g
}

func (recv *DBusInterfaceIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusInterfaceIface with another DBusInterfaceIface, and returns true if they represent the same GObject.
func (recv *DBusInterfaceIface) Equals(other *DBusInterfaceIface) bool {
	return other.ToC() == recv.ToC()
}

// DBusInterfaceInfo is a wrapper around the C record GDBusInterfaceInfo.
type DBusInterfaceInfo struct {
	native   *C.GDBusInterfaceInfo
	RefCount int32
	Name     string
	// no type for methods
	// no type for signals
	// no type for properties
	// no type for annotations
}

func DBusInterfaceInfoNewFromC(u unsafe.Pointer) *DBusInterfaceInfo {
	c := (*C.GDBusInterfaceInfo)(u)
	if c == nil {
		return nil
	}

	g := &DBusInterfaceInfo{
		Name:     C.GoString(c.name),
		RefCount: (int32)(c.ref_count),
		native:   c,
	}

	return g
}

func (recv *DBusInterfaceInfo) ToC() unsafe.Pointer {
	recv.native.ref_count =
		(C.gint)(recv.RefCount)
	recv.native.name =
		C.CString(recv.Name)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusInterfaceInfo with another DBusInterfaceInfo, and returns true if they represent the same GObject.
func (recv *DBusInterfaceInfo) Equals(other *DBusInterfaceInfo) bool {
	return other.ToC() == recv.ToC()
}

// CacheBuild is a wrapper around the C function g_dbus_interface_info_cache_build.
func (recv *DBusInterfaceInfo) CacheBuild() {
	C.g_dbus_interface_info_cache_build((*C.GDBusInterfaceInfo)(recv.native))

	return
}

// CacheRelease is a wrapper around the C function g_dbus_interface_info_cache_release.
func (recv *DBusInterfaceInfo) CacheRelease() {
	C.g_dbus_interface_info_cache_release((*C.GDBusInterfaceInfo)(recv.native))

	return
}

// GenerateXml is a wrapper around the C function g_dbus_interface_info_generate_xml.
func (recv *DBusInterfaceInfo) GenerateXml(indent uint32, stringBuilder *glib.String) {
	c_indent := (C.guint)(indent)

	c_string_builder := (*C.GString)(C.NULL)
	if stringBuilder != nil {
		c_string_builder = (*C.GString)(stringBuilder.ToC())
	}

	C.g_dbus_interface_info_generate_xml((*C.GDBusInterfaceInfo)(recv.native), c_indent, c_string_builder)

	return
}

// LookupMethod is a wrapper around the C function g_dbus_interface_info_lookup_method.
func (recv *DBusInterfaceInfo) LookupMethod(name string) *DBusMethodInfo {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_dbus_interface_info_lookup_method((*C.GDBusInterfaceInfo)(recv.native), c_name)
	retGo := DBusMethodInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// LookupProperty is a wrapper around the C function g_dbus_interface_info_lookup_property.
func (recv *DBusInterfaceInfo) LookupProperty(name string) *DBusPropertyInfo {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_dbus_interface_info_lookup_property((*C.GDBusInterfaceInfo)(recv.native), c_name)
	retGo := DBusPropertyInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// LookupSignal is a wrapper around the C function g_dbus_interface_info_lookup_signal.
func (recv *DBusInterfaceInfo) LookupSignal(name string) *DBusSignalInfo {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_dbus_interface_info_lookup_signal((*C.GDBusInterfaceInfo)(recv.native), c_name)
	retGo := DBusSignalInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Ref is a wrapper around the C function g_dbus_interface_info_ref.
func (recv *DBusInterfaceInfo) Ref() *DBusInterfaceInfo {
	retC := C.g_dbus_interface_info_ref((*C.GDBusInterfaceInfo)(recv.native))
	retGo := DBusInterfaceInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_dbus_interface_info_unref.
func (recv *DBusInterfaceInfo) Unref() {
	C.g_dbus_interface_info_unref((*C.GDBusInterfaceInfo)(recv.native))

	return
}

// DBusInterfaceSkeletonClass is a wrapper around the C record GDBusInterfaceSkeletonClass.
type DBusInterfaceSkeletonClass struct {
	native *C.GDBusInterfaceSkeletonClass
	// parent_class : record
	// no type for get_info
	// no type for get_vtable
	// no type for get_properties
	// no type for flush
	// Private : vfunc_padding
	// no type for g_authorize_method
	// Private : signal_padding
}

func DBusInterfaceSkeletonClassNewFromC(u unsafe.Pointer) *DBusInterfaceSkeletonClass {
	c := (*C.GDBusInterfaceSkeletonClass)(u)
	if c == nil {
		return nil
	}

	g := &DBusInterfaceSkeletonClass{native: c}

	return g
}

func (recv *DBusInterfaceSkeletonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusInterfaceSkeletonClass with another DBusInterfaceSkeletonClass, and returns true if they represent the same GObject.
func (recv *DBusInterfaceSkeletonClass) Equals(other *DBusInterfaceSkeletonClass) bool {
	return other.ToC() == recv.ToC()
}

// DBusInterfaceSkeletonPrivate is a wrapper around the C record GDBusInterfaceSkeletonPrivate.
type DBusInterfaceSkeletonPrivate struct {
	native *C.GDBusInterfaceSkeletonPrivate
}

func DBusInterfaceSkeletonPrivateNewFromC(u unsafe.Pointer) *DBusInterfaceSkeletonPrivate {
	c := (*C.GDBusInterfaceSkeletonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DBusInterfaceSkeletonPrivate{native: c}

	return g
}

func (recv *DBusInterfaceSkeletonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusInterfaceSkeletonPrivate with another DBusInterfaceSkeletonPrivate, and returns true if they represent the same GObject.
func (recv *DBusInterfaceSkeletonPrivate) Equals(other *DBusInterfaceSkeletonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DBusInterfaceVTable is a wrapper around the C record GDBusInterfaceVTable.
type DBusInterfaceVTable struct {
	native *C.GDBusInterfaceVTable
	// method_call : no type generator for DBusInterfaceMethodCallFunc, GDBusInterfaceMethodCallFunc
	// get_property : no type generator for DBusInterfaceGetPropertyFunc, GDBusInterfaceGetPropertyFunc
	// set_property : no type generator for DBusInterfaceSetPropertyFunc, GDBusInterfaceSetPropertyFunc
	// Private : padding
}

func DBusInterfaceVTableNewFromC(u unsafe.Pointer) *DBusInterfaceVTable {
	c := (*C.GDBusInterfaceVTable)(u)
	if c == nil {
		return nil
	}

	g := &DBusInterfaceVTable{native: c}

	return g
}

func (recv *DBusInterfaceVTable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusInterfaceVTable with another DBusInterfaceVTable, and returns true if they represent the same GObject.
func (recv *DBusInterfaceVTable) Equals(other *DBusInterfaceVTable) bool {
	return other.ToC() == recv.ToC()
}

// DBusMethodInfo is a wrapper around the C record GDBusMethodInfo.
type DBusMethodInfo struct {
	native   *C.GDBusMethodInfo
	RefCount int32
	Name     string
	// no type for in_args
	// no type for out_args
	// no type for annotations
}

func DBusMethodInfoNewFromC(u unsafe.Pointer) *DBusMethodInfo {
	c := (*C.GDBusMethodInfo)(u)
	if c == nil {
		return nil
	}

	g := &DBusMethodInfo{
		Name:     C.GoString(c.name),
		RefCount: (int32)(c.ref_count),
		native:   c,
	}

	return g
}

func (recv *DBusMethodInfo) ToC() unsafe.Pointer {
	recv.native.ref_count =
		(C.gint)(recv.RefCount)
	recv.native.name =
		C.CString(recv.Name)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusMethodInfo with another DBusMethodInfo, and returns true if they represent the same GObject.
func (recv *DBusMethodInfo) Equals(other *DBusMethodInfo) bool {
	return other.ToC() == recv.ToC()
}

// Ref is a wrapper around the C function g_dbus_method_info_ref.
func (recv *DBusMethodInfo) Ref() *DBusMethodInfo {
	retC := C.g_dbus_method_info_ref((*C.GDBusMethodInfo)(recv.native))
	retGo := DBusMethodInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_dbus_method_info_unref.
func (recv *DBusMethodInfo) Unref() {
	C.g_dbus_method_info_unref((*C.GDBusMethodInfo)(recv.native))

	return
}

// DBusNodeInfo is a wrapper around the C record GDBusNodeInfo.
type DBusNodeInfo struct {
	native   *C.GDBusNodeInfo
	RefCount int32
	Path     string
	// no type for interfaces
	// no type for nodes
	// no type for annotations
}

func DBusNodeInfoNewFromC(u unsafe.Pointer) *DBusNodeInfo {
	c := (*C.GDBusNodeInfo)(u)
	if c == nil {
		return nil
	}

	g := &DBusNodeInfo{
		Path:     C.GoString(c.path),
		RefCount: (int32)(c.ref_count),
		native:   c,
	}

	return g
}

func (recv *DBusNodeInfo) ToC() unsafe.Pointer {
	recv.native.ref_count =
		(C.gint)(recv.RefCount)
	recv.native.path =
		C.CString(recv.Path)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusNodeInfo with another DBusNodeInfo, and returns true if they represent the same GObject.
func (recv *DBusNodeInfo) Equals(other *DBusNodeInfo) bool {
	return other.ToC() == recv.ToC()
}

// DBusNodeInfoNewForXml is a wrapper around the C function g_dbus_node_info_new_for_xml.
func DBusNodeInfoNewForXml(xmlData string) (*DBusNodeInfo, error) {
	c_xml_data := C.CString(xmlData)
	defer C.free(unsafe.Pointer(c_xml_data))

	var cThrowableError *C.GError

	retC := C.g_dbus_node_info_new_for_xml(c_xml_data, &cThrowableError)
	retGo := DBusNodeInfoNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GenerateXml is a wrapper around the C function g_dbus_node_info_generate_xml.
func (recv *DBusNodeInfo) GenerateXml(indent uint32, stringBuilder *glib.String) {
	c_indent := (C.guint)(indent)

	c_string_builder := (*C.GString)(C.NULL)
	if stringBuilder != nil {
		c_string_builder = (*C.GString)(stringBuilder.ToC())
	}

	C.g_dbus_node_info_generate_xml((*C.GDBusNodeInfo)(recv.native), c_indent, c_string_builder)

	return
}

// LookupInterface is a wrapper around the C function g_dbus_node_info_lookup_interface.
func (recv *DBusNodeInfo) LookupInterface(name string) *DBusInterfaceInfo {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_dbus_node_info_lookup_interface((*C.GDBusNodeInfo)(recv.native), c_name)
	retGo := DBusInterfaceInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Ref is a wrapper around the C function g_dbus_node_info_ref.
func (recv *DBusNodeInfo) Ref() *DBusNodeInfo {
	retC := C.g_dbus_node_info_ref((*C.GDBusNodeInfo)(recv.native))
	retGo := DBusNodeInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_dbus_node_info_unref.
func (recv *DBusNodeInfo) Unref() {
	C.g_dbus_node_info_unref((*C.GDBusNodeInfo)(recv.native))

	return
}

// DBusObjectIface is a wrapper around the C record GDBusObjectIface.
type DBusObjectIface struct {
	native *C.GDBusObjectIface
	// parent_iface : record
	// no type for get_object_path
	// no type for get_interfaces
	// no type for get_interface
	// no type for interface_added
	// no type for interface_removed
}

func DBusObjectIfaceNewFromC(u unsafe.Pointer) *DBusObjectIface {
	c := (*C.GDBusObjectIface)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectIface{native: c}

	return g
}

func (recv *DBusObjectIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectIface with another DBusObjectIface, and returns true if they represent the same GObject.
func (recv *DBusObjectIface) Equals(other *DBusObjectIface) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectManagerClientClass is a wrapper around the C record GDBusObjectManagerClientClass.
type DBusObjectManagerClientClass struct {
	native *C.GDBusObjectManagerClientClass
	// parent_class : record
	// no type for interface_proxy_signal
	// no type for interface_proxy_properties_changed
	// Private : padding
}

func DBusObjectManagerClientClassNewFromC(u unsafe.Pointer) *DBusObjectManagerClientClass {
	c := (*C.GDBusObjectManagerClientClass)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectManagerClientClass{native: c}

	return g
}

func (recv *DBusObjectManagerClientClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectManagerClientClass with another DBusObjectManagerClientClass, and returns true if they represent the same GObject.
func (recv *DBusObjectManagerClientClass) Equals(other *DBusObjectManagerClientClass) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectManagerClientPrivate is a wrapper around the C record GDBusObjectManagerClientPrivate.
type DBusObjectManagerClientPrivate struct {
	native *C.GDBusObjectManagerClientPrivate
}

func DBusObjectManagerClientPrivateNewFromC(u unsafe.Pointer) *DBusObjectManagerClientPrivate {
	c := (*C.GDBusObjectManagerClientPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectManagerClientPrivate{native: c}

	return g
}

func (recv *DBusObjectManagerClientPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectManagerClientPrivate with another DBusObjectManagerClientPrivate, and returns true if they represent the same GObject.
func (recv *DBusObjectManagerClientPrivate) Equals(other *DBusObjectManagerClientPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectManagerIface is a wrapper around the C record GDBusObjectManagerIface.
type DBusObjectManagerIface struct {
	native *C.GDBusObjectManagerIface
	// parent_iface : record
	// no type for get_object_path
	// no type for get_objects
	// no type for get_object
	// no type for get_interface
	// no type for object_added
	// no type for object_removed
	// no type for interface_added
	// no type for interface_removed
}

func DBusObjectManagerIfaceNewFromC(u unsafe.Pointer) *DBusObjectManagerIface {
	c := (*C.GDBusObjectManagerIface)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectManagerIface{native: c}

	return g
}

func (recv *DBusObjectManagerIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectManagerIface with another DBusObjectManagerIface, and returns true if they represent the same GObject.
func (recv *DBusObjectManagerIface) Equals(other *DBusObjectManagerIface) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectManagerServerClass is a wrapper around the C record GDBusObjectManagerServerClass.
type DBusObjectManagerServerClass struct {
	native *C.GDBusObjectManagerServerClass
	// parent_class : record
	// Private : padding
}

func DBusObjectManagerServerClassNewFromC(u unsafe.Pointer) *DBusObjectManagerServerClass {
	c := (*C.GDBusObjectManagerServerClass)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectManagerServerClass{native: c}

	return g
}

func (recv *DBusObjectManagerServerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectManagerServerClass with another DBusObjectManagerServerClass, and returns true if they represent the same GObject.
func (recv *DBusObjectManagerServerClass) Equals(other *DBusObjectManagerServerClass) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectManagerServerPrivate is a wrapper around the C record GDBusObjectManagerServerPrivate.
type DBusObjectManagerServerPrivate struct {
	native *C.GDBusObjectManagerServerPrivate
}

func DBusObjectManagerServerPrivateNewFromC(u unsafe.Pointer) *DBusObjectManagerServerPrivate {
	c := (*C.GDBusObjectManagerServerPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectManagerServerPrivate{native: c}

	return g
}

func (recv *DBusObjectManagerServerPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectManagerServerPrivate with another DBusObjectManagerServerPrivate, and returns true if they represent the same GObject.
func (recv *DBusObjectManagerServerPrivate) Equals(other *DBusObjectManagerServerPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectProxyClass is a wrapper around the C record GDBusObjectProxyClass.
type DBusObjectProxyClass struct {
	native *C.GDBusObjectProxyClass
	// parent_class : record
	// Private : padding
}

func DBusObjectProxyClassNewFromC(u unsafe.Pointer) *DBusObjectProxyClass {
	c := (*C.GDBusObjectProxyClass)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectProxyClass{native: c}

	return g
}

func (recv *DBusObjectProxyClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectProxyClass with another DBusObjectProxyClass, and returns true if they represent the same GObject.
func (recv *DBusObjectProxyClass) Equals(other *DBusObjectProxyClass) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectProxyPrivate is a wrapper around the C record GDBusObjectProxyPrivate.
type DBusObjectProxyPrivate struct {
	native *C.GDBusObjectProxyPrivate
}

func DBusObjectProxyPrivateNewFromC(u unsafe.Pointer) *DBusObjectProxyPrivate {
	c := (*C.GDBusObjectProxyPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectProxyPrivate{native: c}

	return g
}

func (recv *DBusObjectProxyPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectProxyPrivate with another DBusObjectProxyPrivate, and returns true if they represent the same GObject.
func (recv *DBusObjectProxyPrivate) Equals(other *DBusObjectProxyPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectSkeletonClass is a wrapper around the C record GDBusObjectSkeletonClass.
type DBusObjectSkeletonClass struct {
	native *C.GDBusObjectSkeletonClass
	// parent_class : record
	// no type for authorize_method
	// Private : padding
}

func DBusObjectSkeletonClassNewFromC(u unsafe.Pointer) *DBusObjectSkeletonClass {
	c := (*C.GDBusObjectSkeletonClass)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectSkeletonClass{native: c}

	return g
}

func (recv *DBusObjectSkeletonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectSkeletonClass with another DBusObjectSkeletonClass, and returns true if they represent the same GObject.
func (recv *DBusObjectSkeletonClass) Equals(other *DBusObjectSkeletonClass) bool {
	return other.ToC() == recv.ToC()
}

// DBusObjectSkeletonPrivate is a wrapper around the C record GDBusObjectSkeletonPrivate.
type DBusObjectSkeletonPrivate struct {
	native *C.GDBusObjectSkeletonPrivate
}

func DBusObjectSkeletonPrivateNewFromC(u unsafe.Pointer) *DBusObjectSkeletonPrivate {
	c := (*C.GDBusObjectSkeletonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DBusObjectSkeletonPrivate{native: c}

	return g
}

func (recv *DBusObjectSkeletonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusObjectSkeletonPrivate with another DBusObjectSkeletonPrivate, and returns true if they represent the same GObject.
func (recv *DBusObjectSkeletonPrivate) Equals(other *DBusObjectSkeletonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DBusPropertyInfo is a wrapper around the C record GDBusPropertyInfo.
type DBusPropertyInfo struct {
	native    *C.GDBusPropertyInfo
	RefCount  int32
	Name      string
	Signature string
	Flags     DBusPropertyInfoFlags
	// no type for annotations
}

func DBusPropertyInfoNewFromC(u unsafe.Pointer) *DBusPropertyInfo {
	c := (*C.GDBusPropertyInfo)(u)
	if c == nil {
		return nil
	}

	g := &DBusPropertyInfo{
		Flags:     (DBusPropertyInfoFlags)(c.flags),
		Name:      C.GoString(c.name),
		RefCount:  (int32)(c.ref_count),
		Signature: C.GoString(c.signature),
		native:    c,
	}

	return g
}

func (recv *DBusPropertyInfo) ToC() unsafe.Pointer {
	recv.native.ref_count =
		(C.gint)(recv.RefCount)
	recv.native.name =
		C.CString(recv.Name)
	recv.native.signature =
		C.CString(recv.Signature)
	recv.native.flags =
		(C.GDBusPropertyInfoFlags)(recv.Flags)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusPropertyInfo with another DBusPropertyInfo, and returns true if they represent the same GObject.
func (recv *DBusPropertyInfo) Equals(other *DBusPropertyInfo) bool {
	return other.ToC() == recv.ToC()
}

// Ref is a wrapper around the C function g_dbus_property_info_ref.
func (recv *DBusPropertyInfo) Ref() *DBusPropertyInfo {
	retC := C.g_dbus_property_info_ref((*C.GDBusPropertyInfo)(recv.native))
	retGo := DBusPropertyInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_dbus_property_info_unref.
func (recv *DBusPropertyInfo) Unref() {
	C.g_dbus_property_info_unref((*C.GDBusPropertyInfo)(recv.native))

	return
}

// DBusProxyClass is a wrapper around the C record GDBusProxyClass.
type DBusProxyClass struct {
	native *C.GDBusProxyClass
	// Private : parent_class
	// no type for g_properties_changed
	// no type for g_signal
	// Private : padding
}

func DBusProxyClassNewFromC(u unsafe.Pointer) *DBusProxyClass {
	c := (*C.GDBusProxyClass)(u)
	if c == nil {
		return nil
	}

	g := &DBusProxyClass{native: c}

	return g
}

func (recv *DBusProxyClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusProxyClass with another DBusProxyClass, and returns true if they represent the same GObject.
func (recv *DBusProxyClass) Equals(other *DBusProxyClass) bool {
	return other.ToC() == recv.ToC()
}

// DBusProxyPrivate is a wrapper around the C record GDBusProxyPrivate.
type DBusProxyPrivate struct {
	native *C.GDBusProxyPrivate
}

func DBusProxyPrivateNewFromC(u unsafe.Pointer) *DBusProxyPrivate {
	c := (*C.GDBusProxyPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DBusProxyPrivate{native: c}

	return g
}

func (recv *DBusProxyPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusProxyPrivate with another DBusProxyPrivate, and returns true if they represent the same GObject.
func (recv *DBusProxyPrivate) Equals(other *DBusProxyPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DBusSignalInfo is a wrapper around the C record GDBusSignalInfo.
type DBusSignalInfo struct {
	native   *C.GDBusSignalInfo
	RefCount int32
	Name     string
	// no type for args
	// no type for annotations
}

func DBusSignalInfoNewFromC(u unsafe.Pointer) *DBusSignalInfo {
	c := (*C.GDBusSignalInfo)(u)
	if c == nil {
		return nil
	}

	g := &DBusSignalInfo{
		Name:     C.GoString(c.name),
		RefCount: (int32)(c.ref_count),
		native:   c,
	}

	return g
}

func (recv *DBusSignalInfo) ToC() unsafe.Pointer {
	recv.native.ref_count =
		(C.gint)(recv.RefCount)
	recv.native.name =
		C.CString(recv.Name)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusSignalInfo with another DBusSignalInfo, and returns true if they represent the same GObject.
func (recv *DBusSignalInfo) Equals(other *DBusSignalInfo) bool {
	return other.ToC() == recv.ToC()
}

// Ref is a wrapper around the C function g_dbus_signal_info_ref.
func (recv *DBusSignalInfo) Ref() *DBusSignalInfo {
	retC := C.g_dbus_signal_info_ref((*C.GDBusSignalInfo)(recv.native))
	retGo := DBusSignalInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_dbus_signal_info_unref.
func (recv *DBusSignalInfo) Unref() {
	C.g_dbus_signal_info_unref((*C.GDBusSignalInfo)(recv.native))

	return
}

// DBusSubtreeVTable is a wrapper around the C record GDBusSubtreeVTable.
type DBusSubtreeVTable struct {
	native *C.GDBusSubtreeVTable
	// enumerate : no type generator for DBusSubtreeEnumerateFunc, GDBusSubtreeEnumerateFunc
	// introspect : no type generator for DBusSubtreeIntrospectFunc, GDBusSubtreeIntrospectFunc
	// dispatch : no type generator for DBusSubtreeDispatchFunc, GDBusSubtreeDispatchFunc
	// Private : padding
}

func DBusSubtreeVTableNewFromC(u unsafe.Pointer) *DBusSubtreeVTable {
	c := (*C.GDBusSubtreeVTable)(u)
	if c == nil {
		return nil
	}

	g := &DBusSubtreeVTable{native: c}

	return g
}

func (recv *DBusSubtreeVTable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DBusSubtreeVTable with another DBusSubtreeVTable, and returns true if they represent the same GObject.
func (recv *DBusSubtreeVTable) Equals(other *DBusSubtreeVTable) bool {
	return other.ToC() == recv.ToC()
}

// DataInputStreamClass is a wrapper around the C record GDataInputStreamClass.
type DataInputStreamClass struct {
	native *C.GDataInputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func DataInputStreamClassNewFromC(u unsafe.Pointer) *DataInputStreamClass {
	c := (*C.GDataInputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &DataInputStreamClass{native: c}

	return g
}

func (recv *DataInputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DataInputStreamClass with another DataInputStreamClass, and returns true if they represent the same GObject.
func (recv *DataInputStreamClass) Equals(other *DataInputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// DataInputStreamPrivate is a wrapper around the C record GDataInputStreamPrivate.
type DataInputStreamPrivate struct {
	native *C.GDataInputStreamPrivate
}

func DataInputStreamPrivateNewFromC(u unsafe.Pointer) *DataInputStreamPrivate {
	c := (*C.GDataInputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DataInputStreamPrivate{native: c}

	return g
}

func (recv *DataInputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DataInputStreamPrivate with another DataInputStreamPrivate, and returns true if they represent the same GObject.
func (recv *DataInputStreamPrivate) Equals(other *DataInputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DataOutputStreamClass is a wrapper around the C record GDataOutputStreamClass.
type DataOutputStreamClass struct {
	native *C.GDataOutputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func DataOutputStreamClassNewFromC(u unsafe.Pointer) *DataOutputStreamClass {
	c := (*C.GDataOutputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &DataOutputStreamClass{native: c}

	return g
}

func (recv *DataOutputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DataOutputStreamClass with another DataOutputStreamClass, and returns true if they represent the same GObject.
func (recv *DataOutputStreamClass) Equals(other *DataOutputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// DataOutputStreamPrivate is a wrapper around the C record GDataOutputStreamPrivate.
type DataOutputStreamPrivate struct {
	native *C.GDataOutputStreamPrivate
}

func DataOutputStreamPrivateNewFromC(u unsafe.Pointer) *DataOutputStreamPrivate {
	c := (*C.GDataOutputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DataOutputStreamPrivate{native: c}

	return g
}

func (recv *DataOutputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DataOutputStreamPrivate with another DataOutputStreamPrivate, and returns true if they represent the same GObject.
func (recv *DataOutputStreamPrivate) Equals(other *DataOutputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DesktopAppInfoClass is a wrapper around the C record GDesktopAppInfoClass.
type DesktopAppInfoClass struct {
	native *C.GDesktopAppInfoClass
	// parent_class : record
}

func DesktopAppInfoClassNewFromC(u unsafe.Pointer) *DesktopAppInfoClass {
	c := (*C.GDesktopAppInfoClass)(u)
	if c == nil {
		return nil
	}

	g := &DesktopAppInfoClass{native: c}

	return g
}

func (recv *DesktopAppInfoClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DesktopAppInfoClass with another DesktopAppInfoClass, and returns true if they represent the same GObject.
func (recv *DesktopAppInfoClass) Equals(other *DesktopAppInfoClass) bool {
	return other.ToC() == recv.ToC()
}

// DesktopAppInfoLookupIface is a wrapper around the C record GDesktopAppInfoLookupIface.
type DesktopAppInfoLookupIface struct {
	native *C.GDesktopAppInfoLookupIface
	// g_iface : record
	// no type for get_default_for_uri_scheme
}

func DesktopAppInfoLookupIfaceNewFromC(u unsafe.Pointer) *DesktopAppInfoLookupIface {
	c := (*C.GDesktopAppInfoLookupIface)(u)
	if c == nil {
		return nil
	}

	g := &DesktopAppInfoLookupIface{native: c}

	return g
}

func (recv *DesktopAppInfoLookupIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DesktopAppInfoLookupIface with another DesktopAppInfoLookupIface, and returns true if they represent the same GObject.
func (recv *DesktopAppInfoLookupIface) Equals(other *DesktopAppInfoLookupIface) bool {
	return other.ToC() == recv.ToC()
}

// DriveIface is a wrapper around the C record GDriveIface.
type DriveIface struct {
	native *C.GDriveIface
	// g_iface : record
	// no type for changed
	// no type for disconnected
	// no type for eject_button
	// no type for get_name
	// no type for get_icon
	// no type for has_volumes
	// no type for get_volumes
	// no type for is_media_removable
	// no type for has_media
	// no type for is_media_check_automatic
	// no type for can_eject
	// no type for can_poll_for_media
	// no type for eject
	// no type for eject_finish
	// no type for poll_for_media
	// no type for poll_for_media_finish
	// no type for get_identifier
	// no type for enumerate_identifiers
	// no type for get_start_stop_type
	// no type for can_start
	// no type for can_start_degraded
	// no type for start
	// no type for start_finish
	// no type for can_stop
	// no type for stop
	// no type for stop_finish
	// no type for stop_button
	// no type for eject_with_operation
	// no type for eject_with_operation_finish
	// no type for get_sort_key
	// no type for get_symbolic_icon
	// no type for is_removable
}

func DriveIfaceNewFromC(u unsafe.Pointer) *DriveIface {
	c := (*C.GDriveIface)(u)
	if c == nil {
		return nil
	}

	g := &DriveIface{native: c}

	return g
}

func (recv *DriveIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DriveIface with another DriveIface, and returns true if they represent the same GObject.
func (recv *DriveIface) Equals(other *DriveIface) bool {
	return other.ToC() == recv.ToC()
}

// EmblemClass is a wrapper around the C record GEmblemClass.
type EmblemClass struct {
	native *C.GEmblemClass
}

func EmblemClassNewFromC(u unsafe.Pointer) *EmblemClass {
	c := (*C.GEmblemClass)(u)
	if c == nil {
		return nil
	}

	g := &EmblemClass{native: c}

	return g
}

func (recv *EmblemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EmblemClass with another EmblemClass, and returns true if they represent the same GObject.
func (recv *EmblemClass) Equals(other *EmblemClass) bool {
	return other.ToC() == recv.ToC()
}

// EmblemedIconClass is a wrapper around the C record GEmblemedIconClass.
type EmblemedIconClass struct {
	native *C.GEmblemedIconClass
	// parent_class : record
}

func EmblemedIconClassNewFromC(u unsafe.Pointer) *EmblemedIconClass {
	c := (*C.GEmblemedIconClass)(u)
	if c == nil {
		return nil
	}

	g := &EmblemedIconClass{native: c}

	return g
}

func (recv *EmblemedIconClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EmblemedIconClass with another EmblemedIconClass, and returns true if they represent the same GObject.
func (recv *EmblemedIconClass) Equals(other *EmblemedIconClass) bool {
	return other.ToC() == recv.ToC()
}

// EmblemedIconPrivate is a wrapper around the C record GEmblemedIconPrivate.
type EmblemedIconPrivate struct {
	native *C.GEmblemedIconPrivate
}

func EmblemedIconPrivateNewFromC(u unsafe.Pointer) *EmblemedIconPrivate {
	c := (*C.GEmblemedIconPrivate)(u)
	if c == nil {
		return nil
	}

	g := &EmblemedIconPrivate{native: c}

	return g
}

func (recv *EmblemedIconPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EmblemedIconPrivate with another EmblemedIconPrivate, and returns true if they represent the same GObject.
func (recv *EmblemedIconPrivate) Equals(other *EmblemedIconPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileAttributeInfo is a wrapper around the C record GFileAttributeInfo.
type FileAttributeInfo struct {
	native *C.GFileAttributeInfo
	Name   string
	Type   FileAttributeType
	Flags  FileAttributeInfoFlags
}

func FileAttributeInfoNewFromC(u unsafe.Pointer) *FileAttributeInfo {
	c := (*C.GFileAttributeInfo)(u)
	if c == nil {
		return nil
	}

	g := &FileAttributeInfo{
		Flags:  (FileAttributeInfoFlags)(c.flags),
		Name:   C.GoString(c.name),
		Type:   (FileAttributeType)(c._type),
		native: c,
	}

	return g
}

func (recv *FileAttributeInfo) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native._type =
		(C.GFileAttributeType)(recv.Type)
	recv.native.flags =
		(C.GFileAttributeInfoFlags)(recv.Flags)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileAttributeInfo with another FileAttributeInfo, and returns true if they represent the same GObject.
func (recv *FileAttributeInfo) Equals(other *FileAttributeInfo) bool {
	return other.ToC() == recv.ToC()
}

// FileAttributeInfoList is a wrapper around the C record GFileAttributeInfoList.
type FileAttributeInfoList struct {
	native *C.GFileAttributeInfoList
	// infos : record
	NInfos int32
}

func FileAttributeInfoListNewFromC(u unsafe.Pointer) *FileAttributeInfoList {
	c := (*C.GFileAttributeInfoList)(u)
	if c == nil {
		return nil
	}

	g := &FileAttributeInfoList{
		NInfos: (int32)(c.n_infos),
		native: c,
	}

	return g
}

func (recv *FileAttributeInfoList) ToC() unsafe.Pointer {
	recv.native.n_infos =
		(C.int)(recv.NInfos)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileAttributeInfoList with another FileAttributeInfoList, and returns true if they represent the same GObject.
func (recv *FileAttributeInfoList) Equals(other *FileAttributeInfoList) bool {
	return other.ToC() == recv.ToC()
}

// FileAttributeInfoListNew is a wrapper around the C function g_file_attribute_info_list_new.
func FileAttributeInfoListNew() *FileAttributeInfoList {
	retC := C.g_file_attribute_info_list_new()
	retGo := FileAttributeInfoListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Add is a wrapper around the C function g_file_attribute_info_list_add.
func (recv *FileAttributeInfoList) Add(name string, type_ FileAttributeType, flags FileAttributeInfoFlags) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_type := (C.GFileAttributeType)(type_)

	c_flags := (C.GFileAttributeInfoFlags)(flags)

	C.g_file_attribute_info_list_add((*C.GFileAttributeInfoList)(recv.native), c_name, c_type, c_flags)

	return
}

// Dup is a wrapper around the C function g_file_attribute_info_list_dup.
func (recv *FileAttributeInfoList) Dup() *FileAttributeInfoList {
	retC := C.g_file_attribute_info_list_dup((*C.GFileAttributeInfoList)(recv.native))
	retGo := FileAttributeInfoListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Lookup is a wrapper around the C function g_file_attribute_info_list_lookup.
func (recv *FileAttributeInfoList) Lookup(name string) *FileAttributeInfo {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_file_attribute_info_list_lookup((*C.GFileAttributeInfoList)(recv.native), c_name)
	retGo := FileAttributeInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Ref is a wrapper around the C function g_file_attribute_info_list_ref.
func (recv *FileAttributeInfoList) Ref() *FileAttributeInfoList {
	retC := C.g_file_attribute_info_list_ref((*C.GFileAttributeInfoList)(recv.native))
	retGo := FileAttributeInfoListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_file_attribute_info_list_unref.
func (recv *FileAttributeInfoList) Unref() {
	C.g_file_attribute_info_list_unref((*C.GFileAttributeInfoList)(recv.native))

	return
}

// FileAttributeMatcher is a wrapper around the C record GFileAttributeMatcher.
type FileAttributeMatcher struct {
	native *C.GFileAttributeMatcher
}

func FileAttributeMatcherNewFromC(u unsafe.Pointer) *FileAttributeMatcher {
	c := (*C.GFileAttributeMatcher)(u)
	if c == nil {
		return nil
	}

	g := &FileAttributeMatcher{native: c}

	return g
}

func (recv *FileAttributeMatcher) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileAttributeMatcher with another FileAttributeMatcher, and returns true if they represent the same GObject.
func (recv *FileAttributeMatcher) Equals(other *FileAttributeMatcher) bool {
	return other.ToC() == recv.ToC()
}

// FileAttributeMatcherNew is a wrapper around the C function g_file_attribute_matcher_new.
func FileAttributeMatcherNew(attributes string) *FileAttributeMatcher {
	c_attributes := C.CString(attributes)
	defer C.free(unsafe.Pointer(c_attributes))

	retC := C.g_file_attribute_matcher_new(c_attributes)
	retGo := FileAttributeMatcherNewFromC(unsafe.Pointer(retC))

	return retGo
}

// EnumerateNamespace is a wrapper around the C function g_file_attribute_matcher_enumerate_namespace.
func (recv *FileAttributeMatcher) EnumerateNamespace(ns string) bool {
	c_ns := C.CString(ns)
	defer C.free(unsafe.Pointer(c_ns))

	retC := C.g_file_attribute_matcher_enumerate_namespace((*C.GFileAttributeMatcher)(recv.native), c_ns)
	retGo := retC == C.TRUE

	return retGo
}

// EnumerateNext is a wrapper around the C function g_file_attribute_matcher_enumerate_next.
func (recv *FileAttributeMatcher) EnumerateNext() string {
	retC := C.g_file_attribute_matcher_enumerate_next((*C.GFileAttributeMatcher)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Matches is a wrapper around the C function g_file_attribute_matcher_matches.
func (recv *FileAttributeMatcher) Matches(attribute string) bool {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_attribute_matcher_matches((*C.GFileAttributeMatcher)(recv.native), c_attribute)
	retGo := retC == C.TRUE

	return retGo
}

// MatchesOnly is a wrapper around the C function g_file_attribute_matcher_matches_only.
func (recv *FileAttributeMatcher) MatchesOnly(attribute string) bool {
	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	retC := C.g_file_attribute_matcher_matches_only((*C.GFileAttributeMatcher)(recv.native), c_attribute)
	retGo := retC == C.TRUE

	return retGo
}

// Ref is a wrapper around the C function g_file_attribute_matcher_ref.
func (recv *FileAttributeMatcher) Ref() *FileAttributeMatcher {
	retC := C.g_file_attribute_matcher_ref((*C.GFileAttributeMatcher)(recv.native))
	retGo := FileAttributeMatcherNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Subtract is a wrapper around the C function g_file_attribute_matcher_subtract.
func (recv *FileAttributeMatcher) Subtract(subtract *FileAttributeMatcher) *FileAttributeMatcher {
	c_subtract := (*C.GFileAttributeMatcher)(C.NULL)
	if subtract != nil {
		c_subtract = (*C.GFileAttributeMatcher)(subtract.ToC())
	}

	retC := C.g_file_attribute_matcher_subtract((*C.GFileAttributeMatcher)(recv.native), c_subtract)
	retGo := FileAttributeMatcherNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ToString is a wrapper around the C function g_file_attribute_matcher_to_string.
func (recv *FileAttributeMatcher) ToString() string {
	retC := C.g_file_attribute_matcher_to_string((*C.GFileAttributeMatcher)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_file_attribute_matcher_unref.
func (recv *FileAttributeMatcher) Unref() {
	C.g_file_attribute_matcher_unref((*C.GFileAttributeMatcher)(recv.native))

	return
}

// FileDescriptorBasedIface is a wrapper around the C record GFileDescriptorBasedIface.
type FileDescriptorBasedIface struct {
	native *C.GFileDescriptorBasedIface
	// g_iface : record
	// no type for get_fd
}

func FileDescriptorBasedIfaceNewFromC(u unsafe.Pointer) *FileDescriptorBasedIface {
	c := (*C.GFileDescriptorBasedIface)(u)
	if c == nil {
		return nil
	}

	g := &FileDescriptorBasedIface{native: c}

	return g
}

func (recv *FileDescriptorBasedIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileDescriptorBasedIface with another FileDescriptorBasedIface, and returns true if they represent the same GObject.
func (recv *FileDescriptorBasedIface) Equals(other *FileDescriptorBasedIface) bool {
	return other.ToC() == recv.ToC()
}

// FileEnumeratorClass is a wrapper around the C record GFileEnumeratorClass.
type FileEnumeratorClass struct {
	native *C.GFileEnumeratorClass
	// parent_class : record
	// no type for next_file
	// no type for close_fn
	// no type for next_files_async
	// no type for next_files_finish
	// no type for close_async
	// no type for close_finish
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
	// no type for _g_reserved7
}

func FileEnumeratorClassNewFromC(u unsafe.Pointer) *FileEnumeratorClass {
	c := (*C.GFileEnumeratorClass)(u)
	if c == nil {
		return nil
	}

	g := &FileEnumeratorClass{native: c}

	return g
}

func (recv *FileEnumeratorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileEnumeratorClass with another FileEnumeratorClass, and returns true if they represent the same GObject.
func (recv *FileEnumeratorClass) Equals(other *FileEnumeratorClass) bool {
	return other.ToC() == recv.ToC()
}

// FileEnumeratorPrivate is a wrapper around the C record GFileEnumeratorPrivate.
type FileEnumeratorPrivate struct {
	native *C.GFileEnumeratorPrivate
}

func FileEnumeratorPrivateNewFromC(u unsafe.Pointer) *FileEnumeratorPrivate {
	c := (*C.GFileEnumeratorPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FileEnumeratorPrivate{native: c}

	return g
}

func (recv *FileEnumeratorPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileEnumeratorPrivate with another FileEnumeratorPrivate, and returns true if they represent the same GObject.
func (recv *FileEnumeratorPrivate) Equals(other *FileEnumeratorPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileIOStreamClass is a wrapper around the C record GFileIOStreamClass.
type FileIOStreamClass struct {
	native *C.GFileIOStreamClass
	// parent_class : record
	// no type for tell
	// no type for can_seek
	// no type for seek
	// no type for can_truncate
	// no type for truncate_fn
	// no type for query_info
	// no type for query_info_async
	// no type for query_info_finish
	// no type for get_etag
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func FileIOStreamClassNewFromC(u unsafe.Pointer) *FileIOStreamClass {
	c := (*C.GFileIOStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &FileIOStreamClass{native: c}

	return g
}

func (recv *FileIOStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileIOStreamClass with another FileIOStreamClass, and returns true if they represent the same GObject.
func (recv *FileIOStreamClass) Equals(other *FileIOStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// FileIOStreamPrivate is a wrapper around the C record GFileIOStreamPrivate.
type FileIOStreamPrivate struct {
	native *C.GFileIOStreamPrivate
}

func FileIOStreamPrivateNewFromC(u unsafe.Pointer) *FileIOStreamPrivate {
	c := (*C.GFileIOStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FileIOStreamPrivate{native: c}

	return g
}

func (recv *FileIOStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileIOStreamPrivate with another FileIOStreamPrivate, and returns true if they represent the same GObject.
func (recv *FileIOStreamPrivate) Equals(other *FileIOStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileIconClass is a wrapper around the C record GFileIconClass.
type FileIconClass struct {
	native *C.GFileIconClass
}

func FileIconClassNewFromC(u unsafe.Pointer) *FileIconClass {
	c := (*C.GFileIconClass)(u)
	if c == nil {
		return nil
	}

	g := &FileIconClass{native: c}

	return g
}

func (recv *FileIconClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileIconClass with another FileIconClass, and returns true if they represent the same GObject.
func (recv *FileIconClass) Equals(other *FileIconClass) bool {
	return other.ToC() == recv.ToC()
}

// FileIface is a wrapper around the C record GFileIface.
type FileIface struct {
	native *C.GFileIface
	// g_iface : record
	// no type for dup
	// no type for hash
	// no type for equal
	// no type for is_native
	// no type for has_uri_scheme
	// no type for get_uri_scheme
	// no type for get_basename
	// no type for get_path
	// no type for get_uri
	// no type for get_parse_name
	// no type for get_parent
	// no type for prefix_matches
	// no type for get_relative_path
	// no type for resolve_relative_path
	// no type for get_child_for_display_name
	// no type for enumerate_children
	// no type for enumerate_children_async
	// no type for enumerate_children_finish
	// no type for query_info
	// no type for query_info_async
	// no type for query_info_finish
	// no type for query_filesystem_info
	// no type for query_filesystem_info_async
	// no type for query_filesystem_info_finish
	// no type for find_enclosing_mount
	// no type for find_enclosing_mount_async
	// no type for find_enclosing_mount_finish
	// no type for set_display_name
	// no type for set_display_name_async
	// no type for set_display_name_finish
	// no type for query_settable_attributes
	// no type for _query_settable_attributes_async
	// no type for _query_settable_attributes_finish
	// no type for query_writable_namespaces
	// no type for _query_writable_namespaces_async
	// no type for _query_writable_namespaces_finish
	// no type for set_attribute
	// no type for set_attributes_from_info
	// no type for set_attributes_async
	// no type for set_attributes_finish
	// no type for read_fn
	// no type for read_async
	// no type for read_finish
	// no type for append_to
	// no type for append_to_async
	// no type for append_to_finish
	// no type for create
	// no type for create_async
	// no type for create_finish
	// no type for replace
	// no type for replace_async
	// no type for replace_finish
	// no type for delete_file
	// no type for delete_file_async
	// no type for delete_file_finish
	// no type for trash
	// no type for trash_async
	// no type for trash_finish
	// no type for make_directory
	// no type for make_directory_async
	// no type for make_directory_finish
	// no type for make_symbolic_link
	// no type for _make_symbolic_link_async
	// no type for _make_symbolic_link_finish
	// no type for copy
	// no type for copy_async
	// no type for copy_finish
	// no type for move
	// no type for _move_async
	// no type for _move_finish
	// no type for mount_mountable
	// no type for mount_mountable_finish
	// no type for unmount_mountable
	// no type for unmount_mountable_finish
	// no type for eject_mountable
	// no type for eject_mountable_finish
	// no type for mount_enclosing_volume
	// no type for mount_enclosing_volume_finish
	// no type for monitor_dir
	// no type for monitor_file
	// no type for open_readwrite
	// no type for open_readwrite_async
	// no type for open_readwrite_finish
	// no type for create_readwrite
	// no type for create_readwrite_async
	// no type for create_readwrite_finish
	// no type for replace_readwrite
	// no type for replace_readwrite_async
	// no type for replace_readwrite_finish
	// no type for start_mountable
	// no type for start_mountable_finish
	// no type for stop_mountable
	// no type for stop_mountable_finish
	SupportsThreadContexts bool
	// no type for unmount_mountable_with_operation
	// no type for unmount_mountable_with_operation_finish
	// no type for eject_mountable_with_operation
	// no type for eject_mountable_with_operation_finish
	// no type for poll_mountable
	// no type for poll_mountable_finish
	// no type for measure_disk_usage
	// no type for measure_disk_usage_async
	// no type for measure_disk_usage_finish
}

func FileIfaceNewFromC(u unsafe.Pointer) *FileIface {
	c := (*C.GFileIface)(u)
	if c == nil {
		return nil
	}

	g := &FileIface{
		SupportsThreadContexts: c.supports_thread_contexts == C.TRUE,
		native:                 c,
	}

	return g
}

func (recv *FileIface) ToC() unsafe.Pointer {
	recv.native.supports_thread_contexts =
		boolToGboolean(recv.SupportsThreadContexts)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileIface with another FileIface, and returns true if they represent the same GObject.
func (recv *FileIface) Equals(other *FileIface) bool {
	return other.ToC() == recv.ToC()
}

// FileInfoClass is a wrapper around the C record GFileInfoClass.
type FileInfoClass struct {
	native *C.GFileInfoClass
}

func FileInfoClassNewFromC(u unsafe.Pointer) *FileInfoClass {
	c := (*C.GFileInfoClass)(u)
	if c == nil {
		return nil
	}

	g := &FileInfoClass{native: c}

	return g
}

func (recv *FileInfoClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileInfoClass with another FileInfoClass, and returns true if they represent the same GObject.
func (recv *FileInfoClass) Equals(other *FileInfoClass) bool {
	return other.ToC() == recv.ToC()
}

// FileInputStreamClass is a wrapper around the C record GFileInputStreamClass.
type FileInputStreamClass struct {
	native *C.GFileInputStreamClass
	// parent_class : record
	// no type for tell
	// no type for can_seek
	// no type for seek
	// no type for query_info
	// no type for query_info_async
	// no type for query_info_finish
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func FileInputStreamClassNewFromC(u unsafe.Pointer) *FileInputStreamClass {
	c := (*C.GFileInputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &FileInputStreamClass{native: c}

	return g
}

func (recv *FileInputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileInputStreamClass with another FileInputStreamClass, and returns true if they represent the same GObject.
func (recv *FileInputStreamClass) Equals(other *FileInputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// FileInputStreamPrivate is a wrapper around the C record GFileInputStreamPrivate.
type FileInputStreamPrivate struct {
	native *C.GFileInputStreamPrivate
}

func FileInputStreamPrivateNewFromC(u unsafe.Pointer) *FileInputStreamPrivate {
	c := (*C.GFileInputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FileInputStreamPrivate{native: c}

	return g
}

func (recv *FileInputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileInputStreamPrivate with another FileInputStreamPrivate, and returns true if they represent the same GObject.
func (recv *FileInputStreamPrivate) Equals(other *FileInputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileMonitorClass is a wrapper around the C record GFileMonitorClass.
type FileMonitorClass struct {
	native *C.GFileMonitorClass
	// parent_class : record
	// no type for changed
	// no type for cancel
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func FileMonitorClassNewFromC(u unsafe.Pointer) *FileMonitorClass {
	c := (*C.GFileMonitorClass)(u)
	if c == nil {
		return nil
	}

	g := &FileMonitorClass{native: c}

	return g
}

func (recv *FileMonitorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileMonitorClass with another FileMonitorClass, and returns true if they represent the same GObject.
func (recv *FileMonitorClass) Equals(other *FileMonitorClass) bool {
	return other.ToC() == recv.ToC()
}

// FileMonitorPrivate is a wrapper around the C record GFileMonitorPrivate.
type FileMonitorPrivate struct {
	native *C.GFileMonitorPrivate
}

func FileMonitorPrivateNewFromC(u unsafe.Pointer) *FileMonitorPrivate {
	c := (*C.GFileMonitorPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FileMonitorPrivate{native: c}

	return g
}

func (recv *FileMonitorPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileMonitorPrivate with another FileMonitorPrivate, and returns true if they represent the same GObject.
func (recv *FileMonitorPrivate) Equals(other *FileMonitorPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileOutputStreamClass is a wrapper around the C record GFileOutputStreamClass.
type FileOutputStreamClass struct {
	native *C.GFileOutputStreamClass
	// parent_class : record
	// no type for tell
	// no type for can_seek
	// no type for seek
	// no type for can_truncate
	// no type for truncate_fn
	// no type for query_info
	// no type for query_info_async
	// no type for query_info_finish
	// no type for get_etag
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func FileOutputStreamClassNewFromC(u unsafe.Pointer) *FileOutputStreamClass {
	c := (*C.GFileOutputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &FileOutputStreamClass{native: c}

	return g
}

func (recv *FileOutputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileOutputStreamClass with another FileOutputStreamClass, and returns true if they represent the same GObject.
func (recv *FileOutputStreamClass) Equals(other *FileOutputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// FileOutputStreamPrivate is a wrapper around the C record GFileOutputStreamPrivate.
type FileOutputStreamPrivate struct {
	native *C.GFileOutputStreamPrivate
}

func FileOutputStreamPrivateNewFromC(u unsafe.Pointer) *FileOutputStreamPrivate {
	c := (*C.GFileOutputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FileOutputStreamPrivate{native: c}

	return g
}

func (recv *FileOutputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileOutputStreamPrivate with another FileOutputStreamPrivate, and returns true if they represent the same GObject.
func (recv *FileOutputStreamPrivate) Equals(other *FileOutputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FilenameCompleterClass is a wrapper around the C record GFilenameCompleterClass.
type FilenameCompleterClass struct {
	native *C.GFilenameCompleterClass
	// parent_class : record
	// no type for got_completion_data
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
}

func FilenameCompleterClassNewFromC(u unsafe.Pointer) *FilenameCompleterClass {
	c := (*C.GFilenameCompleterClass)(u)
	if c == nil {
		return nil
	}

	g := &FilenameCompleterClass{native: c}

	return g
}

func (recv *FilenameCompleterClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FilenameCompleterClass with another FilenameCompleterClass, and returns true if they represent the same GObject.
func (recv *FilenameCompleterClass) Equals(other *FilenameCompleterClass) bool {
	return other.ToC() == recv.ToC()
}

// FilterInputStreamClass is a wrapper around the C record GFilterInputStreamClass.
type FilterInputStreamClass struct {
	native *C.GFilterInputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
}

func FilterInputStreamClassNewFromC(u unsafe.Pointer) *FilterInputStreamClass {
	c := (*C.GFilterInputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &FilterInputStreamClass{native: c}

	return g
}

func (recv *FilterInputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FilterInputStreamClass with another FilterInputStreamClass, and returns true if they represent the same GObject.
func (recv *FilterInputStreamClass) Equals(other *FilterInputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// FilterOutputStreamClass is a wrapper around the C record GFilterOutputStreamClass.
type FilterOutputStreamClass struct {
	native *C.GFilterOutputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
}

func FilterOutputStreamClassNewFromC(u unsafe.Pointer) *FilterOutputStreamClass {
	c := (*C.GFilterOutputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &FilterOutputStreamClass{native: c}

	return g
}

func (recv *FilterOutputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FilterOutputStreamClass with another FilterOutputStreamClass, and returns true if they represent the same GObject.
func (recv *FilterOutputStreamClass) Equals(other *FilterOutputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// IOExtension is a wrapper around the C record GIOExtension.
type IOExtension struct {
	native *C.GIOExtension
}

func IOExtensionNewFromC(u unsafe.Pointer) *IOExtension {
	c := (*C.GIOExtension)(u)
	if c == nil {
		return nil
	}

	g := &IOExtension{native: c}

	return g
}

func (recv *IOExtension) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOExtension with another IOExtension, and returns true if they represent the same GObject.
func (recv *IOExtension) Equals(other *IOExtension) bool {
	return other.ToC() == recv.ToC()
}

// GetName is a wrapper around the C function g_io_extension_get_name.
func (recv *IOExtension) GetName() string {
	retC := C.g_io_extension_get_name((*C.GIOExtension)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPriority is a wrapper around the C function g_io_extension_get_priority.
func (recv *IOExtension) GetPriority() int32 {
	retC := C.g_io_extension_get_priority((*C.GIOExtension)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetType is a wrapper around the C function g_io_extension_get_type.
func (recv *IOExtension) GetType() gobject.Type {
	retC := C.g_io_extension_get_type((*C.GIOExtension)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// RefClass is a wrapper around the C function g_io_extension_ref_class.
func (recv *IOExtension) RefClass() *gobject.TypeClass {
	retC := C.g_io_extension_ref_class((*C.GIOExtension)(recv.native))
	retGo := gobject.TypeClassNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IOExtensionPoint is a wrapper around the C record GIOExtensionPoint.
type IOExtensionPoint struct {
	native *C.GIOExtensionPoint
}

func IOExtensionPointNewFromC(u unsafe.Pointer) *IOExtensionPoint {
	c := (*C.GIOExtensionPoint)(u)
	if c == nil {
		return nil
	}

	g := &IOExtensionPoint{native: c}

	return g
}

func (recv *IOExtensionPoint) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOExtensionPoint with another IOExtensionPoint, and returns true if they represent the same GObject.
func (recv *IOExtensionPoint) Equals(other *IOExtensionPoint) bool {
	return other.ToC() == recv.ToC()
}

// IOExtensionPointImplement is a wrapper around the C function g_io_extension_point_implement.
func IOExtensionPointImplement(extensionPointName string, type_ gobject.Type, extensionName string, priority int32) *IOExtension {
	c_extension_point_name := C.CString(extensionPointName)
	defer C.free(unsafe.Pointer(c_extension_point_name))

	c_type := (C.GType)(type_)

	c_extension_name := C.CString(extensionName)
	defer C.free(unsafe.Pointer(c_extension_name))

	c_priority := (C.gint)(priority)

	retC := C.g_io_extension_point_implement(c_extension_point_name, c_type, c_extension_name, c_priority)
	retGo := IOExtensionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IOExtensionPointLookup is a wrapper around the C function g_io_extension_point_lookup.
func IOExtensionPointLookup(name string) *IOExtensionPoint {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_io_extension_point_lookup(c_name)
	retGo := IOExtensionPointNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IOExtensionPointRegister is a wrapper around the C function g_io_extension_point_register.
func IOExtensionPointRegister(name string) *IOExtensionPoint {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_io_extension_point_register(c_name)
	retGo := IOExtensionPointNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetExtensionByName is a wrapper around the C function g_io_extension_point_get_extension_by_name.
func (recv *IOExtensionPoint) GetExtensionByName(name string) *IOExtension {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.g_io_extension_point_get_extension_by_name((*C.GIOExtensionPoint)(recv.native), c_name)
	retGo := IOExtensionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetExtensions is a wrapper around the C function g_io_extension_point_get_extensions.
func (recv *IOExtensionPoint) GetExtensions() *glib.List {
	retC := C.g_io_extension_point_get_extensions((*C.GIOExtensionPoint)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetRequiredType is a wrapper around the C function g_io_extension_point_get_required_type.
func (recv *IOExtensionPoint) GetRequiredType() gobject.Type {
	retC := C.g_io_extension_point_get_required_type((*C.GIOExtensionPoint)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// SetRequiredType is a wrapper around the C function g_io_extension_point_set_required_type.
func (recv *IOExtensionPoint) SetRequiredType(type_ gobject.Type) {
	c_type := (C.GType)(type_)

	C.g_io_extension_point_set_required_type((*C.GIOExtensionPoint)(recv.native), c_type)

	return
}

// IOModuleClass is a wrapper around the C record GIOModuleClass.
type IOModuleClass struct {
	native *C.GIOModuleClass
}

func IOModuleClassNewFromC(u unsafe.Pointer) *IOModuleClass {
	c := (*C.GIOModuleClass)(u)
	if c == nil {
		return nil
	}

	g := &IOModuleClass{native: c}

	return g
}

func (recv *IOModuleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOModuleClass with another IOModuleClass, and returns true if they represent the same GObject.
func (recv *IOModuleClass) Equals(other *IOModuleClass) bool {
	return other.ToC() == recv.ToC()
}

// IOModuleScope is a wrapper around the C record GIOModuleScope.
type IOModuleScope struct {
	native *C.GIOModuleScope
}

func IOModuleScopeNewFromC(u unsafe.Pointer) *IOModuleScope {
	c := (*C.GIOModuleScope)(u)
	if c == nil {
		return nil
	}

	g := &IOModuleScope{native: c}

	return g
}

func (recv *IOModuleScope) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOModuleScope with another IOModuleScope, and returns true if they represent the same GObject.
func (recv *IOModuleScope) Equals(other *IOModuleScope) bool {
	return other.ToC() == recv.ToC()
}

// IOModuleScopeNew is a wrapper around the C function g_io_module_scope_new.
func IOModuleScopeNew(flags IOModuleScopeFlags) *IOModuleScope {
	c_flags := (C.GIOModuleScopeFlags)(flags)

	retC := C.g_io_module_scope_new(c_flags)
	retGo := IOModuleScopeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Block is a wrapper around the C function g_io_module_scope_block.
func (recv *IOModuleScope) Block(basename string) {
	c_basename := C.CString(basename)
	defer C.free(unsafe.Pointer(c_basename))

	C.g_io_module_scope_block((*C.GIOModuleScope)(recv.native), c_basename)

	return
}

// Free is a wrapper around the C function g_io_module_scope_free.
func (recv *IOModuleScope) Free() {
	C.g_io_module_scope_free((*C.GIOModuleScope)(recv.native))

	return
}

// IOSchedulerJob is a wrapper around the C record GIOSchedulerJob.
type IOSchedulerJob struct {
	native *C.GIOSchedulerJob
}

func IOSchedulerJobNewFromC(u unsafe.Pointer) *IOSchedulerJob {
	c := (*C.GIOSchedulerJob)(u)
	if c == nil {
		return nil
	}

	g := &IOSchedulerJob{native: c}

	return g
}

func (recv *IOSchedulerJob) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOSchedulerJob with another IOSchedulerJob, and returns true if they represent the same GObject.
func (recv *IOSchedulerJob) Equals(other *IOSchedulerJob) bool {
	return other.ToC() == recv.ToC()
}

// Unsupported : g_io_scheduler_job_send_to_mainloop : unsupported parameter func : no type generator for GLib.SourceFunc (GSourceFunc) for param func

// Unsupported : g_io_scheduler_job_send_to_mainloop_async : unsupported parameter func : no type generator for GLib.SourceFunc (GSourceFunc) for param func

// IOStreamAdapter is a wrapper around the C record GIOStreamAdapter.
type IOStreamAdapter struct {
	native *C.GIOStreamAdapter
}

func IOStreamAdapterNewFromC(u unsafe.Pointer) *IOStreamAdapter {
	c := (*C.GIOStreamAdapter)(u)
	if c == nil {
		return nil
	}

	g := &IOStreamAdapter{native: c}

	return g
}

func (recv *IOStreamAdapter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOStreamAdapter with another IOStreamAdapter, and returns true if they represent the same GObject.
func (recv *IOStreamAdapter) Equals(other *IOStreamAdapter) bool {
	return other.ToC() == recv.ToC()
}

// IOStreamClass is a wrapper around the C record GIOStreamClass.
type IOStreamClass struct {
	native *C.GIOStreamClass
	// parent_class : record
	// no type for get_input_stream
	// no type for get_output_stream
	// no type for close_fn
	// no type for close_async
	// no type for close_finish
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
	// no type for _g_reserved7
	// no type for _g_reserved8
	// no type for _g_reserved9
	// no type for _g_reserved10
}

func IOStreamClassNewFromC(u unsafe.Pointer) *IOStreamClass {
	c := (*C.GIOStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &IOStreamClass{native: c}

	return g
}

func (recv *IOStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOStreamClass with another IOStreamClass, and returns true if they represent the same GObject.
func (recv *IOStreamClass) Equals(other *IOStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// IOStreamPrivate is a wrapper around the C record GIOStreamPrivate.
type IOStreamPrivate struct {
	native *C.GIOStreamPrivate
}

func IOStreamPrivateNewFromC(u unsafe.Pointer) *IOStreamPrivate {
	c := (*C.GIOStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &IOStreamPrivate{native: c}

	return g
}

func (recv *IOStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IOStreamPrivate with another IOStreamPrivate, and returns true if they represent the same GObject.
func (recv *IOStreamPrivate) Equals(other *IOStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// IconIface is a wrapper around the C record GIconIface.
type IconIface struct {
	native *C.GIconIface
	// g_iface : record
	// no type for hash
	// no type for equal
	// no type for to_tokens
	// no type for from_tokens
	// no type for serialize
}

func IconIfaceNewFromC(u unsafe.Pointer) *IconIface {
	c := (*C.GIconIface)(u)
	if c == nil {
		return nil
	}

	g := &IconIface{native: c}

	return g
}

func (recv *IconIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconIface with another IconIface, and returns true if they represent the same GObject.
func (recv *IconIface) Equals(other *IconIface) bool {
	return other.ToC() == recv.ToC()
}

// InetAddressClass is a wrapper around the C record GInetAddressClass.
type InetAddressClass struct {
	native *C.GInetAddressClass
	// parent_class : record
	// no type for to_string
	// no type for to_bytes
}

func InetAddressClassNewFromC(u unsafe.Pointer) *InetAddressClass {
	c := (*C.GInetAddressClass)(u)
	if c == nil {
		return nil
	}

	g := &InetAddressClass{native: c}

	return g
}

func (recv *InetAddressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetAddressClass with another InetAddressClass, and returns true if they represent the same GObject.
func (recv *InetAddressClass) Equals(other *InetAddressClass) bool {
	return other.ToC() == recv.ToC()
}

// InetAddressMaskClass is a wrapper around the C record GInetAddressMaskClass.
type InetAddressMaskClass struct {
	native *C.GInetAddressMaskClass
	// parent_class : record
}

func InetAddressMaskClassNewFromC(u unsafe.Pointer) *InetAddressMaskClass {
	c := (*C.GInetAddressMaskClass)(u)
	if c == nil {
		return nil
	}

	g := &InetAddressMaskClass{native: c}

	return g
}

func (recv *InetAddressMaskClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetAddressMaskClass with another InetAddressMaskClass, and returns true if they represent the same GObject.
func (recv *InetAddressMaskClass) Equals(other *InetAddressMaskClass) bool {
	return other.ToC() == recv.ToC()
}

// InetAddressMaskPrivate is a wrapper around the C record GInetAddressMaskPrivate.
type InetAddressMaskPrivate struct {
	native *C.GInetAddressMaskPrivate
}

func InetAddressMaskPrivateNewFromC(u unsafe.Pointer) *InetAddressMaskPrivate {
	c := (*C.GInetAddressMaskPrivate)(u)
	if c == nil {
		return nil
	}

	g := &InetAddressMaskPrivate{native: c}

	return g
}

func (recv *InetAddressMaskPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetAddressMaskPrivate with another InetAddressMaskPrivate, and returns true if they represent the same GObject.
func (recv *InetAddressMaskPrivate) Equals(other *InetAddressMaskPrivate) bool {
	return other.ToC() == recv.ToC()
}

// InetAddressPrivate is a wrapper around the C record GInetAddressPrivate.
type InetAddressPrivate struct {
	native *C.GInetAddressPrivate
}

func InetAddressPrivateNewFromC(u unsafe.Pointer) *InetAddressPrivate {
	c := (*C.GInetAddressPrivate)(u)
	if c == nil {
		return nil
	}

	g := &InetAddressPrivate{native: c}

	return g
}

func (recv *InetAddressPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetAddressPrivate with another InetAddressPrivate, and returns true if they represent the same GObject.
func (recv *InetAddressPrivate) Equals(other *InetAddressPrivate) bool {
	return other.ToC() == recv.ToC()
}

// InetSocketAddressClass is a wrapper around the C record GInetSocketAddressClass.
type InetSocketAddressClass struct {
	native *C.GInetSocketAddressClass
	// parent_class : record
}

func InetSocketAddressClassNewFromC(u unsafe.Pointer) *InetSocketAddressClass {
	c := (*C.GInetSocketAddressClass)(u)
	if c == nil {
		return nil
	}

	g := &InetSocketAddressClass{native: c}

	return g
}

func (recv *InetSocketAddressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetSocketAddressClass with another InetSocketAddressClass, and returns true if they represent the same GObject.
func (recv *InetSocketAddressClass) Equals(other *InetSocketAddressClass) bool {
	return other.ToC() == recv.ToC()
}

// InetSocketAddressPrivate is a wrapper around the C record GInetSocketAddressPrivate.
type InetSocketAddressPrivate struct {
	native *C.GInetSocketAddressPrivate
}

func InetSocketAddressPrivateNewFromC(u unsafe.Pointer) *InetSocketAddressPrivate {
	c := (*C.GInetSocketAddressPrivate)(u)
	if c == nil {
		return nil
	}

	g := &InetSocketAddressPrivate{native: c}

	return g
}

func (recv *InetSocketAddressPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InetSocketAddressPrivate with another InetSocketAddressPrivate, and returns true if they represent the same GObject.
func (recv *InetSocketAddressPrivate) Equals(other *InetSocketAddressPrivate) bool {
	return other.ToC() == recv.ToC()
}

// InitableIface is a wrapper around the C record GInitableIface.
type InitableIface struct {
	native *C.GInitableIface
	// g_iface : record
	// no type for init
}

func InitableIfaceNewFromC(u unsafe.Pointer) *InitableIface {
	c := (*C.GInitableIface)(u)
	if c == nil {
		return nil
	}

	g := &InitableIface{native: c}

	return g
}

func (recv *InitableIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InitableIface with another InitableIface, and returns true if they represent the same GObject.
func (recv *InitableIface) Equals(other *InitableIface) bool {
	return other.ToC() == recv.ToC()
}

// InputStreamClass is a wrapper around the C record GInputStreamClass.
type InputStreamClass struct {
	native *C.GInputStreamClass
	// parent_class : record
	// no type for read_fn
	// no type for skip
	// no type for close_fn
	// no type for read_async
	// no type for read_finish
	// no type for skip_async
	// no type for skip_finish
	// no type for close_async
	// no type for close_finish
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func InputStreamClassNewFromC(u unsafe.Pointer) *InputStreamClass {
	c := (*C.GInputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &InputStreamClass{native: c}

	return g
}

func (recv *InputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InputStreamClass with another InputStreamClass, and returns true if they represent the same GObject.
func (recv *InputStreamClass) Equals(other *InputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// InputStreamPrivate is a wrapper around the C record GInputStreamPrivate.
type InputStreamPrivate struct {
	native *C.GInputStreamPrivate
}

func InputStreamPrivateNewFromC(u unsafe.Pointer) *InputStreamPrivate {
	c := (*C.GInputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &InputStreamPrivate{native: c}

	return g
}

func (recv *InputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InputStreamPrivate with another InputStreamPrivate, and returns true if they represent the same GObject.
func (recv *InputStreamPrivate) Equals(other *InputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// InputVector is a wrapper around the C record GInputVector.
type InputVector struct {
	native *C.GInputVector
	Buffer uintptr
	Size   uint64
}

func InputVectorNewFromC(u unsafe.Pointer) *InputVector {
	c := (*C.GInputVector)(u)
	if c == nil {
		return nil
	}

	g := &InputVector{
		Buffer: (uintptr)(c.buffer),
		Size:   (uint64)(c.size),
		native: c,
	}

	return g
}

func (recv *InputVector) ToC() unsafe.Pointer {
	recv.native.buffer =
		(C.gpointer)(recv.Buffer)
	recv.native.size =
		(C.gsize)(recv.Size)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InputVector with another InputVector, and returns true if they represent the same GObject.
func (recv *InputVector) Equals(other *InputVector) bool {
	return other.ToC() == recv.ToC()
}

// ListStoreClass is a wrapper around the C record GListStoreClass.
type ListStoreClass struct {
	native *C.GListStoreClass
	// parent_class : record
}

func ListStoreClassNewFromC(u unsafe.Pointer) *ListStoreClass {
	c := (*C.GListStoreClass)(u)
	if c == nil {
		return nil
	}

	g := &ListStoreClass{native: c}

	return g
}

func (recv *ListStoreClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListStoreClass with another ListStoreClass, and returns true if they represent the same GObject.
func (recv *ListStoreClass) Equals(other *ListStoreClass) bool {
	return other.ToC() == recv.ToC()
}

// LoadableIconIface is a wrapper around the C record GLoadableIconIface.
type LoadableIconIface struct {
	native *C.GLoadableIconIface
	// g_iface : record
	// no type for load
	// no type for load_async
	// no type for load_finish
}

func LoadableIconIfaceNewFromC(u unsafe.Pointer) *LoadableIconIface {
	c := (*C.GLoadableIconIface)(u)
	if c == nil {
		return nil
	}

	g := &LoadableIconIface{native: c}

	return g
}

func (recv *LoadableIconIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LoadableIconIface with another LoadableIconIface, and returns true if they represent the same GObject.
func (recv *LoadableIconIface) Equals(other *LoadableIconIface) bool {
	return other.ToC() == recv.ToC()
}

// MemoryInputStreamClass is a wrapper around the C record GMemoryInputStreamClass.
type MemoryInputStreamClass struct {
	native *C.GMemoryInputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func MemoryInputStreamClassNewFromC(u unsafe.Pointer) *MemoryInputStreamClass {
	c := (*C.GMemoryInputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &MemoryInputStreamClass{native: c}

	return g
}

func (recv *MemoryInputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MemoryInputStreamClass with another MemoryInputStreamClass, and returns true if they represent the same GObject.
func (recv *MemoryInputStreamClass) Equals(other *MemoryInputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// MemoryInputStreamPrivate is a wrapper around the C record GMemoryInputStreamPrivate.
type MemoryInputStreamPrivate struct {
	native *C.GMemoryInputStreamPrivate
}

func MemoryInputStreamPrivateNewFromC(u unsafe.Pointer) *MemoryInputStreamPrivate {
	c := (*C.GMemoryInputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MemoryInputStreamPrivate{native: c}

	return g
}

func (recv *MemoryInputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MemoryInputStreamPrivate with another MemoryInputStreamPrivate, and returns true if they represent the same GObject.
func (recv *MemoryInputStreamPrivate) Equals(other *MemoryInputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MemoryOutputStreamClass is a wrapper around the C record GMemoryOutputStreamClass.
type MemoryOutputStreamClass struct {
	native *C.GMemoryOutputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func MemoryOutputStreamClassNewFromC(u unsafe.Pointer) *MemoryOutputStreamClass {
	c := (*C.GMemoryOutputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &MemoryOutputStreamClass{native: c}

	return g
}

func (recv *MemoryOutputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MemoryOutputStreamClass with another MemoryOutputStreamClass, and returns true if they represent the same GObject.
func (recv *MemoryOutputStreamClass) Equals(other *MemoryOutputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// MemoryOutputStreamPrivate is a wrapper around the C record GMemoryOutputStreamPrivate.
type MemoryOutputStreamPrivate struct {
	native *C.GMemoryOutputStreamPrivate
}

func MemoryOutputStreamPrivateNewFromC(u unsafe.Pointer) *MemoryOutputStreamPrivate {
	c := (*C.GMemoryOutputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MemoryOutputStreamPrivate{native: c}

	return g
}

func (recv *MemoryOutputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MemoryOutputStreamPrivate with another MemoryOutputStreamPrivate, and returns true if they represent the same GObject.
func (recv *MemoryOutputStreamPrivate) Equals(other *MemoryOutputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuAttributeIterClass is a wrapper around the C record GMenuAttributeIterClass.
type MenuAttributeIterClass struct {
	native *C.GMenuAttributeIterClass
	// parent_class : record
	// no type for get_next
}

func MenuAttributeIterClassNewFromC(u unsafe.Pointer) *MenuAttributeIterClass {
	c := (*C.GMenuAttributeIterClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuAttributeIterClass{native: c}

	return g
}

func (recv *MenuAttributeIterClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuAttributeIterClass with another MenuAttributeIterClass, and returns true if they represent the same GObject.
func (recv *MenuAttributeIterClass) Equals(other *MenuAttributeIterClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuAttributeIterPrivate is a wrapper around the C record GMenuAttributeIterPrivate.
type MenuAttributeIterPrivate struct {
	native *C.GMenuAttributeIterPrivate
}

func MenuAttributeIterPrivateNewFromC(u unsafe.Pointer) *MenuAttributeIterPrivate {
	c := (*C.GMenuAttributeIterPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuAttributeIterPrivate{native: c}

	return g
}

func (recv *MenuAttributeIterPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuAttributeIterPrivate with another MenuAttributeIterPrivate, and returns true if they represent the same GObject.
func (recv *MenuAttributeIterPrivate) Equals(other *MenuAttributeIterPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuLinkIterClass is a wrapper around the C record GMenuLinkIterClass.
type MenuLinkIterClass struct {
	native *C.GMenuLinkIterClass
	// parent_class : record
	// no type for get_next
}

func MenuLinkIterClassNewFromC(u unsafe.Pointer) *MenuLinkIterClass {
	c := (*C.GMenuLinkIterClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuLinkIterClass{native: c}

	return g
}

func (recv *MenuLinkIterClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuLinkIterClass with another MenuLinkIterClass, and returns true if they represent the same GObject.
func (recv *MenuLinkIterClass) Equals(other *MenuLinkIterClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuLinkIterPrivate is a wrapper around the C record GMenuLinkIterPrivate.
type MenuLinkIterPrivate struct {
	native *C.GMenuLinkIterPrivate
}

func MenuLinkIterPrivateNewFromC(u unsafe.Pointer) *MenuLinkIterPrivate {
	c := (*C.GMenuLinkIterPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuLinkIterPrivate{native: c}

	return g
}

func (recv *MenuLinkIterPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuLinkIterPrivate with another MenuLinkIterPrivate, and returns true if they represent the same GObject.
func (recv *MenuLinkIterPrivate) Equals(other *MenuLinkIterPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuModelClass is a wrapper around the C record GMenuModelClass.
type MenuModelClass struct {
	native *C.GMenuModelClass
	// parent_class : record
	// no type for is_mutable
	// no type for get_n_items
	// no type for get_item_attributes
	// no type for iterate_item_attributes
	// no type for get_item_attribute_value
	// no type for get_item_links
	// no type for iterate_item_links
	// no type for get_item_link
}

func MenuModelClassNewFromC(u unsafe.Pointer) *MenuModelClass {
	c := (*C.GMenuModelClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuModelClass{native: c}

	return g
}

func (recv *MenuModelClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuModelClass with another MenuModelClass, and returns true if they represent the same GObject.
func (recv *MenuModelClass) Equals(other *MenuModelClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuModelPrivate is a wrapper around the C record GMenuModelPrivate.
type MenuModelPrivate struct {
	native *C.GMenuModelPrivate
}

func MenuModelPrivateNewFromC(u unsafe.Pointer) *MenuModelPrivate {
	c := (*C.GMenuModelPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuModelPrivate{native: c}

	return g
}

func (recv *MenuModelPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuModelPrivate with another MenuModelPrivate, and returns true if they represent the same GObject.
func (recv *MenuModelPrivate) Equals(other *MenuModelPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MountIface is a wrapper around the C record GMountIface.
type MountIface struct {
	native *C.GMountIface
	// g_iface : record
	// no type for changed
	// no type for unmounted
	// no type for get_root
	// no type for get_name
	// no type for get_icon
	// no type for get_uuid
	// no type for get_volume
	// no type for get_drive
	// no type for can_unmount
	// no type for can_eject
	// no type for unmount
	// no type for unmount_finish
	// no type for eject
	// no type for eject_finish
	// no type for remount
	// no type for remount_finish
	// no type for guess_content_type
	// no type for guess_content_type_finish
	// no type for guess_content_type_sync
	// no type for pre_unmount
	// no type for unmount_with_operation
	// no type for unmount_with_operation_finish
	// no type for eject_with_operation
	// no type for eject_with_operation_finish
	// no type for get_default_location
	// no type for get_sort_key
	// no type for get_symbolic_icon
}

func MountIfaceNewFromC(u unsafe.Pointer) *MountIface {
	c := (*C.GMountIface)(u)
	if c == nil {
		return nil
	}

	g := &MountIface{native: c}

	return g
}

func (recv *MountIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MountIface with another MountIface, and returns true if they represent the same GObject.
func (recv *MountIface) Equals(other *MountIface) bool {
	return other.ToC() == recv.ToC()
}

// MountOperationClass is a wrapper around the C record GMountOperationClass.
type MountOperationClass struct {
	native *C.GMountOperationClass
	// parent_class : record
	// no type for ask_password
	// no type for ask_question
	// no type for reply
	// no type for aborted
	// no type for show_processes
	// no type for show_unmount_progress
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
	// no type for _g_reserved7
	// no type for _g_reserved8
	// no type for _g_reserved9
}

func MountOperationClassNewFromC(u unsafe.Pointer) *MountOperationClass {
	c := (*C.GMountOperationClass)(u)
	if c == nil {
		return nil
	}

	g := &MountOperationClass{native: c}

	return g
}

func (recv *MountOperationClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MountOperationClass with another MountOperationClass, and returns true if they represent the same GObject.
func (recv *MountOperationClass) Equals(other *MountOperationClass) bool {
	return other.ToC() == recv.ToC()
}

// MountOperationPrivate is a wrapper around the C record GMountOperationPrivate.
type MountOperationPrivate struct {
	native *C.GMountOperationPrivate
}

func MountOperationPrivateNewFromC(u unsafe.Pointer) *MountOperationPrivate {
	c := (*C.GMountOperationPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MountOperationPrivate{native: c}

	return g
}

func (recv *MountOperationPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MountOperationPrivate with another MountOperationPrivate, and returns true if they represent the same GObject.
func (recv *MountOperationPrivate) Equals(other *MountOperationPrivate) bool {
	return other.ToC() == recv.ToC()
}

// NativeSocketAddress is a wrapper around the C record GNativeSocketAddress.
type NativeSocketAddress struct {
	native *C.GNativeSocketAddress
}

func NativeSocketAddressNewFromC(u unsafe.Pointer) *NativeSocketAddress {
	c := (*C.GNativeSocketAddress)(u)
	if c == nil {
		return nil
	}

	g := &NativeSocketAddress{native: c}

	return g
}

func (recv *NativeSocketAddress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NativeSocketAddress with another NativeSocketAddress, and returns true if they represent the same GObject.
func (recv *NativeSocketAddress) Equals(other *NativeSocketAddress) bool {
	return other.ToC() == recv.ToC()
}

// NativeVolumeMonitorClass is a wrapper around the C record GNativeVolumeMonitorClass.
type NativeVolumeMonitorClass struct {
	native *C.GNativeVolumeMonitorClass
	// parent_class : record
	// no type for get_mount_for_mount_path
}

func NativeVolumeMonitorClassNewFromC(u unsafe.Pointer) *NativeVolumeMonitorClass {
	c := (*C.GNativeVolumeMonitorClass)(u)
	if c == nil {
		return nil
	}

	g := &NativeVolumeMonitorClass{native: c}

	return g
}

func (recv *NativeVolumeMonitorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NativeVolumeMonitorClass with another NativeVolumeMonitorClass, and returns true if they represent the same GObject.
func (recv *NativeVolumeMonitorClass) Equals(other *NativeVolumeMonitorClass) bool {
	return other.ToC() == recv.ToC()
}

// NetworkAddressClass is a wrapper around the C record GNetworkAddressClass.
type NetworkAddressClass struct {
	native *C.GNetworkAddressClass
	// parent_class : record
}

func NetworkAddressClassNewFromC(u unsafe.Pointer) *NetworkAddressClass {
	c := (*C.GNetworkAddressClass)(u)
	if c == nil {
		return nil
	}

	g := &NetworkAddressClass{native: c}

	return g
}

func (recv *NetworkAddressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NetworkAddressClass with another NetworkAddressClass, and returns true if they represent the same GObject.
func (recv *NetworkAddressClass) Equals(other *NetworkAddressClass) bool {
	return other.ToC() == recv.ToC()
}

// NetworkAddressPrivate is a wrapper around the C record GNetworkAddressPrivate.
type NetworkAddressPrivate struct {
	native *C.GNetworkAddressPrivate
}

func NetworkAddressPrivateNewFromC(u unsafe.Pointer) *NetworkAddressPrivate {
	c := (*C.GNetworkAddressPrivate)(u)
	if c == nil {
		return nil
	}

	g := &NetworkAddressPrivate{native: c}

	return g
}

func (recv *NetworkAddressPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NetworkAddressPrivate with another NetworkAddressPrivate, and returns true if they represent the same GObject.
func (recv *NetworkAddressPrivate) Equals(other *NetworkAddressPrivate) bool {
	return other.ToC() == recv.ToC()
}

// NetworkMonitorInterface is a wrapper around the C record GNetworkMonitorInterface.
type NetworkMonitorInterface struct {
	native *C.GNetworkMonitorInterface
	// g_iface : record
	// no type for network_changed
	// no type for can_reach
	// no type for can_reach_async
	// no type for can_reach_finish
}

func NetworkMonitorInterfaceNewFromC(u unsafe.Pointer) *NetworkMonitorInterface {
	c := (*C.GNetworkMonitorInterface)(u)
	if c == nil {
		return nil
	}

	g := &NetworkMonitorInterface{native: c}

	return g
}

func (recv *NetworkMonitorInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NetworkMonitorInterface with another NetworkMonitorInterface, and returns true if they represent the same GObject.
func (recv *NetworkMonitorInterface) Equals(other *NetworkMonitorInterface) bool {
	return other.ToC() == recv.ToC()
}

// NetworkServiceClass is a wrapper around the C record GNetworkServiceClass.
type NetworkServiceClass struct {
	native *C.GNetworkServiceClass
	// parent_class : record
}

func NetworkServiceClassNewFromC(u unsafe.Pointer) *NetworkServiceClass {
	c := (*C.GNetworkServiceClass)(u)
	if c == nil {
		return nil
	}

	g := &NetworkServiceClass{native: c}

	return g
}

func (recv *NetworkServiceClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NetworkServiceClass with another NetworkServiceClass, and returns true if they represent the same GObject.
func (recv *NetworkServiceClass) Equals(other *NetworkServiceClass) bool {
	return other.ToC() == recv.ToC()
}

// NetworkServicePrivate is a wrapper around the C record GNetworkServicePrivate.
type NetworkServicePrivate struct {
	native *C.GNetworkServicePrivate
}

func NetworkServicePrivateNewFromC(u unsafe.Pointer) *NetworkServicePrivate {
	c := (*C.GNetworkServicePrivate)(u)
	if c == nil {
		return nil
	}

	g := &NetworkServicePrivate{native: c}

	return g
}

func (recv *NetworkServicePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NetworkServicePrivate with another NetworkServicePrivate, and returns true if they represent the same GObject.
func (recv *NetworkServicePrivate) Equals(other *NetworkServicePrivate) bool {
	return other.ToC() == recv.ToC()
}

// OutputStreamClass is a wrapper around the C record GOutputStreamClass.
type OutputStreamClass struct {
	native *C.GOutputStreamClass
	// parent_class : record
	// no type for write_fn
	// no type for splice
	// no type for flush
	// no type for close_fn
	// no type for write_async
	// no type for write_finish
	// no type for splice_async
	// no type for splice_finish
	// no type for flush_async
	// no type for flush_finish
	// no type for close_async
	// no type for close_finish
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
	// no type for _g_reserved7
	// no type for _g_reserved8
}

func OutputStreamClassNewFromC(u unsafe.Pointer) *OutputStreamClass {
	c := (*C.GOutputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &OutputStreamClass{native: c}

	return g
}

func (recv *OutputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OutputStreamClass with another OutputStreamClass, and returns true if they represent the same GObject.
func (recv *OutputStreamClass) Equals(other *OutputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// OutputStreamPrivate is a wrapper around the C record GOutputStreamPrivate.
type OutputStreamPrivate struct {
	native *C.GOutputStreamPrivate
}

func OutputStreamPrivateNewFromC(u unsafe.Pointer) *OutputStreamPrivate {
	c := (*C.GOutputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &OutputStreamPrivate{native: c}

	return g
}

func (recv *OutputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OutputStreamPrivate with another OutputStreamPrivate, and returns true if they represent the same GObject.
func (recv *OutputStreamPrivate) Equals(other *OutputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// OutputVector is a wrapper around the C record GOutputVector.
type OutputVector struct {
	native *C.GOutputVector
	Buffer uintptr
	Size   uint64
}

func OutputVectorNewFromC(u unsafe.Pointer) *OutputVector {
	c := (*C.GOutputVector)(u)
	if c == nil {
		return nil
	}

	g := &OutputVector{
		Buffer: (uintptr)(c.buffer),
		Size:   (uint64)(c.size),
		native: c,
	}

	return g
}

func (recv *OutputVector) ToC() unsafe.Pointer {
	recv.native.buffer =
		(C.gconstpointer)(recv.Buffer)
	recv.native.size =
		(C.gsize)(recv.Size)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OutputVector with another OutputVector, and returns true if they represent the same GObject.
func (recv *OutputVector) Equals(other *OutputVector) bool {
	return other.ToC() == recv.ToC()
}

// PermissionClass is a wrapper around the C record GPermissionClass.
type PermissionClass struct {
	native *C.GPermissionClass
	// parent_class : record
	// no type for acquire
	// no type for acquire_async
	// no type for acquire_finish
	// no type for release
	// no type for release_async
	// no type for release_finish
	// no type for reserved
}

func PermissionClassNewFromC(u unsafe.Pointer) *PermissionClass {
	c := (*C.GPermissionClass)(u)
	if c == nil {
		return nil
	}

	g := &PermissionClass{native: c}

	return g
}

func (recv *PermissionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PermissionClass with another PermissionClass, and returns true if they represent the same GObject.
func (recv *PermissionClass) Equals(other *PermissionClass) bool {
	return other.ToC() == recv.ToC()
}

// PermissionPrivate is a wrapper around the C record GPermissionPrivate.
type PermissionPrivate struct {
	native *C.GPermissionPrivate
}

func PermissionPrivateNewFromC(u unsafe.Pointer) *PermissionPrivate {
	c := (*C.GPermissionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &PermissionPrivate{native: c}

	return g
}

func (recv *PermissionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PermissionPrivate with another PermissionPrivate, and returns true if they represent the same GObject.
func (recv *PermissionPrivate) Equals(other *PermissionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// PollableInputStreamInterface is a wrapper around the C record GPollableInputStreamInterface.
type PollableInputStreamInterface struct {
	native *C.GPollableInputStreamInterface
	// g_iface : record
	// no type for can_poll
	// no type for is_readable
	// no type for create_source
	// no type for read_nonblocking
}

func PollableInputStreamInterfaceNewFromC(u unsafe.Pointer) *PollableInputStreamInterface {
	c := (*C.GPollableInputStreamInterface)(u)
	if c == nil {
		return nil
	}

	g := &PollableInputStreamInterface{native: c}

	return g
}

func (recv *PollableInputStreamInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PollableInputStreamInterface with another PollableInputStreamInterface, and returns true if they represent the same GObject.
func (recv *PollableInputStreamInterface) Equals(other *PollableInputStreamInterface) bool {
	return other.ToC() == recv.ToC()
}

// PollableOutputStreamInterface is a wrapper around the C record GPollableOutputStreamInterface.
type PollableOutputStreamInterface struct {
	native *C.GPollableOutputStreamInterface
	// g_iface : record
	// no type for can_poll
	// no type for is_writable
	// no type for create_source
	// no type for write_nonblocking
}

func PollableOutputStreamInterfaceNewFromC(u unsafe.Pointer) *PollableOutputStreamInterface {
	c := (*C.GPollableOutputStreamInterface)(u)
	if c == nil {
		return nil
	}

	g := &PollableOutputStreamInterface{native: c}

	return g
}

func (recv *PollableOutputStreamInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PollableOutputStreamInterface with another PollableOutputStreamInterface, and returns true if they represent the same GObject.
func (recv *PollableOutputStreamInterface) Equals(other *PollableOutputStreamInterface) bool {
	return other.ToC() == recv.ToC()
}

// ProxyAddressClass is a wrapper around the C record GProxyAddressClass.
type ProxyAddressClass struct {
	native *C.GProxyAddressClass
	// parent_class : record
}

func ProxyAddressClassNewFromC(u unsafe.Pointer) *ProxyAddressClass {
	c := (*C.GProxyAddressClass)(u)
	if c == nil {
		return nil
	}

	g := &ProxyAddressClass{native: c}

	return g
}

func (recv *ProxyAddressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyAddressClass with another ProxyAddressClass, and returns true if they represent the same GObject.
func (recv *ProxyAddressClass) Equals(other *ProxyAddressClass) bool {
	return other.ToC() == recv.ToC()
}

// ProxyAddressEnumeratorClass is a wrapper around the C record GProxyAddressEnumeratorClass.
type ProxyAddressEnumeratorClass struct {
	native *C.GProxyAddressEnumeratorClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
	// no type for _g_reserved7
}

func ProxyAddressEnumeratorClassNewFromC(u unsafe.Pointer) *ProxyAddressEnumeratorClass {
	c := (*C.GProxyAddressEnumeratorClass)(u)
	if c == nil {
		return nil
	}

	g := &ProxyAddressEnumeratorClass{native: c}

	return g
}

func (recv *ProxyAddressEnumeratorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyAddressEnumeratorClass with another ProxyAddressEnumeratorClass, and returns true if they represent the same GObject.
func (recv *ProxyAddressEnumeratorClass) Equals(other *ProxyAddressEnumeratorClass) bool {
	return other.ToC() == recv.ToC()
}

// ProxyAddressEnumeratorPrivate is a wrapper around the C record GProxyAddressEnumeratorPrivate.
type ProxyAddressEnumeratorPrivate struct {
	native *C.GProxyAddressEnumeratorPrivate
}

func ProxyAddressEnumeratorPrivateNewFromC(u unsafe.Pointer) *ProxyAddressEnumeratorPrivate {
	c := (*C.GProxyAddressEnumeratorPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ProxyAddressEnumeratorPrivate{native: c}

	return g
}

func (recv *ProxyAddressEnumeratorPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyAddressEnumeratorPrivate with another ProxyAddressEnumeratorPrivate, and returns true if they represent the same GObject.
func (recv *ProxyAddressEnumeratorPrivate) Equals(other *ProxyAddressEnumeratorPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ProxyAddressPrivate is a wrapper around the C record GProxyAddressPrivate.
type ProxyAddressPrivate struct {
	native *C.GProxyAddressPrivate
}

func ProxyAddressPrivateNewFromC(u unsafe.Pointer) *ProxyAddressPrivate {
	c := (*C.GProxyAddressPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ProxyAddressPrivate{native: c}

	return g
}

func (recv *ProxyAddressPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyAddressPrivate with another ProxyAddressPrivate, and returns true if they represent the same GObject.
func (recv *ProxyAddressPrivate) Equals(other *ProxyAddressPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ProxyInterface is a wrapper around the C record GProxyInterface.
type ProxyInterface struct {
	native *C.GProxyInterface
	// g_iface : record
	// no type for connect
	// no type for connect_async
	// no type for connect_finish
	// no type for supports_hostname
}

func ProxyInterfaceNewFromC(u unsafe.Pointer) *ProxyInterface {
	c := (*C.GProxyInterface)(u)
	if c == nil {
		return nil
	}

	g := &ProxyInterface{native: c}

	return g
}

func (recv *ProxyInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyInterface with another ProxyInterface, and returns true if they represent the same GObject.
func (recv *ProxyInterface) Equals(other *ProxyInterface) bool {
	return other.ToC() == recv.ToC()
}

// ProxyResolverInterface is a wrapper around the C record GProxyResolverInterface.
type ProxyResolverInterface struct {
	native *C.GProxyResolverInterface
	// g_iface : record
	// no type for is_supported
	// no type for lookup
	// no type for lookup_async
	// no type for lookup_finish
}

func ProxyResolverInterfaceNewFromC(u unsafe.Pointer) *ProxyResolverInterface {
	c := (*C.GProxyResolverInterface)(u)
	if c == nil {
		return nil
	}

	g := &ProxyResolverInterface{native: c}

	return g
}

func (recv *ProxyResolverInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProxyResolverInterface with another ProxyResolverInterface, and returns true if they represent the same GObject.
func (recv *ProxyResolverInterface) Equals(other *ProxyResolverInterface) bool {
	return other.ToC() == recv.ToC()
}

// RemoteActionGroupInterface is a wrapper around the C record GRemoteActionGroupInterface.
type RemoteActionGroupInterface struct {
	native *C.GRemoteActionGroupInterface
	// g_iface : record
	// no type for activate_action_full
	// no type for change_action_state_full
}

func RemoteActionGroupInterfaceNewFromC(u unsafe.Pointer) *RemoteActionGroupInterface {
	c := (*C.GRemoteActionGroupInterface)(u)
	if c == nil {
		return nil
	}

	g := &RemoteActionGroupInterface{native: c}

	return g
}

func (recv *RemoteActionGroupInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RemoteActionGroupInterface with another RemoteActionGroupInterface, and returns true if they represent the same GObject.
func (recv *RemoteActionGroupInterface) Equals(other *RemoteActionGroupInterface) bool {
	return other.ToC() == recv.ToC()
}

// ResolverClass is a wrapper around the C record GResolverClass.
type ResolverClass struct {
	native *C.GResolverClass
	// parent_class : record
	// no type for reload
	// no type for lookup_by_name
	// no type for lookup_by_name_async
	// no type for lookup_by_name_finish
	// no type for lookup_by_address
	// no type for lookup_by_address_async
	// no type for lookup_by_address_finish
	// no type for lookup_service
	// no type for lookup_service_async
	// no type for lookup_service_finish
	// no type for lookup_records
	// no type for lookup_records_async
	// no type for lookup_records_finish
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
}

func ResolverClassNewFromC(u unsafe.Pointer) *ResolverClass {
	c := (*C.GResolverClass)(u)
	if c == nil {
		return nil
	}

	g := &ResolverClass{native: c}

	return g
}

func (recv *ResolverClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ResolverClass with another ResolverClass, and returns true if they represent the same GObject.
func (recv *ResolverClass) Equals(other *ResolverClass) bool {
	return other.ToC() == recv.ToC()
}

// ResolverPrivate is a wrapper around the C record GResolverPrivate.
type ResolverPrivate struct {
	native *C.GResolverPrivate
}

func ResolverPrivateNewFromC(u unsafe.Pointer) *ResolverPrivate {
	c := (*C.GResolverPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ResolverPrivate{native: c}

	return g
}

func (recv *ResolverPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ResolverPrivate with another ResolverPrivate, and returns true if they represent the same GObject.
func (recv *ResolverPrivate) Equals(other *ResolverPrivate) bool {
	return other.ToC() == recv.ToC()
}

// Resource is a wrapper around the C record GResource.
type Resource struct {
	native *C.GResource
}

func ResourceNewFromC(u unsafe.Pointer) *Resource {
	c := (*C.GResource)(u)
	if c == nil {
		return nil
	}

	g := &Resource{native: c}

	return g
}

func (recv *Resource) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Resource with another Resource, and returns true if they represent the same GObject.
func (recv *Resource) Equals(other *Resource) bool {
	return other.ToC() == recv.ToC()
}

// ResourceNewFromData is a wrapper around the C function g_resource_new_from_data.
func ResourceNewFromData(data *glib.Bytes) (*Resource, error) {
	c_data := (*C.GBytes)(C.NULL)
	if data != nil {
		c_data = (*C.GBytes)(data.ToC())
	}

	var cThrowableError *C.GError

	retC := C.g_resource_new_from_data(c_data, &cThrowableError)
	retGo := ResourceNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ResourceLoad is a wrapper around the C function g_resource_load.
func ResourceLoad(filename string) (*Resource, error) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	var cThrowableError *C.GError

	retC := C.g_resource_load(c_filename, &cThrowableError)
	retGo := ResourceNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// EnumerateChildren is a wrapper around the C function g_resource_enumerate_children.
func (recv *Resource) EnumerateChildren(path string, lookupFlags ResourceLookupFlags) ([]string, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_lookup_flags := (C.GResourceLookupFlags)(lookupFlags)

	var cThrowableError *C.GError

	retC := C.g_resource_enumerate_children((*C.GResource)(recv.native), c_path, c_lookup_flags, &cThrowableError)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetInfo is a wrapper around the C function g_resource_get_info.
func (recv *Resource) GetInfo(path string, lookupFlags ResourceLookupFlags) (bool, uint64, uint32, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_lookup_flags := (C.GResourceLookupFlags)(lookupFlags)

	var c_size C.gsize

	var c_flags C.guint32

	var cThrowableError *C.GError

	retC := C.g_resource_get_info((*C.GResource)(recv.native), c_path, c_lookup_flags, &c_size, &c_flags, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	size := (uint64)(c_size)

	flags := (uint32)(c_flags)

	return retGo, size, flags, goError
}

// LookupData is a wrapper around the C function g_resource_lookup_data.
func (recv *Resource) LookupData(path string, lookupFlags ResourceLookupFlags) (*glib.Bytes, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_lookup_flags := (C.GResourceLookupFlags)(lookupFlags)

	var cThrowableError *C.GError

	retC := C.g_resource_lookup_data((*C.GResource)(recv.native), c_path, c_lookup_flags, &cThrowableError)
	retGo := glib.BytesNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// OpenStream is a wrapper around the C function g_resource_open_stream.
func (recv *Resource) OpenStream(path string, lookupFlags ResourceLookupFlags) (*InputStream, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_lookup_flags := (C.GResourceLookupFlags)(lookupFlags)

	var cThrowableError *C.GError

	retC := C.g_resource_open_stream((*C.GResource)(recv.native), c_path, c_lookup_flags, &cThrowableError)
	retGo := InputStreamNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Ref is a wrapper around the C function g_resource_ref.
func (recv *Resource) Ref() *Resource {
	retC := C.g_resource_ref((*C.GResource)(recv.native))
	retGo := ResourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_resource_unref.
func (recv *Resource) Unref() {
	C.g_resource_unref((*C.GResource)(recv.native))

	return
}

// SeekableIface is a wrapper around the C record GSeekableIface.
type SeekableIface struct {
	native *C.GSeekableIface
	// g_iface : record
	// no type for tell
	// no type for can_seek
	// no type for seek
	// no type for can_truncate
	// no type for truncate_fn
}

func SeekableIfaceNewFromC(u unsafe.Pointer) *SeekableIface {
	c := (*C.GSeekableIface)(u)
	if c == nil {
		return nil
	}

	g := &SeekableIface{native: c}

	return g
}

func (recv *SeekableIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeekableIface with another SeekableIface, and returns true if they represent the same GObject.
func (recv *SeekableIface) Equals(other *SeekableIface) bool {
	return other.ToC() == recv.ToC()
}

// Blacklisted : GSettingsBackendClass

// Blacklisted : GSettingsBackendPrivate

// SettingsClass is a wrapper around the C record GSettingsClass.
type SettingsClass struct {
	native *C.GSettingsClass
	// parent_class : record
	// no type for writable_changed
	// no type for changed
	// no type for writable_change_event
	// no type for change_event
	// no type for padding
}

func SettingsClassNewFromC(u unsafe.Pointer) *SettingsClass {
	c := (*C.GSettingsClass)(u)
	if c == nil {
		return nil
	}

	g := &SettingsClass{native: c}

	return g
}

func (recv *SettingsClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsClass with another SettingsClass, and returns true if they represent the same GObject.
func (recv *SettingsClass) Equals(other *SettingsClass) bool {
	return other.ToC() == recv.ToC()
}

// SettingsPrivate is a wrapper around the C record GSettingsPrivate.
type SettingsPrivate struct {
	native *C.GSettingsPrivate
}

func SettingsPrivateNewFromC(u unsafe.Pointer) *SettingsPrivate {
	c := (*C.GSettingsPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SettingsPrivate{native: c}

	return g
}

func (recv *SettingsPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsPrivate with another SettingsPrivate, and returns true if they represent the same GObject.
func (recv *SettingsPrivate) Equals(other *SettingsPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SettingsSchema is a wrapper around the C record GSettingsSchema.
type SettingsSchema struct {
	native *C.GSettingsSchema
}

func SettingsSchemaNewFromC(u unsafe.Pointer) *SettingsSchema {
	c := (*C.GSettingsSchema)(u)
	if c == nil {
		return nil
	}

	g := &SettingsSchema{native: c}

	return g
}

func (recv *SettingsSchema) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsSchema with another SettingsSchema, and returns true if they represent the same GObject.
func (recv *SettingsSchema) Equals(other *SettingsSchema) bool {
	return other.ToC() == recv.ToC()
}

// GetId is a wrapper around the C function g_settings_schema_get_id.
func (recv *SettingsSchema) GetId() string {
	retC := C.g_settings_schema_get_id((*C.GSettingsSchema)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPath is a wrapper around the C function g_settings_schema_get_path.
func (recv *SettingsSchema) GetPath() string {
	retC := C.g_settings_schema_get_path((*C.GSettingsSchema)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Ref is a wrapper around the C function g_settings_schema_ref.
func (recv *SettingsSchema) Ref() *SettingsSchema {
	retC := C.g_settings_schema_ref((*C.GSettingsSchema)(recv.native))
	retGo := SettingsSchemaNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_settings_schema_unref.
func (recv *SettingsSchema) Unref() {
	C.g_settings_schema_unref((*C.GSettingsSchema)(recv.native))

	return
}

// SettingsSchemaKey is a wrapper around the C record GSettingsSchemaKey.
type SettingsSchemaKey struct {
	native *C.GSettingsSchemaKey
}

func SettingsSchemaKeyNewFromC(u unsafe.Pointer) *SettingsSchemaKey {
	c := (*C.GSettingsSchemaKey)(u)
	if c == nil {
		return nil
	}

	g := &SettingsSchemaKey{native: c}

	return g
}

func (recv *SettingsSchemaKey) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsSchemaKey with another SettingsSchemaKey, and returns true if they represent the same GObject.
func (recv *SettingsSchemaKey) Equals(other *SettingsSchemaKey) bool {
	return other.ToC() == recv.ToC()
}

// GetDescription is a wrapper around the C function g_settings_schema_key_get_description.
func (recv *SettingsSchemaKey) GetDescription() string {
	retC := C.g_settings_schema_key_get_description((*C.GSettingsSchemaKey)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetSummary is a wrapper around the C function g_settings_schema_key_get_summary.
func (recv *SettingsSchemaKey) GetSummary() string {
	retC := C.g_settings_schema_key_get_summary((*C.GSettingsSchemaKey)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SettingsSchemaSource is a wrapper around the C record GSettingsSchemaSource.
type SettingsSchemaSource struct {
	native *C.GSettingsSchemaSource
}

func SettingsSchemaSourceNewFromC(u unsafe.Pointer) *SettingsSchemaSource {
	c := (*C.GSettingsSchemaSource)(u)
	if c == nil {
		return nil
	}

	g := &SettingsSchemaSource{native: c}

	return g
}

func (recv *SettingsSchemaSource) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsSchemaSource with another SettingsSchemaSource, and returns true if they represent the same GObject.
func (recv *SettingsSchemaSource) Equals(other *SettingsSchemaSource) bool {
	return other.ToC() == recv.ToC()
}

// SettingsSchemaSourceNewFromDirectory is a wrapper around the C function g_settings_schema_source_new_from_directory.
func SettingsSchemaSourceNewFromDirectory(directory string, parent *SettingsSchemaSource, trusted bool) (*SettingsSchemaSource, error) {
	c_directory := C.CString(directory)
	defer C.free(unsafe.Pointer(c_directory))

	c_parent := (*C.GSettingsSchemaSource)(C.NULL)
	if parent != nil {
		c_parent = (*C.GSettingsSchemaSource)(parent.ToC())
	}

	c_trusted :=
		boolToGboolean(trusted)

	var cThrowableError *C.GError

	retC := C.g_settings_schema_source_new_from_directory(c_directory, c_parent, c_trusted, &cThrowableError)
	retGo := SettingsSchemaSourceNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SettingsSchemaSourceGetDefault is a wrapper around the C function g_settings_schema_source_get_default.
func SettingsSchemaSourceGetDefault() *SettingsSchemaSource {
	retC := C.g_settings_schema_source_get_default()
	var retGo (*SettingsSchemaSource)
	if retC == nil {
		retGo = nil
	} else {
		retGo = SettingsSchemaSourceNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Lookup is a wrapper around the C function g_settings_schema_source_lookup.
func (recv *SettingsSchemaSource) Lookup(schemaId string, recursive bool) *SettingsSchema {
	c_schema_id := C.CString(schemaId)
	defer C.free(unsafe.Pointer(c_schema_id))

	c_recursive :=
		boolToGboolean(recursive)

	retC := C.g_settings_schema_source_lookup((*C.GSettingsSchemaSource)(recv.native), c_schema_id, c_recursive)
	var retGo (*SettingsSchema)
	if retC == nil {
		retGo = nil
	} else {
		retGo = SettingsSchemaNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Ref is a wrapper around the C function g_settings_schema_source_ref.
func (recv *SettingsSchemaSource) Ref() *SettingsSchemaSource {
	retC := C.g_settings_schema_source_ref((*C.GSettingsSchemaSource)(recv.native))
	retGo := SettingsSchemaSourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function g_settings_schema_source_unref.
func (recv *SettingsSchemaSource) Unref() {
	C.g_settings_schema_source_unref((*C.GSettingsSchemaSource)(recv.native))

	return
}

// SimpleActionGroupClass is a wrapper around the C record GSimpleActionGroupClass.
type SimpleActionGroupClass struct {
	native *C.GSimpleActionGroupClass
	// Private : parent_class
	// Private : padding
}

func SimpleActionGroupClassNewFromC(u unsafe.Pointer) *SimpleActionGroupClass {
	c := (*C.GSimpleActionGroupClass)(u)
	if c == nil {
		return nil
	}

	g := &SimpleActionGroupClass{native: c}

	return g
}

func (recv *SimpleActionGroupClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleActionGroupClass with another SimpleActionGroupClass, and returns true if they represent the same GObject.
func (recv *SimpleActionGroupClass) Equals(other *SimpleActionGroupClass) bool {
	return other.ToC() == recv.ToC()
}

// SimpleActionGroupPrivate is a wrapper around the C record GSimpleActionGroupPrivate.
type SimpleActionGroupPrivate struct {
	native *C.GSimpleActionGroupPrivate
}

func SimpleActionGroupPrivateNewFromC(u unsafe.Pointer) *SimpleActionGroupPrivate {
	c := (*C.GSimpleActionGroupPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SimpleActionGroupPrivate{native: c}

	return g
}

func (recv *SimpleActionGroupPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleActionGroupPrivate with another SimpleActionGroupPrivate, and returns true if they represent the same GObject.
func (recv *SimpleActionGroupPrivate) Equals(other *SimpleActionGroupPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SimpleAsyncResultClass is a wrapper around the C record GSimpleAsyncResultClass.
type SimpleAsyncResultClass struct {
	native *C.GSimpleAsyncResultClass
}

func SimpleAsyncResultClassNewFromC(u unsafe.Pointer) *SimpleAsyncResultClass {
	c := (*C.GSimpleAsyncResultClass)(u)
	if c == nil {
		return nil
	}

	g := &SimpleAsyncResultClass{native: c}

	return g
}

func (recv *SimpleAsyncResultClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleAsyncResultClass with another SimpleAsyncResultClass, and returns true if they represent the same GObject.
func (recv *SimpleAsyncResultClass) Equals(other *SimpleAsyncResultClass) bool {
	return other.ToC() == recv.ToC()
}

// SimpleProxyResolverClass is a wrapper around the C record GSimpleProxyResolverClass.
type SimpleProxyResolverClass struct {
	native *C.GSimpleProxyResolverClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func SimpleProxyResolverClassNewFromC(u unsafe.Pointer) *SimpleProxyResolverClass {
	c := (*C.GSimpleProxyResolverClass)(u)
	if c == nil {
		return nil
	}

	g := &SimpleProxyResolverClass{native: c}

	return g
}

func (recv *SimpleProxyResolverClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleProxyResolverClass with another SimpleProxyResolverClass, and returns true if they represent the same GObject.
func (recv *SimpleProxyResolverClass) Equals(other *SimpleProxyResolverClass) bool {
	return other.ToC() == recv.ToC()
}

// SimpleProxyResolverPrivate is a wrapper around the C record GSimpleProxyResolverPrivate.
type SimpleProxyResolverPrivate struct {
	native *C.GSimpleProxyResolverPrivate
}

func SimpleProxyResolverPrivateNewFromC(u unsafe.Pointer) *SimpleProxyResolverPrivate {
	c := (*C.GSimpleProxyResolverPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SimpleProxyResolverPrivate{native: c}

	return g
}

func (recv *SimpleProxyResolverPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SimpleProxyResolverPrivate with another SimpleProxyResolverPrivate, and returns true if they represent the same GObject.
func (recv *SimpleProxyResolverPrivate) Equals(other *SimpleProxyResolverPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SocketAddressClass is a wrapper around the C record GSocketAddressClass.
type SocketAddressClass struct {
	native *C.GSocketAddressClass
	// parent_class : record
	// no type for get_family
	// no type for get_native_size
	// no type for to_native
}

func SocketAddressClassNewFromC(u unsafe.Pointer) *SocketAddressClass {
	c := (*C.GSocketAddressClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketAddressClass{native: c}

	return g
}

func (recv *SocketAddressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketAddressClass with another SocketAddressClass, and returns true if they represent the same GObject.
func (recv *SocketAddressClass) Equals(other *SocketAddressClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketAddressEnumeratorClass is a wrapper around the C record GSocketAddressEnumeratorClass.
type SocketAddressEnumeratorClass struct {
	native *C.GSocketAddressEnumeratorClass
	// parent_class : record
	// no type for next
	// no type for next_async
	// no type for next_finish
}

func SocketAddressEnumeratorClassNewFromC(u unsafe.Pointer) *SocketAddressEnumeratorClass {
	c := (*C.GSocketAddressEnumeratorClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketAddressEnumeratorClass{native: c}

	return g
}

func (recv *SocketAddressEnumeratorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketAddressEnumeratorClass with another SocketAddressEnumeratorClass, and returns true if they represent the same GObject.
func (recv *SocketAddressEnumeratorClass) Equals(other *SocketAddressEnumeratorClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketClass is a wrapper around the C record GSocketClass.
type SocketClass struct {
	native *C.GSocketClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
	// no type for _g_reserved7
	// no type for _g_reserved8
	// no type for _g_reserved9
	// no type for _g_reserved10
}

func SocketClassNewFromC(u unsafe.Pointer) *SocketClass {
	c := (*C.GSocketClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketClass{native: c}

	return g
}

func (recv *SocketClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketClass with another SocketClass, and returns true if they represent the same GObject.
func (recv *SocketClass) Equals(other *SocketClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketClientClass is a wrapper around the C record GSocketClientClass.
type SocketClientClass struct {
	native *C.GSocketClientClass
	// parent_class : record
	// no type for event
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
}

func SocketClientClassNewFromC(u unsafe.Pointer) *SocketClientClass {
	c := (*C.GSocketClientClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketClientClass{native: c}

	return g
}

func (recv *SocketClientClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketClientClass with another SocketClientClass, and returns true if they represent the same GObject.
func (recv *SocketClientClass) Equals(other *SocketClientClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketClientPrivate is a wrapper around the C record GSocketClientPrivate.
type SocketClientPrivate struct {
	native *C.GSocketClientPrivate
}

func SocketClientPrivateNewFromC(u unsafe.Pointer) *SocketClientPrivate {
	c := (*C.GSocketClientPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SocketClientPrivate{native: c}

	return g
}

func (recv *SocketClientPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketClientPrivate with another SocketClientPrivate, and returns true if they represent the same GObject.
func (recv *SocketClientPrivate) Equals(other *SocketClientPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SocketConnectableIface is a wrapper around the C record GSocketConnectableIface.
type SocketConnectableIface struct {
	native *C.GSocketConnectableIface
	// g_iface : record
	// no type for enumerate
	// no type for proxy_enumerate
	// no type for to_string
}

func SocketConnectableIfaceNewFromC(u unsafe.Pointer) *SocketConnectableIface {
	c := (*C.GSocketConnectableIface)(u)
	if c == nil {
		return nil
	}

	g := &SocketConnectableIface{native: c}

	return g
}

func (recv *SocketConnectableIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketConnectableIface with another SocketConnectableIface, and returns true if they represent the same GObject.
func (recv *SocketConnectableIface) Equals(other *SocketConnectableIface) bool {
	return other.ToC() == recv.ToC()
}

// SocketConnectionClass is a wrapper around the C record GSocketConnectionClass.
type SocketConnectionClass struct {
	native *C.GSocketConnectionClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
}

func SocketConnectionClassNewFromC(u unsafe.Pointer) *SocketConnectionClass {
	c := (*C.GSocketConnectionClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketConnectionClass{native: c}

	return g
}

func (recv *SocketConnectionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketConnectionClass with another SocketConnectionClass, and returns true if they represent the same GObject.
func (recv *SocketConnectionClass) Equals(other *SocketConnectionClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketConnectionPrivate is a wrapper around the C record GSocketConnectionPrivate.
type SocketConnectionPrivate struct {
	native *C.GSocketConnectionPrivate
}

func SocketConnectionPrivateNewFromC(u unsafe.Pointer) *SocketConnectionPrivate {
	c := (*C.GSocketConnectionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SocketConnectionPrivate{native: c}

	return g
}

func (recv *SocketConnectionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketConnectionPrivate with another SocketConnectionPrivate, and returns true if they represent the same GObject.
func (recv *SocketConnectionPrivate) Equals(other *SocketConnectionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SocketControlMessageClass is a wrapper around the C record GSocketControlMessageClass.
type SocketControlMessageClass struct {
	native *C.GSocketControlMessageClass
	// parent_class : record
	// no type for get_size
	// no type for get_level
	// no type for get_type
	// no type for serialize
	// no type for deserialize
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func SocketControlMessageClassNewFromC(u unsafe.Pointer) *SocketControlMessageClass {
	c := (*C.GSocketControlMessageClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketControlMessageClass{native: c}

	return g
}

func (recv *SocketControlMessageClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketControlMessageClass with another SocketControlMessageClass, and returns true if they represent the same GObject.
func (recv *SocketControlMessageClass) Equals(other *SocketControlMessageClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketControlMessagePrivate is a wrapper around the C record GSocketControlMessagePrivate.
type SocketControlMessagePrivate struct {
	native *C.GSocketControlMessagePrivate
}

func SocketControlMessagePrivateNewFromC(u unsafe.Pointer) *SocketControlMessagePrivate {
	c := (*C.GSocketControlMessagePrivate)(u)
	if c == nil {
		return nil
	}

	g := &SocketControlMessagePrivate{native: c}

	return g
}

func (recv *SocketControlMessagePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketControlMessagePrivate with another SocketControlMessagePrivate, and returns true if they represent the same GObject.
func (recv *SocketControlMessagePrivate) Equals(other *SocketControlMessagePrivate) bool {
	return other.ToC() == recv.ToC()
}

// SocketListenerClass is a wrapper around the C record GSocketListenerClass.
type SocketListenerClass struct {
	native *C.GSocketListenerClass
	// parent_class : record
	// no type for changed
	// no type for event
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
}

func SocketListenerClassNewFromC(u unsafe.Pointer) *SocketListenerClass {
	c := (*C.GSocketListenerClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketListenerClass{native: c}

	return g
}

func (recv *SocketListenerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketListenerClass with another SocketListenerClass, and returns true if they represent the same GObject.
func (recv *SocketListenerClass) Equals(other *SocketListenerClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketListenerPrivate is a wrapper around the C record GSocketListenerPrivate.
type SocketListenerPrivate struct {
	native *C.GSocketListenerPrivate
}

func SocketListenerPrivateNewFromC(u unsafe.Pointer) *SocketListenerPrivate {
	c := (*C.GSocketListenerPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SocketListenerPrivate{native: c}

	return g
}

func (recv *SocketListenerPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketListenerPrivate with another SocketListenerPrivate, and returns true if they represent the same GObject.
func (recv *SocketListenerPrivate) Equals(other *SocketListenerPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SocketPrivate is a wrapper around the C record GSocketPrivate.
type SocketPrivate struct {
	native *C.GSocketPrivate
}

func SocketPrivateNewFromC(u unsafe.Pointer) *SocketPrivate {
	c := (*C.GSocketPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SocketPrivate{native: c}

	return g
}

func (recv *SocketPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketPrivate with another SocketPrivate, and returns true if they represent the same GObject.
func (recv *SocketPrivate) Equals(other *SocketPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SocketServiceClass is a wrapper around the C record GSocketServiceClass.
type SocketServiceClass struct {
	native *C.GSocketServiceClass
	// parent_class : record
	// no type for incoming
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
}

func SocketServiceClassNewFromC(u unsafe.Pointer) *SocketServiceClass {
	c := (*C.GSocketServiceClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketServiceClass{native: c}

	return g
}

func (recv *SocketServiceClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketServiceClass with another SocketServiceClass, and returns true if they represent the same GObject.
func (recv *SocketServiceClass) Equals(other *SocketServiceClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketServicePrivate is a wrapper around the C record GSocketServicePrivate.
type SocketServicePrivate struct {
	native *C.GSocketServicePrivate
}

func SocketServicePrivateNewFromC(u unsafe.Pointer) *SocketServicePrivate {
	c := (*C.GSocketServicePrivate)(u)
	if c == nil {
		return nil
	}

	g := &SocketServicePrivate{native: c}

	return g
}

func (recv *SocketServicePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketServicePrivate with another SocketServicePrivate, and returns true if they represent the same GObject.
func (recv *SocketServicePrivate) Equals(other *SocketServicePrivate) bool {
	return other.ToC() == recv.ToC()
}

// SrvTarget is a wrapper around the C record GSrvTarget.
type SrvTarget struct {
	native *C.GSrvTarget
}

func SrvTargetNewFromC(u unsafe.Pointer) *SrvTarget {
	c := (*C.GSrvTarget)(u)
	if c == nil {
		return nil
	}

	g := &SrvTarget{native: c}

	return g
}

func (recv *SrvTarget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SrvTarget with another SrvTarget, and returns true if they represent the same GObject.
func (recv *SrvTarget) Equals(other *SrvTarget) bool {
	return other.ToC() == recv.ToC()
}

// SrvTargetNew is a wrapper around the C function g_srv_target_new.
func SrvTargetNew(hostname string, port uint16, priority uint16, weight uint16) *SrvTarget {
	c_hostname := C.CString(hostname)
	defer C.free(unsafe.Pointer(c_hostname))

	c_port := (C.guint16)(port)

	c_priority := (C.guint16)(priority)

	c_weight := (C.guint16)(weight)

	retC := C.g_srv_target_new(c_hostname, c_port, c_priority, c_weight)
	retGo := SrvTargetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SrvTargetListSort is a wrapper around the C function g_srv_target_list_sort.
func SrvTargetListSort(targets *glib.List) *glib.List {
	c_targets := (*C.GList)(C.NULL)
	if targets != nil {
		c_targets = (*C.GList)(targets.ToC())
	}

	retC := C.g_srv_target_list_sort(c_targets)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Copy is a wrapper around the C function g_srv_target_copy.
func (recv *SrvTarget) Copy() *SrvTarget {
	retC := C.g_srv_target_copy((*C.GSrvTarget)(recv.native))
	retGo := SrvTargetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function g_srv_target_free.
func (recv *SrvTarget) Free() {
	C.g_srv_target_free((*C.GSrvTarget)(recv.native))

	return
}

// GetHostname is a wrapper around the C function g_srv_target_get_hostname.
func (recv *SrvTarget) GetHostname() string {
	retC := C.g_srv_target_get_hostname((*C.GSrvTarget)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPort is a wrapper around the C function g_srv_target_get_port.
func (recv *SrvTarget) GetPort() uint16 {
	retC := C.g_srv_target_get_port((*C.GSrvTarget)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// GetPriority is a wrapper around the C function g_srv_target_get_priority.
func (recv *SrvTarget) GetPriority() uint16 {
	retC := C.g_srv_target_get_priority((*C.GSrvTarget)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// GetWeight is a wrapper around the C function g_srv_target_get_weight.
func (recv *SrvTarget) GetWeight() uint16 {
	retC := C.g_srv_target_get_weight((*C.GSrvTarget)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// StaticResource is a wrapper around the C record GStaticResource.
type StaticResource struct {
	native *C.GStaticResource
	// Private : data
	// Private : data_len
	// Private : resource
	// Private : next
	// Private : padding
}

func StaticResourceNewFromC(u unsafe.Pointer) *StaticResource {
	c := (*C.GStaticResource)(u)
	if c == nil {
		return nil
	}

	g := &StaticResource{native: c}

	return g
}

func (recv *StaticResource) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StaticResource with another StaticResource, and returns true if they represent the same GObject.
func (recv *StaticResource) Equals(other *StaticResource) bool {
	return other.ToC() == recv.ToC()
}

// Fini is a wrapper around the C function g_static_resource_fini.
func (recv *StaticResource) Fini() {
	C.g_static_resource_fini((*C.GStaticResource)(recv.native))

	return
}

// GetResource is a wrapper around the C function g_static_resource_get_resource.
func (recv *StaticResource) GetResource() *Resource {
	retC := C.g_static_resource_get_resource((*C.GStaticResource)(recv.native))
	retGo := ResourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Init is a wrapper around the C function g_static_resource_init.
func (recv *StaticResource) Init() {
	C.g_static_resource_init((*C.GStaticResource)(recv.native))

	return
}

// TaskClass is a wrapper around the C record GTaskClass.
type TaskClass struct {
	native *C.GTaskClass
}

func TaskClassNewFromC(u unsafe.Pointer) *TaskClass {
	c := (*C.GTaskClass)(u)
	if c == nil {
		return nil
	}

	g := &TaskClass{native: c}

	return g
}

func (recv *TaskClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TaskClass with another TaskClass, and returns true if they represent the same GObject.
func (recv *TaskClass) Equals(other *TaskClass) bool {
	return other.ToC() == recv.ToC()
}

// TcpConnectionClass is a wrapper around the C record GTcpConnectionClass.
type TcpConnectionClass struct {
	native *C.GTcpConnectionClass
	// parent_class : record
}

func TcpConnectionClassNewFromC(u unsafe.Pointer) *TcpConnectionClass {
	c := (*C.GTcpConnectionClass)(u)
	if c == nil {
		return nil
	}

	g := &TcpConnectionClass{native: c}

	return g
}

func (recv *TcpConnectionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TcpConnectionClass with another TcpConnectionClass, and returns true if they represent the same GObject.
func (recv *TcpConnectionClass) Equals(other *TcpConnectionClass) bool {
	return other.ToC() == recv.ToC()
}

// TcpConnectionPrivate is a wrapper around the C record GTcpConnectionPrivate.
type TcpConnectionPrivate struct {
	native *C.GTcpConnectionPrivate
}

func TcpConnectionPrivateNewFromC(u unsafe.Pointer) *TcpConnectionPrivate {
	c := (*C.GTcpConnectionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TcpConnectionPrivate{native: c}

	return g
}

func (recv *TcpConnectionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TcpConnectionPrivate with another TcpConnectionPrivate, and returns true if they represent the same GObject.
func (recv *TcpConnectionPrivate) Equals(other *TcpConnectionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TcpWrapperConnectionClass is a wrapper around the C record GTcpWrapperConnectionClass.
type TcpWrapperConnectionClass struct {
	native *C.GTcpWrapperConnectionClass
	// parent_class : record
}

func TcpWrapperConnectionClassNewFromC(u unsafe.Pointer) *TcpWrapperConnectionClass {
	c := (*C.GTcpWrapperConnectionClass)(u)
	if c == nil {
		return nil
	}

	g := &TcpWrapperConnectionClass{native: c}

	return g
}

func (recv *TcpWrapperConnectionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TcpWrapperConnectionClass with another TcpWrapperConnectionClass, and returns true if they represent the same GObject.
func (recv *TcpWrapperConnectionClass) Equals(other *TcpWrapperConnectionClass) bool {
	return other.ToC() == recv.ToC()
}

// TcpWrapperConnectionPrivate is a wrapper around the C record GTcpWrapperConnectionPrivate.
type TcpWrapperConnectionPrivate struct {
	native *C.GTcpWrapperConnectionPrivate
}

func TcpWrapperConnectionPrivateNewFromC(u unsafe.Pointer) *TcpWrapperConnectionPrivate {
	c := (*C.GTcpWrapperConnectionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TcpWrapperConnectionPrivate{native: c}

	return g
}

func (recv *TcpWrapperConnectionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TcpWrapperConnectionPrivate with another TcpWrapperConnectionPrivate, and returns true if they represent the same GObject.
func (recv *TcpWrapperConnectionPrivate) Equals(other *TcpWrapperConnectionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ThemedIconClass is a wrapper around the C record GThemedIconClass.
type ThemedIconClass struct {
	native *C.GThemedIconClass
}

func ThemedIconClassNewFromC(u unsafe.Pointer) *ThemedIconClass {
	c := (*C.GThemedIconClass)(u)
	if c == nil {
		return nil
	}

	g := &ThemedIconClass{native: c}

	return g
}

func (recv *ThemedIconClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThemedIconClass with another ThemedIconClass, and returns true if they represent the same GObject.
func (recv *ThemedIconClass) Equals(other *ThemedIconClass) bool {
	return other.ToC() == recv.ToC()
}

// ThreadedSocketServiceClass is a wrapper around the C record GThreadedSocketServiceClass.
type ThreadedSocketServiceClass struct {
	native *C.GThreadedSocketServiceClass
	// parent_class : record
	// no type for run
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func ThreadedSocketServiceClassNewFromC(u unsafe.Pointer) *ThreadedSocketServiceClass {
	c := (*C.GThreadedSocketServiceClass)(u)
	if c == nil {
		return nil
	}

	g := &ThreadedSocketServiceClass{native: c}

	return g
}

func (recv *ThreadedSocketServiceClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThreadedSocketServiceClass with another ThreadedSocketServiceClass, and returns true if they represent the same GObject.
func (recv *ThreadedSocketServiceClass) Equals(other *ThreadedSocketServiceClass) bool {
	return other.ToC() == recv.ToC()
}

// ThreadedSocketServicePrivate is a wrapper around the C record GThreadedSocketServicePrivate.
type ThreadedSocketServicePrivate struct {
	native *C.GThreadedSocketServicePrivate
}

func ThreadedSocketServicePrivateNewFromC(u unsafe.Pointer) *ThreadedSocketServicePrivate {
	c := (*C.GThreadedSocketServicePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ThreadedSocketServicePrivate{native: c}

	return g
}

func (recv *ThreadedSocketServicePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThreadedSocketServicePrivate with another ThreadedSocketServicePrivate, and returns true if they represent the same GObject.
func (recv *ThreadedSocketServicePrivate) Equals(other *ThreadedSocketServicePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TlsBackendInterface is a wrapper around the C record GTlsBackendInterface.
type TlsBackendInterface struct {
	native *C.GTlsBackendInterface
	// g_iface : record
	// no type for supports_tls
	// no type for get_certificate_type
	// no type for get_client_connection_type
	// no type for get_server_connection_type
	// no type for get_file_database_type
	// no type for get_default_database
	// no type for supports_dtls
	// no type for get_dtls_client_connection_type
	// no type for get_dtls_server_connection_type
}

func TlsBackendInterfaceNewFromC(u unsafe.Pointer) *TlsBackendInterface {
	c := (*C.GTlsBackendInterface)(u)
	if c == nil {
		return nil
	}

	g := &TlsBackendInterface{native: c}

	return g
}

func (recv *TlsBackendInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsBackendInterface with another TlsBackendInterface, and returns true if they represent the same GObject.
func (recv *TlsBackendInterface) Equals(other *TlsBackendInterface) bool {
	return other.ToC() == recv.ToC()
}

// TlsCertificateClass is a wrapper around the C record GTlsCertificateClass.
type TlsCertificateClass struct {
	native *C.GTlsCertificateClass
	// parent_class : record
	// no type for verify
	// Private : padding
}

func TlsCertificateClassNewFromC(u unsafe.Pointer) *TlsCertificateClass {
	c := (*C.GTlsCertificateClass)(u)
	if c == nil {
		return nil
	}

	g := &TlsCertificateClass{native: c}

	return g
}

func (recv *TlsCertificateClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsCertificateClass with another TlsCertificateClass, and returns true if they represent the same GObject.
func (recv *TlsCertificateClass) Equals(other *TlsCertificateClass) bool {
	return other.ToC() == recv.ToC()
}

// TlsCertificatePrivate is a wrapper around the C record GTlsCertificatePrivate.
type TlsCertificatePrivate struct {
	native *C.GTlsCertificatePrivate
}

func TlsCertificatePrivateNewFromC(u unsafe.Pointer) *TlsCertificatePrivate {
	c := (*C.GTlsCertificatePrivate)(u)
	if c == nil {
		return nil
	}

	g := &TlsCertificatePrivate{native: c}

	return g
}

func (recv *TlsCertificatePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsCertificatePrivate with another TlsCertificatePrivate, and returns true if they represent the same GObject.
func (recv *TlsCertificatePrivate) Equals(other *TlsCertificatePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TlsClientConnectionInterface is a wrapper around the C record GTlsClientConnectionInterface.
type TlsClientConnectionInterface struct {
	native *C.GTlsClientConnectionInterface
	// g_iface : record
	// no type for copy_session_state
}

func TlsClientConnectionInterfaceNewFromC(u unsafe.Pointer) *TlsClientConnectionInterface {
	c := (*C.GTlsClientConnectionInterface)(u)
	if c == nil {
		return nil
	}

	g := &TlsClientConnectionInterface{native: c}

	return g
}

func (recv *TlsClientConnectionInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsClientConnectionInterface with another TlsClientConnectionInterface, and returns true if they represent the same GObject.
func (recv *TlsClientConnectionInterface) Equals(other *TlsClientConnectionInterface) bool {
	return other.ToC() == recv.ToC()
}

// TlsConnectionClass is a wrapper around the C record GTlsConnectionClass.
type TlsConnectionClass struct {
	native *C.GTlsConnectionClass
	// parent_class : record
	// no type for accept_certificate
	// no type for handshake
	// no type for handshake_async
	// no type for handshake_finish
	// Private : padding
}

func TlsConnectionClassNewFromC(u unsafe.Pointer) *TlsConnectionClass {
	c := (*C.GTlsConnectionClass)(u)
	if c == nil {
		return nil
	}

	g := &TlsConnectionClass{native: c}

	return g
}

func (recv *TlsConnectionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsConnectionClass with another TlsConnectionClass, and returns true if they represent the same GObject.
func (recv *TlsConnectionClass) Equals(other *TlsConnectionClass) bool {
	return other.ToC() == recv.ToC()
}

// TlsConnectionPrivate is a wrapper around the C record GTlsConnectionPrivate.
type TlsConnectionPrivate struct {
	native *C.GTlsConnectionPrivate
}

func TlsConnectionPrivateNewFromC(u unsafe.Pointer) *TlsConnectionPrivate {
	c := (*C.GTlsConnectionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TlsConnectionPrivate{native: c}

	return g
}

func (recv *TlsConnectionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsConnectionPrivate with another TlsConnectionPrivate, and returns true if they represent the same GObject.
func (recv *TlsConnectionPrivate) Equals(other *TlsConnectionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TlsDatabaseClass is a wrapper around the C record GTlsDatabaseClass.
type TlsDatabaseClass struct {
	native *C.GTlsDatabaseClass
	// parent_class : record
	// no type for verify_chain
	// no type for verify_chain_async
	// no type for verify_chain_finish
	// no type for create_certificate_handle
	// no type for lookup_certificate_for_handle
	// no type for lookup_certificate_for_handle_async
	// no type for lookup_certificate_for_handle_finish
	// no type for lookup_certificate_issuer
	// no type for lookup_certificate_issuer_async
	// no type for lookup_certificate_issuer_finish
	// no type for lookup_certificates_issued_by
	// no type for lookup_certificates_issued_by_async
	// no type for lookup_certificates_issued_by_finish
	// Private : padding
}

func TlsDatabaseClassNewFromC(u unsafe.Pointer) *TlsDatabaseClass {
	c := (*C.GTlsDatabaseClass)(u)
	if c == nil {
		return nil
	}

	g := &TlsDatabaseClass{native: c}

	return g
}

func (recv *TlsDatabaseClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsDatabaseClass with another TlsDatabaseClass, and returns true if they represent the same GObject.
func (recv *TlsDatabaseClass) Equals(other *TlsDatabaseClass) bool {
	return other.ToC() == recv.ToC()
}

// TlsDatabasePrivate is a wrapper around the C record GTlsDatabasePrivate.
type TlsDatabasePrivate struct {
	native *C.GTlsDatabasePrivate
}

func TlsDatabasePrivateNewFromC(u unsafe.Pointer) *TlsDatabasePrivate {
	c := (*C.GTlsDatabasePrivate)(u)
	if c == nil {
		return nil
	}

	g := &TlsDatabasePrivate{native: c}

	return g
}

func (recv *TlsDatabasePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsDatabasePrivate with another TlsDatabasePrivate, and returns true if they represent the same GObject.
func (recv *TlsDatabasePrivate) Equals(other *TlsDatabasePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TlsFileDatabaseInterface is a wrapper around the C record GTlsFileDatabaseInterface.
type TlsFileDatabaseInterface struct {
	native *C.GTlsFileDatabaseInterface
	// g_iface : record
	// Private : padding
}

func TlsFileDatabaseInterfaceNewFromC(u unsafe.Pointer) *TlsFileDatabaseInterface {
	c := (*C.GTlsFileDatabaseInterface)(u)
	if c == nil {
		return nil
	}

	g := &TlsFileDatabaseInterface{native: c}

	return g
}

func (recv *TlsFileDatabaseInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsFileDatabaseInterface with another TlsFileDatabaseInterface, and returns true if they represent the same GObject.
func (recv *TlsFileDatabaseInterface) Equals(other *TlsFileDatabaseInterface) bool {
	return other.ToC() == recv.ToC()
}

// TlsInteractionClass is a wrapper around the C record GTlsInteractionClass.
type TlsInteractionClass struct {
	native *C.GTlsInteractionClass
	// Private : parent_class
	// no type for ask_password
	// no type for ask_password_async
	// no type for ask_password_finish
	// no type for request_certificate
	// no type for request_certificate_async
	// no type for request_certificate_finish
	// Private : padding
}

func TlsInteractionClassNewFromC(u unsafe.Pointer) *TlsInteractionClass {
	c := (*C.GTlsInteractionClass)(u)
	if c == nil {
		return nil
	}

	g := &TlsInteractionClass{native: c}

	return g
}

func (recv *TlsInteractionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsInteractionClass with another TlsInteractionClass, and returns true if they represent the same GObject.
func (recv *TlsInteractionClass) Equals(other *TlsInteractionClass) bool {
	return other.ToC() == recv.ToC()
}

// TlsInteractionPrivate is a wrapper around the C record GTlsInteractionPrivate.
type TlsInteractionPrivate struct {
	native *C.GTlsInteractionPrivate
}

func TlsInteractionPrivateNewFromC(u unsafe.Pointer) *TlsInteractionPrivate {
	c := (*C.GTlsInteractionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TlsInteractionPrivate{native: c}

	return g
}

func (recv *TlsInteractionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsInteractionPrivate with another TlsInteractionPrivate, and returns true if they represent the same GObject.
func (recv *TlsInteractionPrivate) Equals(other *TlsInteractionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TlsPasswordClass is a wrapper around the C record GTlsPasswordClass.
type TlsPasswordClass struct {
	native *C.GTlsPasswordClass
	// parent_class : record
	// no type for get_value
	// no type for set_value
	// no type for get_default_warning
	// Private : padding
}

func TlsPasswordClassNewFromC(u unsafe.Pointer) *TlsPasswordClass {
	c := (*C.GTlsPasswordClass)(u)
	if c == nil {
		return nil
	}

	g := &TlsPasswordClass{native: c}

	return g
}

func (recv *TlsPasswordClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsPasswordClass with another TlsPasswordClass, and returns true if they represent the same GObject.
func (recv *TlsPasswordClass) Equals(other *TlsPasswordClass) bool {
	return other.ToC() == recv.ToC()
}

// TlsPasswordPrivate is a wrapper around the C record GTlsPasswordPrivate.
type TlsPasswordPrivate struct {
	native *C.GTlsPasswordPrivate
}

func TlsPasswordPrivateNewFromC(u unsafe.Pointer) *TlsPasswordPrivate {
	c := (*C.GTlsPasswordPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TlsPasswordPrivate{native: c}

	return g
}

func (recv *TlsPasswordPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsPasswordPrivate with another TlsPasswordPrivate, and returns true if they represent the same GObject.
func (recv *TlsPasswordPrivate) Equals(other *TlsPasswordPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TlsServerConnectionInterface is a wrapper around the C record GTlsServerConnectionInterface.
type TlsServerConnectionInterface struct {
	native *C.GTlsServerConnectionInterface
	// g_iface : record
}

func TlsServerConnectionInterfaceNewFromC(u unsafe.Pointer) *TlsServerConnectionInterface {
	c := (*C.GTlsServerConnectionInterface)(u)
	if c == nil {
		return nil
	}

	g := &TlsServerConnectionInterface{native: c}

	return g
}

func (recv *TlsServerConnectionInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TlsServerConnectionInterface with another TlsServerConnectionInterface, and returns true if they represent the same GObject.
func (recv *TlsServerConnectionInterface) Equals(other *TlsServerConnectionInterface) bool {
	return other.ToC() == recv.ToC()
}

// UnixConnectionClass is a wrapper around the C record GUnixConnectionClass.
type UnixConnectionClass struct {
	native *C.GUnixConnectionClass
	// parent_class : record
}

func UnixConnectionClassNewFromC(u unsafe.Pointer) *UnixConnectionClass {
	c := (*C.GUnixConnectionClass)(u)
	if c == nil {
		return nil
	}

	g := &UnixConnectionClass{native: c}

	return g
}

func (recv *UnixConnectionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixConnectionClass with another UnixConnectionClass, and returns true if they represent the same GObject.
func (recv *UnixConnectionClass) Equals(other *UnixConnectionClass) bool {
	return other.ToC() == recv.ToC()
}

// UnixConnectionPrivate is a wrapper around the C record GUnixConnectionPrivate.
type UnixConnectionPrivate struct {
	native *C.GUnixConnectionPrivate
}

func UnixConnectionPrivateNewFromC(u unsafe.Pointer) *UnixConnectionPrivate {
	c := (*C.GUnixConnectionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &UnixConnectionPrivate{native: c}

	return g
}

func (recv *UnixConnectionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixConnectionPrivate with another UnixConnectionPrivate, and returns true if they represent the same GObject.
func (recv *UnixConnectionPrivate) Equals(other *UnixConnectionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// UnixCredentialsMessageClass is a wrapper around the C record GUnixCredentialsMessageClass.
type UnixCredentialsMessageClass struct {
	native *C.GUnixCredentialsMessageClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
}

func UnixCredentialsMessageClassNewFromC(u unsafe.Pointer) *UnixCredentialsMessageClass {
	c := (*C.GUnixCredentialsMessageClass)(u)
	if c == nil {
		return nil
	}

	g := &UnixCredentialsMessageClass{native: c}

	return g
}

func (recv *UnixCredentialsMessageClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixCredentialsMessageClass with another UnixCredentialsMessageClass, and returns true if they represent the same GObject.
func (recv *UnixCredentialsMessageClass) Equals(other *UnixCredentialsMessageClass) bool {
	return other.ToC() == recv.ToC()
}

// UnixCredentialsMessagePrivate is a wrapper around the C record GUnixCredentialsMessagePrivate.
type UnixCredentialsMessagePrivate struct {
	native *C.GUnixCredentialsMessagePrivate
}

func UnixCredentialsMessagePrivateNewFromC(u unsafe.Pointer) *UnixCredentialsMessagePrivate {
	c := (*C.GUnixCredentialsMessagePrivate)(u)
	if c == nil {
		return nil
	}

	g := &UnixCredentialsMessagePrivate{native: c}

	return g
}

func (recv *UnixCredentialsMessagePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixCredentialsMessagePrivate with another UnixCredentialsMessagePrivate, and returns true if they represent the same GObject.
func (recv *UnixCredentialsMessagePrivate) Equals(other *UnixCredentialsMessagePrivate) bool {
	return other.ToC() == recv.ToC()
}

// UnixFDListClass is a wrapper around the C record GUnixFDListClass.
type UnixFDListClass struct {
	native *C.GUnixFDListClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func UnixFDListClassNewFromC(u unsafe.Pointer) *UnixFDListClass {
	c := (*C.GUnixFDListClass)(u)
	if c == nil {
		return nil
	}

	g := &UnixFDListClass{native: c}

	return g
}

func (recv *UnixFDListClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixFDListClass with another UnixFDListClass, and returns true if they represent the same GObject.
func (recv *UnixFDListClass) Equals(other *UnixFDListClass) bool {
	return other.ToC() == recv.ToC()
}

// UnixFDListPrivate is a wrapper around the C record GUnixFDListPrivate.
type UnixFDListPrivate struct {
	native *C.GUnixFDListPrivate
}

func UnixFDListPrivateNewFromC(u unsafe.Pointer) *UnixFDListPrivate {
	c := (*C.GUnixFDListPrivate)(u)
	if c == nil {
		return nil
	}

	g := &UnixFDListPrivate{native: c}

	return g
}

func (recv *UnixFDListPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixFDListPrivate with another UnixFDListPrivate, and returns true if they represent the same GObject.
func (recv *UnixFDListPrivate) Equals(other *UnixFDListPrivate) bool {
	return other.ToC() == recv.ToC()
}

// UnixFDMessageClass is a wrapper around the C record GUnixFDMessageClass.
type UnixFDMessageClass struct {
	native *C.GUnixFDMessageClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
}

func UnixFDMessageClassNewFromC(u unsafe.Pointer) *UnixFDMessageClass {
	c := (*C.GUnixFDMessageClass)(u)
	if c == nil {
		return nil
	}

	g := &UnixFDMessageClass{native: c}

	return g
}

func (recv *UnixFDMessageClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixFDMessageClass with another UnixFDMessageClass, and returns true if they represent the same GObject.
func (recv *UnixFDMessageClass) Equals(other *UnixFDMessageClass) bool {
	return other.ToC() == recv.ToC()
}

// UnixFDMessagePrivate is a wrapper around the C record GUnixFDMessagePrivate.
type UnixFDMessagePrivate struct {
	native *C.GUnixFDMessagePrivate
}

func UnixFDMessagePrivateNewFromC(u unsafe.Pointer) *UnixFDMessagePrivate {
	c := (*C.GUnixFDMessagePrivate)(u)
	if c == nil {
		return nil
	}

	g := &UnixFDMessagePrivate{native: c}

	return g
}

func (recv *UnixFDMessagePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixFDMessagePrivate with another UnixFDMessagePrivate, and returns true if they represent the same GObject.
func (recv *UnixFDMessagePrivate) Equals(other *UnixFDMessagePrivate) bool {
	return other.ToC() == recv.ToC()
}

// UnixInputStreamClass is a wrapper around the C record GUnixInputStreamClass.
type UnixInputStreamClass struct {
	native *C.GUnixInputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func UnixInputStreamClassNewFromC(u unsafe.Pointer) *UnixInputStreamClass {
	c := (*C.GUnixInputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &UnixInputStreamClass{native: c}

	return g
}

func (recv *UnixInputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixInputStreamClass with another UnixInputStreamClass, and returns true if they represent the same GObject.
func (recv *UnixInputStreamClass) Equals(other *UnixInputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// UnixInputStreamPrivate is a wrapper around the C record GUnixInputStreamPrivate.
type UnixInputStreamPrivate struct {
	native *C.GUnixInputStreamPrivate
}

func UnixInputStreamPrivateNewFromC(u unsafe.Pointer) *UnixInputStreamPrivate {
	c := (*C.GUnixInputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &UnixInputStreamPrivate{native: c}

	return g
}

func (recv *UnixInputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixInputStreamPrivate with another UnixInputStreamPrivate, and returns true if they represent the same GObject.
func (recv *UnixInputStreamPrivate) Equals(other *UnixInputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// UnixMountEntry is a wrapper around the C record GUnixMountEntry.
type UnixMountEntry struct {
	native *C.GUnixMountEntry
}

func UnixMountEntryNewFromC(u unsafe.Pointer) *UnixMountEntry {
	c := (*C.GUnixMountEntry)(u)
	if c == nil {
		return nil
	}

	g := &UnixMountEntry{native: c}

	return g
}

func (recv *UnixMountEntry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixMountEntry with another UnixMountEntry, and returns true if they represent the same GObject.
func (recv *UnixMountEntry) Equals(other *UnixMountEntry) bool {
	return other.ToC() == recv.ToC()
}

// UnixMountMonitorClass is a wrapper around the C record GUnixMountMonitorClass.
type UnixMountMonitorClass struct {
	native *C.GUnixMountMonitorClass
}

func UnixMountMonitorClassNewFromC(u unsafe.Pointer) *UnixMountMonitorClass {
	c := (*C.GUnixMountMonitorClass)(u)
	if c == nil {
		return nil
	}

	g := &UnixMountMonitorClass{native: c}

	return g
}

func (recv *UnixMountMonitorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixMountMonitorClass with another UnixMountMonitorClass, and returns true if they represent the same GObject.
func (recv *UnixMountMonitorClass) Equals(other *UnixMountMonitorClass) bool {
	return other.ToC() == recv.ToC()
}

// UnixMountPoint is a wrapper around the C record GUnixMountPoint.
type UnixMountPoint struct {
	native *C.GUnixMountPoint
}

func UnixMountPointNewFromC(u unsafe.Pointer) *UnixMountPoint {
	c := (*C.GUnixMountPoint)(u)
	if c == nil {
		return nil
	}

	g := &UnixMountPoint{native: c}

	return g
}

func (recv *UnixMountPoint) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixMountPoint with another UnixMountPoint, and returns true if they represent the same GObject.
func (recv *UnixMountPoint) Equals(other *UnixMountPoint) bool {
	return other.ToC() == recv.ToC()
}

// Compare is a wrapper around the C function g_unix_mount_point_compare.
func (recv *UnixMountPoint) Compare(mount2 *UnixMountPoint) int32 {
	c_mount2 := (*C.GUnixMountPoint)(C.NULL)
	if mount2 != nil {
		c_mount2 = (*C.GUnixMountPoint)(mount2.ToC())
	}

	retC := C.g_unix_mount_point_compare((*C.GUnixMountPoint)(recv.native), c_mount2)
	retGo := (int32)(retC)

	return retGo
}

// Free is a wrapper around the C function g_unix_mount_point_free.
func (recv *UnixMountPoint) Free() {
	C.g_unix_mount_point_free((*C.GUnixMountPoint)(recv.native))

	return
}

// GetDevicePath is a wrapper around the C function g_unix_mount_point_get_device_path.
func (recv *UnixMountPoint) GetDevicePath() string {
	retC := C.g_unix_mount_point_get_device_path((*C.GUnixMountPoint)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetFsType is a wrapper around the C function g_unix_mount_point_get_fs_type.
func (recv *UnixMountPoint) GetFsType() string {
	retC := C.g_unix_mount_point_get_fs_type((*C.GUnixMountPoint)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetMountPath is a wrapper around the C function g_unix_mount_point_get_mount_path.
func (recv *UnixMountPoint) GetMountPath() string {
	retC := C.g_unix_mount_point_get_mount_path((*C.GUnixMountPoint)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetOptions is a wrapper around the C function g_unix_mount_point_get_options.
func (recv *UnixMountPoint) GetOptions() string {
	retC := C.g_unix_mount_point_get_options((*C.GUnixMountPoint)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GuessCanEject is a wrapper around the C function g_unix_mount_point_guess_can_eject.
func (recv *UnixMountPoint) GuessCanEject() bool {
	retC := C.g_unix_mount_point_guess_can_eject((*C.GUnixMountPoint)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GuessIcon is a wrapper around the C function g_unix_mount_point_guess_icon.
func (recv *UnixMountPoint) GuessIcon() *Icon {
	retC := C.g_unix_mount_point_guess_icon((*C.GUnixMountPoint)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GuessName is a wrapper around the C function g_unix_mount_point_guess_name.
func (recv *UnixMountPoint) GuessName() string {
	retC := C.g_unix_mount_point_guess_name((*C.GUnixMountPoint)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GuessSymbolicIcon is a wrapper around the C function g_unix_mount_point_guess_symbolic_icon.
func (recv *UnixMountPoint) GuessSymbolicIcon() *Icon {
	retC := C.g_unix_mount_point_guess_symbolic_icon((*C.GUnixMountPoint)(recv.native))
	retGo := IconNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IsLoopback is a wrapper around the C function g_unix_mount_point_is_loopback.
func (recv *UnixMountPoint) IsLoopback() bool {
	retC := C.g_unix_mount_point_is_loopback((*C.GUnixMountPoint)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsReadonly is a wrapper around the C function g_unix_mount_point_is_readonly.
func (recv *UnixMountPoint) IsReadonly() bool {
	retC := C.g_unix_mount_point_is_readonly((*C.GUnixMountPoint)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsUserMountable is a wrapper around the C function g_unix_mount_point_is_user_mountable.
func (recv *UnixMountPoint) IsUserMountable() bool {
	retC := C.g_unix_mount_point_is_user_mountable((*C.GUnixMountPoint)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// UnixOutputStreamClass is a wrapper around the C record GUnixOutputStreamClass.
type UnixOutputStreamClass struct {
	native *C.GUnixOutputStreamClass
	// parent_class : record
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
}

func UnixOutputStreamClassNewFromC(u unsafe.Pointer) *UnixOutputStreamClass {
	c := (*C.GUnixOutputStreamClass)(u)
	if c == nil {
		return nil
	}

	g := &UnixOutputStreamClass{native: c}

	return g
}

func (recv *UnixOutputStreamClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixOutputStreamClass with another UnixOutputStreamClass, and returns true if they represent the same GObject.
func (recv *UnixOutputStreamClass) Equals(other *UnixOutputStreamClass) bool {
	return other.ToC() == recv.ToC()
}

// UnixOutputStreamPrivate is a wrapper around the C record GUnixOutputStreamPrivate.
type UnixOutputStreamPrivate struct {
	native *C.GUnixOutputStreamPrivate
}

func UnixOutputStreamPrivateNewFromC(u unsafe.Pointer) *UnixOutputStreamPrivate {
	c := (*C.GUnixOutputStreamPrivate)(u)
	if c == nil {
		return nil
	}

	g := &UnixOutputStreamPrivate{native: c}

	return g
}

func (recv *UnixOutputStreamPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixOutputStreamPrivate with another UnixOutputStreamPrivate, and returns true if they represent the same GObject.
func (recv *UnixOutputStreamPrivate) Equals(other *UnixOutputStreamPrivate) bool {
	return other.ToC() == recv.ToC()
}

// UnixSocketAddressClass is a wrapper around the C record GUnixSocketAddressClass.
type UnixSocketAddressClass struct {
	native *C.GUnixSocketAddressClass
	// parent_class : record
}

func UnixSocketAddressClassNewFromC(u unsafe.Pointer) *UnixSocketAddressClass {
	c := (*C.GUnixSocketAddressClass)(u)
	if c == nil {
		return nil
	}

	g := &UnixSocketAddressClass{native: c}

	return g
}

func (recv *UnixSocketAddressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixSocketAddressClass with another UnixSocketAddressClass, and returns true if they represent the same GObject.
func (recv *UnixSocketAddressClass) Equals(other *UnixSocketAddressClass) bool {
	return other.ToC() == recv.ToC()
}

// UnixSocketAddressPrivate is a wrapper around the C record GUnixSocketAddressPrivate.
type UnixSocketAddressPrivate struct {
	native *C.GUnixSocketAddressPrivate
}

func UnixSocketAddressPrivateNewFromC(u unsafe.Pointer) *UnixSocketAddressPrivate {
	c := (*C.GUnixSocketAddressPrivate)(u)
	if c == nil {
		return nil
	}

	g := &UnixSocketAddressPrivate{native: c}

	return g
}

func (recv *UnixSocketAddressPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UnixSocketAddressPrivate with another UnixSocketAddressPrivate, and returns true if they represent the same GObject.
func (recv *UnixSocketAddressPrivate) Equals(other *UnixSocketAddressPrivate) bool {
	return other.ToC() == recv.ToC()
}

// VfsClass is a wrapper around the C record GVfsClass.
type VfsClass struct {
	native *C.GVfsClass
	// parent_class : record
	// no type for is_active
	// no type for get_file_for_path
	// no type for get_file_for_uri
	// no type for get_supported_uri_schemes
	// no type for parse_name
	// no type for local_file_add_info
	// no type for add_writable_namespaces
	// no type for local_file_set_attributes
	// no type for local_file_removed
	// no type for local_file_moved
	// no type for deserialize_icon
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
}

func VfsClassNewFromC(u unsafe.Pointer) *VfsClass {
	c := (*C.GVfsClass)(u)
	if c == nil {
		return nil
	}

	g := &VfsClass{native: c}

	return g
}

func (recv *VfsClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VfsClass with another VfsClass, and returns true if they represent the same GObject.
func (recv *VfsClass) Equals(other *VfsClass) bool {
	return other.ToC() == recv.ToC()
}

// VolumeIface is a wrapper around the C record GVolumeIface.
type VolumeIface struct {
	native *C.GVolumeIface
	// g_iface : record
	// no type for changed
	// no type for removed
	// no type for get_name
	// no type for get_icon
	// no type for get_uuid
	// no type for get_drive
	// no type for get_mount
	// no type for can_mount
	// no type for can_eject
	// no type for mount_fn
	// no type for mount_finish
	// no type for eject
	// no type for eject_finish
	// no type for get_identifier
	// no type for enumerate_identifiers
	// no type for should_automount
	// no type for get_activation_root
	// no type for eject_with_operation
	// no type for eject_with_operation_finish
	// no type for get_sort_key
	// no type for get_symbolic_icon
}

func VolumeIfaceNewFromC(u unsafe.Pointer) *VolumeIface {
	c := (*C.GVolumeIface)(u)
	if c == nil {
		return nil
	}

	g := &VolumeIface{native: c}

	return g
}

func (recv *VolumeIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VolumeIface with another VolumeIface, and returns true if they represent the same GObject.
func (recv *VolumeIface) Equals(other *VolumeIface) bool {
	return other.ToC() == recv.ToC()
}

// VolumeMonitorClass is a wrapper around the C record GVolumeMonitorClass.
type VolumeMonitorClass struct {
	native *C.GVolumeMonitorClass
	// parent_class : record
	// no type for volume_added
	// no type for volume_removed
	// no type for volume_changed
	// no type for mount_added
	// no type for mount_removed
	// no type for mount_pre_unmount
	// no type for mount_changed
	// no type for drive_connected
	// no type for drive_disconnected
	// no type for drive_changed
	// no type for is_supported
	// no type for get_connected_drives
	// no type for get_volumes
	// no type for get_mounts
	// no type for get_volume_for_uuid
	// no type for get_mount_for_uuid
	// no type for adopt_orphan_mount
	// no type for drive_eject_button
	// no type for drive_stop_button
	// no type for _g_reserved1
	// no type for _g_reserved2
	// no type for _g_reserved3
	// no type for _g_reserved4
	// no type for _g_reserved5
	// no type for _g_reserved6
}

func VolumeMonitorClassNewFromC(u unsafe.Pointer) *VolumeMonitorClass {
	c := (*C.GVolumeMonitorClass)(u)
	if c == nil {
		return nil
	}

	g := &VolumeMonitorClass{native: c}

	return g
}

func (recv *VolumeMonitorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VolumeMonitorClass with another VolumeMonitorClass, and returns true if they represent the same GObject.
func (recv *VolumeMonitorClass) Equals(other *VolumeMonitorClass) bool {
	return other.ToC() == recv.ToC()
}

// ZlibCompressorClass is a wrapper around the C record GZlibCompressorClass.
type ZlibCompressorClass struct {
	native *C.GZlibCompressorClass
	// parent_class : record
}

func ZlibCompressorClassNewFromC(u unsafe.Pointer) *ZlibCompressorClass {
	c := (*C.GZlibCompressorClass)(u)
	if c == nil {
		return nil
	}

	g := &ZlibCompressorClass{native: c}

	return g
}

func (recv *ZlibCompressorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ZlibCompressorClass with another ZlibCompressorClass, and returns true if they represent the same GObject.
func (recv *ZlibCompressorClass) Equals(other *ZlibCompressorClass) bool {
	return other.ToC() == recv.ToC()
}

// ZlibDecompressorClass is a wrapper around the C record GZlibDecompressorClass.
type ZlibDecompressorClass struct {
	native *C.GZlibDecompressorClass
	// parent_class : record
}

func ZlibDecompressorClassNewFromC(u unsafe.Pointer) *ZlibDecompressorClass {
	c := (*C.GZlibDecompressorClass)(u)
	if c == nil {
		return nil
	}

	g := &ZlibDecompressorClass{native: c}

	return g
}

func (recv *ZlibDecompressorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ZlibDecompressorClass with another ZlibDecompressorClass, and returns true if they represent the same GObject.
func (recv *ZlibDecompressorClass) Equals(other *ZlibDecompressorClass) bool {
	return other.ToC() == recv.ToC()
}
