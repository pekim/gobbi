// This is a generated file - DO NOT EDIT

package gtk

import (
	atk "github.com/pekim/gobbi/lib/atk"
	cairo "github.com/pekim/gobbi/lib/cairo"
	gdk "github.com/pekim/gobbi/lib/gdk"
	gdkpixbuf "github.com/pekim/gobbi/lib/gdkpixbuf"
	gio "github.com/pekim/gobbi/lib/gio"
	glib "github.com/pekim/gobbi/lib/glib"
	gobject "github.com/pekim/gobbi/lib/gobject"
	pango "github.com/pekim/gobbi/lib/pango"
	"sync"
	"unsafe"
)

// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// #include <stdlib.h>
/*

	void adjustment_changedHandler(GObject *, gpointer);

	static gulong Adjustment_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(adjustment_changedHandler), data);
	}

*/
/*

	void adjustment_valueChangedHandler(GObject *, gpointer);

	static gulong Adjustment_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(adjustment_valueChangedHandler), data);
	}

*/
/*

	void appchooserwidget_applicationActivatedHandler(GObject *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_application_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "application-activated", G_CALLBACK(appchooserwidget_applicationActivatedHandler), data);
	}

*/
/*

	void appchooserwidget_applicationSelectedHandler(GObject *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_application_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "application-selected", G_CALLBACK(appchooserwidget_applicationSelectedHandler), data);
	}

*/
/*

	void appchooserwidget_populatePopupHandler(GObject *, GtkMenu *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(appchooserwidget_populatePopupHandler), data);
	}

*/
/*

	void assistant_escapeHandler(GObject *, gpointer);

	static gulong Assistant_signal_connect_escape(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "escape", G_CALLBACK(assistant_escapeHandler), data);
	}

*/
/*

	void button_activateHandler(GObject *, gpointer);

	static gulong Button_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(button_activateHandler), data);
	}

*/
/*

	void button_clickedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(button_clickedHandler), data);
	}

*/
/*

	void button_enterHandler(GObject *, gpointer);

	static gulong Button_signal_connect_enter(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enter", G_CALLBACK(button_enterHandler), data);
	}

*/
/*

	void button_leaveHandler(GObject *, gpointer);

	static gulong Button_signal_connect_leave(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "leave", G_CALLBACK(button_leaveHandler), data);
	}

*/
/*

	void button_pressedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_pressed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "pressed", G_CALLBACK(button_pressedHandler), data);
	}

*/
/*

	void button_releasedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_released(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "released", G_CALLBACK(button_releasedHandler), data);
	}

*/
/*

	void calendar_daySelectedHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_day_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "day-selected", G_CALLBACK(calendar_daySelectedHandler), data);
	}

*/
/*

	void calendar_daySelectedDoubleClickHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_day_selected_double_click(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "day-selected-double-click", G_CALLBACK(calendar_daySelectedDoubleClickHandler), data);
	}

*/
/*

	void calendar_monthChangedHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_month_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "month-changed", G_CALLBACK(calendar_monthChangedHandler), data);
	}

*/
/*

	void calendar_nextMonthHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_next_month(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "next-month", G_CALLBACK(calendar_nextMonthHandler), data);
	}

*/
/*

	void calendar_nextYearHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_next_year(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "next-year", G_CALLBACK(calendar_nextYearHandler), data);
	}

*/
/*

	void calendar_prevMonthHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_prev_month(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prev-month", G_CALLBACK(calendar_prevMonthHandler), data);
	}

*/
/*

	void calendar_prevYearHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_prev_year(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prev-year", G_CALLBACK(calendar_prevYearHandler), data);
	}

*/
/*

	void checkmenuitem_toggledHandler(GObject *, gpointer);

	static gulong CheckMenuItem_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(checkmenuitem_toggledHandler), data);
	}

*/
/*

	void colorselection_colorChangedHandler(GObject *, gpointer);

	static gulong ColorSelection_signal_connect_color_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "color-changed", G_CALLBACK(colorselection_colorChangedHandler), data);
	}

*/
/*

	void container_addHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_add(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "add", G_CALLBACK(container_addHandler), data);
	}

*/
/*

	void container_checkResizeHandler(GObject *, gpointer);

	static gulong Container_signal_connect_check_resize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "check-resize", G_CALLBACK(container_checkResizeHandler), data);
	}

*/
/*

	void container_removeHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_remove(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove", G_CALLBACK(container_removeHandler), data);
	}

*/
/*

	void container_setFocusChildHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_set_focus_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-focus-child", G_CALLBACK(container_setFocusChildHandler), data);
	}

*/
/*

	void cssprovider_parsingErrorHandler(GObject *, GtkCssSection *, GError *, gpointer);

	static gulong CssProvider_signal_connect_parsing_error(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "parsing-error", G_CALLBACK(cssprovider_parsingErrorHandler), data);
	}

*/
/*

	void dialog_closeHandler(GObject *, gpointer);

	static gulong Dialog_signal_connect_close(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "close", G_CALLBACK(dialog_closeHandler), data);
	}

*/
/*

	void entry_activateHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(entry_activateHandler), data);
	}

*/
/*

	void entry_backspaceHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_backspace(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "backspace", G_CALLBACK(entry_backspaceHandler), data);
	}

*/
/*

	void entry_copyClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(entry_copyClipboardHandler), data);
	}

*/
/*

	void entry_cutClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_cut_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cut-clipboard", G_CALLBACK(entry_cutClipboardHandler), data);
	}

*/
/*

	void entry_pasteClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_paste_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paste-clipboard", G_CALLBACK(entry_pasteClipboardHandler), data);
	}

*/
/*

	void entry_populatePopupHandler(GObject *, GtkWidget *, gpointer);

	static gulong Entry_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(entry_populatePopupHandler), data);
	}

*/
/*

	void entry_toggleOverwriteHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_toggle_overwrite(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-overwrite", G_CALLBACK(entry_toggleOverwriteHandler), data);
	}

*/
/*

	void expander_activateHandler(GObject *, gpointer);

	static gulong Expander_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(expander_activateHandler), data);
	}

*/
/*

	void filechooserwidget_desktopFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_desktop_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "desktop-folder", G_CALLBACK(filechooserwidget_desktopFolderHandler), data);
	}

*/
/*

	void filechooserwidget_downFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_down_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "down-folder", G_CALLBACK(filechooserwidget_downFolderHandler), data);
	}

*/
/*

	void filechooserwidget_homeFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_home_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "home-folder", G_CALLBACK(filechooserwidget_homeFolderHandler), data);
	}

*/
/*

	void filechooserwidget_locationPopupOnPasteHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_location_popup_on_paste(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-popup-on-paste", G_CALLBACK(filechooserwidget_locationPopupOnPasteHandler), data);
	}

*/
/*

	void filechooserwidget_locationTogglePopupHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_location_toggle_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-toggle-popup", G_CALLBACK(filechooserwidget_locationTogglePopupHandler), data);
	}

*/
/*

	void filechooserwidget_placesShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_places_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "places-shortcut", G_CALLBACK(filechooserwidget_placesShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_recentShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_recent_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "recent-shortcut", G_CALLBACK(filechooserwidget_recentShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_searchShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_search_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "search-shortcut", G_CALLBACK(filechooserwidget_searchShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_showHiddenHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_show_hidden(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-hidden", G_CALLBACK(filechooserwidget_showHiddenHandler), data);
	}

*/
/*

	void filechooserwidget_upFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_up_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "up-folder", G_CALLBACK(filechooserwidget_upFolderHandler), data);
	}

*/
/*

	void flowbox_activateCursorChildHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_activate_cursor_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-child", G_CALLBACK(flowbox_activateCursorChildHandler), data);
	}

*/
/*

	void flowbox_childActivatedHandler(GObject *, GtkFlowBoxChild *, gpointer);

	static gulong FlowBox_signal_connect_child_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-activated", G_CALLBACK(flowbox_childActivatedHandler), data);
	}

*/
/*

	void flowbox_selectAllHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(flowbox_selectAllHandler), data);
	}

*/
/*

	void flowbox_selectedChildrenChangedHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_selected_children_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selected-children-changed", G_CALLBACK(flowbox_selectedChildrenChangedHandler), data);
	}

*/
/*

	void flowbox_toggleCursorChildHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_toggle_cursor_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-child", G_CALLBACK(flowbox_toggleCursorChildHandler), data);
	}

*/
/*

	void flowbox_unselectAllHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(flowbox_unselectAllHandler), data);
	}

*/
/*

	void flowboxchild_activateHandler(GObject *, gpointer);

	static gulong FlowBoxChild_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(flowboxchild_activateHandler), data);
	}

*/
/*

	void hsv_changedHandler(GObject *, gpointer);

	static gulong HSV_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(hsv_changedHandler), data);
	}

*/
/*

	void handlebox_childAttachedHandler(GObject *, GtkWidget *, gpointer);

	static gulong HandleBox_signal_connect_child_attached(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-attached", G_CALLBACK(handlebox_childAttachedHandler), data);
	}

*/
/*

	void handlebox_childDetachedHandler(GObject *, GtkWidget *, gpointer);

	static gulong HandleBox_signal_connect_child_detached(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-detached", G_CALLBACK(handlebox_childDetachedHandler), data);
	}

*/
/*

	void imcontext_preeditChangedHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-changed", G_CALLBACK(imcontext_preeditChangedHandler), data);
	}

*/
/*

	void imcontext_preeditEndHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-end", G_CALLBACK(imcontext_preeditEndHandler), data);
	}

*/
/*

	void imcontext_preeditStartHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_start(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-start", G_CALLBACK(imcontext_preeditStartHandler), data);
	}

*/
/*

	gboolean imcontext_retrieveSurroundingHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_retrieve_surrounding(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "retrieve-surrounding", G_CALLBACK(imcontext_retrieveSurroundingHandler), data);
	}

*/
/*

	void icontheme_changedHandler(GObject *, gpointer);

	static gulong IconTheme_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(icontheme_changedHandler), data);
	}

*/
/*

	gboolean iconview_activateCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_activate_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-item", G_CALLBACK(iconview_activateCursorItemHandler), data);
	}

*/
/*

	void iconview_itemActivatedHandler(GObject *, GtkTreePath *, gpointer);

	static gulong IconView_signal_connect_item_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "item-activated", G_CALLBACK(iconview_itemActivatedHandler), data);
	}

*/
/*

	void iconview_selectAllHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(iconview_selectAllHandler), data);
	}

*/
/*

	void iconview_selectCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_select_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-item", G_CALLBACK(iconview_selectCursorItemHandler), data);
	}

*/
/*

	void iconview_selectionChangedHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_selection_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-changed", G_CALLBACK(iconview_selectionChangedHandler), data);
	}

*/
/*

	void iconview_toggleCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_toggle_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-item", G_CALLBACK(iconview_toggleCursorItemHandler), data);
	}

*/
/*

	void iconview_unselectAllHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(iconview_unselectAllHandler), data);
	}

*/
/*

	void label_copyClipboardHandler(GObject *, gpointer);

	static gulong Label_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(label_copyClipboardHandler), data);
	}

*/
/*

	void label_populatePopupHandler(GObject *, GtkMenu *, gpointer);

	static gulong Label_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(label_populatePopupHandler), data);
	}

*/
/*

	gboolean linkbutton_activateLinkHandler(GObject *, gpointer);

	static gulong LinkButton_signal_connect_activate_link(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-link", G_CALLBACK(linkbutton_activateLinkHandler), data);
	}

*/
/*

	void listbox_activateCursorRowHandler(GObject *, gpointer);

	static gulong ListBox_signal_connect_activate_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-row", G_CALLBACK(listbox_activateCursorRowHandler), data);
	}

*/
/*

	void listbox_toggleCursorRowHandler(GObject *, gpointer);

	static gulong ListBox_signal_connect_toggle_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-row", G_CALLBACK(listbox_toggleCursorRowHandler), data);
	}

*/
/*

	void menuitem_activateHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(menuitem_activateHandler), data);
	}

*/
/*

	void menuitem_activateItemHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_activate_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-item", G_CALLBACK(menuitem_activateItemHandler), data);
	}

*/
/*

	void menuitem_deselectHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_deselect(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "deselect", G_CALLBACK(menuitem_deselectHandler), data);
	}

*/
/*

	void menuitem_selectHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_select(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select", G_CALLBACK(menuitem_selectHandler), data);
	}

*/
/*

	void menushell_activateCurrentHandler(GObject *, gboolean, gpointer);

	static gulong MenuShell_signal_connect_activate_current(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-current", G_CALLBACK(menushell_activateCurrentHandler), data);
	}

*/
/*

	void menushell_cancelHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_cancel(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cancel", G_CALLBACK(menushell_cancelHandler), data);
	}

*/
/*

	void menushell_deactivateHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_deactivate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "deactivate", G_CALLBACK(menushell_deactivateHandler), data);
	}

*/
/*

	void menushell_selectionDoneHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_selection_done(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-done", G_CALLBACK(menushell_selectionDoneHandler), data);
	}

*/
/*

	void menutoolbutton_showMenuHandler(GObject *, gpointer);

	static gulong MenuToolButton_signal_connect_show_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-menu", G_CALLBACK(menutoolbutton_showMenuHandler), data);
	}

*/
/*

	gboolean notebook_selectPageHandler(GObject *, gboolean, gpointer);

	static gulong Notebook_signal_connect_select_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-page", G_CALLBACK(notebook_selectPageHandler), data);
	}

*/
/*

	void placessidebar_showConnectToServerHandler(GObject *, gpointer);

	static gulong PlacesSidebar_signal_connect_show_connect_to_server(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-connect-to-server", G_CALLBACK(placessidebar_showConnectToServerHandler), data);
	}

*/
/*

	void popover_closedHandler(GObject *, gpointer);

	static gulong Popover_signal_connect_closed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "closed", G_CALLBACK(popover_closedHandler), data);
	}

*/
/*

	void radiomenuitem_groupChangedHandler(GObject *, gpointer);

	static gulong RadioMenuItem_signal_connect_group_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "group-changed", G_CALLBACK(radiomenuitem_groupChangedHandler), data);
	}

*/
/*

	void range_valueChangedHandler(GObject *, gpointer);

	static gulong Range_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(range_valueChangedHandler), data);
	}

*/
/*

	gboolean spinbutton_outputHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_output(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "output", G_CALLBACK(spinbutton_outputHandler), data);
	}

*/
/*

	void spinbutton_valueChangedHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(spinbutton_valueChangedHandler), data);
	}

*/
/*

	void switch_activateHandler(GObject *, gpointer);

	static gulong Switch_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(switch_activateHandler), data);
	}

*/
/*

	void textbuffer_applyTagHandler(GObject *, GtkTextTag *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_apply_tag(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "apply-tag", G_CALLBACK(textbuffer_applyTagHandler), data);
	}

*/
/*

	void textbuffer_beginUserActionHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_begin_user_action(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "begin-user-action", G_CALLBACK(textbuffer_beginUserActionHandler), data);
	}

*/
/*

	void textbuffer_changedHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(textbuffer_changedHandler), data);
	}

*/
/*

	void textbuffer_deleteRangeHandler(GObject *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_delete_range(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-range", G_CALLBACK(textbuffer_deleteRangeHandler), data);
	}

*/
/*

	void textbuffer_endUserActionHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_end_user_action(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "end-user-action", G_CALLBACK(textbuffer_endUserActionHandler), data);
	}

*/
/*

	void textbuffer_insertChildAnchorHandler(GObject *, GtkTextIter *, GtkTextChildAnchor *, gpointer);

	static gulong TextBuffer_signal_connect_insert_child_anchor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-child-anchor", G_CALLBACK(textbuffer_insertChildAnchorHandler), data);
	}

*/
/*

	void textbuffer_insertPixbufHandler(GObject *, GtkTextIter *, GdkPixbuf *, gpointer);

	static gulong TextBuffer_signal_connect_insert_pixbuf(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-pixbuf", G_CALLBACK(textbuffer_insertPixbufHandler), data);
	}

*/
/*

	void textbuffer_markDeletedHandler(GObject *, GtkTextMark *, gpointer);

	static gulong TextBuffer_signal_connect_mark_deleted(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mark-deleted", G_CALLBACK(textbuffer_markDeletedHandler), data);
	}

*/
/*

	void textbuffer_markSetHandler(GObject *, GtkTextIter *, GtkTextMark *, gpointer);

	static gulong TextBuffer_signal_connect_mark_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mark-set", G_CALLBACK(textbuffer_markSetHandler), data);
	}

*/
/*

	void textbuffer_modifiedChangedHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_modified_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "modified-changed", G_CALLBACK(textbuffer_modifiedChangedHandler), data);
	}

*/
/*

	void textbuffer_removeTagHandler(GObject *, GtkTextTag *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_remove_tag(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove-tag", G_CALLBACK(textbuffer_removeTagHandler), data);
	}

*/
/*

	void texttagtable_tagAddedHandler(GObject *, GtkTextTag *, gpointer);

	static gulong TextTagTable_signal_connect_tag_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-added", G_CALLBACK(texttagtable_tagAddedHandler), data);
	}

*/
/*

	void texttagtable_tagChangedHandler(GObject *, GtkTextTag *, gboolean, gpointer);

	static gulong TextTagTable_signal_connect_tag_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-changed", G_CALLBACK(texttagtable_tagChangedHandler), data);
	}

*/
/*

	void texttagtable_tagRemovedHandler(GObject *, GtkTextTag *, gpointer);

	static gulong TextTagTable_signal_connect_tag_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-removed", G_CALLBACK(texttagtable_tagRemovedHandler), data);
	}

*/
/*

	void textview_backspaceHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_backspace(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "backspace", G_CALLBACK(textview_backspaceHandler), data);
	}

*/
/*

	void textview_copyClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(textview_copyClipboardHandler), data);
	}

*/
/*

	void textview_cutClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_cut_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cut-clipboard", G_CALLBACK(textview_cutClipboardHandler), data);
	}

*/
/*

	void textview_pasteClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_paste_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paste-clipboard", G_CALLBACK(textview_pasteClipboardHandler), data);
	}

*/
/*

	void textview_populatePopupHandler(GObject *, GtkWidget *, gpointer);

	static gulong TextView_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(textview_populatePopupHandler), data);
	}

*/
/*

	void textview_selectAllHandler(GObject *, gboolean, gpointer);

	static gulong TextView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(textview_selectAllHandler), data);
	}

*/
/*

	void textview_setAnchorHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_set_anchor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-anchor", G_CALLBACK(textview_setAnchorHandler), data);
	}

*/
/*

	void textview_toggleCursorVisibleHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_toggle_cursor_visible(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-visible", G_CALLBACK(textview_toggleCursorVisibleHandler), data);
	}

*/
/*

	void textview_toggleOverwriteHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_toggle_overwrite(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-overwrite", G_CALLBACK(textview_toggleOverwriteHandler), data);
	}

*/
/*

	void toggleaction_toggledHandler(GObject *, gpointer);

	static gulong ToggleAction_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(toggleaction_toggledHandler), data);
	}

*/
/*

	void togglebutton_toggledHandler(GObject *, gpointer);

	static gulong ToggleButton_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(togglebutton_toggledHandler), data);
	}

*/
/*

	void toggletoolbutton_toggledHandler(GObject *, gpointer);

	static gulong ToggleToolButton_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(toggletoolbutton_toggledHandler), data);
	}

*/
/*

	void toolbutton_clickedHandler(GObject *, gpointer);

	static gulong ToolButton_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(toolbutton_clickedHandler), data);
	}

*/
/*

	gboolean toolitem_createMenuProxyHandler(GObject *, gpointer);

	static gulong ToolItem_signal_connect_create_menu_proxy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "create-menu-proxy", G_CALLBACK(toolitem_createMenuProxyHandler), data);
	}

*/
/*

	void toolitem_toolbarReconfiguredHandler(GObject *, gpointer);

	static gulong ToolItem_signal_connect_toolbar_reconfigured(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toolbar-reconfigured", G_CALLBACK(toolitem_toolbarReconfiguredHandler), data);
	}

*/
/*

	gboolean toolbar_focusHomeOrEndHandler(GObject *, gboolean, gpointer);

	static gulong Toolbar_signal_connect_focus_home_or_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-home-or-end", G_CALLBACK(toolbar_focusHomeOrEndHandler), data);
	}

*/
/*

	void treeselection_changedHandler(GObject *, gpointer);

	static gulong TreeSelection_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(treeselection_changedHandler), data);
	}

*/
/*

	void treeview_columnsChangedHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_columns_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "columns-changed", G_CALLBACK(treeview_columnsChangedHandler), data);
	}

*/
/*

	void treeview_cursorChangedHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_cursor_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cursor-changed", G_CALLBACK(treeview_cursorChangedHandler), data);
	}

*/
/*

	gboolean treeview_expandCollapseCursorRowHandler(GObject *, gboolean, gboolean, gboolean, gpointer);

	static gulong TreeView_signal_connect_expand_collapse_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "expand-collapse-cursor-row", G_CALLBACK(treeview_expandCollapseCursorRowHandler), data);
	}

*/
/*

	void treeview_rowActivatedHandler(GObject *, GtkTreePath *, GtkTreeViewColumn *, gpointer);

	static gulong TreeView_signal_connect_row_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-activated", G_CALLBACK(treeview_rowActivatedHandler), data);
	}

*/
/*

	void treeview_rowCollapsedHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_row_collapsed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-collapsed", G_CALLBACK(treeview_rowCollapsedHandler), data);
	}

*/
/*

	void treeview_rowExpandedHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_row_expanded(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-expanded", G_CALLBACK(treeview_rowExpandedHandler), data);
	}

*/
/*

	gboolean treeview_selectAllHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(treeview_selectAllHandler), data);
	}

*/
/*

	gboolean treeview_selectCursorParentHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_select_cursor_parent(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-parent", G_CALLBACK(treeview_selectCursorParentHandler), data);
	}

*/
/*

	gboolean treeview_selectCursorRowHandler(GObject *, gboolean, gpointer);

	static gulong TreeView_signal_connect_select_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-row", G_CALLBACK(treeview_selectCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_startInteractiveSearchHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_start_interactive_search(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "start-interactive-search", G_CALLBACK(treeview_startInteractiveSearchHandler), data);
	}

*/
/*

	gboolean treeview_testCollapseRowHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_test_collapse_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "test-collapse-row", G_CALLBACK(treeview_testCollapseRowHandler), data);
	}

*/
/*

	gboolean treeview_testExpandRowHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_test_expand_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "test-expand-row", G_CALLBACK(treeview_testExpandRowHandler), data);
	}

*/
/*

	gboolean treeview_toggleCursorRowHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_toggle_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-row", G_CALLBACK(treeview_toggleCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_unselectAllHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(treeview_unselectAllHandler), data);
	}

*/
/*

	void treeviewcolumn_clickedHandler(GObject *, gpointer);

	static gulong TreeViewColumn_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(treeviewcolumn_clickedHandler), data);
	}

*/
/*

	void widget_accelClosuresChangedHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_accel_closures_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-closures-changed", G_CALLBACK(widget_accelClosuresChangedHandler), data);
	}

*/
/*

	gboolean widget_buttonPressEventHandler(GObject *, GdkEventButton *, gpointer);

	static gulong Widget_signal_connect_button_press_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "button-press-event", G_CALLBACK(widget_buttonPressEventHandler), data);
	}

*/
/*

	gboolean widget_buttonReleaseEventHandler(GObject *, GdkEventButton *, gpointer);

	static gulong Widget_signal_connect_button_release_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "button-release-event", G_CALLBACK(widget_buttonReleaseEventHandler), data);
	}

*/
/*

	void widget_compositedChangedHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_composited_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "composited-changed", G_CALLBACK(widget_compositedChangedHandler), data);
	}

*/
/*

	gboolean widget_configureEventHandler(GObject *, GdkEventConfigure *, gpointer);

	static gulong Widget_signal_connect_configure_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "configure-event", G_CALLBACK(widget_configureEventHandler), data);
	}

*/
/*

	void widget_destroyHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_destroy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "destroy", G_CALLBACK(widget_destroyHandler), data);
	}

*/
/*

	void widget_dragBeginHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_begin(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-begin", G_CALLBACK(widget_dragBeginHandler), data);
	}

*/
/*

	void widget_dragDataDeleteHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_data_delete(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-data-delete", G_CALLBACK(widget_dragDataDeleteHandler), data);
	}

*/
/*

	void widget_dragEndHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-end", G_CALLBACK(widget_dragEndHandler), data);
	}

*/
/*

	gboolean widget_enterNotifyEventHandler(GObject *, GdkEventCrossing *, gpointer);

	static gulong Widget_signal_connect_enter_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enter-notify-event", G_CALLBACK(widget_enterNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_focusInEventHandler(GObject *, GdkEventFocus *, gpointer);

	static gulong Widget_signal_connect_focus_in_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-in-event", G_CALLBACK(widget_focusInEventHandler), data);
	}

*/
/*

	gboolean widget_focusOutEventHandler(GObject *, GdkEventFocus *, gpointer);

	static gulong Widget_signal_connect_focus_out_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-out-event", G_CALLBACK(widget_focusOutEventHandler), data);
	}

*/
/*

	void widget_grabFocusHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_grab_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-focus", G_CALLBACK(widget_grabFocusHandler), data);
	}

*/
/*

	void widget_grabNotifyHandler(GObject *, gboolean, gpointer);

	static gulong Widget_signal_connect_grab_notify(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-notify", G_CALLBACK(widget_grabNotifyHandler), data);
	}

*/
/*

	void widget_hideHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_hide(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "hide", G_CALLBACK(widget_hideHandler), data);
	}

*/
/*

	void widget_hierarchyChangedHandler(GObject *, GtkWidget *, gpointer);

	static gulong Widget_signal_connect_hierarchy_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "hierarchy-changed", G_CALLBACK(widget_hierarchyChangedHandler), data);
	}

*/
/*

	gboolean widget_keyPressEventHandler(GObject *, GdkEventKey *, gpointer);

	static gulong Widget_signal_connect_key_press_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "key-press-event", G_CALLBACK(widget_keyPressEventHandler), data);
	}

*/
/*

	gboolean widget_keyReleaseEventHandler(GObject *, GdkEventKey *, gpointer);

	static gulong Widget_signal_connect_key_release_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "key-release-event", G_CALLBACK(widget_keyReleaseEventHandler), data);
	}

*/
/*

	gboolean widget_leaveNotifyEventHandler(GObject *, GdkEventCrossing *, gpointer);

	static gulong Widget_signal_connect_leave_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "leave-notify-event", G_CALLBACK(widget_leaveNotifyEventHandler), data);
	}

*/
/*

	void widget_mapHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_map(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "map", G_CALLBACK(widget_mapHandler), data);
	}

*/
/*

	gboolean widget_mapEventHandler(GObject *, GdkEventAny *, gpointer);

	static gulong Widget_signal_connect_map_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "map-event", G_CALLBACK(widget_mapEventHandler), data);
	}

*/
/*

	gboolean widget_mnemonicActivateHandler(GObject *, gboolean, gpointer);

	static gulong Widget_signal_connect_mnemonic_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mnemonic-activate", G_CALLBACK(widget_mnemonicActivateHandler), data);
	}

*/
/*

	gboolean widget_motionNotifyEventHandler(GObject *, GdkEventMotion *, gpointer);

	static gulong Widget_signal_connect_motion_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "motion-notify-event", G_CALLBACK(widget_motionNotifyEventHandler), data);
	}

*/
/*

	void widget_parentSetHandler(GObject *, GtkWidget *, gpointer);

	static gulong Widget_signal_connect_parent_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "parent-set", G_CALLBACK(widget_parentSetHandler), data);
	}

*/
/*

	gboolean widget_popupMenuHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_popup_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup-menu", G_CALLBACK(widget_popupMenuHandler), data);
	}

*/
/*

	gboolean widget_propertyNotifyEventHandler(GObject *, GdkEventProperty *, gpointer);

	static gulong Widget_signal_connect_property_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "property-notify-event", G_CALLBACK(widget_propertyNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_proximityInEventHandler(GObject *, GdkEventProximity *, gpointer);

	static gulong Widget_signal_connect_proximity_in_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "proximity-in-event", G_CALLBACK(widget_proximityInEventHandler), data);
	}

*/
/*

	gboolean widget_proximityOutEventHandler(GObject *, GdkEventProximity *, gpointer);

	static gulong Widget_signal_connect_proximity_out_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "proximity-out-event", G_CALLBACK(widget_proximityOutEventHandler), data);
	}

*/
/*

	void widget_realizeHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_realize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "realize", G_CALLBACK(widget_realizeHandler), data);
	}

*/
/*

	void widget_screenChangedHandler(GObject *, GdkScreen *, gpointer);

	static gulong Widget_signal_connect_screen_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "screen-changed", G_CALLBACK(widget_screenChangedHandler), data);
	}

*/
/*

	gboolean widget_scrollEventHandler(GObject *, GdkEventScroll *, gpointer);

	static gulong Widget_signal_connect_scroll_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "scroll-event", G_CALLBACK(widget_scrollEventHandler), data);
	}

*/
/*

	gboolean widget_selectionClearEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_clear_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-clear-event", G_CALLBACK(widget_selectionClearEventHandler), data);
	}

*/
/*

	gboolean widget_selectionNotifyEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-notify-event", G_CALLBACK(widget_selectionNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_selectionRequestEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_request_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-request-event", G_CALLBACK(widget_selectionRequestEventHandler), data);
	}

*/
/*

	void widget_showHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_show(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show", G_CALLBACK(widget_showHandler), data);
	}

*/
/*

	void widget_styleSetHandler(GObject *, GtkStyle *, gpointer);

	static gulong Widget_signal_connect_style_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "style-set", G_CALLBACK(widget_styleSetHandler), data);
	}

*/
/*

	void widget_unmapHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_unmap(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmap", G_CALLBACK(widget_unmapHandler), data);
	}

*/
/*

	gboolean widget_unmapEventHandler(GObject *, GdkEventAny *, gpointer);

	static gulong Widget_signal_connect_unmap_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmap-event", G_CALLBACK(widget_unmapEventHandler), data);
	}

*/
/*

	void widget_unrealizeHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_unrealize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unrealize", G_CALLBACK(widget_unrealizeHandler), data);
	}

*/
/*

	gboolean widget_visibilityNotifyEventHandler(GObject *, GdkEventVisibility *, gpointer);

	static gulong Widget_signal_connect_visibility_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "visibility-notify-event", G_CALLBACK(widget_visibilityNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_windowStateEventHandler(GObject *, GdkEventWindowState *, gpointer);

	static gulong Widget_signal_connect_window_state_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "window-state-event", G_CALLBACK(widget_windowStateEventHandler), data);
	}

*/
/*

	void window_activateDefaultHandler(GObject *, gpointer);

	static gulong Window_signal_connect_activate_default(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-default", G_CALLBACK(window_activateDefaultHandler), data);
	}

*/
/*

	void window_activateFocusHandler(GObject *, gpointer);

	static gulong Window_signal_connect_activate_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-focus", G_CALLBACK(window_activateFocusHandler), data);
	}

*/
/*

	gboolean window_enableDebuggingHandler(GObject *, gboolean, gpointer);

	static gulong Window_signal_connect_enable_debugging(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enable-debugging", G_CALLBACK(window_enableDebuggingHandler), data);
	}

*/
/*

	void window_keysChangedHandler(GObject *, gpointer);

	static gulong Window_signal_connect_keys_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "keys-changed", G_CALLBACK(window_keysChangedHandler), data);
	}

*/
/*

	void window_setFocusHandler(GObject *, GtkWidget *, gpointer);

	static gulong Window_signal_connect_set_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-focus", G_CALLBACK(window_setFocusHandler), data);
	}

*/
import "C"

// The GtkAboutDialog offers a simple way to display information about
// a program like its logo, name, copyright, website and license. It is
// also possible to give credits to the authors, documenters, translators
// and artists who have worked on the program. An about dialog is typically
// opened when the user selects the `About` option from the `Help` menu.
// All parts of the dialog are optional.
//
// About dialogs often contain links and email addresses. GtkAboutDialog
// displays these as clickable links. By default, it calls gtk_show_uri_on_window()
// when a user clicks one. The behaviour can be overridden with the
// #GtkAboutDialog::activate-link signal.
//
// To specify a person with an email address, use a string like
// "Edgar Allan Poe <edgar\@poe.com>". To specify a website with a title,
// use a string like "GTK+ team http://www.gtk.org".
//
// To make constructing a GtkAboutDialog as convenient as possible, you can
// use the function gtk_show_about_dialog() which constructs and shows a dialog
// and keeps it around so that it can be shown again.
//
// Note that GTK+ sets a default title of `_("About %s")` on the dialog
// window (where \%s is replaced by the name of the application, but in
// order to ensure proper translation of the title, applications should
// set the title property explicitly when constructing a GtkAboutDialog,
// as shown in the following example:
// |[<!-- language="C" -->
// GdkPixbuf *example_logo = gdk_pixbuf_new_from_file ("./logo.png", NULL);
// gtk_show_about_dialog (NULL,
// "program-name", "ExampleCode",
// "logo", example_logo,
// "title", _("About ExampleCode"),
// NULL);
// ]|
//
// It is also possible to show a #GtkAboutDialog like any other #GtkDialog,
// e.g. using gtk_dialog_run(). In this case, you might need to know that
// the Close button returns the #GTK_RESPONSE_CANCEL response id.
/*

C record/class : GtkAboutDialog
*/
type AboutDialog struct {
	native *C.GtkAboutDialog
	// parent_instance : record
	// Private : priv
}

func AboutDialogNewFromC(u unsafe.Pointer) *AboutDialog {
	c := (*C.GtkAboutDialog)(u)
	if c == nil {
		return nil
	}

	g := &AboutDialog{native: c}

	return g
}

func (recv *AboutDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *AboutDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *AboutDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *AboutDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *AboutDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *AboutDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AboutDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AboutDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to AboutDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a AboutDialog.
func CastToAboutDialog(object *gobject.Object) *AboutDialog {
	return AboutDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by AboutDialog
func (recv *AboutDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AboutDialog
func (recv *AboutDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A #GtkAccelGroup represents a group of keyboard accelerators,
// typically attached to a toplevel #GtkWindow (with
// gtk_window_add_accel_group()). Usually you wont need to create a
// #GtkAccelGroup directly; instead, when using #GtkUIManager, GTK+
// automatically sets up the accelerators for your menus in the ui
// managers #GtkAccelGroup.
//
// Note that accelerators are different from
// mnemonics. Accelerators are shortcuts for
// activating a menu item; they appear alongside the menu item theyre a
// shortcut for. For example Ctrl+Q might appear alongside the Quit
// menu item. Mnemonics are shortcuts for GUI elements such as text
// entries or buttons; they appear as underlined characters. See
// gtk_label_new_with_mnemonic(). Menu items can have both accelerators
// and mnemonics, of course.
/*

C record/class : GtkAccelGroup
*/
type AccelGroup struct {
	native *C.GtkAccelGroup
	// parent : record
	// priv : record
}

func AccelGroupNewFromC(u unsafe.Pointer) *AccelGroup {
	c := (*C.GtkAccelGroup)(u)
	if c == nil {
		return nil
	}

	g := &AccelGroup{native: c}

	return g
}

func (recv *AccelGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *AccelGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to AccelGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelGroup.
func CastToAccelGroup(object *gobject.Object) *AccelGroup {
	return AccelGroupNewFromC(object.ToC())
}

// Unsupported signal 'accel-activate' for AccelGroup : unsupported parameter keyval : type guint :

// Unsupported signal 'accel-changed' for AccelGroup : unsupported parameter keyval : type guint :

// Creates a new #GtkAccelGroup.
/*

C function : gtk_accel_group_new
*/
func AccelGroupNew() *AccelGroup {
	retC := C.gtk_accel_group_new()
	retGo := AccelGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Finds the first accelerator in @accel_group that matches
// @accel_key and @accel_mods, and activates it.
/*

C function : gtk_accel_group_activate
*/
func (recv *AccelGroup) Activate(accelQuark glib.Quark, acceleratable *gobject.Object, accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_quark := (C.GQuark)(accelQuark)

	c_acceleratable := (*C.GObject)(C.NULL)
	if acceleratable != nil {
		c_acceleratable = (*C.GObject)(acceleratable.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_accel_group_activate((*C.GtkAccelGroup)(recv.native), c_accel_quark, c_acceleratable, c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// Installs an accelerator in this group. When @accel_group is being
// activated in response to a call to gtk_accel_groups_activate(),
// @closure will be invoked if the @accel_key and @accel_mods from
// gtk_accel_groups_activate() match those of this connection.
//
// The signature used for the @closure is that of #GtkAccelGroupActivate.
//
// Note that, due to implementation details, a single closure can
// only be connected to one accelerator group.
/*

C function : gtk_accel_group_connect
*/
func (recv *AccelGroup) Connect(accelKey uint32, accelMods gdk.ModifierType, accelFlags AccelFlags, closure *gobject.Closure) {
	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	c_accel_flags := (C.GtkAccelFlags)(accelFlags)

	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	C.gtk_accel_group_connect((*C.GtkAccelGroup)(recv.native), c_accel_key, c_accel_mods, c_accel_flags, c_closure)

	return
}

// Installs an accelerator in this group, using an accelerator path
// to look up the appropriate key and modifiers (see
// gtk_accel_map_add_entry()). When @accel_group is being activated
// in response to a call to gtk_accel_groups_activate(), @closure will
// be invoked if the @accel_key and @accel_mods from
// gtk_accel_groups_activate() match the key and modifiers for the path.
//
// The signature used for the @closure is that of #GtkAccelGroupActivate.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore,
// if you pass a static string, you can save some memory by interning it
// first with g_intern_static_string().
/*

C function : gtk_accel_group_connect_by_path
*/
func (recv *AccelGroup) ConnectByPath(accelPath string, closure *gobject.Closure) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	C.gtk_accel_group_connect_by_path((*C.GtkAccelGroup)(recv.native), c_accel_path, c_closure)

	return
}

// Removes an accelerator previously installed through
// gtk_accel_group_connect().
//
// Since 2.20 @closure can be %NULL.
/*

C function : gtk_accel_group_disconnect
*/
func (recv *AccelGroup) Disconnect(closure *gobject.Closure) bool {
	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	retC := C.gtk_accel_group_disconnect((*C.GtkAccelGroup)(recv.native), c_closure)
	retGo := retC == C.TRUE

	return retGo
}

// Removes an accelerator previously installed through
// gtk_accel_group_connect().
/*

C function : gtk_accel_group_disconnect_key
*/
func (recv *AccelGroup) DisconnectKey(accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_accel_group_disconnect_key((*C.GtkAccelGroup)(recv.native), c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_accel_group_find : unsupported parameter find_func : no type generator for AccelGroupFindFunc (GtkAccelGroupFindFunc) for param find_func

// Locks the given accelerator group.
//
// Locking an acelerator group prevents the accelerators contained
// within it to be changed during runtime. Refer to
// gtk_accel_map_change_entry() about runtime accelerator changes.
//
// If called more than once, @accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number
// of times.
/*

C function : gtk_accel_group_lock
*/
func (recv *AccelGroup) Lock() {
	C.gtk_accel_group_lock((*C.GtkAccelGroup)(recv.native))

	return
}

// Unsupported : gtk_accel_group_query : no return type

// Undoes the last call to gtk_accel_group_lock() on this @accel_group.
/*

C function : gtk_accel_group_unlock
*/
func (recv *AccelGroup) Unlock() {
	C.gtk_accel_group_unlock((*C.GtkAccelGroup)(recv.native))

	return
}

// The #GtkAccelLabel widget is a subclass of #GtkLabel that also displays an
// accelerator key on the right of the label text, e.g. Ctrl+S.
// It is commonly used in menus to show the keyboard short-cuts for commands.
//
// The accelerator key to display is typically not set explicitly (although it
// can be, with gtk_accel_label_set_accel()). Instead, the #GtkAccelLabel displays
// the accelerators which have been added to a particular widget. This widget is
// set by calling gtk_accel_label_set_accel_widget().
//
// For example, a #GtkMenuItem widget may have an accelerator added to emit
// the activate signal when the Ctrl+S key combination is pressed.
// A #GtkAccelLabel is created and added to the #GtkMenuItem, and
// gtk_accel_label_set_accel_widget() is called with the #GtkMenuItem as the
// second argument. The #GtkAccelLabel will now display Ctrl+S after its label.
//
// Note that creating a #GtkMenuItem with gtk_menu_item_new_with_label() (or
// one of the similar functions for #GtkCheckMenuItem and #GtkRadioMenuItem)
// automatically adds a #GtkAccelLabel to the #GtkMenuItem and calls
// gtk_accel_label_set_accel_widget() to set it up for you.
//
// A #GtkAccelLabel will only display accelerators which have %GTK_ACCEL_VISIBLE
// set (see #GtkAccelFlags).
// A #GtkAccelLabel can display multiple accelerators and even signal names,
// though it is almost always used to display just one accelerator key.
//
// ## Creating a simple menu item with an accelerator key.
//
// |[<!-- language="C" -->
// GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
// GtkWidget *menu = gtk_menu_new ();
// GtkWidget *save_item;
// GtkAccelGroup *accel_group;
//
// Create a GtkAccelGroup and add it to the window.
// accel_group = gtk_accel_group_new ();
// gtk_window_add_accel_group (GTK_WINDOW (window), accel_group);
//
// Create the menu item using the convenience function.
// save_item = gtk_menu_item_new_with_label ("Save");
// gtk_widget_show (save_item);
// gtk_container_add (GTK_CONTAINER (menu), save_item);
//
// Now add the accelerator to the GtkMenuItem. Note that since we
// called gtk_menu_item_new_with_label() to create the GtkMenuItem
// the GtkAccelLabel is automatically set up to display the
// GtkMenuItem accelerators. We just need to make sure we use
// GTK_ACCEL_VISIBLE here.
// gtk_widget_add_accelerator (save_item, "activate", accel_group,
// GDK_KEY_s, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// label
//  accelerator
// ]|
//
// Like #GtkLabel, GtkAccelLabel has a main CSS node with the name label.
// It adds a subnode with name accelerator.
/*

C record/class : GtkAccelLabel
*/
type AccelLabel struct {
	native *C.GtkAccelLabel
	// label : record
	// priv : record
}

func AccelLabelNewFromC(u unsafe.Pointer) *AccelLabel {
	c := (*C.GtkAccelLabel)(u)
	if c == nil {
		return nil
	}

	g := &AccelLabel{native: c}

	return g
}

func (recv *AccelLabel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Label upcasts to *Label
func (recv *AccelLabel) Label() *Label {
	return LabelNewFromC(unsafe.Pointer(recv.native))
}

// Misc upcasts to *Misc
func (recv *AccelLabel) Misc() *Misc {
	return recv.Label().Misc()
}

// Widget upcasts to *Widget
func (recv *AccelLabel) Widget() *Widget {
	return recv.Label().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AccelLabel) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Label().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AccelLabel) Object() *gobject.Object {
	return recv.Label().Object()
}

// CastToWidget down casts any arbitary Object to AccelLabel.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelLabel.
func CastToAccelLabel(object *gobject.Object) *AccelLabel {
	return AccelLabelNewFromC(object.ToC())
}

// Creates a new #GtkAccelLabel.
/*

C function : gtk_accel_label_new
*/
func AccelLabelNew(string string) *AccelLabel {
	c_string := C.CString(string)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.gtk_accel_label_new(c_string)
	retGo := AccelLabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Fetches the widget monitored by this accelerator label. See
// gtk_accel_label_set_accel_widget().
/*

C function : gtk_accel_label_get_accel_widget
*/
func (recv *AccelLabel) GetAccelWidget() *Widget {
	retC := C.gtk_accel_label_get_accel_widget((*C.GtkAccelLabel)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the width needed to display the accelerator key(s).
// This is used by menus to align all of the #GtkMenuItem widgets, and shouldn't
// be needed by applications.
/*

C function : gtk_accel_label_get_accel_width
*/
func (recv *AccelLabel) GetAccelWidth() uint32 {
	retC := C.gtk_accel_label_get_accel_width((*C.GtkAccelLabel)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Recreates the string representing the accelerator keys.
// This should not be needed since the string is automatically updated whenever
// accelerators are added or removed from the associated widget.
/*

C function : gtk_accel_label_refetch
*/
func (recv *AccelLabel) Refetch() bool {
	retC := C.gtk_accel_label_refetch((*C.GtkAccelLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the closure to be monitored by this accelerator label. The closure
// must be connected to an accelerator group; see gtk_accel_group_connect().
// Passing %NULL for @accel_closure will dissociate @accel_label from its
// current closure, if any.
/*

C function : gtk_accel_label_set_accel_closure
*/
func (recv *AccelLabel) SetAccelClosure(accelClosure *gobject.Closure) {
	c_accel_closure := (*C.GClosure)(C.NULL)
	if accelClosure != nil {
		c_accel_closure = (*C.GClosure)(accelClosure.ToC())
	}

	C.gtk_accel_label_set_accel_closure((*C.GtkAccelLabel)(recv.native), c_accel_closure)

	return
}

// Sets the widget to be monitored by this accelerator label. Passing %NULL for
// @accel_widget will dissociate @accel_label from its current widget, if any.
/*

C function : gtk_accel_label_set_accel_widget
*/
func (recv *AccelLabel) SetAccelWidget(accelWidget *Widget) {
	c_accel_widget := (*C.GtkWidget)(C.NULL)
	if accelWidget != nil {
		c_accel_widget = (*C.GtkWidget)(accelWidget.ToC())
	}

	C.gtk_accel_label_set_accel_widget((*C.GtkAccelLabel)(recv.native), c_accel_widget)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AccelLabel
func (recv *AccelLabel) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AccelLabel
func (recv *AccelLabel) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Accelerator maps are used to define runtime configurable accelerators.
// Functions for manipulating them are are usually used by higher level
// convenience mechanisms like #GtkUIManager and are thus considered
// low-level. Youll want to use them if youre manually creating menus that
// should have user-configurable accelerators.
//
// An accelerator is uniquely defined by:
// - accelerator path
// - accelerator key
// - accelerator modifiers
//
// The accelerator path must consist of
// <WINDOWTYPE>/Category1/Category2/.../Action, where WINDOWTYPE
// should be a unique application-specific identifier that corresponds
// to the kind of window the accelerator is being used in, e.g.
// Gimp-Image, Abiword-Document or Gnumeric-Settings.
// The Category1/.../Action portion is most appropriately chosen by
// the action the accelerator triggers, i.e. for accelerators on menu
// items, choose the items menu path, e.g. File/Save As,
// Image/View/Zoom or Edit/Select All. So a full valid accelerator
// path may look like: <Gimp-Toolbox>/File/Dialogs/Tool Options....
//
// All accelerators are stored inside one global #GtkAccelMap that can
// be obtained using gtk_accel_map_get(). See
// [Monitoring changes][monitoring-changes] for additional
// details.
//
// # Manipulating accelerators
//
// New accelerators can be added using gtk_accel_map_add_entry().
// To search for specific accelerator, use gtk_accel_map_lookup_entry().
// Modifications of existing accelerators should be done using
// gtk_accel_map_change_entry().
//
// In order to avoid having some accelerators changed, they can be
// locked using gtk_accel_map_lock_path(). Unlocking is done using
// gtk_accel_map_unlock_path().
//
// # Saving and loading accelerator maps
//
// Accelerator maps can be saved to and loaded from some external
// resource. For simple saving and loading from file,
// gtk_accel_map_save() and gtk_accel_map_load() are provided.
// Saving and loading can also be done by providing file descriptor
// to gtk_accel_map_save_fd() and gtk_accel_map_load_fd().
//
// # Monitoring changes
//
// #GtkAccelMap object is only useful for monitoring changes of
// accelerators. By connecting to #GtkAccelMap::changed signal, one
// can monitor changes of all accelerators. It is also possible to
// monitor only single accelerator path by using it as a detail of
// the #GtkAccelMap::changed signal.
/*

C record/class : GtkAccelMap
*/
type AccelMap struct {
	native *C.GtkAccelMap
}

func AccelMapNewFromC(u unsafe.Pointer) *AccelMap {
	c := (*C.GtkAccelMap)(u)
	if c == nil {
		return nil
	}

	g := &AccelMap{native: c}

	return g
}

func (recv *AccelMap) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *AccelMap) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to AccelMap.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelMap.
func CastToAccelMap(object *gobject.Object) *AccelMap {
	return AccelMapNewFromC(object.ToC())
}

// The #GtkAccessible class is the base class for accessible
// implementations for #GtkWidget subclasses. It is a thin
// wrapper around #AtkObject, which adds facilities for associating
// a widget with its accessible object.
//
// An accessible implementation for a third-party widget should
// derive from #GtkAccessible and implement the suitable interfaces
// from ATK, such as #AtkText or #AtkSelection. To establish
// the connection between the widget class and its corresponding
// acccessible implementation, override the get_accessible vfunc
// in #GtkWidgetClass.
/*

C record/class : GtkAccessible
*/
type Accessible struct {
	native *C.GtkAccessible
	// parent : record
	// Private : priv
}

func AccessibleNewFromC(u unsafe.Pointer) *Accessible {
	c := (*C.GtkAccessible)(u)
	if c == nil {
		return nil
	}

	g := &Accessible{native: c}

	return g
}

func (recv *Accessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Accessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Accessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a Accessible.
func CastToAccessible(object *gobject.Object) *Accessible {
	return AccessibleNewFromC(object.ToC())
}

// This function specifies the callback function to be called
// when the widget corresponding to a GtkAccessible is destroyed.
/*

C function : gtk_accessible_connect_widget_destroyed
*/
func (recv *Accessible) ConnectWidgetDestroyed() {
	C.gtk_accessible_connect_widget_destroyed((*C.GtkAccessible)(recv.native))

	return
}

// > In GTK+ 3.10, GtkAction has been deprecated. Use #GAction
// > instead, and associate actions with #GtkActionable widgets. Use
// > #GMenuModel for creating menus with gtk_menu_new_from_model().
//
// Actions represent operations that the user can be perform, along with
// some information how it should be presented in the interface. Each action
// provides methods to create icons, menu items and toolbar items
// representing itself.
//
// As well as the callback that is called when the action gets activated,
// the following also gets associated with the action:
//
// - a name (not translated, for path lookup)
//
// - a label (translated, for display)
//
// - an accelerator
//
// - whether label indicates a stock id
//
// - a tooltip (optional, translated)
//
// - a toolbar label (optional, shorter than label)
//
//
// The action will also have some state information:
//
// - visible (shown/hidden)
//
// - sensitive (enabled/disabled)
//
// Apart from regular actions, there are [toggle actions][GtkToggleAction],
// which can be toggled between two states and
// [radio actions][GtkRadioAction], of which only one in a group
// can be in the active state. Other actions can be implemented as #GtkAction
// subclasses.
//
// Each action can have one or more proxy widgets. To act as an action proxy,
// widget needs to implement #GtkActivatable interface. Proxies mirror the state
// of the action and should change when the actions state changes. Properties
// that are always mirrored by proxies are #GtkAction:sensitive and
// #GtkAction:visible. #GtkAction:gicon, #GtkAction:icon-name, #GtkAction:label,
// #GtkAction:short-label and #GtkAction:stock-id properties are only mirorred
// if proxy widget has #GtkActivatable:use-action-appearance property set to
// %TRUE.
//
// When the proxy is activated, it should activate its action.
/*

C record/class : GtkAction
*/
type Action struct {
	native *C.GtkAction
	// object : record
	// Private : private_data
}

func ActionNewFromC(u unsafe.Pointer) *Action {
	c := (*C.GtkAction)(u)
	if c == nil {
		return nil
	}

	g := &Action{native: c}

	return g
}

func (recv *Action) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Action) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Action.
// Exercise care, as this is a potentially dangerous function if the Object is not a Action.
func CastToAction(object *gobject.Object) *Action {
	return ActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by Action
func (recv *Action) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// GtkActionBar is designed to present contextual actions. It is
// expected to be displayed below the content and expand horizontally
// to fill the area.
//
// It allows placing children at the start or the end. In addition, it
// contains an internal centered box which is centered with respect to
// the full width of the box, even if the children at either side take
// up different amounts of space.
//
// # CSS nodes
//
// GtkActionBar has a single CSS node with name actionbar.
/*

C record/class : GtkActionBar
*/
type ActionBar struct {
	native *C.GtkActionBar
	// Private : bin
}

func ActionBarNewFromC(u unsafe.Pointer) *ActionBar {
	c := (*C.GtkActionBar)(u)
	if c == nil {
		return nil
	}

	g := &ActionBar{native: c}

	return g
}

func (recv *ActionBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ActionBar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ActionBar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ActionBar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ActionBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ActionBar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ActionBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a ActionBar.
func CastToActionBar(object *gobject.Object) *ActionBar {
	return ActionBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ActionBar
func (recv *ActionBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ActionBar
func (recv *ActionBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Actions are organised into groups. An action group is essentially a
// map from names to #GtkAction objects.
//
// All actions that would make sense to use in a particular context
// should be in a single group. Multiple action groups may be used for a
// particular user interface. In fact, it is expected that most nontrivial
// applications will make use of multiple groups. For example, in an
// application that can edit multiple documents, one group holding global
// actions (e.g. quit, about, new), and one group per document holding
// actions that act on that document (eg. save, cut/copy/paste, etc). Each
// windows menus would be constructed from a combination of two action
// groups.
//
// ## Accelerators ## {#Action-Accel}
//
// Accelerators are handled by the GTK+ accelerator map. All actions are
// assigned an accelerator path (which normally has the form
// `<Actions>/group-name/action-name`) and a shortcut is associated with
// this accelerator path. All menuitems and toolitems take on this accelerator
// path. The GTK+ accelerator map code makes sure that the correct shortcut
// is displayed next to the menu item.
//
// # GtkActionGroup as GtkBuildable # {#GtkActionGroup-BUILDER-UI}
//
// The #GtkActionGroup implementation of the #GtkBuildable interface accepts
// #GtkAction objects as <child> elements in UI definitions.
//
// Note that it is probably more common to define actions and action groups
// in the code, since they are directly related to what the code can do.
//
// The GtkActionGroup implementation of the GtkBuildable interface supports
// a custom <accelerator> element, which has attributes named key and
// modifiers and allows to specify accelerators. This is similar to the
// <accelerator> element of #GtkWidget, the main difference is that
// it doesnt allow you to specify a signal.
//
// ## A #GtkDialog UI definition fragment. ##
// |[
// <object class="GtkActionGroup" id="actiongroup">
// <child>
// <object class="GtkAction" id="About">
// <property name="name">About</property>
// <property name="stock_id">gtk-about</property>
// <signal handler="about_activate" name="activate"/>
// </object>
// <accelerator key="F1" modifiers="GDK_CONTROL_MASK | GDK_SHIFT_MASK"/>
// </child>
// </object>
// ]|
/*

C record/class : GtkActionGroup
*/
type ActionGroup struct {
	native *C.GtkActionGroup
	// parent : record
	// Private : priv
}

func ActionGroupNewFromC(u unsafe.Pointer) *ActionGroup {
	c := (*C.GtkActionGroup)(u)
	if c == nil {
		return nil
	}

	g := &ActionGroup{native: c}

	return g
}

func (recv *ActionGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *ActionGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to ActionGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a ActionGroup.
func CastToActionGroup(object *gobject.Object) *ActionGroup {
	return ActionGroupNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by ActionGroup
func (recv *ActionGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkAdjustment object represents a value which has an associated lower
// and upper bound, together with step and page increments, and a page size.
// It is used within several GTK+ widgets, including #GtkSpinButton, #GtkViewport,
// and #GtkRange (which is a base class for #GtkScrollbar and #GtkScale).
//
// The #GtkAdjustment object does not update the value itself. Instead
// it is left up to the owner of the #GtkAdjustment to control the value.
/*

C record/class : GtkAdjustment
*/
type Adjustment struct {
	native *C.GtkAdjustment
	// parent_instance : record
	// priv : record
}

func AdjustmentNewFromC(u unsafe.Pointer) *Adjustment {
	c := (*C.GtkAdjustment)(u)
	if c == nil {
		return nil
	}

	g := &Adjustment{native: c}

	return g
}

func (recv *Adjustment) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Adjustment) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Adjustment) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to Adjustment.
// Exercise care, as this is a potentially dangerous function if the Object is not a Adjustment.
func CastToAdjustment(object *gobject.Object) *Adjustment {
	return AdjustmentNewFromC(object.ToC())
}

type signalAdjustmentChangedDetail struct {
	callback  AdjustmentSignalChangedCallback
	handlerID C.gulong
}

var signalAdjustmentChangedId int
var signalAdjustmentChangedMap = make(map[int]signalAdjustmentChangedDetail)
var signalAdjustmentChangedLock sync.Mutex

// AdjustmentSignalChangedCallback is a callback function for a 'changed' signal emitted from a Adjustment.
type AdjustmentSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the Adjustment.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Adjustment) ConnectChanged(callback AdjustmentSignalChangedCallback) int {
	signalAdjustmentChangedLock.Lock()
	defer signalAdjustmentChangedLock.Unlock()

	signalAdjustmentChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Adjustment_signal_connect_changed(instance, C.gpointer(uintptr(signalAdjustmentChangedId)))

	detail := signalAdjustmentChangedDetail{callback, handlerID}
	signalAdjustmentChangedMap[signalAdjustmentChangedId] = detail

	return signalAdjustmentChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Adjustment.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Adjustment) DisconnectChanged(connectionID int) {
	signalAdjustmentChangedLock.Lock()
	defer signalAdjustmentChangedLock.Unlock()

	detail, exists := signalAdjustmentChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAdjustmentChangedMap, connectionID)
}

//export adjustment_changedHandler
func adjustment_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalAdjustmentChangedMap[index].callback
	callback()
}

type signalAdjustmentValueChangedDetail struct {
	callback  AdjustmentSignalValueChangedCallback
	handlerID C.gulong
}

var signalAdjustmentValueChangedId int
var signalAdjustmentValueChangedMap = make(map[int]signalAdjustmentValueChangedDetail)
var signalAdjustmentValueChangedLock sync.Mutex

// AdjustmentSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a Adjustment.
type AdjustmentSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the Adjustment.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *Adjustment) ConnectValueChanged(callback AdjustmentSignalValueChangedCallback) int {
	signalAdjustmentValueChangedLock.Lock()
	defer signalAdjustmentValueChangedLock.Unlock()

	signalAdjustmentValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Adjustment_signal_connect_value_changed(instance, C.gpointer(uintptr(signalAdjustmentValueChangedId)))

	detail := signalAdjustmentValueChangedDetail{callback, handlerID}
	signalAdjustmentValueChangedMap[signalAdjustmentValueChangedId] = detail

	return signalAdjustmentValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the Adjustment.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *Adjustment) DisconnectValueChanged(connectionID int) {
	signalAdjustmentValueChangedLock.Lock()
	defer signalAdjustmentValueChangedLock.Unlock()

	detail, exists := signalAdjustmentValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAdjustmentValueChangedMap, connectionID)
}

//export adjustment_valueChangedHandler
func adjustment_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalAdjustmentValueChangedMap[index].callback
	callback()
}

// Creates a new #GtkAdjustment.
/*

C function : gtk_adjustment_new
*/
func AdjustmentNew(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) *Adjustment {
	c_value := (C.gdouble)(value)

	c_lower := (C.gdouble)(lower)

	c_upper := (C.gdouble)(upper)

	c_step_increment := (C.gdouble)(stepIncrement)

	c_page_increment := (C.gdouble)(pageIncrement)

	c_page_size := (C.gdouble)(pageSize)

	retC := C.gtk_adjustment_new(c_value, c_lower, c_upper, c_step_increment, c_page_increment, c_page_size)
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Emits a #GtkAdjustment::changed signal from the #GtkAdjustment.
// This is typically called by the owner of the #GtkAdjustment after it has
// changed any of the #GtkAdjustment properties other than the value.
/*

C function : gtk_adjustment_changed
*/
func (recv *Adjustment) Changed() {
	C.gtk_adjustment_changed((*C.GtkAdjustment)(recv.native))

	return
}

// Updates the #GtkAdjustment:value property to ensure that the range
// between @lower and @upper is in the current page (i.e. between
// #GtkAdjustment:value and #GtkAdjustment:value + #GtkAdjustment:page-size).
// If the range is larger than the page size, then only the start of it will
// be in the current page.
//
// A #GtkAdjustment::value-changed signal will be emitted if the value is changed.
/*

C function : gtk_adjustment_clamp_page
*/
func (recv *Adjustment) ClampPage(lower float64, upper float64) {
	c_lower := (C.gdouble)(lower)

	c_upper := (C.gdouble)(upper)

	C.gtk_adjustment_clamp_page((*C.GtkAdjustment)(recv.native), c_lower, c_upper)

	return
}

// Gets the current value of the adjustment.
// See gtk_adjustment_set_value().
/*

C function : gtk_adjustment_get_value
*/
func (recv *Adjustment) GetValue() float64 {
	retC := C.gtk_adjustment_get_value((*C.GtkAdjustment)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Sets the #GtkAdjustment value. The value is clamped to lie between
// #GtkAdjustment:lower and #GtkAdjustment:upper.
//
// Note that for adjustments which are used in a #GtkScrollbar, the
// effective range of allowed values goes from #GtkAdjustment:lower to
// #GtkAdjustment:upper - #GtkAdjustment:page-size.
/*

C function : gtk_adjustment_set_value
*/
func (recv *Adjustment) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_adjustment_set_value((*C.GtkAdjustment)(recv.native), c_value)

	return
}

// Emits a #GtkAdjustment::value-changed signal from the #GtkAdjustment.
// This is typically called by the owner of the #GtkAdjustment after it has
// changed the #GtkAdjustment:value property.
/*

C function : gtk_adjustment_value_changed
*/
func (recv *Adjustment) ValueChanged() {
	C.gtk_adjustment_value_changed((*C.GtkAdjustment)(recv.native))

	return
}

// The #GtkAlignment widget controls the alignment and size of its child widget.
// It has four settings: xscale, yscale, xalign, and yalign.
//
// The scale settings are used to specify how much the child widget should
// expand to fill the space allocated to the #GtkAlignment.
// The values can range from 0 (meaning the child doesnt expand at all) to
// 1 (meaning the child expands to fill all of the available space).
//
// The align settings are used to place the child widget within the available
// area. The values range from 0 (top or left) to 1 (bottom or right).
// Of course, if the scale settings are both set to 1, the alignment settings
// have no effect.
//
// GtkAlignment has been deprecated in 3.14 and should not be used in
// newly-written code. The desired effect can be achieved by using the
// #GtkWidget:halign, #GtkWidget:valign and #GtkWidget:margin properties on the
// child widget.
/*

C record/class : GtkAlignment
*/
type Alignment struct {
	native *C.GtkAlignment
	// bin : record
	// Private : priv
}

func AlignmentNewFromC(u unsafe.Pointer) *Alignment {
	c := (*C.GtkAlignment)(u)
	if c == nil {
		return nil
	}

	g := &Alignment{native: c}

	return g
}

func (recv *Alignment) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Alignment) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Alignment) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Alignment) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Alignment) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Alignment) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Alignment.
// Exercise care, as this is a potentially dangerous function if the Object is not a Alignment.
func CastToAlignment(object *gobject.Object) *Alignment {
	return AlignmentNewFromC(object.ToC())
}

// Creates a new #GtkAlignment.
/*

C function : gtk_alignment_new
*/
func AlignmentNew(xalign float32, yalign float32, xscale float32, yscale float32) *Alignment {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_xscale := (C.gfloat)(xscale)

	c_yscale := (C.gfloat)(yscale)

	retC := C.gtk_alignment_new(c_xalign, c_yalign, c_xscale, c_yscale)
	retGo := AlignmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the #GtkAlignment values.
/*

C function : gtk_alignment_set
*/
func (recv *Alignment) Set(xalign float32, yalign float32, xscale float32, yscale float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_xscale := (C.gfloat)(xscale)

	c_yscale := (C.gfloat)(yscale)

	C.gtk_alignment_set((*C.GtkAlignment)(recv.native), c_xalign, c_yalign, c_xscale, c_yscale)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Alignment
func (recv *Alignment) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Alignment
func (recv *Alignment) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkAppChooserButton is a widget that lets the user select
// an application. It implements the #GtkAppChooser interface.
//
// Initially, a #GtkAppChooserButton selects the first application
// in its list, which will either be the most-recently used application
// or, if #GtkAppChooserButton:show-default-item is %TRUE, the
// default application.
//
// The list of applications shown in a #GtkAppChooserButton includes
// the recommended applications for the given content type. When
// #GtkAppChooserButton:show-default-item is set, the default application
// is also included. To let the user chooser other applications,
// you can set the #GtkAppChooserButton:show-dialog-item property,
// which allows to open a full #GtkAppChooserDialog.
//
// It is possible to add custom items to the list, using
// gtk_app_chooser_button_append_custom_item(). These items cause
// the #GtkAppChooserButton::custom-item-activated signal to be
// emitted when they are selected.
//
// To track changes in the selected application, use the
// #GtkComboBox::changed signal.
/*

C record/class : GtkAppChooserButton
*/
type AppChooserButton struct {
	native *C.GtkAppChooserButton
	// parent : record
	// Private : priv
}

func AppChooserButtonNewFromC(u unsafe.Pointer) *AppChooserButton {
	c := (*C.GtkAppChooserButton)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserButton{native: c}

	return g
}

func (recv *AppChooserButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ComboBox upcasts to *ComboBox
func (recv *AppChooserButton) ComboBox() *ComboBox {
	return ComboBoxNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *AppChooserButton) Bin() *Bin {
	return recv.ComboBox().Bin()
}

// Container upcasts to *Container
func (recv *AppChooserButton) Container() *Container {
	return recv.ComboBox().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserButton) Widget() *Widget {
	return recv.ComboBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ComboBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserButton) Object() *gobject.Object {
	return recv.ComboBox().Object()
}

// CastToWidget down casts any arbitary Object to AppChooserButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserButton.
func CastToAppChooserButton(object *gobject.Object) *AppChooserButton {
	return AppChooserButtonNewFromC(object.ToC())
}

// Unsupported signal 'custom-item-activated' for AppChooserButton : unsupported parameter item_name : type utf8 :

// Returns the text to display at the top of the dialog.
/*

C function : gtk_app_chooser_button_get_heading
*/
func (recv *AppChooserButton) GetHeading() string {
	retC := C.gtk_app_chooser_button_get_heading((*C.GtkAppChooserButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Sets the text to display at the top of the dialog.
// If the heading is not set, the dialog displays a default text.
/*

C function : gtk_app_chooser_button_set_heading
*/
func (recv *AppChooserButton) SetHeading(heading string) {
	c_heading := C.CString(heading)
	defer C.free(unsafe.Pointer(c_heading))

	C.gtk_app_chooser_button_set_heading((*C.GtkAppChooserButton)(recv.native), c_heading)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserButton
func (recv *AppChooserButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserButton
func (recv *AppChooserButton) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserButton
func (recv *AppChooserButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by AppChooserButton
func (recv *AppChooserButton) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by AppChooserButton
func (recv *AppChooserButton) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// #GtkAppChooserDialog shows a #GtkAppChooserWidget inside a #GtkDialog.
//
// Note that #GtkAppChooserDialog does not have any interesting methods
// of its own. Instead, you should get the embedded #GtkAppChooserWidget
// using gtk_app_chooser_dialog_get_widget() and call its methods if
// the generic #GtkAppChooser interface is not sufficient for your needs.
//
// To set the heading that is shown above the #GtkAppChooserWidget,
// use gtk_app_chooser_dialog_set_heading().
/*

C record/class : GtkAppChooserDialog
*/
type AppChooserDialog struct {
	native *C.GtkAppChooserDialog
	// parent : record
	// Private : priv
}

func AppChooserDialogNewFromC(u unsafe.Pointer) *AppChooserDialog {
	c := (*C.GtkAppChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserDialog{native: c}

	return g
}

func (recv *AppChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *AppChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *AppChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *AppChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *AppChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to AppChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserDialog.
func CastToAppChooserDialog(object *gobject.Object) *AppChooserDialog {
	return AppChooserDialogNewFromC(object.ToC())
}

// Returns the text to display at the top of the dialog.
/*

C function : gtk_app_chooser_dialog_get_heading
*/
func (recv *AppChooserDialog) GetHeading() string {
	retC := C.gtk_app_chooser_dialog_get_heading((*C.GtkAppChooserDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Sets the text to display at the top of the dialog.
// If the heading is not set, the dialog displays a default text.
/*

C function : gtk_app_chooser_dialog_set_heading
*/
func (recv *AppChooserDialog) SetHeading(heading string) {
	c_heading := C.CString(heading)
	defer C.free(unsafe.Pointer(c_heading))

	C.gtk_app_chooser_dialog_set_heading((*C.GtkAppChooserDialog)(recv.native), c_heading)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserDialog
func (recv *AppChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserDialog
func (recv *AppChooserDialog) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserDialog
func (recv *AppChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkAppChooserWidget is a widget for selecting applications.
// It is the main building block for #GtkAppChooserDialog. Most
// applications only need to use the latter; but you can use
// this widget as part of a larger widget if you have special needs.
//
// #GtkAppChooserWidget offers detailed control over what applications
// are shown, using the
// #GtkAppChooserWidget:show-default,
// #GtkAppChooserWidget:show-recommended,
// #GtkAppChooserWidget:show-fallback,
// #GtkAppChooserWidget:show-other and
// #GtkAppChooserWidget:show-all
// properties. See the #GtkAppChooser documentation for more information
// about these groups of applications.
//
// To keep track of the selected application, use the
// #GtkAppChooserWidget::application-selected and #GtkAppChooserWidget::application-activated signals.
//
// # CSS nodes
//
// GtkAppChooserWidget has a single CSS node with name appchooser.
/*

C record/class : GtkAppChooserWidget
*/
type AppChooserWidget struct {
	native *C.GtkAppChooserWidget
	// parent : record
	// Private : priv
}

func AppChooserWidgetNewFromC(u unsafe.Pointer) *AppChooserWidget {
	c := (*C.GtkAppChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserWidget{native: c}

	return g
}

func (recv *AppChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *AppChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *AppChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to AppChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserWidget.
func CastToAppChooserWidget(object *gobject.Object) *AppChooserWidget {
	return AppChooserWidgetNewFromC(object.ToC())
}

type signalAppChooserWidgetApplicationActivatedDetail struct {
	callback  AppChooserWidgetSignalApplicationActivatedCallback
	handlerID C.gulong
}

var signalAppChooserWidgetApplicationActivatedId int
var signalAppChooserWidgetApplicationActivatedMap = make(map[int]signalAppChooserWidgetApplicationActivatedDetail)
var signalAppChooserWidgetApplicationActivatedLock sync.Mutex

// AppChooserWidgetSignalApplicationActivatedCallback is a callback function for a 'application-activated' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalApplicationActivatedCallback func(application *gio.AppInfo)

/*
ConnectApplicationActivated connects the callback to the 'application-activated' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectApplicationActivated to remove it.
*/
func (recv *AppChooserWidget) ConnectApplicationActivated(callback AppChooserWidgetSignalApplicationActivatedCallback) int {
	signalAppChooserWidgetApplicationActivatedLock.Lock()
	defer signalAppChooserWidgetApplicationActivatedLock.Unlock()

	signalAppChooserWidgetApplicationActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_application_activated(instance, C.gpointer(uintptr(signalAppChooserWidgetApplicationActivatedId)))

	detail := signalAppChooserWidgetApplicationActivatedDetail{callback, handlerID}
	signalAppChooserWidgetApplicationActivatedMap[signalAppChooserWidgetApplicationActivatedId] = detail

	return signalAppChooserWidgetApplicationActivatedId
}

/*
DisconnectApplicationActivated disconnects a callback from the 'application-activated' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectApplicationActivated.
*/
func (recv *AppChooserWidget) DisconnectApplicationActivated(connectionID int) {
	signalAppChooserWidgetApplicationActivatedLock.Lock()
	defer signalAppChooserWidgetApplicationActivatedLock.Unlock()

	detail, exists := signalAppChooserWidgetApplicationActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetApplicationActivatedMap, connectionID)
}

//export appchooserwidget_applicationActivatedHandler
func appchooserwidget_applicationActivatedHandler(_ *C.GObject, c_application *C.GAppInfo, data C.gpointer) {
	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetApplicationActivatedMap[index].callback
	callback(application)
}

type signalAppChooserWidgetApplicationSelectedDetail struct {
	callback  AppChooserWidgetSignalApplicationSelectedCallback
	handlerID C.gulong
}

var signalAppChooserWidgetApplicationSelectedId int
var signalAppChooserWidgetApplicationSelectedMap = make(map[int]signalAppChooserWidgetApplicationSelectedDetail)
var signalAppChooserWidgetApplicationSelectedLock sync.Mutex

// AppChooserWidgetSignalApplicationSelectedCallback is a callback function for a 'application-selected' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalApplicationSelectedCallback func(application *gio.AppInfo)

/*
ConnectApplicationSelected connects the callback to the 'application-selected' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectApplicationSelected to remove it.
*/
func (recv *AppChooserWidget) ConnectApplicationSelected(callback AppChooserWidgetSignalApplicationSelectedCallback) int {
	signalAppChooserWidgetApplicationSelectedLock.Lock()
	defer signalAppChooserWidgetApplicationSelectedLock.Unlock()

	signalAppChooserWidgetApplicationSelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_application_selected(instance, C.gpointer(uintptr(signalAppChooserWidgetApplicationSelectedId)))

	detail := signalAppChooserWidgetApplicationSelectedDetail{callback, handlerID}
	signalAppChooserWidgetApplicationSelectedMap[signalAppChooserWidgetApplicationSelectedId] = detail

	return signalAppChooserWidgetApplicationSelectedId
}

/*
DisconnectApplicationSelected disconnects a callback from the 'application-selected' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectApplicationSelected.
*/
func (recv *AppChooserWidget) DisconnectApplicationSelected(connectionID int) {
	signalAppChooserWidgetApplicationSelectedLock.Lock()
	defer signalAppChooserWidgetApplicationSelectedLock.Unlock()

	detail, exists := signalAppChooserWidgetApplicationSelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetApplicationSelectedMap, connectionID)
}

//export appchooserwidget_applicationSelectedHandler
func appchooserwidget_applicationSelectedHandler(_ *C.GObject, c_application *C.GAppInfo, data C.gpointer) {
	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetApplicationSelectedMap[index].callback
	callback(application)
}

type signalAppChooserWidgetPopulatePopupDetail struct {
	callback  AppChooserWidgetSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalAppChooserWidgetPopulatePopupId int
var signalAppChooserWidgetPopulatePopupMap = make(map[int]signalAppChooserWidgetPopulatePopupDetail)
var signalAppChooserWidgetPopulatePopupLock sync.Mutex

// AppChooserWidgetSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalPopulatePopupCallback func(menu *Menu, application *gio.AppInfo)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *AppChooserWidget) ConnectPopulatePopup(callback AppChooserWidgetSignalPopulatePopupCallback) int {
	signalAppChooserWidgetPopulatePopupLock.Lock()
	defer signalAppChooserWidgetPopulatePopupLock.Unlock()

	signalAppChooserWidgetPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalAppChooserWidgetPopulatePopupId)))

	detail := signalAppChooserWidgetPopulatePopupDetail{callback, handlerID}
	signalAppChooserWidgetPopulatePopupMap[signalAppChooserWidgetPopulatePopupId] = detail

	return signalAppChooserWidgetPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *AppChooserWidget) DisconnectPopulatePopup(connectionID int) {
	signalAppChooserWidgetPopulatePopupLock.Lock()
	defer signalAppChooserWidgetPopulatePopupLock.Unlock()

	detail, exists := signalAppChooserWidgetPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetPopulatePopupMap, connectionID)
}

//export appchooserwidget_populatePopupHandler
func appchooserwidget_populatePopupHandler(_ *C.GObject, c_menu *C.GtkMenu, c_application *C.GAppInfo, data C.gpointer) {
	menu := MenuNewFromC(unsafe.Pointer(c_menu))

	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetPopulatePopupMap[index].callback
	callback(menu, application)
}

// Sets the text that is shown if there are not applications
// that can handle the content type.
/*

C function : gtk_app_chooser_widget_set_default_text
*/
func (recv *AppChooserWidget) SetDefaultText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_app_chooser_widget_set_default_text((*C.GtkAppChooserWidget)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserWidget
func (recv *AppChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserWidget
func (recv *AppChooserWidget) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserWidget
func (recv *AppChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by AppChooserWidget
func (recv *AppChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// #GtkApplication is a class that handles many important aspects
// of a GTK+ application in a convenient fashion, without enforcing
// a one-size-fits-all application model.
//
// Currently, GtkApplication handles GTK+ initialization, application
// uniqueness, session management, provides some basic scriptability and
// desktop shell integration by exporting actions and menus and manages a
// list of toplevel windows whose life-cycle is automatically tied to the
// life-cycle of your application.
//
// While GtkApplication works fine with plain #GtkWindows, it is recommended
// to use it together with #GtkApplicationWindow.
//
// When GDK threads are enabled, GtkApplication will acquire the GDK
// lock when invoking actions that arrive from other processes.  The GDK
// lock is not touched for local action invocations.  In order to have
// actions invoked in a predictable context it is therefore recommended
// that the GDK lock be held while invoking actions locally with
// g_action_group_activate_action().  The same applies to actions
// associated with #GtkApplicationWindow and to the activate and
// open #GApplication methods.
//
// ## Automatic resources ## {#automatic-resources}
//
// #GtkApplication will automatically load menus from the #GtkBuilder
// resource located at "gtk/menus.ui", relative to the application's
// resource base path (see g_application_set_resource_base_path()).  The
// menu with the ID "app-menu" is taken as the application's app menu
// and the menu with the ID "menubar" is taken as the application's
// menubar.  Additional menus (most interesting submenus) can be named
// and accessed via gtk_application_get_menu_by_id() which allows for
// dynamic population of a part of the menu structure.
//
// If the resources "gtk/menus-appmenu.ui" or "gtk/menus-traditional.ui" are
// present then these files will be used in preference, depending on the value
// of gtk_application_prefers_app_menu(). If the resource "gtk/menus-common.ui"
// is present it will be loaded as well. This is useful for storing items that
// are referenced from both "gtk/menus-appmenu.ui" and
// "gtk/menus-traditional.ui".
//
// It is also possible to provide the menus manually using
// gtk_application_set_app_menu() and gtk_application_set_menubar().
//
// #GtkApplication will also automatically setup an icon search path for
// the default icon theme by appending "icons" to the resource base
// path.  This allows your application to easily store its icons as
// resources.  See gtk_icon_theme_add_resource_path() for more
// information.
//
// If there is a resource located at "gtk/help-overlay.ui" which
// defines a #GtkShortcutsWindow with ID "help_overlay" then GtkApplication
// associates an instance of this shortcuts window with each
// #GtkApplicationWindow and sets up keyboard accelerators (Control-F1
// and Control-?) to open it. To create a menu item that displays the
// shortcuts window, associate the item with the action win.show-help-overlay.
//
// ## A simple application ## {#gtkapplication}
//
// [A simple example](https://git.gnome.org/browse/gtk+/tree/examples/bp/bloatpad.c)
//
// GtkApplication optionally registers with a session manager
// of the users session (if you set the #GtkApplication:register-session
// property) and offers various functionality related to the session
// life-cycle.
//
// An application can block various ways to end the session with
// the gtk_application_inhibit() function. Typical use cases for
// this kind of inhibiting are long-running, uninterruptible operations,
// such as burning a CD or performing a disk backup. The session
// manager may not honor the inhibitor, but it can be expected to
// inform the user about the negative consequences of ending the
// session while inhibitors are present.
//
// ## See Also ## {#seealso}
// [HowDoI: Using GtkApplication](https://wiki.gnome.org/HowDoI/GtkApplication),
// [Getting Started with GTK+: Basics](https://developer.gnome.org/gtk3/stable/gtk-getting-started.html#id-1.2.3.3)
/*

C record/class : GtkApplication
*/
type Application struct {
	native *C.GtkApplication
	// parent : record
	// Private : priv
}

func ApplicationNewFromC(u unsafe.Pointer) *Application {
	c := (*C.GtkApplication)(u)
	if c == nil {
		return nil
	}

	g := &Application{native: c}

	return g
}

func (recv *Application) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Application upcasts to *Application
func (recv *Application) Application() *gio.Application {
	return gio.ApplicationNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Application) Object() *gobject.Object {
	return recv.Application().Object()
}

// CastToWidget down casts any arbitary Object to Application.
// Exercise care, as this is a potentially dangerous function if the Object is not a Application.
func CastToApplication(object *gobject.Object) *Application {
	return ApplicationNewFromC(object.ToC())
}

// ActionGroup returns the ActionGroup interface implemented by Application
func (recv *Application) ActionGroup() *gio.ActionGroup {
	return gio.ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by Application
func (recv *Application) ActionMap() *gio.ActionMap {
	return gio.ActionMapNewFromC(recv.ToC())
}

// #GtkApplicationWindow is a #GtkWindow subclass that offers some
// extra functionality for better integration with #GtkApplication
// features.  Notably, it can handle both the application menu as well
// as the menubar. See gtk_application_set_app_menu() and
// gtk_application_set_menubar().
//
// This class implements the #GActionGroup and #GActionMap interfaces,
// to let you add window-specific actions that will be exported by the
// associated #GtkApplication, together with its application-wide
// actions.  Window-specific actions are prefixed with the win.
// prefix and application-wide actions are prefixed with the app.
// prefix.  Actions must be addressed with the prefixed name when
// referring to them from a #GMenuModel.
//
// Note that widgets that are placed inside a #GtkApplicationWindow
// can also activate these actions, if they implement the
// #GtkActionable interface.
//
// As with #GtkApplication, the GDK lock will be acquired when
// processing actions arriving from other processes and should therefore
// be held when activating actions locally (if GDK threads are enabled).
//
// The settings #GtkSettings:gtk-shell-shows-app-menu and
// #GtkSettings:gtk-shell-shows-menubar tell GTK+ whether the
// desktop environment is showing the application menu and menubar
// models outside the application as part of the desktop shell.
// For instance, on OS X, both menus will be displayed remotely;
// on Windows neither will be. gnome-shell (starting with version 3.4)
// will display the application menu, but not the menubar.
//
// If the desktop environment does not display the menubar, then
// #GtkApplicationWindow will automatically show a #GtkMenuBar for it.
// This behaviour can be overridden with the #GtkApplicationWindow:show-menubar
// property. If the desktop environment does not display the application
// menu, then it will automatically be included in the menubar or in the
// windows client-side decorations.
//
// ## A GtkApplicationWindow with a menubar
//
// |[<!-- language="C" -->
// GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
//
// GtkBuilder *builder = gtk_builder_new_from_string (
// "<interface>"
// "  <menu id='menubar'>"
// "    <submenu label='_Edit'>"
// "      <item label='_Copy' action='win.copy'/>"
// "      <item label='_Paste' action='win.paste'/>"
// "    </submenu>"
// "  </menu>"
// "</interface>",
// -1);
//
// GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
// "menubar"));
// gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
// g_object_unref (builder);
//
// ...
//
// GtkWidget *window = gtk_application_window_new (app);
// ]|
//
// ## Handling fallback yourself
//
// [A simple example](https://git.gnome.org/browse/gtk+/tree/examples/sunny.c)
//
// The XML format understood by #GtkBuilder for #GMenuModel consists
// of a toplevel `<menu>` element, which contains one or more `<item>`
// elements. Each `<item>` element contains `<attribute>` and `<link>`
// elements with a mandatory name attribute. `<link>` elements have the
// same content model as `<menu>`. Instead of `<link name="submenu>` or
// `<link name="section">`, you can use `<submenu>` or `<section>`
// elements.
//
// Attribute values can be translated using gettext, like other #GtkBuilder
// content. `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the #GtkBuilder must have been given the gettext
// domain to use.
//
// The following attributes are used when constructing menu items:
// - "label": a user-visible string to display
// - "action": the prefixed name of the action to trigger
// - "target": the parameter to use when activating the action
// - "icon" and "verb-icon": names of icons that may be displayed
// - "submenu-action": name of an action that may be used to determine
// if a submenu can be opened
// - "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
//
// The following attributes are used when constructing sections:
// - "label": a user-visible string to use as section heading
// - "display-hint": a string used to determine special formatting for the section.
// Possible values include "horizontal-buttons".
// - "text-direction": a string used to determine the #GtkTextDirection to use
// when "display-hint" is set to "horizontal-buttons". Possible values
// include "rtl", "ltr", and "none".
//
// The following attributes are used when constructing submenus:
// - "label": a user-visible string to display
// - "icon": icon name to display
/*

C record/class : GtkApplicationWindow
*/
type ApplicationWindow struct {
	native *C.GtkApplicationWindow
	// parent_instance : record
	// Private : priv
}

func ApplicationWindowNewFromC(u unsafe.Pointer) *ApplicationWindow {
	c := (*C.GtkApplicationWindow)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationWindow{native: c}

	return g
}

func (recv *ApplicationWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Window upcasts to *Window
func (recv *ApplicationWindow) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ApplicationWindow) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *ApplicationWindow) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *ApplicationWindow) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ApplicationWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ApplicationWindow) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitary Object to ApplicationWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ApplicationWindow.
func CastToApplicationWindow(object *gobject.Object) *ApplicationWindow {
	return ApplicationWindowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// ActionGroup returns the ActionGroup interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ActionGroup() *gio.ActionGroup {
	return gio.ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ActionMap() *gio.ActionMap {
	return gio.ActionMapNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ApplicationWindow
func (recv *ApplicationWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// GtkArrow should be used to draw simple arrows that need to point in
// one of the four cardinal directions (up, down, left, or right).  The
// style of the arrow can be one of shadow in, shadow out, etched in, or
// etched out.  Note that these directions and style types may be
// amended in versions of GTK+ to come.
//
// GtkArrow will fill any space alloted to it, but since it is inherited
// from #GtkMisc, it can be padded and/or aligned, to fill exactly the
// space the programmer desires.
//
// Arrows are created with a call to gtk_arrow_new().  The direction or
// style of an arrow can be changed after creation by using gtk_arrow_set().
//
// GtkArrow has been deprecated; you can simply use a #GtkImage with a
// suitable icon name, such as pan-down-symbolic. When replacing
// GtkArrow by an image, pay attention to the fact that GtkArrow is
// doing automatic flipping between #GTK_ARROW_LEFT and #GTK_ARROW_RIGHT,
// depending on the text direction. To get the same effect with an image,
// use the icon names pan-start-symbolic and pan-end-symbolic, which
// react to the text direction.
/*

C record/class : GtkArrow
*/
type Arrow struct {
	native *C.GtkArrow
	// misc : record
	// Private : priv
}

func ArrowNewFromC(u unsafe.Pointer) *Arrow {
	c := (*C.GtkArrow)(u)
	if c == nil {
		return nil
	}

	g := &Arrow{native: c}

	return g
}

func (recv *Arrow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Misc upcasts to *Misc
func (recv *Arrow) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Arrow) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Arrow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Arrow) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitary Object to Arrow.
// Exercise care, as this is a potentially dangerous function if the Object is not a Arrow.
func CastToArrow(object *gobject.Object) *Arrow {
	return ArrowNewFromC(object.ToC())
}

// Creates a new #GtkArrow widget.
/*

C function : gtk_arrow_new
*/
func ArrowNew(arrowType ArrowType, shadowType ShadowType) *Arrow {
	c_arrow_type := (C.GtkArrowType)(arrowType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	retC := C.gtk_arrow_new(c_arrow_type, c_shadow_type)
	retGo := ArrowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the direction and style of the #GtkArrow, @arrow.
/*

C function : gtk_arrow_set
*/
func (recv *Arrow) Set(arrowType ArrowType, shadowType ShadowType) {
	c_arrow_type := (C.GtkArrowType)(arrowType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	C.gtk_arrow_set((*C.GtkArrow)(recv.native), c_arrow_type, c_shadow_type)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Arrow
func (recv *Arrow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Arrow
func (recv *Arrow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkArrowAccessible
*/
type ArrowAccessible struct {
	native *C.GtkArrowAccessible
	// parent : record
	// priv : record
}

func ArrowAccessibleNewFromC(u unsafe.Pointer) *ArrowAccessible {
	c := (*C.GtkArrowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ArrowAccessible{native: c}

	return g
}

func (recv *ArrowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ArrowAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ArrowAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ArrowAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ArrowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ArrowAccessible.
func CastToArrowAccessible(object *gobject.Object) *ArrowAccessible {
	return ArrowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ArrowAccessible
func (recv *ArrowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ArrowAccessible
func (recv *ArrowAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// The #GtkAspectFrame is useful when you want
// pack a widget so that it can resize but always retains
// the same aspect ratio. For instance, one might be
// drawing a small preview of a larger image. #GtkAspectFrame
// derives from #GtkFrame, so it can draw a label and
// a frame around the child. The frame will be
// shrink-wrapped to the size of the child.
//
// # CSS nodes
//
// GtkAspectFrame uses a CSS node with name frame.
/*

C record/class : GtkAspectFrame
*/
type AspectFrame struct {
	native *C.GtkAspectFrame
	// frame : record
	// Private : priv
}

func AspectFrameNewFromC(u unsafe.Pointer) *AspectFrame {
	c := (*C.GtkAspectFrame)(u)
	if c == nil {
		return nil
	}

	g := &AspectFrame{native: c}

	return g
}

func (recv *AspectFrame) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Frame upcasts to *Frame
func (recv *AspectFrame) Frame() *Frame {
	return FrameNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *AspectFrame) Bin() *Bin {
	return recv.Frame().Bin()
}

// Container upcasts to *Container
func (recv *AspectFrame) Container() *Container {
	return recv.Frame().Container()
}

// Widget upcasts to *Widget
func (recv *AspectFrame) Widget() *Widget {
	return recv.Frame().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AspectFrame) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Frame().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AspectFrame) Object() *gobject.Object {
	return recv.Frame().Object()
}

// CastToWidget down casts any arbitary Object to AspectFrame.
// Exercise care, as this is a potentially dangerous function if the Object is not a AspectFrame.
func CastToAspectFrame(object *gobject.Object) *AspectFrame {
	return AspectFrameNewFromC(object.ToC())
}

// Create a new #GtkAspectFrame.
/*

C function : gtk_aspect_frame_new
*/
func AspectFrameNew(label string, xalign float32, yalign float32, ratio float32, obeyChild bool) *AspectFrame {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_ratio := (C.gfloat)(ratio)

	c_obey_child :=
		boolToGboolean(obeyChild)

	retC := C.gtk_aspect_frame_new(c_label, c_xalign, c_yalign, c_ratio, c_obey_child)
	retGo := AspectFrameNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Set parameters for an existing #GtkAspectFrame.
/*

C function : gtk_aspect_frame_set
*/
func (recv *AspectFrame) Set(xalign float32, yalign float32, ratio float32, obeyChild bool) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_ratio := (C.gfloat)(ratio)

	c_obey_child :=
		boolToGboolean(obeyChild)

	C.gtk_aspect_frame_set((*C.GtkAspectFrame)(recv.native), c_xalign, c_yalign, c_ratio, c_obey_child)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AspectFrame
func (recv *AspectFrame) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AspectFrame
func (recv *AspectFrame) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A #GtkAssistant is a widget used to represent a generally complex
// operation splitted in several steps, guiding the user through its
// pages and controlling the page flow to collect the necessary data.
//
// The design of GtkAssistant is that it controls what buttons to show
// and to make sensitive, based on what it knows about the page sequence
// and the [type][GtkAssistantPageType] of each page,
// in addition to state information like the page
// [completion][gtk-assistant-set-page-complete]
// and [committed][gtk-assistant-commit] status.
//
// If you have a case that doesnt quite fit in #GtkAssistants way of
// handling buttons, you can use the #GTK_ASSISTANT_PAGE_CUSTOM page
// type and handle buttons yourself.
//
// # GtkAssistant as GtkBuildable
//
// The GtkAssistant implementation of the #GtkBuildable interface
// exposes the @action_area as internal children with the name
// action_area.
//
// To add pages to an assistant in #GtkBuilder, simply add it as a
// child to the GtkAssistant object, and set its child properties
// as necessary.
//
// # CSS nodes
//
// GtkAssistant has a single CSS node with the name assistant.
/*

C record/class : GtkAssistant
*/
type Assistant struct {
	native *C.GtkAssistant
	// parent : record
	// Private : priv
}

func AssistantNewFromC(u unsafe.Pointer) *Assistant {
	c := (*C.GtkAssistant)(u)
	if c == nil {
		return nil
	}

	g := &Assistant{native: c}

	return g
}

func (recv *Assistant) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Window upcasts to *Window
func (recv *Assistant) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *Assistant) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *Assistant) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *Assistant) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Assistant) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Assistant) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitary Object to Assistant.
// Exercise care, as this is a potentially dangerous function if the Object is not a Assistant.
func CastToAssistant(object *gobject.Object) *Assistant {
	return AssistantNewFromC(object.ToC())
}

type signalAssistantEscapeDetail struct {
	callback  AssistantSignalEscapeCallback
	handlerID C.gulong
}

var signalAssistantEscapeId int
var signalAssistantEscapeMap = make(map[int]signalAssistantEscapeDetail)
var signalAssistantEscapeLock sync.Mutex

// AssistantSignalEscapeCallback is a callback function for a 'escape' signal emitted from a Assistant.
type AssistantSignalEscapeCallback func()

/*
ConnectEscape connects the callback to the 'escape' signal for the Assistant.

The returned value represents the connection, and may be passed to DisconnectEscape to remove it.
*/
func (recv *Assistant) ConnectEscape(callback AssistantSignalEscapeCallback) int {
	signalAssistantEscapeLock.Lock()
	defer signalAssistantEscapeLock.Unlock()

	signalAssistantEscapeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Assistant_signal_connect_escape(instance, C.gpointer(uintptr(signalAssistantEscapeId)))

	detail := signalAssistantEscapeDetail{callback, handlerID}
	signalAssistantEscapeMap[signalAssistantEscapeId] = detail

	return signalAssistantEscapeId
}

/*
DisconnectEscape disconnects a callback from the 'escape' signal for the Assistant.

The connectionID should be a value returned from a call to ConnectEscape.
*/
func (recv *Assistant) DisconnectEscape(connectionID int) {
	signalAssistantEscapeLock.Lock()
	defer signalAssistantEscapeLock.Unlock()

	detail, exists := signalAssistantEscapeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAssistantEscapeMap, connectionID)
}

//export assistant_escapeHandler
func assistant_escapeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalAssistantEscapeMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Assistant
func (recv *Assistant) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Assistant
func (recv *Assistant) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkBin widget is a container with just one child.
// It is not very useful itself, but it is useful for deriving subclasses,
// since it provides common code needed for handling a single child widget.
//
// Many GTK+ widgets are subclasses of #GtkBin, including #GtkWindow,
// #GtkButton, #GtkFrame, #GtkHandleBox or #GtkScrolledWindow.
/*

C record/class : GtkBin
*/
type Bin struct {
	native *C.GtkBin
	// container : record
	// Private : priv
}

func BinNewFromC(u unsafe.Pointer) *Bin {
	c := (*C.GtkBin)(u)
	if c == nil {
		return nil
	}

	g := &Bin{native: c}

	return g
}

func (recv *Bin) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Bin) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Bin) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Bin) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Bin) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Bin.
// Exercise care, as this is a potentially dangerous function if the Object is not a Bin.
func CastToBin(object *gobject.Object) *Bin {
	return BinNewFromC(object.ToC())
}

// Gets the child of the #GtkBin, or %NULL if the bin contains
// no child widget. The returned widget does not have a reference
// added, so you do not need to unref it.
/*

C function : gtk_bin_get_child
*/
func (recv *Bin) GetChild() *Widget {
	retC := C.gtk_bin_get_child((*C.GtkBin)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Bin
func (recv *Bin) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Bin
func (recv *Bin) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkBooleanCellAccessible
*/
type BooleanCellAccessible struct {
	native *C.GtkBooleanCellAccessible
	// parent : record
	// priv : record
}

func BooleanCellAccessibleNewFromC(u unsafe.Pointer) *BooleanCellAccessible {
	c := (*C.GtkBooleanCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &BooleanCellAccessible{native: c}

	return g
}

func (recv *BooleanCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *BooleanCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *BooleanCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *BooleanCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *BooleanCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to BooleanCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a BooleanCellAccessible.
func CastToBooleanCellAccessible(object *gobject.Object) *BooleanCellAccessible {
	return BooleanCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by BooleanCellAccessible
func (recv *BooleanCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by BooleanCellAccessible
func (recv *BooleanCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// The GtkBox widget organizes child widgets into a rectangular area.
//
// The rectangular area of a GtkBox is organized into either a single row
// or a single column of child widgets depending upon the orientation.
// Thus, all children of a GtkBox are allocated one dimension in common,
// which is the height of a row, or the width of a column.
//
// GtkBox uses a notion of packing. Packing refers
// to adding widgets with reference to a particular position in a
// #GtkContainer. For a GtkBox, there are two reference positions: the
// start and the end of the box.
// For a vertical #GtkBox, the start is defined as the top of the box and
// the end is defined as the bottom. For a horizontal #GtkBox the start
// is defined as the left side and the end is defined as the right side.
//
// Use repeated calls to gtk_box_pack_start() to pack widgets into a
// GtkBox from start to end. Use gtk_box_pack_end() to add widgets from
// end to start. You may intersperse these calls and add widgets from
// both ends of the same GtkBox.
//
// Because GtkBox is a #GtkContainer, you may also use gtk_container_add()
// to insert widgets into the box, and they will be packed with the default
// values for expand and fill child properties. Use gtk_container_remove()
// to remove widgets from the GtkBox.
//
// Use gtk_box_set_homogeneous() to specify whether or not all children
// of the GtkBox are forced to get the same amount of space.
//
// Use gtk_box_set_spacing() to determine how much space will be
// minimally placed between all children in the GtkBox. Note that
// spacing is added between the children, while
// padding added by gtk_box_pack_start() or gtk_box_pack_end() is added
// on either side of the widget it belongs to.
//
// Use gtk_box_reorder_child() to move a GtkBox child to a different
// place in the box.
//
// Use gtk_box_set_child_packing() to reset the expand,
// fill and padding child properties.
// Use gtk_box_query_child_packing() to query these fields.
//
// Note that a single-row or single-column #GtkGrid provides exactly
// the same functionality as #GtkBox.
//
// # CSS nodes
//
// GtkBox uses a single CSS node with name box.
//
// In horizontal orientation, the nodes of the children are always arranged
// from left to right. So :first-child will always select the leftmost child,
// regardless of text direction.
/*

C record/class : GtkBox
*/
type Box struct {
	native *C.GtkBox
	// container : record
	// Private : priv
}

func BoxNewFromC(u unsafe.Pointer) *Box {
	c := (*C.GtkBox)(u)
	if c == nil {
		return nil
	}

	g := &Box{native: c}

	return g
}

func (recv *Box) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Box) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Box) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Box) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Box) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Box.
// Exercise care, as this is a potentially dangerous function if the Object is not a Box.
func CastToBox(object *gobject.Object) *Box {
	return BoxNewFromC(object.ToC())
}

// Returns whether the box is homogeneous (all children are the
// same size). See gtk_box_set_homogeneous().
/*

C function : gtk_box_get_homogeneous
*/
func (recv *Box) GetHomogeneous() bool {
	retC := C.gtk_box_get_homogeneous((*C.GtkBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_box_set_spacing().
/*

C function : gtk_box_get_spacing
*/
func (recv *Box) GetSpacing() int32 {
	retC := C.gtk_box_get_spacing((*C.GtkBox)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Adds @child to @box, packed with reference to the end of @box.
// The @child is packed after (away from end of) any other child
// packed with reference to the end of @box.
/*

C function : gtk_box_pack_end
*/
func (recv *Box) PackEnd(child *Widget, expand bool, fill bool, padding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	C.gtk_box_pack_end((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding)

	return
}

// Adds @child to @box, packed with reference to the start of @box.
// The @child is packed after any other child packed with reference
// to the start of @box.
/*

C function : gtk_box_pack_start
*/
func (recv *Box) PackStart(child *Widget, expand bool, fill bool, padding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	C.gtk_box_pack_start((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding)

	return
}

// Unsupported : gtk_box_query_child_packing : unsupported parameter pack_type : GtkPackType* with indirection level of 1

// Moves @child to a new @position in the list of @box children.
// The list contains widgets packed #GTK_PACK_START
// as well as widgets packed #GTK_PACK_END, in the order that these
// widgets were added to @box.
//
// A widgets position in the @box children list determines where
// the widget is packed into @box.  A child widget at some position
// in the list will be packed just after all other widgets of the
// same packing type that appear earlier in the list.
/*

C function : gtk_box_reorder_child
*/
func (recv *Box) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_box_reorder_child((*C.GtkBox)(recv.native), c_child, c_position)

	return
}

// Sets the way @child is packed into @box.
/*

C function : gtk_box_set_child_packing
*/
func (recv *Box) SetChildPacking(child *Widget, expand bool, fill bool, padding uint32, packType PackType) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	c_pack_type := (C.GtkPackType)(packType)

	C.gtk_box_set_child_packing((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding, c_pack_type)

	return
}

// Sets the #GtkBox:homogeneous property of @box, controlling
// whether or not all children of @box are given equal space
// in the box.
/*

C function : gtk_box_set_homogeneous
*/
func (recv *Box) SetHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_box_set_homogeneous((*C.GtkBox)(recv.native), c_homogeneous)

	return
}

// Sets the #GtkBox:spacing property of @box, which is the
// number of pixels to place between children of @box.
/*

C function : gtk_box_set_spacing
*/
func (recv *Box) SetSpacing(spacing int32) {
	c_spacing := (C.gint)(spacing)

	C.gtk_box_set_spacing((*C.GtkBox)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Box
func (recv *Box) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Box
func (recv *Box) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Box
func (recv *Box) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// A GtkBuilder is an auxiliary object that reads textual descriptions
// of a user interface and instantiates the described objects. To create
// a GtkBuilder from a user interface description, call
// gtk_builder_new_from_file(), gtk_builder_new_from_resource() or
// gtk_builder_new_from_string().
//
// In the (unusual) case that you want to add user interface
// descriptions from multiple sources to the same GtkBuilder you can
// call gtk_builder_new() to get an empty builder and populate it by
// (multiple) calls to gtk_builder_add_from_file(),
// gtk_builder_add_from_resource() or gtk_builder_add_from_string().
//
// A GtkBuilder holds a reference to all objects that it has constructed
// and drops these references when it is finalized. This finalization can
// cause the destruction of non-widget objects or widgets which are not
// contained in a toplevel window. For toplevel windows constructed by a
// builder, it is the responsibility of the user to call gtk_widget_destroy()
// to get rid of them and all the widgets they contain.
//
// The functions gtk_builder_get_object() and gtk_builder_get_objects()
// can be used to access the widgets in the interface by the names assigned
// to them inside the UI description. Toplevel windows returned by these
// functions will stay around until the user explicitly destroys them
// with gtk_widget_destroy(). Other widgets will either be part of a
// larger hierarchy constructed by the builder (in which case you should
// not have to worry about their lifecycle), or without a parent, in which
// case they have to be added to some container to make use of them.
// Non-widget objects need to be reffed with g_object_ref() to keep them
// beyond the lifespan of the builder.
//
// The function gtk_builder_connect_signals() and variants thereof can be
// used to connect handlers to the named signals in the description.
//
// # GtkBuilder UI Definitions # {#BUILDER-UI}
//
// GtkBuilder parses textual descriptions of user interfaces which are
// specified in an XML format which can be roughly described by the
// RELAX NG schema below. We refer to these descriptions as GtkBuilder
// UI definitions or just UI definitions if the context is clear.
// Do not confuse GtkBuilder UI Definitions with
// [GtkUIManager UI Definitions][XML-UI], which are more limited in scope.
// It is common to use `.ui` as the filename extension for files containing
// GtkBuilder UI definitions.
//
// [RELAX NG Compact Syntax](https://git.gnome.org/browse/gtk+/tree/gtk/gtkbuilder.rnc)
//
// The toplevel element is <interface>. It optionally takes a domain
// attribute, which will make the builder look for translated strings
// using dgettext() in the domain specified. This can also be done by
// calling gtk_builder_set_translation_domain() on the builder.
// Objects are described by <object> elements, which can contain
// <property> elements to set properties, <signal> elements which
// connect signals to handlers, and <child> elements, which describe
// child objects (most often widgets inside a container, but also e.g.
// actions in an action group, or columns in a tree model). A <child>
// element contains an <object> element which describes the child object.
// The target toolkit version(s) are described by <requires> elements,
// the lib attribute specifies the widget library in question (currently
// the only supported value is gtk+) and the version attribute specifies
// the target version in the form <major>.<minor>. The builder will error
// out if the version requirements are not met.
//
// Typically, the specific kind of object represented by an <object>
// element is specified by the class attribute. If the type has not
// been loaded yet, GTK+ tries to find the get_type() function from the
// class name by applying heuristics. This works in most cases, but if
// necessary, it is possible to specify the name of the get_type() function
// explictly with the "type-func" attribute. As a special case, GtkBuilder
// allows to use an object that has been constructed by a #GtkUIManager in
// another part of the UI definition by specifying the id of the #GtkUIManager
// in the constructor attribute and the name of the object in the id
// attribute.
//
// Objects may be given a name with the id attribute, which allows the
// application to retrieve them from the builder with gtk_builder_get_object().
// An id is also necessary to use the object as property value in other
// parts of the UI definition. GTK+ reserves ids starting and ending
// with ___ (3 underscores) for its own purposes.
//
// Setting properties of objects is pretty straightforward with the
// <property> element: the name attribute specifies the name of the
// property, and the content of the element specifies the value.
// If the translatable attribute is set to a true value, GTK+ uses
// gettext() (or dgettext() if the builder has a translation domain set)
// to find a translation for the value. This happens before the value
// is parsed, so it can be used for properties of any type, but it is
// probably most useful for string properties. It is also possible to
// specify a context to disambiguate short strings, and comments which
// may help the translators.
//
// GtkBuilder can parse textual representations for the most common
// property types: characters, strings, integers, floating-point numbers,
// booleans (strings like TRUE, t, yes, y, 1 are interpreted
// as %TRUE, strings like FALSE, f, no, n, 0 are interpreted
// as %FALSE), enumerations (can be specified by their name, nick or
// integer value), flags (can be specified by their name, nick, integer
// value, optionally combined with |, e.g. GTK_VISIBLE|GTK_REALIZED)
// and colors (in a format understood by gdk_rgba_parse()).
//
// GVariants can be specified in the format understood by g_variant_parse(),
// and pixbufs can be specified as a filename of an image file to load.
//
// Objects can be referred to by their name and by default refer to
// objects declared in the local xml fragment and objects exposed via
// gtk_builder_expose_object(). In general, GtkBuilder allows forward
// references to objects  declared in the local xml; an object doesnt
// have to be constructed before it can be referred to. The exception
// to this rule is that an object has to be constructed before it can
// be used as the value of a construct-only property.
//
// It is also possible to bind a property value to another object's
// property value using the attributes
// "bind-source" to specify the source object of the binding,
// "bind-property" to specify the source property and optionally
// "bind-flags" to specify the binding flags
// Internally builder implement this using GBinding objects.
// For more information see g_object_bind_property()
//
// Signal handlers are set up with the <signal> element. The name
// attribute specifies the name of the signal, and the handler attribute
// specifies the function to connect to the signal. By default, GTK+ tries
// to find the handler using g_module_symbol(), but this can be changed by
// passing a custom #GtkBuilderConnectFunc to
// gtk_builder_connect_signals_full(). The remaining attributes, after,
// swapped and object, have the same meaning as the corresponding
// parameters of the g_signal_connect_object() or
// g_signal_connect_data() functions. A last_modification_time
// attribute is also allowed, but it does not have a meaning to the
// builder.
//
// Sometimes it is necessary to refer to widgets which have implicitly
// been constructed by GTK+ as part of a composite widget, to set
// properties on them or to add further children (e.g. the @vbox of
// a #GtkDialog). This can be achieved by setting the internal-child
// propery of the <child> element to a true value. Note that GtkBuilder
// still requires an <object> element for the internal child, even if it
// has already been constructed.
//
// A number of widgets have different places where a child can be added
// (e.g. tabs vs. page content in notebooks). This can be reflected in
// a UI definition by specifying the type attribute on a <child>
// The possible values for the type attribute are described in the
// sections describing the widget-specific portions of UI definitions.
//
// # A GtkBuilder UI Definition
//
// |[
// <interface>
// <object class="GtkDialog" id="dialog1">
// <child internal-child="vbox">
// <object class="GtkBox" id="vbox1">
// <property name="border-width">10</property>
// <child internal-child="action_area">
// <object class="GtkButtonBox" id="hbuttonbox1">
// <property name="border-width">20</property>
// <child>
// <object class="GtkButton" id="ok_button">
// <property name="label">gtk-ok</property>
// <property name="use-stock">TRUE</property>
// <signal name="clicked" handler="ok_button_clicked"/>
// </object>
// </child>
// </object>
// </child>
// </object>
// </child>
// </object>
// </interface>
// ]|
//
// Beyond this general structure, several object classes define their
// own XML DTD fragments for filling in the ANY placeholders in the DTD
// above. Note that a custom element in a <child> element gets parsed by
// the custom tag handler of the parent object, while a custom element in
// an <object> element gets parsed by the custom tag handler of the object.
//
// These XML fragments are explained in the documentation of the
// respective objects.
//
// Additionally, since 3.10 a special <template> tag has been added
// to the format allowing one to define a widget classs components.
// See the [GtkWidget documentation][composite-templates] for details.
/*

C record/class : GtkBuilder
*/
type Builder struct {
	native *C.GtkBuilder
	// parent_instance : record
	// priv : record
}

func BuilderNewFromC(u unsafe.Pointer) *Builder {
	c := (*C.GtkBuilder)(u)
	if c == nil {
		return nil
	}

	g := &Builder{native: c}

	return g
}

func (recv *Builder) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Builder) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Builder.
// Exercise care, as this is a potentially dangerous function if the Object is not a Builder.
func CastToBuilder(object *gobject.Object) *Builder {
	return BuilderNewFromC(object.ToC())
}

// Blacklisted : gtk_builder_extend_with_template

// The #GtkButton widget is generally used to trigger a callback function that is
// called when the button is pressed.  The various signals and how to use them
// are outlined below.
//
// The #GtkButton widget can hold any valid child widget.  That is, it can hold
// almost any other standard #GtkWidget.  The most commonly used child is the
// #GtkLabel.
//
// # CSS nodes
//
// GtkButton has a single CSS node with name button. The node will get the
// style classes .image-button or .text-button, if the content is just an
// image or label, respectively. It may also receive the .flat style class.
//
// Other style classes that are commonly used with GtkButton include
// .suggested-action and .destructive-action. In special cases, buttons
// can be made round by adding the .circular style class.
//
// Button-like widgets like #GtkToggleButton, #GtkMenuButton, #GtkVolumeButton,
// #GtkLockButton, #GtkColorButton, #GtkFontButton or #GtkFileChooserButton use
// style classes such as .toggle, .popup, .scale, .lock, .color, .font, .file
// to differentiate themselves from a plain GtkButton.
/*

C record/class : GtkButton
*/
type Button struct {
	native *C.GtkButton
	// Private : bin
	// Private : priv
}

func ButtonNewFromC(u unsafe.Pointer) *Button {
	c := (*C.GtkButton)(u)
	if c == nil {
		return nil
	}

	g := &Button{native: c}

	return g
}

func (recv *Button) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Button) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Button) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Button) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Button) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Button) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Button.
// Exercise care, as this is a potentially dangerous function if the Object is not a Button.
func CastToButton(object *gobject.Object) *Button {
	return ButtonNewFromC(object.ToC())
}

type signalButtonActivateDetail struct {
	callback  ButtonSignalActivateCallback
	handlerID C.gulong
}

var signalButtonActivateId int
var signalButtonActivateMap = make(map[int]signalButtonActivateDetail)
var signalButtonActivateLock sync.Mutex

// ButtonSignalActivateCallback is a callback function for a 'activate' signal emitted from a Button.
type ButtonSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Button) ConnectActivate(callback ButtonSignalActivateCallback) int {
	signalButtonActivateLock.Lock()
	defer signalButtonActivateLock.Unlock()

	signalButtonActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_activate(instance, C.gpointer(uintptr(signalButtonActivateId)))

	detail := signalButtonActivateDetail{callback, handlerID}
	signalButtonActivateMap[signalButtonActivateId] = detail

	return signalButtonActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Button.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Button) DisconnectActivate(connectionID int) {
	signalButtonActivateLock.Lock()
	defer signalButtonActivateLock.Unlock()

	detail, exists := signalButtonActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonActivateMap, connectionID)
}

//export button_activateHandler
func button_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonActivateMap[index].callback
	callback()
}

type signalButtonClickedDetail struct {
	callback  ButtonSignalClickedCallback
	handlerID C.gulong
}

var signalButtonClickedId int
var signalButtonClickedMap = make(map[int]signalButtonClickedDetail)
var signalButtonClickedLock sync.Mutex

// ButtonSignalClickedCallback is a callback function for a 'clicked' signal emitted from a Button.
type ButtonSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *Button) ConnectClicked(callback ButtonSignalClickedCallback) int {
	signalButtonClickedLock.Lock()
	defer signalButtonClickedLock.Unlock()

	signalButtonClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_clicked(instance, C.gpointer(uintptr(signalButtonClickedId)))

	detail := signalButtonClickedDetail{callback, handlerID}
	signalButtonClickedMap[signalButtonClickedId] = detail

	return signalButtonClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the Button.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *Button) DisconnectClicked(connectionID int) {
	signalButtonClickedLock.Lock()
	defer signalButtonClickedLock.Unlock()

	detail, exists := signalButtonClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonClickedMap, connectionID)
}

//export button_clickedHandler
func button_clickedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonClickedMap[index].callback
	callback()
}

type signalButtonEnterDetail struct {
	callback  ButtonSignalEnterCallback
	handlerID C.gulong
}

var signalButtonEnterId int
var signalButtonEnterMap = make(map[int]signalButtonEnterDetail)
var signalButtonEnterLock sync.Mutex

// ButtonSignalEnterCallback is a callback function for a 'enter' signal emitted from a Button.
type ButtonSignalEnterCallback func()

/*
ConnectEnter connects the callback to the 'enter' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectEnter to remove it.
*/
func (recv *Button) ConnectEnter(callback ButtonSignalEnterCallback) int {
	signalButtonEnterLock.Lock()
	defer signalButtonEnterLock.Unlock()

	signalButtonEnterId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_enter(instance, C.gpointer(uintptr(signalButtonEnterId)))

	detail := signalButtonEnterDetail{callback, handlerID}
	signalButtonEnterMap[signalButtonEnterId] = detail

	return signalButtonEnterId
}

/*
DisconnectEnter disconnects a callback from the 'enter' signal for the Button.

The connectionID should be a value returned from a call to ConnectEnter.
*/
func (recv *Button) DisconnectEnter(connectionID int) {
	signalButtonEnterLock.Lock()
	defer signalButtonEnterLock.Unlock()

	detail, exists := signalButtonEnterMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonEnterMap, connectionID)
}

//export button_enterHandler
func button_enterHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonEnterMap[index].callback
	callback()
}

type signalButtonLeaveDetail struct {
	callback  ButtonSignalLeaveCallback
	handlerID C.gulong
}

var signalButtonLeaveId int
var signalButtonLeaveMap = make(map[int]signalButtonLeaveDetail)
var signalButtonLeaveLock sync.Mutex

// ButtonSignalLeaveCallback is a callback function for a 'leave' signal emitted from a Button.
type ButtonSignalLeaveCallback func()

/*
ConnectLeave connects the callback to the 'leave' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectLeave to remove it.
*/
func (recv *Button) ConnectLeave(callback ButtonSignalLeaveCallback) int {
	signalButtonLeaveLock.Lock()
	defer signalButtonLeaveLock.Unlock()

	signalButtonLeaveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_leave(instance, C.gpointer(uintptr(signalButtonLeaveId)))

	detail := signalButtonLeaveDetail{callback, handlerID}
	signalButtonLeaveMap[signalButtonLeaveId] = detail

	return signalButtonLeaveId
}

/*
DisconnectLeave disconnects a callback from the 'leave' signal for the Button.

The connectionID should be a value returned from a call to ConnectLeave.
*/
func (recv *Button) DisconnectLeave(connectionID int) {
	signalButtonLeaveLock.Lock()
	defer signalButtonLeaveLock.Unlock()

	detail, exists := signalButtonLeaveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonLeaveMap, connectionID)
}

//export button_leaveHandler
func button_leaveHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonLeaveMap[index].callback
	callback()
}

type signalButtonPressedDetail struct {
	callback  ButtonSignalPressedCallback
	handlerID C.gulong
}

var signalButtonPressedId int
var signalButtonPressedMap = make(map[int]signalButtonPressedDetail)
var signalButtonPressedLock sync.Mutex

// ButtonSignalPressedCallback is a callback function for a 'pressed' signal emitted from a Button.
type ButtonSignalPressedCallback func()

/*
ConnectPressed connects the callback to the 'pressed' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectPressed to remove it.
*/
func (recv *Button) ConnectPressed(callback ButtonSignalPressedCallback) int {
	signalButtonPressedLock.Lock()
	defer signalButtonPressedLock.Unlock()

	signalButtonPressedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_pressed(instance, C.gpointer(uintptr(signalButtonPressedId)))

	detail := signalButtonPressedDetail{callback, handlerID}
	signalButtonPressedMap[signalButtonPressedId] = detail

	return signalButtonPressedId
}

/*
DisconnectPressed disconnects a callback from the 'pressed' signal for the Button.

The connectionID should be a value returned from a call to ConnectPressed.
*/
func (recv *Button) DisconnectPressed(connectionID int) {
	signalButtonPressedLock.Lock()
	defer signalButtonPressedLock.Unlock()

	detail, exists := signalButtonPressedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonPressedMap, connectionID)
}

//export button_pressedHandler
func button_pressedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonPressedMap[index].callback
	callback()
}

type signalButtonReleasedDetail struct {
	callback  ButtonSignalReleasedCallback
	handlerID C.gulong
}

var signalButtonReleasedId int
var signalButtonReleasedMap = make(map[int]signalButtonReleasedDetail)
var signalButtonReleasedLock sync.Mutex

// ButtonSignalReleasedCallback is a callback function for a 'released' signal emitted from a Button.
type ButtonSignalReleasedCallback func()

/*
ConnectReleased connects the callback to the 'released' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectReleased to remove it.
*/
func (recv *Button) ConnectReleased(callback ButtonSignalReleasedCallback) int {
	signalButtonReleasedLock.Lock()
	defer signalButtonReleasedLock.Unlock()

	signalButtonReleasedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_released(instance, C.gpointer(uintptr(signalButtonReleasedId)))

	detail := signalButtonReleasedDetail{callback, handlerID}
	signalButtonReleasedMap[signalButtonReleasedId] = detail

	return signalButtonReleasedId
}

/*
DisconnectReleased disconnects a callback from the 'released' signal for the Button.

The connectionID should be a value returned from a call to ConnectReleased.
*/
func (recv *Button) DisconnectReleased(connectionID int) {
	signalButtonReleasedLock.Lock()
	defer signalButtonReleasedLock.Unlock()

	detail, exists := signalButtonReleasedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonReleasedMap, connectionID)
}

//export button_releasedHandler
func button_releasedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonReleasedMap[index].callback
	callback()
}

// Creates a new #GtkButton widget. To add a child widget to the button,
// use gtk_container_add().
/*

C function : gtk_button_new
*/
func ButtonNew() *Button {
	retC := C.gtk_button_new()
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkButton containing the image and text from a stock item.
// Some stock ids have preprocessor macros like #GTK_STOCK_OK and
// #GTK_STOCK_APPLY.
//
// If @stock_id is unknown, then it will be treated as a mnemonic
// label (as for gtk_button_new_with_mnemonic()).
/*

C function : gtk_button_new_from_stock
*/
func ButtonNewFromStock(stockId string) *Button {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_button_new_from_stock(c_stock_id)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a #GtkButton widget with a #GtkLabel child containing the given
// text.
/*

C function : gtk_button_new_with_label
*/
func ButtonNewWithLabel(label string) *Button {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_button_new_with_label(c_label)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkButton containing a label.
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use __ (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
// Pressing Alt and that key activates the button.
/*

C function : gtk_button_new_with_mnemonic
*/
func ButtonNewWithMnemonic(label string) *Button {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_button_new_with_mnemonic(c_label)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Emits a #GtkButton::clicked signal to the given #GtkButton.
/*

C function : gtk_button_clicked
*/
func (recv *Button) Clicked() {
	C.gtk_button_clicked((*C.GtkButton)(recv.native))

	return
}

// Emits a #GtkButton::enter signal to the given #GtkButton.
/*

C function : gtk_button_enter
*/
func (recv *Button) Enter() {
	C.gtk_button_enter((*C.GtkButton)(recv.native))

	return
}

// Fetches the text from the label of the button, as set by
// gtk_button_set_label(). If the label text has not
// been set the return value will be %NULL. This will be the
// case if you create an empty button with gtk_button_new() to
// use as a container.
/*

C function : gtk_button_get_label
*/
func (recv *Button) GetLabel() string {
	retC := C.gtk_button_get_label((*C.GtkButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Returns the current relief style of the given #GtkButton.
/*

C function : gtk_button_get_relief
*/
func (recv *Button) GetRelief() ReliefStyle {
	retC := C.gtk_button_get_relief((*C.GtkButton)(recv.native))
	retGo := (ReliefStyle)(retC)

	return retGo
}

// Returns whether the button label is a stock item.
/*

C function : gtk_button_get_use_stock
*/
func (recv *Button) GetUseStock() bool {
	retC := C.gtk_button_get_use_stock((*C.GtkButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether an embedded underline in the button label indicates a
// mnemonic. See gtk_button_set_use_underline ().
/*

C function : gtk_button_get_use_underline
*/
func (recv *Button) GetUseUnderline() bool {
	retC := C.gtk_button_get_use_underline((*C.GtkButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Emits a #GtkButton::leave signal to the given #GtkButton.
/*

C function : gtk_button_leave
*/
func (recv *Button) Leave() {
	C.gtk_button_leave((*C.GtkButton)(recv.native))

	return
}

// Emits a #GtkButton::pressed signal to the given #GtkButton.
/*

C function : gtk_button_pressed
*/
func (recv *Button) Pressed() {
	C.gtk_button_pressed((*C.GtkButton)(recv.native))

	return
}

// Emits a #GtkButton::released signal to the given #GtkButton.
/*

C function : gtk_button_released
*/
func (recv *Button) Released() {
	C.gtk_button_released((*C.GtkButton)(recv.native))

	return
}

// Sets the text of the label of the button to @str. This text is
// also used to select the stock item if gtk_button_set_use_stock()
// is used.
//
// This will also clear any previously set labels.
/*

C function : gtk_button_set_label
*/
func (recv *Button) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_button_set_label((*C.GtkButton)(recv.native), c_label)

	return
}

// Sets the relief style of the edges of the given #GtkButton widget.
// Two styles exist, %GTK_RELIEF_NORMAL and %GTK_RELIEF_NONE.
// The default style is, as one can guess, %GTK_RELIEF_NORMAL.
// The deprecated value %GTK_RELIEF_HALF behaves the same as
// %GTK_RELIEF_NORMAL.
/*

C function : gtk_button_set_relief
*/
func (recv *Button) SetRelief(relief ReliefStyle) {
	c_relief := (C.GtkReliefStyle)(relief)

	C.gtk_button_set_relief((*C.GtkButton)(recv.native), c_relief)

	return
}

// If %TRUE, the label set on the button is used as a
// stock id to select the stock item for the button.
/*

C function : gtk_button_set_use_stock
*/
func (recv *Button) SetUseStock(useStock bool) {
	c_use_stock :=
		boolToGboolean(useStock)

	C.gtk_button_set_use_stock((*C.GtkButton)(recv.native), c_use_stock)

	return
}

// If true, an underline in the text of the button label indicates
// the next character should be used for the mnemonic accelerator key.
/*

C function : gtk_button_set_use_underline
*/
func (recv *Button) SetUseUnderline(useUnderline bool) {
	c_use_underline :=
		boolToGboolean(useUnderline)

	C.gtk_button_set_use_underline((*C.GtkButton)(recv.native), c_use_underline)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Button
func (recv *Button) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by Button
func (recv *Button) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by Button
func (recv *Button) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Button
func (recv *Button) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkButtonAccessible
*/
type ButtonAccessible struct {
	native *C.GtkButtonAccessible
	// parent : record
	// priv : record
}

func ButtonAccessibleNewFromC(u unsafe.Pointer) *ButtonAccessible {
	c := (*C.GtkButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ButtonAccessible{native: c}

	return g
}

func (recv *ButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ButtonAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ButtonAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ButtonAccessible.
func CastToButtonAccessible(object *gobject.Object) *ButtonAccessible {
	return ButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

/*

C record/class : GtkButtonBox
*/
type ButtonBox struct {
	native *C.GtkButtonBox
	// box : record
	// Private : priv
}

func ButtonBoxNewFromC(u unsafe.Pointer) *ButtonBox {
	c := (*C.GtkButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &ButtonBox{native: c}

	return g
}

func (recv *ButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *ButtonBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ButtonBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ButtonBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ButtonBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to ButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ButtonBox.
func CastToButtonBox(object *gobject.Object) *ButtonBox {
	return ButtonBoxNewFromC(object.ToC())
}

// Retrieves the method being used to arrange the buttons in a button box.
/*

C function : gtk_button_box_get_layout
*/
func (recv *ButtonBox) GetLayout() ButtonBoxStyle {
	retC := C.gtk_button_box_get_layout((*C.GtkButtonBox)(recv.native))
	retGo := (ButtonBoxStyle)(retC)

	return retGo
}

// Sets whether @child should appear in a secondary group of children.
// A typical use of a secondary child is the help button in a dialog.
//
// This group appears after the other children if the style
// is %GTK_BUTTONBOX_START, %GTK_BUTTONBOX_SPREAD or
// %GTK_BUTTONBOX_EDGE, and before the other children if the style
// is %GTK_BUTTONBOX_END. For horizontal button boxes, the definition
// of before/after depends on direction of the widget (see
// gtk_widget_set_direction()). If the style is %GTK_BUTTONBOX_START
// or %GTK_BUTTONBOX_END, then the secondary children are aligned at
// the other end of the button box from the main children. For the
// other styles, they appear immediately next to the main children.
/*

C function : gtk_button_box_set_child_secondary
*/
func (recv *ButtonBox) SetChildSecondary(child *Widget, isSecondary bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_is_secondary :=
		boolToGboolean(isSecondary)

	C.gtk_button_box_set_child_secondary((*C.GtkButtonBox)(recv.native), c_child, c_is_secondary)

	return
}

// Changes the way buttons are arranged in their container.
/*

C function : gtk_button_box_set_layout
*/
func (recv *ButtonBox) SetLayout(layoutStyle ButtonBoxStyle) {
	c_layout_style := (C.GtkButtonBoxStyle)(layoutStyle)

	C.gtk_button_box_set_layout((*C.GtkButtonBox)(recv.native), c_layout_style)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ButtonBox
func (recv *ButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ButtonBox
func (recv *ButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ButtonBox
func (recv *ButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// #GtkCalendar is a widget that displays a Gregorian calendar, one month
// at a time. It can be created with gtk_calendar_new().
//
// The month and year currently displayed can be altered with
// gtk_calendar_select_month(). The exact day can be selected from the
// displayed month using gtk_calendar_select_day().
//
// To place a visual marker on a particular day, use gtk_calendar_mark_day()
// and to remove the marker, gtk_calendar_unmark_day(). Alternative, all
// marks can be cleared with gtk_calendar_clear_marks().
//
// The way in which the calendar itself is displayed can be altered using
// gtk_calendar_set_display_options().
//
// The selected date can be retrieved from a #GtkCalendar using
// gtk_calendar_get_date().
//
// Users should be aware that, although the Gregorian calendar is the
// legal calendar in most countries, it was adopted progressively
// between 1582 and 1929. Display before these dates is likely to be
// historically incorrect.
/*

C record/class : GtkCalendar
*/
type Calendar struct {
	native *C.GtkCalendar
	// widget : record
	// priv : record
}

func CalendarNewFromC(u unsafe.Pointer) *Calendar {
	c := (*C.GtkCalendar)(u)
	if c == nil {
		return nil
	}

	g := &Calendar{native: c}

	return g
}

func (recv *Calendar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Calendar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Calendar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Calendar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Calendar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Calendar.
func CastToCalendar(object *gobject.Object) *Calendar {
	return CalendarNewFromC(object.ToC())
}

type signalCalendarDaySelectedDetail struct {
	callback  CalendarSignalDaySelectedCallback
	handlerID C.gulong
}

var signalCalendarDaySelectedId int
var signalCalendarDaySelectedMap = make(map[int]signalCalendarDaySelectedDetail)
var signalCalendarDaySelectedLock sync.Mutex

// CalendarSignalDaySelectedCallback is a callback function for a 'day-selected' signal emitted from a Calendar.
type CalendarSignalDaySelectedCallback func()

/*
ConnectDaySelected connects the callback to the 'day-selected' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectDaySelected to remove it.
*/
func (recv *Calendar) ConnectDaySelected(callback CalendarSignalDaySelectedCallback) int {
	signalCalendarDaySelectedLock.Lock()
	defer signalCalendarDaySelectedLock.Unlock()

	signalCalendarDaySelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_day_selected(instance, C.gpointer(uintptr(signalCalendarDaySelectedId)))

	detail := signalCalendarDaySelectedDetail{callback, handlerID}
	signalCalendarDaySelectedMap[signalCalendarDaySelectedId] = detail

	return signalCalendarDaySelectedId
}

/*
DisconnectDaySelected disconnects a callback from the 'day-selected' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectDaySelected.
*/
func (recv *Calendar) DisconnectDaySelected(connectionID int) {
	signalCalendarDaySelectedLock.Lock()
	defer signalCalendarDaySelectedLock.Unlock()

	detail, exists := signalCalendarDaySelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarDaySelectedMap, connectionID)
}

//export calendar_daySelectedHandler
func calendar_daySelectedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarDaySelectedMap[index].callback
	callback()
}

type signalCalendarDaySelectedDoubleClickDetail struct {
	callback  CalendarSignalDaySelectedDoubleClickCallback
	handlerID C.gulong
}

var signalCalendarDaySelectedDoubleClickId int
var signalCalendarDaySelectedDoubleClickMap = make(map[int]signalCalendarDaySelectedDoubleClickDetail)
var signalCalendarDaySelectedDoubleClickLock sync.Mutex

// CalendarSignalDaySelectedDoubleClickCallback is a callback function for a 'day-selected-double-click' signal emitted from a Calendar.
type CalendarSignalDaySelectedDoubleClickCallback func()

/*
ConnectDaySelectedDoubleClick connects the callback to the 'day-selected-double-click' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectDaySelectedDoubleClick to remove it.
*/
func (recv *Calendar) ConnectDaySelectedDoubleClick(callback CalendarSignalDaySelectedDoubleClickCallback) int {
	signalCalendarDaySelectedDoubleClickLock.Lock()
	defer signalCalendarDaySelectedDoubleClickLock.Unlock()

	signalCalendarDaySelectedDoubleClickId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_day_selected_double_click(instance, C.gpointer(uintptr(signalCalendarDaySelectedDoubleClickId)))

	detail := signalCalendarDaySelectedDoubleClickDetail{callback, handlerID}
	signalCalendarDaySelectedDoubleClickMap[signalCalendarDaySelectedDoubleClickId] = detail

	return signalCalendarDaySelectedDoubleClickId
}

/*
DisconnectDaySelectedDoubleClick disconnects a callback from the 'day-selected-double-click' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectDaySelectedDoubleClick.
*/
func (recv *Calendar) DisconnectDaySelectedDoubleClick(connectionID int) {
	signalCalendarDaySelectedDoubleClickLock.Lock()
	defer signalCalendarDaySelectedDoubleClickLock.Unlock()

	detail, exists := signalCalendarDaySelectedDoubleClickMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarDaySelectedDoubleClickMap, connectionID)
}

//export calendar_daySelectedDoubleClickHandler
func calendar_daySelectedDoubleClickHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarDaySelectedDoubleClickMap[index].callback
	callback()
}

type signalCalendarMonthChangedDetail struct {
	callback  CalendarSignalMonthChangedCallback
	handlerID C.gulong
}

var signalCalendarMonthChangedId int
var signalCalendarMonthChangedMap = make(map[int]signalCalendarMonthChangedDetail)
var signalCalendarMonthChangedLock sync.Mutex

// CalendarSignalMonthChangedCallback is a callback function for a 'month-changed' signal emitted from a Calendar.
type CalendarSignalMonthChangedCallback func()

/*
ConnectMonthChanged connects the callback to the 'month-changed' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectMonthChanged to remove it.
*/
func (recv *Calendar) ConnectMonthChanged(callback CalendarSignalMonthChangedCallback) int {
	signalCalendarMonthChangedLock.Lock()
	defer signalCalendarMonthChangedLock.Unlock()

	signalCalendarMonthChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_month_changed(instance, C.gpointer(uintptr(signalCalendarMonthChangedId)))

	detail := signalCalendarMonthChangedDetail{callback, handlerID}
	signalCalendarMonthChangedMap[signalCalendarMonthChangedId] = detail

	return signalCalendarMonthChangedId
}

/*
DisconnectMonthChanged disconnects a callback from the 'month-changed' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectMonthChanged.
*/
func (recv *Calendar) DisconnectMonthChanged(connectionID int) {
	signalCalendarMonthChangedLock.Lock()
	defer signalCalendarMonthChangedLock.Unlock()

	detail, exists := signalCalendarMonthChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarMonthChangedMap, connectionID)
}

//export calendar_monthChangedHandler
func calendar_monthChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarMonthChangedMap[index].callback
	callback()
}

type signalCalendarNextMonthDetail struct {
	callback  CalendarSignalNextMonthCallback
	handlerID C.gulong
}

var signalCalendarNextMonthId int
var signalCalendarNextMonthMap = make(map[int]signalCalendarNextMonthDetail)
var signalCalendarNextMonthLock sync.Mutex

// CalendarSignalNextMonthCallback is a callback function for a 'next-month' signal emitted from a Calendar.
type CalendarSignalNextMonthCallback func()

/*
ConnectNextMonth connects the callback to the 'next-month' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectNextMonth to remove it.
*/
func (recv *Calendar) ConnectNextMonth(callback CalendarSignalNextMonthCallback) int {
	signalCalendarNextMonthLock.Lock()
	defer signalCalendarNextMonthLock.Unlock()

	signalCalendarNextMonthId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_next_month(instance, C.gpointer(uintptr(signalCalendarNextMonthId)))

	detail := signalCalendarNextMonthDetail{callback, handlerID}
	signalCalendarNextMonthMap[signalCalendarNextMonthId] = detail

	return signalCalendarNextMonthId
}

/*
DisconnectNextMonth disconnects a callback from the 'next-month' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectNextMonth.
*/
func (recv *Calendar) DisconnectNextMonth(connectionID int) {
	signalCalendarNextMonthLock.Lock()
	defer signalCalendarNextMonthLock.Unlock()

	detail, exists := signalCalendarNextMonthMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarNextMonthMap, connectionID)
}

//export calendar_nextMonthHandler
func calendar_nextMonthHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarNextMonthMap[index].callback
	callback()
}

type signalCalendarNextYearDetail struct {
	callback  CalendarSignalNextYearCallback
	handlerID C.gulong
}

var signalCalendarNextYearId int
var signalCalendarNextYearMap = make(map[int]signalCalendarNextYearDetail)
var signalCalendarNextYearLock sync.Mutex

// CalendarSignalNextYearCallback is a callback function for a 'next-year' signal emitted from a Calendar.
type CalendarSignalNextYearCallback func()

/*
ConnectNextYear connects the callback to the 'next-year' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectNextYear to remove it.
*/
func (recv *Calendar) ConnectNextYear(callback CalendarSignalNextYearCallback) int {
	signalCalendarNextYearLock.Lock()
	defer signalCalendarNextYearLock.Unlock()

	signalCalendarNextYearId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_next_year(instance, C.gpointer(uintptr(signalCalendarNextYearId)))

	detail := signalCalendarNextYearDetail{callback, handlerID}
	signalCalendarNextYearMap[signalCalendarNextYearId] = detail

	return signalCalendarNextYearId
}

/*
DisconnectNextYear disconnects a callback from the 'next-year' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectNextYear.
*/
func (recv *Calendar) DisconnectNextYear(connectionID int) {
	signalCalendarNextYearLock.Lock()
	defer signalCalendarNextYearLock.Unlock()

	detail, exists := signalCalendarNextYearMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarNextYearMap, connectionID)
}

//export calendar_nextYearHandler
func calendar_nextYearHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarNextYearMap[index].callback
	callback()
}

type signalCalendarPrevMonthDetail struct {
	callback  CalendarSignalPrevMonthCallback
	handlerID C.gulong
}

var signalCalendarPrevMonthId int
var signalCalendarPrevMonthMap = make(map[int]signalCalendarPrevMonthDetail)
var signalCalendarPrevMonthLock sync.Mutex

// CalendarSignalPrevMonthCallback is a callback function for a 'prev-month' signal emitted from a Calendar.
type CalendarSignalPrevMonthCallback func()

/*
ConnectPrevMonth connects the callback to the 'prev-month' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectPrevMonth to remove it.
*/
func (recv *Calendar) ConnectPrevMonth(callback CalendarSignalPrevMonthCallback) int {
	signalCalendarPrevMonthLock.Lock()
	defer signalCalendarPrevMonthLock.Unlock()

	signalCalendarPrevMonthId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_prev_month(instance, C.gpointer(uintptr(signalCalendarPrevMonthId)))

	detail := signalCalendarPrevMonthDetail{callback, handlerID}
	signalCalendarPrevMonthMap[signalCalendarPrevMonthId] = detail

	return signalCalendarPrevMonthId
}

/*
DisconnectPrevMonth disconnects a callback from the 'prev-month' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectPrevMonth.
*/
func (recv *Calendar) DisconnectPrevMonth(connectionID int) {
	signalCalendarPrevMonthLock.Lock()
	defer signalCalendarPrevMonthLock.Unlock()

	detail, exists := signalCalendarPrevMonthMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarPrevMonthMap, connectionID)
}

//export calendar_prevMonthHandler
func calendar_prevMonthHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarPrevMonthMap[index].callback
	callback()
}

type signalCalendarPrevYearDetail struct {
	callback  CalendarSignalPrevYearCallback
	handlerID C.gulong
}

var signalCalendarPrevYearId int
var signalCalendarPrevYearMap = make(map[int]signalCalendarPrevYearDetail)
var signalCalendarPrevYearLock sync.Mutex

// CalendarSignalPrevYearCallback is a callback function for a 'prev-year' signal emitted from a Calendar.
type CalendarSignalPrevYearCallback func()

/*
ConnectPrevYear connects the callback to the 'prev-year' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectPrevYear to remove it.
*/
func (recv *Calendar) ConnectPrevYear(callback CalendarSignalPrevYearCallback) int {
	signalCalendarPrevYearLock.Lock()
	defer signalCalendarPrevYearLock.Unlock()

	signalCalendarPrevYearId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_prev_year(instance, C.gpointer(uintptr(signalCalendarPrevYearId)))

	detail := signalCalendarPrevYearDetail{callback, handlerID}
	signalCalendarPrevYearMap[signalCalendarPrevYearId] = detail

	return signalCalendarPrevYearId
}

/*
DisconnectPrevYear disconnects a callback from the 'prev-year' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectPrevYear.
*/
func (recv *Calendar) DisconnectPrevYear(connectionID int) {
	signalCalendarPrevYearLock.Lock()
	defer signalCalendarPrevYearLock.Unlock()

	detail, exists := signalCalendarPrevYearMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarPrevYearMap, connectionID)
}

//export calendar_prevYearHandler
func calendar_prevYearHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarPrevYearMap[index].callback
	callback()
}

// Creates a new calendar, with the current date being selected.
/*

C function : gtk_calendar_new
*/
func CalendarNew() *Calendar {
	retC := C.gtk_calendar_new()
	retGo := CalendarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Remove all visual markers.
/*

C function : gtk_calendar_clear_marks
*/
func (recv *Calendar) ClearMarks() {
	C.gtk_calendar_clear_marks((*C.GtkCalendar)(recv.native))

	return
}

// Obtains the selected date from a #GtkCalendar.
/*

C function : gtk_calendar_get_date
*/
func (recv *Calendar) GetDate() (uint32, uint32, uint32) {
	var c_year C.guint

	var c_month C.guint

	var c_day C.guint

	C.gtk_calendar_get_date((*C.GtkCalendar)(recv.native), &c_year, &c_month, &c_day)

	year := (uint32)(c_year)

	month := (uint32)(c_month)

	day := (uint32)(c_day)

	return year, month, day
}

// Places a visual marker on a particular day.
/*

C function : gtk_calendar_mark_day
*/
func (recv *Calendar) MarkDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_mark_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// Selects a day from the current month.
/*

C function : gtk_calendar_select_day
*/
func (recv *Calendar) SelectDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_select_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// Shifts the calendar to a different month.
/*

C function : gtk_calendar_select_month
*/
func (recv *Calendar) SelectMonth(month uint32, year uint32) {
	c_month := (C.guint)(month)

	c_year := (C.guint)(year)

	C.gtk_calendar_select_month((*C.GtkCalendar)(recv.native), c_month, c_year)

	return
}

// Removes the visual marker from a particular day.
/*

C function : gtk_calendar_unmark_day
*/
func (recv *Calendar) UnmarkDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_unmark_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Calendar
func (recv *Calendar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Calendar
func (recv *Calendar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkCellAccessible
*/
type CellAccessible struct {
	native *C.GtkCellAccessible
	// parent : record
	// priv : record
}

func CellAccessibleNewFromC(u unsafe.Pointer) *CellAccessible {
	c := (*C.GtkCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &CellAccessible{native: c}

	return g
}

func (recv *CellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Accessible upcasts to *Accessible
func (recv *CellAccessible) Accessible() *Accessible {
	return AccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellAccessible) Object() *atk.Object {
	return recv.Accessible().Object()
}

// CastToWidget down casts any arbitary Object to CellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAccessible.
func CastToCellAccessible(object *gobject.Object) *CellAccessible {
	return CellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by CellAccessible
func (recv *CellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by CellAccessible
func (recv *CellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// The #GtkCellArea is an abstract class for #GtkCellLayout widgets
// (also referred to as "layouting widgets") to interface with an
// arbitrary number of #GtkCellRenderers and interact with the user
// for a given #GtkTreeModel row.
//
// The cell area handles events, focus navigation, drawing and
// size requests and allocations for a given row of data.
//
// Usually users dont have to interact with the #GtkCellArea directly
// unless they are implementing a cell-layouting widget themselves.
//
// # Requesting area sizes
//
// As outlined in
// [GtkWidgets geometry management section][geometry-management],
// GTK+ uses a height-for-width
// geometry management system to compute the sizes of widgets and user
// interfaces. #GtkCellArea uses the same semantics to calculate the
// size of an area for an arbitrary number of #GtkTreeModel rows.
//
// When requesting the size of a cell area one needs to calculate
// the size for a handful of rows, and this will be done differently by
// different layouting widgets. For instance a #GtkTreeViewColumn
// always lines up the areas from top to bottom while a #GtkIconView
// on the other hand might enforce that all areas received the same
// width and wrap the areas around, requesting height for more cell
// areas when allocated less width.
//
// Its also important for areas to maintain some cell
// alignments with areas rendered for adjacent rows (cells can
// appear columnized inside an area even when the size of
// cells are different in each row). For this reason the #GtkCellArea
// uses a #GtkCellAreaContext object to store the alignments
// and sizes along the way (as well as the overall largest minimum
// and natural size for all the rows which have been calculated
// with the said context).
//
// The #GtkCellAreaContext is an opaque object specific to the
// #GtkCellArea which created it (see gtk_cell_area_create_context()).
// The owning cell-layouting widget can create as many contexts as
// it wishes to calculate sizes of rows which should receive the
// same size in at least one orientation (horizontally or vertically),
// However, its important that the same #GtkCellAreaContext which
// was used to request the sizes for a given #GtkTreeModel row be
// used when rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level
// of a #GtkTreeModel one would do the following:
//
// |[<!-- language="C" -->
// GtkTreeIter iter;
// gint        minimum_width;
// gint        natural_width;
//
// valid = gtk_tree_model_get_iter_first (model, &iter);
// while (valid)
// {
// gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
// gtk_cell_area_get_preferred_width (area, context, widget, NULL, NULL);
//
// valid = gtk_tree_model_iter_next (model, &iter);
// }
// gtk_cell_area_context_get_preferred_width (context, &minimum_width, &natural_width);
// ]|
//
// Note that in this example its not important to observe the
// returned minimum and natural width of the area for each row
// unless the cell-layouting object is actually interested in the
// widths of individual rows. The overall width is however stored
// in the accompanying #GtkCellAreaContext object and can be consulted
// at any time.
//
// This can be useful since #GtkCellLayout widgets usually have to
// support requesting and rendering rows in treemodels with an
// exceedingly large amount of rows. The #GtkCellLayout widget in
// that case would calculate the required width of the rows in an
// idle or timeout source (see g_timeout_add()) and when the widget
// is requested its actual width in #GtkWidgetClass.get_preferred_width()
// it can simply consult the width accumulated so far in the
// #GtkCellAreaContext object.
//
// A simple example where rows are rendered from top to bottom and
// take up the full width of the layouting widget would look like:
//
// |[<!-- language="C" -->
// static void
// foo_get_preferred_width (GtkWidget       *widget,
// gint            *minimum_size,
// gint            *natural_size)
// {
// Foo        *foo  = FOO (widget);
// FooPrivate *priv = foo->priv;
//
// foo_ensure_at_least_one_handfull_of_rows_have_been_requested (foo);
//
// gtk_cell_area_context_get_preferred_width (priv->context, minimum_size, natural_size);
// }
// ]|
//
// In the above example the Foo widget has to make sure that some
// row sizes have been calculated (the amount of rows that Foo judged
// was appropriate to request space for in a single timeout iteration)
// before simply returning the amount of space required by the area via
// the #GtkCellAreaContext.
//
// Requesting the height for width (or width for height) of an area is
// a similar task except in this case the #GtkCellAreaContext does not
// store the data (actually, it does not know how much space the layouting
// widget plans to allocate it for every row. Its up to the layouting
// widget to render each row of data with the appropriate height and
// width which was requested by the #GtkCellArea).
//
// In order to request the height for width of all the rows at the
// root level of a #GtkTreeModel one would do the following:
//
// |[<!-- language="C" -->
// GtkTreeIter iter;
// gint        minimum_height;
// gint        natural_height;
// gint        full_minimum_height = 0;
// gint        full_natural_height = 0;
//
// valid = gtk_tree_model_get_iter_first (model, &iter);
// while (valid)
// {
// gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
// gtk_cell_area_get_preferred_height_for_width (area, context, widget,
// width, &minimum_height, &natural_height);
//
// if (width_is_for_allocation)
// cache_row_height (&iter, minimum_height, natural_height);
//
// full_minimum_height += minimum_height;
// full_natural_height += natural_height;
//
// valid = gtk_tree_model_iter_next (model, &iter);
// }
// ]|
//
// Note that in the above example we would need to cache the heights
// returned for each row so that we would know what sizes to render the
// areas for each row. However we would only want to really cache the
// heights if the request is intended for the layouting widgets real
// allocation.
//
// In some cases the layouting widget is requested the height for an
// arbitrary for_width, this is a special case for layouting widgets
// who need to request size for tens of thousands  of rows. For this
// case its only important that the layouting widget calculate
// one reasonably sized chunk of rows and return that height
// synchronously. The reasoning here is that any layouting widget is
// at least capable of synchronously calculating enough height to fill
// the screen height (or scrolled window height) in response to a single
// call to #GtkWidgetClass.get_preferred_height_for_width(). Returning
// a perfect height for width that is larger than the screen area is
// inconsequential since after the layouting receives an allocation
// from a scrolled window it simply continues to drive the scrollbar
// values while more and more height is required for the row heights
// that are calculated in the background.
//
// # Rendering Areas
//
// Once area sizes have been aquired at least for the rows in the
// visible area of the layouting widget they can be rendered at
// #GtkWidgetClass.draw() time.
//
// A crude example of how to render all the rows at the root level
// runs as follows:
//
// |[<!-- language="C" -->
// GtkAllocation allocation;
// GdkRectangle  cell_area = { 0, };
// GtkTreeIter   iter;
// gint          minimum_width;
// gint          natural_width;
//
// gtk_widget_get_allocation (widget, &allocation);
// cell_area.width = allocation.width;
//
// valid = gtk_tree_model_get_iter_first (model, &iter);
// while (valid)
// {
// cell_area.height = get_cached_height_for_row (&iter);
//
// gtk_cell_area_apply_attributes (area, model, &iter, FALSE, FALSE);
// gtk_cell_area_render (area, context, widget, cr,
// &cell_area, &cell_area, state_flags, FALSE);
//
// cell_area.y += cell_area.height;
//
// valid = gtk_tree_model_iter_next (model, &iter);
// }
// ]|
//
// Note that the cached height in this example really depends on how
// the layouting widget works. The layouting widget might decide to
// give every row its minimum or natural height or, if the model content
// is expected to fit inside the layouting widget without scrolling, it
// would make sense to calculate the allocation for each row at
// #GtkWidget::size-allocate time using gtk_distribute_natural_allocation().
//
// # Handling Events and Driving Keyboard Focus
//
// Passing events to the area is as simple as handling events on any
// normal widget and then passing them to the gtk_cell_area_event()
// API as they come in. Usually #GtkCellArea is only interested in
// button events, however some customized derived areas can be implemented
// who are interested in handling other events. Handling an event can
// trigger the #GtkCellArea::focus-changed signal to fire; as well as
// #GtkCellArea::add-editable in the case that an editable cell was
// clicked and needs to start editing. You can call
// gtk_cell_area_stop_editing() at any time to cancel any cell editing
// that is currently in progress.
//
// The #GtkCellArea drives keyboard focus from cell to cell in a way
// similar to #GtkWidget. For layouting widgets that support giving
// focus to cells its important to remember to pass %GTK_CELL_RENDERER_FOCUSED
// to the area functions for the row that has focus and to tell the
// area to paint the focus at render time.
//
// Layouting widgets that accept focus on cells should implement the
// #GtkWidgetClass.focus() virtual method. The layouting widget is always
// responsible for knowing where #GtkTreeModel rows are rendered inside
// the widget, so at #GtkWidgetClass.focus() time the layouting widget
// should use the #GtkCellArea methods to navigate focus inside the area
// and then observe the GtkDirectionType to pass the focus to adjacent
// rows and areas.
//
// A basic example of how the #GtkWidgetClass.focus() virtual method
// should be implemented:
//
// |[<!-- language="C" -->
// static gboolean
// foo_focus (GtkWidget       *widget,
// GtkDirectionType direction)
// {
// Foo        *foo  = FOO (widget);
// FooPrivate *priv = foo->priv;
// gint        focus_row;
// gboolean    have_focus = FALSE;
//
// focus_row = priv->focus_row;
//
// if (!gtk_widget_has_focus (widget))
// gtk_widget_grab_focus (widget);
//
// valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
// while (valid)
// {
// gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
// if (gtk_cell_area_focus (priv->area, direction))
// {
// priv->focus_row = focus_row;
// have_focus = TRUE;
// break;
// }
// else
// {
// if (direction == GTK_DIR_RIGHT ||
// direction == GTK_DIR_LEFT)
// break;
// else if (direction == GTK_DIR_UP ||
// direction == GTK_DIR_TAB_BACKWARD)
// {
// if (focus_row == 0)
// break;
// else
// {
// focus_row--;
// valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
// }
// }
// else
// {
// if (focus_row == last_row)
// break;
// else
// {
// focus_row++;
// valid = gtk_tree_model_iter_next (priv->model, &iter);
// }
// }
// }
// }
// return have_focus;
// }
// ]|
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
// # Cell Properties
//
// The #GtkCellArea introduces cell properties for #GtkCellRenderers
// in very much the same way that #GtkContainer introduces
// [child properties][child-properties]
// for #GtkWidgets. This provides some general interfaces for defining
// the relationship cell areas have with their cells. For instance in a
// #GtkCellAreaBox a cell might expand and receive extra space when
// the area is allocated more than its full natural request, or a cell
// might be configured to align with adjacent rows which were requested
// and rendered with the same #GtkCellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell
// properties for a cell area class and gtk_cell_area_class_find_cell_property()
// or gtk_cell_area_class_list_cell_properties() to get information about
// existing cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain
// the value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
/*

C record/class : GtkCellArea
*/
type CellArea struct {
	native *C.GtkCellArea
	// Private : parent_instance
	// Private : priv
}

func CellAreaNewFromC(u unsafe.Pointer) *CellArea {
	c := (*C.GtkCellArea)(u)
	if c == nil {
		return nil
	}

	g := &CellArea{native: c}

	return g
}

func (recv *CellArea) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellArea) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellArea) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to CellArea.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellArea.
func CastToCellArea(object *gobject.Object) *CellArea {
	return CellAreaNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by CellArea
func (recv *CellArea) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellArea
func (recv *CellArea) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// The #GtkCellAreaBox renders cell renderers into a row or a column
// depending on its #GtkOrientation.
//
// GtkCellAreaBox uses a notion of packing. Packing
// refers to adding cell renderers with reference to a particular position
// in a #GtkCellAreaBox. There are two reference positions: the
// start and the end of the box.
// When the #GtkCellAreaBox is oriented in the %GTK_ORIENTATION_VERTICAL
// orientation, the start is defined as the top of the box and the end is
// defined as the bottom. In the %GTK_ORIENTATION_HORIZONTAL orientation
// start is defined as the left side and the end is defined as the right
// side.
//
// Alignments of #GtkCellRenderers rendered in adjacent rows can be
// configured by configuring the #GtkCellAreaBox align child cell property
// with gtk_cell_area_cell_set_property() or by specifying the "align"
// argument to gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
/*

C record/class : GtkCellAreaBox
*/
type CellAreaBox struct {
	native *C.GtkCellAreaBox
	// Private : parent_instance
	// Private : priv
}

func CellAreaBoxNewFromC(u unsafe.Pointer) *CellAreaBox {
	c := (*C.GtkCellAreaBox)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaBox{native: c}

	return g
}

func (recv *CellAreaBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellArea upcasts to *CellArea
func (recv *CellAreaBox) CellArea() *CellArea {
	return CellAreaNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellAreaBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellArea().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellAreaBox) Object() *gobject.Object {
	return recv.CellArea().Object()
}

// CastToWidget down casts any arbitary Object to CellAreaBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAreaBox.
func CastToCellAreaBox(object *gobject.Object) *CellAreaBox {
	return CellAreaBoxNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by CellAreaBox
func (recv *CellAreaBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellAreaBox
func (recv *CellAreaBox) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by CellAreaBox
func (recv *CellAreaBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkCellAreaContext object is created by a given #GtkCellArea
// implementation via its #GtkCellAreaClass.create_context() virtual
// method and is used to store cell sizes and alignments for a series of
// #GtkTreeModel rows that are requested and rendered in the same context.
//
// #GtkCellLayout widgets can create any number of contexts in which to
// request and render groups of data rows. However, its important that the
// same context which was used to request sizes for a given #GtkTreeModel
// row also be used for the same row when calling other #GtkCellArea APIs
// such as gtk_cell_area_render() and gtk_cell_area_event().
/*

C record/class : GtkCellAreaContext
*/
type CellAreaContext struct {
	native *C.GtkCellAreaContext
	// Private : parent_instance
	// Private : priv
}

func CellAreaContextNewFromC(u unsafe.Pointer) *CellAreaContext {
	c := (*C.GtkCellAreaContext)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaContext{native: c}

	return g
}

func (recv *CellAreaContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *CellAreaContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to CellAreaContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAreaContext.
func CastToCellAreaContext(object *gobject.Object) *CellAreaContext {
	return CellAreaContextNewFromC(object.ToC())
}

// Allocates a width and/or a height for all rows which are to be
// rendered with @context.
//
// Usually allocation is performed only horizontally or sometimes
// vertically since a group of rows are usually rendered side by
// side vertically or horizontally and share either the same width
// or the same height. Sometimes they are allocated in both horizontal
// and vertical orientations producing a homogeneous effect of the
// rows. This is generally the case for #GtkTreeView when
// #GtkTreeView:fixed-height-mode is enabled.
//
// Since 3.0
/*

C function : gtk_cell_area_context_allocate
*/
func (recv *CellAreaContext) Allocate(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_cell_area_context_allocate((*C.GtkCellAreaContext)(recv.native), c_width, c_height)

	return
}

// Resets any previously cached request and allocation
// data.
//
// When underlying #GtkTreeModel data changes its
// important to reset the context if the content
// size is allowed to shrink. If the content size
// is only allowed to grow (this is usually an option
// for views rendering large data stores as a measure
// of optimization), then only the row that changed
// or was inserted needs to be (re)requested with
// gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires
// that the allocated size changes (or whenever this
// allocation changes at all), the variable row
// sizes need to be re-requested for every row.
//
// For instance, if the rows are displayed all with
// the same width from top to bottom then a change
// in the allocated width necessitates a recalculation
// of all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
//
// Since 3.0
/*

C function : gtk_cell_area_context_reset
*/
func (recv *CellAreaContext) Reset() {
	C.gtk_cell_area_context_reset((*C.GtkCellAreaContext)(recv.native))

	return
}

// The #GtkCellRenderer is a base class of a set of objects used for
// rendering a cell to a #cairo_t.  These objects are used primarily by
// the #GtkTreeView widget, though they arent tied to them in any
// specific way.  It is worth noting that #GtkCellRenderer is not a
// #GtkWidget and cannot be treated as such.
//
// The primary use of a #GtkCellRenderer is for drawing a certain graphical
// elements on a #cairo_t. Typically, one cell renderer is used to
// draw many cells on the screen.  To this extent, it isnt expected that a
// CellRenderer keep any permanent state around.  Instead, any state is set
// just prior to use using #GObjects property system.  Then, the
// cell is measured using gtk_cell_renderer_get_size(). Finally, the cell
// is rendered in the correct location using gtk_cell_renderer_render().
//
// There are a number of rules that must be followed when writing a new
// #GtkCellRenderer.  First and foremost, its important that a certain set
// of properties will always yield a cell renderer of the same size,
// barring a #GtkStyle change.  The #GtkCellRenderer also has a number of
// generic properties that are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally
// provide active user interface elements. A cell renderer can be
// activatable like #GtkCellRendererToggle,
// which toggles when it gets activated by a mouse click, or it can be
// editable like #GtkCellRendererText, which
// allows the user to edit the text using a #GtkEntry.
// To make a cell renderer activatable or editable, you have to
// implement the #GtkCellRendererClass.activate or
// #GtkCellRendererClass.start_editing virtual functions, respectively.
//
// Many properties of #GtkCellRenderer and its subclasses have a
// corresponding set property, e.g. cell-background-set corresponds
// to cell-background. These set properties reflect whether a property
// has been set or not. You should not set them independently.
/*

C record/class : GtkCellRenderer
*/
type CellRenderer struct {
	native *C.GtkCellRenderer
	// parent_instance : record
	// Private : priv
}

func CellRendererNewFromC(u unsafe.Pointer) *CellRenderer {
	c := (*C.GtkCellRenderer)(u)
	if c == nil {
		return nil
	}

	g := &CellRenderer{native: c}

	return g
}

func (recv *CellRenderer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRenderer) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellRenderer) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to CellRenderer.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRenderer.
func CastToCellRenderer(object *gobject.Object) *CellRenderer {
	return CellRendererNewFromC(object.ToC())
}

// Unsupported : gtk_cell_renderer_activate : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Fills in @width and @height with the appropriate size of @cell.
/*

C function : gtk_cell_renderer_get_fixed_size
*/
func (recv *CellRenderer) GetFixedSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_cell_renderer_get_fixed_size((*C.GtkCellRenderer)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// Unsupported : gtk_cell_renderer_get_size : unsupported parameter cell_area : Blacklisted record : GdkRectangle

// Unsupported : gtk_cell_renderer_render : unsupported parameter background_area : Blacklisted record : GdkRectangle

// Sets the renderer size to be explicit, independent of the properties set.
/*

C function : gtk_cell_renderer_set_fixed_size
*/
func (recv *CellRenderer) SetFixedSize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_cell_renderer_set_fixed_size((*C.GtkCellRenderer)(recv.native), c_width, c_height)

	return
}

// Unsupported : gtk_cell_renderer_start_editing : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// #GtkCellRendererAccel displays a keyboard accelerator (i.e. a key
// combination like `Control + a`). If the cell renderer is editable,
// the accelerator can be changed by simply typing the new combination.
//
// The #GtkCellRendererAccel cell renderer was added in GTK+ 2.10.
/*

C record/class : GtkCellRendererAccel
*/
type CellRendererAccel struct {
	native *C.GtkCellRendererAccel
	// parent : record
	// Private : priv
}

func CellRendererAccelNewFromC(u unsafe.Pointer) *CellRendererAccel {
	c := (*C.GtkCellRendererAccel)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererAccel{native: c}

	return g
}

func (recv *CellRendererAccel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererAccel) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererAccel) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererAccel) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererAccel) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererAccel.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererAccel.
func CastToCellRendererAccel(object *gobject.Object) *CellRendererAccel {
	return CellRendererAccelNewFromC(object.ToC())
}

// #GtkCellRendererCombo renders text in a cell like #GtkCellRendererText from
// which it is derived. But while #GtkCellRendererText offers a simple entry to
// edit the text, #GtkCellRendererCombo offers a #GtkComboBox
// widget to edit the text. The values to display in the combo box are taken from
// the tree model specified in the #GtkCellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer to the combo
// box and sets it to display the column specified by its
// #GtkCellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the #GtkCellRenderer::editing-started signal.
//
// The #GtkCellRendererCombo cell renderer was added in GTK+ 2.6.
/*

C record/class : GtkCellRendererCombo
*/
type CellRendererCombo struct {
	native *C.GtkCellRendererCombo
	// parent : record
	// Private : priv
}

func CellRendererComboNewFromC(u unsafe.Pointer) *CellRendererCombo {
	c := (*C.GtkCellRendererCombo)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererCombo{native: c}

	return g
}

func (recv *CellRendererCombo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererCombo) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererCombo) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererCombo) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererCombo) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererCombo.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererCombo.
func CastToCellRendererCombo(object *gobject.Object) *CellRendererCombo {
	return CellRendererComboNewFromC(object.ToC())
}

// A #GtkCellRendererPixbuf can be used to render an image in a cell. It allows
// to render either a given #GdkPixbuf (set via the
// #GtkCellRendererPixbuf:pixbuf property) or a named icon (set via the
// #GtkCellRendererPixbuf:icon-name property).
//
// To support the tree view, #GtkCellRendererPixbuf also supports rendering two
// alternative pixbufs, when the #GtkCellRenderer:is-expander property is %TRUE.
// If the #GtkCellRenderer:is-expanded property is %TRUE and the
// #GtkCellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the #GtkCellRenderer:is-expanded property is %FALSE
// and the #GtkCellRendererPixbuf:pixbuf-expander-closed property is set to a
// pixbuf, it renders that one.
/*

C record/class : GtkCellRendererPixbuf
*/
type CellRendererPixbuf struct {
	native *C.GtkCellRendererPixbuf
	// parent : record
	// Private : priv
}

func CellRendererPixbufNewFromC(u unsafe.Pointer) *CellRendererPixbuf {
	c := (*C.GtkCellRendererPixbuf)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererPixbuf{native: c}

	return g
}

func (recv *CellRendererPixbuf) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererPixbuf) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererPixbuf) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererPixbuf) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererPixbuf.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererPixbuf.
func CastToCellRendererPixbuf(object *gobject.Object) *CellRendererPixbuf {
	return CellRendererPixbufNewFromC(object.ToC())
}

// Creates a new #GtkCellRendererPixbuf. Adjust rendering
// parameters using object properties. Object properties can be set
// globally (with g_object_set()). Also, with #GtkTreeViewColumn, you
// can bind a property to a value in a #GtkTreeModel. For example, you
// can bind the pixbuf property on the cell renderer to a pixbuf value
// in the model, thus rendering a different image in each row of the
// #GtkTreeView.
/*

C function : gtk_cell_renderer_pixbuf_new
*/
func CellRendererPixbufNew() *CellRendererPixbuf {
	retC := C.gtk_cell_renderer_pixbuf_new()
	retGo := CellRendererPixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// #GtkCellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
//
// The #GtkCellRendererProgress cell renderer was added in GTK+ 2.6.
/*

C record/class : GtkCellRendererProgress
*/
type CellRendererProgress struct {
	native *C.GtkCellRendererProgress
	// parent_instance : record
	// Private : priv
}

func CellRendererProgressNewFromC(u unsafe.Pointer) *CellRendererProgress {
	c := (*C.GtkCellRendererProgress)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererProgress{native: c}

	return g
}

func (recv *CellRendererProgress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererProgress) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererProgress) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererProgress) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererProgress.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererProgress.
func CastToCellRendererProgress(object *gobject.Object) *CellRendererProgress {
	return CellRendererProgressNewFromC(object.ToC())
}

// Orientable returns the Orientable interface implemented by CellRendererProgress
func (recv *CellRendererProgress) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// #GtkCellRendererSpin renders text in a cell like #GtkCellRendererText from
// which it is derived. But while #GtkCellRendererText offers a simple entry to
// edit the text, #GtkCellRendererSpin offers a #GtkSpinButton widget. Of course,
// that means that the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the
// cell renderer, which can be set explicitly or mapped to a column in the
// tree model, like all properties of cell renders. #GtkCellRendererSpin
// also has properties for the #GtkCellRendererSpin:climb-rate and the number
// of #GtkCellRendererSpin:digits to display. Other #GtkSpinButton properties
// can be set in a handler for the #GtkCellRenderer::editing-started signal.
//
// The #GtkCellRendererSpin cell renderer was added in GTK+ 2.10.
/*

C record/class : GtkCellRendererSpin
*/
type CellRendererSpin struct {
	native *C.GtkCellRendererSpin
	// parent : record
	// Private : priv
}

func CellRendererSpinNewFromC(u unsafe.Pointer) *CellRendererSpin {
	c := (*C.GtkCellRendererSpin)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpin{native: c}

	return g
}

func (recv *CellRendererSpin) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererSpin) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererSpin) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererSpin) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererSpin) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererSpin.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererSpin.
func CastToCellRendererSpin(object *gobject.Object) *CellRendererSpin {
	return CellRendererSpinNewFromC(object.ToC())
}

// GtkCellRendererSpinner renders a spinning animation in a cell, very
// similar to #GtkSpinner. It can often be used as an alternative
// to a #GtkCellRendererProgress for displaying indefinite activity,
// instead of actual progress.
//
// To start the animation in a cell, set the #GtkCellRendererSpinner:active
// property to %TRUE and increment the #GtkCellRendererSpinner:pulse property
// at regular intervals. The usual way to set the cell renderer properties
// for each cell is to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
/*

C record/class : GtkCellRendererSpinner
*/
type CellRendererSpinner struct {
	native *C.GtkCellRendererSpinner
	// parent : record
	// Private : priv
}

func CellRendererSpinnerNewFromC(u unsafe.Pointer) *CellRendererSpinner {
	c := (*C.GtkCellRendererSpinner)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpinner{native: c}

	return g
}

func (recv *CellRendererSpinner) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererSpinner) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererSpinner) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererSpinner) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererSpinner.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererSpinner.
func CastToCellRendererSpinner(object *gobject.Object) *CellRendererSpinner {
	return CellRendererSpinnerNewFromC(object.ToC())
}

// A #GtkCellRendererText renders a given text in its cell, using the font, color and
// style information provided by its properties. The text will be ellipsized if it is
// too long and the #GtkCellRendererText:ellipsize property allows it.
//
// If the #GtkCellRenderer:mode is %GTK_CELL_RENDERER_MODE_EDITABLE,
// the #GtkCellRendererText allows to edit its text using an entry.
/*

C record/class : GtkCellRendererText
*/
type CellRendererText struct {
	native *C.GtkCellRendererText
	// parent : record
	// Private : priv
}

func CellRendererTextNewFromC(u unsafe.Pointer) *CellRendererText {
	c := (*C.GtkCellRendererText)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererText{native: c}

	return g
}

func (recv *CellRendererText) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererText) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererText) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererText) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererText.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererText.
func CastToCellRendererText(object *gobject.Object) *CellRendererText {
	return CellRendererTextNewFromC(object.ToC())
}

// Unsupported signal 'edited' for CellRendererText : unsupported parameter path : type utf8 :

// Creates a new #GtkCellRendererText. Adjust how text is drawn using
// object properties. Object properties can be
// set globally (with g_object_set()). Also, with #GtkTreeViewColumn,
// you can bind a property to a value in a #GtkTreeModel. For example,
// you can bind the text property on the cell renderer to a string
// value in the model, thus rendering a different string in each row
// of the #GtkTreeView
/*

C function : gtk_cell_renderer_text_new
*/
func CellRendererTextNew() *CellRendererText {
	retC := C.gtk_cell_renderer_text_new()
	retGo := CellRendererTextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the height of a renderer to explicitly be determined by the font and
// y_pad property set on it.  Further changes in these properties do not
// affect the height, so they must be accompanied by a subsequent call to this
// function.  Using this function is unflexible, and should really only be used
// if calculating the size of a cell is too slow (ie, a massive number of cells
// displayed).  If @number_of_rows is -1, then the fixed height is unset, and
// the height is determined by the properties again.
/*

C function : gtk_cell_renderer_text_set_fixed_height_from_font
*/
func (recv *CellRendererText) SetFixedHeightFromFont(numberOfRows int32) {
	c_number_of_rows := (C.gint)(numberOfRows)

	C.gtk_cell_renderer_text_set_fixed_height_from_font((*C.GtkCellRendererText)(recv.native), c_number_of_rows)

	return
}

// #GtkCellRendererToggle renders a toggle button in a cell. The
// button is drawn as a radio or a checkbutton, depending on the
// #GtkCellRendererToggle:radio property.
// When activated, it emits the #GtkCellRendererToggle::toggled signal.
/*

C record/class : GtkCellRendererToggle
*/
type CellRendererToggle struct {
	native *C.GtkCellRendererToggle
	// parent : record
	// Private : priv
}

func CellRendererToggleNewFromC(u unsafe.Pointer) *CellRendererToggle {
	c := (*C.GtkCellRendererToggle)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererToggle{native: c}

	return g
}

func (recv *CellRendererToggle) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererToggle) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererToggle) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererToggle) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererToggle.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererToggle.
func CastToCellRendererToggle(object *gobject.Object) *CellRendererToggle {
	return CellRendererToggleNewFromC(object.ToC())
}

// Unsupported signal 'toggled' for CellRendererToggle : unsupported parameter path : type utf8 :

// Creates a new #GtkCellRendererToggle. Adjust rendering
// parameters using object properties. Object properties can be set
// globally (with g_object_set()). Also, with #GtkTreeViewColumn, you
// can bind a property to a value in a #GtkTreeModel. For example, you
// can bind the active property on the cell renderer to a boolean value
// in the model, thus causing the check button to reflect the state of
// the model.
/*

C function : gtk_cell_renderer_toggle_new
*/
func CellRendererToggleNew() *CellRendererToggle {
	retC := C.gtk_cell_renderer_toggle_new()
	retGo := CellRendererToggleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
/*

C function : gtk_cell_renderer_toggle_get_active
*/
func (recv *CellRendererToggle) GetActive() bool {
	retC := C.gtk_cell_renderer_toggle_get_active((*C.GtkCellRendererToggle)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether were rendering radio toggles rather than checkboxes.
/*

C function : gtk_cell_renderer_toggle_get_radio
*/
func (recv *CellRendererToggle) GetRadio() bool {
	retC := C.gtk_cell_renderer_toggle_get_radio((*C.GtkCellRendererToggle)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Activates or deactivates a cell renderer.
/*

C function : gtk_cell_renderer_toggle_set_active
*/
func (recv *CellRendererToggle) SetActive(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_cell_renderer_toggle_set_active((*C.GtkCellRendererToggle)(recv.native), c_setting)

	return
}

// If @radio is %TRUE, the cell renderer renders a radio toggle
// (i.e. a toggle in a group of mutually-exclusive toggles).
// If %FALSE, it renders a check toggle (a standalone boolean option).
// This can be set globally for the cell renderer, or changed just
// before rendering each cell in the model (for #GtkTreeView, you set
// up a per-row setting using #GtkTreeViewColumn to associate model
// columns with cell renderer properties).
/*

C function : gtk_cell_renderer_toggle_set_radio
*/
func (recv *CellRendererToggle) SetRadio(radio bool) {
	c_radio :=
		boolToGboolean(radio)

	C.gtk_cell_renderer_toggle_set_radio((*C.GtkCellRendererToggle)(recv.native), c_radio)

	return
}

// A #GtkCellView displays a single row of a #GtkTreeModel using a #GtkCellArea
// and #GtkCellAreaContext. A #GtkCellAreaContext can be provided to the
// #GtkCellView at construction time in order to keep the cellview in context
// of a group of cell views, this ensures that the renderers displayed will
// be properly aligned with eachother (like the aligned cells in the menus
// of #GtkComboBox).
//
// #GtkCellView is #GtkOrientable in order to decide in which orientation
// the underlying #GtkCellAreaContext should be allocated. Taking the #GtkComboBox
// menu as an example, cellviews should be oriented horizontally if the menus are
// listed top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
// # CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
/*

C record/class : GtkCellView
*/
type CellView struct {
	native *C.GtkCellView
	// parent_instance : record
	// Private : priv
}

func CellViewNewFromC(u unsafe.Pointer) *CellView {
	c := (*C.GtkCellView)(u)
	if c == nil {
		return nil
	}

	g := &CellView{native: c}

	return g
}

func (recv *CellView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *CellView) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellView) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to CellView.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellView.
func CastToCellView(object *gobject.Object) *CellView {
	return CellViewNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by CellView
func (recv *CellView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CellView
func (recv *CellView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellView
func (recv *CellView) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by CellView
func (recv *CellView) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// A #GtkCheckButton places a discrete #GtkToggleButton next to a widget,
// (usually a #GtkLabel). See the section on #GtkToggleButton widgets for
// more information about toggle/check buttons.
//
// The important signal ( #GtkToggleButton::toggled ) is also inherited from
// #GtkToggleButton.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// checkbutton
//  check
//  <child>
// ]|
//
// A GtkCheckButton with indicator (see gtk_toggle_button_set_mode()) has a
// main CSS node with name checkbutton and a subnode with name check.
//
// |[<!-- language="plain" -->
// button.check
//  check
//  <child>
// ]|
//
// A GtkCheckButton without indicator changes the name of its main node
// to button and adds a .check style class to it. The subnode is invisible
// in this case.
/*

C record/class : GtkCheckButton
*/
type CheckButton struct {
	native *C.GtkCheckButton
	// toggle_button : record
}

func CheckButtonNewFromC(u unsafe.Pointer) *CheckButton {
	c := (*C.GtkCheckButton)(u)
	if c == nil {
		return nil
	}

	g := &CheckButton{native: c}

	return g
}

func (recv *CheckButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleButton upcasts to *ToggleButton
func (recv *CheckButton) ToggleButton() *ToggleButton {
	return ToggleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *CheckButton) Button() *Button {
	return recv.ToggleButton().Button()
}

// Bin upcasts to *Bin
func (recv *CheckButton) Bin() *Bin {
	return recv.ToggleButton().Bin()
}

// Container upcasts to *Container
func (recv *CheckButton) Container() *Container {
	return recv.ToggleButton().Container()
}

// Widget upcasts to *Widget
func (recv *CheckButton) Widget() *Widget {
	return recv.ToggleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CheckButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CheckButton) Object() *gobject.Object {
	return recv.ToggleButton().Object()
}

// CastToWidget down casts any arbitary Object to CheckButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckButton.
func CastToCheckButton(object *gobject.Object) *CheckButton {
	return CheckButtonNewFromC(object.ToC())
}

// Creates a new #GtkCheckButton.
/*

C function : gtk_check_button_new
*/
func CheckButtonNew() *CheckButton {
	retC := C.gtk_check_button_new()
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkCheckButton with a #GtkLabel to the right of it.
/*

C function : gtk_check_button_new_with_label
*/
func CheckButtonNewWithLabel(label string) *CheckButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_button_new_with_label(c_label)
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkCheckButton containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the check button.
/*

C function : gtk_check_button_new_with_mnemonic
*/
func CheckButtonNewWithMnemonic(label string) *CheckButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_button_new_with_mnemonic(c_label)
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by CheckButton
func (recv *CheckButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by CheckButton
func (recv *CheckButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by CheckButton
func (recv *CheckButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CheckButton
func (recv *CheckButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A #GtkCheckMenuItem is a menu item that maintains the state of a boolean
// value in addition to a #GtkMenuItem usual role in activating application
// code.
//
// A check box indicating the state of the boolean value is displayed
// at the left side of the #GtkMenuItem.  Activating the #GtkMenuItem
// toggles the value.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// menuitem
//  check.left
//  <child>
// ]|
//
// GtkCheckMenuItem has a main CSS node with name menuitem, and a subnode
// with name check, which gets the .left or .right style class.
/*

C record/class : GtkCheckMenuItem
*/
type CheckMenuItem struct {
	native *C.GtkCheckMenuItem
	// menu_item : record
	// Private : priv
}

func CheckMenuItemNewFromC(u unsafe.Pointer) *CheckMenuItem {
	c := (*C.GtkCheckMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItem{native: c}

	return g
}

func (recv *CheckMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItem upcasts to *MenuItem
func (recv *CheckMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *CheckMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *CheckMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *CheckMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CheckMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CheckMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitary Object to CheckMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckMenuItem.
func CastToCheckMenuItem(object *gobject.Object) *CheckMenuItem {
	return CheckMenuItemNewFromC(object.ToC())
}

type signalCheckMenuItemToggledDetail struct {
	callback  CheckMenuItemSignalToggledCallback
	handlerID C.gulong
}

var signalCheckMenuItemToggledId int
var signalCheckMenuItemToggledMap = make(map[int]signalCheckMenuItemToggledDetail)
var signalCheckMenuItemToggledLock sync.Mutex

// CheckMenuItemSignalToggledCallback is a callback function for a 'toggled' signal emitted from a CheckMenuItem.
type CheckMenuItemSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the CheckMenuItem.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *CheckMenuItem) ConnectToggled(callback CheckMenuItemSignalToggledCallback) int {
	signalCheckMenuItemToggledLock.Lock()
	defer signalCheckMenuItemToggledLock.Unlock()

	signalCheckMenuItemToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.CheckMenuItem_signal_connect_toggled(instance, C.gpointer(uintptr(signalCheckMenuItemToggledId)))

	detail := signalCheckMenuItemToggledDetail{callback, handlerID}
	signalCheckMenuItemToggledMap[signalCheckMenuItemToggledId] = detail

	return signalCheckMenuItemToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the CheckMenuItem.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *CheckMenuItem) DisconnectToggled(connectionID int) {
	signalCheckMenuItemToggledLock.Lock()
	defer signalCheckMenuItemToggledLock.Unlock()

	detail, exists := signalCheckMenuItemToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCheckMenuItemToggledMap, connectionID)
}

//export checkmenuitem_toggledHandler
func checkmenuitem_toggledHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCheckMenuItemToggledMap[index].callback
	callback()
}

// Creates a new #GtkCheckMenuItem.
/*

C function : gtk_check_menu_item_new
*/
func CheckMenuItemNew() *CheckMenuItem {
	retC := C.gtk_check_menu_item_new()
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkCheckMenuItem with a label.
/*

C function : gtk_check_menu_item_new_with_label
*/
func CheckMenuItemNewWithLabel(label string) *CheckMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_menu_item_new_with_label(c_label)
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkCheckMenuItem containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
/*

C function : gtk_check_menu_item_new_with_mnemonic
*/
func CheckMenuItemNewWithMnemonic(label string) *CheckMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_menu_item_new_with_mnemonic(c_label)
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns whether the check menu item is active. See
// gtk_check_menu_item_set_active ().
/*

C function : gtk_check_menu_item_get_active
*/
func (recv *CheckMenuItem) GetActive() bool {
	retC := C.gtk_check_menu_item_get_active((*C.GtkCheckMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves the value set by gtk_check_menu_item_set_inconsistent().
/*

C function : gtk_check_menu_item_get_inconsistent
*/
func (recv *CheckMenuItem) GetInconsistent() bool {
	retC := C.gtk_check_menu_item_get_inconsistent((*C.GtkCheckMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the active state of the menu items check box.
/*

C function : gtk_check_menu_item_set_active
*/
func (recv *CheckMenuItem) SetActive(isActive bool) {
	c_is_active :=
		boolToGboolean(isActive)

	C.gtk_check_menu_item_set_active((*C.GtkCheckMenuItem)(recv.native), c_is_active)

	return
}

// If the user has selected a range of elements (such as some text or
// spreadsheet cells) that are affected by a boolean setting, and the
// current values in that range are inconsistent, you may want to
// display the check in an in between state. This function turns on
// in between display.  Normally you would turn off the inconsistent
// state again if the user explicitly selects a setting. This has to be
// done manually, gtk_check_menu_item_set_inconsistent() only affects
// visual appearance, it doesnt affect the semantics of the widget.
/*

C function : gtk_check_menu_item_set_inconsistent
*/
func (recv *CheckMenuItem) SetInconsistent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_check_menu_item_set_inconsistent((*C.GtkCheckMenuItem)(recv.native), c_setting)

	return
}

// Emits the #GtkCheckMenuItem::toggled signal.
/*

C function : gtk_check_menu_item_toggled
*/
func (recv *CheckMenuItem) Toggled() {
	C.gtk_check_menu_item_toggled((*C.GtkCheckMenuItem)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by CheckMenuItem
func (recv *CheckMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkCheckMenuItemAccessible
*/
type CheckMenuItemAccessible struct {
	native *C.GtkCheckMenuItemAccessible
	// parent : record
	// priv : record
}

func CheckMenuItemAccessibleNewFromC(u unsafe.Pointer) *CheckMenuItemAccessible {
	c := (*C.GtkCheckMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItemAccessible{native: c}

	return g
}

func (recv *CheckMenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItemAccessible upcasts to *MenuItemAccessible
func (recv *CheckMenuItemAccessible) MenuItemAccessible() *MenuItemAccessible {
	return MenuItemAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *CheckMenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.MenuItemAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *CheckMenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.MenuItemAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *CheckMenuItemAccessible) Accessible() *Accessible {
	return recv.MenuItemAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *CheckMenuItemAccessible) Object() *atk.Object {
	return recv.MenuItemAccessible().Object()
}

// CastToWidget down casts any arbitary Object to CheckMenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckMenuItemAccessible.
func CastToCheckMenuItemAccessible(object *gobject.Object) *CheckMenuItemAccessible {
	return CheckMenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// The #GtkClipboard object represents a clipboard of data shared
// between different processes or between different widgets in
// the same process. Each clipboard is identified by a name encoded as a
// #GdkAtom. (Conversion to and from strings can be done with
// gdk_atom_intern() and gdk_atom_name().) The default clipboard
// corresponds to the CLIPBOARD atom; another commonly used clipboard
// is the PRIMARY clipboard, which, in X, traditionally contains
// the currently selected text.
//
// To support having a number of different formats on the clipboard
// at the same time, the clipboard mechanism allows providing
// callbacks instead of the actual data.  When you set the contents
// of the clipboard, you can either supply the data directly (via
// functions like gtk_clipboard_set_text()), or you can supply a
// callback to be called at a later time when the data is needed (via
// gtk_clipboard_set_with_data() or gtk_clipboard_set_with_owner().)
// Providing a callback also avoids having to make copies of the data
// when it is not needed.
//
// gtk_clipboard_set_with_data() and gtk_clipboard_set_with_owner()
// are quite similar; the choice between the two depends mostly on
// which is more convenient in a particular situation.
// The former is most useful when you want to have a blob of data
// with callbacks to convert it into the various data types that you
// advertise. When the @clear_func you provided is called, you
// simply free the data blob. The latter is more useful when the
// contents of clipboard reflect the internal state of a #GObject
// (As an example, for the PRIMARY clipboard, when an entry widget
// provides the clipboards contents the contents are simply the
// text within the selected region.) If the contents change, the
// entry widget can call gtk_clipboard_set_with_owner() to update
// the timestamp for clipboard ownership, without having to worry
// about @clear_func being called.
//
// Requesting the data from the clipboard is essentially
// asynchronous. If the contents of the clipboard are provided within
// the same process, then a direct function call will be made to
// retrieve the data, but if they are provided by another process,
// then the data needs to be retrieved from the other process, which
// may take some time. To avoid blocking the user interface, the call
// to request the selection, gtk_clipboard_request_contents() takes a
// callback that will be called when the contents are received (or
// when the request fails.) If you dont want to deal with providing
// a separate callback, you can also use gtk_clipboard_wait_for_contents().
// What this does is run the GLib main loop recursively waiting for
// the contents. This can simplify the code flow, but you still have
// to be aware that other callbacks in your program can be called
// while this recursive mainloop is running.
//
// Along with the functions to get the clipboard contents as an
// arbitrary data chunk, there are also functions to retrieve
// it as text, gtk_clipboard_request_text() and
// gtk_clipboard_wait_for_text(). These functions take care of
// determining which formats are advertised by the clipboard
// provider, asking for the clipboard in the best available format
// and converting the results into the UTF-8 encoding. (The standard
// form for representing strings in GTK+.)
/*

C record/class : GtkClipboard
*/
type Clipboard struct {
	native *C.GtkClipboard
}

func ClipboardNewFromC(u unsafe.Pointer) *Clipboard {
	c := (*C.GtkClipboard)(u)
	if c == nil {
		return nil
	}

	g := &Clipboard{native: c}

	return g
}

func (recv *Clipboard) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Clipboard) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Clipboard.
// Exercise care, as this is a potentially dangerous function if the Object is not a Clipboard.
func CastToClipboard(object *gobject.Object) *Clipboard {
	return ClipboardNewFromC(object.ToC())
}

// Clears the contents of the clipboard. Generally this should only
// be called between the time you call gtk_clipboard_set_with_owner()
// or gtk_clipboard_set_with_data(),
// and when the @clear_func you supplied is called. Otherwise, the
// clipboard may be owned by someone else.
/*

C function : gtk_clipboard_clear
*/
func (recv *Clipboard) Clear() {
	C.gtk_clipboard_clear((*C.GtkClipboard)(recv.native))

	return
}

// If the clipboard contents callbacks were set with
// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
// gtk_clipboard_clear() has not subsequently called, returns the owner set
// by gtk_clipboard_set_with_owner().
/*

C function : gtk_clipboard_get_owner
*/
func (recv *Clipboard) GetOwner() *gobject.Object {
	retC := C.gtk_clipboard_get_owner((*C.GtkClipboard)(recv.native))
	var retGo (*gobject.Object)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gobject.ObjectNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_clipboard_request_contents : unsupported parameter target : Blacklisted record : GdkAtom

// Unsupported : gtk_clipboard_request_text : unsupported parameter callback : no type generator for ClipboardTextReceivedFunc (GtkClipboardTextReceivedFunc) for param callback

// Sets the contents of the clipboard to the given UTF-8 string. GTK+ will
// make a copy of the text and take responsibility for responding
// for requests for the text, and for converting the text into
// the requested format.
/*

C function : gtk_clipboard_set_text
*/
func (recv *Clipboard) SetText(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_clipboard_set_text((*C.GtkClipboard)(recv.native), c_text, c_len)

	return
}

// Unsupported : gtk_clipboard_set_with_data : unsupported parameter targets :

// Unsupported : gtk_clipboard_set_with_owner : unsupported parameter targets :

// Unsupported : gtk_clipboard_wait_for_contents : unsupported parameter target : Blacklisted record : GdkAtom

// Requests the contents of the clipboard as text and converts
// the result to UTF-8 if necessary. This function waits for
// the data to be received using the main loop, so events,
// timeouts, etc, may be dispatched during the wait.
/*

C function : gtk_clipboard_wait_for_text
*/
func (recv *Clipboard) WaitForText() string {
	retC := C.gtk_clipboard_wait_for_text((*C.GtkClipboard)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Test to see if there is text available to be pasted
// This is done by requesting the TARGETS atom and checking
// if it contains any of the supported text targets. This function
// waits for the data to be received using the main loop, so events,
// timeouts, etc, may be dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_text() since it doesnt need to retrieve
// the actual text.
/*

C function : gtk_clipboard_wait_is_text_available
*/
func (recv *Clipboard) WaitIsTextAvailable() bool {
	retC := C.gtk_clipboard_wait_is_text_available((*C.GtkClipboard)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// The #GtkColorButton is a button which displays the currently selected
// color and allows to open a color selection dialog to change the color.
// It is suitable widget for selecting a color in a preference dialog.
//
// # CSS nodes
//
// GtkColorButton has a single CSS node with name button. To differentiate
// it from a plain #GtkButton, it gets the .color style class.
/*

C record/class : GtkColorButton
*/
type ColorButton struct {
	native *C.GtkColorButton
	// button : record
	// Private : priv
}

func ColorButtonNewFromC(u unsafe.Pointer) *ColorButton {
	c := (*C.GtkColorButton)(u)
	if c == nil {
		return nil
	}

	g := &ColorButton{native: c}

	return g
}

func (recv *ColorButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *ColorButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ColorButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ColorButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ColorButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to ColorButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorButton.
func CastToColorButton(object *gobject.Object) *ColorButton {
	return ColorButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorButton
func (recv *ColorButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ColorButton
func (recv *ColorButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ColorButton
func (recv *ColorButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorButton
func (recv *ColorButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorButton
func (recv *ColorButton) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// The #GtkColorChooserDialog widget is a dialog for choosing
// a color. It implements the #GtkColorChooser interface.
/*

C record/class : GtkColorChooserDialog
*/
type ColorChooserDialog struct {
	native *C.GtkColorChooserDialog
	// parent_instance : record
	// Private : priv
}

func ColorChooserDialogNewFromC(u unsafe.Pointer) *ColorChooserDialog {
	c := (*C.GtkColorChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserDialog{native: c}

	return g
}

func (recv *ColorChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *ColorChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *ColorChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *ColorChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *ColorChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *ColorChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to ColorChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorChooserDialog.
func CastToColorChooserDialog(object *gobject.Object) *ColorChooserDialog {
	return ColorChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// The #GtkColorChooserWidget widget lets the user select a
// color. By default, the chooser presents a predefined palette
// of colors, plus a small number of settable custom colors.
// It is also possible to select a different color with the
// single-color editor. To enter the single-color editing mode,
// use the context menu of any color of the palette, or use the
// '+' button to add a new custom color.
//
// The chooser automatically remembers the last selection, as well
// as custom colors.
//
// To change the initially selected color, use gtk_color_chooser_set_rgba().
// To get the selected color use gtk_color_chooser_get_rgba().
//
// The #GtkColorChooserWidget is used in the #GtkColorChooserDialog
// to provide a dialog for selecting colors.
//
// # CSS names
//
// GtkColorChooserWidget has a single CSS node with name colorchooser.
/*

C record/class : GtkColorChooserWidget
*/
type ColorChooserWidget struct {
	native *C.GtkColorChooserWidget
	// parent_instance : record
	// Private : priv
}

func ColorChooserWidgetNewFromC(u unsafe.Pointer) *ColorChooserWidget {
	c := (*C.GtkColorChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserWidget{native: c}

	return g
}

func (recv *ColorChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *ColorChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ColorChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ColorChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to ColorChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorChooserWidget.
func CastToColorChooserWidget(object *gobject.Object) *ColorChooserWidget {
	return ColorChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkColorSelection
*/
type ColorSelection struct {
	native *C.GtkColorSelection
	// parent_instance : record
	// Private : private_data
}

func ColorSelectionNewFromC(u unsafe.Pointer) *ColorSelection {
	c := (*C.GtkColorSelection)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelection{native: c}

	return g
}

func (recv *ColorSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *ColorSelection) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ColorSelection) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ColorSelection) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorSelection) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorSelection) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to ColorSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorSelection.
func CastToColorSelection(object *gobject.Object) *ColorSelection {
	return ColorSelectionNewFromC(object.ToC())
}

type signalColorSelectionColorChangedDetail struct {
	callback  ColorSelectionSignalColorChangedCallback
	handlerID C.gulong
}

var signalColorSelectionColorChangedId int
var signalColorSelectionColorChangedMap = make(map[int]signalColorSelectionColorChangedDetail)
var signalColorSelectionColorChangedLock sync.Mutex

// ColorSelectionSignalColorChangedCallback is a callback function for a 'color-changed' signal emitted from a ColorSelection.
type ColorSelectionSignalColorChangedCallback func()

/*
ConnectColorChanged connects the callback to the 'color-changed' signal for the ColorSelection.

The returned value represents the connection, and may be passed to DisconnectColorChanged to remove it.
*/
func (recv *ColorSelection) ConnectColorChanged(callback ColorSelectionSignalColorChangedCallback) int {
	signalColorSelectionColorChangedLock.Lock()
	defer signalColorSelectionColorChangedLock.Unlock()

	signalColorSelectionColorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ColorSelection_signal_connect_color_changed(instance, C.gpointer(uintptr(signalColorSelectionColorChangedId)))

	detail := signalColorSelectionColorChangedDetail{callback, handlerID}
	signalColorSelectionColorChangedMap[signalColorSelectionColorChangedId] = detail

	return signalColorSelectionColorChangedId
}

/*
DisconnectColorChanged disconnects a callback from the 'color-changed' signal for the ColorSelection.

The connectionID should be a value returned from a call to ConnectColorChanged.
*/
func (recv *ColorSelection) DisconnectColorChanged(connectionID int) {
	signalColorSelectionColorChangedLock.Lock()
	defer signalColorSelectionColorChangedLock.Unlock()

	detail, exists := signalColorSelectionColorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalColorSelectionColorChangedMap, connectionID)
}

//export colorselection_colorChangedHandler
func colorselection_colorChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalColorSelectionColorChangedMap[index].callback
	callback()
}

// Creates a new GtkColorSelection.
/*

C function : gtk_color_selection_new
*/
func ColorSelectionNew() *ColorSelection {
	retC := C.gtk_color_selection_new()
	retGo := ColorSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the current alpha value.
/*

C function : gtk_color_selection_get_current_alpha
*/
func (recv *ColorSelection) GetCurrentAlpha() uint16 {
	retC := C.gtk_color_selection_get_current_alpha((*C.GtkColorSelection)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// Sets @color to be the current color in the GtkColorSelection widget.
/*

C function : gtk_color_selection_get_current_color
*/
func (recv *ColorSelection) GetCurrentColor() *gdk.Color {
	var c_color C.GdkColor

	C.gtk_color_selection_get_current_color((*C.GtkColorSelection)(recv.native), &c_color)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return color
}

// Determines whether the colorsel has an opacity control.
/*

C function : gtk_color_selection_get_has_opacity_control
*/
func (recv *ColorSelection) GetHasOpacityControl() bool {
	retC := C.gtk_color_selection_get_has_opacity_control((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Determines whether the color selector has a color palette.
/*

C function : gtk_color_selection_get_has_palette
*/
func (recv *ColorSelection) GetHasPalette() bool {
	retC := C.gtk_color_selection_get_has_palette((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the previous alpha value.
/*

C function : gtk_color_selection_get_previous_alpha
*/
func (recv *ColorSelection) GetPreviousAlpha() uint16 {
	retC := C.gtk_color_selection_get_previous_alpha((*C.GtkColorSelection)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// Fills @color in with the original color value.
/*

C function : gtk_color_selection_get_previous_color
*/
func (recv *ColorSelection) GetPreviousColor() *gdk.Color {
	var c_color C.GdkColor

	C.gtk_color_selection_get_previous_color((*C.GtkColorSelection)(recv.native), &c_color)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return color
}

// Gets the current state of the @colorsel.
/*

C function : gtk_color_selection_is_adjusting
*/
func (recv *ColorSelection) IsAdjusting() bool {
	retC := C.gtk_color_selection_is_adjusting((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the current opacity to be @alpha.
//
// The first time this is called, it will also set
// the original opacity to be @alpha too.
/*

C function : gtk_color_selection_set_current_alpha
*/
func (recv *ColorSelection) SetCurrentAlpha(alpha uint16) {
	c_alpha := (C.guint16)(alpha)

	C.gtk_color_selection_set_current_alpha((*C.GtkColorSelection)(recv.native), c_alpha)

	return
}

// Sets the current color to be @color.
//
// The first time this is called, it will also set
// the original color to be @color too.
/*

C function : gtk_color_selection_set_current_color
*/
func (recv *ColorSelection) SetCurrentColor(color *gdk.Color) {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_color_selection_set_current_color((*C.GtkColorSelection)(recv.native), c_color)

	return
}

// Sets the @colorsel to use or not use opacity.
/*

C function : gtk_color_selection_set_has_opacity_control
*/
func (recv *ColorSelection) SetHasOpacityControl(hasOpacity bool) {
	c_has_opacity :=
		boolToGboolean(hasOpacity)

	C.gtk_color_selection_set_has_opacity_control((*C.GtkColorSelection)(recv.native), c_has_opacity)

	return
}

// Shows and hides the palette based upon the value of @has_palette.
/*

C function : gtk_color_selection_set_has_palette
*/
func (recv *ColorSelection) SetHasPalette(hasPalette bool) {
	c_has_palette :=
		boolToGboolean(hasPalette)

	C.gtk_color_selection_set_has_palette((*C.GtkColorSelection)(recv.native), c_has_palette)

	return
}

// Sets the previous alpha to be @alpha.
//
// This function should be called with some hesitations,
// as it might seem confusing to have that alpha change.
/*

C function : gtk_color_selection_set_previous_alpha
*/
func (recv *ColorSelection) SetPreviousAlpha(alpha uint16) {
	c_alpha := (C.guint16)(alpha)

	C.gtk_color_selection_set_previous_alpha((*C.GtkColorSelection)(recv.native), c_alpha)

	return
}

// Sets the previous color to be @color.
//
// This function should be called with some hesitations,
// as it might seem confusing to have that color change.
// Calling gtk_color_selection_set_current_color() will also
// set this color the first time it is called.
/*

C function : gtk_color_selection_set_previous_color
*/
func (recv *ColorSelection) SetPreviousColor(color *gdk.Color) {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_color_selection_set_previous_color((*C.GtkColorSelection)(recv.native), c_color)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorSelection
func (recv *ColorSelection) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorSelection
func (recv *ColorSelection) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ColorSelection
func (recv *ColorSelection) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkColorSelectionDialog
*/
type ColorSelectionDialog struct {
	native *C.GtkColorSelectionDialog
	// parent_instance : record
	// Private : priv
}

func ColorSelectionDialogNewFromC(u unsafe.Pointer) *ColorSelectionDialog {
	c := (*C.GtkColorSelectionDialog)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelectionDialog{native: c}

	return g
}

func (recv *ColorSelectionDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *ColorSelectionDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *ColorSelectionDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *ColorSelectionDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *ColorSelectionDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *ColorSelectionDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorSelectionDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorSelectionDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to ColorSelectionDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorSelectionDialog.
func CastToColorSelectionDialog(object *gobject.Object) *ColorSelectionDialog {
	return ColorSelectionDialogNewFromC(object.ToC())
}

// Creates a new #GtkColorSelectionDialog.
/*

C function : gtk_color_selection_dialog_new
*/
func ColorSelectionDialogNew(title string) *ColorSelectionDialog {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	retC := C.gtk_color_selection_dialog_new(c_title)
	retGo := ColorSelectionDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorSelectionDialog
func (recv *ColorSelectionDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorSelectionDialog
func (recv *ColorSelectionDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A GtkComboBox is a widget that allows the user to choose from a list of
// valid choices. The GtkComboBox displays the selected choice. When
// activated, the GtkComboBox displays a popup which allows the user to
// make a new choice. The style in which the selected value is displayed,
// and the style of the popup is determined by the current theme. It may
// be similar to a Windows-style combo box.
//
// The GtkComboBox uses the model-view pattern; the list of valid choices
// is specified in the form of a tree model, and the display of the choices
// can be adapted to the data in the model by using cell renderers, as you
// would in a tree view. This is possible since GtkComboBox implements the
// #GtkCellLayout interface. The tree model holding the valid choices is
// not restricted to a flat list, it can be a real tree, and the popup will
// reflect the tree structure.
//
// To allow the user to enter values not in the model, the has-entry
// property allows the GtkComboBox to contain a #GtkEntry. This entry
// can be accessed by calling gtk_bin_get_child() on the combo box.
//
// For a simple list of textual choices, the model-view API of GtkComboBox
// can be a bit overwhelming. In this case, #GtkComboBoxText offers a
// simple alternative. Both GtkComboBox and #GtkComboBoxText can contain
// an entry.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// combobox
//  box.linked
//     button.combo
//         box
//             cellview
//             arrow
//  window.popup
// ]|
//
// A normal combobox contains a box with the .linked class, a button
// with the .combo class and inside those buttons, there are a cellview and
// an arrow.
//
// |[<!-- language="plain" -->
// combobox
//  box.linked
//     entry.combo
//     button.combo
//         box
//             arrow
//  window.popup
// ]|
//
// A GtkComboBox with an entry has a single CSS node with name combobox. It
// contains a box with the .linked class. That box contains an entry and a
// button, both with the .combo class added.
// The button also contains another node with name arrow.
/*

C record/class : GtkComboBox
*/
type ComboBox struct {
	native *C.GtkComboBox
	// parent_instance : record
	// Private : priv
}

func ComboBoxNewFromC(u unsafe.Pointer) *ComboBox {
	c := (*C.GtkComboBox)(u)
	if c == nil {
		return nil
	}

	g := &ComboBox{native: c}

	return g
}

func (recv *ComboBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ComboBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ComboBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ComboBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ComboBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ComboBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ComboBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBox.
func CastToComboBox(object *gobject.Object) *ComboBox {
	return ComboBoxNewFromC(object.ToC())
}

// Creates a new empty #GtkComboBox using @area to layout cells.
/*

C function : gtk_combo_box_new_with_area
*/
func ComboBoxNewWithArea(area *CellArea) *ComboBox {
	c_area := (*C.GtkCellArea)(C.NULL)
	if area != nil {
		c_area = (*C.GtkCellArea)(area.ToC())
	}

	retC := C.gtk_combo_box_new_with_area(c_area)
	retGo := ComboBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new empty #GtkComboBox with an entry.
//
// The new combo box will use @area to layout cells.
/*

C function : gtk_combo_box_new_with_area_and_entry
*/
func ComboBoxNewWithAreaAndEntry(area *CellArea) *ComboBox {
	c_area := (*C.GtkCellArea)(C.NULL)
	if area != nil {
		c_area = (*C.GtkCellArea)(area.ToC())
	}

	retC := C.gtk_combo_box_new_with_area_and_entry(c_area)
	retGo := ComboBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the current value of the :add-tearoffs property.
/*

C function : gtk_combo_box_get_add_tearoffs
*/
func (recv *ComboBox) GetAddTearoffs() bool {
	retC := C.gtk_combo_box_get_add_tearoffs((*C.GtkComboBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by ComboBox
func (recv *ComboBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ComboBox
func (recv *ComboBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by ComboBox
func (recv *ComboBox) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by ComboBox
func (recv *ComboBox) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

/*

C record/class : GtkComboBoxAccessible
*/
type ComboBoxAccessible struct {
	native *C.GtkComboBoxAccessible
	// parent : record
	// priv : record
}

func ComboBoxAccessibleNewFromC(u unsafe.Pointer) *ComboBoxAccessible {
	c := (*C.GtkComboBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxAccessible{native: c}

	return g
}

func (recv *ComboBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ComboBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ComboBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ComboBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ComboBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ComboBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBoxAccessible.
func CastToComboBoxAccessible(object *gobject.Object) *ComboBoxAccessible {
	return ComboBoxAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// A GtkComboBoxText is a simple variant of #GtkComboBox that hides
// the model-view complexity for simple text-only use cases.
//
// To create a GtkComboBoxText, use gtk_combo_box_text_new() or
// gtk_combo_box_text_new_with_entry().
//
// You can add items to a GtkComboBoxText with
// gtk_combo_box_text_append_text(), gtk_combo_box_text_insert_text()
// or gtk_combo_box_text_prepend_text() and remove options with
// gtk_combo_box_text_remove().
//
// If the GtkComboBoxText contains an entry (via the has-entry property),
// its contents can be retrieved using gtk_combo_box_text_get_active_text().
// The entry itself can be accessed by calling gtk_bin_get_child() on the
// combo box.
//
// You should not call gtk_combo_box_set_model() or attempt to pack more cells
// into this combo box via its GtkCellLayout interface.
//
// # GtkComboBoxText as GtkBuildable
//
// The GtkComboBoxText implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the id
// corresponding to the appended text and also supports the regular
// translation attributes translatable, context and comments.
//
// Here is a UI definition fragment specifying GtkComboBoxText items:
// |[
// <object class="GtkComboBoxText">
// <items>
// <item translatable="yes" id="factory">Factory</item>
// <item translatable="yes" id="home">Home</item>
// <item translatable="yes" id="subway">Subway</item>
// </items>
// </object>
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// combobox
//  box.linked
//  entry.combo
//  button.combo
//  window.popup
// ]|
//
// GtkComboBoxText has a single CSS node with name combobox. It adds
// the style class .combo to the main CSS nodes of its entry and button
// children, and the .linked class to the node of its internal box.
/*

C record/class : GtkComboBoxText
*/
type ComboBoxText struct {
	native *C.GtkComboBoxText
	// Private : parent_instance
	// Private : priv
}

func ComboBoxTextNewFromC(u unsafe.Pointer) *ComboBoxText {
	c := (*C.GtkComboBoxText)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxText{native: c}

	return g
}

func (recv *ComboBoxText) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ComboBox upcasts to *ComboBox
func (recv *ComboBoxText) ComboBox() *ComboBox {
	return ComboBoxNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ComboBoxText) Bin() *Bin {
	return recv.ComboBox().Bin()
}

// Container upcasts to *Container
func (recv *ComboBoxText) Container() *Container {
	return recv.ComboBox().Container()
}

// Widget upcasts to *Widget
func (recv *ComboBoxText) Widget() *Widget {
	return recv.ComboBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ComboBoxText) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ComboBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ComboBoxText) Object() *gobject.Object {
	return recv.ComboBox().Object()
}

// CastToWidget down casts any arbitary Object to ComboBoxText.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBoxText.
func CastToComboBoxText(object *gobject.Object) *ComboBoxText {
	return ComboBoxTextNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ComboBoxText
func (recv *ComboBoxText) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ComboBoxText
func (recv *ComboBoxText) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by ComboBoxText
func (recv *ComboBoxText) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by ComboBoxText
func (recv *ComboBoxText) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// A GTK+ user interface is constructed by nesting widgets inside widgets.
// Container widgets are the inner nodes in the resulting tree of widgets:
// they contain other widgets. So, for example, you might have a #GtkWindow
// containing a #GtkFrame containing a #GtkLabel. If you wanted an image instead
// of a textual label inside the frame, you might replace the #GtkLabel widget
// with a #GtkImage widget.
//
// There are two major kinds of container widgets in GTK+. Both are subclasses
// of the abstract GtkContainer base class.
//
// The first type of container widget has a single child widget and derives
// from #GtkBin. These containers are decorators, which
// add some kind of functionality to the child. For example, a #GtkButton makes
// its child into a clickable button; a #GtkFrame draws a frame around its child
// and a #GtkWindow places its child widget inside a top-level window.
//
// The second type of container can have more than one child; its purpose is to
// manage layout. This means that these containers assign
// sizes and positions to their children. For example, a #GtkHBox arranges its
// children in a horizontal row, and a #GtkGrid arranges the widgets it contains
// in a two-dimensional grid.
//
// For implementations of #GtkContainer the virtual method #GtkContainerClass.forall()
// is always required, since it's used for drawing and other internal operations
// on the children.
// If the #GtkContainer implementation expect to have non internal children
// it's needed to implement both #GtkContainerClass.add() and #GtkContainerClass.remove().
// If the GtkContainer implementation has internal children, they should be added
// with gtk_widget_set_parent() on init() and removed with gtk_widget_unparent()
// in the #GtkWidgetClass.destroy() implementation.
// See more about implementing custom widgets at https://wiki.gnome.org/HowDoI/CustomWidgets
//
// # Height for width geometry management
//
// GTK+ uses a height-for-width (and width-for-height) geometry management system.
// Height-for-width means that a widget can change how much vertical space it needs,
// depending on the amount of horizontal space that it is given (and similar for
// width-for-height).
//
// There are some things to keep in mind when implementing container widgets
// that make use of GTK+s height for width geometry management system. First,
// its important to note that a container must prioritize one of its
// dimensions, that is to say that a widget or container can only have a
// #GtkSizeRequestMode that is %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH or
// %GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT. However, every widget and container
// must be able to respond to the APIs for both dimensions, i.e. even if a
// widget has a request mode that is height-for-width, it is possible that
// its parent will request its sizes using the width-for-height APIs.
//
// To ensure that everything works properly, here are some guidelines to follow
// when implementing height-for-width (or width-for-height) containers.
//
// Each request mode involves 2 virtual methods. Height-for-width apis run
// through gtk_widget_get_preferred_width() and then through gtk_widget_get_preferred_height_for_width().
// When handling requests in the opposite #GtkSizeRequestMode it is important that
// every widget request at least enough space to display all of its content at all times.
//
// When gtk_widget_get_preferred_height() is called on a container that is height-for-width,
// the container must return the height for its minimum width. This is easily achieved by
// simply calling the reverse apis implemented for itself as follows:
//
// |[<!-- language="C" -->
// static void
// foo_container_get_preferred_height (GtkWidget *widget,
// gint *min_height,
// gint *nat_height)
// {
// if (i_am_in_height_for_width_mode)
// {
// gint min_width;
//
// GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
// &min_width,
// NULL);
// GTK_WIDGET_GET_CLASS (widget)->get_preferred_height_for_width
// (widget,
// min_width,
// min_height,
// nat_height);
// }
// else
// {
// ... many containers support both request modes, execute the
// real width-for-height request here by returning the
// collective heights of all widgets that are stacked
// vertically (or whatever is appropriate for this container)
// ...
// }
// }
// ]|
//
// Similarly, when gtk_widget_get_preferred_width_for_height() is called for a container or widget
// that is height-for-width, it then only needs to return the base minimum width like so:
//
// |[<!-- language="C" -->
// static void
// foo_container_get_preferred_width_for_height (GtkWidget *widget,
// gint for_height,
// gint *min_width,
// gint *nat_width)
// {
// if (i_am_in_height_for_width_mode)
// {
// GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
// min_width,
// nat_width);
// }
// else
// {
// ... execute the real width-for-height request here based on
// the required width of the children collectively if the
// container were to be allocated the said height ...
// }
// }
// ]|
//
// Height for width requests are generally implemented in terms of a virtual allocation
// of widgets in the input orientation. Assuming an height-for-width request mode, a container
// would implement the get_preferred_height_for_width() virtual function by first calling
// gtk_widget_get_preferred_width() for each of its children.
//
// For each potential group of children that are lined up horizontally, the values returned by
// gtk_widget_get_preferred_width() should be collected in an array of #GtkRequestedSize structures.
// Any child spacing should be removed from the input @for_width and then the collective size should be
// allocated using the gtk_distribute_natural_allocation() convenience function.
//
// The container will then move on to request the preferred height for each child by using
// gtk_widget_get_preferred_height_for_width() and using the sizes stored in the #GtkRequestedSize array.
//
// To allocate a height-for-width container, its again important
// to consider that a container must prioritize one dimension over the other. So if
// a container is a height-for-width container it must first allocate all widgets horizontally
// using a #GtkRequestedSize array and gtk_distribute_natural_allocation() and then add any
// extra space (if and where appropriate) for the widget to expand.
//
// After adding all the expand space, the container assumes it was allocated sufficient
// height to fit all of its content. At this time, the container must use the total horizontal sizes
// of each widget to request the height-for-width of each of its children and store the requests in a
// #GtkRequestedSize array for any widgets that stack vertically (for tabular containers this can
// be generalized into the heights and widths of rows and columns).
// The vertical space must then again be distributed using gtk_distribute_natural_allocation()
// while this time considering the allocated height of the widget minus any vertical spacing
// that the container adds. Then vertical expand space should be added where appropriate and available
// and the container should go on to actually allocating the child widgets.
//
// See [GtkWidgets geometry management section][geometry-management]
// to learn more about implementing height-for-width geometry management for widgets.
//
// # Child properties
//
// GtkContainer introduces child properties.
// These are object properties that are not specific
// to either the container or the contained widget, but rather to their relation.
// Typical examples of child properties are the position or pack-type of a widget
// which is contained in a #GtkBox.
//
// Use gtk_container_class_install_child_property() to install child properties
// for a container class and gtk_container_class_find_child_property() or
// gtk_container_class_list_child_properties() to get information about existing
// child properties.
//
// To set the value of a child property, use gtk_container_child_set_property(),
// gtk_container_child_set() or gtk_container_child_set_valist().
// To obtain the value of a child property, use
// gtk_container_child_get_property(), gtk_container_child_get() or
// gtk_container_child_get_valist(). To emit notification about child property
// changes, use gtk_widget_child_notify().
//
// # GtkContainer as GtkBuildable
//
// The GtkContainer implementation of the GtkBuildable interface supports
// a <packing> element for children, which can contain multiple <property>
// elements that specify child properties for the child.
//
// Since 2.16, child properties can also be marked as translatable using
// the same translatable, comments and context attributes that are used
// for regular properties.
//
// Since 3.16, containers can have a <focus-chain> element containing multiple
// <widget> elements, one for each child that should be added to the focus
// chain. The name attribute gives the id of the widget.
//
// An example of these properties in UI definitions:
// |[
// <object class="GtkBox">
// <child>
// <object class="GtkEntry" id="entry1"/>
// <packing>
// <property name="pack-type">start</property>
// </packing>
// </child>
// <child>
// <object class="GtkEntry" id="entry2"/>
// </child>
// <focus-chain>
// <widget name="entry1"/>
// <widget name="entry2"/>
// </focus-chain>
// </object>
// ]|
/*

C record/class : GtkContainer
*/
type Container struct {
	native *C.GtkContainer
	// widget : record
	// Private : priv
}

func ContainerNewFromC(u unsafe.Pointer) *Container {
	c := (*C.GtkContainer)(u)
	if c == nil {
		return nil
	}

	g := &Container{native: c}

	return g
}

func (recv *Container) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Container) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Container) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Container) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Container.
// Exercise care, as this is a potentially dangerous function if the Object is not a Container.
func CastToContainer(object *gobject.Object) *Container {
	return ContainerNewFromC(object.ToC())
}

type signalContainerAddDetail struct {
	callback  ContainerSignalAddCallback
	handlerID C.gulong
}

var signalContainerAddId int
var signalContainerAddMap = make(map[int]signalContainerAddDetail)
var signalContainerAddLock sync.Mutex

// ContainerSignalAddCallback is a callback function for a 'add' signal emitted from a Container.
type ContainerSignalAddCallback func(object *Widget)

/*
ConnectAdd connects the callback to the 'add' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectAdd to remove it.
*/
func (recv *Container) ConnectAdd(callback ContainerSignalAddCallback) int {
	signalContainerAddLock.Lock()
	defer signalContainerAddLock.Unlock()

	signalContainerAddId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_add(instance, C.gpointer(uintptr(signalContainerAddId)))

	detail := signalContainerAddDetail{callback, handlerID}
	signalContainerAddMap[signalContainerAddId] = detail

	return signalContainerAddId
}

/*
DisconnectAdd disconnects a callback from the 'add' signal for the Container.

The connectionID should be a value returned from a call to ConnectAdd.
*/
func (recv *Container) DisconnectAdd(connectionID int) {
	signalContainerAddLock.Lock()
	defer signalContainerAddLock.Unlock()

	detail, exists := signalContainerAddMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerAddMap, connectionID)
}

//export container_addHandler
func container_addHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerAddMap[index].callback
	callback(object)
}

type signalContainerCheckResizeDetail struct {
	callback  ContainerSignalCheckResizeCallback
	handlerID C.gulong
}

var signalContainerCheckResizeId int
var signalContainerCheckResizeMap = make(map[int]signalContainerCheckResizeDetail)
var signalContainerCheckResizeLock sync.Mutex

// ContainerSignalCheckResizeCallback is a callback function for a 'check-resize' signal emitted from a Container.
type ContainerSignalCheckResizeCallback func()

/*
ConnectCheckResize connects the callback to the 'check-resize' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectCheckResize to remove it.
*/
func (recv *Container) ConnectCheckResize(callback ContainerSignalCheckResizeCallback) int {
	signalContainerCheckResizeLock.Lock()
	defer signalContainerCheckResizeLock.Unlock()

	signalContainerCheckResizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_check_resize(instance, C.gpointer(uintptr(signalContainerCheckResizeId)))

	detail := signalContainerCheckResizeDetail{callback, handlerID}
	signalContainerCheckResizeMap[signalContainerCheckResizeId] = detail

	return signalContainerCheckResizeId
}

/*
DisconnectCheckResize disconnects a callback from the 'check-resize' signal for the Container.

The connectionID should be a value returned from a call to ConnectCheckResize.
*/
func (recv *Container) DisconnectCheckResize(connectionID int) {
	signalContainerCheckResizeLock.Lock()
	defer signalContainerCheckResizeLock.Unlock()

	detail, exists := signalContainerCheckResizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerCheckResizeMap, connectionID)
}

//export container_checkResizeHandler
func container_checkResizeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalContainerCheckResizeMap[index].callback
	callback()
}

type signalContainerRemoveDetail struct {
	callback  ContainerSignalRemoveCallback
	handlerID C.gulong
}

var signalContainerRemoveId int
var signalContainerRemoveMap = make(map[int]signalContainerRemoveDetail)
var signalContainerRemoveLock sync.Mutex

// ContainerSignalRemoveCallback is a callback function for a 'remove' signal emitted from a Container.
type ContainerSignalRemoveCallback func(object *Widget)

/*
ConnectRemove connects the callback to the 'remove' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectRemove to remove it.
*/
func (recv *Container) ConnectRemove(callback ContainerSignalRemoveCallback) int {
	signalContainerRemoveLock.Lock()
	defer signalContainerRemoveLock.Unlock()

	signalContainerRemoveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_remove(instance, C.gpointer(uintptr(signalContainerRemoveId)))

	detail := signalContainerRemoveDetail{callback, handlerID}
	signalContainerRemoveMap[signalContainerRemoveId] = detail

	return signalContainerRemoveId
}

/*
DisconnectRemove disconnects a callback from the 'remove' signal for the Container.

The connectionID should be a value returned from a call to ConnectRemove.
*/
func (recv *Container) DisconnectRemove(connectionID int) {
	signalContainerRemoveLock.Lock()
	defer signalContainerRemoveLock.Unlock()

	detail, exists := signalContainerRemoveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerRemoveMap, connectionID)
}

//export container_removeHandler
func container_removeHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerRemoveMap[index].callback
	callback(object)
}

type signalContainerSetFocusChildDetail struct {
	callback  ContainerSignalSetFocusChildCallback
	handlerID C.gulong
}

var signalContainerSetFocusChildId int
var signalContainerSetFocusChildMap = make(map[int]signalContainerSetFocusChildDetail)
var signalContainerSetFocusChildLock sync.Mutex

// ContainerSignalSetFocusChildCallback is a callback function for a 'set-focus-child' signal emitted from a Container.
type ContainerSignalSetFocusChildCallback func(object *Widget)

/*
ConnectSetFocusChild connects the callback to the 'set-focus-child' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectSetFocusChild to remove it.
*/
func (recv *Container) ConnectSetFocusChild(callback ContainerSignalSetFocusChildCallback) int {
	signalContainerSetFocusChildLock.Lock()
	defer signalContainerSetFocusChildLock.Unlock()

	signalContainerSetFocusChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_set_focus_child(instance, C.gpointer(uintptr(signalContainerSetFocusChildId)))

	detail := signalContainerSetFocusChildDetail{callback, handlerID}
	signalContainerSetFocusChildMap[signalContainerSetFocusChildId] = detail

	return signalContainerSetFocusChildId
}

/*
DisconnectSetFocusChild disconnects a callback from the 'set-focus-child' signal for the Container.

The connectionID should be a value returned from a call to ConnectSetFocusChild.
*/
func (recv *Container) DisconnectSetFocusChild(connectionID int) {
	signalContainerSetFocusChildLock.Lock()
	defer signalContainerSetFocusChildLock.Unlock()

	detail, exists := signalContainerSetFocusChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerSetFocusChildMap, connectionID)
}

//export container_setFocusChildHandler
func container_setFocusChildHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerSetFocusChildMap[index].callback
	callback(object)
}

// Adds @widget to @container. Typically used for simple containers
// such as #GtkWindow, #GtkFrame, or #GtkButton; for more complicated
// layout containers such as #GtkBox or #GtkGrid, this function will
// pick default packing parameters that may not be correct.  So
// consider functions such as gtk_box_pack_start() and
// gtk_grid_attach() as an alternative to gtk_container_add() in
// those cases. A widget may be added to only one container at a time;
// you cant place the same widget inside two different containers.
//
// Note that some containers, such as #GtkScrolledWindow or #GtkListBox,
// may add intermediate children between the added widget and the
// container.
/*

C function : gtk_container_add
*/
func (recv *Container) Add(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_container_add((*C.GtkContainer)(recv.native), c_widget)

	return
}

// Unsupported : gtk_container_add_with_properties : unsupported parameter ... : varargs

/*

C function : gtk_container_check_resize
*/
func (recv *Container) CheckResize() {
	C.gtk_container_check_resize((*C.GtkContainer)(recv.native))

	return
}

// Unsupported : gtk_container_child_get : unsupported parameter ... : varargs

// Gets the value of a child property for @child and @container.
/*

C function : gtk_container_child_get_property
*/
func (recv *Container) ChildGetProperty(child *Widget, propertyName string, value *gobject.Value) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_container_child_get_property((*C.GtkContainer)(recv.native), c_child, c_property_name, c_value)

	return
}

// Unsupported : gtk_container_child_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Unsupported : gtk_container_child_set : unsupported parameter ... : varargs

// Sets a child property for @child and @container.
/*

C function : gtk_container_child_set_property
*/
func (recv *Container) ChildSetProperty(child *Widget, propertyName string, value *gobject.Value) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_container_child_set_property((*C.GtkContainer)(recv.native), c_child, c_property_name, c_value)

	return
}

// Unsupported : gtk_container_child_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Returns the type of the children supported by the container.
//
// Note that this may return %G_TYPE_NONE to indicate that no more
// children can be added, e.g. for a #GtkPaned which already has two
// children.
/*

C function : gtk_container_child_type
*/
func (recv *Container) ChildType() gobject.Type {
	retC := C.gtk_container_child_type((*C.GtkContainer)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// Unsupported : gtk_container_forall : unsupported parameter callback : no type generator for Callback (GtkCallback) for param callback

// Unsupported : gtk_container_foreach : unsupported parameter callback : no type generator for Callback (GtkCallback) for param callback

// Retrieves the border width of the container. See
// gtk_container_set_border_width().
/*

C function : gtk_container_get_border_width
*/
func (recv *Container) GetBorderWidth() uint32 {
	retC := C.gtk_container_get_border_width((*C.GtkContainer)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Returns the containers non-internal children. See
// gtk_container_forall() for details on what constitutes an "internal" child.
/*

C function : gtk_container_get_children
*/
func (recv *Container) GetChildren() *glib.List {
	retC := C.gtk_container_get_children((*C.GtkContainer)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the focus chain of the container, if one has been
// set explicitly. If no focus chain has been explicitly
// set, GTK+ computes the focus chain based on the positions
// of the children. In that case, GTK+ stores %NULL in
// @focusable_widgets and returns %FALSE.
/*

C function : gtk_container_get_focus_chain
*/
func (recv *Container) GetFocusChain() (bool, *glib.List) {
	var c_focusable_widgets *C.GList

	retC := C.gtk_container_get_focus_chain((*C.GtkContainer)(recv.native), &c_focusable_widgets)
	retGo := retC == C.TRUE

	focusableWidgets := glib.ListNewFromC(unsafe.Pointer(c_focusable_widgets))

	return retGo, focusableWidgets
}

// Retrieves the horizontal focus adjustment for the container. See
// gtk_container_set_focus_hadjustment ().
/*

C function : gtk_container_get_focus_hadjustment
*/
func (recv *Container) GetFocusHadjustment() *Adjustment {
	retC := C.gtk_container_get_focus_hadjustment((*C.GtkContainer)(recv.native))
	var retGo (*Adjustment)
	if retC == nil {
		retGo = nil
	} else {
		retGo = AdjustmentNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the vertical focus adjustment for the container. See
// gtk_container_set_focus_vadjustment().
/*

C function : gtk_container_get_focus_vadjustment
*/
func (recv *Container) GetFocusVadjustment() *Adjustment {
	retC := C.gtk_container_get_focus_vadjustment((*C.GtkContainer)(recv.native))
	var retGo (*Adjustment)
	if retC == nil {
		retGo = nil
	} else {
		retGo = AdjustmentNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns a newly created widget path representing all the widget hierarchy
// from the toplevel down to and including @child.
/*

C function : gtk_container_get_path_for_child
*/
func (recv *Container) GetPathForChild(child *Widget) *WidgetPath {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_container_get_path_for_child((*C.GtkContainer)(recv.native), c_child)
	retGo := WidgetPathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the resize mode for the container. See
// gtk_container_set_resize_mode ().
/*

C function : gtk_container_get_resize_mode
*/
func (recv *Container) GetResizeMode() ResizeMode {
	retC := C.gtk_container_get_resize_mode((*C.GtkContainer)(recv.native))
	retGo := (ResizeMode)(retC)

	return retGo
}

// When a container receives a call to the draw function, it must send
// synthetic #GtkWidget::draw calls to all children that dont have their
// own #GdkWindows. This function provides a convenient way of doing this.
// A container, when it receives a call to its #GtkWidget::draw function,
// calls gtk_container_propagate_draw() once for each child, passing in
// the @cr the container received.
//
// gtk_container_propagate_draw() takes care of translating the origin of @cr,
// and deciding whether the draw needs to be sent to the child. It is a
// convenient and optimized way of getting the same effect as calling
// gtk_widget_draw() on the child directly.
//
// In most cases, a container can simply either inherit the
// #GtkWidget::draw implementation from #GtkContainer, or do some drawing
// and then chain to the ::draw implementation from #GtkContainer.
/*

C function : gtk_container_propagate_draw
*/
func (recv *Container) PropagateDraw(child *Widget, cr *cairo.Context) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	C.gtk_container_propagate_draw((*C.GtkContainer)(recv.native), c_child, c_cr)

	return
}

// Removes @widget from @container. @widget must be inside @container.
// Note that @container will own a reference to @widget, and that this
// may be the last reference held; so removing a widget from its
// container can destroy that widget. If you want to use @widget
// again, you need to add a reference to it before removing it from
// a container, using g_object_ref(). If you dont want to use @widget
// again its usually more efficient to simply destroy it directly
// using gtk_widget_destroy() since this will remove it from the
// container and help break any circular reference count cycles.
/*

C function : gtk_container_remove
*/
func (recv *Container) Remove(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_container_remove((*C.GtkContainer)(recv.native), c_widget)

	return
}

/*

C function : gtk_container_resize_children
*/
func (recv *Container) ResizeChildren() {
	C.gtk_container_resize_children((*C.GtkContainer)(recv.native))

	return
}

// Sets the border width of the container.
//
// The border width of a container is the amount of space to leave
// around the outside of the container. The only exception to this is
// #GtkWindow; because toplevel windows cant leave space outside,
// they leave the space inside. The border is added on all sides of
// the container. To add space to only one side, use a specific
// #GtkWidget:margin property on the child widget, for example
// #GtkWidget:margin-top.
/*

C function : gtk_container_set_border_width
*/
func (recv *Container) SetBorderWidth(borderWidth uint32) {
	c_border_width := (C.guint)(borderWidth)

	C.gtk_container_set_border_width((*C.GtkContainer)(recv.native), c_border_width)

	return
}

// Sets a focus chain, overriding the one computed automatically by GTK+.
//
// In principle each widget in the chain should be a descendant of the
// container, but this is not enforced by this method, since its allowed
// to set the focus chain before you pack the widgets, or have a widget
// in the chain that isnt always packed. The necessary checks are done
// when the focus chain is actually traversed.
/*

C function : gtk_container_set_focus_chain
*/
func (recv *Container) SetFocusChain(focusableWidgets *glib.List) {
	c_focusable_widgets := (*C.GList)(C.NULL)
	if focusableWidgets != nil {
		c_focusable_widgets = (*C.GList)(focusableWidgets.ToC())
	}

	C.gtk_container_set_focus_chain((*C.GtkContainer)(recv.native), c_focusable_widgets)

	return
}

// Sets, or unsets if @child is %NULL, the focused child of @container.
//
// This function emits the GtkContainer::set_focus_child signal of
// @container. Implementations of #GtkContainer can override the
// default behaviour by overriding the class closure of this signal.
//
// This is function is mostly meant to be used by widgets. Applications can use
// gtk_widget_grab_focus() to manually set the focus to a specific widget.
/*

C function : gtk_container_set_focus_child
*/
func (recv *Container) SetFocusChild(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_container_set_focus_child((*C.GtkContainer)(recv.native), c_child)

	return
}

// Hooks up an adjustment to focus handling in a container, so when a child
// of the container is focused, the adjustment is scrolled to show that
// widget. This function sets the horizontal alignment.
// See gtk_scrolled_window_get_hadjustment() for a typical way of obtaining
// the adjustment and gtk_container_set_focus_vadjustment() for setting
// the vertical adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the container.
/*

C function : gtk_container_set_focus_hadjustment
*/
func (recv *Container) SetFocusHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_container_set_focus_hadjustment((*C.GtkContainer)(recv.native), c_adjustment)

	return
}

// Hooks up an adjustment to focus handling in a container, so when a
// child of the container is focused, the adjustment is scrolled to
// show that widget. This function sets the vertical alignment. See
// gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
// the adjustment and gtk_container_set_focus_hadjustment() for setting
// the horizontal adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the container.
/*

C function : gtk_container_set_focus_vadjustment
*/
func (recv *Container) SetFocusVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_container_set_focus_vadjustment((*C.GtkContainer)(recv.native), c_adjustment)

	return
}

// Sets the @reallocate_redraws flag of the container to the given value.
//
// Containers requesting reallocation redraws get automatically
// redrawn if any of their children changed allocation.
/*

C function : gtk_container_set_reallocate_redraws
*/
func (recv *Container) SetReallocateRedraws(needsRedraws bool) {
	c_needs_redraws :=
		boolToGboolean(needsRedraws)

	C.gtk_container_set_reallocate_redraws((*C.GtkContainer)(recv.native), c_needs_redraws)

	return
}

// Sets the resize mode for the container.
//
// The resize mode of a container determines whether a resize request
// will be passed to the containers parent, queued for later execution
// or executed immediately.
/*

C function : gtk_container_set_resize_mode
*/
func (recv *Container) SetResizeMode(resizeMode ResizeMode) {
	c_resize_mode := (C.GtkResizeMode)(resizeMode)

	C.gtk_container_set_resize_mode((*C.GtkContainer)(recv.native), c_resize_mode)

	return
}

// Removes a focus chain explicitly set with gtk_container_set_focus_chain().
/*

C function : gtk_container_unset_focus_chain
*/
func (recv *Container) UnsetFocusChain() {
	C.gtk_container_unset_focus_chain((*C.GtkContainer)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Container
func (recv *Container) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Container
func (recv *Container) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkContainerAccessible
*/
type ContainerAccessible struct {
	native *C.GtkContainerAccessible
	// parent : record
	// priv : record
}

func ContainerAccessibleNewFromC(u unsafe.Pointer) *ContainerAccessible {
	c := (*C.GtkContainerAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ContainerAccessible{native: c}

	return g
}

func (recv *ContainerAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ContainerAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ContainerAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ContainerAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ContainerAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ContainerAccessible.
func CastToContainerAccessible(object *gobject.Object) *ContainerAccessible {
	return ContainerAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ContainerAccessible
func (recv *ContainerAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

/*

C record/class : GtkContainerCellAccessible
*/
type ContainerCellAccessible struct {
	native *C.GtkContainerCellAccessible
	// parent : record
	// priv : record
}

func ContainerCellAccessibleNewFromC(u unsafe.Pointer) *ContainerCellAccessible {
	c := (*C.GtkContainerCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ContainerCellAccessible{native: c}

	return g
}

func (recv *ContainerCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellAccessible upcasts to *CellAccessible
func (recv *ContainerCellAccessible) CellAccessible() *CellAccessible {
	return CellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ContainerCellAccessible) Accessible() *Accessible {
	return recv.CellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ContainerCellAccessible) Object() *atk.Object {
	return recv.CellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ContainerCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ContainerCellAccessible.
func CastToContainerCellAccessible(object *gobject.Object) *ContainerCellAccessible {
	return ContainerCellAccessibleNewFromC(object.ToC())
}

/*

C function : gtk_container_cell_accessible_new
*/
func ContainerCellAccessibleNew() *ContainerCellAccessible {
	retC := C.gtk_container_cell_accessible_new()
	retGo := ContainerCellAccessibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

/*

C function : gtk_container_cell_accessible_add_child
*/
func (recv *ContainerCellAccessible) AddChild(child *CellAccessible) {
	c_child := (*C.GtkCellAccessible)(C.NULL)
	if child != nil {
		c_child = (*C.GtkCellAccessible)(child.ToC())
	}

	C.gtk_container_cell_accessible_add_child((*C.GtkContainerCellAccessible)(recv.native), c_child)

	return
}

// Get a list of children.
/*

C function : gtk_container_cell_accessible_get_children
*/
func (recv *ContainerCellAccessible) GetChildren() *glib.List {
	retC := C.gtk_container_cell_accessible_get_children((*C.GtkContainerCellAccessible)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

/*

C function : gtk_container_cell_accessible_remove_child
*/
func (recv *ContainerCellAccessible) RemoveChild(child *CellAccessible) {
	c_child := (*C.GtkCellAccessible)(C.NULL)
	if child != nil {
		c_child = (*C.GtkCellAccessible)(child.ToC())
	}

	C.gtk_container_cell_accessible_remove_child((*C.GtkContainerCellAccessible)(recv.native), c_child)

	return
}

// Action returns the Action interface implemented by ContainerCellAccessible
func (recv *ContainerCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ContainerCellAccessible
func (recv *ContainerCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// GtkCssProvider is an object implementing the #GtkStyleProvider interface.
// It is able to parse [CSS-like][css-overview] input in order to style widgets.
//
// An application can make GTK+ parse a specific CSS style sheet by calling
// gtk_css_provider_load_from_file() or gtk_css_provider_load_from_resource()
// and adding the provider with gtk_style_context_add_provider() or
// gtk_style_context_add_provider_for_screen().
//
// In addition, certain files will be read when GTK+ is initialized. First, the
// file `$XDG_CONFIG_HOME/gtk-3.0/gtk.css` is loaded if it exists. Then, GTK+
// loads the first existing file among
// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk.css`,
// `$HOME/.themes/THEME/gtk-VERSION/gtk.css`,
// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk.css` and
// `DATADIR/share/themes/THEME/gtk-VERSION/gtk.css`, where `THEME` is the name of
// the current theme (see the #GtkSettings:gtk-theme-name setting), `DATADIR`
// is the prefix configured when GTK+ was compiled (unless overridden by the
// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK+ version number.
// If no file is found for the current version, GTK+ tries older versions all the
// way back to 3.0.
//
// In the same way, GTK+ tries to load a gtk-keys.css file for the current
// key theme, as defined by #GtkSettings:gtk-key-theme-name.
/*

C record/class : GtkCssProvider
*/
type CssProvider struct {
	native *C.GtkCssProvider
	// parent_instance : record
	// priv : record
}

func CssProviderNewFromC(u unsafe.Pointer) *CssProvider {
	c := (*C.GtkCssProvider)(u)
	if c == nil {
		return nil
	}

	g := &CssProvider{native: c}

	return g
}

func (recv *CssProvider) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *CssProvider) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to CssProvider.
// Exercise care, as this is a potentially dangerous function if the Object is not a CssProvider.
func CastToCssProvider(object *gobject.Object) *CssProvider {
	return CssProviderNewFromC(object.ToC())
}

type signalCssProviderParsingErrorDetail struct {
	callback  CssProviderSignalParsingErrorCallback
	handlerID C.gulong
}

var signalCssProviderParsingErrorId int
var signalCssProviderParsingErrorMap = make(map[int]signalCssProviderParsingErrorDetail)
var signalCssProviderParsingErrorLock sync.Mutex

// CssProviderSignalParsingErrorCallback is a callback function for a 'parsing-error' signal emitted from a CssProvider.
type CssProviderSignalParsingErrorCallback func(section *CssSection, error *glib.Error)

/*
ConnectParsingError connects the callback to the 'parsing-error' signal for the CssProvider.

The returned value represents the connection, and may be passed to DisconnectParsingError to remove it.
*/
func (recv *CssProvider) ConnectParsingError(callback CssProviderSignalParsingErrorCallback) int {
	signalCssProviderParsingErrorLock.Lock()
	defer signalCssProviderParsingErrorLock.Unlock()

	signalCssProviderParsingErrorId++
	instance := C.gpointer(recv.native)
	handlerID := C.CssProvider_signal_connect_parsing_error(instance, C.gpointer(uintptr(signalCssProviderParsingErrorId)))

	detail := signalCssProviderParsingErrorDetail{callback, handlerID}
	signalCssProviderParsingErrorMap[signalCssProviderParsingErrorId] = detail

	return signalCssProviderParsingErrorId
}

/*
DisconnectParsingError disconnects a callback from the 'parsing-error' signal for the CssProvider.

The connectionID should be a value returned from a call to ConnectParsingError.
*/
func (recv *CssProvider) DisconnectParsingError(connectionID int) {
	signalCssProviderParsingErrorLock.Lock()
	defer signalCssProviderParsingErrorLock.Unlock()

	detail, exists := signalCssProviderParsingErrorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCssProviderParsingErrorMap, connectionID)
}

//export cssprovider_parsingErrorHandler
func cssprovider_parsingErrorHandler(_ *C.GObject, c_section *C.GtkCssSection, c_error *C.GError, data C.gpointer) {
	section := CssSectionNewFromC(unsafe.Pointer(c_section))

	error := glib.ErrorNewFromC(unsafe.Pointer(c_error))

	index := int(uintptr(data))
	callback := signalCssProviderParsingErrorMap[index].callback
	callback(section, error)
}

// Returns a newly created #GtkCssProvider.
/*

C function : gtk_css_provider_new
*/
func CssProviderNew() *CssProvider {
	retC := C.gtk_css_provider_new()
	retGo := CssProviderNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Loads @data into @css_provider, and by doing so clears any previously loaded
// information.
/*

C function : gtk_css_provider_load_from_data
*/
func (recv *CssProvider) LoadFromData(data []uint8) (bool, error) {
	c_data := &data[0]

	c_length := (C.gssize)(len(data))

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_data((*C.GtkCssProvider)(recv.native), (*C.gchar)(unsafe.Pointer(c_data)), c_length, &cThrowableError)
	retGo := retC == C.TRUE

	goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
	if cThrowableError != nil {
		C.g_error_free(cThrowableError)
	}

	return retGo, goThrowableError
}

// Loads the data contained in @file into @css_provider, making it
// clear any previously loaded information.
/*

C function : gtk_css_provider_load_from_file
*/
func (recv *CssProvider) LoadFromFile(file *gio.File) (bool, error) {
	c_file := (*C.GFile)(file.ToC())

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_file((*C.GtkCssProvider)(recv.native), c_file, &cThrowableError)
	retGo := retC == C.TRUE

	goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
	if cThrowableError != nil {
		C.g_error_free(cThrowableError)
	}

	return retGo, goThrowableError
}

// Loads the data contained in @path into @css_provider, making it clear
// any previously loaded information.
/*

C function : gtk_css_provider_load_from_path
*/
func (recv *CssProvider) LoadFromPath(path string) (bool, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_path((*C.GtkCssProvider)(recv.native), c_path, &cThrowableError)
	retGo := retC == C.TRUE

	goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
	if cThrowableError != nil {
		C.g_error_free(cThrowableError)
	}

	return retGo, goThrowableError
}

// StyleProvider returns the StyleProvider interface implemented by CssProvider
func (recv *CssProvider) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// Dialog boxes are a convenient way to prompt the user for a small amount
// of input, e.g. to display a message, ask a question, or anything else
// that does not require extensive effort on the users part.
//
// GTK+ treats a dialog as a window split vertically. The top section is a
// #GtkVBox, and is where widgets such as a #GtkLabel or a #GtkEntry should
// be packed. The bottom area is known as the
// action area. This is generally used for
// packing buttons into the dialog which may perform functions such as
// cancel, ok, or apply.
//
// #GtkDialog boxes are created with a call to gtk_dialog_new() or
// gtk_dialog_new_with_buttons(). gtk_dialog_new_with_buttons() is
// recommended; it allows you to set the dialog title, some convenient
// flags, and add simple buttons.
//
// If dialog is a newly created dialog, the two primary areas of the
// window can be accessed through gtk_dialog_get_content_area() and
// gtk_dialog_get_action_area(), as can be seen from the example below.
//
// A modal dialog (that is, one which freezes the rest of the application
// from user input), can be created by calling gtk_window_set_modal() on the
// dialog. Use the GTK_WINDOW() macro to cast the widget returned from
// gtk_dialog_new() into a #GtkWindow. When using gtk_dialog_new_with_buttons()
// you can also pass the #GTK_DIALOG_MODAL flag to make a dialog modal.
//
// If you add buttons to #GtkDialog using gtk_dialog_new_with_buttons(),
// gtk_dialog_add_button(), gtk_dialog_add_buttons(), or
// gtk_dialog_add_action_widget(), clicking the button will emit a signal
// called #GtkDialog::response with a response ID that you specified. GTK+
// will never assign a meaning to positive response IDs; these are entirely
// user-defined. But for convenience, you can use the response IDs in the
// #GtkResponseType enumeration (these all have values less than zero). If
// a dialog receives a delete event, the #GtkDialog::response signal will
// be emitted with a response ID of #GTK_RESPONSE_DELETE_EVENT.
//
// If you want to block waiting for a dialog to return before returning
// control flow to your code, you can call gtk_dialog_run(). This function
// enters a recursive main loop and waits for the user to respond to the
// dialog, returning the response ID corresponding to the button the user
// clicked.
//
// For the simple dialog in the following example, in reality youd probably
// use #GtkMessageDialog to save yourself some effort. But youd need to
// create the dialog contents manually if you had more than a simple message
// in the dialog.
//
// An example for simple GtkDialog usage:
// |[<!-- language="C" -->
// Function to open a dialog box with a message
// void
// quick_message (GtkWindow *parent, gchar *message)
// {
// GtkWidget *dialog, *label, *content_area;
// GtkDialogFlags flags;
//
// Create the widgets
// flags = GTK_DIALOG_DESTROY_WITH_PARENT;
// dialog = gtk_dialog_new_with_buttons ("Message",
// parent,
// flags,
// _("_OK"),
// GTK_RESPONSE_NONE,
// NULL);
// content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
// label = gtk_label_new (message);
//
// Ensure that the dialog box is destroyed when the user responds
//
// g_signal_connect_swapped (dialog,
// "response",
// G_CALLBACK (gtk_widget_destroy),
// dialog);
//
// Add the label, and show everything weve added
//
// gtk_container_add (GTK_CONTAINER (content_area), label);
// gtk_widget_show_all (dialog);
// }
// ]|
//
// # GtkDialog as GtkBuildable
//
// The GtkDialog implementation of the #GtkBuildable interface exposes the
// @vbox and @action_area as internal children with the names vbox and
// action_area.
//
// GtkDialog supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The response attribute specifies a
// numeric response, and the content of the element is the id of widget
// (which should be a child of the dialogs @action_area). To mark a response
// as default, set the default attribute of the <action-widget> element
// to true.
//
// GtkDialog supports adding action widgets by specifying action as
// the type attribute of a <child> element. The widget will be added
// either to the action area or the headerbar of the dialog, depending
// on the use-header-bar property. The response id has to be associated
// with the action widget using the <action-widgets> element.
//
// An example of a #GtkDialog UI definition fragment:
// |[
// <object class="GtkDialog" id="dialog1">
// <child type="action">
// <object class="GtkButton" id="button_cancel"/>
// </child>
// <child type="action">
// <object class="GtkButton" id="button_ok">
// <property name="can-default">True</property>
// </object>
// </child>
// <action-widgets>
// <action-widget response="cancel">button_cancel</action-widget>
// <action-widget response="ok" default="true">button_ok</action-widget>
// </action-widgets>
// </object>
// ]|
/*

C record/class : GtkDialog
*/
type Dialog struct {
	native *C.GtkDialog
	// window : record
	// Private : priv
}

func DialogNewFromC(u unsafe.Pointer) *Dialog {
	c := (*C.GtkDialog)(u)
	if c == nil {
		return nil
	}

	g := &Dialog{native: c}

	return g
}

func (recv *Dialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Window upcasts to *Window
func (recv *Dialog) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *Dialog) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *Dialog) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *Dialog) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Dialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Dialog) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitary Object to Dialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a Dialog.
func CastToDialog(object *gobject.Object) *Dialog {
	return DialogNewFromC(object.ToC())
}

type signalDialogCloseDetail struct {
	callback  DialogSignalCloseCallback
	handlerID C.gulong
}

var signalDialogCloseId int
var signalDialogCloseMap = make(map[int]signalDialogCloseDetail)
var signalDialogCloseLock sync.Mutex

// DialogSignalCloseCallback is a callback function for a 'close' signal emitted from a Dialog.
type DialogSignalCloseCallback func()

/*
ConnectClose connects the callback to the 'close' signal for the Dialog.

The returned value represents the connection, and may be passed to DisconnectClose to remove it.
*/
func (recv *Dialog) ConnectClose(callback DialogSignalCloseCallback) int {
	signalDialogCloseLock.Lock()
	defer signalDialogCloseLock.Unlock()

	signalDialogCloseId++
	instance := C.gpointer(recv.native)
	handlerID := C.Dialog_signal_connect_close(instance, C.gpointer(uintptr(signalDialogCloseId)))

	detail := signalDialogCloseDetail{callback, handlerID}
	signalDialogCloseMap[signalDialogCloseId] = detail

	return signalDialogCloseId
}

/*
DisconnectClose disconnects a callback from the 'close' signal for the Dialog.

The connectionID should be a value returned from a call to ConnectClose.
*/
func (recv *Dialog) DisconnectClose(connectionID int) {
	signalDialogCloseLock.Lock()
	defer signalDialogCloseLock.Unlock()

	detail, exists := signalDialogCloseMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDialogCloseMap, connectionID)
}

//export dialog_closeHandler
func dialog_closeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalDialogCloseMap[index].callback
	callback()
}

// Unsupported signal 'response' for Dialog : unsupported parameter response_id : type gint :

// Creates a new dialog box.
//
// Widgets should not be packed into this #GtkWindow
// directly, but into the @vbox and @action_area, as described above.
/*

C function : gtk_dialog_new
*/
func DialogNew() *Dialog {
	retC := C.gtk_dialog_new()
	retGo := DialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_dialog_new_with_buttons : unsupported parameter ... : varargs

// Adds an activatable widget to the action area of a #GtkDialog,
// connecting a signal handler that will emit the #GtkDialog::response
// signal on the dialog when the widget is activated. The widget is
// appended to the end of the dialogs action area. If you want to add a
// non-activatable widget, simply pack it into the @action_area field
// of the #GtkDialog struct.
/*

C function : gtk_dialog_add_action_widget
*/
func (recv *Dialog) AddActionWidget(child *Widget, responseId int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_add_action_widget((*C.GtkDialog)(recv.native), c_child, c_response_id)

	return
}

// Adds a button with the given text and sets things up so that
// clicking the button will emit the #GtkDialog::response signal with
// the given @response_id. The button is appended to the end of the
// dialogs action area. The button widget is returned, but usually
// you dont need it.
/*

C function : gtk_dialog_add_button
*/
func (recv *Dialog) AddButton(buttonText string, responseId int32) *Widget {
	c_button_text := C.CString(buttonText)
	defer C.free(unsafe.Pointer(c_button_text))

	c_response_id := (C.gint)(responseId)

	retC := C.gtk_dialog_add_button((*C.GtkDialog)(recv.native), c_button_text, c_response_id)
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_dialog_add_buttons : unsupported parameter ... : varargs

// Emits the #GtkDialog::response signal with the given response ID.
// Used to indicate that the user has responded to the dialog in some way;
// typically either you or gtk_dialog_run() will be monitoring the
// ::response signal and take appropriate action.
/*

C function : gtk_dialog_response
*/
func (recv *Dialog) Response(responseId int32) {
	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_response((*C.GtkDialog)(recv.native), c_response_id)

	return
}

// Blocks in a recursive main loop until the @dialog either emits the
// #GtkDialog::response signal, or is destroyed. If the dialog is
// destroyed during the call to gtk_dialog_run(), gtk_dialog_run() returns
// #GTK_RESPONSE_NONE. Otherwise, it returns the response ID from the
// ::response signal emission.
//
// Before entering the recursive main loop, gtk_dialog_run() calls
// gtk_widget_show() on the dialog for you. Note that you still
// need to show any children of the dialog yourself.
//
// During gtk_dialog_run(), the default behavior of #GtkWidget::delete-event
// is disabled; if the dialog receives ::delete_event, it will not be
// destroyed as windows usually are, and gtk_dialog_run() will return
// #GTK_RESPONSE_DELETE_EVENT. Also, during gtk_dialog_run() the dialog
// will be modal. You can force gtk_dialog_run() to return at any time by
// calling gtk_dialog_response() to emit the ::response signal. Destroying
// the dialog during gtk_dialog_run() is a very bad idea, because your
// post-run code wont know whether the dialog was destroyed or not.
//
// After gtk_dialog_run() returns, you are responsible for hiding or
// destroying the dialog if you wish to do so.
//
// Typical usage of this function might be:
// |[<!-- language="C" -->
// GtkWidget *dialog = gtk_dialog_new ();
// Set up dialog...
//
// int result = gtk_dialog_run (GTK_DIALOG (dialog));
// switch (result)
// {
// case GTK_RESPONSE_ACCEPT:
// do_application_specific_something ();
// break;
// default:
// do_nothing_since_dialog_was_cancelled ();
// break;
// }
// gtk_widget_destroy (dialog);
// ]|
//
// Note that even though the recursive main loop gives the effect of a
// modal dialog (it prevents the user from interacting with other
// windows in the same window group while the dialog is run), callbacks
// such as timeouts, IO channel watches, DND drops, etc, will
// be triggered during a gtk_dialog_run() call.
/*

C function : gtk_dialog_run
*/
func (recv *Dialog) Run() int32 {
	retC := C.gtk_dialog_run((*C.GtkDialog)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Sets the last widget in the dialogs action area with the given @response_id
// as the default widget for the dialog. Pressing Enter normally activates
// the default widget.
/*

C function : gtk_dialog_set_default_response
*/
func (recv *Dialog) SetDefaultResponse(responseId int32) {
	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_set_default_response((*C.GtkDialog)(recv.native), c_response_id)

	return
}

// Calls `gtk_widget_set_sensitive (widget, @setting)`
// for each widget in the dialogs action area with the given @response_id.
// A convenient way to sensitize/desensitize dialog buttons.
/*

C function : gtk_dialog_set_response_sensitive
*/
func (recv *Dialog) SetResponseSensitive(responseId int32, setting bool) {
	c_response_id := (C.gint)(responseId)

	c_setting :=
		boolToGboolean(setting)

	C.gtk_dialog_set_response_sensitive((*C.GtkDialog)(recv.native), c_response_id, c_setting)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Dialog
func (recv *Dialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Dialog
func (recv *Dialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkDrawingArea widget is used for creating custom user interface
// elements. Its essentially a blank widget; you can draw on it. After
// creating a drawing area, the application may want to connect to:
//
// - Mouse and button press signals to respond to input from
// the user. (Use gtk_widget_add_events() to enable events
// you wish to receive.)
//
// - The #GtkWidget::realize signal to take any necessary actions
// when the widget is instantiated on a particular display.
// (Create GDK resources in response to this signal.)
//
// - The #GtkWidget::size-allocate signal to take any necessary
// actions when the widget changes size.
//
// - The #GtkWidget::draw signal to handle redrawing the
// contents of the widget.
//
// The following code portion demonstrates using a drawing
// area to display a circle in the normal widget foreground
// color.
//
// Note that GDK automatically clears the exposed area before sending
// the expose event, and that drawing is implicitly clipped to the exposed
// area. If you want to have a theme-provided background, you need
// to call gtk_render_background() in your ::draw method.
//
// ## Simple GtkDrawingArea usage
//
// |[<!-- language="C" -->
// gboolean
// draw_callback (GtkWidget *widget, cairo_t *cr, gpointer data)
// {
// guint width, height;
// GdkRGBA color;
// GtkStyleContext *context;
//
// context = gtk_widget_get_style_context (widget);
//
// width = gtk_widget_get_allocated_width (widget);
// height = gtk_widget_get_allocated_height (widget);
//
// gtk_render_background (context, cr, 0, 0, width, height);
//
// cairo_arc (cr,
// width / 2.0, height / 2.0,
// MIN (width, height) / 2.0,
// 0, 2 * G_PI);
//
// gtk_style_context_get_color (context,
// gtk_style_context_get_state (context),
// &color);
// gdk_cairo_set_source_rgba (cr, &color);
//
// cairo_fill (cr);
//
// return FALSE;
// }
// [...]
// GtkWidget *drawing_area = gtk_drawing_area_new ();
// gtk_widget_set_size_request (drawing_area, 100, 100);
// g_signal_connect (G_OBJECT (drawing_area), "draw",
// G_CALLBACK (draw_callback), NULL);
// ]|
//
// Draw signals are normally delivered when a drawing area first comes
// onscreen, or when its covered by another window and then uncovered.
// You can also force an expose event by adding to the damage region
// of the drawing areas window; gtk_widget_queue_draw_area() and
// gdk_window_invalidate_rect() are equally good ways to do this.
// Youll then get a draw signal for the invalid region.
//
// The available routines for drawing are documented on the
// [GDK Drawing Primitives][gdk3-Cairo-Interaction] page
// and the cairo documentation.
//
// To receive mouse events on a drawing area, you will need to enable
// them with gtk_widget_add_events(). To receive keyboard events, you
// will need to set the can-focus property on the drawing area, and you
// should probably draw some user-visible indication that the drawing
// area is focused. Use gtk_widget_has_focus() in your expose event
// handler to decide whether to draw the focus indicator. See
// gtk_render_focus() for one way to draw focus.
/*

C record/class : GtkDrawingArea
*/
type DrawingArea struct {
	native *C.GtkDrawingArea
	// widget : record
	// Private : dummy
}

func DrawingAreaNewFromC(u unsafe.Pointer) *DrawingArea {
	c := (*C.GtkDrawingArea)(u)
	if c == nil {
		return nil
	}

	g := &DrawingArea{native: c}

	return g
}

func (recv *DrawingArea) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *DrawingArea) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *DrawingArea) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *DrawingArea) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to DrawingArea.
// Exercise care, as this is a potentially dangerous function if the Object is not a DrawingArea.
func CastToDrawingArea(object *gobject.Object) *DrawingArea {
	return DrawingAreaNewFromC(object.ToC())
}

// Creates a new drawing area.
/*

C function : gtk_drawing_area_new
*/
func DrawingAreaNew() *DrawingArea {
	retC := C.gtk_drawing_area_new()
	retGo := DrawingAreaNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by DrawingArea
func (recv *DrawingArea) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by DrawingArea
func (recv *DrawingArea) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkEntry widget is a single line text entry
// widget. A fairly large set of key bindings are supported
// by default. If the entered text is longer than the allocation
// of the widget, the widget will scroll so that the cursor
// position is visible.
//
// When using an entry for passwords and other sensitive information,
// it can be put into password mode using gtk_entry_set_visibility().
// In this mode, entered text is displayed using a invisible character.
// By default, GTK+ picks the best invisible character that is available
// in the current font, but it can be changed with
// gtk_entry_set_invisible_char(). Since 2.16, GTK+ displays a warning
// when Caps Lock or input methods might interfere with entering text in
// a password entry. The warning can be turned off with the
// #GtkEntry:caps-lock-warning property.
//
// Since 2.16, GtkEntry has the ability to display progress or activity
// information behind the text. To make an entry display such information,
// use gtk_entry_set_progress_fraction() or gtk_entry_set_progress_pulse_step().
//
// Additionally, GtkEntry can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and
// can have tooltips. To add an icon, use gtk_entry_set_icon_from_gicon() or
// one of the various other functions that set an icon from a stock id, an
// icon name or a pixbuf. To trigger an action when the user clicks an icon,
// connect to the #GtkEntry::icon-press signal. To allow DND operations
// from an icon, use gtk_entry_set_icon_drag_source(). To set a tooltip on
// an icon, use gtk_entry_set_icon_tooltip_text() or the corresponding function
// for markup.
//
// Note that functionality or information that is only available by clicking
// on an icon in an entry may not be accessible at all to users which are not
// able to use a mouse or other pointing device. It is therefore recommended
// that any such functionality should also be available by other means, e.g.
// via the context menu of the entry.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// entry
//  image.left
//  image.right
//  undershoot.left
//  undershoot.right
//  [selection]
//  [progress[.pulse]]
//  [window.popup]
// ]|
//
// GtkEntry has a main node with the name entry. Depending on the properties
// of the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry shows progress, it adds a subnode with the name progress.
// The node has the style class .pulse when the shown progress is pulsing.
//
// The CSS node for a context menu is added as a subnode below entry as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using
// CSS nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
/*

C record/class : GtkEntry
*/
type Entry struct {
	native *C.GtkEntry
	// Private : parent_instance
	// Private : priv
}

func EntryNewFromC(u unsafe.Pointer) *Entry {
	c := (*C.GtkEntry)(u)
	if c == nil {
		return nil
	}

	g := &Entry{native: c}

	return g
}

func (recv *Entry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Entry) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Entry) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Entry) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Entry.
// Exercise care, as this is a potentially dangerous function if the Object is not a Entry.
func CastToEntry(object *gobject.Object) *Entry {
	return EntryNewFromC(object.ToC())
}

type signalEntryActivateDetail struct {
	callback  EntrySignalActivateCallback
	handlerID C.gulong
}

var signalEntryActivateId int
var signalEntryActivateMap = make(map[int]signalEntryActivateDetail)
var signalEntryActivateLock sync.Mutex

// EntrySignalActivateCallback is a callback function for a 'activate' signal emitted from a Entry.
type EntrySignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Entry) ConnectActivate(callback EntrySignalActivateCallback) int {
	signalEntryActivateLock.Lock()
	defer signalEntryActivateLock.Unlock()

	signalEntryActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_activate(instance, C.gpointer(uintptr(signalEntryActivateId)))

	detail := signalEntryActivateDetail{callback, handlerID}
	signalEntryActivateMap[signalEntryActivateId] = detail

	return signalEntryActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Entry.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Entry) DisconnectActivate(connectionID int) {
	signalEntryActivateLock.Lock()
	defer signalEntryActivateLock.Unlock()

	detail, exists := signalEntryActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryActivateMap, connectionID)
}

//export entry_activateHandler
func entry_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryActivateMap[index].callback
	callback()
}

type signalEntryBackspaceDetail struct {
	callback  EntrySignalBackspaceCallback
	handlerID C.gulong
}

var signalEntryBackspaceId int
var signalEntryBackspaceMap = make(map[int]signalEntryBackspaceDetail)
var signalEntryBackspaceLock sync.Mutex

// EntrySignalBackspaceCallback is a callback function for a 'backspace' signal emitted from a Entry.
type EntrySignalBackspaceCallback func()

/*
ConnectBackspace connects the callback to the 'backspace' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectBackspace to remove it.
*/
func (recv *Entry) ConnectBackspace(callback EntrySignalBackspaceCallback) int {
	signalEntryBackspaceLock.Lock()
	defer signalEntryBackspaceLock.Unlock()

	signalEntryBackspaceId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_backspace(instance, C.gpointer(uintptr(signalEntryBackspaceId)))

	detail := signalEntryBackspaceDetail{callback, handlerID}
	signalEntryBackspaceMap[signalEntryBackspaceId] = detail

	return signalEntryBackspaceId
}

/*
DisconnectBackspace disconnects a callback from the 'backspace' signal for the Entry.

The connectionID should be a value returned from a call to ConnectBackspace.
*/
func (recv *Entry) DisconnectBackspace(connectionID int) {
	signalEntryBackspaceLock.Lock()
	defer signalEntryBackspaceLock.Unlock()

	detail, exists := signalEntryBackspaceMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryBackspaceMap, connectionID)
}

//export entry_backspaceHandler
func entry_backspaceHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryBackspaceMap[index].callback
	callback()
}

type signalEntryCopyClipboardDetail struct {
	callback  EntrySignalCopyClipboardCallback
	handlerID C.gulong
}

var signalEntryCopyClipboardId int
var signalEntryCopyClipboardMap = make(map[int]signalEntryCopyClipboardDetail)
var signalEntryCopyClipboardLock sync.Mutex

// EntrySignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a Entry.
type EntrySignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *Entry) ConnectCopyClipboard(callback EntrySignalCopyClipboardCallback) int {
	signalEntryCopyClipboardLock.Lock()
	defer signalEntryCopyClipboardLock.Unlock()

	signalEntryCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalEntryCopyClipboardId)))

	detail := signalEntryCopyClipboardDetail{callback, handlerID}
	signalEntryCopyClipboardMap[signalEntryCopyClipboardId] = detail

	return signalEntryCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *Entry) DisconnectCopyClipboard(connectionID int) {
	signalEntryCopyClipboardLock.Lock()
	defer signalEntryCopyClipboardLock.Unlock()

	detail, exists := signalEntryCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCopyClipboardMap, connectionID)
}

//export entry_copyClipboardHandler
func entry_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryCopyClipboardMap[index].callback
	callback()
}

type signalEntryCutClipboardDetail struct {
	callback  EntrySignalCutClipboardCallback
	handlerID C.gulong
}

var signalEntryCutClipboardId int
var signalEntryCutClipboardMap = make(map[int]signalEntryCutClipboardDetail)
var signalEntryCutClipboardLock sync.Mutex

// EntrySignalCutClipboardCallback is a callback function for a 'cut-clipboard' signal emitted from a Entry.
type EntrySignalCutClipboardCallback func()

/*
ConnectCutClipboard connects the callback to the 'cut-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectCutClipboard to remove it.
*/
func (recv *Entry) ConnectCutClipboard(callback EntrySignalCutClipboardCallback) int {
	signalEntryCutClipboardLock.Lock()
	defer signalEntryCutClipboardLock.Unlock()

	signalEntryCutClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_cut_clipboard(instance, C.gpointer(uintptr(signalEntryCutClipboardId)))

	detail := signalEntryCutClipboardDetail{callback, handlerID}
	signalEntryCutClipboardMap[signalEntryCutClipboardId] = detail

	return signalEntryCutClipboardId
}

/*
DisconnectCutClipboard disconnects a callback from the 'cut-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectCutClipboard.
*/
func (recv *Entry) DisconnectCutClipboard(connectionID int) {
	signalEntryCutClipboardLock.Lock()
	defer signalEntryCutClipboardLock.Unlock()

	detail, exists := signalEntryCutClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCutClipboardMap, connectionID)
}

//export entry_cutClipboardHandler
func entry_cutClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryCutClipboardMap[index].callback
	callback()
}

// Unsupported signal 'delete-from-cursor' for Entry : unsupported parameter type : type DeleteType :

// Unsupported signal 'insert-at-cursor' for Entry : unsupported parameter string : type utf8 :

// Unsupported signal 'move-cursor' for Entry : unsupported parameter step : type MovementStep :

type signalEntryPasteClipboardDetail struct {
	callback  EntrySignalPasteClipboardCallback
	handlerID C.gulong
}

var signalEntryPasteClipboardId int
var signalEntryPasteClipboardMap = make(map[int]signalEntryPasteClipboardDetail)
var signalEntryPasteClipboardLock sync.Mutex

// EntrySignalPasteClipboardCallback is a callback function for a 'paste-clipboard' signal emitted from a Entry.
type EntrySignalPasteClipboardCallback func()

/*
ConnectPasteClipboard connects the callback to the 'paste-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectPasteClipboard to remove it.
*/
func (recv *Entry) ConnectPasteClipboard(callback EntrySignalPasteClipboardCallback) int {
	signalEntryPasteClipboardLock.Lock()
	defer signalEntryPasteClipboardLock.Unlock()

	signalEntryPasteClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_paste_clipboard(instance, C.gpointer(uintptr(signalEntryPasteClipboardId)))

	detail := signalEntryPasteClipboardDetail{callback, handlerID}
	signalEntryPasteClipboardMap[signalEntryPasteClipboardId] = detail

	return signalEntryPasteClipboardId
}

/*
DisconnectPasteClipboard disconnects a callback from the 'paste-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectPasteClipboard.
*/
func (recv *Entry) DisconnectPasteClipboard(connectionID int) {
	signalEntryPasteClipboardLock.Lock()
	defer signalEntryPasteClipboardLock.Unlock()

	detail, exists := signalEntryPasteClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryPasteClipboardMap, connectionID)
}

//export entry_pasteClipboardHandler
func entry_pasteClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryPasteClipboardMap[index].callback
	callback()
}

type signalEntryPopulatePopupDetail struct {
	callback  EntrySignalPopulatePopupCallback
	handlerID C.gulong
}

var signalEntryPopulatePopupId int
var signalEntryPopulatePopupMap = make(map[int]signalEntryPopulatePopupDetail)
var signalEntryPopulatePopupLock sync.Mutex

// EntrySignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a Entry.
type EntrySignalPopulatePopupCallback func(widget *Widget)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *Entry) ConnectPopulatePopup(callback EntrySignalPopulatePopupCallback) int {
	signalEntryPopulatePopupLock.Lock()
	defer signalEntryPopulatePopupLock.Unlock()

	signalEntryPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalEntryPopulatePopupId)))

	detail := signalEntryPopulatePopupDetail{callback, handlerID}
	signalEntryPopulatePopupMap[signalEntryPopulatePopupId] = detail

	return signalEntryPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the Entry.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *Entry) DisconnectPopulatePopup(connectionID int) {
	signalEntryPopulatePopupLock.Lock()
	defer signalEntryPopulatePopupLock.Unlock()

	detail, exists := signalEntryPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryPopulatePopupMap, connectionID)
}

//export entry_populatePopupHandler
func entry_populatePopupHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalEntryPopulatePopupMap[index].callback
	callback(widget)
}

type signalEntryToggleOverwriteDetail struct {
	callback  EntrySignalToggleOverwriteCallback
	handlerID C.gulong
}

var signalEntryToggleOverwriteId int
var signalEntryToggleOverwriteMap = make(map[int]signalEntryToggleOverwriteDetail)
var signalEntryToggleOverwriteLock sync.Mutex

// EntrySignalToggleOverwriteCallback is a callback function for a 'toggle-overwrite' signal emitted from a Entry.
type EntrySignalToggleOverwriteCallback func()

/*
ConnectToggleOverwrite connects the callback to the 'toggle-overwrite' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectToggleOverwrite to remove it.
*/
func (recv *Entry) ConnectToggleOverwrite(callback EntrySignalToggleOverwriteCallback) int {
	signalEntryToggleOverwriteLock.Lock()
	defer signalEntryToggleOverwriteLock.Unlock()

	signalEntryToggleOverwriteId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_toggle_overwrite(instance, C.gpointer(uintptr(signalEntryToggleOverwriteId)))

	detail := signalEntryToggleOverwriteDetail{callback, handlerID}
	signalEntryToggleOverwriteMap[signalEntryToggleOverwriteId] = detail

	return signalEntryToggleOverwriteId
}

/*
DisconnectToggleOverwrite disconnects a callback from the 'toggle-overwrite' signal for the Entry.

The connectionID should be a value returned from a call to ConnectToggleOverwrite.
*/
func (recv *Entry) DisconnectToggleOverwrite(connectionID int) {
	signalEntryToggleOverwriteLock.Lock()
	defer signalEntryToggleOverwriteLock.Unlock()

	detail, exists := signalEntryToggleOverwriteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryToggleOverwriteMap, connectionID)
}

//export entry_toggleOverwriteHandler
func entry_toggleOverwriteHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryToggleOverwriteMap[index].callback
	callback()
}

// Creates a new entry.
/*

C function : gtk_entry_new
*/
func EntryNew() *Entry {
	retC := C.gtk_entry_new()
	retGo := EntryNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the value set by gtk_entry_set_activates_default().
/*

C function : gtk_entry_get_activates_default
*/
func (recv *Entry) GetActivatesDefault() bool {
	retC := C.gtk_entry_get_activates_default((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_entry_set_has_frame().
/*

C function : gtk_entry_get_has_frame
*/
func (recv *Entry) GetHasFrame() bool {
	retC := C.gtk_entry_get_has_frame((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves the character displayed in place of the real characters
// for entries with visibility set to false. See gtk_entry_set_invisible_char().
/*

C function : gtk_entry_get_invisible_char
*/
func (recv *Entry) GetInvisibleChar() rune {
	retC := C.gtk_entry_get_invisible_char((*C.GtkEntry)(recv.native))
	retGo := (rune)(retC)

	return retGo
}

// Gets the #PangoLayout used to display the entry.
// The layout is useful to e.g. convert text positions to
// pixel positions, in combination with gtk_entry_get_layout_offsets().
// The returned layout is owned by the entry and must not be
// modified or freed by the caller.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte
// indices in the layout to byte indices in the entry contents.
/*

C function : gtk_entry_get_layout
*/
func (recv *Entry) GetLayout() *pango.Layout {
	retC := C.gtk_entry_get_layout((*C.GtkEntry)(recv.native))
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Obtains the position of the #PangoLayout used to render text
// in the entry, in widget coordinates. Useful if you want to line
// up the text in an entry with some other text, e.g. when using the
// entry to implement editable cells in a sheet widget.
//
// Also useful to convert mouse events into coordinates inside the
// #PangoLayout, e.g. to take some action if some part of the entry text
// is clicked.
//
// Note that as the user scrolls around in the entry the offsets will
// change; youll need to connect to the notify::scroll-offset
// signal to track this. Remember when using the #PangoLayout
// functions you need to convert to and from pixels using
// PANGO_PIXELS() or #PANGO_SCALE.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte
// indices in the layout to byte indices in the entry contents.
/*

C function : gtk_entry_get_layout_offsets
*/
func (recv *Entry) GetLayoutOffsets() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_entry_get_layout_offsets((*C.GtkEntry)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// Retrieves the maximum allowed length of the text in
// @entry. See gtk_entry_set_max_length().
//
// This is equivalent to getting @entry's #GtkEntryBuffer and
// calling gtk_entry_buffer_get_max_length() on it.
/*

C function : gtk_entry_get_max_length
*/
func (recv *Entry) GetMaxLength() int32 {
	retC := C.gtk_entry_get_max_length((*C.GtkEntry)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Retrieves the contents of the entry widget.
// See also gtk_editable_get_chars().
//
// This is equivalent to getting @entry's #GtkEntryBuffer and calling
// gtk_entry_buffer_get_text() on it.
/*

C function : gtk_entry_get_text
*/
func (recv *Entry) GetText() string {
	retC := C.gtk_entry_get_text((*C.GtkEntry)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Retrieves whether the text in @entry is visible. See
// gtk_entry_set_visibility().
/*

C function : gtk_entry_get_visibility
*/
func (recv *Entry) GetVisibility() bool {
	retC := C.gtk_entry_get_visibility((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_entry_set_width_chars().
/*

C function : gtk_entry_get_width_chars
*/
func (recv *Entry) GetWidthChars() int32 {
	retC := C.gtk_entry_get_width_chars((*C.GtkEntry)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Converts from a position in the entrys #PangoLayout (returned by
// gtk_entry_get_layout()) to a position in the entry contents
// (returned by gtk_entry_get_text()).
/*

C function : gtk_entry_layout_index_to_text_index
*/
func (recv *Entry) LayoutIndexToTextIndex(layoutIndex int32) int32 {
	c_layout_index := (C.gint)(layoutIndex)

	retC := C.gtk_entry_layout_index_to_text_index((*C.GtkEntry)(recv.native), c_layout_index)
	retGo := (int32)(retC)

	return retGo
}

// If @setting is %TRUE, pressing Enter in the @entry will activate the default
// widget for the window containing the entry. This usually means that
// the dialog box containing the entry will be closed, since the default
// widget is usually one of the dialog buttons.
//
// (For experts: if @setting is %TRUE, the entry calls
// gtk_window_activate_default() on the window containing the entry, in
// the default handler for the #GtkEntry::activate signal.)
/*

C function : gtk_entry_set_activates_default
*/
func (recv *Entry) SetActivatesDefault(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_entry_set_activates_default((*C.GtkEntry)(recv.native), c_setting)

	return
}

// Sets whether the entry has a beveled frame around it.
/*

C function : gtk_entry_set_has_frame
*/
func (recv *Entry) SetHasFrame(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_entry_set_has_frame((*C.GtkEntry)(recv.native), c_setting)

	return
}

// Sets the character to use in place of the actual text when
// gtk_entry_set_visibility() has been called to set text visibility
// to %FALSE. i.e. this is the character used in password mode to
// show the user how many characters have been typed. By default, GTK+
// picks the best invisible char available in the current font. If you
// set the invisible char to 0, then the user will get no feedback
// at all; there will be no text on the screen as they type.
/*

C function : gtk_entry_set_invisible_char
*/
func (recv *Entry) SetInvisibleChar(ch rune) {
	c_ch := (C.gunichar)(ch)

	C.gtk_entry_set_invisible_char((*C.GtkEntry)(recv.native), c_ch)

	return
}

// Sets the maximum allowed length of the contents of the widget. If
// the current contents are longer than the given length, then they
// will be truncated to fit.
//
// This is equivalent to getting @entry's #GtkEntryBuffer and
// calling gtk_entry_buffer_set_max_length() on it.
// ]|
/*

C function : gtk_entry_set_max_length
*/
func (recv *Entry) SetMaxLength(max int32) {
	c_max := (C.gint)(max)

	C.gtk_entry_set_max_length((*C.GtkEntry)(recv.native), c_max)

	return
}

// Sets the text in the widget to the given
// value, replacing the current contents.
//
// See gtk_entry_buffer_set_text().
/*

C function : gtk_entry_set_text
*/
func (recv *Entry) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_entry_set_text((*C.GtkEntry)(recv.native), c_text)

	return
}

// Sets whether the contents of the entry are visible or not.
// When visibility is set to %FALSE, characters are displayed
// as the invisible char, and will also appear that way when
// the text in the entry widget is copied elsewhere.
//
// By default, GTK+ picks the best invisible character available
// in the current font, but it can be changed with
// gtk_entry_set_invisible_char().
//
// Note that you probably want to set #GtkEntry:input-purpose
// to %GTK_INPUT_PURPOSE_PASSWORD or %GTK_INPUT_PURPOSE_PIN to
// inform input methods about the purpose of this entry,
// in addition to setting visibility to %FALSE.
/*

C function : gtk_entry_set_visibility
*/
func (recv *Entry) SetVisibility(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_entry_set_visibility((*C.GtkEntry)(recv.native), c_visible)

	return
}

// Changes the size request of the entry to be about the right size
// for @n_chars characters. Note that it changes the size
// request, the size can still be affected by
// how you pack the widget into containers. If @n_chars is -1, the
// size reverts to the default entry size.
/*

C function : gtk_entry_set_width_chars
*/
func (recv *Entry) SetWidthChars(nChars int32) {
	c_n_chars := (C.gint)(nChars)

	C.gtk_entry_set_width_chars((*C.GtkEntry)(recv.native), c_n_chars)

	return
}

// Converts from a position in the entry contents (returned
// by gtk_entry_get_text()) to a position in the
// entrys #PangoLayout (returned by gtk_entry_get_layout(),
// with text retrieved via pango_layout_get_text()).
/*

C function : gtk_entry_text_index_to_layout_index
*/
func (recv *Entry) TextIndexToLayoutIndex(textIndex int32) int32 {
	c_text_index := (C.gint)(textIndex)

	retC := C.gtk_entry_text_index_to_layout_index((*C.GtkEntry)(recv.native), c_text_index)
	retGo := (int32)(retC)

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Entry
func (recv *Entry) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Entry
func (recv *Entry) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by Entry
func (recv *Entry) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by Entry
func (recv *Entry) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

/*

C record/class : GtkEntryAccessible
*/
type EntryAccessible struct {
	native *C.GtkEntryAccessible
	// parent : record
	// priv : record
}

func EntryAccessibleNewFromC(u unsafe.Pointer) *EntryAccessible {
	c := (*C.GtkEntryAccessible)(u)
	if c == nil {
		return nil
	}

	g := &EntryAccessible{native: c}

	return g
}

func (recv *EntryAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *EntryAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *EntryAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *EntryAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to EntryAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryAccessible.
func CastToEntryAccessible(object *gobject.Object) *EntryAccessible {
	return EntryAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by EntryAccessible
func (recv *EntryAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by EntryAccessible
func (recv *EntryAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by EntryAccessible
func (recv *EntryAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by EntryAccessible
func (recv *EntryAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// The #GtkEntryBuffer class contains the actual text displayed in a
// #GtkEntry widget.
//
// A single #GtkEntryBuffer object can be shared by multiple #GtkEntry
// widgets which will then share the same text content, but not the cursor
// position, visibility attributes, icon etc.
//
// #GtkEntryBuffer may be derived from. Such a derived class might allow
// text to be stored in an alternate location, such as non-pageable memory,
// useful in the case of important passwords. Or a derived class could
// integrate with an applications concept of undo/redo.
/*

C record/class : GtkEntryBuffer
*/
type EntryBuffer struct {
	native *C.GtkEntryBuffer
	// parent_instance : record
	// Private : priv
}

func EntryBufferNewFromC(u unsafe.Pointer) *EntryBuffer {
	c := (*C.GtkEntryBuffer)(u)
	if c == nil {
		return nil
	}

	g := &EntryBuffer{native: c}

	return g
}

func (recv *EntryBuffer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *EntryBuffer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to EntryBuffer.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryBuffer.
func CastToEntryBuffer(object *gobject.Object) *EntryBuffer {
	return EntryBufferNewFromC(object.ToC())
}

// #GtkEntryCompletion is an auxiliary object to be used in conjunction with
// #GtkEntry to provide the completion functionality. It implements the
// #GtkCellLayout interface, to allow the user to add extra cells to the
// #GtkTreeView with completion matches.
//
// Completion functionality means that when the user modifies the text
// in the entry, #GtkEntryCompletion checks which rows in the model match
// the current content of the entry, and displays a list of matches.
// By default, the matching is done by comparing the entry text
// case-insensitively against the text column of the model (see
// gtk_entry_completion_set_text_column()), but this can be overridden
// with a custom match function (see gtk_entry_completion_set_match_func()).
//
// When the user selects a completion, the content of the entry is
// updated. By default, the content of the entry is replaced by the
// text column of the model, but this can be overridden by connecting
// to the #GtkEntryCompletion::match-selected signal and updating the
// entry in the signal handler. Note that you should return %TRUE from
// the signal handler to suppress the default behaviour.
//
// To add completion functionality to an entry, use gtk_entry_set_completion().
//
// In addition to regular completion matches, which will be inserted into the
// entry when they are selected, #GtkEntryCompletion also allows to display
// actions in the popup window. Their appearance is similar to menuitems,
// to differentiate them clearly from completion strings. When an action is
// selected, the #GtkEntryCompletion::action-activated signal is emitted.
//
// GtkEntryCompletion uses a #GtkTreeModelFilter model to represent the
// subset of the entire model that is currently matching. While the
// GtkEntryCompletion signals #GtkEntryCompletion::match-selected and
// #GtkEntryCompletion::cursor-on-match take the original model and an
// iter pointing to that model as arguments, other callbacks and signals
// (such as #GtkCellLayoutDataFuncs or #GtkCellArea::apply-attributes)
// will generally take the filter model as argument. As long as you are
// only calling gtk_tree_model_get(), this will make no difference to
// you. If for some reason, you need the original model, use
// gtk_tree_model_filter_get_model(). Dont forget to use
// gtk_tree_model_filter_convert_iter_to_child_iter() to obtain a
// matching iter.
/*

C record/class : GtkEntryCompletion
*/
type EntryCompletion struct {
	native *C.GtkEntryCompletion
	// parent_instance : record
	// Private : priv
}

func EntryCompletionNewFromC(u unsafe.Pointer) *EntryCompletion {
	c := (*C.GtkEntryCompletion)(u)
	if c == nil {
		return nil
	}

	g := &EntryCompletion{native: c}

	return g
}

func (recv *EntryCompletion) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *EntryCompletion) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to EntryCompletion.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryCompletion.
func CastToEntryCompletion(object *gobject.Object) *EntryCompletion {
	return EntryCompletionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by EntryCompletion
func (recv *EntryCompletion) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by EntryCompletion
func (recv *EntryCompletion) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Unsupported : EntryIconAccessible : no CType

// The #GtkEventBox widget is a subclass of #GtkBin which also has its
// own window. It is useful since it allows you to catch events for widgets
// which do not have their own window.
/*

C record/class : GtkEventBox
*/
type EventBox struct {
	native *C.GtkEventBox
	// bin : record
	// Private : priv
}

func EventBoxNewFromC(u unsafe.Pointer) *EventBox {
	c := (*C.GtkEventBox)(u)
	if c == nil {
		return nil
	}

	g := &EventBox{native: c}

	return g
}

func (recv *EventBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *EventBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *EventBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *EventBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *EventBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *EventBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to EventBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a EventBox.
func CastToEventBox(object *gobject.Object) *EventBox {
	return EventBoxNewFromC(object.ToC())
}

// Creates a new #GtkEventBox.
/*

C function : gtk_event_box_new
*/
func EventBoxNew() *EventBox {
	retC := C.gtk_event_box_new()
	retGo := EventBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by EventBox
func (recv *EventBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by EventBox
func (recv *EventBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkEventController is a base, low-level implementation for event
// controllers. Those react to a series of #GdkEvents, and possibly trigger
// actions as a consequence of those.
/*

C record/class : GtkEventController
*/
type EventController struct {
	native *C.GtkEventController
}

func EventControllerNewFromC(u unsafe.Pointer) *EventController {
	c := (*C.GtkEventController)(u)
	if c == nil {
		return nil
	}

	g := &EventController{native: c}

	return g
}

func (recv *EventController) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *EventController) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to EventController.
// Exercise care, as this is a potentially dangerous function if the Object is not a EventController.
func CastToEventController(object *gobject.Object) *EventController {
	return EventControllerNewFromC(object.ToC())
}

// A #GtkExpander allows the user to hide or show its child by clicking
// on an expander triangle similar to the triangles used in a #GtkTreeView.
//
// Normally you use an expander as you would use any other descendant
// of #GtkBin; you create the child widget and use gtk_container_add()
// to add it to the expander. When the expander is toggled, it will take
// care of showing and hiding the child automatically.
//
// # Special Usage
//
// There are situations in which you may prefer to show and hide the
// expanded widget yourself, such as when you want to actually create
// the widget at expansion time. In this case, create a #GtkExpander
// but do not add a child to it. The expander widget has an
// #GtkExpander:expanded property which can be used to monitor
// its expansion state. You should watch this property with a signal
// connection as follows:
//
// |[<!-- language="C" -->
// static void
// expander_callback (GObject    *object,
// GParamSpec *param_spec,
// gpointer    user_data)
// {
// GtkExpander *expander;
//
// expander = GTK_EXPANDER (object);
//
// if (gtk_expander_get_expanded (expander))
// {
// Show or create widgets
// }
// else
// {
// Hide or destroy widgets
// }
// }
//
// static void
// create_expander (void)
// {
// GtkWidget *expander = gtk_expander_new_with_mnemonic ("_More Options");
// g_signal_connect (expander, "notify::expanded",
// G_CALLBACK (expander_callback), NULL);
//
// ...
// }
// ]|
//
// # GtkExpander as GtkBuildable
//
// The GtkExpander implementation of the GtkBuildable interface supports
// placing a child in the label position by specifying label as the
// type attribute of a <child> element. A normal content child can be
// specified without specifying a <child> type attribute.
//
// An example of a UI definition fragment with GtkExpander:
// |[
// <object class="GtkExpander">
// <child type="label">
// <object class="GtkLabel" id="expander-label"/>
// </child>
// <child>
// <object class="GtkEntry" id="expander-content"/>
// </child>
// </object>
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// expander
//  title
//     arrow
//     <label widget>
//  <child>
// ]|
//
// GtkExpander has three CSS nodes, the main node with the name expander,
// a subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
/*

C record/class : GtkExpander
*/
type Expander struct {
	native *C.GtkExpander
	// bin : record
	// priv : record
}

func ExpanderNewFromC(u unsafe.Pointer) *Expander {
	c := (*C.GtkExpander)(u)
	if c == nil {
		return nil
	}

	g := &Expander{native: c}

	return g
}

func (recv *Expander) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Expander) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Expander) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Expander) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Expander) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Expander) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Expander.
// Exercise care, as this is a potentially dangerous function if the Object is not a Expander.
func CastToExpander(object *gobject.Object) *Expander {
	return ExpanderNewFromC(object.ToC())
}

type signalExpanderActivateDetail struct {
	callback  ExpanderSignalActivateCallback
	handlerID C.gulong
}

var signalExpanderActivateId int
var signalExpanderActivateMap = make(map[int]signalExpanderActivateDetail)
var signalExpanderActivateLock sync.Mutex

// ExpanderSignalActivateCallback is a callback function for a 'activate' signal emitted from a Expander.
type ExpanderSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Expander.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Expander) ConnectActivate(callback ExpanderSignalActivateCallback) int {
	signalExpanderActivateLock.Lock()
	defer signalExpanderActivateLock.Unlock()

	signalExpanderActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Expander_signal_connect_activate(instance, C.gpointer(uintptr(signalExpanderActivateId)))

	detail := signalExpanderActivateDetail{callback, handlerID}
	signalExpanderActivateMap[signalExpanderActivateId] = detail

	return signalExpanderActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Expander.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Expander) DisconnectActivate(connectionID int) {
	signalExpanderActivateLock.Lock()
	defer signalExpanderActivateLock.Unlock()

	detail, exists := signalExpanderActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalExpanderActivateMap, connectionID)
}

//export expander_activateHandler
func expander_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalExpanderActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Expander
func (recv *Expander) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Expander
func (recv *Expander) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkExpanderAccessible
*/
type ExpanderAccessible struct {
	native *C.GtkExpanderAccessible
	// parent : record
	// priv : record
}

func ExpanderAccessibleNewFromC(u unsafe.Pointer) *ExpanderAccessible {
	c := (*C.GtkExpanderAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ExpanderAccessible{native: c}

	return g
}

func (recv *ExpanderAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ExpanderAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ExpanderAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ExpanderAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ExpanderAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ExpanderAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ExpanderAccessible.
func CastToExpanderAccessible(object *gobject.Object) *ExpanderAccessible {
	return ExpanderAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ExpanderAccessible
func (recv *ExpanderAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ExpanderAccessible
func (recv *ExpanderAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// The #GtkFileChooserButton is a widget that lets the user select a
// file.  It implements the #GtkFileChooser interface.  Visually, it is a
// file name with a button to bring up a #GtkFileChooserDialog.
// The user can then use that dialog to change the file associated with
// that button.  This widget does not support setting the
// #GtkFileChooser:select-multiple property to %TRUE.
//
// ## Create a button to let the user select a file in /etc
//
// |[<!-- language="C" -->
// {
// GtkWidget *button;
//
// button = gtk_file_chooser_button_new (_("Select a file"),
// GTK_FILE_CHOOSER_ACTION_OPEN);
// gtk_file_chooser_set_current_folder (GTK_FILE_CHOOSER (button),
// "/etc");
// }
// ]|
//
// The #GtkFileChooserButton supports the #GtkFileChooserActions
// %GTK_FILE_CHOOSER_ACTION_OPEN and %GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// > The #GtkFileChooserButton will ellipsize the label, and will thus
// > request little horizontal space.  To give the button more space,
// > you should call gtk_widget_get_preferred_size(),
// > gtk_file_chooser_button_set_width_chars(), or pack the button in
// > such a way that other interface elements give space to the
// > widget.
/*

C record/class : GtkFileChooserButton
*/
type FileChooserButton struct {
	native *C.GtkFileChooserButton
	// parent : record
	// Private : priv
}

func FileChooserButtonNewFromC(u unsafe.Pointer) *FileChooserButton {
	c := (*C.GtkFileChooserButton)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserButton{native: c}

	return g
}

func (recv *FileChooserButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *FileChooserButton) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FileChooserButton) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserButton) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserButton) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to FileChooserButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserButton.
func CastToFileChooserButton(object *gobject.Object) *FileChooserButton {
	return FileChooserButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserButton
func (recv *FileChooserButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserButton
func (recv *FileChooserButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserButton
func (recv *FileChooserButton) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FileChooserButton
func (recv *FileChooserButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// #GtkFileChooserDialog is a dialog box suitable for use with
// File/Open or File/Save as commands.  This widget works by
// putting a #GtkFileChooserWidget inside a #GtkDialog.  It exposes
// the #GtkFileChooser interface, so you can use all of the
// #GtkFileChooser functions on the file chooser dialog as well as
// those for #GtkDialog.
//
// Note that #GtkFileChooserDialog does not have any methods of its
// own.  Instead, you should use the functions that work on a
// #GtkFileChooser.
//
// If you want to integrate well with the platform you should use the
// #GtkFileChooserNative API, which will use a platform-specific
// dialog if available and fall back to GtkFileChooserDialog
// otherwise.
//
// ## Typical usage ## {#gtkfilechooser-typical-usage}
//
// In the simplest of cases, you can the following code to use
// #GtkFileChooserDialog to select a file for opening:
//
// |[
// GtkWidget *dialog;
// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
// gint res;
//
// dialog = gtk_file_chooser_dialog_new ("Open File",
// parent_window,
// action,
// _("_Cancel"),
// GTK_RESPONSE_CANCEL,
// _("_Open"),
// GTK_RESPONSE_ACCEPT,
// NULL);
//
// res = gtk_dialog_run (GTK_DIALOG (dialog));
// if (res == GTK_RESPONSE_ACCEPT)
// {
// char *filename;
// GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
// filename = gtk_file_chooser_get_filename (chooser);
// open_file (filename);
// g_free (filename);
// }
//
// gtk_widget_destroy (dialog);
// ]|
//
// To use a dialog for saving, you can use this:
//
// |[
// GtkWidget *dialog;
// GtkFileChooser *chooser;
// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
// gint res;
//
// dialog = gtk_file_chooser_dialog_new ("Save File",
// parent_window,
// action,
// _("_Cancel"),
// GTK_RESPONSE_CANCEL,
// _("_Save"),
// GTK_RESPONSE_ACCEPT,
// NULL);
// chooser = GTK_FILE_CHOOSER (dialog);
//
// gtk_file_chooser_set_do_overwrite_confirmation (chooser, TRUE);
//
// if (user_edited_a_new_document)
// gtk_file_chooser_set_current_name (chooser,
// _("Untitled document"));
// else
// gtk_file_chooser_set_filename (chooser,
// existing_filename);
//
// res = gtk_dialog_run (GTK_DIALOG (dialog));
// if (res == GTK_RESPONSE_ACCEPT)
// {
// char *filename;
//
// filename = gtk_file_chooser_get_filename (chooser);
// save_to_file (filename);
// g_free (filename);
// }
//
// gtk_widget_destroy (dialog);
// ]|
//
// ## Setting up a file chooser dialog ## {#gtkfilechooserdialog-setting-up}
//
// There are various cases in which you may need to use a #GtkFileChooserDialog:
//
// - To select a file for opening. Use #GTK_FILE_CHOOSER_ACTION_OPEN.
//
// - To save a file for the first time. Use #GTK_FILE_CHOOSER_ACTION_SAVE,
// and suggest a name such as Untitled with gtk_file_chooser_set_current_name().
//
// - To save a file under a different name. Use #GTK_FILE_CHOOSER_ACTION_SAVE,
// and set the existing filename with gtk_file_chooser_set_filename().
//
// - To choose a folder instead of a file. Use #GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// Note that old versions of the file choosers documentation suggested
// using gtk_file_chooser_set_current_folder() in various
// situations, with the intention of letting the application
// suggest a reasonable default folder.  This is no longer
// considered to be a good policy, as now the file chooser is
// able to make good suggestions on its own.  In general, you
// should only cause the file chooser to show a specific folder
// when it is appropriate to use gtk_file_chooser_set_filename(),
// i.e. when you are doing a Save As command and you already
// have a file saved somewhere.
//
// ## Response Codes ## {#gtkfilechooserdialog-responses}
//
// #GtkFileChooserDialog inherits from #GtkDialog, so buttons that
// go in its action area have response codes such as
// #GTK_RESPONSE_ACCEPT and #GTK_RESPONSE_CANCEL.  For example, you
// could call gtk_file_chooser_dialog_new() as follows:
//
// |[
// GtkWidget *dialog;
// GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
// dialog = gtk_file_chooser_dialog_new ("Open File",
// parent_window,
// action,
// _("_Cancel"),
// GTK_RESPONSE_CANCEL,
// _("_Open"),
// GTK_RESPONSE_ACCEPT,
// NULL);
// ]|
//
// This will create buttons for Cancel and Open that use stock
// response identifiers from #GtkResponseType.  For most dialog
// boxes you can use your own custom response codes rather than the
// ones in #GtkResponseType, but #GtkFileChooserDialog assumes that
// its accept-type action, e.g. an Open or Save button,
// will have one of the following response codes:
//
// - #GTK_RESPONSE_ACCEPT
// - #GTK_RESPONSE_OK
// - #GTK_RESPONSE_YES
// - #GTK_RESPONSE_APPLY
//
// This is because #GtkFileChooserDialog must intercept responses
// and switch to folders if appropriate, rather than letting the
// dialog terminate  the implementation uses these known
// response codes to know which responses can be blocked if
// appropriate.
//
// To summarize, make sure you use a
// [stock response code][gtkfilechooserdialog-responses]
// when you use #GtkFileChooserDialog to ensure proper operation.
/*

C record/class : GtkFileChooserDialog
*/
type FileChooserDialog struct {
	native *C.GtkFileChooserDialog
	// parent_instance : record
	// priv : record
}

func FileChooserDialogNewFromC(u unsafe.Pointer) *FileChooserDialog {
	c := (*C.GtkFileChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserDialog{native: c}

	return g
}

func (recv *FileChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *FileChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FileChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FileChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FileChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to FileChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserDialog.
func CastToFileChooserDialog(object *gobject.Object) *FileChooserDialog {
	return FileChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserDialog
func (recv *FileChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserDialog
func (recv *FileChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserDialog
func (recv *FileChooserDialog) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// #GtkFileChooserWidget is a widget for choosing files.
// It exposes the #GtkFileChooser interface, and you should
// use the methods of this interface to interact with the
// widget.
//
// # CSS nodes
//
// GtkFileChooserWidget has a single CSS node with name filechooser.
/*

C record/class : GtkFileChooserWidget
*/
type FileChooserWidget struct {
	native *C.GtkFileChooserWidget
	// parent_instance : record
	// priv : record
}

func FileChooserWidgetNewFromC(u unsafe.Pointer) *FileChooserWidget {
	c := (*C.GtkFileChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserWidget{native: c}

	return g
}

func (recv *FileChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *FileChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FileChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to FileChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserWidget.
func CastToFileChooserWidget(object *gobject.Object) *FileChooserWidget {
	return FileChooserWidgetNewFromC(object.ToC())
}

type signalFileChooserWidgetDesktopFolderDetail struct {
	callback  FileChooserWidgetSignalDesktopFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetDesktopFolderId int
var signalFileChooserWidgetDesktopFolderMap = make(map[int]signalFileChooserWidgetDesktopFolderDetail)
var signalFileChooserWidgetDesktopFolderLock sync.Mutex

// FileChooserWidgetSignalDesktopFolderCallback is a callback function for a 'desktop-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalDesktopFolderCallback func()

/*
ConnectDesktopFolder connects the callback to the 'desktop-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectDesktopFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectDesktopFolder(callback FileChooserWidgetSignalDesktopFolderCallback) int {
	signalFileChooserWidgetDesktopFolderLock.Lock()
	defer signalFileChooserWidgetDesktopFolderLock.Unlock()

	signalFileChooserWidgetDesktopFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_desktop_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetDesktopFolderId)))

	detail := signalFileChooserWidgetDesktopFolderDetail{callback, handlerID}
	signalFileChooserWidgetDesktopFolderMap[signalFileChooserWidgetDesktopFolderId] = detail

	return signalFileChooserWidgetDesktopFolderId
}

/*
DisconnectDesktopFolder disconnects a callback from the 'desktop-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectDesktopFolder.
*/
func (recv *FileChooserWidget) DisconnectDesktopFolder(connectionID int) {
	signalFileChooserWidgetDesktopFolderLock.Lock()
	defer signalFileChooserWidgetDesktopFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetDesktopFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetDesktopFolderMap, connectionID)
}

//export filechooserwidget_desktopFolderHandler
func filechooserwidget_desktopFolderHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetDesktopFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetDownFolderDetail struct {
	callback  FileChooserWidgetSignalDownFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetDownFolderId int
var signalFileChooserWidgetDownFolderMap = make(map[int]signalFileChooserWidgetDownFolderDetail)
var signalFileChooserWidgetDownFolderLock sync.Mutex

// FileChooserWidgetSignalDownFolderCallback is a callback function for a 'down-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalDownFolderCallback func()

/*
ConnectDownFolder connects the callback to the 'down-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectDownFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectDownFolder(callback FileChooserWidgetSignalDownFolderCallback) int {
	signalFileChooserWidgetDownFolderLock.Lock()
	defer signalFileChooserWidgetDownFolderLock.Unlock()

	signalFileChooserWidgetDownFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_down_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetDownFolderId)))

	detail := signalFileChooserWidgetDownFolderDetail{callback, handlerID}
	signalFileChooserWidgetDownFolderMap[signalFileChooserWidgetDownFolderId] = detail

	return signalFileChooserWidgetDownFolderId
}

/*
DisconnectDownFolder disconnects a callback from the 'down-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectDownFolder.
*/
func (recv *FileChooserWidget) DisconnectDownFolder(connectionID int) {
	signalFileChooserWidgetDownFolderLock.Lock()
	defer signalFileChooserWidgetDownFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetDownFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetDownFolderMap, connectionID)
}

//export filechooserwidget_downFolderHandler
func filechooserwidget_downFolderHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetDownFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetHomeFolderDetail struct {
	callback  FileChooserWidgetSignalHomeFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetHomeFolderId int
var signalFileChooserWidgetHomeFolderMap = make(map[int]signalFileChooserWidgetHomeFolderDetail)
var signalFileChooserWidgetHomeFolderLock sync.Mutex

// FileChooserWidgetSignalHomeFolderCallback is a callback function for a 'home-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalHomeFolderCallback func()

/*
ConnectHomeFolder connects the callback to the 'home-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectHomeFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectHomeFolder(callback FileChooserWidgetSignalHomeFolderCallback) int {
	signalFileChooserWidgetHomeFolderLock.Lock()
	defer signalFileChooserWidgetHomeFolderLock.Unlock()

	signalFileChooserWidgetHomeFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_home_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetHomeFolderId)))

	detail := signalFileChooserWidgetHomeFolderDetail{callback, handlerID}
	signalFileChooserWidgetHomeFolderMap[signalFileChooserWidgetHomeFolderId] = detail

	return signalFileChooserWidgetHomeFolderId
}

/*
DisconnectHomeFolder disconnects a callback from the 'home-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectHomeFolder.
*/
func (recv *FileChooserWidget) DisconnectHomeFolder(connectionID int) {
	signalFileChooserWidgetHomeFolderLock.Lock()
	defer signalFileChooserWidgetHomeFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetHomeFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetHomeFolderMap, connectionID)
}

//export filechooserwidget_homeFolderHandler
func filechooserwidget_homeFolderHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetHomeFolderMap[index].callback
	callback()
}

// Unsupported signal 'location-popup' for FileChooserWidget : unsupported parameter path : type utf8 :

type signalFileChooserWidgetLocationPopupOnPasteDetail struct {
	callback  FileChooserWidgetSignalLocationPopupOnPasteCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationPopupOnPasteId int
var signalFileChooserWidgetLocationPopupOnPasteMap = make(map[int]signalFileChooserWidgetLocationPopupOnPasteDetail)
var signalFileChooserWidgetLocationPopupOnPasteLock sync.Mutex

// FileChooserWidgetSignalLocationPopupOnPasteCallback is a callback function for a 'location-popup-on-paste' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationPopupOnPasteCallback func()

/*
ConnectLocationPopupOnPaste connects the callback to the 'location-popup-on-paste' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationPopupOnPaste to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationPopupOnPaste(callback FileChooserWidgetSignalLocationPopupOnPasteCallback) int {
	signalFileChooserWidgetLocationPopupOnPasteLock.Lock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.Unlock()

	signalFileChooserWidgetLocationPopupOnPasteId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_popup_on_paste(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationPopupOnPasteId)))

	detail := signalFileChooserWidgetLocationPopupOnPasteDetail{callback, handlerID}
	signalFileChooserWidgetLocationPopupOnPasteMap[signalFileChooserWidgetLocationPopupOnPasteId] = detail

	return signalFileChooserWidgetLocationPopupOnPasteId
}

/*
DisconnectLocationPopupOnPaste disconnects a callback from the 'location-popup-on-paste' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationPopupOnPaste.
*/
func (recv *FileChooserWidget) DisconnectLocationPopupOnPaste(connectionID int) {
	signalFileChooserWidgetLocationPopupOnPasteLock.Lock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationPopupOnPasteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationPopupOnPasteMap, connectionID)
}

//export filechooserwidget_locationPopupOnPasteHandler
func filechooserwidget_locationPopupOnPasteHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationPopupOnPasteMap[index].callback
	callback()
}

type signalFileChooserWidgetLocationTogglePopupDetail struct {
	callback  FileChooserWidgetSignalLocationTogglePopupCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationTogglePopupId int
var signalFileChooserWidgetLocationTogglePopupMap = make(map[int]signalFileChooserWidgetLocationTogglePopupDetail)
var signalFileChooserWidgetLocationTogglePopupLock sync.Mutex

// FileChooserWidgetSignalLocationTogglePopupCallback is a callback function for a 'location-toggle-popup' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationTogglePopupCallback func()

/*
ConnectLocationTogglePopup connects the callback to the 'location-toggle-popup' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationTogglePopup to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationTogglePopup(callback FileChooserWidgetSignalLocationTogglePopupCallback) int {
	signalFileChooserWidgetLocationTogglePopupLock.Lock()
	defer signalFileChooserWidgetLocationTogglePopupLock.Unlock()

	signalFileChooserWidgetLocationTogglePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_toggle_popup(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationTogglePopupId)))

	detail := signalFileChooserWidgetLocationTogglePopupDetail{callback, handlerID}
	signalFileChooserWidgetLocationTogglePopupMap[signalFileChooserWidgetLocationTogglePopupId] = detail

	return signalFileChooserWidgetLocationTogglePopupId
}

/*
DisconnectLocationTogglePopup disconnects a callback from the 'location-toggle-popup' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationTogglePopup.
*/
func (recv *FileChooserWidget) DisconnectLocationTogglePopup(connectionID int) {
	signalFileChooserWidgetLocationTogglePopupLock.Lock()
	defer signalFileChooserWidgetLocationTogglePopupLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationTogglePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationTogglePopupMap, connectionID)
}

//export filechooserwidget_locationTogglePopupHandler
func filechooserwidget_locationTogglePopupHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationTogglePopupMap[index].callback
	callback()
}

type signalFileChooserWidgetPlacesShortcutDetail struct {
	callback  FileChooserWidgetSignalPlacesShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetPlacesShortcutId int
var signalFileChooserWidgetPlacesShortcutMap = make(map[int]signalFileChooserWidgetPlacesShortcutDetail)
var signalFileChooserWidgetPlacesShortcutLock sync.Mutex

// FileChooserWidgetSignalPlacesShortcutCallback is a callback function for a 'places-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalPlacesShortcutCallback func()

/*
ConnectPlacesShortcut connects the callback to the 'places-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectPlacesShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectPlacesShortcut(callback FileChooserWidgetSignalPlacesShortcutCallback) int {
	signalFileChooserWidgetPlacesShortcutLock.Lock()
	defer signalFileChooserWidgetPlacesShortcutLock.Unlock()

	signalFileChooserWidgetPlacesShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_places_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetPlacesShortcutId)))

	detail := signalFileChooserWidgetPlacesShortcutDetail{callback, handlerID}
	signalFileChooserWidgetPlacesShortcutMap[signalFileChooserWidgetPlacesShortcutId] = detail

	return signalFileChooserWidgetPlacesShortcutId
}

/*
DisconnectPlacesShortcut disconnects a callback from the 'places-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectPlacesShortcut.
*/
func (recv *FileChooserWidget) DisconnectPlacesShortcut(connectionID int) {
	signalFileChooserWidgetPlacesShortcutLock.Lock()
	defer signalFileChooserWidgetPlacesShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetPlacesShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetPlacesShortcutMap, connectionID)
}

//export filechooserwidget_placesShortcutHandler
func filechooserwidget_placesShortcutHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetPlacesShortcutMap[index].callback
	callback()
}

// Unsupported signal 'quick-bookmark' for FileChooserWidget : unsupported parameter bookmark_index : type gint :

type signalFileChooserWidgetRecentShortcutDetail struct {
	callback  FileChooserWidgetSignalRecentShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetRecentShortcutId int
var signalFileChooserWidgetRecentShortcutMap = make(map[int]signalFileChooserWidgetRecentShortcutDetail)
var signalFileChooserWidgetRecentShortcutLock sync.Mutex

// FileChooserWidgetSignalRecentShortcutCallback is a callback function for a 'recent-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalRecentShortcutCallback func()

/*
ConnectRecentShortcut connects the callback to the 'recent-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectRecentShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectRecentShortcut(callback FileChooserWidgetSignalRecentShortcutCallback) int {
	signalFileChooserWidgetRecentShortcutLock.Lock()
	defer signalFileChooserWidgetRecentShortcutLock.Unlock()

	signalFileChooserWidgetRecentShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_recent_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetRecentShortcutId)))

	detail := signalFileChooserWidgetRecentShortcutDetail{callback, handlerID}
	signalFileChooserWidgetRecentShortcutMap[signalFileChooserWidgetRecentShortcutId] = detail

	return signalFileChooserWidgetRecentShortcutId
}

/*
DisconnectRecentShortcut disconnects a callback from the 'recent-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectRecentShortcut.
*/
func (recv *FileChooserWidget) DisconnectRecentShortcut(connectionID int) {
	signalFileChooserWidgetRecentShortcutLock.Lock()
	defer signalFileChooserWidgetRecentShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetRecentShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetRecentShortcutMap, connectionID)
}

//export filechooserwidget_recentShortcutHandler
func filechooserwidget_recentShortcutHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetRecentShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetSearchShortcutDetail struct {
	callback  FileChooserWidgetSignalSearchShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetSearchShortcutId int
var signalFileChooserWidgetSearchShortcutMap = make(map[int]signalFileChooserWidgetSearchShortcutDetail)
var signalFileChooserWidgetSearchShortcutLock sync.Mutex

// FileChooserWidgetSignalSearchShortcutCallback is a callback function for a 'search-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalSearchShortcutCallback func()

/*
ConnectSearchShortcut connects the callback to the 'search-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectSearchShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectSearchShortcut(callback FileChooserWidgetSignalSearchShortcutCallback) int {
	signalFileChooserWidgetSearchShortcutLock.Lock()
	defer signalFileChooserWidgetSearchShortcutLock.Unlock()

	signalFileChooserWidgetSearchShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_search_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetSearchShortcutId)))

	detail := signalFileChooserWidgetSearchShortcutDetail{callback, handlerID}
	signalFileChooserWidgetSearchShortcutMap[signalFileChooserWidgetSearchShortcutId] = detail

	return signalFileChooserWidgetSearchShortcutId
}

/*
DisconnectSearchShortcut disconnects a callback from the 'search-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectSearchShortcut.
*/
func (recv *FileChooserWidget) DisconnectSearchShortcut(connectionID int) {
	signalFileChooserWidgetSearchShortcutLock.Lock()
	defer signalFileChooserWidgetSearchShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetSearchShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetSearchShortcutMap, connectionID)
}

//export filechooserwidget_searchShortcutHandler
func filechooserwidget_searchShortcutHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetSearchShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetShowHiddenDetail struct {
	callback  FileChooserWidgetSignalShowHiddenCallback
	handlerID C.gulong
}

var signalFileChooserWidgetShowHiddenId int
var signalFileChooserWidgetShowHiddenMap = make(map[int]signalFileChooserWidgetShowHiddenDetail)
var signalFileChooserWidgetShowHiddenLock sync.Mutex

// FileChooserWidgetSignalShowHiddenCallback is a callback function for a 'show-hidden' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalShowHiddenCallback func()

/*
ConnectShowHidden connects the callback to the 'show-hidden' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectShowHidden to remove it.
*/
func (recv *FileChooserWidget) ConnectShowHidden(callback FileChooserWidgetSignalShowHiddenCallback) int {
	signalFileChooserWidgetShowHiddenLock.Lock()
	defer signalFileChooserWidgetShowHiddenLock.Unlock()

	signalFileChooserWidgetShowHiddenId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_show_hidden(instance, C.gpointer(uintptr(signalFileChooserWidgetShowHiddenId)))

	detail := signalFileChooserWidgetShowHiddenDetail{callback, handlerID}
	signalFileChooserWidgetShowHiddenMap[signalFileChooserWidgetShowHiddenId] = detail

	return signalFileChooserWidgetShowHiddenId
}

/*
DisconnectShowHidden disconnects a callback from the 'show-hidden' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectShowHidden.
*/
func (recv *FileChooserWidget) DisconnectShowHidden(connectionID int) {
	signalFileChooserWidgetShowHiddenLock.Lock()
	defer signalFileChooserWidgetShowHiddenLock.Unlock()

	detail, exists := signalFileChooserWidgetShowHiddenMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetShowHiddenMap, connectionID)
}

//export filechooserwidget_showHiddenHandler
func filechooserwidget_showHiddenHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetShowHiddenMap[index].callback
	callback()
}

type signalFileChooserWidgetUpFolderDetail struct {
	callback  FileChooserWidgetSignalUpFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetUpFolderId int
var signalFileChooserWidgetUpFolderMap = make(map[int]signalFileChooserWidgetUpFolderDetail)
var signalFileChooserWidgetUpFolderLock sync.Mutex

// FileChooserWidgetSignalUpFolderCallback is a callback function for a 'up-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalUpFolderCallback func()

/*
ConnectUpFolder connects the callback to the 'up-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectUpFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectUpFolder(callback FileChooserWidgetSignalUpFolderCallback) int {
	signalFileChooserWidgetUpFolderLock.Lock()
	defer signalFileChooserWidgetUpFolderLock.Unlock()

	signalFileChooserWidgetUpFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_up_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetUpFolderId)))

	detail := signalFileChooserWidgetUpFolderDetail{callback, handlerID}
	signalFileChooserWidgetUpFolderMap[signalFileChooserWidgetUpFolderId] = detail

	return signalFileChooserWidgetUpFolderId
}

/*
DisconnectUpFolder disconnects a callback from the 'up-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectUpFolder.
*/
func (recv *FileChooserWidget) DisconnectUpFolder(connectionID int) {
	signalFileChooserWidgetUpFolderLock.Lock()
	defer signalFileChooserWidgetUpFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetUpFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetUpFolderMap, connectionID)
}

//export filechooserwidget_upFolderHandler
func filechooserwidget_upFolderHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetUpFolderMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserWidget
func (recv *FileChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserWidget
func (recv *FileChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserWidget
func (recv *FileChooserWidget) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FileChooserWidget
func (recv *FileChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// A GtkFileFilter can be used to restrict the files being shown in a
// #GtkFileChooser. Files can be filtered based on their name (with
// gtk_file_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), or by a custom filter function
// (with gtk_file_filter_add_custom()).
//
// Filtering by mime types handles aliasing and subclassing of mime
// types; e.g. a filter for text/plain also matches a file with mime
// type application/rtf, since application/rtf is a subclass of
// text/plain. Note that #GtkFileFilter allows wildcards for the
// subtype of a mime type, so you can e.g. filter for image/\*.
//
// Normally, filters are used by adding them to a #GtkFileChooser,
// see gtk_file_chooser_add_filter(), but it is also possible
// to manually use a filter on a file with gtk_file_filter_filter().
//
// # GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface
// supports adding rules using the <mime-types>, <patterns> and
// <applications> elements and listing the rules within. Specifying
// a <mime-type> or <pattern> has the same effect as as calling
// gtk_file_filter_add_mime_type() or gtk_file_filter_add_pattern().
//
// An example of a UI definition fragment specifying GtkFileFilter
// rules:
// |[
// <object class="GtkFileFilter">
// <mime-types>
// <mime-type>text/plain</mime-type>
// <mime-type>image/ *</mime-type>
// </mime-types>
// <patterns>
// <pattern>*.txt</pattern>
// <pattern>*.png</pattern>
// </patterns>
// </object>
// ]|
/*

C record/class : GtkFileFilter
*/
type FileFilter struct {
	native *C.GtkFileFilter
}

func FileFilterNewFromC(u unsafe.Pointer) *FileFilter {
	c := (*C.GtkFileFilter)(u)
	if c == nil {
		return nil
	}

	g := &FileFilter{native: c}

	return g
}

func (recv *FileFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileFilter) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FileFilter) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to FileFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileFilter.
func CastToFileFilter(object *gobject.Object) *FileFilter {
	return FileFilterNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by FileFilter
func (recv *FileFilter) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkFixed widget is a container which can place child widgets
// at fixed positions and with fixed sizes, given in pixels. #GtkFixed
// performs no automatic layout management.
//
// For most applications, you should not use this container! It keeps
// you from having to learn about the other GTK+ containers, but it
// results in broken applications.  With #GtkFixed, the following
// things will result in truncated text, overlapping widgets, and
// other display bugs:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course
// change the size of widgets containing text; keep in mind that
// users may use a larger font because of difficulty reading the
// default, or they may be using a different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also,
// display of non-English text will use a different font in many
// cases.
//
// In addition, #GtkFixed does not pay attention to text direction and thus may
// produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK+ will order containers
// appropriately for the text direction, e.g. to put labels to the right of the
// thing they label when using an RTL language, but it cant do that with
// #GtkFixed. So if you need to reorder widgets depending on the text direction,
// you would need to manually detect it and adjust child positions accordingly.
//
// Finally, fixed positioning makes it kind of annoying to add/remove
// GUI elements, since you have to reposition all the other
// elements. This is a long-term maintenance problem for your
// application.
//
// If you know none of these things are an issue for your application,
// and prefer the simplicity of #GtkFixed, by all means use the
// widget. But you should be aware of the tradeoffs.
//
// See also #GtkLayout, which shares the ability to perform fixed positioning
// of child widgets and additionally adds custom drawing and scrollability.
/*

C record/class : GtkFixed
*/
type Fixed struct {
	native *C.GtkFixed
	// container : record
	// Private : priv
}

func FixedNewFromC(u unsafe.Pointer) *Fixed {
	c := (*C.GtkFixed)(u)
	if c == nil {
		return nil
	}

	g := &Fixed{native: c}

	return g
}

func (recv *Fixed) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Fixed) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Fixed) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Fixed) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Fixed) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Fixed.
// Exercise care, as this is a potentially dangerous function if the Object is not a Fixed.
func CastToFixed(object *gobject.Object) *Fixed {
	return FixedNewFromC(object.ToC())
}

// Creates a new #GtkFixed.
/*

C function : gtk_fixed_new
*/
func FixedNew() *Fixed {
	retC := C.gtk_fixed_new()
	retGo := FixedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Moves a child of a #GtkFixed container to the given position.
/*

C function : gtk_fixed_move
*/
func (recv *Fixed) Move(widget *Widget, x int32, y int32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_fixed_move((*C.GtkFixed)(recv.native), c_widget, c_x, c_y)

	return
}

// Adds a widget to a #GtkFixed container at the given position.
/*

C function : gtk_fixed_put
*/
func (recv *Fixed) Put(widget *Widget, x int32, y int32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_fixed_put((*C.GtkFixed)(recv.native), c_widget, c_x, c_y)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Fixed
func (recv *Fixed) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Fixed
func (recv *Fixed) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A GtkFlowBox positions child widgets in sequence according to its
// orientation.
//
// For instance, with the horizontal orientation, the widgets will be
// arranged from left to right, starting a new row under the previous
// row when necessary. Reducing the width in this case will require more
// rows, so a larger height will be requested.
//
// Likewise, with the vertical orientation, the widgets will be arranged
// from top to bottom, starting a new column to the right when necessary.
// Reducing the height will require more columns, so a larger width will
// be requested.
//
// The size request of a GtkFlowBox alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a #GtkScrolledWindow to enable that.
//
// The children of a GtkFlowBox can be dynamically sorted and filtered.
//
// Although a GtkFlowBox must have only #GtkFlowBoxChild children,
// you can add any kind of widget to it via gtk_container_add(), and
// a GtkFlowBoxChild widget will automatically be inserted between
// the box and the widget.
//
// Also see #GtkListBox.
//
// GtkFlowBox was added in GTK+ 3.12.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// flowbox
//  flowboxchild
//     <child>
//  flowboxchild
//     <child>
// 
//  [rubberband]
// ]|
//
// GtkFlowBox uses a single CSS node with name flowbox. GtkFlowBoxChild
// uses a single CSS node with name flowboxchild.
// For rubberband selection, a subnode with name rubberband is used.
/*

C record/class : GtkFlowBox
*/
type FlowBox struct {
	native *C.GtkFlowBox
	// container : record
}

func FlowBoxNewFromC(u unsafe.Pointer) *FlowBox {
	c := (*C.GtkFlowBox)(u)
	if c == nil {
		return nil
	}

	g := &FlowBox{native: c}

	return g
}

func (recv *FlowBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *FlowBox) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *FlowBox) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FlowBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FlowBox) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to FlowBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBox.
func CastToFlowBox(object *gobject.Object) *FlowBox {
	return FlowBoxNewFromC(object.ToC())
}

type signalFlowBoxActivateCursorChildDetail struct {
	callback  FlowBoxSignalActivateCursorChildCallback
	handlerID C.gulong
}

var signalFlowBoxActivateCursorChildId int
var signalFlowBoxActivateCursorChildMap = make(map[int]signalFlowBoxActivateCursorChildDetail)
var signalFlowBoxActivateCursorChildLock sync.Mutex

// FlowBoxSignalActivateCursorChildCallback is a callback function for a 'activate-cursor-child' signal emitted from a FlowBox.
type FlowBoxSignalActivateCursorChildCallback func()

/*
ConnectActivateCursorChild connects the callback to the 'activate-cursor-child' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectActivateCursorChild to remove it.
*/
func (recv *FlowBox) ConnectActivateCursorChild(callback FlowBoxSignalActivateCursorChildCallback) int {
	signalFlowBoxActivateCursorChildLock.Lock()
	defer signalFlowBoxActivateCursorChildLock.Unlock()

	signalFlowBoxActivateCursorChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_activate_cursor_child(instance, C.gpointer(uintptr(signalFlowBoxActivateCursorChildId)))

	detail := signalFlowBoxActivateCursorChildDetail{callback, handlerID}
	signalFlowBoxActivateCursorChildMap[signalFlowBoxActivateCursorChildId] = detail

	return signalFlowBoxActivateCursorChildId
}

/*
DisconnectActivateCursorChild disconnects a callback from the 'activate-cursor-child' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectActivateCursorChild.
*/
func (recv *FlowBox) DisconnectActivateCursorChild(connectionID int) {
	signalFlowBoxActivateCursorChildLock.Lock()
	defer signalFlowBoxActivateCursorChildLock.Unlock()

	detail, exists := signalFlowBoxActivateCursorChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxActivateCursorChildMap, connectionID)
}

//export flowbox_activateCursorChildHandler
func flowbox_activateCursorChildHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxActivateCursorChildMap[index].callback
	callback()
}

type signalFlowBoxChildActivatedDetail struct {
	callback  FlowBoxSignalChildActivatedCallback
	handlerID C.gulong
}

var signalFlowBoxChildActivatedId int
var signalFlowBoxChildActivatedMap = make(map[int]signalFlowBoxChildActivatedDetail)
var signalFlowBoxChildActivatedLock sync.Mutex

// FlowBoxSignalChildActivatedCallback is a callback function for a 'child-activated' signal emitted from a FlowBox.
type FlowBoxSignalChildActivatedCallback func(child *FlowBoxChild)

/*
ConnectChildActivated connects the callback to the 'child-activated' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectChildActivated to remove it.
*/
func (recv *FlowBox) ConnectChildActivated(callback FlowBoxSignalChildActivatedCallback) int {
	signalFlowBoxChildActivatedLock.Lock()
	defer signalFlowBoxChildActivatedLock.Unlock()

	signalFlowBoxChildActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_child_activated(instance, C.gpointer(uintptr(signalFlowBoxChildActivatedId)))

	detail := signalFlowBoxChildActivatedDetail{callback, handlerID}
	signalFlowBoxChildActivatedMap[signalFlowBoxChildActivatedId] = detail

	return signalFlowBoxChildActivatedId
}

/*
DisconnectChildActivated disconnects a callback from the 'child-activated' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectChildActivated.
*/
func (recv *FlowBox) DisconnectChildActivated(connectionID int) {
	signalFlowBoxChildActivatedLock.Lock()
	defer signalFlowBoxChildActivatedLock.Unlock()

	detail, exists := signalFlowBoxChildActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxChildActivatedMap, connectionID)
}

//export flowbox_childActivatedHandler
func flowbox_childActivatedHandler(_ *C.GObject, c_child *C.GtkFlowBoxChild, data C.gpointer) {
	child := FlowBoxChildNewFromC(unsafe.Pointer(c_child))

	index := int(uintptr(data))
	callback := signalFlowBoxChildActivatedMap[index].callback
	callback(child)
}

// Unsupported signal 'move-cursor' for FlowBox : unsupported parameter step : type MovementStep :

type signalFlowBoxSelectAllDetail struct {
	callback  FlowBoxSignalSelectAllCallback
	handlerID C.gulong
}

var signalFlowBoxSelectAllId int
var signalFlowBoxSelectAllMap = make(map[int]signalFlowBoxSelectAllDetail)
var signalFlowBoxSelectAllLock sync.Mutex

// FlowBoxSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a FlowBox.
type FlowBoxSignalSelectAllCallback func()

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *FlowBox) ConnectSelectAll(callback FlowBoxSignalSelectAllCallback) int {
	signalFlowBoxSelectAllLock.Lock()
	defer signalFlowBoxSelectAllLock.Unlock()

	signalFlowBoxSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_select_all(instance, C.gpointer(uintptr(signalFlowBoxSelectAllId)))

	detail := signalFlowBoxSelectAllDetail{callback, handlerID}
	signalFlowBoxSelectAllMap[signalFlowBoxSelectAllId] = detail

	return signalFlowBoxSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *FlowBox) DisconnectSelectAll(connectionID int) {
	signalFlowBoxSelectAllLock.Lock()
	defer signalFlowBoxSelectAllLock.Unlock()

	detail, exists := signalFlowBoxSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxSelectAllMap, connectionID)
}

//export flowbox_selectAllHandler
func flowbox_selectAllHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxSelectAllMap[index].callback
	callback()
}

type signalFlowBoxSelectedChildrenChangedDetail struct {
	callback  FlowBoxSignalSelectedChildrenChangedCallback
	handlerID C.gulong
}

var signalFlowBoxSelectedChildrenChangedId int
var signalFlowBoxSelectedChildrenChangedMap = make(map[int]signalFlowBoxSelectedChildrenChangedDetail)
var signalFlowBoxSelectedChildrenChangedLock sync.Mutex

// FlowBoxSignalSelectedChildrenChangedCallback is a callback function for a 'selected-children-changed' signal emitted from a FlowBox.
type FlowBoxSignalSelectedChildrenChangedCallback func()

/*
ConnectSelectedChildrenChanged connects the callback to the 'selected-children-changed' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectSelectedChildrenChanged to remove it.
*/
func (recv *FlowBox) ConnectSelectedChildrenChanged(callback FlowBoxSignalSelectedChildrenChangedCallback) int {
	signalFlowBoxSelectedChildrenChangedLock.Lock()
	defer signalFlowBoxSelectedChildrenChangedLock.Unlock()

	signalFlowBoxSelectedChildrenChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_selected_children_changed(instance, C.gpointer(uintptr(signalFlowBoxSelectedChildrenChangedId)))

	detail := signalFlowBoxSelectedChildrenChangedDetail{callback, handlerID}
	signalFlowBoxSelectedChildrenChangedMap[signalFlowBoxSelectedChildrenChangedId] = detail

	return signalFlowBoxSelectedChildrenChangedId
}

/*
DisconnectSelectedChildrenChanged disconnects a callback from the 'selected-children-changed' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectSelectedChildrenChanged.
*/
func (recv *FlowBox) DisconnectSelectedChildrenChanged(connectionID int) {
	signalFlowBoxSelectedChildrenChangedLock.Lock()
	defer signalFlowBoxSelectedChildrenChangedLock.Unlock()

	detail, exists := signalFlowBoxSelectedChildrenChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxSelectedChildrenChangedMap, connectionID)
}

//export flowbox_selectedChildrenChangedHandler
func flowbox_selectedChildrenChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxSelectedChildrenChangedMap[index].callback
	callback()
}

type signalFlowBoxToggleCursorChildDetail struct {
	callback  FlowBoxSignalToggleCursorChildCallback
	handlerID C.gulong
}

var signalFlowBoxToggleCursorChildId int
var signalFlowBoxToggleCursorChildMap = make(map[int]signalFlowBoxToggleCursorChildDetail)
var signalFlowBoxToggleCursorChildLock sync.Mutex

// FlowBoxSignalToggleCursorChildCallback is a callback function for a 'toggle-cursor-child' signal emitted from a FlowBox.
type FlowBoxSignalToggleCursorChildCallback func()

/*
ConnectToggleCursorChild connects the callback to the 'toggle-cursor-child' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectToggleCursorChild to remove it.
*/
func (recv *FlowBox) ConnectToggleCursorChild(callback FlowBoxSignalToggleCursorChildCallback) int {
	signalFlowBoxToggleCursorChildLock.Lock()
	defer signalFlowBoxToggleCursorChildLock.Unlock()

	signalFlowBoxToggleCursorChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_toggle_cursor_child(instance, C.gpointer(uintptr(signalFlowBoxToggleCursorChildId)))

	detail := signalFlowBoxToggleCursorChildDetail{callback, handlerID}
	signalFlowBoxToggleCursorChildMap[signalFlowBoxToggleCursorChildId] = detail

	return signalFlowBoxToggleCursorChildId
}

/*
DisconnectToggleCursorChild disconnects a callback from the 'toggle-cursor-child' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectToggleCursorChild.
*/
func (recv *FlowBox) DisconnectToggleCursorChild(connectionID int) {
	signalFlowBoxToggleCursorChildLock.Lock()
	defer signalFlowBoxToggleCursorChildLock.Unlock()

	detail, exists := signalFlowBoxToggleCursorChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxToggleCursorChildMap, connectionID)
}

//export flowbox_toggleCursorChildHandler
func flowbox_toggleCursorChildHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxToggleCursorChildMap[index].callback
	callback()
}

type signalFlowBoxUnselectAllDetail struct {
	callback  FlowBoxSignalUnselectAllCallback
	handlerID C.gulong
}

var signalFlowBoxUnselectAllId int
var signalFlowBoxUnselectAllMap = make(map[int]signalFlowBoxUnselectAllDetail)
var signalFlowBoxUnselectAllLock sync.Mutex

// FlowBoxSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a FlowBox.
type FlowBoxSignalUnselectAllCallback func()

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *FlowBox) ConnectUnselectAll(callback FlowBoxSignalUnselectAllCallback) int {
	signalFlowBoxUnselectAllLock.Lock()
	defer signalFlowBoxUnselectAllLock.Unlock()

	signalFlowBoxUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalFlowBoxUnselectAllId)))

	detail := signalFlowBoxUnselectAllDetail{callback, handlerID}
	signalFlowBoxUnselectAllMap[signalFlowBoxUnselectAllId] = detail

	return signalFlowBoxUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *FlowBox) DisconnectUnselectAll(connectionID int) {
	signalFlowBoxUnselectAllLock.Lock()
	defer signalFlowBoxUnselectAllLock.Unlock()

	detail, exists := signalFlowBoxUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxUnselectAllMap, connectionID)
}

//export flowbox_unselectAllHandler
func flowbox_unselectAllHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxUnselectAllMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FlowBox
func (recv *FlowBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FlowBox
func (recv *FlowBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FlowBox
func (recv *FlowBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkFlowBoxAccessible
*/
type FlowBoxAccessible struct {
	native *C.GtkFlowBoxAccessible
	// parent : record
	// priv : record
}

func FlowBoxAccessibleNewFromC(u unsafe.Pointer) *FlowBoxAccessible {
	c := (*C.GtkFlowBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxAccessible{native: c}

	return g
}

func (recv *FlowBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FlowBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FlowBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FlowBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FlowBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to FlowBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxAccessible.
func CastToFlowBoxAccessible(object *gobject.Object) *FlowBoxAccessible {
	return FlowBoxAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FlowBoxAccessible
func (recv *FlowBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by FlowBoxAccessible
func (recv *FlowBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

/*

C record/class : GtkFlowBoxChild
*/
type FlowBoxChild struct {
	native *C.GtkFlowBoxChild
	// parent_instance : record
}

func FlowBoxChildNewFromC(u unsafe.Pointer) *FlowBoxChild {
	c := (*C.GtkFlowBoxChild)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChild{native: c}

	return g
}

func (recv *FlowBoxChild) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *FlowBoxChild) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FlowBoxChild) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *FlowBoxChild) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FlowBoxChild) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FlowBoxChild) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to FlowBoxChild.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxChild.
func CastToFlowBoxChild(object *gobject.Object) *FlowBoxChild {
	return FlowBoxChildNewFromC(object.ToC())
}

type signalFlowBoxChildActivateDetail struct {
	callback  FlowBoxChildSignalActivateCallback
	handlerID C.gulong
}

var signalFlowBoxChildActivateId int
var signalFlowBoxChildActivateMap = make(map[int]signalFlowBoxChildActivateDetail)
var signalFlowBoxChildActivateLock sync.Mutex

// FlowBoxChildSignalActivateCallback is a callback function for a 'activate' signal emitted from a FlowBoxChild.
type FlowBoxChildSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the FlowBoxChild.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *FlowBoxChild) ConnectActivate(callback FlowBoxChildSignalActivateCallback) int {
	signalFlowBoxChildActivateLock.Lock()
	defer signalFlowBoxChildActivateLock.Unlock()

	signalFlowBoxChildActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBoxChild_signal_connect_activate(instance, C.gpointer(uintptr(signalFlowBoxChildActivateId)))

	detail := signalFlowBoxChildActivateDetail{callback, handlerID}
	signalFlowBoxChildActivateMap[signalFlowBoxChildActivateId] = detail

	return signalFlowBoxChildActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the FlowBoxChild.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *FlowBoxChild) DisconnectActivate(connectionID int) {
	signalFlowBoxChildActivateLock.Lock()
	defer signalFlowBoxChildActivateLock.Unlock()

	detail, exists := signalFlowBoxChildActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxChildActivateMap, connectionID)
}

//export flowboxchild_activateHandler
func flowboxchild_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxChildActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FlowBoxChild
func (recv *FlowBoxChild) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FlowBoxChild
func (recv *FlowBoxChild) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkFlowBoxChildAccessible
*/
type FlowBoxChildAccessible struct {
	native *C.GtkFlowBoxChildAccessible
	// parent : record
}

func FlowBoxChildAccessibleNewFromC(u unsafe.Pointer) *FlowBoxChildAccessible {
	c := (*C.GtkFlowBoxChildAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChildAccessible{native: c}

	return g
}

func (recv *FlowBoxChildAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FlowBoxChildAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FlowBoxChildAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FlowBoxChildAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FlowBoxChildAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to FlowBoxChildAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxChildAccessible.
func CastToFlowBoxChildAccessible(object *gobject.Object) *FlowBoxChildAccessible {
	return FlowBoxChildAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FlowBoxChildAccessible
func (recv *FlowBoxChildAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// The #GtkFontButton is a button which displays the currently selected
// font an allows to open a font chooser dialog to change the font.
// It is suitable widget for selecting a font in a preference dialog.
//
// # CSS nodes
//
// GtkFontButton has a single CSS node with name button and style class .font.
/*

C record/class : GtkFontButton
*/
type FontButton struct {
	native *C.GtkFontButton
	// button : record
	// Private : priv
}

func FontButtonNewFromC(u unsafe.Pointer) *FontButton {
	c := (*C.GtkFontButton)(u)
	if c == nil {
		return nil
	}

	g := &FontButton{native: c}

	return g
}

func (recv *FontButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *FontButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *FontButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *FontButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *FontButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to FontButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontButton.
func CastToFontButton(object *gobject.Object) *FontButton {
	return FontButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontButton
func (recv *FontButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by FontButton
func (recv *FontButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by FontButton
func (recv *FontButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontButton
func (recv *FontButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontButton
func (recv *FontButton) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// The #GtkFontChooserDialog widget is a dialog for selecting a font.
// It implements the #GtkFontChooser interface.
//
// # GtkFontChooserDialog as GtkBuildable
//
// The GtkFontChooserDialog implementation of the #GtkBuildable
// interface exposes the buttons with the names select_button
// and cancel_button.
/*

C record/class : GtkFontChooserDialog
*/
type FontChooserDialog struct {
	native *C.GtkFontChooserDialog
	// parent_instance : record
	// Private : priv
}

func FontChooserDialogNewFromC(u unsafe.Pointer) *FontChooserDialog {
	c := (*C.GtkFontChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserDialog{native: c}

	return g
}

func (recv *FontChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *FontChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FontChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FontChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FontChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FontChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to FontChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontChooserDialog.
func CastToFontChooserDialog(object *gobject.Object) *FontChooserDialog {
	return FontChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontChooserDialog
func (recv *FontChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontChooserDialog
func (recv *FontChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontChooserDialog
func (recv *FontChooserDialog) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// The #GtkFontChooserWidget widget lists the available fonts,
// styles and sizes, allowing the user to select a font. It is
// used in the #GtkFontChooserDialog widget to provide a
// dialog box for selecting fonts.
//
// To set the font which is initially selected, use
// gtk_font_chooser_set_font() or gtk_font_chooser_set_font_desc().
//
// To get the selected font use gtk_font_chooser_get_font() or
// gtk_font_chooser_get_font_desc().
//
// To change the text which is shown in the preview area, use
// gtk_font_chooser_set_preview_text().
//
// # CSS nodes
//
// GtkFontChooserWidget has a single CSS node with name fontchooser.
/*

C record/class : GtkFontChooserWidget
*/
type FontChooserWidget struct {
	native *C.GtkFontChooserWidget
	// parent_instance : record
	// Private : priv
}

func FontChooserWidgetNewFromC(u unsafe.Pointer) *FontChooserWidget {
	c := (*C.GtkFontChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserWidget{native: c}

	return g
}

func (recv *FontChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *FontChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FontChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FontChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to FontChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontChooserWidget.
func CastToFontChooserWidget(object *gobject.Object) *FontChooserWidget {
	return FontChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontChooserWidget
func (recv *FontChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontChooserWidget
func (recv *FontChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontChooserWidget
func (recv *FontChooserWidget) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FontChooserWidget
func (recv *FontChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkFontSelection
*/
type FontSelection struct {
	native *C.GtkFontSelection
	// parent_instance : record
	// Private : priv
}

func FontSelectionNewFromC(u unsafe.Pointer) *FontSelection {
	c := (*C.GtkFontSelection)(u)
	if c == nil {
		return nil
	}

	g := &FontSelection{native: c}

	return g
}

func (recv *FontSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *FontSelection) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FontSelection) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FontSelection) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontSelection) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontSelection) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to FontSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontSelection.
func CastToFontSelection(object *gobject.Object) *FontSelection {
	return FontSelectionNewFromC(object.ToC())
}

// Creates a new #GtkFontSelection.
/*

C function : gtk_font_selection_new
*/
func FontSelectionNew() *FontSelection {
	retC := C.gtk_font_selection_new()
	retGo := FontSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk_font_selection_set_font_name(), as the font selection widget may
// normalize font names and thus return a string with a different structure.
// For example, Helvetica Italic Bold 12 could be normalized to
// Helvetica Bold Italic 12. Use pango_font_description_equal()
// if you want to compare two font descriptions.
/*

C function : gtk_font_selection_get_font_name
*/
func (recv *FontSelection) GetFontName() string {
	retC := C.gtk_font_selection_get_font_name((*C.GtkFontSelection)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Gets the text displayed in the preview area.
/*

C function : gtk_font_selection_get_preview_text
*/
func (recv *FontSelection) GetPreviewText() string {
	retC := C.gtk_font_selection_get_preview_text((*C.GtkFontSelection)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Sets the currently-selected font.
//
// Note that the @fontsel needs to know the screen in which it will appear
// for this to work; this can be guaranteed by simply making sure that the
// @fontsel is inserted in a toplevel window before you call this function.
/*

C function : gtk_font_selection_set_font_name
*/
func (recv *FontSelection) SetFontName(fontname string) bool {
	c_fontname := C.CString(fontname)
	defer C.free(unsafe.Pointer(c_fontname))

	retC := C.gtk_font_selection_set_font_name((*C.GtkFontSelection)(recv.native), c_fontname)
	retGo := retC == C.TRUE

	return retGo
}

// Sets the text displayed in the preview area.
// The @text is used to show how the selected font looks.
/*

C function : gtk_font_selection_set_preview_text
*/
func (recv *FontSelection) SetPreviewText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_font_selection_set_preview_text((*C.GtkFontSelection)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by FontSelection
func (recv *FontSelection) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontSelection
func (recv *FontSelection) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FontSelection
func (recv *FontSelection) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkFontSelectionDialog
*/
type FontSelectionDialog struct {
	native *C.GtkFontSelectionDialog
	// parent_instance : record
	// Private : priv
}

func FontSelectionDialogNewFromC(u unsafe.Pointer) *FontSelectionDialog {
	c := (*C.GtkFontSelectionDialog)(u)
	if c == nil {
		return nil
	}

	g := &FontSelectionDialog{native: c}

	return g
}

func (recv *FontSelectionDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *FontSelectionDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FontSelectionDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FontSelectionDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FontSelectionDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FontSelectionDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontSelectionDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontSelectionDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to FontSelectionDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontSelectionDialog.
func CastToFontSelectionDialog(object *gobject.Object) *FontSelectionDialog {
	return FontSelectionDialogNewFromC(object.ToC())
}

// Creates a new #GtkFontSelectionDialog.
/*

C function : gtk_font_selection_dialog_new
*/
func FontSelectionDialogNew(title string) *FontSelectionDialog {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	retC := C.gtk_font_selection_dialog_new(c_title)
	retGo := FontSelectionDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk_font_selection_dialog_set_font_name(), as the font selection widget
// may normalize font names and thus return a string with a different
// structure. For example, Helvetica Italic Bold 12 could be normalized
// to Helvetica Bold Italic 12.  Use pango_font_description_equal()
// if you want to compare two font descriptions.
/*

C function : gtk_font_selection_dialog_get_font_name
*/
func (recv *FontSelectionDialog) GetFontName() string {
	retC := C.gtk_font_selection_dialog_get_font_name((*C.GtkFontSelectionDialog)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Gets the text displayed in the preview area.
/*

C function : gtk_font_selection_dialog_get_preview_text
*/
func (recv *FontSelectionDialog) GetPreviewText() string {
	retC := C.gtk_font_selection_dialog_get_preview_text((*C.GtkFontSelectionDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Sets the currently selected font.
/*

C function : gtk_font_selection_dialog_set_font_name
*/
func (recv *FontSelectionDialog) SetFontName(fontname string) bool {
	c_fontname := C.CString(fontname)
	defer C.free(unsafe.Pointer(c_fontname))

	retC := C.gtk_font_selection_dialog_set_font_name((*C.GtkFontSelectionDialog)(recv.native), c_fontname)
	retGo := retC == C.TRUE

	return retGo
}

// Sets the text displayed in the preview area.
/*

C function : gtk_font_selection_dialog_set_preview_text
*/
func (recv *FontSelectionDialog) SetPreviewText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_font_selection_dialog_set_preview_text((*C.GtkFontSelectionDialog)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by FontSelectionDialog
func (recv *FontSelectionDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontSelectionDialog
func (recv *FontSelectionDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The frame widget is a bin that surrounds its child with a decorative
// frame and an optional label. If present, the label is drawn in a gap
// in the top side of the frame. The position of the label can be
// controlled with gtk_frame_set_label_align().
//
// # GtkFrame as GtkBuildable
//
// The GtkFrame implementation of the GtkBuildable interface supports
// placing a child in the label position by specifying label as the
// type attribute of a <child> element. A normal content child can
// be specified without specifying a <child> type attribute.
//
// An example of a UI definition fragment with GtkFrame:
// |[
// <object class="GtkFrame">
// <child type="label">
// <object class="GtkLabel" id="frame-label"/>
// </child>
// <child>
// <object class="GtkEntry" id="frame-content"/>
// </child>
// </object>
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// frame
//  border[.flat]
//  <label widget>
//  <child>
// ]|
//
// GtkFrame has a main CSS node named frame and a subnode named border. The
// border node is used to draw the visible border. You can set the appearance
// of the border using CSS properties like border-style on the border node.
//
// The border node can be given the style class .flat, which is used by themes
// to disable drawing of the border. To do this from code, call
// gtk_frame_set_shadow_type() with %GTK_SHADOW_NONE to add the .flat class or
// any other shadow type to remove it.
/*

C record/class : GtkFrame
*/
type Frame struct {
	native *C.GtkFrame
	// bin : record
	// Private : priv
}

func FrameNewFromC(u unsafe.Pointer) *Frame {
	c := (*C.GtkFrame)(u)
	if c == nil {
		return nil
	}

	g := &Frame{native: c}

	return g
}

func (recv *Frame) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Frame) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Frame) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Frame) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Frame) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Frame) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Frame.
// Exercise care, as this is a potentially dangerous function if the Object is not a Frame.
func CastToFrame(object *gobject.Object) *Frame {
	return FrameNewFromC(object.ToC())
}

// Creates a new #GtkFrame, with optional label @label.
// If @label is %NULL, the label is omitted.
/*

C function : gtk_frame_new
*/
func FrameNew(label string) *Frame {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_frame_new(c_label)
	retGo := FrameNewFromC(unsafe.Pointer(retC))

	return retGo
}

// If the frames label widget is a #GtkLabel, returns the
// text in the label widget. (The frame will have a #GtkLabel
// for the label widget if a non-%NULL argument was passed
// to gtk_frame_new().)
/*

C function : gtk_frame_get_label
*/
func (recv *Frame) GetLabel() string {
	retC := C.gtk_frame_get_label((*C.GtkFrame)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Retrieves the X and Y alignment of the frames label. See
// gtk_frame_set_label_align().
/*

C function : gtk_frame_get_label_align
*/
func (recv *Frame) GetLabelAlign() (float32, float32) {
	var c_xalign C.gfloat

	var c_yalign C.gfloat

	C.gtk_frame_get_label_align((*C.GtkFrame)(recv.native), &c_xalign, &c_yalign)

	xalign := (float32)(c_xalign)

	yalign := (float32)(c_yalign)

	return xalign, yalign
}

// Retrieves the label widget for the frame. See
// gtk_frame_set_label_widget().
/*

C function : gtk_frame_get_label_widget
*/
func (recv *Frame) GetLabelWidget() *Widget {
	retC := C.gtk_frame_get_label_widget((*C.GtkFrame)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the shadow type of the frame. See
// gtk_frame_set_shadow_type().
/*

C function : gtk_frame_get_shadow_type
*/
func (recv *Frame) GetShadowType() ShadowType {
	retC := C.gtk_frame_get_shadow_type((*C.GtkFrame)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// Removes the current #GtkFrame:label-widget. If @label is not %NULL, creates a
// new #GtkLabel with that text and adds it as the #GtkFrame:label-widget.
/*

C function : gtk_frame_set_label
*/
func (recv *Frame) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_frame_set_label((*C.GtkFrame)(recv.native), c_label)

	return
}

// Sets the alignment of the frame widgets label. The
// default values for a newly created frame are 0.0 and 0.5.
/*

C function : gtk_frame_set_label_align
*/
func (recv *Frame) SetLabelAlign(xalign float32, yalign float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	C.gtk_frame_set_label_align((*C.GtkFrame)(recv.native), c_xalign, c_yalign)

	return
}

// Sets the #GtkFrame:label-widget for the frame. This is the widget that
// will appear embedded in the top edge of the frame as a title.
/*

C function : gtk_frame_set_label_widget
*/
func (recv *Frame) SetLabelWidget(labelWidget *Widget) {
	c_label_widget := (*C.GtkWidget)(C.NULL)
	if labelWidget != nil {
		c_label_widget = (*C.GtkWidget)(labelWidget.ToC())
	}

	C.gtk_frame_set_label_widget((*C.GtkFrame)(recv.native), c_label_widget)

	return
}

// Sets the #GtkFrame:shadow-type for @frame, i.e. whether it is drawn without
// (%GTK_SHADOW_NONE) or with (other values) a visible border. Values other than
// %GTK_SHADOW_NONE are treated identically by GtkFrame. The chosen type is
// applied by removing or adding the .flat class to the CSS node named border.
/*

C function : gtk_frame_set_shadow_type
*/
func (recv *Frame) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_frame_set_shadow_type((*C.GtkFrame)(recv.native), c_type)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Frame
func (recv *Frame) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Frame
func (recv *Frame) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkFrameAccessible
*/
type FrameAccessible struct {
	native *C.GtkFrameAccessible
	// parent : record
	// priv : record
}

func FrameAccessibleNewFromC(u unsafe.Pointer) *FrameAccessible {
	c := (*C.GtkFrameAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FrameAccessible{native: c}

	return g
}

func (recv *FrameAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FrameAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FrameAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FrameAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FrameAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to FrameAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FrameAccessible.
func CastToFrameAccessible(object *gobject.Object) *FrameAccessible {
	return FrameAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FrameAccessible
func (recv *FrameAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// #GtkGesture is the base object for gesture recognition, although this
// object is quite generalized to serve as a base for multi-touch gestures,
// it is suitable to implement single-touch and pointer-based gestures (using
// the special %NULL #GdkEventSequence value for these).
//
// The number of touches that a #GtkGesture need to be recognized is controlled
// by the #GtkGesture:n-points property, if a gesture is keeping track of less
// or more than that number of sequences, it won't check wether the gesture
// is recognized.
//
// As soon as the gesture has the expected number of touches, the gesture will
// run the #GtkGesture::check signal regularly on input events until the gesture
// is recognized, the criteria to consider a gesture as "recognized" is left to
// #GtkGesture subclasses.
//
// A recognized gesture will then emit the following signals:
// - #GtkGesture::begin when the gesture is recognized.
// - A number of #GtkGesture::update, whenever an input event is processed.
// - #GtkGesture::end when the gesture is no longer recognized.
//
// ## Event propagation
//
// In order to receive events, a gesture needs to either set a propagation phase
// through gtk_event_controller_set_propagation_phase(), or feed those manually
// through gtk_event_controller_handle_event().
//
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
//
// After the capture phase, GTK+ emits the traditional #GtkWidget::button-press-event,
// #GtkWidget::button-release-event, #GtkWidget::touch-event, etc signals. Gestures
// with the %GTK_PHASE_TARGET phase are fed events from the default #GtkWidget::event
// handlers.
//
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get
// a chance to interact with events that have not been handled yet.
//
// ## States of a sequence # {#touch-sequence-states}
//
// Whenever input interaction happens, a single event may trigger a cascade of
// #GtkGestures, both across the parents of the widget receiving the event and
// in parallel within an individual widget. It is a responsibility of the
// widgets using those gestures to set the state of touch sequences accordingly
// in order to enable cooperation of gestures around the #GdkEventSequences
// triggering those.
//
// Within a widget, gestures can be grouped through gtk_gesture_group(),
// grouped gestures synchronize the state of sequences, so calling
// gtk_gesture_set_sequence_state() on one will effectively propagate
// the state throughout the group.
//
// By default, all sequences start out in the #GTK_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
//
// If a sequence enters into the #GTK_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while
// the touch is active.
//
// If a sequence enters in the #GTK_EVENT_SEQUENCE_CLAIMED state, the gesture
// group will grab all interaction on the sequence, by:
// - Setting the same sequence to #GTK_EVENT_SEQUENCE_DENIED on every other gesture
// group within the widget, and every gesture on parent widgets in the propagation
// chain.
// - calling #GtkGesture::cancel on every gesture in widgets underneath in the
// propagation chain.
// - Stopping event propagation after the gesture group handles the event.
//
// Note: if a sequence is set early to #GTK_EVENT_SEQUENCE_CLAIMED on
// #GDK_TOUCH_BEGIN/#GDK_BUTTON_PRESS (so those events are captured before
// reaching the event widget, this implies #GTK_PHASE_CAPTURE), one similar
// event will emulated if the sequence changes to #GTK_EVENT_SEQUENCE_DENIED.
// This way event coherence is preserved before event propagation is unstopped
// again.
//
// Sequence states can't be changed freely, see gtk_gesture_set_sequence_state()
// to know about the possible lifetimes of a #GdkEventSequence.
//
// ## Touchpad gestures
//
// On the platforms that support it, #GtkGesture will handle transparently
// touchpad gesture events. The only precautions users of #GtkGesture should do
// to enable this support are:
// - Enabling %GDK_TOUCHPAD_GESTURE_MASK on their #GdkWindows
// - If the gesture has %GTK_PHASE_NONE, ensuring events of type
// %GDK_TOUCHPAD_SWIPE and %GDK_TOUCHPAD_PINCH are handled by the #GtkGesture
/*

C record/class : GtkGesture
*/
type Gesture struct {
	native *C.GtkGesture
}

func GestureNewFromC(u unsafe.Pointer) *Gesture {
	c := (*C.GtkGesture)(u)
	if c == nil {
		return nil
	}

	g := &Gesture{native: c}

	return g
}

func (recv *Gesture) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// EventController upcasts to *EventController
func (recv *Gesture) EventController() *EventController {
	return EventControllerNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Gesture) Object() *gobject.Object {
	return recv.EventController().Object()
}

// CastToWidget down casts any arbitary Object to Gesture.
// Exercise care, as this is a potentially dangerous function if the Object is not a Gesture.
func CastToGesture(object *gobject.Object) *Gesture {
	return GestureNewFromC(object.ToC())
}

// Unsupported : gtk_gesture_get_last_event : no return generator

// #GtkGestureDrag is a #GtkGesture implementation that recognizes drag
// operations. The drag operation itself can be tracked throught the
// #GtkGestureDrag::drag-begin, #GtkGestureDrag::drag-update and
// #GtkGestureDrag::drag-end signals, or the relevant coordinates be
// extracted through gtk_gesture_drag_get_offset() and
// gtk_gesture_drag_get_start_point().
/*

C record/class : GtkGestureDrag
*/
type GestureDrag struct {
	native *C.GtkGestureDrag
}

func GestureDragNewFromC(u unsafe.Pointer) *GestureDrag {
	c := (*C.GtkGestureDrag)(u)
	if c == nil {
		return nil
	}

	g := &GestureDrag{native: c}

	return g
}

func (recv *GestureDrag) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureDrag) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureDrag) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureDrag) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureDrag) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitary Object to GestureDrag.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureDrag.
func CastToGestureDrag(object *gobject.Object) *GestureDrag {
	return GestureDragNewFromC(object.ToC())
}

// #GtkGestureLongPress is a #GtkGesture implementation able to recognize
// long presses, triggering the #GtkGestureLongPress::pressed after the
// timeout is exceeded.
//
// If the touchpoint is lifted before the timeout passes, or if it drifts
// too far of the initial press point, the #GtkGestureLongPress::cancelled
// signal will be emitted.
/*

C record/class : GtkGestureLongPress
*/
type GestureLongPress struct {
	native *C.GtkGestureLongPress
}

func GestureLongPressNewFromC(u unsafe.Pointer) *GestureLongPress {
	c := (*C.GtkGestureLongPress)(u)
	if c == nil {
		return nil
	}

	g := &GestureLongPress{native: c}

	return g
}

func (recv *GestureLongPress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureLongPress) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureLongPress) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureLongPress) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureLongPress) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitary Object to GestureLongPress.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureLongPress.
func CastToGestureLongPress(object *gobject.Object) *GestureLongPress {
	return GestureLongPressNewFromC(object.ToC())
}

// #GtkGestureMultiPress is a #GtkGesture implementation able to recognize
// multiple clicks on a nearby zone, which can be listened for through the
// #GtkGestureMultiPress::pressed signal. Whenever time or distance between
// clicks exceed the GTK+ defaults, #GtkGestureMultiPress::stopped is emitted,
// and the click counter is reset.
//
// Callers may also restrict the area that is considered valid for a >1
// touch/button press through gtk_gesture_multi_press_set_area(), so any
// click happening outside that area is considered to be a first click of
// its own.
/*

C record/class : GtkGestureMultiPress
*/
type GestureMultiPress struct {
	native *C.GtkGestureMultiPress
}

func GestureMultiPressNewFromC(u unsafe.Pointer) *GestureMultiPress {
	c := (*C.GtkGestureMultiPress)(u)
	if c == nil {
		return nil
	}

	g := &GestureMultiPress{native: c}

	return g
}

func (recv *GestureMultiPress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureMultiPress) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureMultiPress) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureMultiPress) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureMultiPress) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitary Object to GestureMultiPress.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureMultiPress.
func CastToGestureMultiPress(object *gobject.Object) *GestureMultiPress {
	return GestureMultiPressNewFromC(object.ToC())
}

// #GtkGesturePan is a #GtkGesture implementation able to recognize
// pan gestures, those are drags that are locked to happen along one
// axis. The axis that a #GtkGesturePan handles is defined at
// construct time, and can be changed through
// gtk_gesture_pan_set_orientation().
//
// When the gesture starts to be recognized, #GtkGesturePan will
// attempt to determine as early as possible whether the sequence
// is moving in the expected direction, and denying the sequence if
// this does not happen.
//
// Once a panning gesture along the expected axis is recognized,
// the #GtkGesturePan::pan signal will be emitted as input events
// are received, containing the offset in the given axis.
/*

C record/class : GtkGesturePan
*/
type GesturePan struct {
	native *C.GtkGesturePan
}

func GesturePanNewFromC(u unsafe.Pointer) *GesturePan {
	c := (*C.GtkGesturePan)(u)
	if c == nil {
		return nil
	}

	g := &GesturePan{native: c}

	return g
}

func (recv *GesturePan) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureDrag upcasts to *GestureDrag
func (recv *GesturePan) GestureDrag() *GestureDrag {
	return GestureDragNewFromC(unsafe.Pointer(recv.native))
}

// GestureSingle upcasts to *GestureSingle
func (recv *GesturePan) GestureSingle() *GestureSingle {
	return recv.GestureDrag().GestureSingle()
}

// Gesture upcasts to *Gesture
func (recv *GesturePan) Gesture() *Gesture {
	return recv.GestureDrag().Gesture()
}

// EventController upcasts to *EventController
func (recv *GesturePan) EventController() *EventController {
	return recv.GestureDrag().EventController()
}

// Object upcasts to *Object
func (recv *GesturePan) Object() *gobject.Object {
	return recv.GestureDrag().Object()
}

// CastToWidget down casts any arbitary Object to GesturePan.
// Exercise care, as this is a potentially dangerous function if the Object is not a GesturePan.
func CastToGesturePan(object *gobject.Object) *GesturePan {
	return GesturePanNewFromC(object.ToC())
}

// #GtkGestureRotate is a #GtkGesture implementation able to recognize
// 2-finger rotations, whenever the angle between both handled sequences
// changes, the #GtkGestureRotate::angle-changed signal is emitted.
/*

C record/class : GtkGestureRotate
*/
type GestureRotate struct {
	native *C.GtkGestureRotate
}

func GestureRotateNewFromC(u unsafe.Pointer) *GestureRotate {
	c := (*C.GtkGestureRotate)(u)
	if c == nil {
		return nil
	}

	g := &GestureRotate{native: c}

	return g
}

func (recv *GestureRotate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Gesture upcasts to *Gesture
func (recv *GestureRotate) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureRotate) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureRotate) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitary Object to GestureRotate.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureRotate.
func CastToGestureRotate(object *gobject.Object) *GestureRotate {
	return GestureRotateNewFromC(object.ToC())
}

// #GtkGestureSingle is a subclass of #GtkGesture, optimized (although
// not restricted) for dealing with mouse and single-touch gestures. Under
// interaction, these gestures stick to the first interacting sequence, which
// is accessible through gtk_gesture_single_get_current_sequence() while the
// gesture is being interacted with.
//
// By default gestures react to both %GDK_BUTTON_PRIMARY and touch
// events, gtk_gesture_single_set_touch_only() can be used to change the
// touch behavior. Callers may also specify a different mouse button number
// to interact with through gtk_gesture_single_set_button(), or react to any
// mouse button by setting 0. While the gesture is active, the button being
// currently pressed can be known through gtk_gesture_single_get_current_button().
/*

C record/class : GtkGestureSingle
*/
type GestureSingle struct {
	native *C.GtkGestureSingle
}

func GestureSingleNewFromC(u unsafe.Pointer) *GestureSingle {
	c := (*C.GtkGestureSingle)(u)
	if c == nil {
		return nil
	}

	g := &GestureSingle{native: c}

	return g
}

func (recv *GestureSingle) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Gesture upcasts to *Gesture
func (recv *GestureSingle) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureSingle) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureSingle) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitary Object to GestureSingle.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureSingle.
func CastToGestureSingle(object *gobject.Object) *GestureSingle {
	return GestureSingleNewFromC(object.ToC())
}

// #GtkGestureSwipe is a #GtkGesture implementation able to recognize
// swipes, after a press/move/.../move/release sequence happens, the
// #GtkGestureSwipe::swipe signal will be emitted, providing the velocity
// and directionality of the sequence at the time it was lifted.
//
// If the velocity is desired in intermediate points,
// gtk_gesture_swipe_get_velocity() can be called on eg. a
// #GtkGesture::update handler.
//
// All velocities are reported in pixels/sec units.
/*

C record/class : GtkGestureSwipe
*/
type GestureSwipe struct {
	native *C.GtkGestureSwipe
}

func GestureSwipeNewFromC(u unsafe.Pointer) *GestureSwipe {
	c := (*C.GtkGestureSwipe)(u)
	if c == nil {
		return nil
	}

	g := &GestureSwipe{native: c}

	return g
}

func (recv *GestureSwipe) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureSwipe) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureSwipe) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureSwipe) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureSwipe) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitary Object to GestureSwipe.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureSwipe.
func CastToGestureSwipe(object *gobject.Object) *GestureSwipe {
	return GestureSwipeNewFromC(object.ToC())
}

// #GtkGestureZoom is a #GtkGesture implementation able to recognize
// pinch/zoom gestures, whenever the distance between both tracked
// sequences changes, the #GtkGestureZoom::scale-changed signal is
// emitted to report the scale factor.
/*

C record/class : GtkGestureZoom
*/
type GestureZoom struct {
	native *C.GtkGestureZoom
}

func GestureZoomNewFromC(u unsafe.Pointer) *GestureZoom {
	c := (*C.GtkGestureZoom)(u)
	if c == nil {
		return nil
	}

	g := &GestureZoom{native: c}

	return g
}

func (recv *GestureZoom) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Gesture upcasts to *Gesture
func (recv *GestureZoom) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureZoom) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureZoom) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitary Object to GestureZoom.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureZoom.
func CastToGestureZoom(object *gobject.Object) *GestureZoom {
	return GestureZoomNewFromC(object.ToC())
}

// GtkGrid is a container which arranges its child widgets in
// rows and columns. It is a very similar to #GtkTable and #GtkBox,
// but it consistently uses #GtkWidgets #GtkWidget:margin and #GtkWidget:expand
// properties instead of custom child properties, and it fully supports
// [height-for-width geometry management][geometry-management].
//
// Children are added using gtk_grid_attach(). They can span multiple
// rows or columns. It is also possible to add a child next to an
// existing child, using gtk_grid_attach_next_to(). The behaviour of
// GtkGrid when several children occupy the same grid cell is undefined.
//
// GtkGrid can be used like a #GtkBox by just using gtk_container_add(),
// which will place children next to each other in the direction determined
// by the #GtkOrientable:orientation property.
//
// # CSS nodes
//
// GtkGrid uses a single CSS node with name grid.
/*

C record/class : GtkGrid
*/
type Grid struct {
	native *C.GtkGrid
	// Private : container
	// Private : priv
}

func GridNewFromC(u unsafe.Pointer) *Grid {
	c := (*C.GtkGrid)(u)
	if c == nil {
		return nil
	}

	g := &Grid{native: c}

	return g
}

func (recv *Grid) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Grid) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Grid) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Grid) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Grid) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Grid.
// Exercise care, as this is a potentially dangerous function if the Object is not a Grid.
func CastToGrid(object *gobject.Object) *Grid {
	return GridNewFromC(object.ToC())
}

// Creates a new grid widget.
/*

C function : gtk_grid_new
*/
func GridNew() *Grid {
	retC := C.gtk_grid_new()
	retGo := GridNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a widget to the grid.
//
// The position of @child is determined by @left and @top. The
// number of cells that @child will occupy is determined by
// @width and @height.
/*

C function : gtk_grid_attach
*/
func (recv *Grid) Attach(child *Widget, left int32, top int32, width int32, height int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_left := (C.gint)(left)

	c_top := (C.gint)(top)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_grid_attach((*C.GtkGrid)(recv.native), c_child, c_left, c_top, c_width, c_height)

	return
}

// Adds a widget to the grid.
//
// The widget is placed next to @sibling, on the side determined by
// @side. When @sibling is %NULL, the widget is placed in row (for
// left or right placement) or column 0 (for top or bottom placement),
// at the end indicated by @side.
//
// Attaching widgets labeled [1], [2], [3] with @sibling == %NULL and
// @side == %GTK_POS_LEFT yields a layout of [3][2][1].
/*

C function : gtk_grid_attach_next_to
*/
func (recv *Grid) AttachNextTo(child *Widget, sibling *Widget, side PositionType, width int32, height int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_sibling := (*C.GtkWidget)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkWidget)(sibling.ToC())
	}

	c_side := (C.GtkPositionType)(side)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_grid_attach_next_to((*C.GtkGrid)(recv.native), c_child, c_sibling, c_side, c_width, c_height)

	return
}

// Returns whether all columns of @grid have the same width.
/*

C function : gtk_grid_get_column_homogeneous
*/
func (recv *Grid) GetColumnHomogeneous() bool {
	retC := C.gtk_grid_get_column_homogeneous((*C.GtkGrid)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the amount of space between the columns of @grid.
/*

C function : gtk_grid_get_column_spacing
*/
func (recv *Grid) GetColumnSpacing() uint32 {
	retC := C.gtk_grid_get_column_spacing((*C.GtkGrid)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Returns whether all rows of @grid have the same height.
/*

C function : gtk_grid_get_row_homogeneous
*/
func (recv *Grid) GetRowHomogeneous() bool {
	retC := C.gtk_grid_get_row_homogeneous((*C.GtkGrid)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the amount of space between the rows of @grid.
/*

C function : gtk_grid_get_row_spacing
*/
func (recv *Grid) GetRowSpacing() uint32 {
	retC := C.gtk_grid_get_row_spacing((*C.GtkGrid)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Sets whether all columns of @grid will have the same width.
/*

C function : gtk_grid_set_column_homogeneous
*/
func (recv *Grid) SetColumnHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_grid_set_column_homogeneous((*C.GtkGrid)(recv.native), c_homogeneous)

	return
}

// Sets the amount of space between columns of @grid.
/*

C function : gtk_grid_set_column_spacing
*/
func (recv *Grid) SetColumnSpacing(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_grid_set_column_spacing((*C.GtkGrid)(recv.native), c_spacing)

	return
}

// Sets whether all rows of @grid will have the same height.
/*

C function : gtk_grid_set_row_homogeneous
*/
func (recv *Grid) SetRowHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_grid_set_row_homogeneous((*C.GtkGrid)(recv.native), c_homogeneous)

	return
}

// Sets the amount of space between rows of @grid.
/*

C function : gtk_grid_set_row_spacing
*/
func (recv *Grid) SetRowSpacing(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_grid_set_row_spacing((*C.GtkGrid)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Grid
func (recv *Grid) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Grid
func (recv *Grid) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Grid
func (recv *Grid) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// #GtkHBox is a container that organizes child widgets into a single row.
//
// Use the #GtkBox packing interface to determine the arrangement,
// spacing, width, and alignment of #GtkHBox children.
//
// All children are allocated the same height.
//
// GtkHBox has been deprecated. You can use #GtkBox instead, which is a
// very quick and easychange. If you have derived your own classes from
// GtkHBox, you can simply change the inheritance to derive directly
// from #GtkBox. No further changes are needed, since the default
// value of the #GtkOrientable:orientation property is
// %GTK_ORIENTATION_HORIZONTAL.
// If you dont need first-child or last-child styling, and want your code
// to be future-proof, the recommendation is to switch to #GtkGrid instead
// of nested boxes. For more information about migrating to #GtkGrid,
// see [Migrating from other containers to GtkGrid][gtk-migrating-GtkGrid].
/*

C record/class : GtkHBox
*/
type HBox struct {
	native *C.GtkHBox
	// box : record
}

func HBoxNewFromC(u unsafe.Pointer) *HBox {
	c := (*C.GtkHBox)(u)
	if c == nil {
		return nil
	}

	g := &HBox{native: c}

	return g
}

func (recv *HBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *HBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *HBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to HBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HBox.
func CastToHBox(object *gobject.Object) *HBox {
	return HBoxNewFromC(object.ToC())
}

// Creates a new #GtkHBox.
/*

C function : gtk_hbox_new
*/
func HBoxNew(homogeneous bool, spacing int32) *HBox {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	c_spacing := (C.gint)(spacing)

	retC := C.gtk_hbox_new(c_homogeneous, c_spacing)
	retGo := HBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HBox
func (recv *HBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HBox
func (recv *HBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HBox
func (recv *HBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkHButtonBox
*/
type HButtonBox struct {
	native *C.GtkHButtonBox
	// button_box : record
}

func HButtonBoxNewFromC(u unsafe.Pointer) *HButtonBox {
	c := (*C.GtkHButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &HButtonBox{native: c}

	return g
}

func (recv *HButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonBox upcasts to *ButtonBox
func (recv *HButtonBox) ButtonBox() *ButtonBox {
	return ButtonBoxNewFromC(unsafe.Pointer(recv.native))
}

// Box upcasts to *Box
func (recv *HButtonBox) Box() *Box {
	return recv.ButtonBox().Box()
}

// Container upcasts to *Container
func (recv *HButtonBox) Container() *Container {
	return recv.ButtonBox().Container()
}

// Widget upcasts to *Widget
func (recv *HButtonBox) Widget() *Widget {
	return recv.ButtonBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ButtonBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HButtonBox) Object() *gobject.Object {
	return recv.ButtonBox().Object()
}

// CastToWidget down casts any arbitary Object to HButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HButtonBox.
func CastToHButtonBox(object *gobject.Object) *HButtonBox {
	return HButtonBoxNewFromC(object.ToC())
}

// Creates a new horizontal button box.
/*

C function : gtk_hbutton_box_new
*/
func HButtonBoxNew() *HButtonBox {
	retC := C.gtk_hbutton_box_new()
	retGo := HButtonBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HButtonBox
func (recv *HButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HButtonBox
func (recv *HButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HButtonBox
func (recv *HButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The HPaned widget is a container widget with two
// children arranged horizontally. The division between
// the two panes is adjustable by the user by dragging
// a handle. See #GtkPaned for details.
//
// GtkHPaned has been deprecated, use #GtkPaned instead.
/*

C record/class : GtkHPaned
*/
type HPaned struct {
	native *C.GtkHPaned
	// paned : record
}

func HPanedNewFromC(u unsafe.Pointer) *HPaned {
	c := (*C.GtkHPaned)(u)
	if c == nil {
		return nil
	}

	g := &HPaned{native: c}

	return g
}

func (recv *HPaned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Paned upcasts to *Paned
func (recv *HPaned) Paned() *Paned {
	return PanedNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HPaned) Container() *Container {
	return recv.Paned().Container()
}

// Widget upcasts to *Widget
func (recv *HPaned) Widget() *Widget {
	return recv.Paned().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HPaned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Paned().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HPaned) Object() *gobject.Object {
	return recv.Paned().Object()
}

// CastToWidget down casts any arbitary Object to HPaned.
// Exercise care, as this is a potentially dangerous function if the Object is not a HPaned.
func CastToHPaned(object *gobject.Object) *HPaned {
	return HPanedNewFromC(object.ToC())
}

// Create a new #GtkHPaned
/*

C function : gtk_hpaned_new
*/
func HPanedNew() *HPaned {
	retC := C.gtk_hpaned_new()
	retGo := HPanedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HPaned
func (recv *HPaned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HPaned
func (recv *HPaned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HPaned
func (recv *HPaned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// #GtkHSV is the color wheel part of a complete color selector widget.
// It allows to select a color by determining its HSV components in an
// intuitive way. Moving the selection around the outer ring changes the hue,
// and moving the selection point inside the inner triangle changes value and
// saturation.
//
// #GtkHSV has been deprecated together with #GtkColorSelection, where
// it was used.
/*

C record/class : GtkHSV
*/
type HSV struct {
	native *C.GtkHSV
	// parent_instance : record
	// Private : priv
}

func HSVNewFromC(u unsafe.Pointer) *HSV {
	c := (*C.GtkHSV)(u)
	if c == nil {
		return nil
	}

	g := &HSV{native: c}

	return g
}

func (recv *HSV) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *HSV) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HSV) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HSV) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to HSV.
// Exercise care, as this is a potentially dangerous function if the Object is not a HSV.
func CastToHSV(object *gobject.Object) *HSV {
	return HSVNewFromC(object.ToC())
}

type signalHSVChangedDetail struct {
	callback  HSVSignalChangedCallback
	handlerID C.gulong
}

var signalHSVChangedId int
var signalHSVChangedMap = make(map[int]signalHSVChangedDetail)
var signalHSVChangedLock sync.Mutex

// HSVSignalChangedCallback is a callback function for a 'changed' signal emitted from a HSV.
type HSVSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the HSV.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *HSV) ConnectChanged(callback HSVSignalChangedCallback) int {
	signalHSVChangedLock.Lock()
	defer signalHSVChangedLock.Unlock()

	signalHSVChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HSV_signal_connect_changed(instance, C.gpointer(uintptr(signalHSVChangedId)))

	detail := signalHSVChangedDetail{callback, handlerID}
	signalHSVChangedMap[signalHSVChangedId] = detail

	return signalHSVChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the HSV.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *HSV) DisconnectChanged(connectionID int) {
	signalHSVChangedLock.Lock()
	defer signalHSVChangedLock.Unlock()

	detail, exists := signalHSVChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHSVChangedMap, connectionID)
}

//export hsv_changedHandler
func hsv_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalHSVChangedMap[index].callback
	callback()
}

// Unsupported signal 'move' for HSV : unsupported parameter object : type DirectionType :

// ImplementorIface returns the ImplementorIface interface implemented by HSV
func (recv *HSV) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HSV
func (recv *HSV) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkHScale widget is used to allow the user to select a value using
// a horizontal slider. To create one, use gtk_hscale_new_with_range().
//
// The position to show the current value, and the number of decimal places
// shown can be set using the parent #GtkScale classs functions.
//
// GtkHScale has been deprecated, use #GtkScale instead.
/*

C record/class : GtkHScale
*/
type HScale struct {
	native *C.GtkHScale
	// scale : record
}

func HScaleNewFromC(u unsafe.Pointer) *HScale {
	c := (*C.GtkHScale)(u)
	if c == nil {
		return nil
	}

	g := &HScale{native: c}

	return g
}

func (recv *HScale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Scale upcasts to *Scale
func (recv *HScale) Scale() *Scale {
	return ScaleNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *HScale) Range() *Range {
	return recv.Scale().Range()
}

// Widget upcasts to *Widget
func (recv *HScale) Widget() *Widget {
	return recv.Scale().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HScale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scale().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HScale) Object() *gobject.Object {
	return recv.Scale().Object()
}

// CastToWidget down casts any arbitary Object to HScale.
// Exercise care, as this is a potentially dangerous function if the Object is not a HScale.
func CastToHScale(object *gobject.Object) *HScale {
	return HScaleNewFromC(object.ToC())
}

// Creates a new #GtkHScale.
/*

C function : gtk_hscale_new
*/
func HScaleNew(adjustment *Adjustment) *HScale {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_hscale_new(c_adjustment)
	retGo := HScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new horizontal scale widget that lets the user input a
// number between @min and @max (including @min and @max) with the
// increment @step.  @step must be nonzero; its the distance the
// slider moves when using the arrow keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if @step
// is a power of ten. If the resulting precision is not suitable for your
// needs, use gtk_scale_set_digits() to correct it.
/*

C function : gtk_hscale_new_with_range
*/
func HScaleNewWithRange(min float64, max float64, step float64) *HScale {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_hscale_new_with_range(c_min, c_max, c_step)
	retGo := HScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HScale
func (recv *HScale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HScale
func (recv *HScale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HScale
func (recv *HScale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkHScrollbar widget is a widget arranged horizontally creating a
// scrollbar. See #GtkScrollbar for details on
// scrollbars. #GtkAdjustment pointers may be added to handle the
// adjustment of the scrollbar or it may be left %NULL in which case one
// will be created for you. See #GtkScrollbar for a description of what the
// fields in an adjustment represent for a scrollbar.
//
// GtkHScrollbar has been deprecated, use #GtkScrollbar instead.
/*

C record/class : GtkHScrollbar
*/
type HScrollbar struct {
	native *C.GtkHScrollbar
	// scrollbar : record
}

func HScrollbarNewFromC(u unsafe.Pointer) *HScrollbar {
	c := (*C.GtkHScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &HScrollbar{native: c}

	return g
}

func (recv *HScrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Scrollbar upcasts to *Scrollbar
func (recv *HScrollbar) Scrollbar() *Scrollbar {
	return ScrollbarNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *HScrollbar) Range() *Range {
	return recv.Scrollbar().Range()
}

// Widget upcasts to *Widget
func (recv *HScrollbar) Widget() *Widget {
	return recv.Scrollbar().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HScrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scrollbar().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HScrollbar) Object() *gobject.Object {
	return recv.Scrollbar().Object()
}

// CastToWidget down casts any arbitary Object to HScrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a HScrollbar.
func CastToHScrollbar(object *gobject.Object) *HScrollbar {
	return HScrollbarNewFromC(object.ToC())
}

// Creates a new horizontal scrollbar.
/*

C function : gtk_hscrollbar_new
*/
func HScrollbarNew(adjustment *Adjustment) *HScrollbar {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_hscrollbar_new(c_adjustment)
	retGo := HScrollbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HScrollbar
func (recv *HScrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HScrollbar
func (recv *HScrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HScrollbar
func (recv *HScrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkHSeparator widget is a horizontal separator, used to group the
// widgets within a window. It displays a horizontal line with a shadow to
// make it appear sunken into the interface.
//
// > The #GtkHSeparator widget is not used as a separator within menus.
// > To create a separator in a menu create an empty #GtkSeparatorMenuItem
// > widget using gtk_separator_menu_item_new() and add it to the menu with
// > gtk_menu_shell_append().
//
// GtkHSeparator has been deprecated, use #GtkSeparator instead.
/*

C record/class : GtkHSeparator
*/
type HSeparator struct {
	native *C.GtkHSeparator
	// separator : record
}

func HSeparatorNewFromC(u unsafe.Pointer) *HSeparator {
	c := (*C.GtkHSeparator)(u)
	if c == nil {
		return nil
	}

	g := &HSeparator{native: c}

	return g
}

func (recv *HSeparator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Separator upcasts to *Separator
func (recv *HSeparator) Separator() *Separator {
	return SeparatorNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *HSeparator) Widget() *Widget {
	return recv.Separator().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HSeparator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Separator().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HSeparator) Object() *gobject.Object {
	return recv.Separator().Object()
}

// CastToWidget down casts any arbitary Object to HSeparator.
// Exercise care, as this is a potentially dangerous function if the Object is not a HSeparator.
func CastToHSeparator(object *gobject.Object) *HSeparator {
	return HSeparatorNewFromC(object.ToC())
}

// Creates a new #GtkHSeparator.
/*

C function : gtk_hseparator_new
*/
func HSeparatorNew() *HSeparator {
	retC := C.gtk_hseparator_new()
	retGo := HSeparatorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HSeparator
func (recv *HSeparator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HSeparator
func (recv *HSeparator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HSeparator
func (recv *HSeparator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkHandleBox widget allows a portion of a window to be "torn
// off". It is a bin widget which displays its child and a handle that
// the user can drag to tear off a separate window (the float
// window) containing the child widget. A thin
// ghost is drawn in the original location of the
// handlebox. By dragging the separate window back to its original
// location, it can be reattached.
//
// When reattaching, the ghost and float window, must be aligned
// along one of the edges, the snap edge.
// This either can be specified by the application programmer
// explicitly, or GTK+ will pick a reasonable default based
// on the handle position.
//
// To make detaching and reattaching the handlebox as minimally confusing
// as possible to the user, it is important to set the snap edge so that
// the snap edge does not move when the handlebox is deattached. For
// instance, if the handlebox is packed at the bottom of a VBox, then
// when the handlebox is detached, the bottom edge of the handlebox's
// allocation will remain fixed as the height of the handlebox shrinks,
// so the snap edge should be set to %GTK_POS_BOTTOM.
//
// > #GtkHandleBox has been deprecated. It is very specialized, lacks features
// > to make it useful and most importantly does not fit well into modern
// > application design. Do not use it. There is no replacement.
/*

C record/class : GtkHandleBox
*/
type HandleBox struct {
	native *C.GtkHandleBox
	// bin : record
	// Private : priv
}

func HandleBoxNewFromC(u unsafe.Pointer) *HandleBox {
	c := (*C.GtkHandleBox)(u)
	if c == nil {
		return nil
	}

	g := &HandleBox{native: c}

	return g
}

func (recv *HandleBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *HandleBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HandleBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *HandleBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HandleBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HandleBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to HandleBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HandleBox.
func CastToHandleBox(object *gobject.Object) *HandleBox {
	return HandleBoxNewFromC(object.ToC())
}

type signalHandleBoxChildAttachedDetail struct {
	callback  HandleBoxSignalChildAttachedCallback
	handlerID C.gulong
}

var signalHandleBoxChildAttachedId int
var signalHandleBoxChildAttachedMap = make(map[int]signalHandleBoxChildAttachedDetail)
var signalHandleBoxChildAttachedLock sync.Mutex

// HandleBoxSignalChildAttachedCallback is a callback function for a 'child-attached' signal emitted from a HandleBox.
type HandleBoxSignalChildAttachedCallback func(widget *Widget)

/*
ConnectChildAttached connects the callback to the 'child-attached' signal for the HandleBox.

The returned value represents the connection, and may be passed to DisconnectChildAttached to remove it.
*/
func (recv *HandleBox) ConnectChildAttached(callback HandleBoxSignalChildAttachedCallback) int {
	signalHandleBoxChildAttachedLock.Lock()
	defer signalHandleBoxChildAttachedLock.Unlock()

	signalHandleBoxChildAttachedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HandleBox_signal_connect_child_attached(instance, C.gpointer(uintptr(signalHandleBoxChildAttachedId)))

	detail := signalHandleBoxChildAttachedDetail{callback, handlerID}
	signalHandleBoxChildAttachedMap[signalHandleBoxChildAttachedId] = detail

	return signalHandleBoxChildAttachedId
}

/*
DisconnectChildAttached disconnects a callback from the 'child-attached' signal for the HandleBox.

The connectionID should be a value returned from a call to ConnectChildAttached.
*/
func (recv *HandleBox) DisconnectChildAttached(connectionID int) {
	signalHandleBoxChildAttachedLock.Lock()
	defer signalHandleBoxChildAttachedLock.Unlock()

	detail, exists := signalHandleBoxChildAttachedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHandleBoxChildAttachedMap, connectionID)
}

//export handlebox_childAttachedHandler
func handlebox_childAttachedHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalHandleBoxChildAttachedMap[index].callback
	callback(widget)
}

type signalHandleBoxChildDetachedDetail struct {
	callback  HandleBoxSignalChildDetachedCallback
	handlerID C.gulong
}

var signalHandleBoxChildDetachedId int
var signalHandleBoxChildDetachedMap = make(map[int]signalHandleBoxChildDetachedDetail)
var signalHandleBoxChildDetachedLock sync.Mutex

// HandleBoxSignalChildDetachedCallback is a callback function for a 'child-detached' signal emitted from a HandleBox.
type HandleBoxSignalChildDetachedCallback func(widget *Widget)

/*
ConnectChildDetached connects the callback to the 'child-detached' signal for the HandleBox.

The returned value represents the connection, and may be passed to DisconnectChildDetached to remove it.
*/
func (recv *HandleBox) ConnectChildDetached(callback HandleBoxSignalChildDetachedCallback) int {
	signalHandleBoxChildDetachedLock.Lock()
	defer signalHandleBoxChildDetachedLock.Unlock()

	signalHandleBoxChildDetachedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HandleBox_signal_connect_child_detached(instance, C.gpointer(uintptr(signalHandleBoxChildDetachedId)))

	detail := signalHandleBoxChildDetachedDetail{callback, handlerID}
	signalHandleBoxChildDetachedMap[signalHandleBoxChildDetachedId] = detail

	return signalHandleBoxChildDetachedId
}

/*
DisconnectChildDetached disconnects a callback from the 'child-detached' signal for the HandleBox.

The connectionID should be a value returned from a call to ConnectChildDetached.
*/
func (recv *HandleBox) DisconnectChildDetached(connectionID int) {
	signalHandleBoxChildDetachedLock.Lock()
	defer signalHandleBoxChildDetachedLock.Unlock()

	detail, exists := signalHandleBoxChildDetachedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHandleBoxChildDetachedMap, connectionID)
}

//export handlebox_childDetachedHandler
func handlebox_childDetachedHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalHandleBoxChildDetachedMap[index].callback
	callback(widget)
}

// Create a new handle box.
/*

C function : gtk_handle_box_new
*/
func HandleBoxNew() *HandleBox {
	retC := C.gtk_handle_box_new()
	retGo := HandleBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the handle position of the handle box. See
// gtk_handle_box_set_handle_position().
/*

C function : gtk_handle_box_get_handle_position
*/
func (recv *HandleBox) GetHandlePosition() PositionType {
	retC := C.gtk_handle_box_get_handle_position((*C.GtkHandleBox)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// Gets the type of shadow drawn around the handle box. See
// gtk_handle_box_set_shadow_type().
/*

C function : gtk_handle_box_get_shadow_type
*/
func (recv *HandleBox) GetShadowType() ShadowType {
	retC := C.gtk_handle_box_get_shadow_type((*C.GtkHandleBox)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// Gets the edge used for determining reattachment of the handle box.
// See gtk_handle_box_set_snap_edge().
/*

C function : gtk_handle_box_get_snap_edge
*/
func (recv *HandleBox) GetSnapEdge() PositionType {
	retC := C.gtk_handle_box_get_snap_edge((*C.GtkHandleBox)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// Sets the side of the handlebox where the handle is drawn.
/*

C function : gtk_handle_box_set_handle_position
*/
func (recv *HandleBox) SetHandlePosition(position PositionType) {
	c_position := (C.GtkPositionType)(position)

	C.gtk_handle_box_set_handle_position((*C.GtkHandleBox)(recv.native), c_position)

	return
}

// Sets the type of shadow to be drawn around the border
// of the handle box.
/*

C function : gtk_handle_box_set_shadow_type
*/
func (recv *HandleBox) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_handle_box_set_shadow_type((*C.GtkHandleBox)(recv.native), c_type)

	return
}

// Sets the snap edge of a handlebox. The snap edge is
// the edge of the detached child that must be aligned
// with the corresponding edge of the ghost left
// behind when the child was detached to reattach
// the torn-off window. Usually, the snap edge should
// be chosen so that it stays in the same place on
// the screen when the handlebox is torn off.
//
// If the snap edge is not set, then an appropriate value
// will be guessed from the handle position. If the
// handle position is %GTK_POS_RIGHT or %GTK_POS_LEFT,
// then the snap edge will be %GTK_POS_TOP, otherwise
// it will be %GTK_POS_LEFT.
/*

C function : gtk_handle_box_set_snap_edge
*/
func (recv *HandleBox) SetSnapEdge(edge PositionType) {
	c_edge := (C.GtkPositionType)(edge)

	C.gtk_handle_box_set_snap_edge((*C.GtkHandleBox)(recv.native), c_edge)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by HandleBox
func (recv *HandleBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HandleBox
func (recv *HandleBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// GtkHeaderBar is similar to a horizontal #GtkBox. It allows children to
// be placed at the start or the end. In addition, it allows a title and
// subtitle to be displayed. The title will be centered with respect to
// the width of the box, even if the children at either side take up
// different amounts of space. The height of the titlebar will be
// set to provide sufficient space for the subtitle, even if none is
// currently set. If a subtitle is not needed, the space reservation
// can be turned off with gtk_header_bar_set_has_subtitle().
//
// GtkHeaderBar can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
//
// For these reasons, GtkHeaderBar is the natural choice for use as the custom
// titlebar widget of a #GtkWindow (see gtk_window_set_titlebar()), as it gives
// features typical of titlebars while allowing the addition of child widgets.
/*

C record/class : GtkHeaderBar
*/
type HeaderBar struct {
	native *C.GtkHeaderBar
	// container : record
}

func HeaderBarNewFromC(u unsafe.Pointer) *HeaderBar {
	c := (*C.GtkHeaderBar)(u)
	if c == nil {
		return nil
	}

	g := &HeaderBar{native: c}

	return g
}

func (recv *HeaderBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *HeaderBar) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *HeaderBar) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HeaderBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HeaderBar) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to HeaderBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a HeaderBar.
func CastToHeaderBar(object *gobject.Object) *HeaderBar {
	return HeaderBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by HeaderBar
func (recv *HeaderBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HeaderBar
func (recv *HeaderBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkIMContext defines the interface for GTK+ input methods. An input method
// is used by GTK+ text input widgets like #GtkEntry to map from key events to
// Unicode character strings.
//
// The default input method can be set programmatically via the
// #GtkSettings:gtk-im-module GtkSettings property. Alternatively, you may set
// the GTK_IM_MODULE environment variable as documented in
// [Running GTK+ Applications][gtk-running].
//
// The #GtkEntry #GtkEntry:im-module and #GtkTextView #GtkTextView:im-module
// properties may also be used to set input methods for specific widget
// instances. For instance, a certain entry widget might be expected to contain
// certain characters which would be easier to input with a certain input
// method.
//
// An input method may consume multiple key events in sequence and finally
// output the composed result. This is called preediting, and an input method
// may provide feedback about this process by displaying the intermediate
// composition states as preedit text. For instance, the default GTK+ input
// method implements the input of arbitrary Unicode code points by holding down
// the Control and Shift keys and then typing U followed by the hexadecimal
// digits of the code point.  When releasing the Control and Shift keys,
// preediting ends and the character is inserted as text. Ctrl+Shift+u20AC for
// example results in the  sign.
//
// Additional input methods can be made available for use by GTK+ widgets as
// loadable modules. An input method module is a small shared library which
// implements a subclass of #GtkIMContext or #GtkIMContextSimple and exports
// these four functions:
//
// |[<!-- language="C" -->
// void im_module_init(GTypeModule *module);
// ]|
// This function should register the #GType of the #GtkIMContext subclass which
// implements the input method by means of g_type_module_register_type(). Note
// that g_type_register_static() cannot be used as the type needs to be
// registered dynamically.
//
// |[<!-- language="C" -->
// void im_module_exit(void);
// ]|
// Here goes any cleanup code your input method might require on module unload.
//
// |[<!-- language="C" -->
// void im_module_list(const GtkIMContextInfo ***contexts, int *n_contexts)
// {
// *contexts = info_list;
// *n_contexts = G_N_ELEMENTS (info_list);
// }
// ]|
// This function returns the list of input methods provided by the module. The
// example implementation above shows a common solution and simply returns a
// pointer to statically defined array of #GtkIMContextInfo items for each
// provided input method.
//
// |[<!-- language="C" -->
// GtkIMContext * im_module_create(const gchar *context_id);
// ]|
// This function should return a pointer to a newly created instance of the
// #GtkIMContext subclass identified by @context_id. The context ID is the same
// as specified in the #GtkIMContextInfo array returned by im_module_list().
//
// After a new loadable input method module has been installed on the system,
// the configuration file `gtk.immodules` needs to be
// regenerated by [gtk-query-immodules-3.0][gtk-query-immodules-3.0],
// in order for the new input method to become available to GTK+ applications.
/*

C record/class : GtkIMContext
*/
type IMContext struct {
	native *C.GtkIMContext
	// parent_instance : record
}

func IMContextNewFromC(u unsafe.Pointer) *IMContext {
	c := (*C.GtkIMContext)(u)
	if c == nil {
		return nil
	}

	g := &IMContext{native: c}

	return g
}

func (recv *IMContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *IMContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to IMContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMContext.
func CastToIMContext(object *gobject.Object) *IMContext {
	return IMContextNewFromC(object.ToC())
}

// Unsupported signal 'commit' for IMContext : unsupported parameter str : type utf8 :

// Unsupported signal 'delete-surrounding' for IMContext : unsupported parameter offset : type gint :

type signalIMContextPreeditChangedDetail struct {
	callback  IMContextSignalPreeditChangedCallback
	handlerID C.gulong
}

var signalIMContextPreeditChangedId int
var signalIMContextPreeditChangedMap = make(map[int]signalIMContextPreeditChangedDetail)
var signalIMContextPreeditChangedLock sync.Mutex

// IMContextSignalPreeditChangedCallback is a callback function for a 'preedit-changed' signal emitted from a IMContext.
type IMContextSignalPreeditChangedCallback func()

/*
ConnectPreeditChanged connects the callback to the 'preedit-changed' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditChanged to remove it.
*/
func (recv *IMContext) ConnectPreeditChanged(callback IMContextSignalPreeditChangedCallback) int {
	signalIMContextPreeditChangedLock.Lock()
	defer signalIMContextPreeditChangedLock.Unlock()

	signalIMContextPreeditChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_changed(instance, C.gpointer(uintptr(signalIMContextPreeditChangedId)))

	detail := signalIMContextPreeditChangedDetail{callback, handlerID}
	signalIMContextPreeditChangedMap[signalIMContextPreeditChangedId] = detail

	return signalIMContextPreeditChangedId
}

/*
DisconnectPreeditChanged disconnects a callback from the 'preedit-changed' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditChanged.
*/
func (recv *IMContext) DisconnectPreeditChanged(connectionID int) {
	signalIMContextPreeditChangedLock.Lock()
	defer signalIMContextPreeditChangedLock.Unlock()

	detail, exists := signalIMContextPreeditChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditChangedMap, connectionID)
}

//export imcontext_preeditChangedHandler
func imcontext_preeditChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIMContextPreeditChangedMap[index].callback
	callback()
}

type signalIMContextPreeditEndDetail struct {
	callback  IMContextSignalPreeditEndCallback
	handlerID C.gulong
}

var signalIMContextPreeditEndId int
var signalIMContextPreeditEndMap = make(map[int]signalIMContextPreeditEndDetail)
var signalIMContextPreeditEndLock sync.Mutex

// IMContextSignalPreeditEndCallback is a callback function for a 'preedit-end' signal emitted from a IMContext.
type IMContextSignalPreeditEndCallback func()

/*
ConnectPreeditEnd connects the callback to the 'preedit-end' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditEnd to remove it.
*/
func (recv *IMContext) ConnectPreeditEnd(callback IMContextSignalPreeditEndCallback) int {
	signalIMContextPreeditEndLock.Lock()
	defer signalIMContextPreeditEndLock.Unlock()

	signalIMContextPreeditEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_end(instance, C.gpointer(uintptr(signalIMContextPreeditEndId)))

	detail := signalIMContextPreeditEndDetail{callback, handlerID}
	signalIMContextPreeditEndMap[signalIMContextPreeditEndId] = detail

	return signalIMContextPreeditEndId
}

/*
DisconnectPreeditEnd disconnects a callback from the 'preedit-end' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditEnd.
*/
func (recv *IMContext) DisconnectPreeditEnd(connectionID int) {
	signalIMContextPreeditEndLock.Lock()
	defer signalIMContextPreeditEndLock.Unlock()

	detail, exists := signalIMContextPreeditEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditEndMap, connectionID)
}

//export imcontext_preeditEndHandler
func imcontext_preeditEndHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIMContextPreeditEndMap[index].callback
	callback()
}

type signalIMContextPreeditStartDetail struct {
	callback  IMContextSignalPreeditStartCallback
	handlerID C.gulong
}

var signalIMContextPreeditStartId int
var signalIMContextPreeditStartMap = make(map[int]signalIMContextPreeditStartDetail)
var signalIMContextPreeditStartLock sync.Mutex

// IMContextSignalPreeditStartCallback is a callback function for a 'preedit-start' signal emitted from a IMContext.
type IMContextSignalPreeditStartCallback func()

/*
ConnectPreeditStart connects the callback to the 'preedit-start' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditStart to remove it.
*/
func (recv *IMContext) ConnectPreeditStart(callback IMContextSignalPreeditStartCallback) int {
	signalIMContextPreeditStartLock.Lock()
	defer signalIMContextPreeditStartLock.Unlock()

	signalIMContextPreeditStartId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_start(instance, C.gpointer(uintptr(signalIMContextPreeditStartId)))

	detail := signalIMContextPreeditStartDetail{callback, handlerID}
	signalIMContextPreeditStartMap[signalIMContextPreeditStartId] = detail

	return signalIMContextPreeditStartId
}

/*
DisconnectPreeditStart disconnects a callback from the 'preedit-start' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditStart.
*/
func (recv *IMContext) DisconnectPreeditStart(connectionID int) {
	signalIMContextPreeditStartLock.Lock()
	defer signalIMContextPreeditStartLock.Unlock()

	detail, exists := signalIMContextPreeditStartMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditStartMap, connectionID)
}

//export imcontext_preeditStartHandler
func imcontext_preeditStartHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIMContextPreeditStartMap[index].callback
	callback()
}

type signalIMContextRetrieveSurroundingDetail struct {
	callback  IMContextSignalRetrieveSurroundingCallback
	handlerID C.gulong
}

var signalIMContextRetrieveSurroundingId int
var signalIMContextRetrieveSurroundingMap = make(map[int]signalIMContextRetrieveSurroundingDetail)
var signalIMContextRetrieveSurroundingLock sync.Mutex

// IMContextSignalRetrieveSurroundingCallback is a callback function for a 'retrieve-surrounding' signal emitted from a IMContext.
type IMContextSignalRetrieveSurroundingCallback func() bool

/*
ConnectRetrieveSurrounding connects the callback to the 'retrieve-surrounding' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectRetrieveSurrounding to remove it.
*/
func (recv *IMContext) ConnectRetrieveSurrounding(callback IMContextSignalRetrieveSurroundingCallback) int {
	signalIMContextRetrieveSurroundingLock.Lock()
	defer signalIMContextRetrieveSurroundingLock.Unlock()

	signalIMContextRetrieveSurroundingId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_retrieve_surrounding(instance, C.gpointer(uintptr(signalIMContextRetrieveSurroundingId)))

	detail := signalIMContextRetrieveSurroundingDetail{callback, handlerID}
	signalIMContextRetrieveSurroundingMap[signalIMContextRetrieveSurroundingId] = detail

	return signalIMContextRetrieveSurroundingId
}

/*
DisconnectRetrieveSurrounding disconnects a callback from the 'retrieve-surrounding' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectRetrieveSurrounding.
*/
func (recv *IMContext) DisconnectRetrieveSurrounding(connectionID int) {
	signalIMContextRetrieveSurroundingLock.Lock()
	defer signalIMContextRetrieveSurroundingLock.Unlock()

	detail, exists := signalIMContextRetrieveSurroundingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextRetrieveSurroundingMap, connectionID)
}

//export imcontext_retrieveSurroundingHandler
func imcontext_retrieveSurroundingHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalIMContextRetrieveSurroundingMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Asks the widget that the input context is attached to to delete
// characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
// are in characters not in bytes which differs from the usage other
// places in #GtkIMContext.
//
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and
// call this function immediately afterwards to make sure that you
// know what you are deleting. You should also account for the fact
// that even if the signal was handled, the input context might not
// have deleted all the characters that were requested to be deleted.
//
// This function is used by an input method that wants to make
// subsitutions in the existing text in response to new input. It is
// not useful for applications.
/*

C function : gtk_im_context_delete_surrounding
*/
func (recv *IMContext) DeleteSurrounding(offset int32, nChars int32) bool {
	c_offset := (C.gint)(offset)

	c_n_chars := (C.gint)(nChars)

	retC := C.gtk_im_context_delete_surrounding((*C.GtkIMContext)(recv.native), c_offset, c_n_chars)
	retGo := retC == C.TRUE

	return retGo
}

// Allow an input method to internally handle key press and release
// events. If this function returns %TRUE, then no further processing
// should be done for this key event.
/*

C function : gtk_im_context_filter_keypress
*/
func (recv *IMContext) FilterKeypress(event *gdk.EventKey) bool {
	c_event := (*C.GdkEventKey)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEventKey)(event.ToC())
	}

	retC := C.gtk_im_context_filter_keypress((*C.GtkIMContext)(recv.native), c_event)
	retGo := retC == C.TRUE

	return retGo
}

// Notify the input method that the widget to which this
// input context corresponds has gained focus. The input method
// may, for example, change the displayed feedback to reflect
// this change.
/*

C function : gtk_im_context_focus_in
*/
func (recv *IMContext) FocusIn() {
	C.gtk_im_context_focus_in((*C.GtkIMContext)(recv.native))

	return
}

// Notify the input method that the widget to which this
// input context corresponds has lost focus. The input method
// may, for example, change the displayed feedback or reset the contexts
// state to reflect this change.
/*

C function : gtk_im_context_focus_out
*/
func (recv *IMContext) FocusOut() {
	C.gtk_im_context_focus_out((*C.GtkIMContext)(recv.native))

	return
}

// Retrieve the current preedit string for the input context,
// and a list of attributes to apply to the string.
// This string should be displayed inserted at the insertion
// point.
/*

C function : gtk_im_context_get_preedit_string
*/
func (recv *IMContext) GetPreeditString() (string, *pango.AttrList, int32) {
	var c_str *C.gchar

	var c_attrs *C.PangoAttrList

	var c_cursor_pos C.gint

	C.gtk_im_context_get_preedit_string((*C.GtkIMContext)(recv.native), &c_str, &c_attrs, &c_cursor_pos)

	str := C.GoString(c_str)
	defer C.free(unsafe.Pointer(c_str))

	attrs := pango.AttrListNewFromC(unsafe.Pointer(c_attrs))

	cursorPos := (int32)(c_cursor_pos)

	return str, attrs, cursorPos
}

// Retrieves context around the insertion point. Input methods
// typically want context in order to constrain input text based on
// existing text; this is important for languages such as Thai where
// only some sequences of characters are allowed.
//
// This function is implemented by emitting the
// GtkIMContext::retrieve_surrounding signal on the input method; in
// response to this signal, a widget should provide as much context as
// is available, up to an entire paragraph, by calling
// gtk_im_context_set_surrounding(). Note that there is no obligation
// for a widget to respond to the ::retrieve_surrounding signal, so input
// methods must be prepared to function without context.
/*

C function : gtk_im_context_get_surrounding
*/
func (recv *IMContext) GetSurrounding() (bool, string, int32) {
	var c_text *C.gchar

	var c_cursor_index C.gint

	retC := C.gtk_im_context_get_surrounding((*C.GtkIMContext)(recv.native), &c_text, &c_cursor_index)
	retGo := retC == C.TRUE

	text := C.GoString(c_text)
	defer C.free(unsafe.Pointer(c_text))

	cursorIndex := (int32)(c_cursor_index)

	return retGo, text, cursorIndex
}

// Notify the input method that a change such as a change in cursor
// position has been made. This will typically cause the input
// method to clear the preedit state.
/*

C function : gtk_im_context_reset
*/
func (recv *IMContext) Reset() {
	C.gtk_im_context_reset((*C.GtkIMContext)(recv.native))

	return
}

// Set the client window for the input context; this is the
// #GdkWindow in which the input appears. This window is
// used in order to correctly position status windows, and may
// also be used for purposes internal to the input method.
/*

C function : gtk_im_context_set_client_window
*/
func (recv *IMContext) SetClientWindow(window *gdk.Window) {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	C.gtk_im_context_set_client_window((*C.GtkIMContext)(recv.native), c_window)

	return
}

// Unsupported : gtk_im_context_set_cursor_location : unsupported parameter area : Blacklisted record : GdkRectangle

// Sets surrounding context around the insertion point and preedit
// string. This function is expected to be called in response to the
// GtkIMContext::retrieve_surrounding signal, and will likely have no
// effect if called at other times.
/*

C function : gtk_im_context_set_surrounding
*/
func (recv *IMContext) SetSurrounding(text string, len int32, cursorIndex int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_cursor_index := (C.gint)(cursorIndex)

	C.gtk_im_context_set_surrounding((*C.GtkIMContext)(recv.native), c_text, c_len, c_cursor_index)

	return
}

// Sets whether the IM context should use the preedit string
// to display feedback. If @use_preedit is FALSE (default
// is TRUE), then the IM context may use some other method to display
// feedback, such as displaying it in a child of the root window.
/*

C function : gtk_im_context_set_use_preedit
*/
func (recv *IMContext) SetUsePreedit(usePreedit bool) {
	c_use_preedit :=
		boolToGboolean(usePreedit)

	C.gtk_im_context_set_use_preedit((*C.GtkIMContext)(recv.native), c_use_preedit)

	return
}

// GtkIMContextSimple is a simple input method context supporting table-based
// input methods. It has a built-in table of compose sequences that is derived
// from the X11 Compose files.
//
// GtkIMContextSimple reads additional compose sequences from the first of the
// following files that is found: ~/.config/gtk-3.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
//
// ## Unicode characters
//
// GtkIMContextSimple also supports numeric entry of Unicode characters
// by typing Ctrl-Shift-u, followed by a hexadecimal Unicode codepoint.
// For example, Ctrl-Shift-u 1 2 3 Enter yields U+0123 LATIN SMALL LETTER
// G WITH CEDILLA, i.e. .
//
// ## Emoji
//
// GtkIMContextSimple also supports entry of Emoji by their name.
// This works by first typing Ctrl-Shift-e, followed by an Emoji name.
//
// The following names are supported:
// - :-) 
// - 8-) 
// - <3 
// - kiss 
// - grin 
// - joy 
// - :-* 
// - xD 
// - like 
// - dislike 
// - up 
// - v 
// - ok 
// - B-) 
// - ;-) 
// - ;-P 
// - :-p 
// - 3( 
// - :-( 
// - :] 
// - :'( 
// - :_( 
// - :(( 
// - :o 
// - :| 
// - 3-) 
// - >( 
// - >(( 
// - O:) 
// - ;o 
// - 8| 
// - 8o 
// - :X 
// - }:) 
/*

C record/class : GtkIMContextSimple
*/
type IMContextSimple struct {
	native *C.GtkIMContextSimple
	// object : record
	// Private : priv
}

func IMContextSimpleNewFromC(u unsafe.Pointer) *IMContextSimple {
	c := (*C.GtkIMContextSimple)(u)
	if c == nil {
		return nil
	}

	g := &IMContextSimple{native: c}

	return g
}

func (recv *IMContextSimple) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// IMContext upcasts to *IMContext
func (recv *IMContextSimple) IMContext() *IMContext {
	return IMContextNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *IMContextSimple) Object() *gobject.Object {
	return recv.IMContext().Object()
}

// CastToWidget down casts any arbitary Object to IMContextSimple.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMContextSimple.
func CastToIMContextSimple(object *gobject.Object) *IMContextSimple {
	return IMContextSimpleNewFromC(object.ToC())
}

// Creates a new #GtkIMContextSimple.
/*

C function : gtk_im_context_simple_new
*/
func IMContextSimpleNew() *IMContextSimple {
	retC := C.gtk_im_context_simple_new()
	retGo := IMContextSimpleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Blacklisted : gtk_im_context_simple_add_compose_file

// Adds an additional table to search to the input context.
// Each row of the table consists of @max_seq_len key symbols
// followed by two #guint16 interpreted as the high and low
// words of a #gunicode value. Tables are searched starting
// from the last added.
//
// The table must be sorted in dictionary order on the
// numeric value of the key symbol fields. (Values beyond
// the length of the sequence should be zero.)
/*

C function : gtk_im_context_simple_add_table
*/
func (recv *IMContextSimple) AddTable(data []uint16, maxSeqLen int32, nSeqs int32) {
	c_data := &data[0]

	c_max_seq_len := (C.gint)(maxSeqLen)

	c_n_seqs := (C.gint)(nSeqs)

	C.gtk_im_context_simple_add_table((*C.GtkIMContextSimple)(recv.native), (*C.guint16)(unsafe.Pointer(c_data)), c_max_seq_len, c_n_seqs)

	return
}

/*

C record/class : GtkIMMulticontext
*/
type IMMulticontext struct {
	native *C.GtkIMMulticontext
	// object : record
	// Private : priv
}

func IMMulticontextNewFromC(u unsafe.Pointer) *IMMulticontext {
	c := (*C.GtkIMMulticontext)(u)
	if c == nil {
		return nil
	}

	g := &IMMulticontext{native: c}

	return g
}

func (recv *IMMulticontext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// IMContext upcasts to *IMContext
func (recv *IMMulticontext) IMContext() *IMContext {
	return IMContextNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *IMMulticontext) Object() *gobject.Object {
	return recv.IMContext().Object()
}

// CastToWidget down casts any arbitary Object to IMMulticontext.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMMulticontext.
func CastToIMMulticontext(object *gobject.Object) *IMMulticontext {
	return IMMulticontextNewFromC(object.ToC())
}

// Creates a new #GtkIMMulticontext.
/*

C function : gtk_im_multicontext_new
*/
func IMMulticontextNew() *IMMulticontext {
	retC := C.gtk_im_multicontext_new()
	retGo := IMMulticontextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Add menuitems for various available input methods to a menu;
// the menuitems, when selected, will switch the input method
// for the context and the global default input method.
/*

C function : gtk_im_multicontext_append_menuitems
*/
func (recv *IMMulticontext) AppendMenuitems(menushell *MenuShell) {
	c_menushell := (*C.GtkMenuShell)(C.NULL)
	if menushell != nil {
		c_menushell = (*C.GtkMenuShell)(menushell.ToC())
	}

	C.gtk_im_multicontext_append_menuitems((*C.GtkIMMulticontext)(recv.native), c_menushell)

	return
}

// An icon factory manages a collection of #GtkIconSet; a #GtkIconSet manages a
// set of variants of a particular icon (i.e. a #GtkIconSet contains variants for
// different sizes and widget states). Icons in an icon factory are named by a
// stock ID, which is a simple string identifying the icon. Each #GtkStyle has a
// list of #GtkIconFactory derived from the current theme; those icon factories
// are consulted first when searching for an icon. If the theme doesnt set a
// particular icon, GTK+ looks for the icon in a list of default icon factories,
// maintained by gtk_icon_factory_add_default() and
// gtk_icon_factory_remove_default(). Applications with icons should add a default
// icon factory with their icons, which will allow themes to override the icons
// for the application.
//
// To display an icon, always use gtk_style_lookup_icon_set() on the widget that
// will display the icon, or the convenience function
// gtk_widget_render_icon(). These functions take the theme into account when
// looking up the icon to use for a given stock ID.
//
// # GtkIconFactory as GtkBuildable # {#GtkIconFactory-BUILDER-UI}
//
// GtkIconFactory supports a custom <sources> element, which can contain
// multiple <source> elements. The following attributes are allowed:
//
// - stock-id
//
// The stock id of the source, a string. This attribute is
// mandatory
//
// - filename
//
// The filename of the source, a string.  This attribute is
// optional
//
// - icon-name
//
// The icon name for the source, a string.  This attribute is
// optional.
//
// - size
//
// Size of the icon, a #GtkIconSize enum value.  This attribute is
// optional.
//
// - direction
//
// Direction of the source, a #GtkTextDirection enum value.  This
// attribute is optional.
//
// - state
//
// State of the source, a #GtkStateType enum value.  This
// attribute is optional.
//
//
// ## A #GtkIconFactory UI definition fragment. ##
//
// |[
// <object class="GtkIconFactory" id="iconfactory1">
// <sources>
// <source stock-id="apple-red" filename="apple-red.png"/>
// </sources>
// </object>
// <object class="GtkWindow" id="window1">
// <child>
// <object class="GtkButton" id="apple_button">
// <property name="label">apple-red</property>
// <property name="use-stock">True</property>
// </object>
// </child>
// </object>
// ]|
/*

C record/class : GtkIconFactory
*/
type IconFactory struct {
	native *C.GtkIconFactory
	// parent_instance : record
	// Private : priv
}

func IconFactoryNewFromC(u unsafe.Pointer) *IconFactory {
	c := (*C.GtkIconFactory)(u)
	if c == nil {
		return nil
	}

	g := &IconFactory{native: c}

	return g
}

func (recv *IconFactory) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *IconFactory) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to IconFactory.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconFactory.
func CastToIconFactory(object *gobject.Object) *IconFactory {
	return IconFactoryNewFromC(object.ToC())
}

// Creates a new #GtkIconFactory. An icon factory manages a collection
// of #GtkIconSets; a #GtkIconSet manages a set of variants of a
// particular icon (i.e. a #GtkIconSet contains variants for different
// sizes and widget states). Icons in an icon factory are named by a
// stock ID, which is a simple string identifying the icon. Each
// #GtkStyle has a list of #GtkIconFactorys derived from the current
// theme; those icon factories are consulted first when searching for
// an icon. If the theme doesnt set a particular icon, GTK+ looks for
// the icon in a list of default icon factories, maintained by
// gtk_icon_factory_add_default() and
// gtk_icon_factory_remove_default(). Applications with icons should
// add a default icon factory with their icons, which will allow
// themes to override the icons for the application.
/*

C function : gtk_icon_factory_new
*/
func IconFactoryNew() *IconFactory {
	retC := C.gtk_icon_factory_new()
	retGo := IconFactoryNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds the given @icon_set to the icon factory, under the name
// @stock_id.  @stock_id should be namespaced for your application,
// e.g. myapp-whatever-icon.  Normally applications create a
// #GtkIconFactory, then add it to the list of default factories with
// gtk_icon_factory_add_default(). Then they pass the @stock_id to
// widgets such as #GtkImage to display the icon. Themes can provide
// an icon with the same name (such as "myapp-whatever-icon") to
// override your applications default icons. If an icon already
// existed in @factory for @stock_id, it is unreferenced and replaced
// with the new @icon_set.
/*

C function : gtk_icon_factory_add
*/
func (recv *IconFactory) Add(stockId string, iconSet *IconSet) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	C.gtk_icon_factory_add((*C.GtkIconFactory)(recv.native), c_stock_id, c_icon_set)

	return
}

// Adds an icon factory to the list of icon factories searched by
// gtk_style_lookup_icon_set(). This means that, for example,
// gtk_image_new_from_stock() will be able to find icons in @factory.
// There will normally be an icon factory added for each library or
// application that comes with icons. The default icon factories
// can be overridden by themes.
/*

C function : gtk_icon_factory_add_default
*/
func (recv *IconFactory) AddDefault() {
	C.gtk_icon_factory_add_default((*C.GtkIconFactory)(recv.native))

	return
}

// Looks up @stock_id in the icon factory, returning an icon set
// if found, otherwise %NULL. For display to the user, you should
// use gtk_style_lookup_icon_set() on the #GtkStyle for the
// widget that will display the icon, instead of using this
// function directly, so that themes are taken into account.
/*

C function : gtk_icon_factory_lookup
*/
func (recv *IconFactory) Lookup(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_icon_factory_lookup((*C.GtkIconFactory)(recv.native), c_stock_id)
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Removes an icon factory from the list of default icon
// factories. Not normally used; you might use it for a library that
// can be unloaded or shut down.
/*

C function : gtk_icon_factory_remove_default
*/
func (recv *IconFactory) RemoveDefault() {
	C.gtk_icon_factory_remove_default((*C.GtkIconFactory)(recv.native))

	return
}

// Buildable returns the Buildable interface implemented by IconFactory
func (recv *IconFactory) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Contains information found when looking up an icon in
// an icon theme.
/*

C record/class : GtkIconInfo
*/
type IconInfo struct {
	native *C.GtkIconInfo
}

func IconInfoNewFromC(u unsafe.Pointer) *IconInfo {
	c := (*C.GtkIconInfo)(u)
	if c == nil {
		return nil
	}

	g := &IconInfo{native: c}

	return g
}

func (recv *IconInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *IconInfo) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to IconInfo.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconInfo.
func CastToIconInfo(object *gobject.Object) *IconInfo {
	return IconInfoNewFromC(object.ToC())
}

// #GtkIconTheme provides a facility for looking up icons by name
// and size. The main reason for using a name rather than simply
// providing a filename is to allow different icons to be used
// depending on what icon theme is selected
// by the user. The operation of icon themes on Linux and Unix
// follows the [Icon Theme Specification](http://www.freedesktop.org/Standards/icon-theme-spec)
// There is a fallback icon theme, named `hicolor`, where applications
// should install their icons, but additional icon themes can be installed
// as operating system vendors and users choose.
//
// Named icons are similar to the deprecated [Stock Items][gtkstock],
// and the distinction between the two may be a bit confusing.
// A few things to keep in mind:
//
// - Stock images usually are used in conjunction with
// [Stock Items][gtkstock], such as %GTK_STOCK_OK or
// %GTK_STOCK_OPEN. Named icons are easier to set up and therefore
// are more useful for new icons that an application wants to
// add, such as application icons or window icons.
//
// - Stock images can only be loaded at the symbolic sizes defined
// by the #GtkIconSize enumeration, or by custom sizes defined
// by gtk_icon_size_register(), while named icons are more flexible
// and any pixel size can be specified.
//
// - Because stock images are closely tied to stock items, and thus
// to actions in the user interface, stock images may come in
// multiple variants for different widget states or writing
// directions.
//
// A good rule of thumb is that if there is a stock image for what
// you want to use, use it, otherwise use a named icon. It turns
// out that internally stock images are generally defined in
// terms of one or more named icons. (An example of the
// more than one case is icons that depend on writing direction;
// %GTK_STOCK_GO_FORWARD uses the two themed icons
// gtk-stock-go-forward-ltr and gtk-stock-go-forward-rtl.)
//
// In many cases, named themes are used indirectly, via #GtkImage
// or stock items, rather than directly, but looking up icons
// directly is also simple. The #GtkIconTheme object acts
// as a database of all the icons in the current theme. You
// can create new #GtkIconTheme objects, but its much more
// efficient to use the standard icon theme for the #GdkScreen
// so that the icon information is shared with other people
// looking up icons.
// |[<!-- language="C" -->
// GError *error = NULL;
// GtkIconTheme *icon_theme;
// GdkPixbuf *pixbuf;
//
// icon_theme = gtk_icon_theme_get_default ();
// pixbuf = gtk_icon_theme_load_icon (icon_theme,
// "my-icon-name", // icon name
// 48, // icon size
// 0,  // flags
// &error);
// if (!pixbuf)
// {
// g_warning ("Couldnt load icon: %s", error->message);
// g_error_free (error);
// }
// else
// {
// Use the pixbuf
// g_object_unref (pixbuf);
// }
// ]|
/*

C record/class : GtkIconTheme
*/
type IconTheme struct {
	native *C.GtkIconTheme
	// Private : parent_instance
	// Private : priv
}

func IconThemeNewFromC(u unsafe.Pointer) *IconTheme {
	c := (*C.GtkIconTheme)(u)
	if c == nil {
		return nil
	}

	g := &IconTheme{native: c}

	return g
}

func (recv *IconTheme) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *IconTheme) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to IconTheme.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconTheme.
func CastToIconTheme(object *gobject.Object) *IconTheme {
	return IconThemeNewFromC(object.ToC())
}

type signalIconThemeChangedDetail struct {
	callback  IconThemeSignalChangedCallback
	handlerID C.gulong
}

var signalIconThemeChangedId int
var signalIconThemeChangedMap = make(map[int]signalIconThemeChangedDetail)
var signalIconThemeChangedLock sync.Mutex

// IconThemeSignalChangedCallback is a callback function for a 'changed' signal emitted from a IconTheme.
type IconThemeSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the IconTheme.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *IconTheme) ConnectChanged(callback IconThemeSignalChangedCallback) int {
	signalIconThemeChangedLock.Lock()
	defer signalIconThemeChangedLock.Unlock()

	signalIconThemeChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconTheme_signal_connect_changed(instance, C.gpointer(uintptr(signalIconThemeChangedId)))

	detail := signalIconThemeChangedDetail{callback, handlerID}
	signalIconThemeChangedMap[signalIconThemeChangedId] = detail

	return signalIconThemeChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the IconTheme.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *IconTheme) DisconnectChanged(connectionID int) {
	signalIconThemeChangedLock.Lock()
	defer signalIconThemeChangedLock.Unlock()

	detail, exists := signalIconThemeChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconThemeChangedMap, connectionID)
}

//export icontheme_changedHandler
func icontheme_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconThemeChangedMap[index].callback
	callback()
}

// #GtkIconView provides an alternative view on a #GtkTreeModel.
// It displays the model as a grid of icons with labels. Like
// #GtkTreeView, it allows to select one or multiple items
// (depending on the selection mode, see gtk_icon_view_set_selection_mode()).
// In addition to selection with the arrow keys, #GtkIconView supports
// rubberband selection, which is controlled by dragging the pointer.
//
// Note that if the tree model is backed by an actual tree store (as
// opposed to a flat list where the mapping to icons is obvious),
// #GtkIconView will only display the first level of the tree and
// ignore the trees branches.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// iconview.view
//  [rubberband]
// ]|
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
/*

C record/class : GtkIconView
*/
type IconView struct {
	native *C.GtkIconView
	// parent : record
	// Private : priv
}

func IconViewNewFromC(u unsafe.Pointer) *IconView {
	c := (*C.GtkIconView)(u)
	if c == nil {
		return nil
	}

	g := &IconView{native: c}

	return g
}

func (recv *IconView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *IconView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *IconView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *IconView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *IconView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to IconView.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconView.
func CastToIconView(object *gobject.Object) *IconView {
	return IconViewNewFromC(object.ToC())
}

type signalIconViewActivateCursorItemDetail struct {
	callback  IconViewSignalActivateCursorItemCallback
	handlerID C.gulong
}

var signalIconViewActivateCursorItemId int
var signalIconViewActivateCursorItemMap = make(map[int]signalIconViewActivateCursorItemDetail)
var signalIconViewActivateCursorItemLock sync.Mutex

// IconViewSignalActivateCursorItemCallback is a callback function for a 'activate-cursor-item' signal emitted from a IconView.
type IconViewSignalActivateCursorItemCallback func() bool

/*
ConnectActivateCursorItem connects the callback to the 'activate-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectActivateCursorItem to remove it.
*/
func (recv *IconView) ConnectActivateCursorItem(callback IconViewSignalActivateCursorItemCallback) int {
	signalIconViewActivateCursorItemLock.Lock()
	defer signalIconViewActivateCursorItemLock.Unlock()

	signalIconViewActivateCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_activate_cursor_item(instance, C.gpointer(uintptr(signalIconViewActivateCursorItemId)))

	detail := signalIconViewActivateCursorItemDetail{callback, handlerID}
	signalIconViewActivateCursorItemMap[signalIconViewActivateCursorItemId] = detail

	return signalIconViewActivateCursorItemId
}

/*
DisconnectActivateCursorItem disconnects a callback from the 'activate-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectActivateCursorItem.
*/
func (recv *IconView) DisconnectActivateCursorItem(connectionID int) {
	signalIconViewActivateCursorItemLock.Lock()
	defer signalIconViewActivateCursorItemLock.Unlock()

	detail, exists := signalIconViewActivateCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewActivateCursorItemMap, connectionID)
}

//export iconview_activateCursorItemHandler
func iconview_activateCursorItemHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalIconViewActivateCursorItemMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalIconViewItemActivatedDetail struct {
	callback  IconViewSignalItemActivatedCallback
	handlerID C.gulong
}

var signalIconViewItemActivatedId int
var signalIconViewItemActivatedMap = make(map[int]signalIconViewItemActivatedDetail)
var signalIconViewItemActivatedLock sync.Mutex

// IconViewSignalItemActivatedCallback is a callback function for a 'item-activated' signal emitted from a IconView.
type IconViewSignalItemActivatedCallback func(path *TreePath)

/*
ConnectItemActivated connects the callback to the 'item-activated' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectItemActivated to remove it.
*/
func (recv *IconView) ConnectItemActivated(callback IconViewSignalItemActivatedCallback) int {
	signalIconViewItemActivatedLock.Lock()
	defer signalIconViewItemActivatedLock.Unlock()

	signalIconViewItemActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_item_activated(instance, C.gpointer(uintptr(signalIconViewItemActivatedId)))

	detail := signalIconViewItemActivatedDetail{callback, handlerID}
	signalIconViewItemActivatedMap[signalIconViewItemActivatedId] = detail

	return signalIconViewItemActivatedId
}

/*
DisconnectItemActivated disconnects a callback from the 'item-activated' signal for the IconView.

The connectionID should be a value returned from a call to ConnectItemActivated.
*/
func (recv *IconView) DisconnectItemActivated(connectionID int) {
	signalIconViewItemActivatedLock.Lock()
	defer signalIconViewItemActivatedLock.Unlock()

	detail, exists := signalIconViewItemActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewItemActivatedMap, connectionID)
}

//export iconview_itemActivatedHandler
func iconview_itemActivatedHandler(_ *C.GObject, c_path *C.GtkTreePath, data C.gpointer) {
	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalIconViewItemActivatedMap[index].callback
	callback(path)
}

// Unsupported signal 'move-cursor' for IconView : unsupported parameter step : type MovementStep :

type signalIconViewSelectAllDetail struct {
	callback  IconViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalIconViewSelectAllId int
var signalIconViewSelectAllMap = make(map[int]signalIconViewSelectAllDetail)
var signalIconViewSelectAllLock sync.Mutex

// IconViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a IconView.
type IconViewSignalSelectAllCallback func()

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *IconView) ConnectSelectAll(callback IconViewSignalSelectAllCallback) int {
	signalIconViewSelectAllLock.Lock()
	defer signalIconViewSelectAllLock.Unlock()

	signalIconViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_select_all(instance, C.gpointer(uintptr(signalIconViewSelectAllId)))

	detail := signalIconViewSelectAllDetail{callback, handlerID}
	signalIconViewSelectAllMap[signalIconViewSelectAllId] = detail

	return signalIconViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *IconView) DisconnectSelectAll(connectionID int) {
	signalIconViewSelectAllLock.Lock()
	defer signalIconViewSelectAllLock.Unlock()

	detail, exists := signalIconViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectAllMap, connectionID)
}

//export iconview_selectAllHandler
func iconview_selectAllHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewSelectAllMap[index].callback
	callback()
}

type signalIconViewSelectCursorItemDetail struct {
	callback  IconViewSignalSelectCursorItemCallback
	handlerID C.gulong
}

var signalIconViewSelectCursorItemId int
var signalIconViewSelectCursorItemMap = make(map[int]signalIconViewSelectCursorItemDetail)
var signalIconViewSelectCursorItemLock sync.Mutex

// IconViewSignalSelectCursorItemCallback is a callback function for a 'select-cursor-item' signal emitted from a IconView.
type IconViewSignalSelectCursorItemCallback func()

/*
ConnectSelectCursorItem connects the callback to the 'select-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorItem to remove it.
*/
func (recv *IconView) ConnectSelectCursorItem(callback IconViewSignalSelectCursorItemCallback) int {
	signalIconViewSelectCursorItemLock.Lock()
	defer signalIconViewSelectCursorItemLock.Unlock()

	signalIconViewSelectCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_select_cursor_item(instance, C.gpointer(uintptr(signalIconViewSelectCursorItemId)))

	detail := signalIconViewSelectCursorItemDetail{callback, handlerID}
	signalIconViewSelectCursorItemMap[signalIconViewSelectCursorItemId] = detail

	return signalIconViewSelectCursorItemId
}

/*
DisconnectSelectCursorItem disconnects a callback from the 'select-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectCursorItem.
*/
func (recv *IconView) DisconnectSelectCursorItem(connectionID int) {
	signalIconViewSelectCursorItemLock.Lock()
	defer signalIconViewSelectCursorItemLock.Unlock()

	detail, exists := signalIconViewSelectCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectCursorItemMap, connectionID)
}

//export iconview_selectCursorItemHandler
func iconview_selectCursorItemHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewSelectCursorItemMap[index].callback
	callback()
}

type signalIconViewSelectionChangedDetail struct {
	callback  IconViewSignalSelectionChangedCallback
	handlerID C.gulong
}

var signalIconViewSelectionChangedId int
var signalIconViewSelectionChangedMap = make(map[int]signalIconViewSelectionChangedDetail)
var signalIconViewSelectionChangedLock sync.Mutex

// IconViewSignalSelectionChangedCallback is a callback function for a 'selection-changed' signal emitted from a IconView.
type IconViewSignalSelectionChangedCallback func()

/*
ConnectSelectionChanged connects the callback to the 'selection-changed' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectionChanged to remove it.
*/
func (recv *IconView) ConnectSelectionChanged(callback IconViewSignalSelectionChangedCallback) int {
	signalIconViewSelectionChangedLock.Lock()
	defer signalIconViewSelectionChangedLock.Unlock()

	signalIconViewSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_selection_changed(instance, C.gpointer(uintptr(signalIconViewSelectionChangedId)))

	detail := signalIconViewSelectionChangedDetail{callback, handlerID}
	signalIconViewSelectionChangedMap[signalIconViewSelectionChangedId] = detail

	return signalIconViewSelectionChangedId
}

/*
DisconnectSelectionChanged disconnects a callback from the 'selection-changed' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectionChanged.
*/
func (recv *IconView) DisconnectSelectionChanged(connectionID int) {
	signalIconViewSelectionChangedLock.Lock()
	defer signalIconViewSelectionChangedLock.Unlock()

	detail, exists := signalIconViewSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectionChangedMap, connectionID)
}

//export iconview_selectionChangedHandler
func iconview_selectionChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewSelectionChangedMap[index].callback
	callback()
}

type signalIconViewToggleCursorItemDetail struct {
	callback  IconViewSignalToggleCursorItemCallback
	handlerID C.gulong
}

var signalIconViewToggleCursorItemId int
var signalIconViewToggleCursorItemMap = make(map[int]signalIconViewToggleCursorItemDetail)
var signalIconViewToggleCursorItemLock sync.Mutex

// IconViewSignalToggleCursorItemCallback is a callback function for a 'toggle-cursor-item' signal emitted from a IconView.
type IconViewSignalToggleCursorItemCallback func()

/*
ConnectToggleCursorItem connects the callback to the 'toggle-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorItem to remove it.
*/
func (recv *IconView) ConnectToggleCursorItem(callback IconViewSignalToggleCursorItemCallback) int {
	signalIconViewToggleCursorItemLock.Lock()
	defer signalIconViewToggleCursorItemLock.Unlock()

	signalIconViewToggleCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_toggle_cursor_item(instance, C.gpointer(uintptr(signalIconViewToggleCursorItemId)))

	detail := signalIconViewToggleCursorItemDetail{callback, handlerID}
	signalIconViewToggleCursorItemMap[signalIconViewToggleCursorItemId] = detail

	return signalIconViewToggleCursorItemId
}

/*
DisconnectToggleCursorItem disconnects a callback from the 'toggle-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectToggleCursorItem.
*/
func (recv *IconView) DisconnectToggleCursorItem(connectionID int) {
	signalIconViewToggleCursorItemLock.Lock()
	defer signalIconViewToggleCursorItemLock.Unlock()

	detail, exists := signalIconViewToggleCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewToggleCursorItemMap, connectionID)
}

//export iconview_toggleCursorItemHandler
func iconview_toggleCursorItemHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewToggleCursorItemMap[index].callback
	callback()
}

type signalIconViewUnselectAllDetail struct {
	callback  IconViewSignalUnselectAllCallback
	handlerID C.gulong
}

var signalIconViewUnselectAllId int
var signalIconViewUnselectAllMap = make(map[int]signalIconViewUnselectAllDetail)
var signalIconViewUnselectAllLock sync.Mutex

// IconViewSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a IconView.
type IconViewSignalUnselectAllCallback func()

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *IconView) ConnectUnselectAll(callback IconViewSignalUnselectAllCallback) int {
	signalIconViewUnselectAllLock.Lock()
	defer signalIconViewUnselectAllLock.Unlock()

	signalIconViewUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalIconViewUnselectAllId)))

	detail := signalIconViewUnselectAllDetail{callback, handlerID}
	signalIconViewUnselectAllMap[signalIconViewUnselectAllId] = detail

	return signalIconViewUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the IconView.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *IconView) DisconnectUnselectAll(connectionID int) {
	signalIconViewUnselectAllLock.Lock()
	defer signalIconViewUnselectAllLock.Unlock()

	detail, exists := signalIconViewUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewUnselectAllMap, connectionID)
}

//export iconview_unselectAllHandler
func iconview_unselectAllHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewUnselectAllMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by IconView
func (recv *IconView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by IconView
func (recv *IconView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by IconView
func (recv *IconView) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by IconView
func (recv *IconView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

/*

C record/class : GtkIconViewAccessible
*/
type IconViewAccessible struct {
	native *C.GtkIconViewAccessible
	// parent : record
	// priv : record
}

func IconViewAccessibleNewFromC(u unsafe.Pointer) *IconViewAccessible {
	c := (*C.GtkIconViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &IconViewAccessible{native: c}

	return g
}

func (recv *IconViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *IconViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *IconViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *IconViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *IconViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to IconViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconViewAccessible.
func CastToIconViewAccessible(object *gobject.Object) *IconViewAccessible {
	return IconViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by IconViewAccessible
func (recv *IconViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by IconViewAccessible
func (recv *IconViewAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// The #GtkImage widget displays an image. Various kinds of object
// can be displayed as an image; most typically, you would load a
// #GdkPixbuf ("pixel buffer") from a file, and then display that.
// Theres a convenience function to do this, gtk_image_new_from_file(),
// used as follows:
// |[<!-- language="C" -->
// GtkWidget *image;
// image = gtk_image_new_from_file ("myfile.png");
// ]|
// If the file isnt loaded successfully, the image will contain a
// broken image icon similar to that used in many web browsers.
// If you want to handle errors in loading the file yourself,
// for example by displaying an error message, then load the image with
// gdk_pixbuf_new_from_file(), then create the #GtkImage with
// gtk_image_new_from_pixbuf().
//
// The image file may contain an animation, if so the #GtkImage will
// display an animation (#GdkPixbufAnimation) instead of a static image.
//
// #GtkImage is a subclass of #GtkMisc, which implies that you can
// align it (center, left, right) and add padding to it, using
// #GtkMisc methods.
//
// #GtkImage is a no window widget (has no #GdkWindow of its own),
// so by default does not receive events. If you want to receive events
// on the image, such as button clicks, place the image inside a
// #GtkEventBox, then connect to the event signals on the event box.
//
// ## Handling button press events on a #GtkImage.
//
// |[<!-- language="C" -->
// static gboolean
// button_press_callback (GtkWidget      *event_box,
// GdkEventButton *event,
// gpointer        data)
// {
// g_print ("Event box clicked at coordinates %f,%f\n",
// event->x, event->y);
//
// Returning TRUE means we handled the event, so the signal
// emission should be stopped (dont call any further callbacks
// that may be connected). Return FALSE to continue invoking callbacks.
// return TRUE;
// }
//
// static GtkWidget*
// create_image (void)
// {
// GtkWidget *image;
// GtkWidget *event_box;
//
// image = gtk_image_new_from_file ("myfile.png");
//
// event_box = gtk_event_box_new ();
//
// gtk_container_add (GTK_CONTAINER (event_box), image);
//
// g_signal_connect (G_OBJECT (event_box),
// "button_press_event",
// G_CALLBACK (button_press_callback),
// image);
//
// return image;
// }
// ]|
//
// When handling events on the event box, keep in mind that coordinates
// in the image may be different from event box coordinates due to
// the alignment and padding settings on the image (see #GtkMisc).
// The simplest way to solve this is to set the alignment to 0.0
// (left/top), and set the padding to zero. Then the origin of
// the image will be the same as the origin of the event box.
//
// Sometimes an application will want to avoid depending on external data
// files, such as image files. GTK+ comes with a program to avoid this,
// called gdk-pixbuf-csource. This library
// allows you to convert an image into a C variable declaration, which
// can then be loaded into a #GdkPixbuf using
// gdk_pixbuf_new_from_inline().
//
// # CSS nodes
//
// GtkImage has a single CSS node with the name image.
/*

C record/class : GtkImage
*/
type Image struct {
	native *C.GtkImage
	// misc : record
	// Private : priv
}

func ImageNewFromC(u unsafe.Pointer) *Image {
	c := (*C.GtkImage)(u)
	if c == nil {
		return nil
	}

	g := &Image{native: c}

	return g
}

func (recv *Image) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Misc upcasts to *Misc
func (recv *Image) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Image) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Image) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Image) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitary Object to Image.
// Exercise care, as this is a potentially dangerous function if the Object is not a Image.
func CastToImage(object *gobject.Object) *Image {
	return ImageNewFromC(object.ToC())
}

// Creates a new empty #GtkImage widget.
/*

C function : gtk_image_new
*/
func ImageNew() *Image {
	retC := C.gtk_image_new()
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a #GtkImage displaying the given animation.
// The #GtkImage does not assume a reference to the
// animation; you still need to unref it if you own references.
// #GtkImage will add its own reference rather than adopting yours.
//
// Note that the animation frames are shown using a timeout with
// #G_PRIORITY_DEFAULT. When using animations to indicate busyness,
// keep in mind that the animation will only be shown if the main loop
// is not busy with something that has a higher priority.
/*

C function : gtk_image_new_from_animation
*/
func ImageNewFromAnimation(animation *gdkpixbuf.PixbufAnimation) *Image {
	c_animation := (*C.GdkPixbufAnimation)(C.NULL)
	if animation != nil {
		c_animation = (*C.GdkPixbufAnimation)(animation.ToC())
	}

	retC := C.gtk_image_new_from_animation(c_animation)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImage displaying the file @filename. If the file
// isnt found or cant be loaded, the resulting #GtkImage will
// display a broken image icon. This function never returns %NULL,
// it always returns a valid #GtkImage widget.
//
// If the file contains an animation, the image will contain an
// animation.
//
// If you need to detect failures to load the file, use
// gdk_pixbuf_new_from_file() to load the file yourself, then create
// the #GtkImage from the pixbuf. (Or for animations, use
// gdk_pixbuf_animation_new_from_file()).
//
// The storage type (gtk_image_get_storage_type()) of the returned
// image is not defined, it will be whatever is appropriate for
// displaying the file.
/*

C function : gtk_image_new_from_file
*/
func ImageNewFromFile(filename string) *Image {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.gtk_image_new_from_file(c_filename)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a #GtkImage displaying an icon set. Sample stock sizes are
// #GTK_ICON_SIZE_MENU, #GTK_ICON_SIZE_SMALL_TOOLBAR. Instead of using
// this function, usually its better to create a #GtkIconFactory, put
// your icon sets in the icon factory, add the icon factory to the
// list of default factories with gtk_icon_factory_add_default(), and
// then use gtk_image_new_from_stock(). This will allow themes to
// override the icon you ship with your application.
//
// The #GtkImage does not assume a reference to the
// icon set; you still need to unref it if you own references.
// #GtkImage will add its own reference rather than adopting yours.
/*

C function : gtk_image_new_from_icon_set
*/
func ImageNewFromIconSet(iconSet *IconSet, size IconSize) *Image {
	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	c_size := (C.GtkIconSize)(size)

	retC := C.gtk_image_new_from_icon_set(c_icon_set, c_size)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImage displaying @pixbuf.
// The #GtkImage does not assume a reference to the
// pixbuf; you still need to unref it if you own references.
// #GtkImage will add its own reference rather than adopting yours.
//
// Note that this function just creates an #GtkImage from the pixbuf. The
// #GtkImage created will not react to state changes. Should you want that,
// you should use gtk_image_new_from_icon_name().
/*

C function : gtk_image_new_from_pixbuf
*/
func ImageNewFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *Image {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	retC := C.gtk_image_new_from_pixbuf(c_pixbuf)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a #GtkImage displaying a stock icon. Sample stock icon
// names are #GTK_STOCK_OPEN, #GTK_STOCK_QUIT. Sample stock sizes
// are #GTK_ICON_SIZE_MENU, #GTK_ICON_SIZE_SMALL_TOOLBAR. If the stock
// icon name isnt known, the image will be empty.
// You can register your own stock icon names, see
// gtk_icon_factory_add_default() and gtk_icon_factory_add().
/*

C function : gtk_image_new_from_stock
*/
func ImageNewFromStock(stockId string, size IconSize) *Image {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	retC := C.gtk_image_new_from_stock(c_stock_id, c_size)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the #GdkPixbufAnimation being displayed by the #GtkImage.
// The storage type of the image must be %GTK_IMAGE_EMPTY or
// %GTK_IMAGE_ANIMATION (see gtk_image_get_storage_type()).
// The caller of this function does not own a reference to the
// returned animation.
/*

C function : gtk_image_get_animation
*/
func (recv *Image) GetAnimation() *gdkpixbuf.PixbufAnimation {
	retC := C.gtk_image_get_animation((*C.GtkImage)(recv.native))
	var retGo (*gdkpixbuf.PixbufAnimation)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufAnimationNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_image_get_icon_set : unsupported parameter size : no type generator for gint (GtkIconSize*) for param size

// Gets the #GdkPixbuf being displayed by the #GtkImage.
// The storage type of the image must be %GTK_IMAGE_EMPTY or
// %GTK_IMAGE_PIXBUF (see gtk_image_get_storage_type()).
// The caller of this function does not own a reference to the
// returned pixbuf.
/*

C function : gtk_image_get_pixbuf
*/
func (recv *Image) GetPixbuf() *gdkpixbuf.Pixbuf {
	retC := C.gtk_image_get_pixbuf((*C.GtkImage)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_image_get_stock : unsupported parameter size : no type generator for gint (GtkIconSize*) for param size

// Gets the type of representation being used by the #GtkImage
// to store image data. If the #GtkImage has no image data,
// the return value will be %GTK_IMAGE_EMPTY.
/*

C function : gtk_image_get_storage_type
*/
func (recv *Image) GetStorageType() ImageType {
	retC := C.gtk_image_get_storage_type((*C.GtkImage)(recv.native))
	retGo := (ImageType)(retC)

	return retGo
}

// Causes the #GtkImage to display the given animation (or display
// nothing, if you set the animation to %NULL).
/*

C function : gtk_image_set_from_animation
*/
func (recv *Image) SetFromAnimation(animation *gdkpixbuf.PixbufAnimation) {
	c_animation := (*C.GdkPixbufAnimation)(C.NULL)
	if animation != nil {
		c_animation = (*C.GdkPixbufAnimation)(animation.ToC())
	}

	C.gtk_image_set_from_animation((*C.GtkImage)(recv.native), c_animation)

	return
}

// See gtk_image_new_from_file() for details.
/*

C function : gtk_image_set_from_file
*/
func (recv *Image) SetFromFile(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_image_set_from_file((*C.GtkImage)(recv.native), c_filename)

	return
}

// See gtk_image_new_from_icon_set() for details.
/*

C function : gtk_image_set_from_icon_set
*/
func (recv *Image) SetFromIconSet(iconSet *IconSet, size IconSize) {
	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	c_size := (C.GtkIconSize)(size)

	C.gtk_image_set_from_icon_set((*C.GtkImage)(recv.native), c_icon_set, c_size)

	return
}

// See gtk_image_new_from_pixbuf() for details.
/*

C function : gtk_image_set_from_pixbuf
*/
func (recv *Image) SetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_image_set_from_pixbuf((*C.GtkImage)(recv.native), c_pixbuf)

	return
}

// See gtk_image_new_from_resource() for details.
/*

C function : gtk_image_set_from_resource
*/
func (recv *Image) SetFromResource(resourcePath string) {
	c_resource_path := C.CString(resourcePath)
	defer C.free(unsafe.Pointer(c_resource_path))

	C.gtk_image_set_from_resource((*C.GtkImage)(recv.native), c_resource_path)

	return
}

// See gtk_image_new_from_stock() for details.
/*

C function : gtk_image_set_from_stock
*/
func (recv *Image) SetFromStock(stockId string, size IconSize) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	C.gtk_image_set_from_stock((*C.GtkImage)(recv.native), c_stock_id, c_size)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Image
func (recv *Image) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Image
func (recv *Image) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkImageAccessible
*/
type ImageAccessible struct {
	native *C.GtkImageAccessible
	// parent : record
	// priv : record
}

func ImageAccessibleNewFromC(u unsafe.Pointer) *ImageAccessible {
	c := (*C.GtkImageAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ImageAccessible{native: c}

	return g
}

func (recv *ImageAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ImageAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ImageAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ImageAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ImageAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageAccessible.
func CastToImageAccessible(object *gobject.Object) *ImageAccessible {
	return ImageAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ImageAccessible
func (recv *ImageAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ImageAccessible
func (recv *ImageAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

/*

C record/class : GtkImageCellAccessible
*/
type ImageCellAccessible struct {
	native *C.GtkImageCellAccessible
	// parent : record
	// priv : record
}

func ImageCellAccessibleNewFromC(u unsafe.Pointer) *ImageCellAccessible {
	c := (*C.GtkImageCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ImageCellAccessible{native: c}

	return g
}

func (recv *ImageCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *ImageCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *ImageCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ImageCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ImageCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ImageCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageCellAccessible.
func CastToImageCellAccessible(object *gobject.Object) *ImageCellAccessible {
	return ImageCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// A GtkImageMenuItem is a menu item which has an icon next to the text label.
//
// This is functionally equivalent to:
//
// |[<!-- language="C" -->
// GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
// GtkWidget *icon = gtk_image_new_from_icon_name ("folder-music-symbolic", GTK_ICON_SIZE_MENU);
// GtkWidget *label = gtk_label_new ("Music");
// GtkWidget *menu_item = gtk_menu_item_new ();
//
// gtk_container_add (GTK_CONTAINER (box), icon);
// gtk_container_add (GTK_CONTAINER (box), label);
//
// gtk_container_add (GTK_CONTAINER (menu_item), box);
//
// gtk_widget_show_all (menu_item);
// ]|
//
// Note that the user may disable display of menu icons using
// the #GtkSettings:gtk-menu-images setting, so make sure to still
// fill in the text label. If you want to ensure that your menu items
// show an icon you are strongly encouraged to use a #GtkMenuItem
// with a #GtkImage instead.
//
// #GtkImageMenuItem has been deprecated since GTK+ 3.10. If you want to
// display an icon in a menu item, you should use #GtkMenuItem and pack a
// #GtkBox with a #GtkImage and a #GtkLabel instead. You should also consider
// using #GtkBuilder and the XML #GMenu description for creating menus, by
// following the [GMenu guide][https://developer.gnome.org/GMenu/]. You should
// consider using icons in menu items only sparingly, and for "objects" (or
// "nouns") elements only, like bookmarks, files, and links; "actions" (or
// "verbs") should not have icons.
//
// Furthermore, if you would like to display keyboard accelerator, you must
// pack the accel label into the box using gtk_box_pack_end() and align the
// label, otherwise the accelerator will not display correctly. The following
// code snippet adds a keyboard accelerator to the menu item, with a key
// binding of Ctrl+M:
//
// |[<!-- language="C" -->
// GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
// GtkWidget *icon = gtk_image_new_from_icon_name ("folder-music-symbolic", GTK_ICON_SIZE_MENU);
// GtkWidget *label = gtk_accel_label_new ("Music");
// GtkWidget *menu_item = gtk_menu_item_new ();
// GtkAccelGroup *accel_group = gtk_accel_group_new ();
//
// gtk_container_add (GTK_CONTAINER (box), icon);
//
// gtk_label_set_use_underline (GTK_LABEL (label), TRUE);
// gtk_label_set_xalign (GTK_LABEL (label), 0.0);
//
// gtk_widget_add_accelerator (menu_item, "activate", accel_group,
// GDK_KEY_m, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
// gtk_accel_label_set_accel_widget (GTK_ACCEL_LABEL (label), menu_item);
//
// gtk_box_pack_end (GTK_BOX (box), label, TRUE, TRUE, 0);
//
// gtk_container_add (GTK_CONTAINER (menu_item), box);
//
// gtk_widget_show_all (menu_item);
// ]|
/*

C record/class : GtkImageMenuItem
*/
type ImageMenuItem struct {
	native *C.GtkImageMenuItem
	// menu_item : record
	// Private : priv
}

func ImageMenuItemNewFromC(u unsafe.Pointer) *ImageMenuItem {
	c := (*C.GtkImageMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &ImageMenuItem{native: c}

	return g
}

func (recv *ImageMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItem upcasts to *MenuItem
func (recv *ImageMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ImageMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *ImageMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *ImageMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ImageMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ImageMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitary Object to ImageMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageMenuItem.
func CastToImageMenuItem(object *gobject.Object) *ImageMenuItem {
	return ImageMenuItemNewFromC(object.ToC())
}

// Creates a new #GtkImageMenuItem with an empty label.
/*

C function : gtk_image_menu_item_new
*/
func ImageMenuItemNew() *ImageMenuItem {
	retC := C.gtk_image_menu_item_new()
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImageMenuItem containing the image and text from a
// stock item. Some stock ids have preprocessor macros like #GTK_STOCK_OK
// and #GTK_STOCK_APPLY.
//
// If you want this menu item to have changeable accelerators, then pass in
// %NULL for accel_group. Next call gtk_menu_item_set_accel_path() with an
// appropriate path for the menu item, use gtk_stock_lookup() to look up the
// standard accelerator for the stock item, and if one is found, call
// gtk_accel_map_add_entry() to register it.
/*

C function : gtk_image_menu_item_new_from_stock
*/
func ImageMenuItemNewFromStock(stockId string, accelGroup *AccelGroup) *ImageMenuItem {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	retC := C.gtk_image_menu_item_new_from_stock(c_stock_id, c_accel_group)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImageMenuItem containing a label.
/*

C function : gtk_image_menu_item_new_with_label
*/
func ImageMenuItemNewWithLabel(label string) *ImageMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_image_menu_item_new_with_label(c_label)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImageMenuItem containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
/*

C function : gtk_image_menu_item_new_with_mnemonic
*/
func ImageMenuItemNewWithMnemonic(label string) *ImageMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_image_menu_item_new_with_mnemonic(c_label)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the widget that is currently set as the image of @image_menu_item.
// See gtk_image_menu_item_set_image().
/*

C function : gtk_image_menu_item_get_image
*/
func (recv *ImageMenuItem) GetImage() *Widget {
	retC := C.gtk_image_menu_item_get_image((*C.GtkImageMenuItem)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the image of @image_menu_item to the given widget.
// Note that it depends on the show-menu-images setting whether
// the image will be displayed or not.
/*

C function : gtk_image_menu_item_set_image
*/
func (recv *ImageMenuItem) SetImage(image *Widget) {
	c_image := (*C.GtkWidget)(C.NULL)
	if image != nil {
		c_image = (*C.GtkWidget)(image.ToC())
	}

	C.gtk_image_menu_item_set_image((*C.GtkImageMenuItem)(recv.native), c_image)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ImageMenuItem
func (recv *ImageMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkInfoBar is a widget that can be used to show messages to
// the user without showing a dialog. It is often temporarily shown
// at the top or bottom of a document. In contrast to #GtkDialog, which
// has a action area at the bottom, #GtkInfoBar has an action area
// at the side.
//
// The API of #GtkInfoBar is very similar to #GtkDialog, allowing you
// to add buttons to the action area with gtk_info_bar_add_button() or
// gtk_info_bar_new_with_buttons(). The sensitivity of action widgets
// can be controlled with gtk_info_bar_set_response_sensitive().
// To add widgets to the main content area of a #GtkInfoBar, use
// gtk_info_bar_get_content_area() and add your widgets to the container.
//
// Similar to #GtkMessageDialog, the contents of a #GtkInfoBar can by
// classified as error message, warning, informational message, etc,
// by using gtk_info_bar_set_message_type(). GTK+ may use the message type
// to determine how the message is displayed.
//
// A simple example for using a #GtkInfoBar:
// |[<!-- language="C" -->
// GtkWidget *widget, *message_label, *content_area;
// GtkWidget *grid;
// GtkInfoBar *bar;
//
// set up info bar
// widget = gtk_info_bar_new ();
// bar = GTK_INFO_BAR (widget);
// grid = gtk_grid_new ();
//
// gtk_widget_set_no_show_all (widget, TRUE);
// message_label = gtk_label_new ("");
// content_area = gtk_info_bar_get_content_area (bar);
// gtk_container_add (GTK_CONTAINER (content_area),
// message_label);
// gtk_info_bar_add_button (bar,
// _("_OK"),
// GTK_RESPONSE_OK);
// g_signal_connect (bar,
// "response",
// G_CALLBACK (gtk_widget_hide),
// NULL);
// gtk_grid_attach (GTK_GRID (grid),
// widget,
// 0, 2, 1, 1);
//
// ...
//
// show an error message
// gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
// gtk_info_bar_set_message_type (bar,
// GTK_MESSAGE_ERROR);
// gtk_widget_show (bar);
// ]|
//
// # GtkInfoBar as GtkBuildable
//
// The GtkInfoBar implementation of the GtkBuildable interface exposes
// the content area and action area as internal children with the names
// content_area and action_area.
//
// GtkInfoBar supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The response attribute specifies a
// numeric response, and the content of the element is the id of widget
// (which should be a child of the dialogs @action_area).
//
// # CSS nodes
//
// GtkInfoBar has a single CSS node with name infobar. The node may get
// one of the style classes .info, .warning, .error or .question, depending
// on the message type.
/*

C record/class : GtkInfoBar
*/
type InfoBar struct {
	native *C.GtkInfoBar
	// parent : record
	// Private : priv
}

func InfoBarNewFromC(u unsafe.Pointer) *InfoBar {
	c := (*C.GtkInfoBar)(u)
	if c == nil {
		return nil
	}

	g := &InfoBar{native: c}

	return g
}

func (recv *InfoBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *InfoBar) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *InfoBar) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *InfoBar) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *InfoBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *InfoBar) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to InfoBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a InfoBar.
func CastToInfoBar(object *gobject.Object) *InfoBar {
	return InfoBarNewFromC(object.ToC())
}

// Unsupported : gtk_info_bar_new_with_buttons : unsupported parameter ... : varargs

// ImplementorIface returns the ImplementorIface interface implemented by InfoBar
func (recv *InfoBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by InfoBar
func (recv *InfoBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by InfoBar
func (recv *InfoBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkInvisible widget is used internally in GTK+, and is probably not
// very useful for application developers.
//
// It is used for reliable pointer grabs and selection handling in the code
// for drag-and-drop.
/*

C record/class : GtkInvisible
*/
type Invisible struct {
	native *C.GtkInvisible
	// widget : record
	// Private : priv
}

func InvisibleNewFromC(u unsafe.Pointer) *Invisible {
	c := (*C.GtkInvisible)(u)
	if c == nil {
		return nil
	}

	g := &Invisible{native: c}

	return g
}

func (recv *Invisible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Invisible) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Invisible) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Invisible) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Invisible.
// Exercise care, as this is a potentially dangerous function if the Object is not a Invisible.
func CastToInvisible(object *gobject.Object) *Invisible {
	return InvisibleNewFromC(object.ToC())
}

// Creates a new #GtkInvisible.
/*

C function : gtk_invisible_new
*/
func InvisibleNew() *Invisible {
	retC := C.gtk_invisible_new()
	retGo := InvisibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Invisible
func (recv *Invisible) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Invisible
func (recv *Invisible) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkLabel widget displays a small amount of text. As the name
// implies, most labels are used to label another widget such as a
// #GtkButton, a #GtkMenuItem, or a #GtkComboBox.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// label
//  [selection]
//  [link]
// 
//  [link]
// ]|
//
// GtkLabel has a single CSS node with the name label. A wide variety
// of style classes may be applied to labels, such as .title, .subtitle,
// .dim-label, etc. In the #GtkShortcutsWindow, labels are used wth the
// .keycap style class.
//
// If the label has a selection, it gets a subnode with name selection.
//
// If the label has links, there is one subnode per link. These subnodes
// carry the link or visited state depending on whether they have been
// visited.
//
// # GtkLabel as GtkBuildable
//
// The GtkLabel implementation of the GtkBuildable interface supports a
// custom <attributes> element, which supports any number of <attribute>
// elements. The <attribute> element has attributes named name, value,
// start and end and allows you to specify #PangoAttribute values for
// this label.
//
// An example of a UI definition fragment specifying Pango attributes:
// |[
// <object class="GtkLabel">
// <attributes>
// <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
// <attribute name="background" value="red" start="5" end="10"/>
// </attributes>
// </object>
// ]|
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
// # Mnemonics
//
// Labels may contain mnemonics. Mnemonics are
// underlined characters in the label, used for keyboard navigation.
// Mnemonics are created by providing a string with an underscore before
// the mnemonic character, such as `"_File"`, to the
// functions gtk_label_new_with_mnemonic() or
// gtk_label_set_text_with_mnemonic().
//
// Mnemonics automatically activate any activatable widget the label is
// inside, such as a #GtkButton; if the label is not inside the
// mnemonics target widget, you have to tell the label about the target
// using gtk_label_set_mnemonic_widget(). Heres a simple example where
// the label is inside a button:
//
// |[<!-- language="C" -->
// Pressing Alt+H will activate this button
// GtkWidget *button = gtk_button_new ();
// GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_container_add (GTK_CONTAINER (button), label);
// ]|
//
// Theres a convenience function to create buttons with a mnemonic label
// already inside:
//
// |[<!-- language="C" -->
// Pressing Alt+H will activate this button
// GtkWidget *button = gtk_button_new_with_mnemonic ("_Hello");
// ]|
//
// To create a mnemonic for a widget alongside the label, such as a
// #GtkEntry, you have to point the label at the entry with
// gtk_label_set_mnemonic_widget():
//
// |[<!-- language="C" -->
// Pressing Alt+H will focus the entry
// GtkWidget *entry = gtk_entry_new ();
// GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry);
// ]|
//
// # Markup (styled text)
//
// To make it easy to format text in a label (changing colors,
// fonts, etc.), label text can be provided in a simple
// [markup format][PangoMarkupFormat].
//
// Heres how to create a label with a small font:
// |[<!-- language="C" -->
// GtkWidget *label = gtk_label_new (NULL);
// gtk_label_set_markup (GTK_LABEL (label), "<small>Small text</small>");
// ]|
//
// (See [complete documentation][PangoMarkupFormat] of available
// tags in the Pango manual.)
//
// The markup passed to gtk_label_set_markup() must be valid; for example,
// literal <, > and & characters must be escaped as &lt;, &gt;, and &amp;.
// If you pass text obtained from the user, file, or a network to
// gtk_label_set_markup(), youll want to escape it with
// g_markup_escape_text() or g_markup_printf_escaped().
//
// Markup strings are just a convenient way to set the #PangoAttrList on
// a label; gtk_label_set_attributes() may be a simpler way to set
// attributes in some cases. Be careful though; #PangoAttrList tends to
// cause internationalization problems, unless youre applying attributes
// to the entire string (i.e. unless you set the range of each attribute
// to [0, %G_MAXINT)). The reason is that specifying the start_index and
// end_index for a #PangoAttribute requires knowledge of the exact string
// being displayed, so translations will cause problems.
//
// # Selectable labels
//
// Labels can be made selectable with gtk_label_set_selectable().
// Selectable labels allow the user to copy the label contents to
// the clipboard. Only labels that contain useful-to-copy information
//  such as error messages  should be made selectable.
//
// # Text layout # {#label-text-layout}
//
// A label can contain any number of paragraphs, but will have
// performance problems if it contains more than a small number.
// Paragraphs are separated by newlines or other paragraph separators
// understood by Pango.
//
// Labels can automatically wrap text if you call
// gtk_label_set_line_wrap().
//
// gtk_label_set_justify() sets how the lines in a label align
// with one another. If you want to set how the label as a whole
// aligns in its available space, see the #GtkWidget:halign and
// #GtkWidget:valign properties.
//
// The #GtkLabel:width-chars and #GtkLabel:max-width-chars properties
// can be used to control the size allocation of ellipsized or wrapped
// labels. For ellipsizing labels, if either is specified (and less
// than the actual text size), it is used as the minimum width, and the actual
// text size is used as the natural width of the label. For wrapping labels,
// width-chars is used as the minimum width, if specified, and max-width-chars
// is used as the natural width. Even if max-width-chars specified, wrapping
// labels will be rewrapped to use all of the available width.
//
// Note that the interpretation of #GtkLabel:width-chars and
// #GtkLabel:max-width-chars has changed a bit with the introduction of
// [width-for-height geometry management.][geometry-management]
//
// # Links
//
// Since 2.18, GTK+ supports markup for clickable hyperlinks in addition
// to regular Pango markup. The markup for links is borrowed from HTML,
// using the `<a>` with href and title attributes. GTK+ renders links
// similar to the way they appear in web browsers, with colored, underlined
// text. The title attribute is displayed as a tooltip on the link.
//
// An example looks like this:
//
// |[<!-- language="C" -->
// const gchar *text =
// "Go to the"
// "<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
// "GTK+ website</a> for more...";
// GtkWidget *label = gtk_label_new (NULL);
// gtk_label_set_markup (GTK_LABEL (label), text);
// ]|
//
// It is possible to implement custom handling for links and their tooltips with
// the #GtkLabel::activate-link signal and the gtk_label_get_current_uri() function.
/*

C record/class : GtkLabel
*/
type Label struct {
	native *C.GtkLabel
	// misc : record
	// Private : priv
}

func LabelNewFromC(u unsafe.Pointer) *Label {
	c := (*C.GtkLabel)(u)
	if c == nil {
		return nil
	}

	g := &Label{native: c}

	return g
}

func (recv *Label) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Misc upcasts to *Misc
func (recv *Label) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Label) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Label) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Label) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitary Object to Label.
// Exercise care, as this is a potentially dangerous function if the Object is not a Label.
func CastToLabel(object *gobject.Object) *Label {
	return LabelNewFromC(object.ToC())
}

type signalLabelCopyClipboardDetail struct {
	callback  LabelSignalCopyClipboardCallback
	handlerID C.gulong
}

var signalLabelCopyClipboardId int
var signalLabelCopyClipboardMap = make(map[int]signalLabelCopyClipboardDetail)
var signalLabelCopyClipboardLock sync.Mutex

// LabelSignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a Label.
type LabelSignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *Label) ConnectCopyClipboard(callback LabelSignalCopyClipboardCallback) int {
	signalLabelCopyClipboardLock.Lock()
	defer signalLabelCopyClipboardLock.Unlock()

	signalLabelCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalLabelCopyClipboardId)))

	detail := signalLabelCopyClipboardDetail{callback, handlerID}
	signalLabelCopyClipboardMap[signalLabelCopyClipboardId] = detail

	return signalLabelCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the Label.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *Label) DisconnectCopyClipboard(connectionID int) {
	signalLabelCopyClipboardLock.Lock()
	defer signalLabelCopyClipboardLock.Unlock()

	detail, exists := signalLabelCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelCopyClipboardMap, connectionID)
}

//export label_copyClipboardHandler
func label_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalLabelCopyClipboardMap[index].callback
	callback()
}

// Unsupported signal 'move-cursor' for Label : unsupported parameter step : type MovementStep :

type signalLabelPopulatePopupDetail struct {
	callback  LabelSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalLabelPopulatePopupId int
var signalLabelPopulatePopupMap = make(map[int]signalLabelPopulatePopupDetail)
var signalLabelPopulatePopupLock sync.Mutex

// LabelSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a Label.
type LabelSignalPopulatePopupCallback func(menu *Menu)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *Label) ConnectPopulatePopup(callback LabelSignalPopulatePopupCallback) int {
	signalLabelPopulatePopupLock.Lock()
	defer signalLabelPopulatePopupLock.Unlock()

	signalLabelPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalLabelPopulatePopupId)))

	detail := signalLabelPopulatePopupDetail{callback, handlerID}
	signalLabelPopulatePopupMap[signalLabelPopulatePopupId] = detail

	return signalLabelPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the Label.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *Label) DisconnectPopulatePopup(connectionID int) {
	signalLabelPopulatePopupLock.Lock()
	defer signalLabelPopulatePopupLock.Unlock()

	detail, exists := signalLabelPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelPopulatePopupMap, connectionID)
}

//export label_populatePopupHandler
func label_populatePopupHandler(_ *C.GObject, c_menu *C.GtkMenu, data C.gpointer) {
	menu := MenuNewFromC(unsafe.Pointer(c_menu))

	index := int(uintptr(data))
	callback := signalLabelPopulatePopupMap[index].callback
	callback(menu)
}

// Creates a new label with the given text inside it. You can
// pass %NULL to get an empty label widget.
/*

C function : gtk_label_new
*/
func LabelNew(str string) *Label {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	retC := C.gtk_label_new(c_str)
	retGo := LabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkLabel, containing the text in @str.
//
// If characters in @str are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use
// '__' (two underscores). The first underlined character represents a
// keyboard accelerator called a mnemonic. The mnemonic key can be used
// to activate another widget, chosen automatically, or explicitly using
// gtk_label_set_mnemonic_widget().
//
// If gtk_label_set_mnemonic_widget() is not called, then the first
// activatable ancestor of the #GtkLabel will be chosen as the mnemonic
// widget. For instance, if the label is inside a button or menu item,
// the button or menu item will automatically become the mnemonic widget
// and be activated by the mnemonic.
/*

C function : gtk_label_new_with_mnemonic
*/
func LabelNewWithMnemonic(str string) *Label {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	retC := C.gtk_label_new_with_mnemonic(c_str)
	retGo := LabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the attribute list that was set on the label using
// gtk_label_set_attributes(), if any. This function does
// not reflect attributes that come from the labels markup
// (see gtk_label_set_markup()). If you want to get the
// effective attributes for the label, use
// pango_layout_get_attribute (gtk_label_get_layout (label)).
/*

C function : gtk_label_get_attributes
*/
func (recv *Label) GetAttributes() *pango.AttrList {
	retC := C.gtk_label_get_attributes((*C.GtkLabel)(recv.native))
	var retGo (*pango.AttrList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = pango.AttrListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the justification of the label. See gtk_label_set_justify().
/*

C function : gtk_label_get_justify
*/
func (recv *Label) GetJustify() Justification {
	retC := C.gtk_label_get_justify((*C.GtkLabel)(recv.native))
	retGo := (Justification)(retC)

	return retGo
}

// Fetches the text from a label widget including any embedded
// underlines indicating mnemonics and Pango markup. (See
// gtk_label_get_text()).
/*

C function : gtk_label_get_label
*/
func (recv *Label) GetLabel() string {
	retC := C.gtk_label_get_label((*C.GtkLabel)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Gets the #PangoLayout used to display the label.
// The layout is useful to e.g. convert text positions to
// pixel positions, in combination with gtk_label_get_layout_offsets().
// The returned layout is owned by the @label so need not be
// freed by the caller. The @label is free to recreate its layout at
// any time, so it should be considered read-only.
/*

C function : gtk_label_get_layout
*/
func (recv *Label) GetLayout() *pango.Layout {
	retC := C.gtk_label_get_layout((*C.GtkLabel)(recv.native))
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Obtains the coordinates where the label will draw the #PangoLayout
// representing the text in the label; useful to convert mouse events
// into coordinates inside the #PangoLayout, e.g. to take some action
// if some part of the label is clicked. Of course you will need to
// create a #GtkEventBox to receive the events, and pack the label
// inside it, since labels are windowless (they return %FALSE from
// gtk_widget_get_has_window()). Remember
// when using the #PangoLayout functions you need to convert to
// and from pixels using PANGO_PIXELS() or #PANGO_SCALE.
/*

C function : gtk_label_get_layout_offsets
*/
func (recv *Label) GetLayoutOffsets() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_label_get_layout_offsets((*C.GtkLabel)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// Returns whether lines in the label are automatically wrapped.
// See gtk_label_set_line_wrap().
/*

C function : gtk_label_get_line_wrap
*/
func (recv *Label) GetLineWrap() bool {
	retC := C.gtk_label_get_line_wrap((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// If the label has been set so that it has an mnemonic key this function
// returns the keyval used for the mnemonic accelerator. If there is no
// mnemonic set up it returns #GDK_KEY_VoidSymbol.
/*

C function : gtk_label_get_mnemonic_keyval
*/
func (recv *Label) GetMnemonicKeyval() uint32 {
	retC := C.gtk_label_get_mnemonic_keyval((*C.GtkLabel)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Retrieves the target of the mnemonic (keyboard shortcut) of this
// label. See gtk_label_set_mnemonic_widget().
/*

C function : gtk_label_get_mnemonic_widget
*/
func (recv *Label) GetMnemonicWidget() *Widget {
	retC := C.gtk_label_get_mnemonic_widget((*C.GtkLabel)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets the value set by gtk_label_set_selectable().
/*

C function : gtk_label_get_selectable
*/
func (recv *Label) GetSelectable() bool {
	retC := C.gtk_label_get_selectable((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the selected range of characters in the label, returning %TRUE
// if theres a selection.
/*

C function : gtk_label_get_selection_bounds
*/
func (recv *Label) GetSelectionBounds() (bool, int32, int32) {
	var c_start C.gint

	var c_end C.gint

	retC := C.gtk_label_get_selection_bounds((*C.GtkLabel)(recv.native), &c_start, &c_end)
	retGo := retC == C.TRUE

	start := (int32)(c_start)

	end := (int32)(c_end)

	return retGo, start, end
}

// Fetches the text from a label widget, as displayed on the
// screen. This does not include any embedded underlines
// indicating mnemonics or Pango markup. (See gtk_label_get_label())
/*

C function : gtk_label_get_text
*/
func (recv *Label) GetText() string {
	retC := C.gtk_label_get_text((*C.GtkLabel)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Returns whether the labels text is interpreted as marked up with
// the [Pango text markup language][PangoMarkupFormat].
// See gtk_label_set_use_markup ().
/*

C function : gtk_label_get_use_markup
*/
func (recv *Label) GetUseMarkup() bool {
	retC := C.gtk_label_get_use_markup((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether an embedded underline in the label indicates a
// mnemonic. See gtk_label_set_use_underline().
/*

C function : gtk_label_get_use_underline
*/
func (recv *Label) GetUseUnderline() bool {
	retC := C.gtk_label_get_use_underline((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Selects a range of characters in the label, if the label is selectable.
// See gtk_label_set_selectable(). If the label is not selectable,
// this function has no effect. If @start_offset or
// @end_offset are -1, then the end of the label will be substituted.
/*

C function : gtk_label_select_region
*/
func (recv *Label) SelectRegion(startOffset int32, endOffset int32) {
	c_start_offset := (C.gint)(startOffset)

	c_end_offset := (C.gint)(endOffset)

	C.gtk_label_select_region((*C.GtkLabel)(recv.native), c_start_offset, c_end_offset)

	return
}

// Sets a #PangoAttrList; the attributes in the list are applied to the
// label text.
//
// The attributes set with this function will be applied
// and merged with any other attributes previously effected by way
// of the #GtkLabel:use-underline or #GtkLabel:use-markup properties.
// While it is not recommended to mix markup strings with manually set
// attributes, if you must; know that the attributes will be applied
// to the label after the markup string is parsed.
/*

C function : gtk_label_set_attributes
*/
func (recv *Label) SetAttributes(attrs *pango.AttrList) {
	c_attrs := (*C.PangoAttrList)(C.NULL)
	if attrs != nil {
		c_attrs = (*C.PangoAttrList)(attrs.ToC())
	}

	C.gtk_label_set_attributes((*C.GtkLabel)(recv.native), c_attrs)

	return
}

// Sets the alignment of the lines in the text of the label relative to
// each other. %GTK_JUSTIFY_LEFT is the default value when the widget is
// first created with gtk_label_new(). If you instead want to set the
// alignment of the label as a whole, use gtk_widget_set_halign() instead.
// gtk_label_set_justify() has no effect on labels containing only a
// single line.
/*

C function : gtk_label_set_justify
*/
func (recv *Label) SetJustify(jtype Justification) {
	c_jtype := (C.GtkJustification)(jtype)

	C.gtk_label_set_justify((*C.GtkLabel)(recv.native), c_jtype)

	return
}

// Sets the text of the label. The label is interpreted as
// including embedded underlines and/or Pango markup depending
// on the values of the #GtkLabel:use-underline and
// #GtkLabel:use-markup properties.
/*

C function : gtk_label_set_label
*/
func (recv *Label) SetLabel(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_label((*C.GtkLabel)(recv.native), c_str)

	return
}

// Toggles line wrapping within the #GtkLabel widget. %TRUE makes it break
// lines if text exceeds the widgets size. %FALSE lets the text get cut off
// by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to %TRUE does not make the label
// wrap at its parent containers width, because GTK+ widgets
// conceptually cant make their requisition depend on the parent
// containers size. For a label that wraps at a specific position,
// set the labels width using gtk_widget_set_size_request().
/*

C function : gtk_label_set_line_wrap
*/
func (recv *Label) SetLineWrap(wrap bool) {
	c_wrap :=
		boolToGboolean(wrap)

	C.gtk_label_set_line_wrap((*C.GtkLabel)(recv.native), c_wrap)

	return
}

// Parses @str which is marked up with the
// [Pango text markup language][PangoMarkupFormat], setting the
// labels text and attribute list based on the parse results.
//
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
// |[<!-- language="C" -->
// GtkWidget *label = gtk_label_new (NULL);
// const char *str = "some text";
// const char *format = "<span style=\"italic\">\%s</span>";
// char *markup;
//
// markup = g_markup_printf_escaped (format, str);
// gtk_label_set_markup (GTK_LABEL (label), markup);
// g_free (markup);
// ]|
//
// This function will set the #GtkLabel:use-markup property to %TRUE as
// a side effect.
//
// If you set the label contents using the #GtkLabel:label property you
// should also ensure that you set the #GtkLabel:use-markup property
// accordingly.
//
// See also: gtk_label_set_text()
/*

C function : gtk_label_set_markup
*/
func (recv *Label) SetMarkup(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_markup((*C.GtkLabel)(recv.native), c_str)

	return
}

// Parses @str which is marked up with the
// [Pango text markup language][PangoMarkupFormat],
// setting the labels text and attribute list based on the parse results.
// If characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
/*

C function : gtk_label_set_markup_with_mnemonic
*/
func (recv *Label) SetMarkupWithMnemonic(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_markup_with_mnemonic((*C.GtkLabel)(recv.native), c_str)

	return
}

// If the label has been set so that it has an mnemonic key (using
// i.e. gtk_label_set_markup_with_mnemonic(),
// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic()
// or the use_underline property) the label can be associated with a
// widget that is the target of the mnemonic. When the label is inside
// a widget (like a #GtkButton or a #GtkNotebook tab) it is
// automatically associated with the correct widget, but sometimes
// (i.e. when the target is a #GtkEntry next to the label) you need to
// set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// GtkWidget::mnemonic-activate signal on it. The default handler for
// this signal will activate the widget if there are no mnemonic collisions
// and toggle focus between the colliding widgets otherwise.
/*

C function : gtk_label_set_mnemonic_widget
*/
func (recv *Label) SetMnemonicWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_label_set_mnemonic_widget((*C.GtkLabel)(recv.native), c_widget)

	return
}

// The pattern of underlines you want under the existing text within the
// #GtkLabel widget.  For example if the current text of the label says
// FooBarBaz passing a pattern of ___   ___ will underline
// Foo and Baz but not Bar.
/*

C function : gtk_label_set_pattern
*/
func (recv *Label) SetPattern(pattern string) {
	c_pattern := C.CString(pattern)
	defer C.free(unsafe.Pointer(c_pattern))

	C.gtk_label_set_pattern((*C.GtkLabel)(recv.native), c_pattern)

	return
}

// Selectable labels allow the user to select text from the label, for
// copy-and-paste.
/*

C function : gtk_label_set_selectable
*/
func (recv *Label) SetSelectable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_selectable((*C.GtkLabel)(recv.native), c_setting)

	return
}

// Sets the text within the #GtkLabel widget. It overwrites any text that
// was there before.
//
// This function will clear any previously set mnemonic accelerators, and
// set the #GtkLabel:use-underline property to %FALSE as a side effect.
//
// This function will set the #GtkLabel:use-markup property to %FALSE
// as a side effect.
//
// See also: gtk_label_set_markup()
/*

C function : gtk_label_set_text
*/
func (recv *Label) SetText(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_text((*C.GtkLabel)(recv.native), c_str)

	return
}

// Sets the labels text from the string @str.
// If characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
/*

C function : gtk_label_set_text_with_mnemonic
*/
func (recv *Label) SetTextWithMnemonic(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_text_with_mnemonic((*C.GtkLabel)(recv.native), c_str)

	return
}

// Sets whether the text of the label contains markup in
// [Pangos text markup language][PangoMarkupFormat].
// See gtk_label_set_markup().
/*

C function : gtk_label_set_use_markup
*/
func (recv *Label) SetUseMarkup(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_use_markup((*C.GtkLabel)(recv.native), c_setting)

	return
}

// If true, an underline in the text indicates the next character should be
// used for the mnemonic accelerator key.
/*

C function : gtk_label_set_use_underline
*/
func (recv *Label) SetUseUnderline(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_use_underline((*C.GtkLabel)(recv.native), c_setting)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Label
func (recv *Label) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Label
func (recv *Label) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkLabelAccessible
*/
type LabelAccessible struct {
	native *C.GtkLabelAccessible
	// parent : record
	// priv : record
}

func LabelAccessibleNewFromC(u unsafe.Pointer) *LabelAccessible {
	c := (*C.GtkLabelAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LabelAccessible{native: c}

	return g
}

func (recv *LabelAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LabelAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *LabelAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LabelAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to LabelAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LabelAccessible.
func CastToLabelAccessible(object *gobject.Object) *LabelAccessible {
	return LabelAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by LabelAccessible
func (recv *LabelAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Hypertext returns the Hypertext interface implemented by LabelAccessible
func (recv *LabelAccessible) Hypertext() *atk.Hypertext {
	return atk.HypertextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by LabelAccessible
func (recv *LabelAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// #GtkLayout is similar to #GtkDrawingArea in that its a blank slate and
// doesnt do anything except paint a blank background by default. Its
// different in that it supports scrolling natively due to implementing
// #GtkScrollable, and can contain child widgets since its a #GtkContainer.
//
// If you just want to draw, a #GtkDrawingArea is a better choice since it has
// lower overhead. If you just need to position child widgets at specific
// points, then #GtkFixed provides that functionality on its own.
//
// When handling expose events on a #GtkLayout, you must draw to the #GdkWindow
// returned by gtk_layout_get_bin_window(), rather than to the one returned by
// gtk_widget_get_window() as you would for a #GtkDrawingArea.
/*

C record/class : GtkLayout
*/
type Layout struct {
	native *C.GtkLayout
	// container : record
	// Private : priv
}

func LayoutNewFromC(u unsafe.Pointer) *Layout {
	c := (*C.GtkLayout)(u)
	if c == nil {
		return nil
	}

	g := &Layout{native: c}

	return g
}

func (recv *Layout) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Layout) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Layout) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Layout) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Layout) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Layout.
// Exercise care, as this is a potentially dangerous function if the Object is not a Layout.
func CastToLayout(object *gobject.Object) *Layout {
	return LayoutNewFromC(object.ToC())
}

// Creates a new #GtkLayout. Unless you have a specific adjustment
// youd like the layout to use for scrolling, pass %NULL for
// @hadjustment and @vadjustment.
/*

C function : gtk_layout_new
*/
func LayoutNew(hadjustment *Adjustment, vadjustment *Adjustment) *Layout {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_layout_new(c_hadjustment, c_vadjustment)
	retGo := LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This function should only be called after the layout has been
// placed in a #GtkScrolledWindow or otherwise configured for
// scrolling. It returns the #GtkAdjustment used for communication
// between the horizontal scrollbar and @layout.
//
// See #GtkScrolledWindow, #GtkScrollbar, #GtkAdjustment for details.
/*

C function : gtk_layout_get_hadjustment
*/
func (recv *Layout) GetHadjustment() *Adjustment {
	retC := C.gtk_layout_get_hadjustment((*C.GtkLayout)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the size that has been set on the layout, and that determines
// the total extents of the layouts scrollbar area. See
// gtk_layout_set_size ().
/*

C function : gtk_layout_get_size
*/
func (recv *Layout) GetSize() (uint32, uint32) {
	var c_width C.guint

	var c_height C.guint

	C.gtk_layout_get_size((*C.GtkLayout)(recv.native), &c_width, &c_height)

	width := (uint32)(c_width)

	height := (uint32)(c_height)

	return width, height
}

// This function should only be called after the layout has been
// placed in a #GtkScrolledWindow or otherwise configured for
// scrolling. It returns the #GtkAdjustment used for communication
// between the vertical scrollbar and @layout.
//
// See #GtkScrolledWindow, #GtkScrollbar, #GtkAdjustment for details.
/*

C function : gtk_layout_get_vadjustment
*/
func (recv *Layout) GetVadjustment() *Adjustment {
	retC := C.gtk_layout_get_vadjustment((*C.GtkLayout)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Moves a current child of @layout to a new position.
/*

C function : gtk_layout_move
*/
func (recv *Layout) Move(childWidget *Widget, x int32, y int32) {
	c_child_widget := (*C.GtkWidget)(C.NULL)
	if childWidget != nil {
		c_child_widget = (*C.GtkWidget)(childWidget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_layout_move((*C.GtkLayout)(recv.native), c_child_widget, c_x, c_y)

	return
}

// Adds @child_widget to @layout, at position (@x,@y).
// @layout becomes the new parent container of @child_widget.
/*

C function : gtk_layout_put
*/
func (recv *Layout) Put(childWidget *Widget, x int32, y int32) {
	c_child_widget := (*C.GtkWidget)(C.NULL)
	if childWidget != nil {
		c_child_widget = (*C.GtkWidget)(childWidget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_layout_put((*C.GtkLayout)(recv.native), c_child_widget, c_x, c_y)

	return
}

// Sets the horizontal scroll adjustment for the layout.
//
// See #GtkScrolledWindow, #GtkScrollbar, #GtkAdjustment for details.
/*

C function : gtk_layout_set_hadjustment
*/
func (recv *Layout) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_layout_set_hadjustment((*C.GtkLayout)(recv.native), c_adjustment)

	return
}

// Sets the size of the scrollable area of the layout.
/*

C function : gtk_layout_set_size
*/
func (recv *Layout) SetSize(width uint32, height uint32) {
	c_width := (C.guint)(width)

	c_height := (C.guint)(height)

	C.gtk_layout_set_size((*C.GtkLayout)(recv.native), c_width, c_height)

	return
}

// Sets the vertical scroll adjustment for the layout.
//
// See #GtkScrolledWindow, #GtkScrollbar, #GtkAdjustment for details.
/*

C function : gtk_layout_set_vadjustment
*/
func (recv *Layout) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_layout_set_vadjustment((*C.GtkLayout)(recv.native), c_adjustment)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Layout
func (recv *Layout) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Layout
func (recv *Layout) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by Layout
func (recv *Layout) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// The #GtkLevelBar is a bar widget that can be used
// as a level indicator. Typical use cases are displaying the strength
// of a password, or showing the charge level of a battery.
//
// Use gtk_level_bar_set_value() to set the current value, and
// gtk_level_bar_add_offset_value() to set the value offsets at which
// the bar will be considered in a different state. GTK will add a few
// offsets by default on the level bar: #GTK_LEVEL_BAR_OFFSET_LOW,
// #GTK_LEVEL_BAR_OFFSET_HIGH and #GTK_LEVEL_BAR_OFFSET_FULL, with
// values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets
// when changing the minimum or maximum value. GTK+ will simply clamp
// them to the new range.
//
// ## Adding a custom offset on the bar
//
// |[<!-- language="C" -->
//
// static GtkWidget *
// create_level_bar (void)
// {
// GtkWidget *widget;
// GtkLevelBar *bar;
//
// widget = gtk_level_bar_new ();
// bar = GTK_LEVEL_BAR (widget);
//
// This changes the value of the default low offset
//
// gtk_level_bar_add_offset_value (bar,
// GTK_LEVEL_BAR_OFFSET_LOW,
// 0.10);
//
// This adds a new offset to the bar; the application will
// be able to change its color CSS like this:
//
// levelbar block.my-offset {
//   background-color: magenta;
//   border-style: solid;
//   border-color: black;
//   border-style: 1px;
// }
//
// gtk_level_bar_add_offset_value (bar, "my-offset", 0.60);
//
// return widget;
// }
// ]|
//
// The default interval of values is between zero and one, but its possible to
// modify the interval using gtk_level_bar_set_min_value() and
// gtk_level_bar_set_max_value(). The value will be always drawn in proportion to
// the admissible interval, i.e. a value of 15 with a specified interval between
// 10 and 20 is equivalent to a value of 0.5 with an interval between 0 and 1.
// When #GTK_LEVEL_BAR_MODE_DISCRETE is used, the bar level is rendered
// as a finite number of separated blocks instead of a single one. The number
// of blocks that will be rendered is equal to the number of units specified by
// the admissible interval.
//
// For instance, to build a bar rendered with five blocks, its sufficient to
// set the minimum value to 0 and the maximum value to 5 after changing the indicator
// mode to discrete.
//
// GtkLevelBar was introduced in GTK+ 3.6.
//
// # GtkLevelBar as GtkBuildable
//
// The GtkLevelBar implementation of the GtkBuildable interface supports a
// custom <offsets> element, which can contain any number of <offset> elements,
// each of which must have name and value attributes.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// levelbar[.discrete]
//  trough
//  block.filled.level-name
// 
//  block.empty
// 
// ]|
//
// GtkLevelBar has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled
// or .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name corresponding
// to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
/*

C record/class : GtkLevelBar
*/
type LevelBar struct {
	native *C.GtkLevelBar
	// Private : parent
	// Private : priv
}

func LevelBarNewFromC(u unsafe.Pointer) *LevelBar {
	c := (*C.GtkLevelBar)(u)
	if c == nil {
		return nil
	}

	g := &LevelBar{native: c}

	return g
}

func (recv *LevelBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *LevelBar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LevelBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LevelBar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to LevelBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a LevelBar.
func CastToLevelBar(object *gobject.Object) *LevelBar {
	return LevelBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by LevelBar
func (recv *LevelBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LevelBar
func (recv *LevelBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by LevelBar
func (recv *LevelBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkLevelBarAccessible
*/
type LevelBarAccessible struct {
	native *C.GtkLevelBarAccessible
	// parent : record
	// priv : record
}

func LevelBarAccessibleNewFromC(u unsafe.Pointer) *LevelBarAccessible {
	c := (*C.GtkLevelBarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LevelBarAccessible{native: c}

	return g
}

func (recv *LevelBarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LevelBarAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *LevelBarAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LevelBarAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to LevelBarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LevelBarAccessible.
func CastToLevelBarAccessible(object *gobject.Object) *LevelBarAccessible {
	return LevelBarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by LevelBarAccessible
func (recv *LevelBarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by LevelBarAccessible
func (recv *LevelBarAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// A GtkLinkButton is a #GtkButton with a hyperlink, similar to the one
// used by web browsers, which triggers an action when clicked. It is useful
// to show quick links to resources.
//
// A link button is created by calling either gtk_link_button_new() or
// gtk_link_button_new_with_label(). If using the former, the URI you pass
// to the constructor is used as a label for the widget.
//
// The URI bound to a GtkLinkButton can be set specifically using
// gtk_link_button_set_uri(), and retrieved using gtk_link_button_get_uri().
//
// By default, GtkLinkButton calls gtk_show_uri_on_window() when the button is
// clicked. This behaviour can be overridden by connecting to the
// #GtkLinkButton::activate-link signal and returning %TRUE from the
// signal handler.
//
// # CSS nodes
//
// GtkLinkButton has a single CSS node with name button. To differentiate
// it from a plain #GtkButton, it gets the .link style class.
/*

C record/class : GtkLinkButton
*/
type LinkButton struct {
	native *C.GtkLinkButton
	// Private : parent_instance
	// Private : priv
}

func LinkButtonNewFromC(u unsafe.Pointer) *LinkButton {
	c := (*C.GtkLinkButton)(u)
	if c == nil {
		return nil
	}

	g := &LinkButton{native: c}

	return g
}

func (recv *LinkButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *LinkButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *LinkButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *LinkButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *LinkButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LinkButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LinkButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to LinkButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a LinkButton.
func CastToLinkButton(object *gobject.Object) *LinkButton {
	return LinkButtonNewFromC(object.ToC())
}

type signalLinkButtonActivateLinkDetail struct {
	callback  LinkButtonSignalActivateLinkCallback
	handlerID C.gulong
}

var signalLinkButtonActivateLinkId int
var signalLinkButtonActivateLinkMap = make(map[int]signalLinkButtonActivateLinkDetail)
var signalLinkButtonActivateLinkLock sync.Mutex

// LinkButtonSignalActivateLinkCallback is a callback function for a 'activate-link' signal emitted from a LinkButton.
type LinkButtonSignalActivateLinkCallback func() bool

/*
ConnectActivateLink connects the callback to the 'activate-link' signal for the LinkButton.

The returned value represents the connection, and may be passed to DisconnectActivateLink to remove it.
*/
func (recv *LinkButton) ConnectActivateLink(callback LinkButtonSignalActivateLinkCallback) int {
	signalLinkButtonActivateLinkLock.Lock()
	defer signalLinkButtonActivateLinkLock.Unlock()

	signalLinkButtonActivateLinkId++
	instance := C.gpointer(recv.native)
	handlerID := C.LinkButton_signal_connect_activate_link(instance, C.gpointer(uintptr(signalLinkButtonActivateLinkId)))

	detail := signalLinkButtonActivateLinkDetail{callback, handlerID}
	signalLinkButtonActivateLinkMap[signalLinkButtonActivateLinkId] = detail

	return signalLinkButtonActivateLinkId
}

/*
DisconnectActivateLink disconnects a callback from the 'activate-link' signal for the LinkButton.

The connectionID should be a value returned from a call to ConnectActivateLink.
*/
func (recv *LinkButton) DisconnectActivateLink(connectionID int) {
	signalLinkButtonActivateLinkLock.Lock()
	defer signalLinkButtonActivateLinkLock.Unlock()

	detail, exists := signalLinkButtonActivateLinkMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLinkButtonActivateLinkMap, connectionID)
}

//export linkbutton_activateLinkHandler
func linkbutton_activateLinkHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalLinkButtonActivateLinkMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// ImplementorIface returns the ImplementorIface interface implemented by LinkButton
func (recv *LinkButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by LinkButton
func (recv *LinkButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by LinkButton
func (recv *LinkButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LinkButton
func (recv *LinkButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkLinkButtonAccessible
*/
type LinkButtonAccessible struct {
	native *C.GtkLinkButtonAccessible
	// parent : record
	// priv : record
}

func LinkButtonAccessibleNewFromC(u unsafe.Pointer) *LinkButtonAccessible {
	c := (*C.GtkLinkButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LinkButtonAccessible{native: c}

	return g
}

func (recv *LinkButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *LinkButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *LinkButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LinkButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *LinkButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LinkButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to LinkButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LinkButtonAccessible.
func CastToLinkButtonAccessible(object *gobject.Object) *LinkButtonAccessible {
	return LinkButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// HyperlinkImpl returns the HyperlinkImpl interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) HyperlinkImpl() *atk.HyperlinkImpl {
	return atk.HyperlinkImplNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// A GtkListBox is a vertical container that contains GtkListBoxRow
// children. These rows can by dynamically sorted and filtered, and
// headers can be added dynamically depending on the row content.
// It also allows keyboard and mouse navigation and selection like
// a typical list.
//
// Using GtkListBox is often an alternative to #GtkTreeView, especially
// when the list contents has a more complicated layout than what is allowed
// by a #GtkCellRenderer, or when the contents is interactive (i.e. has a
// button in it).
//
// Although a #GtkListBox must have only #GtkListBoxRow children you can
// add any kind of widget to it via gtk_container_add(), and a #GtkListBoxRow
// widget will automatically be inserted between the list and the widget.
//
// #GtkListBoxRows can be marked as activatable or selectable. If a row
// is activatable, #GtkListBox::row-activated will be emitted for it when
// the user tries to activate it. If it is selectable, the row will be marked
// as selected when the user tries to select it.
//
// The GtkListBox widget was added in GTK+ 3.10.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// list
//  row[.activatable]
// ]|
//
// GtkListBox uses a single CSS node named list. Each GtkListBoxRow uses
// a single CSS node named row. The row nodes get the .activatable
// style class added when appropriate.
/*

C record/class : GtkListBox
*/
type ListBox struct {
	native *C.GtkListBox
	// parent_instance : record
}

func ListBoxNewFromC(u unsafe.Pointer) *ListBox {
	c := (*C.GtkListBox)(u)
	if c == nil {
		return nil
	}

	g := &ListBox{native: c}

	return g
}

func (recv *ListBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *ListBox) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ListBox) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ListBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ListBox) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to ListBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBox.
func CastToListBox(object *gobject.Object) *ListBox {
	return ListBoxNewFromC(object.ToC())
}

type signalListBoxActivateCursorRowDetail struct {
	callback  ListBoxSignalActivateCursorRowCallback
	handlerID C.gulong
}

var signalListBoxActivateCursorRowId int
var signalListBoxActivateCursorRowMap = make(map[int]signalListBoxActivateCursorRowDetail)
var signalListBoxActivateCursorRowLock sync.Mutex

// ListBoxSignalActivateCursorRowCallback is a callback function for a 'activate-cursor-row' signal emitted from a ListBox.
type ListBoxSignalActivateCursorRowCallback func()

/*
ConnectActivateCursorRow connects the callback to the 'activate-cursor-row' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectActivateCursorRow to remove it.
*/
func (recv *ListBox) ConnectActivateCursorRow(callback ListBoxSignalActivateCursorRowCallback) int {
	signalListBoxActivateCursorRowLock.Lock()
	defer signalListBoxActivateCursorRowLock.Unlock()

	signalListBoxActivateCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_activate_cursor_row(instance, C.gpointer(uintptr(signalListBoxActivateCursorRowId)))

	detail := signalListBoxActivateCursorRowDetail{callback, handlerID}
	signalListBoxActivateCursorRowMap[signalListBoxActivateCursorRowId] = detail

	return signalListBoxActivateCursorRowId
}

/*
DisconnectActivateCursorRow disconnects a callback from the 'activate-cursor-row' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectActivateCursorRow.
*/
func (recv *ListBox) DisconnectActivateCursorRow(connectionID int) {
	signalListBoxActivateCursorRowLock.Lock()
	defer signalListBoxActivateCursorRowLock.Unlock()

	detail, exists := signalListBoxActivateCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxActivateCursorRowMap, connectionID)
}

//export listbox_activateCursorRowHandler
func listbox_activateCursorRowHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalListBoxActivateCursorRowMap[index].callback
	callback()
}

// Unsupported signal 'move-cursor' for ListBox : unsupported parameter object : type MovementStep :

type signalListBoxToggleCursorRowDetail struct {
	callback  ListBoxSignalToggleCursorRowCallback
	handlerID C.gulong
}

var signalListBoxToggleCursorRowId int
var signalListBoxToggleCursorRowMap = make(map[int]signalListBoxToggleCursorRowDetail)
var signalListBoxToggleCursorRowLock sync.Mutex

// ListBoxSignalToggleCursorRowCallback is a callback function for a 'toggle-cursor-row' signal emitted from a ListBox.
type ListBoxSignalToggleCursorRowCallback func()

/*
ConnectToggleCursorRow connects the callback to the 'toggle-cursor-row' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectToggleCursorRow to remove it.
*/
func (recv *ListBox) ConnectToggleCursorRow(callback ListBoxSignalToggleCursorRowCallback) int {
	signalListBoxToggleCursorRowLock.Lock()
	defer signalListBoxToggleCursorRowLock.Unlock()

	signalListBoxToggleCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_toggle_cursor_row(instance, C.gpointer(uintptr(signalListBoxToggleCursorRowId)))

	detail := signalListBoxToggleCursorRowDetail{callback, handlerID}
	signalListBoxToggleCursorRowMap[signalListBoxToggleCursorRowId] = detail

	return signalListBoxToggleCursorRowId
}

/*
DisconnectToggleCursorRow disconnects a callback from the 'toggle-cursor-row' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectToggleCursorRow.
*/
func (recv *ListBox) DisconnectToggleCursorRow(connectionID int) {
	signalListBoxToggleCursorRowLock.Lock()
	defer signalListBoxToggleCursorRowLock.Unlock()

	detail, exists := signalListBoxToggleCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxToggleCursorRowMap, connectionID)
}

//export listbox_toggleCursorRowHandler
func listbox_toggleCursorRowHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalListBoxToggleCursorRowMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ListBox
func (recv *ListBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ListBox
func (recv *ListBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkListBoxAccessible
*/
type ListBoxAccessible struct {
	native *C.GtkListBoxAccessible
	// parent : record
	// priv : record
}

func ListBoxAccessibleNewFromC(u unsafe.Pointer) *ListBoxAccessible {
	c := (*C.GtkListBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxAccessible{native: c}

	return g
}

func (recv *ListBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ListBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ListBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ListBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ListBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ListBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxAccessible.
func CastToListBoxAccessible(object *gobject.Object) *ListBoxAccessible {
	return ListBoxAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ListBoxAccessible
func (recv *ListBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by ListBoxAccessible
func (recv *ListBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

/*

C record/class : GtkListBoxRow
*/
type ListBoxRow struct {
	native *C.GtkListBoxRow
	// parent_instance : record
}

func ListBoxRowNewFromC(u unsafe.Pointer) *ListBoxRow {
	c := (*C.GtkListBoxRow)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRow{native: c}

	return g
}

func (recv *ListBoxRow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ListBoxRow) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ListBoxRow) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ListBoxRow) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ListBoxRow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ListBoxRow) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ListBoxRow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxRow.
func CastToListBoxRow(object *gobject.Object) *ListBoxRow {
	return ListBoxRowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ListBoxRow
func (recv *ListBoxRow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ListBoxRow
func (recv *ListBoxRow) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ListBoxRow
func (recv *ListBoxRow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkListBoxRowAccessible
*/
type ListBoxRowAccessible struct {
	native *C.GtkListBoxRowAccessible
	// parent : record
}

func ListBoxRowAccessibleNewFromC(u unsafe.Pointer) *ListBoxRowAccessible {
	c := (*C.GtkListBoxRowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRowAccessible{native: c}

	return g
}

func (recv *ListBoxRowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ListBoxRowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ListBoxRowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ListBoxRowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ListBoxRowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ListBoxRowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxRowAccessible.
func CastToListBoxRowAccessible(object *gobject.Object) *ListBoxRowAccessible {
	return ListBoxRowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ListBoxRowAccessible
func (recv *ListBoxRowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// The #GtkListStore object is a list model for use with a #GtkTreeView
// widget.  It implements the #GtkTreeModel interface, and consequentialy,
// can use all of the methods available there.  It also implements the
// #GtkTreeSortable interface so it can be sorted by the view.
// Finally, it also implements the tree
// [drag and drop][gtk3-GtkTreeView-drag-and-drop]
// interfaces.
//
// The #GtkListStore can accept most GObject types as a column type, though
// it cant accept all custom types.  Internally, it will keep a copy of
// data passed in (such as a string or a boxed pointer).  Columns that
// accept #GObjects are handled a little differently.  The
// #GtkListStore will keep a reference to the object instead of copying the
// value.  As a result, if the object is modified, it is up to the
// application writer to call gtk_tree_model_row_changed() to emit the
// #GtkTreeModel::row_changed signal.  This most commonly affects lists with
// #GdkPixbufs stored.
//
// An example for creating a simple list store:
// |[<!-- language="C" -->
// enum {
// COLUMN_STRING,
// COLUMN_INT,
// COLUMN_BOOLEAN,
// N_COLUMNS
// };
//
// {
// GtkListStore *list_store;
// GtkTreePath *path;
// GtkTreeIter iter;
// gint i;
//
// list_store = gtk_list_store_new (N_COLUMNS,
// G_TYPE_STRING,
// G_TYPE_INT,
// G_TYPE_BOOLEAN);
//
// for (i = 0; i < 10; i++)
// {
// gchar *some_data;
//
// some_data = get_some_data (i);
//
// Add a new row to the model
// gtk_list_store_append (list_store, &iter);
// gtk_list_store_set (list_store, &iter,
// COLUMN_STRING, some_data,
// COLUMN_INT, i,
// COLUMN_BOOLEAN,  FALSE,
// -1);
//
// As the store will keep a copy of the string internally,
// we free some_data.
// g_free (some_data);
// }
//
// Modify a particular row
// path = gtk_tree_path_new_from_string ("4");
// gtk_tree_model_get_iter (GTK_TREE_MODEL (list_store),
// &iter,
// path);
// gtk_tree_path_free (path);
// gtk_list_store_set (list_store, &iter,
// COLUMN_BOOLEAN, TRUE,
// -1);
// }
// ]|
//
// # Performance Considerations
//
// Internally, the #GtkListStore was implemented with a linked list with
// a tail pointer prior to GTK+ 2.6.  As a result, it was fast at data
// insertion and deletion, and not fast at random data access.  The
// #GtkListStore sets the #GTK_TREE_MODEL_ITERS_PERSIST flag, which means
// that #GtkTreeIters can be cached while the row exists.  Thus, if
// access to a particular row is needed often and your code is expected to
// run on older versions of GTK+, it is worth keeping the iter around.
//
// # Atomic Operations
//
// It is important to note that only the methods
// gtk_list_store_insert_with_values() and gtk_list_store_insert_with_valuesv()
// are atomic, in the sense that the row is being appended to the store and the
// values filled in in a single operation with regard to #GtkTreeModel signaling.
// In contrast, using e.g. gtk_list_store_append() and then gtk_list_store_set()
// will first create a row, which triggers the #GtkTreeModel::row-inserted signal
// on #GtkListStore. The row, however, is still empty, and any signal handler
// connecting to #GtkTreeModel::row-inserted on this particular store should be prepared
// for the situation that the row might be empty. This is especially important
// if you are wrapping the #GtkListStore inside a #GtkTreeModelFilter and are
// using a #GtkTreeModelFilterVisibleFunc. Using any of the non-atomic operations
// to append rows to the #GtkListStore will cause the
// #GtkTreeModelFilterVisibleFunc to be visited with an empty row first; the
// function must be prepared for that.
//
// # GtkListStore as GtkBuildable
//
// The GtkListStore implementation of the GtkBuildable interface allows
// to specify the model columns with a <columns> element that may contain
// multiple <column> elements, each specifying one model column. The type
// attribute specifies the data type for the column.
//
// Additionally, it is possible to specify content for the list store
// in the UI definition, with the <data> element. It can contain multiple
// <row> elements, each specifying to content for one row of the list model.
// Inside a <row>, the <col> elements specify the content for individual cells.
//
// Note that it is probably more common to define your models in the code,
// and one might consider it a layering violation to specify the content of
// a list store in a UI definition, data, not presentation, and common wisdom
// is to separate the two, as far as possible.
//
// An example of a UI Definition fragment for a list store:
// |[<!-- language="C" -->
// <object class="GtkListStore">
// <columns>
// <column type="gchararray"/>
// <column type="gchararray"/>
// <column type="gint"/>
// </columns>
// <data>
// <row>
// <col id="0">John</col>
// <col id="1">Doe</col>
// <col id="2">25</col>
// </row>
// <row>
// <col id="0">Johan</col>
// <col id="1">Dahlin</col>
// <col id="2">50</col>
// </row>
// </data>
// </object>
// ]|
/*

C record/class : GtkListStore
*/
type ListStore struct {
	native *C.GtkListStore
	// parent : record
	// Private : priv
}

func ListStoreNewFromC(u unsafe.Pointer) *ListStore {
	c := (*C.GtkListStore)(u)
	if c == nil {
		return nil
	}

	g := &ListStore{native: c}

	return g
}

func (recv *ListStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *ListStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to ListStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListStore.
func CastToListStore(object *gobject.Object) *ListStore {
	return ListStoreNewFromC(object.ToC())
}

// Unsupported : gtk_list_store_new : unsupported parameter ... : varargs

// Non-vararg creation function.  Used primarily by language bindings.
/*

C function : gtk_list_store_newv
*/
func ListStoreNewv(types []gobject.Type) *ListStore {
	c_n_columns := (C.gint)(len(types))

	c_types := &types[0]

	retC := C.gtk_list_store_newv(c_n_columns, (*C.GType)(unsafe.Pointer(c_types)))
	retGo := ListStoreNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Appends a new row to @list_store.  @iter will be changed to point to this new
// row.  The row will be empty after this function is called.  To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_append
*/
func (recv *ListStore) Append() *TreeIter {
	var c_iter C.GtkTreeIter

	C.gtk_list_store_append((*C.GtkListStore)(recv.native), &c_iter)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Removes all rows from the list store.
/*

C function : gtk_list_store_clear
*/
func (recv *ListStore) Clear() {
	C.gtk_list_store_clear((*C.GtkListStore)(recv.native))

	return
}

// Creates a new row at @position.  @iter will be changed to point to this new
// row.  If @position is -1 or is larger than the number of rows on the list,
// then the new row will be appended to the list. The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_insert
*/
func (recv *ListStore) Insert(position int32) *TreeIter {
	var c_iter C.GtkTreeIter

	c_position := (C.gint)(position)

	C.gtk_list_store_insert((*C.GtkListStore)(recv.native), &c_iter, c_position)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Inserts a new row after @sibling. If @sibling is %NULL, then the row will be
// prepended to the beginning of the list. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill
// in values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_insert_after
*/
func (recv *ListStore) InsertAfter(sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_list_store_insert_after((*C.GtkListStore)(recv.native), &c_iter, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Inserts a new row before @sibling. If @sibling is %NULL, then the row will
// be appended to the end of the list. @iter will be changed to point to this
// new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_insert_before
*/
func (recv *ListStore) InsertBefore(sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_list_store_insert_before((*C.GtkListStore)(recv.native), &c_iter, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Prepends a new row to @list_store. @iter will be changed to point to this new
// row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_prepend
*/
func (recv *ListStore) Prepend() *TreeIter {
	var c_iter C.GtkTreeIter

	C.gtk_list_store_prepend((*C.GtkListStore)(recv.native), &c_iter)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Removes the given row from the list store.  After being removed,
// @iter is set to be the next valid row, or invalidated if it pointed
// to the last row in @list_store.
/*

C function : gtk_list_store_remove
*/
func (recv *ListStore) Remove(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_list_store_remove((*C.GtkListStore)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_list_store_set : unsupported parameter ... : varargs

// This function is meant primarily for #GObjects that inherit from #GtkListStore,
// and should only be used when constructing a new #GtkListStore.  It will not
// function after a row has been added, or a method on the #GtkTreeModel
// interface is called.
/*

C function : gtk_list_store_set_column_types
*/
func (recv *ListStore) SetColumnTypes(types []gobject.Type) {
	c_n_columns := (C.gint)(len(types))

	c_types := &types[0]

	C.gtk_list_store_set_column_types((*C.GtkListStore)(recv.native), c_n_columns, (*C.GType)(unsafe.Pointer(c_types)))

	return
}

// Unsupported : gtk_list_store_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Sets the data in the cell specified by @iter and @column.
// The type of @value must be convertible to the type of the
// column.
/*

C function : gtk_list_store_set_value
*/
func (recv *ListStore) SetValue(iter *TreeIter, column int32, value *gobject.Value) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_column := (C.gint)(column)

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_list_store_set_value((*C.GtkListStore)(recv.native), c_iter, c_column, c_value)

	return
}

// Buildable returns the Buildable interface implemented by ListStore
func (recv *ListStore) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TreeDragDest returns the TreeDragDest interface implemented by ListStore
func (recv *ListStore) TreeDragDest() *TreeDragDest {
	return TreeDragDestNewFromC(recv.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by ListStore
func (recv *ListStore) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by ListStore
func (recv *ListStore) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by ListStore
func (recv *ListStore) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// GtkLockButton is a widget that can be used in control panels or
// preference dialogs to allow users to obtain and revoke authorizations
// needed to operate the controls. The required authorization is represented
// by a #GPermission object. Concrete implementations of #GPermission may use
// PolicyKit or some other authorization framework. To obtain a PolicyKit-based
// #GPermission, use polkit_permission_new().
//
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
//
// ![](lockbutton-locked.png)
//
// and the user can click the button to request the permission. Depending
// on the platform, this may pop up an authentication dialog or ask the user
// to authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
//
// ![](lockbutton-unlocked.png)
//
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
//
// ![](lockbutton-sorry.png)
//
// If the user has the permission and cannot drop it, the button is hidden.
//
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the #GtkLockButton:text-lock, #GtkLockButton:text-unlock,
// #GtkLockButton:tooltip-lock, #GtkLockButton:tooltip-unlock and
// #GtkLockButton:tooltip-not-authorized properties.
/*

C record/class : GtkLockButton
*/
type LockButton struct {
	native *C.GtkLockButton
	// parent : record
	// priv : record
}

func LockButtonNewFromC(u unsafe.Pointer) *LockButton {
	c := (*C.GtkLockButton)(u)
	if c == nil {
		return nil
	}

	g := &LockButton{native: c}

	return g
}

func (recv *LockButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *LockButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *LockButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *LockButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *LockButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LockButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LockButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to LockButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a LockButton.
func CastToLockButton(object *gobject.Object) *LockButton {
	return LockButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by LockButton
func (recv *LockButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by LockButton
func (recv *LockButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by LockButton
func (recv *LockButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LockButton
func (recv *LockButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkLockButtonAccessible
*/
type LockButtonAccessible struct {
	native *C.GtkLockButtonAccessible
	// parent : record
	// priv : record
}

func LockButtonAccessibleNewFromC(u unsafe.Pointer) *LockButtonAccessible {
	c := (*C.GtkLockButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LockButtonAccessible{native: c}

	return g
}

func (recv *LockButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *LockButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *LockButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LockButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *LockButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LockButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to LockButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LockButtonAccessible.
func CastToLockButtonAccessible(object *gobject.Object) *LockButtonAccessible {
	return LockButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// A #GtkMenu is a #GtkMenuShell that implements a drop down menu
// consisting of a list of #GtkMenuItem objects which can be navigated
// and activated by the user to perform application functions.
//
// A #GtkMenu is most commonly dropped down by activating a
// #GtkMenuItem in a #GtkMenuBar or popped up by activating a
// #GtkMenuItem in another #GtkMenu.
//
// A #GtkMenu can also be popped up by activating a #GtkComboBox.
// Other composite widgets such as the #GtkNotebook can pop up a
// #GtkMenu as well.
//
// Applications can display a #GtkMenu as a popup menu by calling the
// gtk_menu_popup() function.  The example below shows how an application
// can pop up a menu when the 3rd mouse button is pressed.
//
// ## Connecting the popup signal handler.
//
// |[<!-- language="C" -->
// connect our handler which will popup the menu
// g_signal_connect_swapped (window, "button_press_event",
// G_CALLBACK (my_popup_handler), menu);
// ]|
//
// ## Signal handler which displays a popup menu.
//
// |[<!-- language="C" -->
// static gint
// my_popup_handler (GtkWidget *widget, GdkEvent *event)
// {
// GtkMenu *menu;
// GdkEventButton *event_button;
//
// g_return_val_if_fail (widget != NULL, FALSE);
// g_return_val_if_fail (GTK_IS_MENU (widget), FALSE);
// g_return_val_if_fail (event != NULL, FALSE);
//
// The "widget" is the menu that was supplied when
// g_signal_connect_swapped() was called.
// menu = GTK_MENU (widget);
//
// if (event->type == GDK_BUTTON_PRESS)
// {
// event_button = (GdkEventButton *) event;
// if (event_button->button == GDK_BUTTON_SECONDARY)
// {
// gtk_menu_popup (menu, NULL, NULL, NULL, NULL,
// event_button->button, event_button->time);
// return TRUE;
// }
// }
//
// return FALSE;
// }
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// menu
//  arrow.top
//  <child>
// 
//  <child>
//  arrow.bottom
// ]|
//
// The main CSS node of GtkMenu has name menu, and there are two subnodes
// with name arrow, for scrolling menu arrows. These subnodes get the
// .top and .bottom style classes.
/*

C record/class : GtkMenu
*/
type Menu struct {
	native *C.GtkMenu
	// menu_shell : record
	// Private : priv
}

func MenuNewFromC(u unsafe.Pointer) *Menu {
	c := (*C.GtkMenu)(u)
	if c == nil {
		return nil
	}

	g := &Menu{native: c}

	return g
}

func (recv *Menu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuShell upcasts to *MenuShell
func (recv *Menu) MenuShell() *MenuShell {
	return MenuShellNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Menu) Container() *Container {
	return recv.MenuShell().Container()
}

// Widget upcasts to *Widget
func (recv *Menu) Widget() *Widget {
	return recv.MenuShell().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Menu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuShell().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Menu) Object() *gobject.Object {
	return recv.MenuShell().Object()
}

// CastToWidget down casts any arbitary Object to Menu.
// Exercise care, as this is a potentially dangerous function if the Object is not a Menu.
func CastToMenu(object *gobject.Object) *Menu {
	return MenuNewFromC(object.ToC())
}

// Unsupported signal 'move-scroll' for Menu : unsupported parameter scroll_type : type ScrollType :

// Creates a new #GtkMenu
/*

C function : gtk_menu_new
*/
func MenuNew() *Menu {
	retC := C.gtk_menu_new()
	retGo := MenuNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_menu_attach_to_widget : unsupported parameter detacher : no type generator for MenuDetachFunc (GtkMenuDetachFunc) for param detacher

// Detaches the menu from the widget to which it had been attached.
// This function will call the callback function, @detacher, provided
// when the gtk_menu_attach_to_widget() function was called.
/*

C function : gtk_menu_detach
*/
func (recv *Menu) Detach() {
	C.gtk_menu_detach((*C.GtkMenu)(recv.native))

	return
}

// Gets the #GtkAccelGroup which holds global accelerators for the
// menu. See gtk_menu_set_accel_group().
/*

C function : gtk_menu_get_accel_group
*/
func (recv *Menu) GetAccelGroup() *AccelGroup {
	retC := C.gtk_menu_get_accel_group((*C.GtkMenu)(recv.native))
	retGo := AccelGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the selected menu item from the menu.  This is used by the
// #GtkComboBox.
/*

C function : gtk_menu_get_active
*/
func (recv *Menu) GetActive() *Widget {
	retC := C.gtk_menu_get_active((*C.GtkMenu)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the #GtkWidget that the menu is attached to.
/*

C function : gtk_menu_get_attach_widget
*/
func (recv *Menu) GetAttachWidget() *Widget {
	retC := C.gtk_menu_get_attach_widget((*C.GtkMenu)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns whether the menu is torn off.
// See gtk_menu_set_tearoff_state().
/*

C function : gtk_menu_get_tearoff_state
*/
func (recv *Menu) GetTearoffState() bool {
	retC := C.gtk_menu_get_tearoff_state((*C.GtkMenu)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the title of the menu. See gtk_menu_set_title().
/*

C function : gtk_menu_get_title
*/
func (recv *Menu) GetTitle() string {
	retC := C.gtk_menu_get_title((*C.GtkMenu)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Removes the menu from the screen.
/*

C function : gtk_menu_popdown
*/
func (recv *Menu) Popdown() {
	C.gtk_menu_popdown((*C.GtkMenu)(recv.native))

	return
}

// Unsupported : gtk_menu_popup : unsupported parameter func : no type generator for MenuPositionFunc (GtkMenuPositionFunc) for param func

// Moves @child to a new @position in the list of @menu
// children.
/*

C function : gtk_menu_reorder_child
*/
func (recv *Menu) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_menu_reorder_child((*C.GtkMenu)(recv.native), c_child, c_position)

	return
}

// Repositions the menu according to its position function.
/*

C function : gtk_menu_reposition
*/
func (recv *Menu) Reposition() {
	C.gtk_menu_reposition((*C.GtkMenu)(recv.native))

	return
}

// Set the #GtkAccelGroup which holds global accelerators for the
// menu.  This accelerator group needs to also be added to all windows
// that this menu is being used in with gtk_window_add_accel_group(),
// in order for those windows to support all the accelerators
// contained in this group.
/*

C function : gtk_menu_set_accel_group
*/
func (recv *Menu) SetAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_menu_set_accel_group((*C.GtkMenu)(recv.native), c_accel_group)

	return
}

// Sets an accelerator path for this menu from which accelerator paths
// for its immediate children, its menu items, can be constructed.
// The main purpose of this function is to spare the programmer the
// inconvenience of having to call gtk_menu_item_set_accel_path() on
// each menu item that should support runtime user changable accelerators.
// Instead, by just calling gtk_menu_set_accel_path() on their parent,
// each menu item of this menu, that contains a label describing its
// purpose, automatically gets an accel path assigned.
//
// For example, a menu containing menu items New and Exit, will, after
// `gtk_menu_set_accel_path (menu, "<Gnumeric-Sheet>/File");` has been
// called, assign its items the accel paths: `"<Gnumeric-Sheet>/File/New"`
// and `"<Gnumeric-Sheet>/File/Exit"`.
//
// Assigning accel paths to menu items then enables the user to change
// their accelerators at runtime. More details about accelerator paths
// and their default setups can be found at gtk_accel_map_add_entry().
//
// Note that @accel_path string will be stored in a #GQuark. Therefore,
// if you pass a static string, you can save some memory by interning
// it first with g_intern_static_string().
/*

C function : gtk_menu_set_accel_path
*/
func (recv *Menu) SetAccelPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_menu_set_accel_path((*C.GtkMenu)(recv.native), c_accel_path)

	return
}

// Selects the specified menu item within the menu.  This is used by
// the #GtkComboBox and should not be used by anyone else.
/*

C function : gtk_menu_set_active
*/
func (recv *Menu) SetActive(index uint32) {
	c_index := (C.guint)(index)

	C.gtk_menu_set_active((*C.GtkMenu)(recv.native), c_index)

	return
}

// Changes the tearoff state of the menu.  A menu is normally
// displayed as drop down menu which persists as long as the menu is
// active.  It can also be displayed as a tearoff menu which persists
// until it is closed or reattached.
/*

C function : gtk_menu_set_tearoff_state
*/
func (recv *Menu) SetTearoffState(tornOff bool) {
	c_torn_off :=
		boolToGboolean(tornOff)

	C.gtk_menu_set_tearoff_state((*C.GtkMenu)(recv.native), c_torn_off)

	return
}

// Sets the title string for the menu.
//
// The title is displayed when the menu is shown as a tearoff
// menu. If @title is %NULL, the menu will see if it is attached
// to a parent menu item, and if so it will try to use the same
// text as that menu items label.
/*

C function : gtk_menu_set_title
*/
func (recv *Menu) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_menu_set_title((*C.GtkMenu)(recv.native), c_title)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Menu
func (recv *Menu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Menu
func (recv *Menu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkMenuAccessible
*/
type MenuAccessible struct {
	native *C.GtkMenuAccessible
	// parent : record
	// priv : record
}

func MenuAccessibleNewFromC(u unsafe.Pointer) *MenuAccessible {
	c := (*C.GtkMenuAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuAccessible{native: c}

	return g
}

func (recv *MenuAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuShellAccessible upcasts to *MenuShellAccessible
func (recv *MenuAccessible) MenuShellAccessible() *MenuShellAccessible {
	return MenuShellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.MenuShellAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.MenuShellAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuAccessible) Accessible() *Accessible {
	return recv.MenuShellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuAccessible) Object() *atk.Object {
	return recv.MenuShellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to MenuAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuAccessible.
func CastToMenuAccessible(object *gobject.Object) *MenuAccessible {
	return MenuAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by MenuAccessible
func (recv *MenuAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuAccessible
func (recv *MenuAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// The #GtkMenuBar is a subclass of #GtkMenuShell which contains one or
// more #GtkMenuItems. The result is a standard menu bar which can hold
// many menu items.
//
// # CSS nodes
//
// GtkMenuBar has a single CSS node with name menubar.
/*

C record/class : GtkMenuBar
*/
type MenuBar struct {
	native *C.GtkMenuBar
	// menu_shell : record
	// Private : priv
}

func MenuBarNewFromC(u unsafe.Pointer) *MenuBar {
	c := (*C.GtkMenuBar)(u)
	if c == nil {
		return nil
	}

	g := &MenuBar{native: c}

	return g
}

func (recv *MenuBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuShell upcasts to *MenuShell
func (recv *MenuBar) MenuShell() *MenuShell {
	return MenuShellNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *MenuBar) Container() *Container {
	return recv.MenuShell().Container()
}

// Widget upcasts to *Widget
func (recv *MenuBar) Widget() *Widget {
	return recv.MenuShell().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuShell().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuBar) Object() *gobject.Object {
	return recv.MenuShell().Object()
}

// CastToWidget down casts any arbitary Object to MenuBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuBar.
func CastToMenuBar(object *gobject.Object) *MenuBar {
	return MenuBarNewFromC(object.ToC())
}

// Creates a new #GtkMenuBar
/*

C function : gtk_menu_bar_new
*/
func MenuBarNew() *MenuBar {
	retC := C.gtk_menu_bar_new()
	retGo := MenuBarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuBar
func (recv *MenuBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuBar
func (recv *MenuBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkMenuButton widget is used to display a popup when clicked on.
// This popup can be provided either as a #GtkMenu, a #GtkPopover or an
// abstract #GMenuModel.
//
// The #GtkMenuButton widget can hold any valid child widget. That is, it
// can hold almost any other standard #GtkWidget. The most commonly used
// child is #GtkImage. If no widget is explicitely added to the #GtkMenuButton,
// a #GtkImage is automatically created, using an arrow image oriented
// according to #GtkMenuButton:direction or the generic open-menu-symbolic
// icon if the direction is not set.
//
// The positioning of the popup is determined by the #GtkMenuButton:direction
// property of the menu button.
//
// For menus, the #GtkWidget:halign and #GtkWidget:valign properties of the
// menu are also taken into account. For example, when the direction is
// %GTK_ARROW_DOWN and the horizontal alignment is %GTK_ALIGN_START, the
// menu will be positioned below the button, with the starting edge
// (depending on the text direction) of the menu aligned with the starting
// edge of the button. If there is not enough space below the button, the
// menu is popped up above the button instead. If the alignment would move
// part of the menu offscreen, it is pushed in.
//
// ## Direction = Down
//
// - halign = start
//
// ![](down-start.png)
//
// - halign = center
//
// ![](down-center.png)
//
// - halign = end
//
// ![](down-end.png)
//
// ## Direction = Up
//
// - halign = start
//
// ![](up-start.png)
//
// - halign = center
//
// ![](up-center.png)
//
// - halign = end
//
// ![](up-end.png)
//
// ## Direction = Left
//
// - valign = start
//
// ![](left-start.png)
//
// - valign = center
//
// ![](left-center.png)
//
// - valign = end
//
// ![](left-end.png)
//
// ## Direction = Right
//
// - valign = start
//
// ![](right-start.png)
//
// - valign = center
//
// ![](right-center.png)
//
// - valign = end
//
// ![](right-end.png)
//
// # CSS nodes
//
// GtkMenuButton has a single CSS node with name button. To differentiate
// it from a plain #GtkButton, it gets the .popup style class.
/*

C record/class : GtkMenuButton
*/
type MenuButton struct {
	native *C.GtkMenuButton
	// parent : record
	// Private : priv
}

func MenuButtonNewFromC(u unsafe.Pointer) *MenuButton {
	c := (*C.GtkMenuButton)(u)
	if c == nil {
		return nil
	}

	g := &MenuButton{native: c}

	return g
}

func (recv *MenuButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleButton upcasts to *ToggleButton
func (recv *MenuButton) ToggleButton() *ToggleButton {
	return ToggleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *MenuButton) Button() *Button {
	return recv.ToggleButton().Button()
}

// Bin upcasts to *Bin
func (recv *MenuButton) Bin() *Bin {
	return recv.ToggleButton().Bin()
}

// Container upcasts to *Container
func (recv *MenuButton) Container() *Container {
	return recv.ToggleButton().Container()
}

// Widget upcasts to *Widget
func (recv *MenuButton) Widget() *Widget {
	return recv.ToggleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuButton) Object() *gobject.Object {
	return recv.ToggleButton().Object()
}

// CastToWidget down casts any arbitary Object to MenuButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuButton.
func CastToMenuButton(object *gobject.Object) *MenuButton {
	return MenuButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuButton
func (recv *MenuButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuButton
func (recv *MenuButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuButton
func (recv *MenuButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuButton
func (recv *MenuButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkMenuButtonAccessible
*/
type MenuButtonAccessible struct {
	native *C.GtkMenuButtonAccessible
	// parent : record
	// priv : record
}

func MenuButtonAccessibleNewFromC(u unsafe.Pointer) *MenuButtonAccessible {
	c := (*C.GtkMenuButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuButtonAccessible{native: c}

	return g
}

func (recv *MenuButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleButtonAccessible upcasts to *ToggleButtonAccessible
func (recv *MenuButtonAccessible) ToggleButtonAccessible() *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *MenuButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return recv.ToggleButtonAccessible().ButtonAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ToggleButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ToggleButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuButtonAccessible) Accessible() *Accessible {
	return recv.ToggleButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuButtonAccessible) Object() *atk.Object {
	return recv.ToggleButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to MenuButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuButtonAccessible.
func CastToMenuButtonAccessible(object *gobject.Object) *MenuButtonAccessible {
	return MenuButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// The #GtkMenuItem widget and the derived widgets are the only valid
// children for menus. Their function is to correctly handle highlighting,
// alignment, events and submenus.
//
// As a GtkMenuItem derives from #GtkBin it can hold any valid child widget,
// although only a few are really useful.
//
// By default, a GtkMenuItem sets a #GtkAccelLabel as its child.
// GtkMenuItem has direct functions to set the label and its mnemonic.
// For more advanced label settings, you can fetch the child widget from the GtkBin.
//
// An example for setting markup and accelerator on a MenuItem:
// |[<!-- language="C" -->
// GtkWidget *menu_item = gtk_menu_item_new_with_label ("Example Menu Item");
//
// GtkWidget *child = gtk_bin_get_child (GTK_BIN (menu_item));
// gtk_label_set_markup (GTK_LABEL (child), "<i>new label</i> with <b>markup</b>");
// gtk_accel_label_set_accel (GTK_ACCEL_LABEL (child), GDK_KEY_1, 0);
// ]|
//
// # GtkMenuItem as GtkBuildable
//
// The GtkMenuItem implementation of the #GtkBuildable interface supports
// adding a submenu by specifying submenu as the type attribute of
// a <child> element.
//
// An example of UI definition fragment with submenus:
// |[
// <object class="GtkMenuItem">
// <child type="submenu">
// <object class="GtkMenu"/>
// </child>
// </object>
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// menuitem
//  <child>
//  [arrow.right]
// ]|
//
// GtkMenuItem has a single CSS node with name menuitem. If the menuitem
// has a submenu, it gets another CSS node with name arrow, which has
// the .left or .right style class.
/*

C record/class : GtkMenuItem
*/
type MenuItem struct {
	native *C.GtkMenuItem
	// bin : record
	// Private : priv
}

func MenuItemNewFromC(u unsafe.Pointer) *MenuItem {
	c := (*C.GtkMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &MenuItem{native: c}

	return g
}

func (recv *MenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *MenuItem) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *MenuItem) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *MenuItem) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuItem) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to MenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItem.
func CastToMenuItem(object *gobject.Object) *MenuItem {
	return MenuItemNewFromC(object.ToC())
}

type signalMenuItemActivateDetail struct {
	callback  MenuItemSignalActivateCallback
	handlerID C.gulong
}

var signalMenuItemActivateId int
var signalMenuItemActivateMap = make(map[int]signalMenuItemActivateDetail)
var signalMenuItemActivateLock sync.Mutex

// MenuItemSignalActivateCallback is a callback function for a 'activate' signal emitted from a MenuItem.
type MenuItemSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *MenuItem) ConnectActivate(callback MenuItemSignalActivateCallback) int {
	signalMenuItemActivateLock.Lock()
	defer signalMenuItemActivateLock.Unlock()

	signalMenuItemActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_activate(instance, C.gpointer(uintptr(signalMenuItemActivateId)))

	detail := signalMenuItemActivateDetail{callback, handlerID}
	signalMenuItemActivateMap[signalMenuItemActivateId] = detail

	return signalMenuItemActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *MenuItem) DisconnectActivate(connectionID int) {
	signalMenuItemActivateLock.Lock()
	defer signalMenuItemActivateLock.Unlock()

	detail, exists := signalMenuItemActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemActivateMap, connectionID)
}

//export menuitem_activateHandler
func menuitem_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuItemActivateMap[index].callback
	callback()
}

type signalMenuItemActivateItemDetail struct {
	callback  MenuItemSignalActivateItemCallback
	handlerID C.gulong
}

var signalMenuItemActivateItemId int
var signalMenuItemActivateItemMap = make(map[int]signalMenuItemActivateItemDetail)
var signalMenuItemActivateItemLock sync.Mutex

// MenuItemSignalActivateItemCallback is a callback function for a 'activate-item' signal emitted from a MenuItem.
type MenuItemSignalActivateItemCallback func()

/*
ConnectActivateItem connects the callback to the 'activate-item' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectActivateItem to remove it.
*/
func (recv *MenuItem) ConnectActivateItem(callback MenuItemSignalActivateItemCallback) int {
	signalMenuItemActivateItemLock.Lock()
	defer signalMenuItemActivateItemLock.Unlock()

	signalMenuItemActivateItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_activate_item(instance, C.gpointer(uintptr(signalMenuItemActivateItemId)))

	detail := signalMenuItemActivateItemDetail{callback, handlerID}
	signalMenuItemActivateItemMap[signalMenuItemActivateItemId] = detail

	return signalMenuItemActivateItemId
}

/*
DisconnectActivateItem disconnects a callback from the 'activate-item' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectActivateItem.
*/
func (recv *MenuItem) DisconnectActivateItem(connectionID int) {
	signalMenuItemActivateItemLock.Lock()
	defer signalMenuItemActivateItemLock.Unlock()

	detail, exists := signalMenuItemActivateItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemActivateItemMap, connectionID)
}

//export menuitem_activateItemHandler
func menuitem_activateItemHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuItemActivateItemMap[index].callback
	callback()
}

type signalMenuItemDeselectDetail struct {
	callback  MenuItemSignalDeselectCallback
	handlerID C.gulong
}

var signalMenuItemDeselectId int
var signalMenuItemDeselectMap = make(map[int]signalMenuItemDeselectDetail)
var signalMenuItemDeselectLock sync.Mutex

// MenuItemSignalDeselectCallback is a callback function for a 'deselect' signal emitted from a MenuItem.
type MenuItemSignalDeselectCallback func()

/*
ConnectDeselect connects the callback to the 'deselect' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectDeselect to remove it.
*/
func (recv *MenuItem) ConnectDeselect(callback MenuItemSignalDeselectCallback) int {
	signalMenuItemDeselectLock.Lock()
	defer signalMenuItemDeselectLock.Unlock()

	signalMenuItemDeselectId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_deselect(instance, C.gpointer(uintptr(signalMenuItemDeselectId)))

	detail := signalMenuItemDeselectDetail{callback, handlerID}
	signalMenuItemDeselectMap[signalMenuItemDeselectId] = detail

	return signalMenuItemDeselectId
}

/*
DisconnectDeselect disconnects a callback from the 'deselect' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectDeselect.
*/
func (recv *MenuItem) DisconnectDeselect(connectionID int) {
	signalMenuItemDeselectLock.Lock()
	defer signalMenuItemDeselectLock.Unlock()

	detail, exists := signalMenuItemDeselectMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemDeselectMap, connectionID)
}

//export menuitem_deselectHandler
func menuitem_deselectHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuItemDeselectMap[index].callback
	callback()
}

type signalMenuItemSelectDetail struct {
	callback  MenuItemSignalSelectCallback
	handlerID C.gulong
}

var signalMenuItemSelectId int
var signalMenuItemSelectMap = make(map[int]signalMenuItemSelectDetail)
var signalMenuItemSelectLock sync.Mutex

// MenuItemSignalSelectCallback is a callback function for a 'select' signal emitted from a MenuItem.
type MenuItemSignalSelectCallback func()

/*
ConnectSelect connects the callback to the 'select' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectSelect to remove it.
*/
func (recv *MenuItem) ConnectSelect(callback MenuItemSignalSelectCallback) int {
	signalMenuItemSelectLock.Lock()
	defer signalMenuItemSelectLock.Unlock()

	signalMenuItemSelectId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_select(instance, C.gpointer(uintptr(signalMenuItemSelectId)))

	detail := signalMenuItemSelectDetail{callback, handlerID}
	signalMenuItemSelectMap[signalMenuItemSelectId] = detail

	return signalMenuItemSelectId
}

/*
DisconnectSelect disconnects a callback from the 'select' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectSelect.
*/
func (recv *MenuItem) DisconnectSelect(connectionID int) {
	signalMenuItemSelectLock.Lock()
	defer signalMenuItemSelectLock.Unlock()

	detail, exists := signalMenuItemSelectMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemSelectMap, connectionID)
}

//export menuitem_selectHandler
func menuitem_selectHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuItemSelectMap[index].callback
	callback()
}

// Unsupported signal 'toggle-size-allocate' for MenuItem : unsupported parameter object : type gint :

// Unsupported signal 'toggle-size-request' for MenuItem : unsupported parameter object : type gpointer :

// Creates a new #GtkMenuItem.
/*

C function : gtk_menu_item_new
*/
func MenuItemNew() *MenuItem {
	retC := C.gtk_menu_item_new()
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkMenuItem whose child is a #GtkLabel.
/*

C function : gtk_menu_item_new_with_label
*/
func MenuItemNewWithLabel(label string) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_menu_item_new_with_label(c_label)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkMenuItem containing a label.
//
// The label will be created using gtk_label_new_with_mnemonic(),
// so underscores in @label indicate the mnemonic for the menu item.
/*

C function : gtk_menu_item_new_with_mnemonic
*/
func MenuItemNewWithMnemonic(label string) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_menu_item_new_with_mnemonic(c_label)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Emits the #GtkMenuItem::activate signal on the given item
/*

C function : gtk_menu_item_activate
*/
func (recv *MenuItem) Activate() {
	C.gtk_menu_item_activate((*C.GtkMenuItem)(recv.native))

	return
}

// Emits the #GtkMenuItem::deselect signal on the given item.
/*

C function : gtk_menu_item_deselect
*/
func (recv *MenuItem) Deselect() {
	C.gtk_menu_item_deselect((*C.GtkMenuItem)(recv.native))

	return
}

// Gets whether the menu item appears justified at the right
// side of the menu bar.
/*

C function : gtk_menu_item_get_right_justified
*/
func (recv *MenuItem) GetRightJustified() bool {
	retC := C.gtk_menu_item_get_right_justified((*C.GtkMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the submenu underneath this menu item, if any.
// See gtk_menu_item_set_submenu().
/*

C function : gtk_menu_item_get_submenu
*/
func (recv *MenuItem) GetSubmenu() *Widget {
	retC := C.gtk_menu_item_get_submenu((*C.GtkMenuItem)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Emits the #GtkMenuItem::select signal on the given item.
/*

C function : gtk_menu_item_select
*/
func (recv *MenuItem) Select() {
	C.gtk_menu_item_select((*C.GtkMenuItem)(recv.native))

	return
}

// Set the accelerator path on @menu_item, through which runtime
// changes of the menu items accelerator caused by the user can be
// identified and saved to persistent storage (see gtk_accel_map_save()
// on this). To set up a default accelerator for this menu item, call
// gtk_accel_map_add_entry() with the same @accel_path. See also
// gtk_accel_map_add_entry() on the specifics of accelerator paths,
// and gtk_menu_set_accel_path() for a more convenient variant of
// this function.
//
// This function is basically a convenience wrapper that handles
// calling gtk_widget_set_accel_path() with the appropriate accelerator
// group for the menu item.
//
// Note that you do need to set an accelerator on the parent menu with
// gtk_menu_set_accel_group() for this to work.
//
// Note that @accel_path string will be stored in a #GQuark.
// Therefore, if you pass a static string, you can save some memory
// by interning it first with g_intern_static_string().
/*

C function : gtk_menu_item_set_accel_path
*/
func (recv *MenuItem) SetAccelPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_menu_item_set_accel_path((*C.GtkMenuItem)(recv.native), c_accel_path)

	return
}

// Sets whether the menu item appears justified at the right
// side of a menu bar. This was traditionally done for Help
// menu items, but is now considered a bad idea. (If the widget
// layout is reversed for a right-to-left language like Hebrew
// or Arabic, right-justified-menu-items appear at the left.)
/*

C function : gtk_menu_item_set_right_justified
*/
func (recv *MenuItem) SetRightJustified(rightJustified bool) {
	c_right_justified :=
		boolToGboolean(rightJustified)

	C.gtk_menu_item_set_right_justified((*C.GtkMenuItem)(recv.native), c_right_justified)

	return
}

// Sets or replaces the menu items submenu, or removes it when a %NULL
// submenu is passed.
/*

C function : gtk_menu_item_set_submenu
*/
func (recv *MenuItem) SetSubmenu(submenu *Menu) {
	c_submenu := (*C.GtkWidget)(C.NULL)
	if submenu != nil {
		c_submenu = (*C.GtkWidget)(submenu.ToC())
	}

	C.gtk_menu_item_set_submenu((*C.GtkMenuItem)(recv.native), c_submenu)

	return
}

// Emits the #GtkMenuItem::toggle-size-allocate signal on the given item.
/*

C function : gtk_menu_item_toggle_size_allocate
*/
func (recv *MenuItem) ToggleSizeAllocate(allocation int32) {
	c_allocation := (C.gint)(allocation)

	C.gtk_menu_item_toggle_size_allocate((*C.GtkMenuItem)(recv.native), c_allocation)

	return
}

// Emits the #GtkMenuItem::toggle-size-request signal on the given item.
/*

C function : gtk_menu_item_toggle_size_request
*/
func (recv *MenuItem) ToggleSizeRequest(requisition int32) {
	c_requisition := (C.gint)(requisition)

	C.gtk_menu_item_toggle_size_request((*C.GtkMenuItem)(recv.native), &c_requisition)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuItem
func (recv *MenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuItem
func (recv *MenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuItem
func (recv *MenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuItem
func (recv *MenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkMenuItemAccessible
*/
type MenuItemAccessible struct {
	native *C.GtkMenuItemAccessible
	// parent : record
	// priv : record
}

func MenuItemAccessibleNewFromC(u unsafe.Pointer) *MenuItemAccessible {
	c := (*C.GtkMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuItemAccessible{native: c}

	return g
}

func (recv *MenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuItemAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuItemAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to MenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItemAccessible.
func CastToMenuItemAccessible(object *gobject.Object) *MenuItemAccessible {
	return MenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// A #GtkMenuShell is the abstract base class used to derive the
// #GtkMenu and #GtkMenuBar subclasses.
//
// A #GtkMenuShell is a container of #GtkMenuItem objects arranged
// in a list which can be navigated, selected, and activated by the
// user to perform application functions. A #GtkMenuItem can have a
// submenu associated with it, allowing for nested hierarchical menus.
//
// # Terminology
//
// A menu item can be selected, this means that it is displayed
// in the prelight state, and if it has a submenu, that submenu
// will be popped up.
//
// A menu is active when it is visible onscreen and the user
// is selecting from it. A menubar is not active until the user
// clicks on one of its menuitems. When a menu is active,
// passing the mouse over a submenu will pop it up.
//
// There is also is a concept of the current menu and a current
// menu item. The current menu item is the selected menu item
// that is furthest down in the hierarchy. (Every active menu shell
// does not necessarily contain a selected menu item, but if
// it does, then the parent menu shell must also contain
// a selected menu item.) The current menu is the menu that
// contains the current menu item. It will always have a GTK
// grab and receive all key presses.
/*

C record/class : GtkMenuShell
*/
type MenuShell struct {
	native *C.GtkMenuShell
	// container : record
	// Private : priv
}

func MenuShellNewFromC(u unsafe.Pointer) *MenuShell {
	c := (*C.GtkMenuShell)(u)
	if c == nil {
		return nil
	}

	g := &MenuShell{native: c}

	return g
}

func (recv *MenuShell) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *MenuShell) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *MenuShell) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuShell) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuShell) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to MenuShell.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuShell.
func CastToMenuShell(object *gobject.Object) *MenuShell {
	return MenuShellNewFromC(object.ToC())
}

type signalMenuShellActivateCurrentDetail struct {
	callback  MenuShellSignalActivateCurrentCallback
	handlerID C.gulong
}

var signalMenuShellActivateCurrentId int
var signalMenuShellActivateCurrentMap = make(map[int]signalMenuShellActivateCurrentDetail)
var signalMenuShellActivateCurrentLock sync.Mutex

// MenuShellSignalActivateCurrentCallback is a callback function for a 'activate-current' signal emitted from a MenuShell.
type MenuShellSignalActivateCurrentCallback func(forceHide bool)

/*
ConnectActivateCurrent connects the callback to the 'activate-current' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectActivateCurrent to remove it.
*/
func (recv *MenuShell) ConnectActivateCurrent(callback MenuShellSignalActivateCurrentCallback) int {
	signalMenuShellActivateCurrentLock.Lock()
	defer signalMenuShellActivateCurrentLock.Unlock()

	signalMenuShellActivateCurrentId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_activate_current(instance, C.gpointer(uintptr(signalMenuShellActivateCurrentId)))

	detail := signalMenuShellActivateCurrentDetail{callback, handlerID}
	signalMenuShellActivateCurrentMap[signalMenuShellActivateCurrentId] = detail

	return signalMenuShellActivateCurrentId
}

/*
DisconnectActivateCurrent disconnects a callback from the 'activate-current' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectActivateCurrent.
*/
func (recv *MenuShell) DisconnectActivateCurrent(connectionID int) {
	signalMenuShellActivateCurrentLock.Lock()
	defer signalMenuShellActivateCurrentLock.Unlock()

	detail, exists := signalMenuShellActivateCurrentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellActivateCurrentMap, connectionID)
}

//export menushell_activateCurrentHandler
func menushell_activateCurrentHandler(_ *C.GObject, c_force_hide C.gboolean, data C.gpointer) {
	forceHide := c_force_hide == C.TRUE

	index := int(uintptr(data))
	callback := signalMenuShellActivateCurrentMap[index].callback
	callback(forceHide)
}

type signalMenuShellCancelDetail struct {
	callback  MenuShellSignalCancelCallback
	handlerID C.gulong
}

var signalMenuShellCancelId int
var signalMenuShellCancelMap = make(map[int]signalMenuShellCancelDetail)
var signalMenuShellCancelLock sync.Mutex

// MenuShellSignalCancelCallback is a callback function for a 'cancel' signal emitted from a MenuShell.
type MenuShellSignalCancelCallback func()

/*
ConnectCancel connects the callback to the 'cancel' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectCancel to remove it.
*/
func (recv *MenuShell) ConnectCancel(callback MenuShellSignalCancelCallback) int {
	signalMenuShellCancelLock.Lock()
	defer signalMenuShellCancelLock.Unlock()

	signalMenuShellCancelId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_cancel(instance, C.gpointer(uintptr(signalMenuShellCancelId)))

	detail := signalMenuShellCancelDetail{callback, handlerID}
	signalMenuShellCancelMap[signalMenuShellCancelId] = detail

	return signalMenuShellCancelId
}

/*
DisconnectCancel disconnects a callback from the 'cancel' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectCancel.
*/
func (recv *MenuShell) DisconnectCancel(connectionID int) {
	signalMenuShellCancelLock.Lock()
	defer signalMenuShellCancelLock.Unlock()

	detail, exists := signalMenuShellCancelMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellCancelMap, connectionID)
}

//export menushell_cancelHandler
func menushell_cancelHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuShellCancelMap[index].callback
	callback()
}

// Unsupported signal 'cycle-focus' for MenuShell : unsupported parameter direction : type DirectionType :

type signalMenuShellDeactivateDetail struct {
	callback  MenuShellSignalDeactivateCallback
	handlerID C.gulong
}

var signalMenuShellDeactivateId int
var signalMenuShellDeactivateMap = make(map[int]signalMenuShellDeactivateDetail)
var signalMenuShellDeactivateLock sync.Mutex

// MenuShellSignalDeactivateCallback is a callback function for a 'deactivate' signal emitted from a MenuShell.
type MenuShellSignalDeactivateCallback func()

/*
ConnectDeactivate connects the callback to the 'deactivate' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectDeactivate to remove it.
*/
func (recv *MenuShell) ConnectDeactivate(callback MenuShellSignalDeactivateCallback) int {
	signalMenuShellDeactivateLock.Lock()
	defer signalMenuShellDeactivateLock.Unlock()

	signalMenuShellDeactivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_deactivate(instance, C.gpointer(uintptr(signalMenuShellDeactivateId)))

	detail := signalMenuShellDeactivateDetail{callback, handlerID}
	signalMenuShellDeactivateMap[signalMenuShellDeactivateId] = detail

	return signalMenuShellDeactivateId
}

/*
DisconnectDeactivate disconnects a callback from the 'deactivate' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectDeactivate.
*/
func (recv *MenuShell) DisconnectDeactivate(connectionID int) {
	signalMenuShellDeactivateLock.Lock()
	defer signalMenuShellDeactivateLock.Unlock()

	detail, exists := signalMenuShellDeactivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellDeactivateMap, connectionID)
}

//export menushell_deactivateHandler
func menushell_deactivateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuShellDeactivateMap[index].callback
	callback()
}

// Unsupported signal 'move-current' for MenuShell : unsupported parameter direction : type MenuDirectionType :

type signalMenuShellSelectionDoneDetail struct {
	callback  MenuShellSignalSelectionDoneCallback
	handlerID C.gulong
}

var signalMenuShellSelectionDoneId int
var signalMenuShellSelectionDoneMap = make(map[int]signalMenuShellSelectionDoneDetail)
var signalMenuShellSelectionDoneLock sync.Mutex

// MenuShellSignalSelectionDoneCallback is a callback function for a 'selection-done' signal emitted from a MenuShell.
type MenuShellSignalSelectionDoneCallback func()

/*
ConnectSelectionDone connects the callback to the 'selection-done' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectSelectionDone to remove it.
*/
func (recv *MenuShell) ConnectSelectionDone(callback MenuShellSignalSelectionDoneCallback) int {
	signalMenuShellSelectionDoneLock.Lock()
	defer signalMenuShellSelectionDoneLock.Unlock()

	signalMenuShellSelectionDoneId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_selection_done(instance, C.gpointer(uintptr(signalMenuShellSelectionDoneId)))

	detail := signalMenuShellSelectionDoneDetail{callback, handlerID}
	signalMenuShellSelectionDoneMap[signalMenuShellSelectionDoneId] = detail

	return signalMenuShellSelectionDoneId
}

/*
DisconnectSelectionDone disconnects a callback from the 'selection-done' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectSelectionDone.
*/
func (recv *MenuShell) DisconnectSelectionDone(connectionID int) {
	signalMenuShellSelectionDoneLock.Lock()
	defer signalMenuShellSelectionDoneLock.Unlock()

	detail, exists := signalMenuShellSelectionDoneMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellSelectionDoneMap, connectionID)
}

//export menushell_selectionDoneHandler
func menushell_selectionDoneHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuShellSelectionDoneMap[index].callback
	callback()
}

// Activates the menu item within the menu shell.
/*

C function : gtk_menu_shell_activate_item
*/
func (recv *MenuShell) ActivateItem(menuItem *Widget, forceDeactivate bool) {
	c_menu_item := (*C.GtkWidget)(C.NULL)
	if menuItem != nil {
		c_menu_item = (*C.GtkWidget)(menuItem.ToC())
	}

	c_force_deactivate :=
		boolToGboolean(forceDeactivate)

	C.gtk_menu_shell_activate_item((*C.GtkMenuShell)(recv.native), c_menu_item, c_force_deactivate)

	return
}

// Adds a new #GtkMenuItem to the end of the menu shell's
// item list.
/*

C function : gtk_menu_shell_append
*/
func (recv *MenuShell) Append(child *MenuItem) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_menu_shell_append((*C.GtkMenuShell)(recv.native), c_child)

	return
}

// Deactivates the menu shell.
//
// Typically this results in the menu shell being erased
// from the screen.
/*

C function : gtk_menu_shell_deactivate
*/
func (recv *MenuShell) Deactivate() {
	C.gtk_menu_shell_deactivate((*C.GtkMenuShell)(recv.native))

	return
}

// Deselects the currently selected item from the menu shell,
// if any.
/*

C function : gtk_menu_shell_deselect
*/
func (recv *MenuShell) Deselect() {
	C.gtk_menu_shell_deselect((*C.GtkMenuShell)(recv.native))

	return
}

// Adds a new #GtkMenuItem to the menu shells item list
// at the position indicated by @position.
/*

C function : gtk_menu_shell_insert
*/
func (recv *MenuShell) Insert(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_menu_shell_insert((*C.GtkMenuShell)(recv.native), c_child, c_position)

	return
}

// Adds a new #GtkMenuItem to the beginning of the menu shell's
// item list.
/*

C function : gtk_menu_shell_prepend
*/
func (recv *MenuShell) Prepend(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_menu_shell_prepend((*C.GtkMenuShell)(recv.native), c_child)

	return
}

// Selects the menu item from the menu shell.
/*

C function : gtk_menu_shell_select_item
*/
func (recv *MenuShell) SelectItem(menuItem *Widget) {
	c_menu_item := (*C.GtkWidget)(C.NULL)
	if menuItem != nil {
		c_menu_item = (*C.GtkWidget)(menuItem.ToC())
	}

	C.gtk_menu_shell_select_item((*C.GtkMenuShell)(recv.native), c_menu_item)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuShell
func (recv *MenuShell) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuShell
func (recv *MenuShell) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkMenuShellAccessible
*/
type MenuShellAccessible struct {
	native *C.GtkMenuShellAccessible
	// parent : record
	// priv : record
}

func MenuShellAccessibleNewFromC(u unsafe.Pointer) *MenuShellAccessible {
	c := (*C.GtkMenuShellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuShellAccessible{native: c}

	return g
}

func (recv *MenuShellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuShellAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuShellAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuShellAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuShellAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to MenuShellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuShellAccessible.
func CastToMenuShellAccessible(object *gobject.Object) *MenuShellAccessible {
	return MenuShellAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by MenuShellAccessible
func (recv *MenuShellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuShellAccessible
func (recv *MenuShellAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// A #GtkMenuToolButton is a #GtkToolItem that contains a button and
// a small additional button with an arrow. When clicked, the arrow
// button pops up a dropdown menu.
//
// Use gtk_menu_tool_button_new() to create a new
// #GtkMenuToolButton.
//
// # GtkMenuToolButton as GtkBuildable
//
// The GtkMenuToolButton implementation of the GtkBuildable interface
// supports adding a menu by specifying menu as the type attribute
// of a <child> element.
//
// An example for a UI definition fragment with menus:
// |[
// <object class="GtkMenuToolButton">
// <child type="menu">
// <object class="GtkMenu"/>
// </child>
// </object>
// ]|
/*

C record/class : GtkMenuToolButton
*/
type MenuToolButton struct {
	native *C.GtkMenuToolButton
	// parent : record
	// Private : priv
}

func MenuToolButtonNewFromC(u unsafe.Pointer) *MenuToolButton {
	c := (*C.GtkMenuToolButton)(u)
	if c == nil {
		return nil
	}

	g := &MenuToolButton{native: c}

	return g
}

func (recv *MenuToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToolButton upcasts to *ToolButton
func (recv *MenuToolButton) ToolButton() *ToolButton {
	return ToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolItem upcasts to *ToolItem
func (recv *MenuToolButton) ToolItem() *ToolItem {
	return recv.ToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *MenuToolButton) Bin() *Bin {
	return recv.ToolButton().Bin()
}

// Container upcasts to *Container
func (recv *MenuToolButton) Container() *Container {
	return recv.ToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *MenuToolButton) Widget() *Widget {
	return recv.ToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuToolButton) Object() *gobject.Object {
	return recv.ToolButton().Object()
}

// CastToWidget down casts any arbitary Object to MenuToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuToolButton.
func CastToMenuToolButton(object *gobject.Object) *MenuToolButton {
	return MenuToolButtonNewFromC(object.ToC())
}

type signalMenuToolButtonShowMenuDetail struct {
	callback  MenuToolButtonSignalShowMenuCallback
	handlerID C.gulong
}

var signalMenuToolButtonShowMenuId int
var signalMenuToolButtonShowMenuMap = make(map[int]signalMenuToolButtonShowMenuDetail)
var signalMenuToolButtonShowMenuLock sync.Mutex

// MenuToolButtonSignalShowMenuCallback is a callback function for a 'show-menu' signal emitted from a MenuToolButton.
type MenuToolButtonSignalShowMenuCallback func()

/*
ConnectShowMenu connects the callback to the 'show-menu' signal for the MenuToolButton.

The returned value represents the connection, and may be passed to DisconnectShowMenu to remove it.
*/
func (recv *MenuToolButton) ConnectShowMenu(callback MenuToolButtonSignalShowMenuCallback) int {
	signalMenuToolButtonShowMenuLock.Lock()
	defer signalMenuToolButtonShowMenuLock.Unlock()

	signalMenuToolButtonShowMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuToolButton_signal_connect_show_menu(instance, C.gpointer(uintptr(signalMenuToolButtonShowMenuId)))

	detail := signalMenuToolButtonShowMenuDetail{callback, handlerID}
	signalMenuToolButtonShowMenuMap[signalMenuToolButtonShowMenuId] = detail

	return signalMenuToolButtonShowMenuId
}

/*
DisconnectShowMenu disconnects a callback from the 'show-menu' signal for the MenuToolButton.

The connectionID should be a value returned from a call to ConnectShowMenu.
*/
func (recv *MenuToolButton) DisconnectShowMenu(connectionID int) {
	signalMenuToolButtonShowMenuLock.Lock()
	defer signalMenuToolButtonShowMenuLock.Unlock()

	detail, exists := signalMenuToolButtonShowMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuToolButtonShowMenuMap, connectionID)
}

//export menutoolbutton_showMenuHandler
func menutoolbutton_showMenuHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuToolButtonShowMenuMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuToolButton
func (recv *MenuToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuToolButton
func (recv *MenuToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuToolButton
func (recv *MenuToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuToolButton
func (recv *MenuToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkMessageDialog presents a dialog with some message text. Its simply a
// convenience widget; you could construct the equivalent of #GtkMessageDialog
// from #GtkDialog without too much effort, but #GtkMessageDialog saves typing.
//
// One difference from #GtkDialog is that #GtkMessageDialog sets the
// #GtkWindow:skip-taskbar-hint property to %TRUE, so that the dialog is hidden
// from the taskbar by default.
//
// The easiest way to do a modal message dialog is to use gtk_dialog_run(), though
// you can also pass in the %GTK_DIALOG_MODAL flag, gtk_dialog_run() automatically
// makes the dialog modal and waits for the user to respond to it. gtk_dialog_run()
// returns when any dialog button is clicked.
//
// An example for using a modal dialog:
// |[<!-- language="C" -->
// GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
// dialog = gtk_message_dialog_new (parent_window,
// flags,
// GTK_MESSAGE_ERROR,
// GTK_BUTTONS_CLOSE,
// "Error reading %s: %s",
// filename,
// g_strerror (errno));
// gtk_dialog_run (GTK_DIALOG (dialog));
// gtk_widget_destroy (dialog);
// ]|
//
// You might do a non-modal #GtkMessageDialog as follows:
//
// An example for a non-modal dialog:
// |[<!-- language="C" -->
// GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
// dialog = gtk_message_dialog_new (parent_window,
// flags,
// GTK_MESSAGE_ERROR,
// GTK_BUTTONS_CLOSE,
// "Error reading %s: %s",
// filename,
// g_strerror (errno));
//
// Destroy the dialog when the user responds to it
// (e.g. clicks a button)
//
// g_signal_connect_swapped (dialog, "response",
// G_CALLBACK (gtk_widget_destroy),
// dialog);
// ]|
//
// # GtkMessageDialog as GtkBuildable
//
// The GtkMessageDialog implementation of the GtkBuildable interface exposes
// the message area as an internal child with the name message_area.
/*

C record/class : GtkMessageDialog
*/
type MessageDialog struct {
	native *C.GtkMessageDialog
	// parent_instance : record
	// Private : priv
}

func MessageDialogNewFromC(u unsafe.Pointer) *MessageDialog {
	c := (*C.GtkMessageDialog)(u)
	if c == nil {
		return nil
	}

	g := &MessageDialog{native: c}

	return g
}

func (recv *MessageDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *MessageDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *MessageDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *MessageDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *MessageDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *MessageDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MessageDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MessageDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to MessageDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a MessageDialog.
func CastToMessageDialog(object *gobject.Object) *MessageDialog {
	return MessageDialogNewFromC(object.ToC())
}

// Unsupported : gtk_message_dialog_new : unsupported parameter ... : varargs

// ImplementorIface returns the ImplementorIface interface implemented by MessageDialog
func (recv *MessageDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MessageDialog
func (recv *MessageDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The #GtkMisc widget is an abstract widget which is not useful itself, but
// is used to derive subclasses which have alignment and padding attributes.
//
// The horizontal and vertical padding attributes allows extra space to be
// added around the widget.
//
// The horizontal and vertical alignment attributes enable the widget to be
// positioned within its allocated area. Note that if the widget is added to
// a container in such a way that it expands automatically to fill its
// allocated area, the alignment settings will not alter the widget's position.
//
// Note that the desired effect can in most cases be achieved by using the
// #GtkWidget:halign, #GtkWidget:valign and #GtkWidget:margin properties
// on the child widget, so GtkMisc should not be used in new code. To reflect
// this fact, all #GtkMisc API has been deprecated.
/*

C record/class : GtkMisc
*/
type Misc struct {
	native *C.GtkMisc
	// widget : record
	// Private : priv
}

func MiscNewFromC(u unsafe.Pointer) *Misc {
	c := (*C.GtkMisc)(u)
	if c == nil {
		return nil
	}

	g := &Misc{native: c}

	return g
}

func (recv *Misc) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Misc) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Misc) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Misc) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Misc.
// Exercise care, as this is a potentially dangerous function if the Object is not a Misc.
func CastToMisc(object *gobject.Object) *Misc {
	return MiscNewFromC(object.ToC())
}

// Gets the X and Y alignment of the widget within its allocation.
// See gtk_misc_set_alignment().
/*

C function : gtk_misc_get_alignment
*/
func (recv *Misc) GetAlignment() (float32, float32) {
	var c_xalign C.gfloat

	var c_yalign C.gfloat

	C.gtk_misc_get_alignment((*C.GtkMisc)(recv.native), &c_xalign, &c_yalign)

	xalign := (float32)(c_xalign)

	yalign := (float32)(c_yalign)

	return xalign, yalign
}

// Gets the padding in the X and Y directions of the widget.
// See gtk_misc_set_padding().
/*

C function : gtk_misc_get_padding
*/
func (recv *Misc) GetPadding() (int32, int32) {
	var c_xpad C.gint

	var c_ypad C.gint

	C.gtk_misc_get_padding((*C.GtkMisc)(recv.native), &c_xpad, &c_ypad)

	xpad := (int32)(c_xpad)

	ypad := (int32)(c_ypad)

	return xpad, ypad
}

// Sets the alignment of the widget.
/*

C function : gtk_misc_set_alignment
*/
func (recv *Misc) SetAlignment(xalign float32, yalign float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	C.gtk_misc_set_alignment((*C.GtkMisc)(recv.native), c_xalign, c_yalign)

	return
}

// Sets the amount of space to add around the widget.
/*

C function : gtk_misc_set_padding
*/
func (recv *Misc) SetPadding(xpad int32, ypad int32) {
	c_xpad := (C.gint)(xpad)

	c_ypad := (C.gint)(ypad)

	C.gtk_misc_set_padding((*C.GtkMisc)(recv.native), c_xpad, c_ypad)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Misc
func (recv *Misc) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Misc
func (recv *Misc) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// GtkModelButton is a button class that can use a #GAction as its model.
// In contrast to #GtkToggleButton or #GtkRadioButton, which can also
// be backed by a #GAction via the #GtkActionable:action-name property,
// GtkModelButton will adapt its appearance according to the kind of
// action it is backed by, and appear either as a plain, check or
// radio button.
//
// Model buttons are used when popovers from a menu model with
// gtk_popover_new_from_model(); they can also be used manually in
// a #GtkPopoverMenu.
//
// When the action is specified via the #GtkActionable:action-name
// and #GtkActionable:action-target properties, the role of the button
// (i.e. whether it is a plain, check or radio button) is determined by
// the type of the action and doesn't have to be explicitly specified
// with the #GtkModelButton:role property.
//
// The content of the button is specified by the #GtkModelButton:text
// and #GtkModelButton:icon properties.
//
// The appearance of model buttons can be influenced with the
// #GtkModelButton:centered and #GtkModelButton:iconic properties.
//
// Model buttons have built-in support for submenus in #GtkPopoverMenu.
// To make a GtkModelButton that opens a submenu when activated, set
// the #GtkModelButton:menu-name property. To make a button that goes
// back to the parent menu, you should set the #GtkModelButton:inverted
// property to place the submenu indicator at the opposite side.
//
// # Example
//
// |[
// <object class="GtkPopoverMenu">
// <child>
// <object class="GtkBox">
// <property name="visible">True</property>
// <property name="margin">10</property>
// <child>
// <object class="GtkModelButton">
// <property name="visible">True</property>
// <property name="action-name">view.cut</property>
// <property name="text" translatable="yes">Cut</property>
// </object>
// </child>
// <child>
// <object class="GtkModelButton">
// <property name="visible">True</property>
// <property name="action-name">view.copy</property>
// <property name="text" translatable="yes">Copy</property>
// </object>
// </child>
// <child>
// <object class="GtkModelButton">
// <property name="visible">True</property>
// <property name="action-name">view.paste</property>
// <property name="text" translatable="yes">Paste</property>
// </object>
// </child>
// </object>
// </child>
// </object>
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// modelbutton
//  <child>
//  check
// ]|
//
// |[<!-- language="plain" -->
// modelbutton
//  <child>
//  radio
// ]|
//
// |[<!-- language="plain" -->
// modelbutton
//  <child>
//  arrow
// ]|
//
// GtkModelButton has a main CSS node with name modelbutton, and a subnode,
// which will have the name check, radio or arrow, depending on the role
// of the button and whether it has a menu name set.
//
// The subnode is positioned before or after the content nodes and gets the
// .left or .right style class, depending on where it is located.
//
// |[<!-- language="plain" -->
// button.model
//  <child>
//  check
// ]|
//
// Iconic model buttons (see #GtkModelButton:iconic) change the name of
// their main node to button and add a .model style class to it. The indicator
// subnode is invisible in this case.
/*

C record/class : GtkModelButton
*/
type ModelButton struct {
	native *C.GtkModelButton
}

func ModelButtonNewFromC(u unsafe.Pointer) *ModelButton {
	c := (*C.GtkModelButton)(u)
	if c == nil {
		return nil
	}

	g := &ModelButton{native: c}

	return g
}

func (recv *ModelButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *ModelButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ModelButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ModelButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ModelButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ModelButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ModelButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to ModelButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ModelButton.
func CastToModelButton(object *gobject.Object) *ModelButton {
	return ModelButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ModelButton
func (recv *ModelButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ModelButton
func (recv *ModelButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ModelButton
func (recv *ModelButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ModelButton
func (recv *ModelButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// This should not be accessed directly. Use the accessor functions below.
/*

C record/class : GtkMountOperation
*/
type MountOperation struct {
	native *C.GtkMountOperation
	// parent_instance : record
	// priv : record
}

func MountOperationNewFromC(u unsafe.Pointer) *MountOperation {
	c := (*C.GtkMountOperation)(u)
	if c == nil {
		return nil
	}

	g := &MountOperation{native: c}

	return g
}

func (recv *MountOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MountOperation upcasts to *MountOperation
func (recv *MountOperation) MountOperation() *gio.MountOperation {
	return gio.MountOperationNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *MountOperation) Object() *gobject.Object {
	return recv.MountOperation().Object()
}

// CastToWidget down casts any arbitary Object to MountOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a MountOperation.
func CastToMountOperation(object *gobject.Object) *MountOperation {
	return MountOperationNewFromC(object.ToC())
}

// The #GtkNotebook widget is a #GtkContainer whose children are pages that
// can be switched between using tab labels along one edge.
//
// There are many configuration options for GtkNotebook. Among other
// things, you can choose on which edge the tabs appear
// (see gtk_notebook_set_tab_pos()), whether, if there are too many
// tabs to fit the notebook should be made bigger or scrolling
// arrows added (see gtk_notebook_set_scrollable()), and whether there
// will be a popup menu allowing the users to switch pages.
// (see gtk_notebook_popup_enable(), gtk_notebook_popup_disable())
//
// # GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the #GtkBuildable interface
// supports placing children into tabs by specifying tab as the
// type attribute of a <child> element. Note that the content
// of the tab must be created before the tab can be filled.
// A tab child can be specified without specifying a <child>
// type attribute.
//
// To add a child widget in the notebooks action area, specify
// "action-start" or action-end as the type attribute of the
// <child> element.
//
// An example of a UI definition fragment with GtkNotebook:
// |[
// <object class="GtkNotebook">
// <child>
// <object class="GtkLabel" id="notebook-content">
// <property name="label">Content</property>
// </object>
// </child>
// <child type="tab">
// <object class="GtkLabel" id="notebook-tab">
// <property name="label">Tab</property>
// </object>
// </child>
// </object>
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// notebook
//  header.top
//     [<action widget>]
//     tabs
//        [arrow]
//        tab
//           <tab label>
//       
//        tab[.reorderable-page]
//           <tab label>
//        [arrow]
//     [<action widget>]
// 
//  stack
//  <child>
// 
//  <child>
// ]|
//
// GtkNotebook has a main CSS node with name notebook, a subnode
// with name header and below that a subnode with name tabs which
// contains one subnode per tab with name tab.
//
// If action widgets are present, their CSS nodes are placed next
// to the tabs node. If the notebook is scrollable, CSS nodes with
// name arrow are placed as first and last child of the tabs node.
//
// The main node gets the .frame style class when the notebook
// has a border (see gtk_notebook_set_show_border()).
//
// The header node gets one of the style class .top, .bottom,
// .left or .right, depending on where the tabs are placed. For
// reorderable pages, the tab node gets the .reorderable-page class.
//
// A tab node gets the .dnd style class while it is moved with drag-and-drop.
//
// The nodes are always arranged from left-to-right, regarldess of text direction.
/*

C record/class : GtkNotebook
*/
type Notebook struct {
	native *C.GtkNotebook
	// Private : container
	// Private : priv
}

func NotebookNewFromC(u unsafe.Pointer) *Notebook {
	c := (*C.GtkNotebook)(u)
	if c == nil {
		return nil
	}

	g := &Notebook{native: c}

	return g
}

func (recv *Notebook) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Notebook) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Notebook) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Notebook) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Notebook) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Notebook.
// Exercise care, as this is a potentially dangerous function if the Object is not a Notebook.
func CastToNotebook(object *gobject.Object) *Notebook {
	return NotebookNewFromC(object.ToC())
}

// Unsupported signal 'change-current-page' for Notebook : unsupported parameter object : type gint :

// Unsupported signal 'focus-tab' for Notebook : unsupported parameter object : type NotebookTab :

// Unsupported signal 'move-focus-out' for Notebook : unsupported parameter object : type DirectionType :

// Unsupported signal 'reorder-tab' for Notebook : unsupported parameter object : type DirectionType :

type signalNotebookSelectPageDetail struct {
	callback  NotebookSignalSelectPageCallback
	handlerID C.gulong
}

var signalNotebookSelectPageId int
var signalNotebookSelectPageMap = make(map[int]signalNotebookSelectPageDetail)
var signalNotebookSelectPageLock sync.Mutex

// NotebookSignalSelectPageCallback is a callback function for a 'select-page' signal emitted from a Notebook.
type NotebookSignalSelectPageCallback func(object bool) bool

/*
ConnectSelectPage connects the callback to the 'select-page' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectSelectPage to remove it.
*/
func (recv *Notebook) ConnectSelectPage(callback NotebookSignalSelectPageCallback) int {
	signalNotebookSelectPageLock.Lock()
	defer signalNotebookSelectPageLock.Unlock()

	signalNotebookSelectPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_select_page(instance, C.gpointer(uintptr(signalNotebookSelectPageId)))

	detail := signalNotebookSelectPageDetail{callback, handlerID}
	signalNotebookSelectPageMap[signalNotebookSelectPageId] = detail

	return signalNotebookSelectPageId
}

/*
DisconnectSelectPage disconnects a callback from the 'select-page' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectSelectPage.
*/
func (recv *Notebook) DisconnectSelectPage(connectionID int) {
	signalNotebookSelectPageLock.Lock()
	defer signalNotebookSelectPageLock.Unlock()

	detail, exists := signalNotebookSelectPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookSelectPageMap, connectionID)
}

//export notebook_selectPageHandler
func notebook_selectPageHandler(_ *C.GObject, c_object C.gboolean, data C.gpointer) C.gboolean {
	object := c_object == C.TRUE

	index := int(uintptr(data))
	callback := signalNotebookSelectPageMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'switch-page' for Notebook : unsupported parameter page_num : type guint :

// Creates a new #GtkNotebook widget with no pages.
/*

C function : gtk_notebook_new
*/
func NotebookNew() *Notebook {
	retC := C.gtk_notebook_new()
	retGo := NotebookNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Appends a page to @notebook.
/*

C function : gtk_notebook_append_page
*/
func (recv *Notebook) AppendPage(child *Widget, tabLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	retC := C.gtk_notebook_append_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label)
	retGo := (int32)(retC)

	return retGo
}

// Appends a page to @notebook, specifying the widget to use as the
// label in the popup menu.
/*

C function : gtk_notebook_append_page_menu
*/
func (recv *Notebook) AppendPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	retC := C.gtk_notebook_append_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label)
	retGo := (int32)(retC)

	return retGo
}

// Returns the page number of the current page.
/*

C function : gtk_notebook_get_current_page
*/
func (recv *Notebook) GetCurrentPage() int32 {
	retC := C.gtk_notebook_get_current_page((*C.GtkNotebook)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Retrieves the menu label widget of the page containing @child.
/*

C function : gtk_notebook_get_menu_label
*/
func (recv *Notebook) GetMenuLabel(child *Widget) *Widget {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_menu_label((*C.GtkNotebook)(recv.native), c_child)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the text of the menu label for the page containing
// @child.
/*

C function : gtk_notebook_get_menu_label_text
*/
func (recv *Notebook) GetMenuLabelText(child *Widget) string {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_menu_label_text((*C.GtkNotebook)(recv.native), c_child)
	retGo := C.GoString(retC)

	return retGo
}

// Returns the child widget contained in page number @page_num.
/*

C function : gtk_notebook_get_nth_page
*/
func (recv *Notebook) GetNthPage(pageNum int32) *Widget {
	c_page_num := (C.gint)(pageNum)

	retC := C.gtk_notebook_get_nth_page((*C.GtkNotebook)(recv.native), c_page_num)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns whether the tab label area has arrows for scrolling.
// See gtk_notebook_set_scrollable().
/*

C function : gtk_notebook_get_scrollable
*/
func (recv *Notebook) GetScrollable() bool {
	retC := C.gtk_notebook_get_scrollable((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether a bevel will be drawn around the notebook pages.
// See gtk_notebook_set_show_border().
/*

C function : gtk_notebook_get_show_border
*/
func (recv *Notebook) GetShowBorder() bool {
	retC := C.gtk_notebook_get_show_border((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether the tabs of the notebook are shown.
// See gtk_notebook_set_show_tabs().
/*

C function : gtk_notebook_get_show_tabs
*/
func (recv *Notebook) GetShowTabs() bool {
	retC := C.gtk_notebook_get_show_tabs((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the tab label widget for the page @child.
// %NULL is returned if @child is not in @notebook or
// if no tab label has specifically been set for @child.
/*

C function : gtk_notebook_get_tab_label
*/
func (recv *Notebook) GetTabLabel(child *Widget) *Widget {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_tab_label((*C.GtkNotebook)(recv.native), c_child)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the text of the tab label for the page containing
// @child.
/*

C function : gtk_notebook_get_tab_label_text
*/
func (recv *Notebook) GetTabLabelText(child *Widget) string {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_tab_label_text((*C.GtkNotebook)(recv.native), c_child)
	retGo := C.GoString(retC)

	return retGo
}

// Gets the edge at which the tabs for switching pages in the
// notebook are drawn.
/*

C function : gtk_notebook_get_tab_pos
*/
func (recv *Notebook) GetTabPos() PositionType {
	retC := C.gtk_notebook_get_tab_pos((*C.GtkNotebook)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// Insert a page into @notebook at the given position.
/*

C function : gtk_notebook_insert_page
*/
func (recv *Notebook) InsertPage(child *Widget, tabLabel *Widget, position int32) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_notebook_insert_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_position)
	retGo := (int32)(retC)

	return retGo
}

// Insert a page into @notebook at the given position, specifying
// the widget to use as the label in the popup menu.
/*

C function : gtk_notebook_insert_page_menu
*/
func (recv *Notebook) InsertPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget, position int32) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_notebook_insert_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label, c_position)
	retGo := (int32)(retC)

	return retGo
}

// Switches to the next page. Nothing happens if the current page is
// the last page.
/*

C function : gtk_notebook_next_page
*/
func (recv *Notebook) NextPage() {
	C.gtk_notebook_next_page((*C.GtkNotebook)(recv.native))

	return
}

// Finds the index of the page which contains the given child
// widget.
/*

C function : gtk_notebook_page_num
*/
func (recv *Notebook) PageNum(child *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_page_num((*C.GtkNotebook)(recv.native), c_child)
	retGo := (int32)(retC)

	return retGo
}

// Disables the popup menu.
/*

C function : gtk_notebook_popup_disable
*/
func (recv *Notebook) PopupDisable() {
	C.gtk_notebook_popup_disable((*C.GtkNotebook)(recv.native))

	return
}

// Enables the popup menu: if the user clicks with the right
// mouse button on the tab labels, a menu with all the pages
// will be popped up.
/*

C function : gtk_notebook_popup_enable
*/
func (recv *Notebook) PopupEnable() {
	C.gtk_notebook_popup_enable((*C.GtkNotebook)(recv.native))

	return
}

// Prepends a page to @notebook.
/*

C function : gtk_notebook_prepend_page
*/
func (recv *Notebook) PrependPage(child *Widget, tabLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	retC := C.gtk_notebook_prepend_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label)
	retGo := (int32)(retC)

	return retGo
}

// Prepends a page to @notebook, specifying the widget to use as the
// label in the popup menu.
/*

C function : gtk_notebook_prepend_page_menu
*/
func (recv *Notebook) PrependPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	retC := C.gtk_notebook_prepend_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label)
	retGo := (int32)(retC)

	return retGo
}

// Switches to the previous page. Nothing happens if the current page
// is the first page.
/*

C function : gtk_notebook_prev_page
*/
func (recv *Notebook) PrevPage() {
	C.gtk_notebook_prev_page((*C.GtkNotebook)(recv.native))

	return
}

// Removes a page from the notebook given its index
// in the notebook.
/*

C function : gtk_notebook_remove_page
*/
func (recv *Notebook) RemovePage(pageNum int32) {
	c_page_num := (C.gint)(pageNum)

	C.gtk_notebook_remove_page((*C.GtkNotebook)(recv.native), c_page_num)

	return
}

// Reorders the page containing @child, so that it appears in position
// @position. If @position is greater than or equal to the number of
// children in the list or negative, @child will be moved to the end
// of the list.
/*

C function : gtk_notebook_reorder_child
*/
func (recv *Notebook) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_notebook_reorder_child((*C.GtkNotebook)(recv.native), c_child, c_position)

	return
}

// Switches to the page number @page_num.
//
// Note that due to historical reasons, GtkNotebook refuses
// to switch to a page unless the child widget is visible.
// Therefore, it is recommended to show child widgets before
// adding them to a notebook.
/*

C function : gtk_notebook_set_current_page
*/
func (recv *Notebook) SetCurrentPage(pageNum int32) {
	c_page_num := (C.gint)(pageNum)

	C.gtk_notebook_set_current_page((*C.GtkNotebook)(recv.native), c_page_num)

	return
}

// Changes the menu label for the page containing @child.
/*

C function : gtk_notebook_set_menu_label
*/
func (recv *Notebook) SetMenuLabel(child *Widget, menuLabel *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	C.gtk_notebook_set_menu_label((*C.GtkNotebook)(recv.native), c_child, c_menu_label)

	return
}

// Creates a new label and sets it as the menu label of @child.
/*

C function : gtk_notebook_set_menu_label_text
*/
func (recv *Notebook) SetMenuLabelText(child *Widget, menuText string) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_menu_text := C.CString(menuText)
	defer C.free(unsafe.Pointer(c_menu_text))

	C.gtk_notebook_set_menu_label_text((*C.GtkNotebook)(recv.native), c_child, c_menu_text)

	return
}

// Sets whether the tab label area will have arrows for
// scrolling if there are too many tabs to fit in the area.
/*

C function : gtk_notebook_set_scrollable
*/
func (recv *Notebook) SetScrollable(scrollable bool) {
	c_scrollable :=
		boolToGboolean(scrollable)

	C.gtk_notebook_set_scrollable((*C.GtkNotebook)(recv.native), c_scrollable)

	return
}

// Sets whether a bevel will be drawn around the notebook pages.
// This only has a visual effect when the tabs are not shown.
// See gtk_notebook_set_show_tabs().
/*

C function : gtk_notebook_set_show_border
*/
func (recv *Notebook) SetShowBorder(showBorder bool) {
	c_show_border :=
		boolToGboolean(showBorder)

	C.gtk_notebook_set_show_border((*C.GtkNotebook)(recv.native), c_show_border)

	return
}

// Sets whether to show the tabs for the notebook or not.
/*

C function : gtk_notebook_set_show_tabs
*/
func (recv *Notebook) SetShowTabs(showTabs bool) {
	c_show_tabs :=
		boolToGboolean(showTabs)

	C.gtk_notebook_set_show_tabs((*C.GtkNotebook)(recv.native), c_show_tabs)

	return
}

// Changes the tab label for @child.
// If %NULL is specified for @tab_label, then the page will
// have the label page N.
/*

C function : gtk_notebook_set_tab_label
*/
func (recv *Notebook) SetTabLabel(child *Widget, tabLabel *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	C.gtk_notebook_set_tab_label((*C.GtkNotebook)(recv.native), c_child, c_tab_label)

	return
}

// Creates a new label and sets it as the tab label for the page
// containing @child.
/*

C function : gtk_notebook_set_tab_label_text
*/
func (recv *Notebook) SetTabLabelText(child *Widget, tabText string) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_text := C.CString(tabText)
	defer C.free(unsafe.Pointer(c_tab_text))

	C.gtk_notebook_set_tab_label_text((*C.GtkNotebook)(recv.native), c_child, c_tab_text)

	return
}

// Sets the edge at which the tabs for switching pages in the
// notebook are drawn.
/*

C function : gtk_notebook_set_tab_pos
*/
func (recv *Notebook) SetTabPos(pos PositionType) {
	c_pos := (C.GtkPositionType)(pos)

	C.gtk_notebook_set_tab_pos((*C.GtkNotebook)(recv.native), c_pos)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Notebook
func (recv *Notebook) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Notebook
func (recv *Notebook) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkNotebookAccessible
*/
type NotebookAccessible struct {
	native *C.GtkNotebookAccessible
	// parent : record
	// priv : record
}

func NotebookAccessibleNewFromC(u unsafe.Pointer) *NotebookAccessible {
	c := (*C.GtkNotebookAccessible)(u)
	if c == nil {
		return nil
	}

	g := &NotebookAccessible{native: c}

	return g
}

func (recv *NotebookAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *NotebookAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *NotebookAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *NotebookAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *NotebookAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to NotebookAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a NotebookAccessible.
func CastToNotebookAccessible(object *gobject.Object) *NotebookAccessible {
	return NotebookAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by NotebookAccessible
func (recv *NotebookAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by NotebookAccessible
func (recv *NotebookAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

/*

C record/class : GtkNotebookPageAccessible
*/
type NotebookPageAccessible struct {
	native *C.GtkNotebookPageAccessible
	// parent : record
	// priv : record
}

func NotebookPageAccessibleNewFromC(u unsafe.Pointer) *NotebookPageAccessible {
	c := (*C.GtkNotebookPageAccessible)(u)
	if c == nil {
		return nil
	}

	g := &NotebookPageAccessible{native: c}

	return g
}

func (recv *NotebookPageAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *NotebookPageAccessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to NotebookPageAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a NotebookPageAccessible.
func CastToNotebookPageAccessible(object *gobject.Object) *NotebookPageAccessible {
	return NotebookPageAccessibleNewFromC(object.ToC())
}

/*

C function : gtk_notebook_page_accessible_new
*/
func NotebookPageAccessibleNew(notebook *NotebookAccessible, child *Widget) *NotebookPageAccessible {
	c_notebook := (*C.GtkNotebookAccessible)(C.NULL)
	if notebook != nil {
		c_notebook = (*C.GtkNotebookAccessible)(notebook.ToC())
	}

	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_page_accessible_new(c_notebook, c_child)
	retGo := NotebookPageAccessibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

/*

C function : gtk_notebook_page_accessible_invalidate
*/
func (recv *NotebookPageAccessible) Invalidate() {
	C.gtk_notebook_page_accessible_invalidate((*C.GtkNotebookPageAccessible)(recv.native))

	return
}

// Component returns the Component interface implemented by NotebookPageAccessible
func (recv *NotebookPageAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// GtkNumerableIcon is a subclass of #GEmblemedIcon that can
// show a number or short string as an emblem. The number can
// be overlayed on top of another emblem, if desired.
//
// It supports theming by taking font and color information
// from a provided #GtkStyleContext; see
// gtk_numerable_icon_set_style_context().
//
// Typical numerable icons:
// ![](numerableicon.png)
// ![](numerableicon2.png)
/*

C record/class : GtkNumerableIcon
*/
type NumerableIcon struct {
	native *C.GtkNumerableIcon
	// parent : record
	// Private : priv
}

func NumerableIconNewFromC(u unsafe.Pointer) *NumerableIcon {
	c := (*C.GtkNumerableIcon)(u)
	if c == nil {
		return nil
	}

	g := &NumerableIcon{native: c}

	return g
}

func (recv *NumerableIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// EmblemedIcon upcasts to *EmblemedIcon
func (recv *NumerableIcon) EmblemedIcon() *gio.EmblemedIcon {
	return gio.EmblemedIconNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *NumerableIcon) Object() *gobject.Object {
	return recv.EmblemedIcon().Object()
}

// CastToWidget down casts any arbitary Object to NumerableIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a NumerableIcon.
func CastToNumerableIcon(object *gobject.Object) *NumerableIcon {
	return NumerableIconNewFromC(object.ToC())
}

// Icon returns the Icon interface implemented by NumerableIcon
func (recv *NumerableIcon) Icon() *gio.Icon {
	return gio.IconNewFromC(recv.ToC())
}

// GtkOffscreenWindow is strictly intended to be used for obtaining
// snapshots of widgets that are not part of a normal widget hierarchy.
// Since #GtkOffscreenWindow is a toplevel widget you cannot obtain
// snapshots of a full window with it since you cannot pack a toplevel
// widget in another toplevel.
//
// The idea is to take a widget and manually set the state of it,
// add it to a GtkOffscreenWindow and then retrieve the snapshot
// as a #cairo_surface_t or #GdkPixbuf.
//
// GtkOffscreenWindow derives from #GtkWindow only as an implementation
// detail.  Applications should not use any API specific to #GtkWindow
// to operate on this object.  It should be treated as a #GtkBin that
// has no parent widget.
//
// When contained offscreen widgets are redrawn, GtkOffscreenWindow
// will emit a #GtkWidget::damage-event signal.
/*

C record/class : GtkOffscreenWindow
*/
type OffscreenWindow struct {
	native *C.GtkOffscreenWindow
	// parent_object : record
}

func OffscreenWindowNewFromC(u unsafe.Pointer) *OffscreenWindow {
	c := (*C.GtkOffscreenWindow)(u)
	if c == nil {
		return nil
	}

	g := &OffscreenWindow{native: c}

	return g
}

func (recv *OffscreenWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Window upcasts to *Window
func (recv *OffscreenWindow) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *OffscreenWindow) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *OffscreenWindow) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *OffscreenWindow) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *OffscreenWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *OffscreenWindow) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitary Object to OffscreenWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a OffscreenWindow.
func CastToOffscreenWindow(object *gobject.Object) *OffscreenWindow {
	return OffscreenWindowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by OffscreenWindow
func (recv *OffscreenWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by OffscreenWindow
func (recv *OffscreenWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// GtkOverlay is a container which contains a single main child, on top
// of which it can place overlay widgets. The position of each overlay
// widget is determined by its #GtkWidget:halign and #GtkWidget:valign
// properties. E.g. a widget with both alignments set to %GTK_ALIGN_START
// will be placed at the top left corner of the GtkOverlay container,
// whereas an overlay with halign set to %GTK_ALIGN_CENTER and valign set
// to %GTK_ALIGN_END will be placed a the bottom edge of the GtkOverlay,
// horizontally centered. The position can be adjusted by setting the margin
// properties of the child to non-zero values.
//
// More complicated placement of overlays is possible by connecting
// to the #GtkOverlay::get-child-position signal.
//
// # GtkOverlay as GtkBuildable
//
// The GtkOverlay implementation of the GtkBuildable interface
// supports placing a child as an overlay by specifying overlay as
// the type attribute of a `<child>` element.
//
// # CSS nodes
//
// GtkOverlay has a single CSS node with the name overlay. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// .left, .right, .top, and/or .bottom according to their position.
/*

C record/class : GtkOverlay
*/
type Overlay struct {
	native *C.GtkOverlay
	// parent : record
	// priv : record
}

func OverlayNewFromC(u unsafe.Pointer) *Overlay {
	c := (*C.GtkOverlay)(u)
	if c == nil {
		return nil
	}

	g := &Overlay{native: c}

	return g
}

func (recv *Overlay) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Overlay) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Overlay) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Overlay) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Overlay) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Overlay) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Overlay.
// Exercise care, as this is a potentially dangerous function if the Object is not a Overlay.
func CastToOverlay(object *gobject.Object) *Overlay {
	return OverlayNewFromC(object.ToC())
}

// Unsupported signal 'get-child-position' for Overlay : unsupported parameter allocation : type Gdk.Rectangle : Blacklisted record : GdkRectangle

// ImplementorIface returns the ImplementorIface interface implemented by Overlay
func (recv *Overlay) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Overlay
func (recv *Overlay) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A GtkPageSetup object stores the page size, orientation and margins.
// The idea is that you can get one of these from the page setup dialog
// and then pass it to the #GtkPrintOperation when printing.
// The benefit of splitting this out of the #GtkPrintSettings is that
// these affect the actual layout of the page, and thus need to be set
// long before user prints.
//
// ## Margins ## {#print-margins}
// The margins specified in this object are the print margins, i.e. the
// parts of the page that the printer cannot print on. These are different
// from the layout margins that a word processor uses; they are typically
// used to determine the minimal size for the layout
// margins.
//
// To obtain a #GtkPageSetup use gtk_page_setup_new() to get the defaults,
// or use gtk_print_run_page_setup_dialog() to show the page setup dialog
// and receive the resulting page setup.
//
// ## A page setup dialog
//
// |[<!-- language="C" -->
// static GtkPrintSettings *settings = NULL;
// static GtkPageSetup *page_setup = NULL;
//
// static void
// do_page_setup (void)
// {
// GtkPageSetup *new_page_setup;
//
// if (settings == NULL)
// settings = gtk_print_settings_new ();
//
// new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
// page_setup, settings);
//
// if (page_setup)
// g_object_unref (page_setup);
//
// page_setup = new_page_setup;
// }
// ]|
//
// Printing support was added in GTK+ 2.10.
/*

C record/class : GtkPageSetup
*/
type PageSetup struct {
	native *C.GtkPageSetup
}

func PageSetupNewFromC(u unsafe.Pointer) *PageSetup {
	c := (*C.GtkPageSetup)(u)
	if c == nil {
		return nil
	}

	g := &PageSetup{native: c}

	return g
}

func (recv *PageSetup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *PageSetup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to PageSetup.
// Exercise care, as this is a potentially dangerous function if the Object is not a PageSetup.
func CastToPageSetup(object *gobject.Object) *PageSetup {
	return PageSetupNewFromC(object.ToC())
}

// #GtkPaned has two panes, arranged either
// horizontally or vertically. The division between
// the two panes is adjustable by the user by dragging
// a handle.
//
// Child widgets are
// added to the panes of the widget with gtk_paned_pack1() and
// gtk_paned_pack2(). The division between the two children is set by default
// from the size requests of the children, but it can be adjusted by the
// user.
//
// A paned widget draws a separator between the two child widgets and a
// small handle that the user can drag to adjust the division. It does not
// draw any relief around the children or around the separator. (The space
// in which the separator is called the gutter.) Often, it is useful to put
// each child inside a #GtkFrame with the shadow type set to %GTK_SHADOW_IN
// so that the gutter appears as a ridge. No separator is drawn if one of
// the children is missing.
//
// Each child has two options that can be set, @resize and @shrink. If
// @resize is true, then when the #GtkPaned is resized, that child will
// expand or shrink along with the paned widget. If @shrink is true, then
// that child can be made smaller than its requisition by the user.
// Setting @shrink to %FALSE allows the application to set a minimum size.
// If @resize is false for both children, then this is treated as if
// @resize is true for both children.
//
// The application can set the position of the slider as if it were set
// by the user, by calling gtk_paned_set_position().
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// paned
//  <child>
//  separator[.wide]
//  <child>
// ]|
//
// GtkPaned has a main CSS node with name paned, and a subnode for
// the separator with name separator. The subnode gets a .wide style
// class when the paned is supposed to be wide.
//
// In horizontal orientation, the nodes of the children are always arranged
// from left to right. So :first-child will always select the leftmost child,
// regardless of text direction.
//
// ## Creating a paned widget with minimum sizes.
//
// |[<!-- language="C" -->
// GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
// GtkWidget *frame1 = gtk_frame_new (NULL);
// GtkWidget *frame2 = gtk_frame_new (NULL);
// gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_IN);
// gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_IN);
//
// gtk_widget_set_size_request (hpaned, 200, -1);
//
// gtk_paned_pack1 (GTK_PANED (hpaned), frame1, TRUE, FALSE);
// gtk_widget_set_size_request (frame1, 50, -1);
//
// gtk_paned_pack2 (GTK_PANED (hpaned), frame2, FALSE, FALSE);
// gtk_widget_set_size_request (frame2, 50, -1);
// ]|
/*

C record/class : GtkPaned
*/
type Paned struct {
	native *C.GtkPaned
	// container : record
	// Private : priv
}

func PanedNewFromC(u unsafe.Pointer) *Paned {
	c := (*C.GtkPaned)(u)
	if c == nil {
		return nil
	}

	g := &Paned{native: c}

	return g
}

func (recv *Paned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Paned) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Paned) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Paned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Paned) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Paned.
// Exercise care, as this is a potentially dangerous function if the Object is not a Paned.
func CastToPaned(object *gobject.Object) *Paned {
	return PanedNewFromC(object.ToC())
}

// Adds a child to the top or left pane with default parameters. This is
// equivalent to
// `gtk_paned_pack1 (paned, child, FALSE, TRUE)`.
/*

C function : gtk_paned_add1
*/
func (recv *Paned) Add1(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_paned_add1((*C.GtkPaned)(recv.native), c_child)

	return
}

// Adds a child to the bottom or right pane with default parameters. This
// is equivalent to
// `gtk_paned_pack2 (paned, child, TRUE, TRUE)`.
/*

C function : gtk_paned_add2
*/
func (recv *Paned) Add2(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_paned_add2((*C.GtkPaned)(recv.native), c_child)

	return
}

// Obtains the position of the divider between the two panes.
/*

C function : gtk_paned_get_position
*/
func (recv *Paned) GetPosition() int32 {
	retC := C.gtk_paned_get_position((*C.GtkPaned)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Adds a child to the top or left pane.
/*

C function : gtk_paned_pack1
*/
func (recv *Paned) Pack1(child *Widget, resize bool, shrink bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_resize :=
		boolToGboolean(resize)

	c_shrink :=
		boolToGboolean(shrink)

	C.gtk_paned_pack1((*C.GtkPaned)(recv.native), c_child, c_resize, c_shrink)

	return
}

// Adds a child to the bottom or right pane.
/*

C function : gtk_paned_pack2
*/
func (recv *Paned) Pack2(child *Widget, resize bool, shrink bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_resize :=
		boolToGboolean(resize)

	c_shrink :=
		boolToGboolean(shrink)

	C.gtk_paned_pack2((*C.GtkPaned)(recv.native), c_child, c_resize, c_shrink)

	return
}

// Sets the position of the divider between the two panes.
/*

C function : gtk_paned_set_position
*/
func (recv *Paned) SetPosition(position int32) {
	c_position := (C.gint)(position)

	C.gtk_paned_set_position((*C.GtkPaned)(recv.native), c_position)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Paned
func (recv *Paned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Paned
func (recv *Paned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Paned
func (recv *Paned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkPanedAccessible
*/
type PanedAccessible struct {
	native *C.GtkPanedAccessible
	// parent : record
	// priv : record
}

func PanedAccessibleNewFromC(u unsafe.Pointer) *PanedAccessible {
	c := (*C.GtkPanedAccessible)(u)
	if c == nil {
		return nil
	}

	g := &PanedAccessible{native: c}

	return g
}

func (recv *PanedAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *PanedAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *PanedAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *PanedAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *PanedAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to PanedAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a PanedAccessible.
func CastToPanedAccessible(object *gobject.Object) *PanedAccessible {
	return PanedAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by PanedAccessible
func (recv *PanedAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by PanedAccessible
func (recv *PanedAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// #GtkPlacesSidebar is a widget that displays a list of frequently-used places in the
// file system:  the users home directory, the users bookmarks, and volumes and drives.
// This widget is used as a sidebar in #GtkFileChooser and may be used by file managers
// and similar programs.
//
// The places sidebar displays drives and volumes, and will automatically mount
// or unmount them when the user selects them.
//
// Applications can hook to various signals in the places sidebar to customize
// its behavior.  For example, they can add extra commands to the context menu
// of the sidebar.
//
// While bookmarks are completely in control of the user, the places sidebar also
// allows individual applications to provide extra shortcut folders that are unique
// to each application.  For example, a Paint program may want to add a shortcut
// for a Clipart folder.  You can do this with gtk_places_sidebar_add_shortcut().
//
// To make use of the places sidebar, an application at least needs to connect
// to the #GtkPlacesSidebar::open-location signal.  This is emitted when the
// user selects in the sidebar a location to open.  The application should also
// call gtk_places_sidebar_set_location() when it changes the currently-viewed
// location.
//
// # CSS nodes
//
// GtkPlacesSidebar uses a single CSS node with name placessidebar and style
// class .sidebar.
//
// Among the children of the places sidebar, the following style classes can
// be used:
// - .sidebar-new-bookmark-row for the 'Add new bookmark' row
// - .sidebar-placeholder-row for a row that is a placeholder
// - .has-open-popup when a popup is open for a row
/*

C record/class : GtkPlacesSidebar
*/
type PlacesSidebar struct {
	native *C.GtkPlacesSidebar
}

func PlacesSidebarNewFromC(u unsafe.Pointer) *PlacesSidebar {
	c := (*C.GtkPlacesSidebar)(u)
	if c == nil {
		return nil
	}

	g := &PlacesSidebar{native: c}

	return g
}

func (recv *PlacesSidebar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ScrolledWindow upcasts to *ScrolledWindow
func (recv *PlacesSidebar) ScrolledWindow() *ScrolledWindow {
	return ScrolledWindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *PlacesSidebar) Bin() *Bin {
	return recv.ScrolledWindow().Bin()
}

// Container upcasts to *Container
func (recv *PlacesSidebar) Container() *Container {
	return recv.ScrolledWindow().Container()
}

// Widget upcasts to *Widget
func (recv *PlacesSidebar) Widget() *Widget {
	return recv.ScrolledWindow().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *PlacesSidebar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ScrolledWindow().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *PlacesSidebar) Object() *gobject.Object {
	return recv.ScrolledWindow().Object()
}

// CastToWidget down casts any arbitary Object to PlacesSidebar.
// Exercise care, as this is a potentially dangerous function if the Object is not a PlacesSidebar.
func CastToPlacesSidebar(object *gobject.Object) *PlacesSidebar {
	return PlacesSidebarNewFromC(object.ToC())
}

type signalPlacesSidebarShowConnectToServerDetail struct {
	callback  PlacesSidebarSignalShowConnectToServerCallback
	handlerID C.gulong
}

var signalPlacesSidebarShowConnectToServerId int
var signalPlacesSidebarShowConnectToServerMap = make(map[int]signalPlacesSidebarShowConnectToServerDetail)
var signalPlacesSidebarShowConnectToServerLock sync.Mutex

// PlacesSidebarSignalShowConnectToServerCallback is a callback function for a 'show-connect-to-server' signal emitted from a PlacesSidebar.
type PlacesSidebarSignalShowConnectToServerCallback func()

/*
ConnectShowConnectToServer connects the callback to the 'show-connect-to-server' signal for the PlacesSidebar.

The returned value represents the connection, and may be passed to DisconnectShowConnectToServer to remove it.
*/
func (recv *PlacesSidebar) ConnectShowConnectToServer(callback PlacesSidebarSignalShowConnectToServerCallback) int {
	signalPlacesSidebarShowConnectToServerLock.Lock()
	defer signalPlacesSidebarShowConnectToServerLock.Unlock()

	signalPlacesSidebarShowConnectToServerId++
	instance := C.gpointer(recv.native)
	handlerID := C.PlacesSidebar_signal_connect_show_connect_to_server(instance, C.gpointer(uintptr(signalPlacesSidebarShowConnectToServerId)))

	detail := signalPlacesSidebarShowConnectToServerDetail{callback, handlerID}
	signalPlacesSidebarShowConnectToServerMap[signalPlacesSidebarShowConnectToServerId] = detail

	return signalPlacesSidebarShowConnectToServerId
}

/*
DisconnectShowConnectToServer disconnects a callback from the 'show-connect-to-server' signal for the PlacesSidebar.

The connectionID should be a value returned from a call to ConnectShowConnectToServer.
*/
func (recv *PlacesSidebar) DisconnectShowConnectToServer(connectionID int) {
	signalPlacesSidebarShowConnectToServerLock.Lock()
	defer signalPlacesSidebarShowConnectToServerLock.Unlock()

	detail, exists := signalPlacesSidebarShowConnectToServerMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPlacesSidebarShowConnectToServerMap, connectionID)
}

//export placessidebar_showConnectToServerHandler
func placessidebar_showConnectToServerHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalPlacesSidebarShowConnectToServerMap[index].callback
	callback()
}

// Returns the value previously set with gtk_places_sidebar_set_show_connect_to_server()
/*

C function : gtk_places_sidebar_get_show_connect_to_server
*/
func (recv *PlacesSidebar) GetShowConnectToServer() bool {
	retC := C.gtk_places_sidebar_get_show_connect_to_server((*C.GtkPlacesSidebar)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by PlacesSidebar
func (recv *PlacesSidebar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by PlacesSidebar
func (recv *PlacesSidebar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkPlug

// GtkPopover is a bubble-like context window, primarily meant to
// provide context-dependent information or options. Popovers are
// attached to a widget, passed at construction time on gtk_popover_new(),
// or updated afterwards through gtk_popover_set_relative_to(), by
// default they will point to the whole widget area, although this
// behavior can be changed through gtk_popover_set_pointing_to().
//
// The position of a popover relative to the widget it is attached to
// can also be changed through gtk_popover_set_position().
//
// By default, #GtkPopover performs a GTK+ grab, in order to ensure
// input events get redirected to it while it is shown, and also so
// the popover is dismissed in the expected situations (clicks outside
// the popover, or the Esc key being pressed). If no such modal behavior
// is desired on a popover, gtk_popover_set_modal() may be called on it
// to tweak its behavior.
//
// ## GtkPopover as menu replacement
//
// GtkPopover is often used to replace menus. To facilitate this, it
// supports being populated from a #GMenuModel, using
// gtk_popover_new_from_model(). In addition to all the regular menu
// model features, this function supports rendering sections in the
// model in a more compact form, as a row of icon buttons instead of
// menu items.
//
// To use this rendering, set the display-hint attribute of the
// section to horizontal-buttons and set the icons of your items
// with the verb-icon attribute.
//
// |[
// <section>
// <attribute name="display-hint">horizontal-buttons</attribute>
// <item>
// <attribute name="label">Cut</attribute>
// <attribute name="action">app.cut</attribute>
// <attribute name="verb-icon">edit-cut-symbolic</attribute>
// </item>
// <item>
// <attribute name="label">Copy</attribute>
// <attribute name="action">app.copy</attribute>
// <attribute name="verb-icon">edit-copy-symbolic</attribute>
// </item>
// <item>
// <attribute name="label">Paste</attribute>
// <attribute name="action">app.paste</attribute>
// <attribute name="verb-icon">edit-paste-symbolic</attribute>
// </item>
// </section>
// ]|
//
// # CSS nodes
//
// GtkPopover has a single css node called popover. It always gets the
// .background style class and it gets the .menu style class if it is
// menu-like (e.g. #GtkPopoverMenu or created using gtk_popover_new_from_model().
//
// Particular uses of GtkPopover, such as touch selection popups
// or magnifiers in #GtkEntry or #GtkTextView get style classes
// like .touch-selection or .magnifier to differentiate from
// plain popovers.
/*

C record/class : GtkPopover
*/
type Popover struct {
	native *C.GtkPopover
	// parent_instance : record
	// Private : priv
}

func PopoverNewFromC(u unsafe.Pointer) *Popover {
	c := (*C.GtkPopover)(u)
	if c == nil {
		return nil
	}

	g := &Popover{native: c}

	return g
}

func (recv *Popover) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Popover) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Popover) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Popover) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Popover) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Popover) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Popover.
// Exercise care, as this is a potentially dangerous function if the Object is not a Popover.
func CastToPopover(object *gobject.Object) *Popover {
	return PopoverNewFromC(object.ToC())
}

type signalPopoverClosedDetail struct {
	callback  PopoverSignalClosedCallback
	handlerID C.gulong
}

var signalPopoverClosedId int
var signalPopoverClosedMap = make(map[int]signalPopoverClosedDetail)
var signalPopoverClosedLock sync.Mutex

// PopoverSignalClosedCallback is a callback function for a 'closed' signal emitted from a Popover.
type PopoverSignalClosedCallback func()

/*
ConnectClosed connects the callback to the 'closed' signal for the Popover.

The returned value represents the connection, and may be passed to DisconnectClosed to remove it.
*/
func (recv *Popover) ConnectClosed(callback PopoverSignalClosedCallback) int {
	signalPopoverClosedLock.Lock()
	defer signalPopoverClosedLock.Unlock()

	signalPopoverClosedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Popover_signal_connect_closed(instance, C.gpointer(uintptr(signalPopoverClosedId)))

	detail := signalPopoverClosedDetail{callback, handlerID}
	signalPopoverClosedMap[signalPopoverClosedId] = detail

	return signalPopoverClosedId
}

/*
DisconnectClosed disconnects a callback from the 'closed' signal for the Popover.

The connectionID should be a value returned from a call to ConnectClosed.
*/
func (recv *Popover) DisconnectClosed(connectionID int) {
	signalPopoverClosedLock.Lock()
	defer signalPopoverClosedLock.Unlock()

	detail, exists := signalPopoverClosedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPopoverClosedMap, connectionID)
}

//export popover_closedHandler
func popover_closedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalPopoverClosedMap[index].callback
	callback()
}

// Unsupported : gtk_popover_get_pointing_to : unsupported parameter rect : Blacklisted record : GdkRectangle

// Returns the preferred position of @popover.
/*

C function : gtk_popover_get_position
*/
func (recv *Popover) GetPosition() PositionType {
	retC := C.gtk_popover_get_position((*C.GtkPopover)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Popover
func (recv *Popover) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Popover
func (recv *Popover) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkPopoverAccessible
*/
type PopoverAccessible struct {
	native *C.GtkPopoverAccessible
	// parent : record
}

func PopoverAccessibleNewFromC(u unsafe.Pointer) *PopoverAccessible {
	c := (*C.GtkPopoverAccessible)(u)
	if c == nil {
		return nil
	}

	g := &PopoverAccessible{native: c}

	return g
}

func (recv *PopoverAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *PopoverAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *PopoverAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *PopoverAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *PopoverAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to PopoverAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a PopoverAccessible.
func CastToPopoverAccessible(object *gobject.Object) *PopoverAccessible {
	return PopoverAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by PopoverAccessible
func (recv *PopoverAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// GtkPopoverMenu is a subclass of #GtkPopover that treats its
// children like menus and allows switching between them. It is
// meant to be used primarily together with #GtkModelButton, but
// any widget can be used, such as #GtkSpinButton or #GtkScale.
// In this respect, GtkPopoverMenu is more flexible than popovers
// that are created from a #GMenuModel with gtk_popover_new_from_model().
//
// To add a child as a submenu, set the #GtkPopoverMenu:submenu
// child property to the name of the submenu. To let the user open
// this submenu, add a #GtkModelButton whose #GtkModelButton:menu-name
// property is set to the name you've given to the submenu.
//
// By convention, the first child of a submenu should be a #GtkModelButton
// to switch back to the parent menu. Such a button should use the
// #GtkModelButton:inverted and #GtkModelButton:centered properties
// to achieve a title-like appearance and place the submenu indicator
// at the opposite side. To switch back to the main menu, use "main"
// as the menu name.
//
// # Example
//
// |[
// <object class="GtkPopoverMenu">
// <child>
// <object class="GtkBox">
// <property name="visible">True</property>
// <property name="margin">10</property>
// <child>
// <object class="GtkModelButton">
// <property name="visible">True</property>
// <property name="action-name">win.frob</property>
// <property name="text" translatable="yes">Frob</property>
// </object>
// </child>
// <child>
// <object class="GtkModelButton">
// <property name="visible">True</property>
// <property name="menu-name">more</property>
// <property name="text" translatable="yes">More</property>
// </object>
// </child>
// </object>
// </child>
// <child>
// <object class="GtkBox">
// <property name="visible">True</property>
// <property name="margin">10</property>
// <child>
// <object class="GtkModelButton">
// <property name="visible">True</property>
// <property name="action-name">win.foo</property>
// <property name="text" translatable="yes">Foo</property>
// </object>
// </child>
// <child>
// <object class="GtkModelButton">
// <property name="visible">True</property>
// <property name="action-name">win.bar</property>
// <property name="text" translatable="yes">Bar</property>
// </object>
// </child>
// </object>
// <packing>
// <property name="submenu">more</property>
// </packing>
// </child>
// </object>
// ]|
//
// Just like normal popovers created using gtk_popover_new_from_model,
// #GtkPopoverMenu instances have a single css node called "popover"
// and get the .menu style class.
/*

C record/class : GtkPopoverMenu
*/
type PopoverMenu struct {
	native *C.GtkPopoverMenu
}

func PopoverMenuNewFromC(u unsafe.Pointer) *PopoverMenu {
	c := (*C.GtkPopoverMenu)(u)
	if c == nil {
		return nil
	}

	g := &PopoverMenu{native: c}

	return g
}

func (recv *PopoverMenu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Popover upcasts to *Popover
func (recv *PopoverMenu) Popover() *Popover {
	return PopoverNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *PopoverMenu) Bin() *Bin {
	return recv.Popover().Bin()
}

// Container upcasts to *Container
func (recv *PopoverMenu) Container() *Container {
	return recv.Popover().Container()
}

// Widget upcasts to *Widget
func (recv *PopoverMenu) Widget() *Widget {
	return recv.Popover().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *PopoverMenu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Popover().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *PopoverMenu) Object() *gobject.Object {
	return recv.Popover().Object()
}

// CastToWidget down casts any arbitary Object to PopoverMenu.
// Exercise care, as this is a potentially dangerous function if the Object is not a PopoverMenu.
func CastToPopoverMenu(object *gobject.Object) *PopoverMenu {
	return PopoverMenuNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by PopoverMenu
func (recv *PopoverMenu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by PopoverMenu
func (recv *PopoverMenu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A GtkPrintContext encapsulates context information that is required when
// drawing pages for printing, such as the cairo context and important
// parameters like page size and resolution. It also lets you easily
// create #PangoLayout and #PangoContext objects that match the font metrics
// of the cairo surface.
//
// GtkPrintContext objects gets passed to the #GtkPrintOperation::begin-print,
// #GtkPrintOperation::end-print, #GtkPrintOperation::request-page-setup and
// #GtkPrintOperation::draw-page signals on the #GtkPrintOperation.
//
// ## Using GtkPrintContext in a #GtkPrintOperation::draw-page callback
//
// |[<!-- language="C" -->
// static void
// draw_page (GtkPrintOperation *operation,
// GtkPrintContext   *context,
// int                page_nr)
// {
// cairo_t *cr;
// PangoLayout *layout;
// PangoFontDescription *desc;
//
// cr = gtk_print_context_get_cairo_context (context);
//
// Draw a red rectangle, as wide as the paper (inside the margins)
// cairo_set_source_rgb (cr, 1.0, 0, 0);
// cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
// cairo_fill (cr);
//
// Draw some lines
// cairo_move_to (cr, 20, 10);
// cairo_line_to (cr, 40, 20);
// cairo_arc (cr, 60, 60, 20, 0, M_PI);
// cairo_line_to (cr, 80, 20);
//
// cairo_set_source_rgb (cr, 0, 0, 0);
// cairo_set_line_width (cr, 5);
// cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
// cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
// cairo_stroke (cr);
//
// Draw some text
// layout = gtk_print_context_create_pango_layout (context);
// pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
// desc = pango_font_description_from_string ("sans 28");
// pango_layout_set_font_description (layout, desc);
// pango_font_description_free (desc);
//
// cairo_move_to (cr, 30, 20);
// pango_cairo_layout_path (cr, layout);
//
// Font Outline
// cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
// cairo_set_line_width (cr, 0.5);
// cairo_stroke_preserve (cr);
//
// Font Fill
// cairo_set_source_rgb (cr, 0, 0.0, 1.0);
// cairo_fill (cr);
//
// g_object_unref (layout);
// }
// ]|
//
// Printing support was added in GTK+ 2.10.
/*

C record/class : GtkPrintContext
*/
type PrintContext struct {
	native *C.GtkPrintContext
}

func PrintContextNewFromC(u unsafe.Pointer) *PrintContext {
	c := (*C.GtkPrintContext)(u)
	if c == nil {
		return nil
	}

	g := &PrintContext{native: c}

	return g
}

func (recv *PrintContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *PrintContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to PrintContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintContext.
func CastToPrintContext(object *gobject.Object) *PrintContext {
	return PrintContextNewFromC(object.ToC())
}

// GtkPrintOperation is the high-level, portable printing API.
// It looks a bit different than other GTK+ dialogs such as the
// #GtkFileChooser, since some platforms dont expose enough
// infrastructure to implement a good print dialog. On such
// platforms, GtkPrintOperation uses the native print dialog.
// On platforms which do not provide a native print dialog, GTK+
// uses its own, see #GtkPrintUnixDialog.
//
// The typical way to use the high-level printing API is to create
// a GtkPrintOperation object with gtk_print_operation_new() when
// the user selects to print. Then you set some properties on it,
// e.g. the page size, any #GtkPrintSettings from previous print
// operations, the number of pages, the current page, etc.
//
// Then you start the print operation by calling gtk_print_operation_run().
// It will then show a dialog, let the user select a printer and
// options. When the user finished the dialog various signals will
// be emitted on the #GtkPrintOperation, the main one being
// #GtkPrintOperation::draw-page, which you are supposed to catch
// and render the page on the provided #GtkPrintContext using Cairo.
//
// # The high-level printing API
//
// |[<!-- language="C" -->
// static GtkPrintSettings *settings = NULL;
//
// static void
// do_print (void)
// {
// GtkPrintOperation *print;
// GtkPrintOperationResult res;
//
// print = gtk_print_operation_new ();
//
// if (settings != NULL)
// gtk_print_operation_set_print_settings (print, settings);
//
// g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
// g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
// res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
// GTK_WINDOW (main_window), NULL);
//
// if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
// {
// if (settings != NULL)
// g_object_unref (settings);
// settings = g_object_ref (gtk_print_operation_get_print_settings (print));
// }
//
// g_object_unref (print);
// }
// ]|
//
// By default GtkPrintOperation uses an external application to do
// print preview. To implement a custom print preview, an application
// must connect to the preview signal. The functions
// gtk_print_operation_preview_render_page(),
// gtk_print_operation_preview_end_preview() and
// gtk_print_operation_preview_is_selected()
// are useful when implementing a print preview.
/*

C record/class : GtkPrintOperation
*/
type PrintOperation struct {
	native *C.GtkPrintOperation
	// parent_instance : record
	// Private : priv
}

func PrintOperationNewFromC(u unsafe.Pointer) *PrintOperation {
	c := (*C.GtkPrintOperation)(u)
	if c == nil {
		return nil
	}

	g := &PrintOperation{native: c}

	return g
}

func (recv *PrintOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *PrintOperation) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to PrintOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintOperation.
func CastToPrintOperation(object *gobject.Object) *PrintOperation {
	return PrintOperationNewFromC(object.ToC())
}

// PrintOperationPreview returns the PrintOperationPreview interface implemented by PrintOperation
func (recv *PrintOperation) PrintOperationPreview() *PrintOperationPreview {
	return PrintOperationPreviewNewFromC(recv.ToC())
}

// A GtkPrintSettings object represents the settings of a print dialog in
// a system-independent way. The main use for this object is that once
// youve printed you can get a settings object that represents the settings
// the user chose, and the next time you print you can pass that object in so
// that the user doesnt have to re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save
// the settings for the next time your app runs, or even store them in a
// document. The predefined keys try to use shared values as much as possible
// so that moving such a document between systems still works.
//
// Printing support was added in GTK+ 2.10.
/*

C record/class : GtkPrintSettings
*/
type PrintSettings struct {
	native *C.GtkPrintSettings
}

func PrintSettingsNewFromC(u unsafe.Pointer) *PrintSettings {
	c := (*C.GtkPrintSettings)(u)
	if c == nil {
		return nil
	}

	g := &PrintSettings{native: c}

	return g
}

func (recv *PrintSettings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *PrintSettings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to PrintSettings.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintSettings.
func CastToPrintSettings(object *gobject.Object) *PrintSettings {
	return PrintSettingsNewFromC(object.ToC())
}

// The #GtkProgressBar is typically used to display the progress of a long
// running operation. It provides a visual clue that processing is underway.
// The GtkProgressBar can be used in two different modes: percentage mode
// and activity mode.
//
// When an application can determine how much work needs to take place
// (e.g. read a fixed number of bytes from a file) and can monitor its
// progress, it can use the GtkProgressBar in percentage mode and the
// user sees a growing bar indicating the percentage of the work that
// has been completed. In this mode, the application is required to call
// gtk_progress_bar_set_fraction() periodically to update the progress bar.
//
// When an application has no accurate way of knowing the amount of work
// to do, it can use the #GtkProgressBar in activity mode, which shows
// activity by a block moving back and forth within the progress area. In
// this mode, the application is required to call gtk_progress_bar_pulse()
// periodically to update the progress bar.
//
// There is quite a bit of flexibility provided to control the appearance
// of the #GtkProgressBar. Functions are provided to control the orientation
// of the bar, optional text can be displayed along with the bar, and the
// step size used in activity mode can be set.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// progressbar[.osd]
//  [text]
//  trough[.empty][.full]
//  progress[.pulse]
// ]|
//
// GtkProgressBar has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
/*

C record/class : GtkProgressBar
*/
type ProgressBar struct {
	native *C.GtkProgressBar
	// parent : record
	// Private : priv
}

func ProgressBarNewFromC(u unsafe.Pointer) *ProgressBar {
	c := (*C.GtkProgressBar)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBar{native: c}

	return g
}

func (recv *ProgressBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *ProgressBar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ProgressBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ProgressBar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to ProgressBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProgressBar.
func CastToProgressBar(object *gobject.Object) *ProgressBar {
	return ProgressBarNewFromC(object.ToC())
}

// Creates a new #GtkProgressBar.
/*

C function : gtk_progress_bar_new
*/
func ProgressBarNew() *ProgressBar {
	retC := C.gtk_progress_bar_new()
	retGo := ProgressBarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the current fraction of the task thats been completed.
/*

C function : gtk_progress_bar_get_fraction
*/
func (recv *ProgressBar) GetFraction() float64 {
	retC := C.gtk_progress_bar_get_fraction((*C.GtkProgressBar)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Gets the value set by gtk_progress_bar_set_inverted().
/*

C function : gtk_progress_bar_get_inverted
*/
func (recv *ProgressBar) GetInverted() bool {
	retC := C.gtk_progress_bar_get_inverted((*C.GtkProgressBar)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves the pulse step set with gtk_progress_bar_set_pulse_step().
/*

C function : gtk_progress_bar_get_pulse_step
*/
func (recv *ProgressBar) GetPulseStep() float64 {
	retC := C.gtk_progress_bar_get_pulse_step((*C.GtkProgressBar)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Retrieves the text that is displayed with the progress bar,
// if any, otherwise %NULL. The return value is a reference
// to the text, not a copy of it, so will become invalid
// if you change the text in the progress bar.
/*

C function : gtk_progress_bar_get_text
*/
func (recv *ProgressBar) GetText() string {
	retC := C.gtk_progress_bar_get_text((*C.GtkProgressBar)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Indicates that some progress has been made, but you dont know how much.
// Causes the progress bar to enter activity mode, where a block
// bounces back and forth. Each call to gtk_progress_bar_pulse()
// causes the block to move by a little bit (the amount of movement
// per pulse is determined by gtk_progress_bar_set_pulse_step()).
/*

C function : gtk_progress_bar_pulse
*/
func (recv *ProgressBar) Pulse() {
	C.gtk_progress_bar_pulse((*C.GtkProgressBar)(recv.native))

	return
}

// Causes the progress bar to fill in the given fraction
// of the bar. The fraction should be between 0.0 and 1.0,
// inclusive.
/*

C function : gtk_progress_bar_set_fraction
*/
func (recv *ProgressBar) SetFraction(fraction float64) {
	c_fraction := (C.gdouble)(fraction)

	C.gtk_progress_bar_set_fraction((*C.GtkProgressBar)(recv.native), c_fraction)

	return
}

// Progress bars normally grow from top to bottom or left to right.
// Inverted progress bars grow in the opposite direction.
/*

C function : gtk_progress_bar_set_inverted
*/
func (recv *ProgressBar) SetInverted(inverted bool) {
	c_inverted :=
		boolToGboolean(inverted)

	C.gtk_progress_bar_set_inverted((*C.GtkProgressBar)(recv.native), c_inverted)

	return
}

// Sets the fraction of total progress bar length to move the
// bouncing block for each call to gtk_progress_bar_pulse().
/*

C function : gtk_progress_bar_set_pulse_step
*/
func (recv *ProgressBar) SetPulseStep(fraction float64) {
	c_fraction := (C.gdouble)(fraction)

	C.gtk_progress_bar_set_pulse_step((*C.GtkProgressBar)(recv.native), c_fraction)

	return
}

// Causes the given @text to appear next to the progress bar.
//
// If @text is %NULL and #GtkProgressBar:show-text is %TRUE, the current
// value of #GtkProgressBar:fraction will be displayed as a percentage.
//
// If @text is non-%NULL and #GtkProgressBar:show-text is %TRUE, the text
// will be displayed. In this case, it will not display the progress
// percentage. If @text is the empty string, the progress bar will still
// be styled and sized suitably for containing text, as long as
// #GtkProgressBar:show-text is %TRUE.
/*

C function : gtk_progress_bar_set_text
*/
func (recv *ProgressBar) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_progress_bar_set_text((*C.GtkProgressBar)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ProgressBar
func (recv *ProgressBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ProgressBar
func (recv *ProgressBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ProgressBar
func (recv *ProgressBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkProgressBarAccessible
*/
type ProgressBarAccessible struct {
	native *C.GtkProgressBarAccessible
	// parent : record
	// priv : record
}

func ProgressBarAccessibleNewFromC(u unsafe.Pointer) *ProgressBarAccessible {
	c := (*C.GtkProgressBarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBarAccessible{native: c}

	return g
}

func (recv *ProgressBarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ProgressBarAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ProgressBarAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ProgressBarAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ProgressBarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProgressBarAccessible.
func CastToProgressBarAccessible(object *gobject.Object) *ProgressBarAccessible {
	return ProgressBarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ProgressBarAccessible
func (recv *ProgressBarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ProgressBarAccessible
func (recv *ProgressBarAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// A #GtkRadioAction is similar to #GtkRadioMenuItem. A number of radio
// actions can be linked together so that only one may be active at any
// one time.
/*

C record/class : GtkRadioAction
*/
type RadioAction struct {
	native *C.GtkRadioAction
	// parent : record
	// Private : private_data
}

func RadioActionNewFromC(u unsafe.Pointer) *RadioAction {
	c := (*C.GtkRadioAction)(u)
	if c == nil {
		return nil
	}

	g := &RadioAction{native: c}

	return g
}

func (recv *RadioAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleAction upcasts to *ToggleAction
func (recv *RadioAction) ToggleAction() *ToggleAction {
	return ToggleActionNewFromC(unsafe.Pointer(recv.native))
}

// Action upcasts to *Action
func (recv *RadioAction) Action() *Action {
	return recv.ToggleAction().Action()
}

// Object upcasts to *Object
func (recv *RadioAction) Object() *gobject.Object {
	return recv.ToggleAction().Object()
}

// CastToWidget down casts any arbitary Object to RadioAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioAction.
func CastToRadioAction(object *gobject.Object) *RadioAction {
	return RadioActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RadioAction
func (recv *RadioAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A single radio button performs the same basic function as a #GtkCheckButton,
// as its position in the object hierarchy reflects. It is only when multiple
// radio buttons are grouped together that they become a different user
// interface component in their own right.
//
// Every radio button is a member of some group of radio buttons. When one is
// selected, all other radio buttons in the same group are deselected. A
// #GtkRadioButton is one way of giving the user a choice from many options.
//
// Radio button widgets are created with gtk_radio_button_new(), passing %NULL
// as the argument if this is the first radio button in a group. In subsequent
// calls, the group you wish to add this button to should be passed as an
// argument. Optionally, gtk_radio_button_new_with_label() can be used if you
// want a text label on the radio button.
//
// Alternatively, when adding widgets to an existing group of radio buttons,
// use gtk_radio_button_new_from_widget() with a #GtkRadioButton that already
// has a group assigned to it. The convenience function
// gtk_radio_button_new_with_label_from_widget() is also provided.
//
// To retrieve the group a #GtkRadioButton is assigned to, use
// gtk_radio_button_get_group().
//
// To remove a #GtkRadioButton from one group and make it part of a new one,
// use gtk_radio_button_set_group().
//
// The group list does not need to be freed, as each #GtkRadioButton will remove
// itself and its list item when it is destroyed.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// radiobutton
//  radio
//  <child>
// ]|
//
// A GtkRadioButton with indicator (see gtk_toggle_button_set_mode()) has a
// main CSS node with name radiobutton and a subnode with name radio.
//
// |[<!-- language="plain" -->
// button.radio
//  radio
//  <child>
// ]|
//
// A GtkRadioButton without indicator changes the name of its main node
// to button and adds a .radio style class to it. The subnode is invisible
// in this case.
//
// ## How to create a group of two radio buttons.
//
// |[<!-- language="C" -->
// void create_radio_buttons (void) {
//
// GtkWidget *window, *radio1, *radio2, *box, *entry;
// window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
// box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 2);
// gtk_box_set_homogeneous (GTK_BOX (box), TRUE);
//
// Create a radio button with a GtkEntry widget
// radio1 = gtk_radio_button_new (NULL);
// entry = gtk_entry_new ();
// gtk_container_add (GTK_CONTAINER (radio1), entry);
//
//
// Create a radio button with a label
// radio2 = gtk_radio_button_new_with_label_from_widget (GTK_RADIO_BUTTON (radio1),
// "Im the second radio button.");
//
// Pack them into a box, then show all the widgets
// gtk_box_pack_start (GTK_BOX (box), radio1);
// gtk_box_pack_start (GTK_BOX (box), radio2);
// gtk_container_add (GTK_CONTAINER (window), box);
// gtk_widget_show_all (window);
// return;
// }
// ]|
//
// When an unselected button in the group is clicked the clicked button
// receives the #GtkToggleButton::toggled signal, as does the previously
// selected button.
// Inside the #GtkToggleButton::toggled handler, gtk_toggle_button_get_active()
// can be used to determine if the button has been selected or deselected.
/*

C record/class : GtkRadioButton
*/
type RadioButton struct {
	native *C.GtkRadioButton
	// check_button : record
	// Private : priv
}

func RadioButtonNewFromC(u unsafe.Pointer) *RadioButton {
	c := (*C.GtkRadioButton)(u)
	if c == nil {
		return nil
	}

	g := &RadioButton{native: c}

	return g
}

func (recv *RadioButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CheckButton upcasts to *CheckButton
func (recv *RadioButton) CheckButton() *CheckButton {
	return CheckButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToggleButton upcasts to *ToggleButton
func (recv *RadioButton) ToggleButton() *ToggleButton {
	return recv.CheckButton().ToggleButton()
}

// Button upcasts to *Button
func (recv *RadioButton) Button() *Button {
	return recv.CheckButton().Button()
}

// Bin upcasts to *Bin
func (recv *RadioButton) Bin() *Bin {
	return recv.CheckButton().Bin()
}

// Container upcasts to *Container
func (recv *RadioButton) Container() *Container {
	return recv.CheckButton().Container()
}

// Widget upcasts to *Widget
func (recv *RadioButton) Widget() *Widget {
	return recv.CheckButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CheckButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioButton) Object() *gobject.Object {
	return recv.CheckButton().Object()
}

// CastToWidget down casts any arbitary Object to RadioButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioButton.
func CastToRadioButton(object *gobject.Object) *RadioButton {
	return RadioButtonNewFromC(object.ToC())
}

// Creates a new #GtkRadioButton. To be of any practical value, a widget should
// then be packed into the radio button.
/*

C function : gtk_radio_button_new
*/
func RadioButtonNew(group *glib.SList) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	retC := C.gtk_radio_button_new(c_group)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton, adding it to the same group as
// @radio_group_member. As with gtk_radio_button_new(), a widget
// should be packed into the radio button.
/*

C function : gtk_radio_button_new_from_widget
*/
func RadioButtonNewFromWidget(radioGroupMember *RadioButton) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	retC := C.gtk_radio_button_new_from_widget(c_radio_group_member)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton with a text label.
/*

C function : gtk_radio_button_new_with_label
*/
func RadioButtonNewWithLabel(group *glib.SList, label string) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_label(c_group, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton with a text label, adding it to
// the same group as @radio_group_member.
/*

C function : gtk_radio_button_new_with_label_from_widget
*/
func RadioButtonNewWithLabelFromWidget(radioGroupMember *RadioButton, label string) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_label_from_widget(c_radio_group_member, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton containing a label, adding it to the same
// group as @group. The label will be created using
// gtk_label_new_with_mnemonic(), so underscores in @label indicate the
// mnemonic for the button.
/*

C function : gtk_radio_button_new_with_mnemonic
*/
func RadioButtonNewWithMnemonic(group *glib.SList, label string) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_mnemonic(c_group, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the button.
/*

C function : gtk_radio_button_new_with_mnemonic_from_widget
*/
func RadioButtonNewWithMnemonicFromWidget(radioGroupMember *RadioButton, label string) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_mnemonic_from_widget(c_radio_group_member, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the group assigned to a radio button.
/*

C function : gtk_radio_button_get_group
*/
func (recv *RadioButton) GetGroup() *glib.SList {
	retC := C.gtk_radio_button_get_group((*C.GtkRadioButton)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets a #GtkRadioButtons group. It should be noted that this does not change
// the layout of your interface in any way, so if you are changing the group,
// it is likely you will need to re-arrange the user interface to reflect these
// changes.
/*

C function : gtk_radio_button_set_group
*/
func (recv *RadioButton) SetGroup(group *glib.SList) {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	C.gtk_radio_button_set_group((*C.GtkRadioButton)(recv.native), c_group)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioButton
func (recv *RadioButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioButton
func (recv *RadioButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioButton
func (recv *RadioButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioButton
func (recv *RadioButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkRadioButtonAccessible
*/
type RadioButtonAccessible struct {
	native *C.GtkRadioButtonAccessible
	// parent : record
	// priv : record
}

func RadioButtonAccessibleNewFromC(u unsafe.Pointer) *RadioButtonAccessible {
	c := (*C.GtkRadioButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RadioButtonAccessible{native: c}

	return g
}

func (recv *RadioButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleButtonAccessible upcasts to *ToggleButtonAccessible
func (recv *RadioButtonAccessible) ToggleButtonAccessible() *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *RadioButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return recv.ToggleButtonAccessible().ButtonAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *RadioButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ToggleButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RadioButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ToggleButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *RadioButtonAccessible) Accessible() *Accessible {
	return recv.ToggleButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RadioButtonAccessible) Object() *atk.Object {
	return recv.ToggleButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to RadioButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioButtonAccessible.
func CastToRadioButtonAccessible(object *gobject.Object) *RadioButtonAccessible {
	return RadioButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// A radio menu item is a check menu item that belongs to a group. At each
// instant exactly one of the radio menu items from a group is selected.
//
// The group list does not need to be freed, as each #GtkRadioMenuItem will
// remove itself and its list item when it is destroyed.
//
// The correct way to create a group of radio menu items is approximatively
// this:
//
// ## How to create a group of radio menu items.
//
// |[<!-- language="C" -->
// GSList *group = NULL;
// GtkWidget *item;
// gint i;
//
// for (i = 0; i < 5; i++)
// {
// item = gtk_radio_menu_item_new_with_label (group, "This is an example");
// group = gtk_radio_menu_item_get_group (GTK_RADIO_MENU_ITEM (item));
// if (i == 1)
// gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (item), TRUE);
// }
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// menuitem
//  radio.left
//  <child>
// ]|
//
// GtkRadioMenuItem has a main CSS node with name menuitem, and a subnode
// with name radio, which gets the .left or .right style class.
/*

C record/class : GtkRadioMenuItem
*/
type RadioMenuItem struct {
	native *C.GtkRadioMenuItem
	// check_menu_item : record
	// Private : priv
}

func RadioMenuItemNewFromC(u unsafe.Pointer) *RadioMenuItem {
	c := (*C.GtkRadioMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItem{native: c}

	return g
}

func (recv *RadioMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CheckMenuItem upcasts to *CheckMenuItem
func (recv *RadioMenuItem) CheckMenuItem() *CheckMenuItem {
	return CheckMenuItemNewFromC(unsafe.Pointer(recv.native))
}

// MenuItem upcasts to *MenuItem
func (recv *RadioMenuItem) MenuItem() *MenuItem {
	return recv.CheckMenuItem().MenuItem()
}

// Bin upcasts to *Bin
func (recv *RadioMenuItem) Bin() *Bin {
	return recv.CheckMenuItem().Bin()
}

// Container upcasts to *Container
func (recv *RadioMenuItem) Container() *Container {
	return recv.CheckMenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *RadioMenuItem) Widget() *Widget {
	return recv.CheckMenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CheckMenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioMenuItem) Object() *gobject.Object {
	return recv.CheckMenuItem().Object()
}

// CastToWidget down casts any arbitary Object to RadioMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioMenuItem.
func CastToRadioMenuItem(object *gobject.Object) *RadioMenuItem {
	return RadioMenuItemNewFromC(object.ToC())
}

type signalRadioMenuItemGroupChangedDetail struct {
	callback  RadioMenuItemSignalGroupChangedCallback
	handlerID C.gulong
}

var signalRadioMenuItemGroupChangedId int
var signalRadioMenuItemGroupChangedMap = make(map[int]signalRadioMenuItemGroupChangedDetail)
var signalRadioMenuItemGroupChangedLock sync.Mutex

// RadioMenuItemSignalGroupChangedCallback is a callback function for a 'group-changed' signal emitted from a RadioMenuItem.
type RadioMenuItemSignalGroupChangedCallback func()

/*
ConnectGroupChanged connects the callback to the 'group-changed' signal for the RadioMenuItem.

The returned value represents the connection, and may be passed to DisconnectGroupChanged to remove it.
*/
func (recv *RadioMenuItem) ConnectGroupChanged(callback RadioMenuItemSignalGroupChangedCallback) int {
	signalRadioMenuItemGroupChangedLock.Lock()
	defer signalRadioMenuItemGroupChangedLock.Unlock()

	signalRadioMenuItemGroupChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RadioMenuItem_signal_connect_group_changed(instance, C.gpointer(uintptr(signalRadioMenuItemGroupChangedId)))

	detail := signalRadioMenuItemGroupChangedDetail{callback, handlerID}
	signalRadioMenuItemGroupChangedMap[signalRadioMenuItemGroupChangedId] = detail

	return signalRadioMenuItemGroupChangedId
}

/*
DisconnectGroupChanged disconnects a callback from the 'group-changed' signal for the RadioMenuItem.

The connectionID should be a value returned from a call to ConnectGroupChanged.
*/
func (recv *RadioMenuItem) DisconnectGroupChanged(connectionID int) {
	signalRadioMenuItemGroupChangedLock.Lock()
	defer signalRadioMenuItemGroupChangedLock.Unlock()

	detail, exists := signalRadioMenuItemGroupChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRadioMenuItemGroupChangedMap, connectionID)
}

//export radiomenuitem_groupChangedHandler
func radiomenuitem_groupChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalRadioMenuItemGroupChangedMap[index].callback
	callback()
}

// Creates a new #GtkRadioMenuItem.
/*

C function : gtk_radio_menu_item_new
*/
func RadioMenuItemNew(group *glib.SList) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	retC := C.gtk_radio_menu_item_new(c_group)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioMenuItem whose child is a simple #GtkLabel.
/*

C function : gtk_radio_menu_item_new_with_label
*/
func RadioMenuItemNewWithLabel(group *glib.SList, label string) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_menu_item_new_with_label(c_group, c_label)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioMenuItem containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
/*

C function : gtk_radio_menu_item_new_with_mnemonic
*/
func RadioMenuItemNewWithMnemonic(group *glib.SList, label string) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_menu_item_new_with_mnemonic(c_group, c_label)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the group to which the radio menu item belongs, as a #GList of
// #GtkRadioMenuItem. The list belongs to GTK+ and should not be freed.
/*

C function : gtk_radio_menu_item_get_group
*/
func (recv *RadioMenuItem) GetGroup() *glib.SList {
	retC := C.gtk_radio_menu_item_get_group((*C.GtkRadioMenuItem)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the group of a radio menu item, or changes it.
/*

C function : gtk_radio_menu_item_set_group
*/
func (recv *RadioMenuItem) SetGroup(group *glib.SList) {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	C.gtk_radio_menu_item_set_group((*C.GtkRadioMenuItem)(recv.native), c_group)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioMenuItem
func (recv *RadioMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkRadioMenuItemAccessible
*/
type RadioMenuItemAccessible struct {
	native *C.GtkRadioMenuItemAccessible
	// parent : record
	// priv : record
}

func RadioMenuItemAccessibleNewFromC(u unsafe.Pointer) *RadioMenuItemAccessible {
	c := (*C.GtkRadioMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItemAccessible{native: c}

	return g
}

func (recv *RadioMenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CheckMenuItemAccessible upcasts to *CheckMenuItemAccessible
func (recv *RadioMenuItemAccessible) CheckMenuItemAccessible() *CheckMenuItemAccessible {
	return CheckMenuItemAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// MenuItemAccessible upcasts to *MenuItemAccessible
func (recv *RadioMenuItemAccessible) MenuItemAccessible() *MenuItemAccessible {
	return recv.CheckMenuItemAccessible().MenuItemAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *RadioMenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.CheckMenuItemAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RadioMenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.CheckMenuItemAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *RadioMenuItemAccessible) Accessible() *Accessible {
	return recv.CheckMenuItemAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RadioMenuItemAccessible) Object() *atk.Object {
	return recv.CheckMenuItemAccessible().Object()
}

// CastToWidget down casts any arbitary Object to RadioMenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioMenuItemAccessible.
func CastToRadioMenuItemAccessible(object *gobject.Object) *RadioMenuItemAccessible {
	return RadioMenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// A #GtkRadioToolButton is a #GtkToolItem that contains a radio button,
// that is, a button that is part of a group of toggle buttons where only
// one button can be active at a time.
//
// Use gtk_radio_tool_button_new() to create a new GtkRadioToolButton. Use
// gtk_radio_tool_button_new_from_widget() to create a new GtkRadioToolButton
// that is part of the same group as an existing GtkRadioToolButton.
//
// # CSS nodes
//
// GtkRadioToolButton has a single CSS node with name toolbutton.
/*

C record/class : GtkRadioToolButton
*/
type RadioToolButton struct {
	native *C.GtkRadioToolButton
	// parent : record
}

func RadioToolButtonNewFromC(u unsafe.Pointer) *RadioToolButton {
	c := (*C.GtkRadioToolButton)(u)
	if c == nil {
		return nil
	}

	g := &RadioToolButton{native: c}

	return g
}

func (recv *RadioToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleToolButton upcasts to *ToggleToolButton
func (recv *RadioToolButton) ToggleToolButton() *ToggleToolButton {
	return ToggleToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolButton upcasts to *ToolButton
func (recv *RadioToolButton) ToolButton() *ToolButton {
	return recv.ToggleToolButton().ToolButton()
}

// ToolItem upcasts to *ToolItem
func (recv *RadioToolButton) ToolItem() *ToolItem {
	return recv.ToggleToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *RadioToolButton) Bin() *Bin {
	return recv.ToggleToolButton().Bin()
}

// Container upcasts to *Container
func (recv *RadioToolButton) Container() *Container {
	return recv.ToggleToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *RadioToolButton) Widget() *Widget {
	return recv.ToggleToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioToolButton) Object() *gobject.Object {
	return recv.ToggleToolButton().Object()
}

// CastToWidget down casts any arbitary Object to RadioToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioToolButton.
func CastToRadioToolButton(object *gobject.Object) *RadioToolButton {
	return RadioToolButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioToolButton
func (recv *RadioToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioToolButton
func (recv *RadioToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioToolButton
func (recv *RadioToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioToolButton
func (recv *RadioToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkRange is the common base class for widgets which visualize an
// adjustment, e.g #GtkScale or #GtkScrollbar.
//
// Apart from signals for monitoring the parameters of the adjustment,
// #GtkRange provides properties and methods for influencing the sensitivity
// of the steppers. It also provides properties and methods for setting a
// fill level on range widgets. See gtk_range_set_fill_level().
/*

C record/class : GtkRange
*/
type Range struct {
	native *C.GtkRange
	// widget : record
	// priv : record
}

func RangeNewFromC(u unsafe.Pointer) *Range {
	c := (*C.GtkRange)(u)
	if c == nil {
		return nil
	}

	g := &Range{native: c}

	return g
}

func (recv *Range) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Range) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Range) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Range) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Range.
// Exercise care, as this is a potentially dangerous function if the Object is not a Range.
func CastToRange(object *gobject.Object) *Range {
	return RangeNewFromC(object.ToC())
}

// Unsupported signal 'adjust-bounds' for Range : unsupported parameter value : type gdouble :

// Unsupported signal 'move-slider' for Range : unsupported parameter step : type ScrollType :

type signalRangeValueChangedDetail struct {
	callback  RangeSignalValueChangedCallback
	handlerID C.gulong
}

var signalRangeValueChangedId int
var signalRangeValueChangedMap = make(map[int]signalRangeValueChangedDetail)
var signalRangeValueChangedLock sync.Mutex

// RangeSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a Range.
type RangeSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *Range) ConnectValueChanged(callback RangeSignalValueChangedCallback) int {
	signalRangeValueChangedLock.Lock()
	defer signalRangeValueChangedLock.Unlock()

	signalRangeValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_value_changed(instance, C.gpointer(uintptr(signalRangeValueChangedId)))

	detail := signalRangeValueChangedDetail{callback, handlerID}
	signalRangeValueChangedMap[signalRangeValueChangedId] = detail

	return signalRangeValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the Range.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *Range) DisconnectValueChanged(connectionID int) {
	signalRangeValueChangedLock.Lock()
	defer signalRangeValueChangedLock.Unlock()

	detail, exists := signalRangeValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeValueChangedMap, connectionID)
}

//export range_valueChangedHandler
func range_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalRangeValueChangedMap[index].callback
	callback()
}

// Get the #GtkAdjustment which is the model object for #GtkRange.
// See gtk_range_set_adjustment() for details.
// The return value does not have a reference added, so should not
// be unreferenced.
/*

C function : gtk_range_get_adjustment
*/
func (recv *Range) GetAdjustment() *Adjustment {
	retC := C.gtk_range_get_adjustment((*C.GtkRange)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the value set by gtk_range_set_inverted().
/*

C function : gtk_range_get_inverted
*/
func (recv *Range) GetInverted() bool {
	retC := C.gtk_range_get_inverted((*C.GtkRange)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the current value of the range.
/*

C function : gtk_range_get_value
*/
func (recv *Range) GetValue() float64 {
	retC := C.gtk_range_get_value((*C.GtkRange)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Sets the adjustment to be used as the model object for this range
// widget. The adjustment indicates the current range value, the
// minimum and maximum range values, the step/page increments used
// for keybindings and scrolling, and the page size. The page size
// is normally 0 for #GtkScale and nonzero for #GtkScrollbar, and
// indicates the size of the visible area of the widget being scrolled.
// The page size affects the size of the scrollbar slider.
/*

C function : gtk_range_set_adjustment
*/
func (recv *Range) SetAdjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_range_set_adjustment((*C.GtkRange)(recv.native), c_adjustment)

	return
}

// Sets the step and page sizes for the range.
// The step size is used when the user clicks the #GtkScrollbar
// arrows or moves #GtkScale via arrow keys. The page size
// is used for example when moving via Page Up or Page Down keys.
/*

C function : gtk_range_set_increments
*/
func (recv *Range) SetIncrements(step float64, page float64) {
	c_step := (C.gdouble)(step)

	c_page := (C.gdouble)(page)

	C.gtk_range_set_increments((*C.GtkRange)(recv.native), c_step, c_page)

	return
}

// Ranges normally move from lower to higher values as the
// slider moves from top to bottom or left to right. Inverted
// ranges have higher values at the top or on the right rather than
// on the bottom or left.
/*

C function : gtk_range_set_inverted
*/
func (recv *Range) SetInverted(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_range_set_inverted((*C.GtkRange)(recv.native), c_setting)

	return
}

// Sets the allowable values in the #GtkRange, and clamps the range
// value to be between @min and @max. (If the range has a non-zero
// page size, it is clamped between @min and @max - page-size.)
/*

C function : gtk_range_set_range
*/
func (recv *Range) SetRange(min float64, max float64) {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	C.gtk_range_set_range((*C.GtkRange)(recv.native), c_min, c_max)

	return
}

// Sets the current value of the range; if the value is outside the
// minimum or maximum range values, it will be clamped to fit inside
// them. The range emits the #GtkRange::value-changed signal if the
// value changes.
/*

C function : gtk_range_set_value
*/
func (recv *Range) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_range_set_value((*C.GtkRange)(recv.native), c_value)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Range
func (recv *Range) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Range
func (recv *Range) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Range
func (recv *Range) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkRangeAccessible
*/
type RangeAccessible struct {
	native *C.GtkRangeAccessible
	// parent : record
	// priv : record
}

func RangeAccessibleNewFromC(u unsafe.Pointer) *RangeAccessible {
	c := (*C.GtkRangeAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RangeAccessible{native: c}

	return g
}

func (recv *RangeAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RangeAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *RangeAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RangeAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to RangeAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RangeAccessible.
func CastToRangeAccessible(object *gobject.Object) *RangeAccessible {
	return RangeAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by RangeAccessible
func (recv *RangeAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by RangeAccessible
func (recv *RangeAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// The #GtkRcStyle-struct is used to represent a set
// of information about the appearance of a widget.
// This can later be composited together with other
// #GtkRcStyle-struct<!-- -->s to form a #GtkStyle.
/*

C record/class : GtkRcStyle
*/
type RcStyle struct {
	native *C.GtkRcStyle
	// parent_instance : record
	Name string
	// no type for bg_pixmap_name
	// font_desc : record
	// no type for color_flags
	// no type for fg
	// no type for bg
	// no type for text
	// no type for base
	Xthickness int32
	Ythickness int32
	// Private : rc_properties
	// Private : rc_style_lists
	// Private : icon_factories
	// Private : engine_specified
}

func RcStyleNewFromC(u unsafe.Pointer) *RcStyle {
	c := (*C.GtkRcStyle)(u)
	if c == nil {
		return nil
	}

	g := &RcStyle{
		Name:       C.GoString(c.name),
		Xthickness: (int32)(c.xthickness),
		Ythickness: (int32)(c.ythickness),
		native:     c,
	}

	return g
}

func (recv *RcStyle) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native.xthickness =
		(C.gint)(recv.Xthickness)
	recv.native.ythickness =
		(C.gint)(recv.Ythickness)

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *RcStyle) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to RcStyle.
// Exercise care, as this is a potentially dangerous function if the Object is not a RcStyle.
func CastToRcStyle(object *gobject.Object) *RcStyle {
	return RcStyleNewFromC(object.ToC())
}

// Creates a new #GtkRcStyle with no fields set and
// a reference count of 1.
/*

C function : gtk_rc_style_new
*/
func RcStyleNew() *RcStyle {
	retC := C.gtk_rc_style_new()
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Makes a copy of the specified #GtkRcStyle. This function
// will correctly copy an RC style that is a member of a class
// derived from #GtkRcStyle.
/*

C function : gtk_rc_style_copy
*/
func (recv *RcStyle) Copy() *RcStyle {
	retC := C.gtk_rc_style_copy((*C.GtkRcStyle)(recv.native))
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// A #GtkRecentAction represents a list of recently used files, which
// can be shown by widgets such as #GtkRecentChooserDialog or
// #GtkRecentChooserMenu.
//
// To construct a submenu showing recently used files, use a #GtkRecentAction
// as the action for a <menuitem>. To construct a menu toolbutton showing
// the recently used files in the popup menu, use a #GtkRecentAction as the
// action for a <toolitem> element.
/*

C record/class : GtkRecentAction
*/
type RecentAction struct {
	native *C.GtkRecentAction
	// parent_instance : record
	// Private : priv
}

func RecentActionNewFromC(u unsafe.Pointer) *RecentAction {
	c := (*C.GtkRecentAction)(u)
	if c == nil {
		return nil
	}

	g := &RecentAction{native: c}

	return g
}

func (recv *RecentAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Action upcasts to *Action
func (recv *RecentAction) Action() *Action {
	return ActionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *RecentAction) Object() *gobject.Object {
	return recv.Action().Object()
}

// CastToWidget down casts any arbitary Object to RecentAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentAction.
func CastToRecentAction(object *gobject.Object) *RecentAction {
	return RecentActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RecentAction
func (recv *RecentAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentAction
func (recv *RecentAction) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// #GtkRecentChooserDialog is a dialog box suitable for displaying the recently
// used documents.  This widgets works by putting a #GtkRecentChooserWidget inside
// a #GtkDialog.  It exposes the #GtkRecentChooserIface interface, so you can use
// all the #GtkRecentChooser functions on the recent chooser dialog as well as
// those for #GtkDialog.
//
// Note that #GtkRecentChooserDialog does not have any methods of its own.
// Instead, you should use the functions that work on a #GtkRecentChooser.
//
// ## Typical usage ## {#gtkrecentchooser-typical-usage}
//
// In the simplest of cases, you can use the following code to use
// a #GtkRecentChooserDialog to select a recently used file:
//
// |[<!-- language="C" -->
// GtkWidget *dialog;
// gint res;
//
// dialog = gtk_recent_chooser_dialog_new ("Recent Documents",
// parent_window,
// _("_Cancel"),
// GTK_RESPONSE_CANCEL,
// _("_Open"),
// GTK_RESPONSE_ACCEPT,
// NULL);
//
// res = gtk_dialog_run (GTK_DIALOG (dialog));
// if (res == GTK_RESPONSE_ACCEPT)
// {
// GtkRecentInfo *info;
// GtkRecentChooser *chooser = GTK_RECENT_CHOOSER (dialog);
//
// info = gtk_recent_chooser_get_current_item (chooser);
// open_file (gtk_recent_info_get_uri (info));
// gtk_recent_info_unref (info);
// }
//
// gtk_widget_destroy (dialog);
// ]|
//
// Recently used files are supported since GTK+ 2.10.
/*

C record/class : GtkRecentChooserDialog
*/
type RecentChooserDialog struct {
	native *C.GtkRecentChooserDialog
	// parent_instance : record
	// Private : priv
}

func RecentChooserDialogNewFromC(u unsafe.Pointer) *RecentChooserDialog {
	c := (*C.GtkRecentChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserDialog{native: c}

	return g
}

func (recv *RecentChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *RecentChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *RecentChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *RecentChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *RecentChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to RecentChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserDialog.
func CastToRecentChooserDialog(object *gobject.Object) *RecentChooserDialog {
	return RecentChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// #GtkRecentChooserMenu is a widget suitable for displaying recently used files
// inside a menu.  It can be used to set a sub-menu of a #GtkMenuItem using
// gtk_menu_item_set_submenu(), or as the menu of a #GtkMenuToolButton.
//
// Note that #GtkRecentChooserMenu does not have any methods of its own. Instead,
// you should use the functions that work on a #GtkRecentChooser.
//
// Note also that #GtkRecentChooserMenu does not support multiple filters, as it
// has no way to let the user choose between them as the #GtkRecentChooserWidget
// and #GtkRecentChooserDialog widgets do. Thus using gtk_recent_chooser_add_filter()
// on a #GtkRecentChooserMenu widget will yield the same effects as using
// gtk_recent_chooser_set_filter(), replacing any currently set filter
// with the supplied filter; gtk_recent_chooser_remove_filter() will remove
// any currently set #GtkRecentFilter object and will unset the current filter;
// gtk_recent_chooser_list_filters() will return a list containing a single
// #GtkRecentFilter object.
//
// Recently used files are supported since GTK+ 2.10.
/*

C record/class : GtkRecentChooserMenu
*/
type RecentChooserMenu struct {
	native *C.GtkRecentChooserMenu
	// parent_instance : record
	// Private : priv
}

func RecentChooserMenuNewFromC(u unsafe.Pointer) *RecentChooserMenu {
	c := (*C.GtkRecentChooserMenu)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserMenu{native: c}

	return g
}

func (recv *RecentChooserMenu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Menu upcasts to *Menu
func (recv *RecentChooserMenu) Menu() *Menu {
	return MenuNewFromC(unsafe.Pointer(recv.native))
}

// MenuShell upcasts to *MenuShell
func (recv *RecentChooserMenu) MenuShell() *MenuShell {
	return recv.Menu().MenuShell()
}

// Container upcasts to *Container
func (recv *RecentChooserMenu) Container() *Container {
	return recv.Menu().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserMenu) Widget() *Widget {
	return recv.Menu().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserMenu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Menu().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserMenu) Object() *gobject.Object {
	return recv.Menu().Object()
}

// CastToWidget down casts any arbitary Object to RecentChooserMenu.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserMenu.
func CastToRecentChooserMenu(object *gobject.Object) *RecentChooserMenu {
	return RecentChooserMenuNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// #GtkRecentChooserWidget is a widget suitable for selecting recently used
// files.  It is the main building block of a #GtkRecentChooserDialog.  Most
// applications will only need to use the latter; you can use
// #GtkRecentChooserWidget as part of a larger window if you have special needs.
//
// Note that #GtkRecentChooserWidget does not have any methods of its own.
// Instead, you should use the functions that work on a #GtkRecentChooser.
//
// Recently used files are supported since GTK+ 2.10.
/*

C record/class : GtkRecentChooserWidget
*/
type RecentChooserWidget struct {
	native *C.GtkRecentChooserWidget
	// parent_instance : record
	// Private : priv
}

func RecentChooserWidgetNewFromC(u unsafe.Pointer) *RecentChooserWidget {
	c := (*C.GtkRecentChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserWidget{native: c}

	return g
}

func (recv *RecentChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *RecentChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *RecentChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to RecentChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserWidget.
func CastToRecentChooserWidget(object *gobject.Object) *RecentChooserWidget {
	return RecentChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// A #GtkRecentFilter can be used to restrict the files being shown
// in a #GtkRecentChooser.  Files can be filtered based on their name
// (with gtk_recent_filter_add_pattern()), on their mime type (with
// gtk_file_filter_add_mime_type()), on the application that has
// registered them (with gtk_recent_filter_add_application()), or by
// a custom filter function (with gtk_recent_filter_add_custom()).
//
// Filtering by mime type handles aliasing and subclassing of mime
// types; e.g. a filter for text/plain also matches a file with mime
// type application/rtf, since application/rtf is a subclass of text/plain.
// Note that #GtkRecentFilter allows wildcards for the subtype of a
// mime type, so you can e.g. filter for image/\*.
//
// Normally, filters are used by adding them to a #GtkRecentChooser,
// see gtk_recent_chooser_add_filter(), but it is also possible to
// manually use a filter on a file with gtk_recent_filter_filter().
//
// Recently used files are supported since GTK+ 2.10.
//
// ## GtkRecentFilter as GtkBuildable
//
// The GtkRecentFilter implementation of the GtkBuildable interface
// supports adding rules using the <mime-types>, <patterns> and
// <applications> elements and listing the rules within. Specifying
// a <mime-type>, <pattern> or <application> has the same effect as
// calling gtk_recent_filter_add_mime_type(),
// gtk_recent_filter_add_pattern() or gtk_recent_filter_add_application().
//
// An example of a UI definition fragment specifying GtkRecentFilter rules:
// |[
// <object class="GtkRecentFilter">
// <mime-types>
// <mime-type>text/plain</mime-type>
// <mime-type>image/png</mime-type>
// </mime-types>
// <patterns>
// <pattern>*.txt</pattern>
// <pattern>*.png</pattern>
// </patterns>
// <applications>
// <application>gimp</application>
// <application>gedit</application>
// <application>glade</application>
// </applications>
// </object>
// ]|
/*

C record/class : GtkRecentFilter
*/
type RecentFilter struct {
	native *C.GtkRecentFilter
}

func RecentFilterNewFromC(u unsafe.Pointer) *RecentFilter {
	c := (*C.GtkRecentFilter)(u)
	if c == nil {
		return nil
	}

	g := &RecentFilter{native: c}

	return g
}

func (recv *RecentFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentFilter) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *RecentFilter) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to RecentFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentFilter.
func CastToRecentFilter(object *gobject.Object) *RecentFilter {
	return RecentFilterNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RecentFilter
func (recv *RecentFilter) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkRendererCellAccessible
*/
type RendererCellAccessible struct {
	native *C.GtkRendererCellAccessible
	// parent : record
	// priv : record
}

func RendererCellAccessibleNewFromC(u unsafe.Pointer) *RendererCellAccessible {
	c := (*C.GtkRendererCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RendererCellAccessible{native: c}

	return g
}

func (recv *RendererCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellAccessible upcasts to *CellAccessible
func (recv *RendererCellAccessible) CellAccessible() *CellAccessible {
	return CellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *RendererCellAccessible) Accessible() *Accessible {
	return recv.CellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RendererCellAccessible) Object() *atk.Object {
	return recv.CellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to RendererCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RendererCellAccessible.
func CastToRendererCellAccessible(object *gobject.Object) *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(object.ToC())
}

/*

C function : gtk_renderer_cell_accessible_new
*/
func RendererCellAccessibleNew(renderer *CellRenderer) *RendererCellAccessible {
	c_renderer := (*C.GtkCellRenderer)(C.NULL)
	if renderer != nil {
		c_renderer = (*C.GtkCellRenderer)(renderer.ToC())
	}

	retC := C.gtk_renderer_cell_accessible_new(c_renderer)
	retGo := RendererCellAccessibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Action returns the Action interface implemented by RendererCellAccessible
func (recv *RendererCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RendererCellAccessible
func (recv *RendererCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// The GtkRevealer widget is a container which animates
// the transition of its child from invisible to visible.
//
// The style of transition can be controlled with
// gtk_revealer_set_transition_type().
//
// These animations respect the #GtkSettings:gtk-enable-animations
// setting.
//
// # CSS nodes
//
// GtkRevealer has a single CSS node with name revealer.
//
// The GtkRevealer widget was added in GTK+ 3.10.
/*

C record/class : GtkRevealer
*/
type Revealer struct {
	native *C.GtkRevealer
	// parent_instance : record
}

func RevealerNewFromC(u unsafe.Pointer) *Revealer {
	c := (*C.GtkRevealer)(u)
	if c == nil {
		return nil
	}

	g := &Revealer{native: c}

	return g
}

func (recv *Revealer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Revealer) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Revealer) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Revealer) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Revealer) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Revealer) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Revealer.
// Exercise care, as this is a potentially dangerous function if the Object is not a Revealer.
func CastToRevealer(object *gobject.Object) *Revealer {
	return RevealerNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Revealer
func (recv *Revealer) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Revealer
func (recv *Revealer) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A GtkScale is a slider control used to select a numeric value.
// To use it, youll probably want to investigate the methods on
// its base class, #GtkRange, in addition to the methods for GtkScale itself.
// To set the value of a scale, you would normally use gtk_range_set_value().
// To detect changes to the value, you would normally use the
// #GtkRange::value-changed signal.
//
// Note that using the same upper and lower bounds for the #GtkScale (through
// the #GtkRange methods) will hide the slider itself. This is useful for
// applications that want to show an undeterminate value on the scale, without
// changing the layout of the application (such as movie or music players).
//
// # GtkScale as GtkBuildable
//
// GtkScale supports a custom <marks> element, which can contain multiple
// <mark> elements. The value and position attributes have the same
// meaning as gtk_scale_add_mark() parameters of the same name. If the
// element is not empty, its content is taken as the markup to show at
// the mark. It can be translated with the usual translatable and
// context attributes.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// scale[.fine-tune][.marks-before][.marks-after]
//  marks.top
//     mark
//         [label]
//         indicator
//    
//     mark
//  [value]
//  contents
//     trough
//         slider
//         [highlight]
//         [fill]
//  marks.bottom
//  mark
//      indicator
//      [label]
//  mark
// ]|
//
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see gtk_scale_set_has_origin()), there is a
// subnode with name highlight below the trough node that is used for rendering
// the highlighted part of the trough.
//
// If the scale is showing a fill level (see gtk_range_set_show_fill_level()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
//
// If marks are present, there is a marks subnode before or after the contents
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see #GtkScale:draw-value), there is
// subnode with name value.
/*

C record/class : GtkScale
*/
type Scale struct {
	native *C.GtkScale
	// range : record
	// Private : priv
}

func ScaleNewFromC(u unsafe.Pointer) *Scale {
	c := (*C.GtkScale)(u)
	if c == nil {
		return nil
	}

	g := &Scale{native: c}

	return g
}

func (recv *Scale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Range upcasts to *Range
func (recv *Scale) Range() *Range {
	return RangeNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Scale) Widget() *Widget {
	return recv.Range().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Scale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Range().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Scale) Object() *gobject.Object {
	return recv.Range().Object()
}

// CastToWidget down casts any arbitary Object to Scale.
// Exercise care, as this is a potentially dangerous function if the Object is not a Scale.
func CastToScale(object *gobject.Object) *Scale {
	return ScaleNewFromC(object.ToC())
}

// Unsupported signal 'format-value' for Scale : unsupported parameter value : type gdouble :

// Gets the number of decimal places that are displayed in the value.
/*

C function : gtk_scale_get_digits
*/
func (recv *Scale) GetDigits() int32 {
	retC := C.gtk_scale_get_digits((*C.GtkScale)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns whether the current value is displayed as a string
// next to the slider.
/*

C function : gtk_scale_get_draw_value
*/
func (recv *Scale) GetDrawValue() bool {
	retC := C.gtk_scale_get_draw_value((*C.GtkScale)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the position in which the current value is displayed.
/*

C function : gtk_scale_get_value_pos
*/
func (recv *Scale) GetValuePos() PositionType {
	retC := C.gtk_scale_get_value_pos((*C.GtkScale)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// Sets the number of decimal places that are displayed in the value. Also
// causes the value of the adjustment to be rounded to this number of digits,
// so the retrieved value matches the displayed one, if #GtkScale:draw-value is
// %TRUE when the value changes. If you want to enforce rounding the value when
// #GtkScale:draw-value is %FALSE, you can set #GtkRange:round-digits instead.
//
// Note that rounding to a small number of digits can interfere with
// the smooth autoscrolling that is built into #GtkScale. As an alternative,
// you can use the #GtkScale::format-value signal to format the displayed
// value yourself.
/*

C function : gtk_scale_set_digits
*/
func (recv *Scale) SetDigits(digits int32) {
	c_digits := (C.gint)(digits)

	C.gtk_scale_set_digits((*C.GtkScale)(recv.native), c_digits)

	return
}

// Specifies whether the current value is displayed as a string next
// to the slider.
/*

C function : gtk_scale_set_draw_value
*/
func (recv *Scale) SetDrawValue(drawValue bool) {
	c_draw_value :=
		boolToGboolean(drawValue)

	C.gtk_scale_set_draw_value((*C.GtkScale)(recv.native), c_draw_value)

	return
}

// Sets the position in which the current value is displayed.
/*

C function : gtk_scale_set_value_pos
*/
func (recv *Scale) SetValuePos(pos PositionType) {
	c_pos := (C.GtkPositionType)(pos)

	C.gtk_scale_set_value_pos((*C.GtkScale)(recv.native), c_pos)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Scale
func (recv *Scale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Scale
func (recv *Scale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Scale
func (recv *Scale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkScaleAccessible
*/
type ScaleAccessible struct {
	native *C.GtkScaleAccessible
	// parent : record
	// priv : record
}

func ScaleAccessibleNewFromC(u unsafe.Pointer) *ScaleAccessible {
	c := (*C.GtkScaleAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScaleAccessible{native: c}

	return g
}

func (recv *ScaleAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// RangeAccessible upcasts to *RangeAccessible
func (recv *ScaleAccessible) RangeAccessible() *RangeAccessible {
	return RangeAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScaleAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.RangeAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScaleAccessible) Accessible() *Accessible {
	return recv.RangeAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScaleAccessible) Object() *atk.Object {
	return recv.RangeAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ScaleAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleAccessible.
func CastToScaleAccessible(object *gobject.Object) *ScaleAccessible {
	return ScaleAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ScaleAccessible
func (recv *ScaleAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ScaleAccessible
func (recv *ScaleAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// #GtkScaleButton provides a button which pops up a scale widget.
// This kind of widget is commonly used for volume controls in multimedia
// applications, and GTK+ provides a #GtkVolumeButton subclass that
// is tailored for this use case.
//
// # CSS nodes
//
// GtkScaleButton has a single CSS node with name button. To differentiate
// it from a plain #GtkButton, it gets the .scale style class.
/*

C record/class : GtkScaleButton
*/
type ScaleButton struct {
	native *C.GtkScaleButton
	// parent : record
	// Private : priv
}

func ScaleButtonNewFromC(u unsafe.Pointer) *ScaleButton {
	c := (*C.GtkScaleButton)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButton{native: c}

	return g
}

func (recv *ScaleButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *ScaleButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ScaleButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ScaleButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ScaleButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ScaleButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ScaleButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to ScaleButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleButton.
func CastToScaleButton(object *gobject.Object) *ScaleButton {
	return ScaleButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ScaleButton
func (recv *ScaleButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ScaleButton
func (recv *ScaleButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ScaleButton
func (recv *ScaleButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ScaleButton
func (recv *ScaleButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ScaleButton
func (recv *ScaleButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkScaleButtonAccessible
*/
type ScaleButtonAccessible struct {
	native *C.GtkScaleButtonAccessible
	// parent : record
	// priv : record
}

func ScaleButtonAccessibleNewFromC(u unsafe.Pointer) *ScaleButtonAccessible {
	c := (*C.GtkScaleButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButtonAccessible{native: c}

	return g
}

func (recv *ScaleButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *ScaleButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ScaleButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScaleButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScaleButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScaleButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ScaleButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleButtonAccessible.
func CastToScaleButtonAccessible(object *gobject.Object) *ScaleButtonAccessible {
	return ScaleButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// The #GtkScrollbar widget is a horizontal or vertical scrollbar,
// depending on the value of the #GtkOrientable:orientation property.
//
// Its position and movement are controlled by the adjustment that is passed to
// or created by gtk_scrollbar_new(). See #GtkAdjustment for more details. The
// #GtkAdjustment:value field sets the position of the thumb and must be between
// #GtkAdjustment:lower and #GtkAdjustment:upper - #GtkAdjustment:page-size. The
// #GtkAdjustment:page-size represents the size of the visible scrollable area.
// The fields #GtkAdjustment:step-increment and #GtkAdjustment:page-increment
// fields are added to or subtracted from the #GtkAdjustment:value when the user
// asks to move by a step (using e.g. the cursor arrow keys or, if present, the
// stepper buttons) or by a page (using e.g. the Page Down/Up keys).
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// scrollbar[.fine-tune]
//  contents
//  [button.up]
//  [button.down]
//  trough
//     slider
//  [button.up]
//  [button.down]
// ]|
//
// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
// contents, with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scrollbar is
// in 'fine-tuning' mode.
//
// If steppers are enabled, they are represented by up to four additional
// subnodes with name button. These get the style classes .up and .down to
// indicate in which direction they are moving.
//
// Other style classes that may be added to scrollbars inside #GtkScrolledWindow
// include the positional classes (.left, .right, .top, .bottom) and style
// classes related to overlay scrolling (.overlay-indicator, .dragging, .hovering).
/*

C record/class : GtkScrollbar
*/
type Scrollbar struct {
	native *C.GtkScrollbar
	// range : record
}

func ScrollbarNewFromC(u unsafe.Pointer) *Scrollbar {
	c := (*C.GtkScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &Scrollbar{native: c}

	return g
}

func (recv *Scrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Range upcasts to *Range
func (recv *Scrollbar) Range() *Range {
	return RangeNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Scrollbar) Widget() *Widget {
	return recv.Range().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Scrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Range().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Scrollbar) Object() *gobject.Object {
	return recv.Range().Object()
}

// CastToWidget down casts any arbitary Object to Scrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Scrollbar.
func CastToScrollbar(object *gobject.Object) *Scrollbar {
	return ScrollbarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Scrollbar
func (recv *Scrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Scrollbar
func (recv *Scrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Scrollbar
func (recv *Scrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// GtkScrolledWindow is a container that accepts a single child widget, makes
// that child scrollable using either internally added scrollbars or externally
// associated adjustments, and optionally draws a frame around the child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// #GtkScrollable interface, are added directly. For other types of widget, the
// class #GtkViewport acts as an adaptor, giving scrollability to other widgets.
// GtkScrolledWindows implementation of gtk_container_add() intelligently
// accounts for whether or not the added child is a #GtkScrollable. If it isnt,
// #GtkScrolledWindow wraps the child in a #GtkViewport and adds that for you.
// Therefore, you can just add any child widget and not worry about the details.
//
// If gtk_container_add() has added a #GtkViewport for you, you can remove
// both your added child widget from the #GtkViewport, and the #GtkViewport
// from the GtkScrolledWindow, like this:
//
// |[<!-- language="C" -->
// GtkWidget *scrolled_window = gtk_scrolled_window_new (NULL, NULL);
// GtkWidget *child_widget = gtk_button_new ();
//
// GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
// add a GtkViewport.
// gtk_container_add (GTK_CONTAINER (scrolled_window),
// child_widget);
//
// Either of these will result in child_widget being unparented:
// gtk_container_remove (GTK_CONTAINER (scrolled_window),
// child_widget);
// or
// gtk_container_remove (GTK_CONTAINER (scrolled_window),
// gtk_bin_get_child (GTK_BIN (scrolled_window)));
// ]|
//
// Unless #GtkScrolledWindow:policy is GTK_POLICY_NEVER or GTK_POLICY_EXTERNAL,
// GtkScrolledWindow adds internal #GtkScrollbar widgets around its child. The
// scroll position of the child, and if applicable the scrollbars, is controlled
// by the #GtkScrolledWindow:hadjustment and #GtkScrolledWindow:vadjustment
// that are associated with the GtkScrolledWindow. See the docs on #GtkScrollbar
// for the details, but note that the step_increment and page_increment
// fields are only effective if the policy causes scrollbars to be present.
//
// If a GtkScrolledWindow doesnt behave quite as you would like, or
// doesnt have exactly the right layout, its very possible to set up
// your own scrolling with #GtkScrollbar and for example a #GtkGrid.
//
// # Touch support
//
// GtkScrolledWindow has built-in support for touch devices. When a
// touchscreen is used, swiping will move the scrolled window, and will
// expose 'kinetic' behavior. This can be turned off with the
// #GtkScrolledWindow:kinetic-scrolling property if it is undesired.
//
// GtkScrolledWindow also displays visual 'overshoot' indication when
// the content is pulled beyond the end, and this situation can be
// captured with the #GtkScrolledWindow::edge-overshot signal.
//
// If no mouse device is present, the scrollbars will overlayed as
// narrow, auto-hiding indicators over the content. If traditional
// scrollbars are desired although no mouse is present, this behaviour
// can be turned off with the #GtkScrolledWindow:overlay-scrolling
// property.
//
// # CSS nodes
//
// GtkScrolledWindow has a main CSS node with name scrolledwindow.
//
// It uses subnodes with names overshoot and undershoot to
// draw the overflow and underflow indications. These nodes get
// the .left, .right, .top or .bottom style class added depending
// on where the indication is drawn.
//
// GtkScrolledWindow also sets the positional style classes (.left,
// .right, .top, .bottom) and style classes related to overlay
// scrolling (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn
// with a subnode named junction.
/*

C record/class : GtkScrolledWindow
*/
type ScrolledWindow struct {
	native *C.GtkScrolledWindow
	// container : record
	// priv : record
}

func ScrolledWindowNewFromC(u unsafe.Pointer) *ScrolledWindow {
	c := (*C.GtkScrolledWindow)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindow{native: c}

	return g
}

func (recv *ScrolledWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ScrolledWindow) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ScrolledWindow) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ScrolledWindow) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ScrolledWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ScrolledWindow) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ScrolledWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScrolledWindow.
func CastToScrolledWindow(object *gobject.Object) *ScrolledWindow {
	return ScrolledWindowNewFromC(object.ToC())
}

// Unsupported signal 'move-focus-out' for ScrolledWindow : unsupported parameter direction_type : type DirectionType :

// Unsupported signal 'scroll-child' for ScrolledWindow : unsupported parameter scroll : type ScrollType :

// Creates a new scrolled window.
//
// The two arguments are the scrolled windows adjustments; these will be
// shared with the scrollbars and the child widget to keep the bars in sync
// with the child. Usually you want to pass %NULL for the adjustments, which
// will cause the scrolled window to create them for you.
/*

C function : gtk_scrolled_window_new
*/
func ScrolledWindowNew(hadjustment *Adjustment, vadjustment *Adjustment) *ScrolledWindow {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_scrolled_window_new(c_hadjustment, c_vadjustment)
	retGo := ScrolledWindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Used to add children without native scrolling capabilities. This
// is simply a convenience function; it is equivalent to adding the
// unscrollable child to a viewport, then adding the viewport to the
// scrolled window. If a child has native scrolling, use
// gtk_container_add() instead of this function.
//
// The viewport scrolls the child by moving its #GdkWindow, and takes
// the size of the child to be the size of its toplevel #GdkWindow.
// This will be very wrong for most widgets that support native scrolling;
// for example, if you add a widget such as #GtkTreeView with a viewport,
// the whole widget will scroll, including the column headings. Thus,
// widgets with native scrolling support should not be used with the
// #GtkViewport proxy.
//
// A widget supports scrolling natively if it implements the
// #GtkScrollable interface.
/*

C function : gtk_scrolled_window_add_with_viewport
*/
func (recv *ScrolledWindow) AddWithViewport(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_scrolled_window_add_with_viewport((*C.GtkScrolledWindow)(recv.native), c_child)

	return
}

// Returns the horizontal scrollbars adjustment, used to connect the
// horizontal scrollbar to the child widgets horizontal scroll
// functionality.
/*

C function : gtk_scrolled_window_get_hadjustment
*/
func (recv *ScrolledWindow) GetHadjustment() *Adjustment {
	retC := C.gtk_scrolled_window_get_hadjustment((*C.GtkScrolledWindow)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the placement of the contents with respect to the scrollbars
// for the scrolled window. See gtk_scrolled_window_set_placement().
/*

C function : gtk_scrolled_window_get_placement
*/
func (recv *ScrolledWindow) GetPlacement() CornerType {
	retC := C.gtk_scrolled_window_get_placement((*C.GtkScrolledWindow)(recv.native))
	retGo := (CornerType)(retC)

	return retGo
}

// Unsupported : gtk_scrolled_window_get_policy : unsupported parameter hscrollbar_policy : GtkPolicyType* with indirection level of 1

// Gets the shadow type of the scrolled window. See
// gtk_scrolled_window_set_shadow_type().
/*

C function : gtk_scrolled_window_get_shadow_type
*/
func (recv *ScrolledWindow) GetShadowType() ShadowType {
	retC := C.gtk_scrolled_window_get_shadow_type((*C.GtkScrolledWindow)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// Returns the vertical scrollbars adjustment, used to connect the
// vertical scrollbar to the child widgets vertical scroll functionality.
/*

C function : gtk_scrolled_window_get_vadjustment
*/
func (recv *ScrolledWindow) GetVadjustment() *Adjustment {
	retC := C.gtk_scrolled_window_get_vadjustment((*C.GtkScrolledWindow)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the #GtkAdjustment for the horizontal scrollbar.
/*

C function : gtk_scrolled_window_set_hadjustment
*/
func (recv *ScrolledWindow) SetHadjustment(hadjustment *Adjustment) {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	C.gtk_scrolled_window_set_hadjustment((*C.GtkScrolledWindow)(recv.native), c_hadjustment)

	return
}

// Sets the placement of the contents with respect to the scrollbars
// for the scrolled window.
//
// The default is %GTK_CORNER_TOP_LEFT, meaning the child is
// in the top left, with the scrollbars underneath and to the right.
// Other values in #GtkCornerType are %GTK_CORNER_TOP_RIGHT,
// %GTK_CORNER_BOTTOM_LEFT, and %GTK_CORNER_BOTTOM_RIGHT.
//
// See also gtk_scrolled_window_get_placement() and
// gtk_scrolled_window_unset_placement().
/*

C function : gtk_scrolled_window_set_placement
*/
func (recv *ScrolledWindow) SetPlacement(windowPlacement CornerType) {
	c_window_placement := (C.GtkCornerType)(windowPlacement)

	C.gtk_scrolled_window_set_placement((*C.GtkScrolledWindow)(recv.native), c_window_placement)

	return
}

// Sets the scrollbar policy for the horizontal and vertical scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value
// from the #GtkPolicyType enumeration. If %GTK_POLICY_ALWAYS, the
// scrollbar is always present; if %GTK_POLICY_NEVER, the scrollbar is
// never present; if %GTK_POLICY_AUTOMATIC, the scrollbar is present only
// if needed (that is, if the slider part of the bar would be smaller
// than the trough  the display is larger than the page size).
/*

C function : gtk_scrolled_window_set_policy
*/
func (recv *ScrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	c_hscrollbar_policy := (C.GtkPolicyType)(hscrollbarPolicy)

	c_vscrollbar_policy := (C.GtkPolicyType)(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy((*C.GtkScrolledWindow)(recv.native), c_hscrollbar_policy, c_vscrollbar_policy)

	return
}

// Changes the type of shadow drawn around the contents of
// @scrolled_window.
/*

C function : gtk_scrolled_window_set_shadow_type
*/
func (recv *ScrolledWindow) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_scrolled_window_set_shadow_type((*C.GtkScrolledWindow)(recv.native), c_type)

	return
}

// Sets the #GtkAdjustment for the vertical scrollbar.
/*

C function : gtk_scrolled_window_set_vadjustment
*/
func (recv *ScrolledWindow) SetVadjustment(vadjustment *Adjustment) {
	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	C.gtk_scrolled_window_set_vadjustment((*C.GtkScrolledWindow)(recv.native), c_vadjustment)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ScrolledWindow
func (recv *ScrolledWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ScrolledWindow
func (recv *ScrolledWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkScrolledWindowAccessible
*/
type ScrolledWindowAccessible struct {
	native *C.GtkScrolledWindowAccessible
	// parent : record
	// priv : record
}

func ScrolledWindowAccessibleNewFromC(u unsafe.Pointer) *ScrolledWindowAccessible {
	c := (*C.GtkScrolledWindowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindowAccessible{native: c}

	return g
}

func (recv *ScrolledWindowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ScrolledWindowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScrolledWindowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScrolledWindowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScrolledWindowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ScrolledWindowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScrolledWindowAccessible.
func CastToScrolledWindowAccessible(object *gobject.Object) *ScrolledWindowAccessible {
	return ScrolledWindowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ScrolledWindowAccessible
func (recv *ScrolledWindowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// #GtkSearchBar is a container made to have a search entry (possibly
// with additional connex widgets, such as drop-down menus, or buttons)
// built-in. The search bar would appear when a search is started through
// typing on the keyboard, or the applications search mode is toggled on.
//
// For keyboard presses to start a search, events will need to be
// forwarded from the top-level window that contains the search bar.
// See gtk_search_bar_handle_event() for example code. Common shortcuts
// such as Ctrl+F should be handled as an application action, or through
// the menu items.
//
// You will also need to tell the search bar about which entry you
// are using as your search entry using gtk_search_bar_connect_entry().
// The following example shows you how to create a more complex search
// entry.
//
// # CSS nodes
//
// GtkSearchBar has a single CSS node with name searchbar.
//
// ## Creating a search bar
//
// [A simple example](https://git.gnome.org/browse/gtk+/tree/examples/search-bar.c)
/*

C record/class : GtkSearchBar
*/
type SearchBar struct {
	native *C.GtkSearchBar
	// Private : parent
}

func SearchBarNewFromC(u unsafe.Pointer) *SearchBar {
	c := (*C.GtkSearchBar)(u)
	if c == nil {
		return nil
	}

	g := &SearchBar{native: c}

	return g
}

func (recv *SearchBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *SearchBar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *SearchBar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *SearchBar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SearchBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SearchBar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to SearchBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a SearchBar.
func CastToSearchBar(object *gobject.Object) *SearchBar {
	return SearchBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SearchBar
func (recv *SearchBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SearchBar
func (recv *SearchBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkSearchEntry is a subclass of #GtkEntry that has been
// tailored for use as a search entry.
//
// It will show an inactive symbolic find icon when the search
// entry is empty, and a symbolic clear icon when there is text.
// Clicking on the clear icon will empty the search entry.
//
// Note that the search/clear icon is shown using a secondary
// icon, and thus does not work if you are using the secondary
// icon position for some other purpose.
//
// To make filtering appear more reactive, it is a good idea to
// not react to every change in the entry text immediately, but
// only after a short delay. To support this, #GtkSearchEntry
// emits the #GtkSearchEntry::search-changed signal which can
// be used instead of the #GtkEditable::changed signal.
//
// The #GtkSearchEntry::previous-match, #GtkSearchEntry::next-match
// and #GtkSearchEntry::stop-search signals can be used to implement
// moving between search results and ending the search.
//
// Often, GtkSearchEntry will be fed events by means of being
// placed inside a #GtkSearchBar. If that is not the case,
// you can use gtk_search_entry_handle_event() to pass events.
/*

C record/class : GtkSearchEntry
*/
type SearchEntry struct {
	native *C.GtkSearchEntry
	// parent : record
}

func SearchEntryNewFromC(u unsafe.Pointer) *SearchEntry {
	c := (*C.GtkSearchEntry)(u)
	if c == nil {
		return nil
	}

	g := &SearchEntry{native: c}

	return g
}

func (recv *SearchEntry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Entry upcasts to *Entry
func (recv *SearchEntry) Entry() *Entry {
	return EntryNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *SearchEntry) Widget() *Widget {
	return recv.Entry().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SearchEntry) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Entry().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SearchEntry) Object() *gobject.Object {
	return recv.Entry().Object()
}

// CastToWidget down casts any arbitary Object to SearchEntry.
// Exercise care, as this is a potentially dangerous function if the Object is not a SearchEntry.
func CastToSearchEntry(object *gobject.Object) *SearchEntry {
	return SearchEntryNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SearchEntry
func (recv *SearchEntry) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SearchEntry
func (recv *SearchEntry) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by SearchEntry
func (recv *SearchEntry) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by SearchEntry
func (recv *SearchEntry) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// GtkSeparator is a horizontal or vertical separator widget, depending on the
// value of the #GtkOrientable:orientation property, used to group the widgets
// within a window. It displays a line with a shadow to make it appear sunken
// into the interface.
//
// # CSS nodes
//
// GtkSeparator has a single CSS node with name separator. The node
// gets one of the .horizontal or .vertical style classes.
/*

C record/class : GtkSeparator
*/
type Separator struct {
	native *C.GtkSeparator
	// widget : record
	// priv : record
}

func SeparatorNewFromC(u unsafe.Pointer) *Separator {
	c := (*C.GtkSeparator)(u)
	if c == nil {
		return nil
	}

	g := &Separator{native: c}

	return g
}

func (recv *Separator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Separator) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Separator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Separator) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Separator.
// Exercise care, as this is a potentially dangerous function if the Object is not a Separator.
func CastToSeparator(object *gobject.Object) *Separator {
	return SeparatorNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Separator
func (recv *Separator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Separator
func (recv *Separator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Separator
func (recv *Separator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkSeparatorMenuItem is a separator used to group
// items within a menu. It displays a horizontal line with a shadow to
// make it appear sunken into the interface.
//
// # CSS nodes
//
// GtkSeparatorMenuItem has a single CSS node with name separator.
/*

C record/class : GtkSeparatorMenuItem
*/
type SeparatorMenuItem struct {
	native *C.GtkSeparatorMenuItem
	// menu_item : record
}

func SeparatorMenuItemNewFromC(u unsafe.Pointer) *SeparatorMenuItem {
	c := (*C.GtkSeparatorMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorMenuItem{native: c}

	return g
}

func (recv *SeparatorMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItem upcasts to *MenuItem
func (recv *SeparatorMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *SeparatorMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *SeparatorMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *SeparatorMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SeparatorMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SeparatorMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitary Object to SeparatorMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a SeparatorMenuItem.
func CastToSeparatorMenuItem(object *gobject.Object) *SeparatorMenuItem {
	return SeparatorMenuItemNewFromC(object.ToC())
}

// Creates a new #GtkSeparatorMenuItem.
/*

C function : gtk_separator_menu_item_new
*/
func SeparatorMenuItemNew() *SeparatorMenuItem {
	retC := C.gtk_separator_menu_item_new()
	retGo := SeparatorMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A #GtkSeparatorToolItem is a #GtkToolItem that separates groups of other
// #GtkToolItems. Depending on the theme, a #GtkSeparatorToolItem will
// often look like a vertical line on horizontally docked toolbars.
//
// If the #GtkToolbar child property expand is %TRUE and the property
// #GtkSeparatorToolItem:draw is %FALSE, a #GtkSeparatorToolItem will act as
// a spring that forces other items to the ends of the toolbar.
//
// Use gtk_separator_tool_item_new() to create a new #GtkSeparatorToolItem.
//
// # CSS nodes
//
// GtkSeparatorToolItem has a single CSS node with name separator.
/*

C record/class : GtkSeparatorToolItem
*/
type SeparatorToolItem struct {
	native *C.GtkSeparatorToolItem
	// parent : record
	// Private : priv
}

func SeparatorToolItemNewFromC(u unsafe.Pointer) *SeparatorToolItem {
	c := (*C.GtkSeparatorToolItem)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorToolItem{native: c}

	return g
}

func (recv *SeparatorToolItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToolItem upcasts to *ToolItem
func (recv *SeparatorToolItem) ToolItem() *ToolItem {
	return ToolItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *SeparatorToolItem) Bin() *Bin {
	return recv.ToolItem().Bin()
}

// Container upcasts to *Container
func (recv *SeparatorToolItem) Container() *Container {
	return recv.ToolItem().Container()
}

// Widget upcasts to *Widget
func (recv *SeparatorToolItem) Widget() *Widget {
	return recv.ToolItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SeparatorToolItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SeparatorToolItem) Object() *gobject.Object {
	return recv.ToolItem().Object()
}

// CastToWidget down casts any arbitary Object to SeparatorToolItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a SeparatorToolItem.
func CastToSeparatorToolItem(object *gobject.Object) *SeparatorToolItem {
	return SeparatorToolItemNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// GtkSettings provide a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an
// [XSettings](http://www.freedesktop.org/wiki/Specifications/xsettings-spec)
// manager that is usually part of the desktop environment, along with
// utilities that let the user change these settings. In the absence of
// an Xsettings manager, GTK+ reads default values for settings from
// `settings.ini` files in
// `/etc/gtk-3.0`, `$XDG_CONFIG_DIRS/gtk-3.0`
// and `$XDG_CONFIG_HOME/gtk-3.0`.
// These files must be valid key files (see #GKeyFile), and have
// a section called Settings. Themes can also provide default values
// for settings by installing a `settings.ini` file
// next to their `gtk.css` file.
//
// Applications can override system-wide settings by setting the property
// of the GtkSettings object with g_object_set(). This should be restricted
// to special cases though; GtkSettings are not meant as an application
// configuration facility. When doing so, you need to be aware that settings
// that are specific to individual widgets may not be available before the
// widget type has been realized at least once. The following example
// demonstrates a way to do this:
// |[<!-- language="C" -->
// gtk_init (&argc, &argv);
//
// make sure the type is realized
// g_type_class_unref (g_type_class_ref (GTK_TYPE_IMAGE_MENU_ITEM));
//
// g_object_set (gtk_settings_get_default (), "gtk-enable-animations", FALSE, NULL);
// ]|
//
// There is one GtkSettings instance per screen. It can be obtained with
// gtk_settings_get_for_screen(), but in many cases, it is more convenient
// to use gtk_widget_get_settings(). gtk_settings_get_default() returns the
// GtkSettings instance for the default screen.
/*

C record/class : GtkSettings
*/
type Settings struct {
	native *C.GtkSettings
	// parent_instance : record
	// Private : priv
}

func SettingsNewFromC(u unsafe.Pointer) *Settings {
	c := (*C.GtkSettings)(u)
	if c == nil {
		return nil
	}

	g := &Settings{native: c}

	return g
}

func (recv *Settings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Settings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Settings.
// Exercise care, as this is a potentially dangerous function if the Object is not a Settings.
func CastToSettings(object *gobject.Object) *Settings {
	return SettingsNewFromC(object.ToC())
}

/*

C function : gtk_settings_set_double_property
*/
func (recv *Settings) SetDoubleProperty(name string, vDouble float64, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_double := (C.gdouble)(vDouble)

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_double_property((*C.GtkSettings)(recv.native), c_name, c_v_double, c_origin)

	return
}

/*

C function : gtk_settings_set_long_property
*/
func (recv *Settings) SetLongProperty(name string, vLong int64, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_long := (C.glong)(vLong)

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_long_property((*C.GtkSettings)(recv.native), c_name, c_v_long, c_origin)

	return
}

/*

C function : gtk_settings_set_property_value
*/
func (recv *Settings) SetPropertyValue(name string, svalue *SettingsValue) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_svalue := (*C.GtkSettingsValue)(C.NULL)
	if svalue != nil {
		c_svalue = (*C.GtkSettingsValue)(svalue.ToC())
	}

	C.gtk_settings_set_property_value((*C.GtkSettings)(recv.native), c_name, c_svalue)

	return
}

/*

C function : gtk_settings_set_string_property
*/
func (recv *Settings) SetStringProperty(name string, vString string, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_string := C.CString(vString)
	defer C.free(unsafe.Pointer(c_v_string))

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_string_property((*C.GtkSettings)(recv.native), c_name, c_v_string, c_origin)

	return
}

// StyleProvider returns the StyleProvider interface implemented by Settings
func (recv *Settings) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// #GtkSizeGroup provides a mechanism for grouping a number of widgets
// together so they all request the same amount of space.  This is
// typically useful when you want a column of widgets to have the same
// size, but you cant use a #GtkGrid widget.
//
// In detail, the size requested for each widget in a #GtkSizeGroup is
// the maximum of the sizes that would have been requested for each
// widget in the size group if they were not in the size group. The mode
// of the size group (see gtk_size_group_set_mode()) determines whether
// this applies to the horizontal size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not
// the size that the widgets finally receive. If you want the widgets in
// a #GtkSizeGroup to actually be the same size, you need to pack them in
// such a way that they get the size they request and not more. For
// example, if you are packing your widgets into a table, you would not
// include the %GTK_FILL flag.
//
// #GtkSizeGroup objects are referenced by each widget in the size group,
// so once you have added all widgets to a #GtkSizeGroup, you can drop
// the initial reference to the size group with g_object_unref(). If the
// widgets in the size group are subsequently destroyed, then they will
// be removed from the size group and drop their references on the size
// group; when all widgets have been removed, the size group will be
// freed.
//
// Widgets can be part of multiple size groups; GTK+ will compute the
// horizontal size of a widget from the horizontal requisition of all
// widgets that can be reached from the widget by a chain of size groups
// of type %GTK_SIZE_GROUP_HORIZONTAL or %GTK_SIZE_GROUP_BOTH, and the
// vertical size from the vertical requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// %GTK_SIZE_GROUP_VERTICAL or %GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted
// by size groups (since size groups have no knowledge of what size a widget
// will be allocated in one dimension, it cannot derive how much height
// a widget will receive for a given width). When grouping widgets that
// trade height for width in mode %GTK_SIZE_GROUP_VERTICAL or %GTK_SIZE_GROUP_BOTH:
// the height for the minimum width will be the requested height for all
// widgets in the group. The same is of course true when horizontally grouping
// width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum width
// by way of #GtkLabel:width-chars for instance. Widgets with static sizes as well
// as widgets that grow (such as ellipsizing text) need no such considerations.
//
// # GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the
// size group. The name attribute gives the id of the widget.
//
// An example of a UI definition fragment with GtkSizeGroup:
// |[
// <object class="GtkSizeGroup">
// <property name="mode">GTK_SIZE_GROUP_HORIZONTAL</property>
// <widgets>
// <widget name="radio1"/>
// <widget name="radio2"/>
// </widgets>
// </object>
// ]|
/*

C record/class : GtkSizeGroup
*/
type SizeGroup struct {
	native *C.GtkSizeGroup
	// parent_instance : record
	// Private : priv
}

func SizeGroupNewFromC(u unsafe.Pointer) *SizeGroup {
	c := (*C.GtkSizeGroup)(u)
	if c == nil {
		return nil
	}

	g := &SizeGroup{native: c}

	return g
}

func (recv *SizeGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *SizeGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to SizeGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a SizeGroup.
func CastToSizeGroup(object *gobject.Object) *SizeGroup {
	return SizeGroupNewFromC(object.ToC())
}

// Create a new #GtkSizeGroup.
/*

C function : gtk_size_group_new
*/
func SizeGroupNew(mode SizeGroupMode) *SizeGroup {
	c_mode := (C.GtkSizeGroupMode)(mode)

	retC := C.gtk_size_group_new(c_mode)
	retGo := SizeGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a widget to a #GtkSizeGroup. In the future, the requisition
// of the widget will be determined as the maximum of its requisition
// and the requisition of the other widgets in the size group.
// Whether this applies horizontally, vertically, or in both directions
// depends on the mode of the size group. See gtk_size_group_set_mode().
//
// When the widget is destroyed or no longer referenced elsewhere, it will
// be removed from the size group.
/*

C function : gtk_size_group_add_widget
*/
func (recv *SizeGroup) AddWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_size_group_add_widget((*C.GtkSizeGroup)(recv.native), c_widget)

	return
}

// Gets the current mode of the size group. See gtk_size_group_set_mode().
/*

C function : gtk_size_group_get_mode
*/
func (recv *SizeGroup) GetMode() SizeGroupMode {
	retC := C.gtk_size_group_get_mode((*C.GtkSizeGroup)(recv.native))
	retGo := (SizeGroupMode)(retC)

	return retGo
}

// Removes a widget from a #GtkSizeGroup.
/*

C function : gtk_size_group_remove_widget
*/
func (recv *SizeGroup) RemoveWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_size_group_remove_widget((*C.GtkSizeGroup)(recv.native), c_widget)

	return
}

// Sets the #GtkSizeGroupMode of the size group. The mode of the size
// group determines whether the widgets in the size group should
// all have the same horizontal requisition (%GTK_SIZE_GROUP_HORIZONTAL)
// all have the same vertical requisition (%GTK_SIZE_GROUP_VERTICAL),
// or should all have the same requisition in both directions
// (%GTK_SIZE_GROUP_BOTH).
/*

C function : gtk_size_group_set_mode
*/
func (recv *SizeGroup) SetMode(mode SizeGroupMode) {
	c_mode := (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode((*C.GtkSizeGroup)(recv.native), c_mode)

	return
}

// Buildable returns the Buildable interface implemented by SizeGroup
func (recv *SizeGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkSocket

// A #GtkSpinButton is an ideal way to allow the user to set the value of
// some attribute. Rather than having to directly type a number into a
// #GtkEntry, GtkSpinButton allows the user to click on one of two arrows
// to increment or decrement the displayed value. A value can still be
// typed in, with the bonus that it can be checked to ensure it is in a
// given range.
//
// The main properties of a GtkSpinButton are through an adjustment.
// See the #GtkAdjustment section for more details about an adjustment's
// properties. Note that GtkSpinButton will by default make its entry
// large enough to accomodate the lower and upper bounds of the adjustment,
// which can lead to surprising results. Best practice is to set both
// the #GtkEntry:width-chars and #GtkEntry:max-width-chars poperties
// to the desired number of characters to display in the entry.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// spinbutton.horizontal
//  undershoot.left
//  undershoot.right
//  entry
//     ...
//  button.down
//  button.up
// ]|
//
// |[<!-- language="plain" -->
// spinbutton.vertical
//  undershoot.left
//  undershoot.right
//  button.up
//  entry
//     ...
//  button.down
// ]|
//
// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes
// for the entry and the two buttons, with these names. The button nodes have
// the style classes .up and .down. The GtkEntry subnodes (if present) are put
// below the entry node. The orientation of the spin button is reflected in
// the .vertical or .horizontal style class on the main node.
//
// ## Using a GtkSpinButton to get an integer
//
// |[<!-- language="C" -->
// Provides a function to retrieve an integer value from a GtkSpinButton
// and creates a spin button to model percentage values.
//
// gint
// grab_int_value (GtkSpinButton *button,
// gpointer       user_data)
// {
// return gtk_spin_button_get_value_as_int (button);
// }
//
// void
// create_integer_spin_button (void)
// {
//
// GtkWidget *window, *button;
// GtkAdjustment *adjustment;
//
// adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
//
// window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
// gtk_container_set_border_width (GTK_CONTAINER (window), 5);
//
// creates the spinbutton, with no decimal places
// button = gtk_spin_button_new (adjustment, 1.0, 0);
// gtk_container_add (GTK_CONTAINER (window), button);
//
// gtk_widget_show_all (window);
// }
// ]|
//
// ## Using a GtkSpinButton to get a floating point value
//
// |[<!-- language="C" -->
// Provides a function to retrieve a floating point value from a
// GtkSpinButton, and creates a high precision spin button.
//
// gfloat
// grab_float_value (GtkSpinButton *button,
// gpointer       user_data)
// {
// return gtk_spin_button_get_value (button);
// }
//
// void
// create_floating_spin_button (void)
// {
// GtkWidget *window, *button;
// GtkAdjustment *adjustment;
//
// adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
//
// window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
// gtk_container_set_border_width (GTK_CONTAINER (window), 5);
//
// creates the spinbutton, with three decimal places
// button = gtk_spin_button_new (adjustment, 0.001, 3);
// gtk_container_add (GTK_CONTAINER (window), button);
//
// gtk_widget_show_all (window);
// }
// ]|
/*

C record/class : GtkSpinButton
*/
type SpinButton struct {
	native *C.GtkSpinButton
	// entry : record
	// Private : priv
}

func SpinButtonNewFromC(u unsafe.Pointer) *SpinButton {
	c := (*C.GtkSpinButton)(u)
	if c == nil {
		return nil
	}

	g := &SpinButton{native: c}

	return g
}

func (recv *SpinButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Entry upcasts to *Entry
func (recv *SpinButton) Entry() *Entry {
	return EntryNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *SpinButton) Widget() *Widget {
	return recv.Entry().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SpinButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Entry().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SpinButton) Object() *gobject.Object {
	return recv.Entry().Object()
}

// CastToWidget down casts any arbitary Object to SpinButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinButton.
func CastToSpinButton(object *gobject.Object) *SpinButton {
	return SpinButtonNewFromC(object.ToC())
}

// Unsupported signal 'change-value' for SpinButton : unsupported parameter scroll : type ScrollType :

// Unsupported signal 'input' for SpinButton : unsupported parameter new_value : type gdouble :

type signalSpinButtonOutputDetail struct {
	callback  SpinButtonSignalOutputCallback
	handlerID C.gulong
}

var signalSpinButtonOutputId int
var signalSpinButtonOutputMap = make(map[int]signalSpinButtonOutputDetail)
var signalSpinButtonOutputLock sync.Mutex

// SpinButtonSignalOutputCallback is a callback function for a 'output' signal emitted from a SpinButton.
type SpinButtonSignalOutputCallback func() bool

/*
ConnectOutput connects the callback to the 'output' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectOutput to remove it.
*/
func (recv *SpinButton) ConnectOutput(callback SpinButtonSignalOutputCallback) int {
	signalSpinButtonOutputLock.Lock()
	defer signalSpinButtonOutputLock.Unlock()

	signalSpinButtonOutputId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_output(instance, C.gpointer(uintptr(signalSpinButtonOutputId)))

	detail := signalSpinButtonOutputDetail{callback, handlerID}
	signalSpinButtonOutputMap[signalSpinButtonOutputId] = detail

	return signalSpinButtonOutputId
}

/*
DisconnectOutput disconnects a callback from the 'output' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectOutput.
*/
func (recv *SpinButton) DisconnectOutput(connectionID int) {
	signalSpinButtonOutputLock.Lock()
	defer signalSpinButtonOutputLock.Unlock()

	detail, exists := signalSpinButtonOutputMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonOutputMap, connectionID)
}

//export spinbutton_outputHandler
func spinbutton_outputHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalSpinButtonOutputMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalSpinButtonValueChangedDetail struct {
	callback  SpinButtonSignalValueChangedCallback
	handlerID C.gulong
}

var signalSpinButtonValueChangedId int
var signalSpinButtonValueChangedMap = make(map[int]signalSpinButtonValueChangedDetail)
var signalSpinButtonValueChangedLock sync.Mutex

// SpinButtonSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a SpinButton.
type SpinButtonSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *SpinButton) ConnectValueChanged(callback SpinButtonSignalValueChangedCallback) int {
	signalSpinButtonValueChangedLock.Lock()
	defer signalSpinButtonValueChangedLock.Unlock()

	signalSpinButtonValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_value_changed(instance, C.gpointer(uintptr(signalSpinButtonValueChangedId)))

	detail := signalSpinButtonValueChangedDetail{callback, handlerID}
	signalSpinButtonValueChangedMap[signalSpinButtonValueChangedId] = detail

	return signalSpinButtonValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *SpinButton) DisconnectValueChanged(connectionID int) {
	signalSpinButtonValueChangedLock.Lock()
	defer signalSpinButtonValueChangedLock.Unlock()

	detail, exists := signalSpinButtonValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonValueChangedMap, connectionID)
}

//export spinbutton_valueChangedHandler
func spinbutton_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalSpinButtonValueChangedMap[index].callback
	callback()
}

// Creates a new #GtkSpinButton.
/*

C function : gtk_spin_button_new
*/
func SpinButtonNew(adjustment *Adjustment, climbRate float64, digits uint32) *SpinButton {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	c_climb_rate := (C.gdouble)(climbRate)

	c_digits := (C.guint)(digits)

	retC := C.gtk_spin_button_new(c_adjustment, c_climb_rate, c_digits)
	retGo := SpinButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This is a convenience constructor that allows creation of a numeric
// #GtkSpinButton without manually creating an adjustment. The value is
// initially set to the minimum value and a page increment of 10 * @step
// is the default. The precision of the spin button is equivalent to the
// precision of @step.
//
// Note that the way in which the precision is derived works best if @step
// is a power of ten. If the resulting precision is not suitable for your
// needs, use gtk_spin_button_set_digits() to correct it.
/*

C function : gtk_spin_button_new_with_range
*/
func SpinButtonNewWithRange(min float64, max float64, step float64) *SpinButton {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_spin_button_new_with_range(c_min, c_max, c_step)
	retGo := SpinButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Changes the properties of an existing spin button. The adjustment,
// climb rate, and number of decimal places are updated accordingly.
/*

C function : gtk_spin_button_configure
*/
func (recv *SpinButton) Configure(adjustment *Adjustment, climbRate float64, digits uint32) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	c_climb_rate := (C.gdouble)(climbRate)

	c_digits := (C.guint)(digits)

	C.gtk_spin_button_configure((*C.GtkSpinButton)(recv.native), c_adjustment, c_climb_rate, c_digits)

	return
}

// Get the adjustment associated with a #GtkSpinButton
/*

C function : gtk_spin_button_get_adjustment
*/
func (recv *SpinButton) GetAdjustment() *Adjustment {
	retC := C.gtk_spin_button_get_adjustment((*C.GtkSpinButton)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Fetches the precision of @spin_button. See gtk_spin_button_set_digits().
/*

C function : gtk_spin_button_get_digits
*/
func (recv *SpinButton) GetDigits() uint32 {
	retC := C.gtk_spin_button_get_digits((*C.GtkSpinButton)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Gets the current step and page the increments used by @spin_button. See
// gtk_spin_button_set_increments().
/*

C function : gtk_spin_button_get_increments
*/
func (recv *SpinButton) GetIncrements() (float64, float64) {
	var c_step C.gdouble

	var c_page C.gdouble

	C.gtk_spin_button_get_increments((*C.GtkSpinButton)(recv.native), &c_step, &c_page)

	step := (float64)(c_step)

	page := (float64)(c_page)

	return step, page
}

// Returns whether non-numeric text can be typed into the spin button.
// See gtk_spin_button_set_numeric().
/*

C function : gtk_spin_button_get_numeric
*/
func (recv *SpinButton) GetNumeric() bool {
	retC := C.gtk_spin_button_get_numeric((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the range allowed for @spin_button.
// See gtk_spin_button_set_range().
/*

C function : gtk_spin_button_get_range
*/
func (recv *SpinButton) GetRange() (float64, float64) {
	var c_min C.gdouble

	var c_max C.gdouble

	C.gtk_spin_button_get_range((*C.GtkSpinButton)(recv.native), &c_min, &c_max)

	min := (float64)(c_min)

	max := (float64)(c_max)

	return min, max
}

// Returns whether the values are corrected to the nearest step.
// See gtk_spin_button_set_snap_to_ticks().
/*

C function : gtk_spin_button_get_snap_to_ticks
*/
func (recv *SpinButton) GetSnapToTicks() bool {
	retC := C.gtk_spin_button_get_snap_to_ticks((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the update behavior of a spin button.
// See gtk_spin_button_set_update_policy().
/*

C function : gtk_spin_button_get_update_policy
*/
func (recv *SpinButton) GetUpdatePolicy() SpinButtonUpdatePolicy {
	retC := C.gtk_spin_button_get_update_policy((*C.GtkSpinButton)(recv.native))
	retGo := (SpinButtonUpdatePolicy)(retC)

	return retGo
}

// Get the value in the @spin_button.
/*

C function : gtk_spin_button_get_value
*/
func (recv *SpinButton) GetValue() float64 {
	retC := C.gtk_spin_button_get_value((*C.GtkSpinButton)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Get the value @spin_button represented as an integer.
/*

C function : gtk_spin_button_get_value_as_int
*/
func (recv *SpinButton) GetValueAsInt() int32 {
	retC := C.gtk_spin_button_get_value_as_int((*C.GtkSpinButton)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns whether the spin buttons value wraps around to the
// opposite limit when the upper or lower limit of the range is
// exceeded. See gtk_spin_button_set_wrap().
/*

C function : gtk_spin_button_get_wrap
*/
func (recv *SpinButton) GetWrap() bool {
	retC := C.gtk_spin_button_get_wrap((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Replaces the #GtkAdjustment associated with @spin_button.
/*

C function : gtk_spin_button_set_adjustment
*/
func (recv *SpinButton) SetAdjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_spin_button_set_adjustment((*C.GtkSpinButton)(recv.native), c_adjustment)

	return
}

// Set the precision to be displayed by @spin_button. Up to 20 digit precision
// is allowed.
/*

C function : gtk_spin_button_set_digits
*/
func (recv *SpinButton) SetDigits(digits uint32) {
	c_digits := (C.guint)(digits)

	C.gtk_spin_button_set_digits((*C.GtkSpinButton)(recv.native), c_digits)

	return
}

// Sets the step and page increments for spin_button.  This affects how
// quickly the value changes when the spin buttons arrows are activated.
/*

C function : gtk_spin_button_set_increments
*/
func (recv *SpinButton) SetIncrements(step float64, page float64) {
	c_step := (C.gdouble)(step)

	c_page := (C.gdouble)(page)

	C.gtk_spin_button_set_increments((*C.GtkSpinButton)(recv.native), c_step, c_page)

	return
}

// Sets the flag that determines if non-numeric text can be typed
// into the spin button.
/*

C function : gtk_spin_button_set_numeric
*/
func (recv *SpinButton) SetNumeric(numeric bool) {
	c_numeric :=
		boolToGboolean(numeric)

	C.gtk_spin_button_set_numeric((*C.GtkSpinButton)(recv.native), c_numeric)

	return
}

// Sets the minimum and maximum allowable values for @spin_button.
//
// If the current value is outside this range, it will be adjusted
// to fit within the range, otherwise it will remain unchanged.
/*

C function : gtk_spin_button_set_range
*/
func (recv *SpinButton) SetRange(min float64, max float64) {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	C.gtk_spin_button_set_range((*C.GtkSpinButton)(recv.native), c_min, c_max)

	return
}

// Sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after
// providing an invalid value.
/*

C function : gtk_spin_button_set_snap_to_ticks
*/
func (recv *SpinButton) SetSnapToTicks(snapToTicks bool) {
	c_snap_to_ticks :=
		boolToGboolean(snapToTicks)

	C.gtk_spin_button_set_snap_to_ticks((*C.GtkSpinButton)(recv.native), c_snap_to_ticks)

	return
}

// Sets the update behavior of a spin button.
// This determines whether the spin button is always updated
// or only when a valid value is set.
/*

C function : gtk_spin_button_set_update_policy
*/
func (recv *SpinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy) {
	c_policy := (C.GtkSpinButtonUpdatePolicy)(policy)

	C.gtk_spin_button_set_update_policy((*C.GtkSpinButton)(recv.native), c_policy)

	return
}

// Sets the value of @spin_button.
/*

C function : gtk_spin_button_set_value
*/
func (recv *SpinButton) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_spin_button_set_value((*C.GtkSpinButton)(recv.native), c_value)

	return
}

// Sets the flag that determines if a spin button value wraps
// around to the opposite limit when the upper or lower limit
// of the range is exceeded.
/*

C function : gtk_spin_button_set_wrap
*/
func (recv *SpinButton) SetWrap(wrap bool) {
	c_wrap :=
		boolToGboolean(wrap)

	C.gtk_spin_button_set_wrap((*C.GtkSpinButton)(recv.native), c_wrap)

	return
}

// Increment or decrement a spin buttons value in a specified
// direction by a specified amount.
/*

C function : gtk_spin_button_spin
*/
func (recv *SpinButton) Spin(direction SpinType, increment float64) {
	c_direction := (C.GtkSpinType)(direction)

	c_increment := (C.gdouble)(increment)

	C.gtk_spin_button_spin((*C.GtkSpinButton)(recv.native), c_direction, c_increment)

	return
}

// Manually force an update of the spin button.
/*

C function : gtk_spin_button_update
*/
func (recv *SpinButton) Update() {
	C.gtk_spin_button_update((*C.GtkSpinButton)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by SpinButton
func (recv *SpinButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SpinButton
func (recv *SpinButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by SpinButton
func (recv *SpinButton) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by SpinButton
func (recv *SpinButton) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by SpinButton
func (recv *SpinButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkSpinButtonAccessible
*/
type SpinButtonAccessible struct {
	native *C.GtkSpinButtonAccessible
	// parent : record
	// priv : record
}

func SpinButtonAccessibleNewFromC(u unsafe.Pointer) *SpinButtonAccessible {
	c := (*C.GtkSpinButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SpinButtonAccessible{native: c}

	return g
}

func (recv *SpinButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// EntryAccessible upcasts to *EntryAccessible
func (recv *SpinButtonAccessible) EntryAccessible() *EntryAccessible {
	return EntryAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SpinButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.EntryAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *SpinButtonAccessible) Accessible() *Accessible {
	return recv.EntryAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SpinButtonAccessible) Object() *atk.Object {
	return recv.EntryAccessible().Object()
}

// CastToWidget down casts any arbitary Object to SpinButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinButtonAccessible.
func CastToSpinButtonAccessible(object *gobject.Object) *SpinButtonAccessible {
	return SpinButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// A GtkSpinner widget displays an icon-size spinning animation.
// It is often used as an alternative to a #GtkProgressBar for
// displaying indefinite activity, instead of actual progress.
//
// To start the animation, use gtk_spinner_start(), to stop it
// use gtk_spinner_stop().
//
// # CSS nodes
//
// GtkSpinner has a single CSS node with the name spinner. When the animation is
// active, the :checked pseudoclass is added to this node.
/*

C record/class : GtkSpinner
*/
type Spinner struct {
	native *C.GtkSpinner
	// parent : record
	// Private : priv
}

func SpinnerNewFromC(u unsafe.Pointer) *Spinner {
	c := (*C.GtkSpinner)(u)
	if c == nil {
		return nil
	}

	g := &Spinner{native: c}

	return g
}

func (recv *Spinner) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Spinner) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Spinner) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Spinner) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Spinner.
// Exercise care, as this is a potentially dangerous function if the Object is not a Spinner.
func CastToSpinner(object *gobject.Object) *Spinner {
	return SpinnerNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Spinner
func (recv *Spinner) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Spinner
func (recv *Spinner) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkSpinnerAccessible
*/
type SpinnerAccessible struct {
	native *C.GtkSpinnerAccessible
	// parent : record
	// priv : record
}

func SpinnerAccessibleNewFromC(u unsafe.Pointer) *SpinnerAccessible {
	c := (*C.GtkSpinnerAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SpinnerAccessible{native: c}

	return g
}

func (recv *SpinnerAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SpinnerAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *SpinnerAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SpinnerAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to SpinnerAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinnerAccessible.
func CastToSpinnerAccessible(object *gobject.Object) *SpinnerAccessible {
	return SpinnerAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by SpinnerAccessible
func (recv *SpinnerAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by SpinnerAccessible
func (recv *SpinnerAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// The GtkStack widget is a container which only shows
// one of its children at a time. In contrast to GtkNotebook,
// GtkStack does not provide a means for users to change the
// visible child. Instead, the #GtkStackSwitcher widget can be
// used with GtkStack to provide this functionality.
//
// Transitions between pages can be animated as slides or
// fades. This can be controlled with gtk_stack_set_transition_type().
// These animations respect the #GtkSettings:gtk-enable-animations
// setting.
//
// The GtkStack widget was added in GTK+ 3.10.
//
// # CSS nodes
//
// GtkStack has a single CSS node named stack.
/*

C record/class : GtkStack
*/
type Stack struct {
	native *C.GtkStack
	// parent_instance : record
}

func StackNewFromC(u unsafe.Pointer) *Stack {
	c := (*C.GtkStack)(u)
	if c == nil {
		return nil
	}

	g := &Stack{native: c}

	return g
}

func (recv *Stack) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Stack) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Stack) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Stack) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Stack) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Stack.
// Exercise care, as this is a potentially dangerous function if the Object is not a Stack.
func CastToStack(object *gobject.Object) *Stack {
	return StackNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Stack
func (recv *Stack) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Stack
func (recv *Stack) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkStackAccessible

// A GtkStackSidebar enables you to quickly and easily provide a
// consistent "sidebar" object for your user interface.
//
// In order to use a GtkStackSidebar, you simply use a GtkStack to
// organize your UI flow, and add the sidebar to your sidebar area. You
// can use gtk_stack_sidebar_set_stack() to connect the #GtkStackSidebar
// to the #GtkStack.
//
// # CSS nodes
//
// GtkStackSidebar has a single CSS node with name stacksidebar and
// style class .sidebar.
//
// When circumstances require it, GtkStackSidebar adds the
// .needs-attention style class to the widgets representing the stack
// pages.
/*

C record/class : GtkStackSidebar
*/
type StackSidebar struct {
	native *C.GtkStackSidebar
	// parent : record
}

func StackSidebarNewFromC(u unsafe.Pointer) *StackSidebar {
	c := (*C.GtkStackSidebar)(u)
	if c == nil {
		return nil
	}

	g := &StackSidebar{native: c}

	return g
}

func (recv *StackSidebar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *StackSidebar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *StackSidebar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *StackSidebar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *StackSidebar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *StackSidebar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to StackSidebar.
// Exercise care, as this is a potentially dangerous function if the Object is not a StackSidebar.
func CastToStackSidebar(object *gobject.Object) *StackSidebar {
	return StackSidebarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by StackSidebar
func (recv *StackSidebar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by StackSidebar
func (recv *StackSidebar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// The GtkStackSwitcher widget acts as a controller for a
// #GtkStack; it shows a row of buttons to switch between
// the various pages of the associated stack widget.
//
// All the content for the buttons comes from the child properties
// of the #GtkStack; the button visibility in a #GtkStackSwitcher
// widget is controlled by the visibility of the child in the
// #GtkStack.
//
// It is possible to associate multiple #GtkStackSwitcher widgets
// with the same #GtkStack widget.
//
// The GtkStackSwitcher widget was added in 3.10.
//
// # CSS nodes
//
// GtkStackSwitcher has a single CSS node named stackswitcher and
// style class .stack-switcher.
//
// When circumstances require it, GtkStackSwitcher adds the
// .needs-attention style class to the widgets representing the
// stack pages.
/*

C record/class : GtkStackSwitcher
*/
type StackSwitcher struct {
	native *C.GtkStackSwitcher
	// widget : record
}

func StackSwitcherNewFromC(u unsafe.Pointer) *StackSwitcher {
	c := (*C.GtkStackSwitcher)(u)
	if c == nil {
		return nil
	}

	g := &StackSwitcher{native: c}

	return g
}

func (recv *StackSwitcher) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *StackSwitcher) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *StackSwitcher) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *StackSwitcher) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *StackSwitcher) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *StackSwitcher) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to StackSwitcher.
// Exercise care, as this is a potentially dangerous function if the Object is not a StackSwitcher.
func CastToStackSwitcher(object *gobject.Object) *StackSwitcher {
	return StackSwitcherNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by StackSwitcher
func (recv *StackSwitcher) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by StackSwitcher
func (recv *StackSwitcher) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by StackSwitcher
func (recv *StackSwitcher) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The system tray or notification area is normally used for transient icons
// that indicate some special state. For example, a system tray icon might
// appear to tell the user that they have new mail, or have an incoming instant
// message, or something along those lines. The basic idea is that creating an
// icon in the notification area is less annoying than popping up a dialog.
//
// A #GtkStatusIcon object can be used to display an icon in a system tray.
// The icon can have a tooltip, and the user can interact with it by
// activating it or popping up a context menu.
//
// It is very important to notice that status icons depend on the existence
// of a notification area being available to the user; you should not use status
// icons as the only way to convey critical information regarding your application,
// as the notification area may not exist on the user's environment, or may have
// been removed. You should always check that a status icon has been embedded into
// a notification area by using gtk_status_icon_is_embedded(), and gracefully
// recover if the function returns %FALSE.
//
// On X11, the implementation follows the
// [FreeDesktop System Tray Specification](http://www.freedesktop.org/wiki/Specifications/systemtray-spec).
// Implementations of the tray side of this specification can
// be found e.g. in the GNOME 2 and KDE panel applications.
//
// Note that a GtkStatusIcon is not a widget, but just a #GObject. Making it a
// widget would be impractical, since the system tray on Windows doesnt allow
// to embed arbitrary widgets.
//
// GtkStatusIcon has been deprecated in 3.14. You should consider using
// notifications or more modern platform-specific APIs instead. GLib provides
// the #GNotification API which works well with #GtkApplication on multiple
// platforms and environments, and should be the preferred mechanism to notify
// the users of transient status updates. See this [HowDoI](https://wiki.gnome.org/HowDoI/GNotification)
// for code examples.
/*

C record/class : GtkStatusIcon
*/
type StatusIcon struct {
	native *C.GtkStatusIcon
	// parent_instance : record
	// priv : record
}

func StatusIconNewFromC(u unsafe.Pointer) *StatusIcon {
	c := (*C.GtkStatusIcon)(u)
	if c == nil {
		return nil
	}

	g := &StatusIcon{native: c}

	return g
}

func (recv *StatusIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *StatusIcon) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to StatusIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a StatusIcon.
func CastToStatusIcon(object *gobject.Object) *StatusIcon {
	return StatusIconNewFromC(object.ToC())
}

// A #GtkStatusbar is usually placed along the bottom of an application's
// main #GtkWindow. It may provide a regular commentary of the application's
// status (as is usually the case in a web browser, for example), or may be
// used to simply output a message when the status changes, (when an upload
// is complete in an FTP client, for example).
//
// Status bars in GTK+ maintain a stack of messages. The message at
// the top of the each bars stack is the one that will currently be displayed.
//
// Any messages added to a statusbars stack must specify a
// context id that is used to uniquely identify
// the source of a message. This context id can be generated by
// gtk_statusbar_get_context_id(), given a message and the statusbar that
// it will be added to. Note that messages are stored in a stack, and when
// choosing which message to display, the stack structure is adhered to,
// regardless of the context identifier of a message.
//
// One could say that a statusbar maintains one stack of messages for
// display purposes, but allows multiple message producers to maintain
// sub-stacks of the messages they produced (via context ids).
//
// Status bars are created using gtk_statusbar_new().
//
// Messages are added to the bars stack with gtk_statusbar_push().
//
// The message at the top of the stack can be removed using
// gtk_statusbar_pop(). A message can be removed from anywhere in the
// stack if its message id was recorded at the time it was added. This
// is done using gtk_statusbar_remove().
//
// # CSS node
//
// GtkStatusbar has a single CSS node with name statusbar.
/*

C record/class : GtkStatusbar
*/
type Statusbar struct {
	native *C.GtkStatusbar
	// parent_widget : record
	// Private : priv
}

func StatusbarNewFromC(u unsafe.Pointer) *Statusbar {
	c := (*C.GtkStatusbar)(u)
	if c == nil {
		return nil
	}

	g := &Statusbar{native: c}

	return g
}

func (recv *Statusbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *Statusbar) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Statusbar) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *Statusbar) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Statusbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Statusbar) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to Statusbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Statusbar.
func CastToStatusbar(object *gobject.Object) *Statusbar {
	return StatusbarNewFromC(object.ToC())
}

// Unsupported signal 'text-popped' for Statusbar : unsupported parameter context_id : type guint :

// Unsupported signal 'text-pushed' for Statusbar : unsupported parameter context_id : type guint :

// Creates a new #GtkStatusbar ready for messages.
/*

C function : gtk_statusbar_new
*/
func StatusbarNew() *Statusbar {
	retC := C.gtk_statusbar_new()
	retGo := StatusbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns a new context identifier, given a description
// of the actual context. Note that the description is
// not shown in the UI.
/*

C function : gtk_statusbar_get_context_id
*/
func (recv *Statusbar) GetContextId(contextDescription string) uint32 {
	c_context_description := C.CString(contextDescription)
	defer C.free(unsafe.Pointer(c_context_description))

	retC := C.gtk_statusbar_get_context_id((*C.GtkStatusbar)(recv.native), c_context_description)
	retGo := (uint32)(retC)

	return retGo
}

// Removes the first message in the #GtkStatusbars stack
// with the given context id.
//
// Note that this may not change the displayed message, if
// the message at the top of the stack has a different
// context id.
/*

C function : gtk_statusbar_pop
*/
func (recv *Statusbar) Pop(contextId uint32) {
	c_context_id := (C.guint)(contextId)

	C.gtk_statusbar_pop((*C.GtkStatusbar)(recv.native), c_context_id)

	return
}

// Pushes a new message onto a statusbars stack.
/*

C function : gtk_statusbar_push
*/
func (recv *Statusbar) Push(contextId uint32, text string) uint32 {
	c_context_id := (C.guint)(contextId)

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	retC := C.gtk_statusbar_push((*C.GtkStatusbar)(recv.native), c_context_id, c_text)
	retGo := (uint32)(retC)

	return retGo
}

// Forces the removal of a message from a statusbars stack.
// The exact @context_id and @message_id must be specified.
/*

C function : gtk_statusbar_remove
*/
func (recv *Statusbar) Remove(contextId uint32, messageId uint32) {
	c_context_id := (C.guint)(contextId)

	c_message_id := (C.guint)(messageId)

	C.gtk_statusbar_remove((*C.GtkStatusbar)(recv.native), c_context_id, c_message_id)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Statusbar
func (recv *Statusbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Statusbar
func (recv *Statusbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Statusbar
func (recv *Statusbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkStatusbarAccessible
*/
type StatusbarAccessible struct {
	native *C.GtkStatusbarAccessible
	// parent : record
	// priv : record
}

func StatusbarAccessibleNewFromC(u unsafe.Pointer) *StatusbarAccessible {
	c := (*C.GtkStatusbarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &StatusbarAccessible{native: c}

	return g
}

func (recv *StatusbarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *StatusbarAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *StatusbarAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *StatusbarAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *StatusbarAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to StatusbarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a StatusbarAccessible.
func CastToStatusbarAccessible(object *gobject.Object) *StatusbarAccessible {
	return StatusbarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by StatusbarAccessible
func (recv *StatusbarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// A #GtkStyle object encapsulates the information that provides the look and
// feel for a widget.
//
// > In GTK+ 3.0, GtkStyle has been deprecated and replaced by
// > #GtkStyleContext.
//
// Each #GtkWidget has an associated #GtkStyle object that is used when
// rendering that widget. Also, a #GtkStyle holds information for the five
// possible widget states though not every widget supports all five
// states; see #GtkStateType.
//
// Usually the #GtkStyle for a widget is the same as the default style that
// is set by GTK+ and modified the theme engine.
//
// Usually applications should not need to use or modify the #GtkStyle of
// their widgets.
/*

C record/class : GtkStyle
*/
type Style struct {
	native *C.GtkStyle
	// Private : parent_instance
	// no type for fg
	// no type for bg
	// no type for light
	// no type for dark
	// no type for mid
	// no type for text
	// no type for base
	// no type for text_aa
	// black : record
	// white : record
	// font_desc : record
	Xthickness int32
	Ythickness int32
	// no type for background
	// Private : attach_count
	// Private : visual
	// Private : private_font_desc
	// Private : rc_style
	// Private : styles
	// Private : property_cache
	// Private : icon_factories
}

func StyleNewFromC(u unsafe.Pointer) *Style {
	c := (*C.GtkStyle)(u)
	if c == nil {
		return nil
	}

	g := &Style{
		Xthickness: (int32)(c.xthickness),
		Ythickness: (int32)(c.ythickness),
		native:     c,
	}

	return g
}

func (recv *Style) ToC() unsafe.Pointer {
	recv.native.xthickness =
		(C.gint)(recv.Xthickness)
	recv.native.ythickness =
		(C.gint)(recv.Ythickness)

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Style) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Style.
// Exercise care, as this is a potentially dangerous function if the Object is not a Style.
func CastToStyle(object *gobject.Object) *Style {
	return StyleNewFromC(object.ToC())
}

// Creates a new #GtkStyle.
/*

C function : gtk_style_new
*/
func StyleNew() *Style {
	retC := C.gtk_style_new()
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

/*

C function : gtk_style_apply_default_background
*/
func (recv *Style) ApplyDefaultBackground(cr *cairo.Context, window *gdk.Window, stateType StateType, x int32, y int32, width int32, height int32) {
	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_style_apply_default_background((*C.GtkStyle)(recv.native), c_cr, c_window, c_state_type, c_x, c_y, c_width, c_height)

	return
}

// Attaches a style to a window; this process allocates the
// colors and creates the GCs for the style - it specializes
// it to a particular visual. The process may involve the creation
// of a new style if the style has already been attached to a
// window with a different style and visual.
//
// Since this function may return a new object, you have to use it
// in the following way:
// `style = gtk_style_attach (style, window)`
/*

C function : gtk_style_attach
*/
func (recv *Style) Attach(window *gdk.Window) *Style {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	retC := C.gtk_style_attach((*C.GtkStyle)(recv.native), c_window)
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a copy of the passed in #GtkStyle object.
/*

C function : gtk_style_copy
*/
func (recv *Style) Copy() *Style {
	retC := C.gtk_style_copy((*C.GtkStyle)(recv.native))
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Detaches a style from a window. If the style is not attached
// to any windows anymore, it is unrealized. See gtk_style_attach().
/*

C function : gtk_style_detach
*/
func (recv *Style) Detach() {
	C.gtk_style_detach((*C.GtkStyle)(recv.native))

	return
}

// Looks up @stock_id in the icon factories associated with @style
// and the default icon factory, returning an icon set if found,
// otherwise %NULL.
/*

C function : gtk_style_lookup_icon_set
*/
func (recv *Style) LookupIconSet(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_style_lookup_icon_set((*C.GtkStyle)(recv.native), c_stock_id)
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Renders the icon specified by @source at the given @size
// according to the given parameters and returns the result in a
// pixbuf.
/*

C function : gtk_style_render_icon
*/
func (recv *Style) RenderIcon(source *IconSource, direction TextDirection, state StateType, size IconSize, widget *Widget, detail string) *gdkpixbuf.Pixbuf {
	c_source := (*C.GtkIconSource)(C.NULL)
	if source != nil {
		c_source = (*C.GtkIconSource)(source.ToC())
	}

	c_direction := (C.GtkTextDirection)(direction)

	c_state := (C.GtkStateType)(state)

	c_size := (C.GtkIconSize)(size)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	retC := C.gtk_style_render_icon((*C.GtkStyle)(recv.native), c_source, c_direction, c_state, c_size, c_widget, c_detail)
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the background of @window to the background color or pixmap
// specified by @style for the given state.
/*

C function : gtk_style_set_background
*/
func (recv *Style) SetBackground(window *gdk.Window, stateType StateType) {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	C.gtk_style_set_background((*C.GtkStyle)(recv.native), c_window, c_state_type)

	return
}

// #GtkStyleContext is an object that stores styling information affecting
// a widget defined by #GtkWidgetPath.
//
// In order to construct the final style information, #GtkStyleContext
// queries information from all attached #GtkStyleProviders. Style providers
// can be either attached explicitly to the context through
// gtk_style_context_add_provider(), or to the screen through
// gtk_style_context_add_provider_for_screen(). The resulting style is a
// combination of all providers information in priority order.
//
// For GTK+ widgets, any #GtkStyleContext returned by
// gtk_widget_get_style_context() will already have a #GtkWidgetPath, a
// #GdkScreen and RTL/LTR information set. The style context will also be
// updated automatically if any of these settings change on the widget.
//
// If you are using the theming layer standalone, you will need to set a
// widget path and a screen yourself to the created style context through
// gtk_style_context_set_path() and gtk_style_context_set_screen(), as well
// as updating the context yourself using gtk_style_context_invalidate()
// whenever any of the conditions change, such as a change in the
// #GtkSettings:gtk-theme-name setting or a hierarchy change in the rendered
// widget. See the Foreign drawing example in gtk3-demo.
//
// # Style Classes # {#gtkstylecontext-classes}
//
// Widgets can add style classes to their context, which can be used to associate
// different styles by class. The documentation for individual widgets lists
// which style classes it uses itself, and which style classes may be added by
// applications to affect their appearance.
//
// GTK+ defines macros for a number of style classes.
//
// # Style Regions
//
// Widgets can also add regions with flags to their context. This feature is
// deprecated and will be removed in a future GTK+ update. Please use style
// classes instead.
//
// GTK+ defines macros for a number of style regions.
//
// # Custom styling in UI libraries and applications
//
// If you are developing a library with custom #GtkWidgets that
// render differently than standard components, you may need to add a
// #GtkStyleProvider yourself with the %GTK_STYLE_PROVIDER_PRIORITY_FALLBACK
// priority, either a #GtkCssProvider or a custom object implementing the
// #GtkStyleProvider interface. This way themes may still attempt
// to style your UI elements in a different way if needed so.
//
// If you are using custom styling on an applications, you probably want then
// to make your style information prevail to the themes, so you must use
// a #GtkStyleProvider with the %GTK_STYLE_PROVIDER_PRIORITY_APPLICATION
// priority, keep in mind that the user settings in
// `XDG_CONFIG_HOME/gtk-3.0/gtk.css` will
// still take precedence over your changes, as it uses the
// %GTK_STYLE_PROVIDER_PRIORITY_USER priority.
/*

C record/class : GtkStyleContext
*/
type StyleContext struct {
	native *C.GtkStyleContext
	// parent_object : record
	// priv : record
}

func StyleContextNewFromC(u unsafe.Pointer) *StyleContext {
	c := (*C.GtkStyleContext)(u)
	if c == nil {
		return nil
	}

	g := &StyleContext{native: c}

	return g
}

func (recv *StyleContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *StyleContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to StyleContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a StyleContext.
func CastToStyleContext(object *gobject.Object) *StyleContext {
	return StyleContextNewFromC(object.ToC())
}

// Creates a standalone #GtkStyleContext, this style context
// wont be attached to any widget, so you may want
// to call gtk_style_context_set_path() yourself.
//
// This function is only useful when using the theming layer
// separated from GTK+, if you are using #GtkStyleContext to
// theme #GtkWidgets, use gtk_widget_get_style_context()
// in order to get a style context ready to theme the widget.
/*

C function : gtk_style_context_new
*/
func StyleContextNew() *StyleContext {
	retC := C.gtk_style_context_new()
	retGo := StyleContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the #GdkScreen to which @context is attached.
/*

C function : gtk_style_context_get_screen
*/
func (recv *StyleContext) GetScreen() *gdk.Screen {
	retC := C.gtk_style_context_get_screen((*C.GtkStyleContext)(recv.native))
	retGo := gdk.ScreenNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Queries the location in the CSS where @property was defined for the
// current @context. Note that the state to be queried is taken from
// gtk_style_context_get_state().
//
// If the location is not available, %NULL will be returned. The
// location might not be available for various reasons, such as the
// property being overridden, @property not naming a supported CSS
// property or tracking of definitions being disabled for performance
// reasons.
//
// Shorthand CSS properties cannot be queried for a location and will
// always return %NULL.
/*

C function : gtk_style_context_get_section
*/
func (recv *StyleContext) GetSection(property string) *CssSection {
	c_property := C.CString(property)
	defer C.free(unsafe.Pointer(c_property))

	retC := C.gtk_style_context_get_section((*C.GtkStyleContext)(recv.native), c_property)
	var retGo (*CssSection)
	if retC == nil {
		retGo = nil
	} else {
		retGo = CssSectionNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets the value for a widget style property.
//
// When @value is no longer needed, g_value_unset() must be called
// to free any allocated memory.
/*

C function : gtk_style_context_get_style_property
*/
func (recv *StyleContext) GetStyleProperty(propertyName string, value *gobject.Value) {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_style_context_get_style_property((*C.GtkStyleContext)(recv.native), c_property_name, c_value)

	return
}

// Looks up and resolves a color name in the @context color map.
/*

C function : gtk_style_context_lookup_color
*/
func (recv *StyleContext) LookupColor(colorName string) (bool, *gdk.RGBA) {
	c_color_name := C.CString(colorName)
	defer C.free(unsafe.Pointer(c_color_name))

	var c_color C.GdkRGBA

	retC := C.gtk_style_context_lookup_color((*C.GtkStyleContext)(recv.native), c_color_name, &c_color)
	retGo := retC == C.TRUE

	color := gdk.RGBANewFromC(unsafe.Pointer(&c_color))

	return retGo, color
}

// Looks up @stock_id in the icon factories associated to @context and
// the default icon factory, returning an icon set if found, otherwise
// %NULL.
/*

C function : gtk_style_context_lookup_icon_set
*/
func (recv *StyleContext) LookupIconSet(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_style_context_lookup_icon_set((*C.GtkStyleContext)(recv.native), c_stock_id)
	var retGo (*IconSet)
	if retC == nil {
		retGo = nil
	} else {
		retGo = IconSetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GtkStyleProperties provides the storage for style information
// that is used by #GtkStyleContext and other #GtkStyleProvider
// implementations.
//
// Before style properties can be stored in GtkStyleProperties, they
// must be registered with gtk_style_properties_register_property().
//
// Unless you are writing a #GtkStyleProvider implementation, you
// are unlikely to use this API directly, as gtk_style_context_get()
// and its variants are the preferred way to access styling information
// from widget implementations and theming engine implementations
// should use the APIs provided by #GtkThemingEngine instead.
//
// #GtkStyleProperties has been deprecated in GTK 3.16. The CSS
// machinery does not use it anymore and all users of this object
// have been deprecated.
/*

C record/class : GtkStyleProperties
*/
type StyleProperties struct {
	native *C.GtkStyleProperties
	// Private : parent_object
	// Private : priv
}

func StylePropertiesNewFromC(u unsafe.Pointer) *StyleProperties {
	c := (*C.GtkStyleProperties)(u)
	if c == nil {
		return nil
	}

	g := &StyleProperties{native: c}

	return g
}

func (recv *StyleProperties) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *StyleProperties) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to StyleProperties.
// Exercise care, as this is a potentially dangerous function if the Object is not a StyleProperties.
func CastToStyleProperties(object *gobject.Object) *StyleProperties {
	return StylePropertiesNewFromC(object.ToC())
}

// Returns a newly created #GtkStyleProperties
/*

C function : gtk_style_properties_new
*/
func StylePropertiesNew() *StyleProperties {
	retC := C.gtk_style_properties_new()
	retGo := StylePropertiesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Clears all style information from @props.
/*

C function : gtk_style_properties_clear
*/
func (recv *StyleProperties) Clear() {
	C.gtk_style_properties_clear((*C.GtkStyleProperties)(recv.native))

	return
}

// StyleProvider returns the StyleProvider interface implemented by StyleProperties
func (recv *StyleProperties) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// #GtkSwitch is a widget that has two states: on or off. The user can control
// which state should be active by clicking the empty area, or by dragging the
// handle.
//
// GtkSwitch can also handle situations where the underlying state changes with
// a delay. See #GtkSwitch::state-set for details.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// switch
//  slider
// ]|
//
// GtkSwitch has two css nodes, the main node with the name switch and a subnode
// named slider. Neither of them is using any style classes.
/*

C record/class : GtkSwitch
*/
type Switch struct {
	native *C.GtkSwitch
	// Private : parent_instance
	// Private : priv
}

func SwitchNewFromC(u unsafe.Pointer) *Switch {
	c := (*C.GtkSwitch)(u)
	if c == nil {
		return nil
	}

	g := &Switch{native: c}

	return g
}

func (recv *Switch) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Switch) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Switch) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Switch) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Switch.
// Exercise care, as this is a potentially dangerous function if the Object is not a Switch.
func CastToSwitch(object *gobject.Object) *Switch {
	return SwitchNewFromC(object.ToC())
}

type signalSwitchActivateDetail struct {
	callback  SwitchSignalActivateCallback
	handlerID C.gulong
}

var signalSwitchActivateId int
var signalSwitchActivateMap = make(map[int]signalSwitchActivateDetail)
var signalSwitchActivateLock sync.Mutex

// SwitchSignalActivateCallback is a callback function for a 'activate' signal emitted from a Switch.
type SwitchSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Switch.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Switch) ConnectActivate(callback SwitchSignalActivateCallback) int {
	signalSwitchActivateLock.Lock()
	defer signalSwitchActivateLock.Unlock()

	signalSwitchActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Switch_signal_connect_activate(instance, C.gpointer(uintptr(signalSwitchActivateId)))

	detail := signalSwitchActivateDetail{callback, handlerID}
	signalSwitchActivateMap[signalSwitchActivateId] = detail

	return signalSwitchActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Switch.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Switch) DisconnectActivate(connectionID int) {
	signalSwitchActivateLock.Lock()
	defer signalSwitchActivateLock.Unlock()

	detail, exists := signalSwitchActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSwitchActivateMap, connectionID)
}

//export switch_activateHandler
func switch_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalSwitchActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Switch
func (recv *Switch) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by Switch
func (recv *Switch) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by Switch
func (recv *Switch) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Switch
func (recv *Switch) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkSwitchAccessible
*/
type SwitchAccessible struct {
	native *C.GtkSwitchAccessible
	// parent : record
	// priv : record
}

func SwitchAccessibleNewFromC(u unsafe.Pointer) *SwitchAccessible {
	c := (*C.GtkSwitchAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SwitchAccessible{native: c}

	return g
}

func (recv *SwitchAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SwitchAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *SwitchAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SwitchAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to SwitchAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SwitchAccessible.
func CastToSwitchAccessible(object *gobject.Object) *SwitchAccessible {
	return SwitchAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by SwitchAccessible
func (recv *SwitchAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by SwitchAccessible
func (recv *SwitchAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// The #GtkTable functions allow the programmer to arrange widgets in rows and
// columns, making it easy to align many widgets next to each other,
// horizontally and vertically.
//
// Tables are created with a call to gtk_table_new(), the size of which can
// later be changed with gtk_table_resize().
//
// Widgets can be added to a table using gtk_table_attach() or the more
// convenient (but slightly less flexible) gtk_table_attach_defaults().
//
// To alter the space next to a specific row, use gtk_table_set_row_spacing(),
// and for a column, gtk_table_set_col_spacing().
// The gaps between all rows or columns can be changed by
// calling gtk_table_set_row_spacings() or gtk_table_set_col_spacings()
// respectively. Note that spacing is added between the
// children, while padding added by gtk_table_attach() is added on
// either side of the widget it belongs to.
//
// gtk_table_set_homogeneous(), can be used to set whether all cells in the
// table will resize themselves to the size of the largest widget in the table.
//
// > #GtkTable has been deprecated. Use #GtkGrid instead. It provides the same
// > capabilities as GtkTable for arranging widgets in a rectangular grid, but
// > does support height-for-width geometry management.
/*

C record/class : GtkTable
*/
type Table struct {
	native *C.GtkTable
	// container : record
	// Private : priv
}

func TableNewFromC(u unsafe.Pointer) *Table {
	c := (*C.GtkTable)(u)
	if c == nil {
		return nil
	}

	g := &Table{native: c}

	return g
}

func (recv *Table) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Table) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Table) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Table) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Table) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Table.
// Exercise care, as this is a potentially dangerous function if the Object is not a Table.
func CastToTable(object *gobject.Object) *Table {
	return TableNewFromC(object.ToC())
}

// Used to create a new table widget. An initial size must be given by
// specifying how many rows and columns the table should have, although
// this can be changed later with gtk_table_resize().  @rows and @columns
// must both be in the range 1 .. 65535. For historical reasons, 0 is accepted
// as well and is silently interpreted as 1.
/*

C function : gtk_table_new
*/
func TableNew(rows uint32, columns uint32, homogeneous bool) *Table {
	c_rows := (C.guint)(rows)

	c_columns := (C.guint)(columns)

	c_homogeneous :=
		boolToGboolean(homogeneous)

	retC := C.gtk_table_new(c_rows, c_columns, c_homogeneous)
	retGo := TableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a widget to a table. The number of cells that a widget will occupy is
// specified by @left_attach, @right_attach, @top_attach and @bottom_attach.
// These each represent the leftmost, rightmost, uppermost and lowest column
// and row numbers of the table. (Columns and rows are indexed from zero).
//
// To make a button occupy the lower right cell of a 2x2 table, use
// |[
// gtk_table_attach (table, button,
// 1, 2, // left, right attach
// 1, 2, // top, bottom attach
// xoptions, yoptions,
// xpadding, ypadding);
// ]|
// If you want to make the button span the entire bottom row, use @left_attach == 0 and @right_attach = 2 instead.
/*

C function : gtk_table_attach
*/
func (recv *Table) Attach(child *Widget, leftAttach uint32, rightAttach uint32, topAttach uint32, bottomAttach uint32, xoptions AttachOptions, yoptions AttachOptions, xpadding uint32, ypadding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_left_attach := (C.guint)(leftAttach)

	c_right_attach := (C.guint)(rightAttach)

	c_top_attach := (C.guint)(topAttach)

	c_bottom_attach := (C.guint)(bottomAttach)

	c_xoptions := (C.GtkAttachOptions)(xoptions)

	c_yoptions := (C.GtkAttachOptions)(yoptions)

	c_xpadding := (C.guint)(xpadding)

	c_ypadding := (C.guint)(ypadding)

	C.gtk_table_attach((*C.GtkTable)(recv.native), c_child, c_left_attach, c_right_attach, c_top_attach, c_bottom_attach, c_xoptions, c_yoptions, c_xpadding, c_ypadding)

	return
}

// As there are many options associated with gtk_table_attach(), this convenience
// function provides the programmer with a means to add children to a table with
// identical padding and expansion options. The values used for the #GtkAttachOptions
// are `GTK_EXPAND | GTK_FILL`, and the padding is set to 0.
/*

C function : gtk_table_attach_defaults
*/
func (recv *Table) AttachDefaults(widget *Widget, leftAttach uint32, rightAttach uint32, topAttach uint32, bottomAttach uint32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_left_attach := (C.guint)(leftAttach)

	c_right_attach := (C.guint)(rightAttach)

	c_top_attach := (C.guint)(topAttach)

	c_bottom_attach := (C.guint)(bottomAttach)

	C.gtk_table_attach_defaults((*C.GtkTable)(recv.native), c_widget, c_left_attach, c_right_attach, c_top_attach, c_bottom_attach)

	return
}

// Gets the amount of space between column @col, and
// column @col + 1. See gtk_table_set_col_spacing().
/*

C function : gtk_table_get_col_spacing
*/
func (recv *Table) GetColSpacing(column uint32) uint32 {
	c_column := (C.guint)(column)

	retC := C.gtk_table_get_col_spacing((*C.GtkTable)(recv.native), c_column)
	retGo := (uint32)(retC)

	return retGo
}

// Gets the default column spacing for the table. This is
// the spacing that will be used for newly added columns.
// (See gtk_table_set_col_spacings())
/*

C function : gtk_table_get_default_col_spacing
*/
func (recv *Table) GetDefaultColSpacing() uint32 {
	retC := C.gtk_table_get_default_col_spacing((*C.GtkTable)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Gets the default row spacing for the table. This is
// the spacing that will be used for newly added rows.
// (See gtk_table_set_row_spacings())
/*

C function : gtk_table_get_default_row_spacing
*/
func (recv *Table) GetDefaultRowSpacing() uint32 {
	retC := C.gtk_table_get_default_row_spacing((*C.GtkTable)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Returns whether the table cells are all constrained to the same
// width and height. (See gtk_table_set_homogeneous ())
/*

C function : gtk_table_get_homogeneous
*/
func (recv *Table) GetHomogeneous() bool {
	retC := C.gtk_table_get_homogeneous((*C.GtkTable)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the amount of space between row @row, and
// row @row + 1. See gtk_table_set_row_spacing().
/*

C function : gtk_table_get_row_spacing
*/
func (recv *Table) GetRowSpacing(row uint32) uint32 {
	c_row := (C.guint)(row)

	retC := C.gtk_table_get_row_spacing((*C.GtkTable)(recv.native), c_row)
	retGo := (uint32)(retC)

	return retGo
}

// If you need to change a tables size after
// it has been created, this function allows you to do so.
/*

C function : gtk_table_resize
*/
func (recv *Table) Resize(rows uint32, columns uint32) {
	c_rows := (C.guint)(rows)

	c_columns := (C.guint)(columns)

	C.gtk_table_resize((*C.GtkTable)(recv.native), c_rows, c_columns)

	return
}

// Alters the amount of space between a given table column and the following
// column.
/*

C function : gtk_table_set_col_spacing
*/
func (recv *Table) SetColSpacing(column uint32, spacing uint32) {
	c_column := (C.guint)(column)

	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_col_spacing((*C.GtkTable)(recv.native), c_column, c_spacing)

	return
}

// Sets the space between every column in @table equal to @spacing.
/*

C function : gtk_table_set_col_spacings
*/
func (recv *Table) SetColSpacings(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_col_spacings((*C.GtkTable)(recv.native), c_spacing)

	return
}

// Changes the homogenous property of table cells, ie. whether all cells are
// an equal size or not.
/*

C function : gtk_table_set_homogeneous
*/
func (recv *Table) SetHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_table_set_homogeneous((*C.GtkTable)(recv.native), c_homogeneous)

	return
}

// Changes the space between a given table row and the subsequent row.
/*

C function : gtk_table_set_row_spacing
*/
func (recv *Table) SetRowSpacing(row uint32, spacing uint32) {
	c_row := (C.guint)(row)

	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_row_spacing((*C.GtkTable)(recv.native), c_row, c_spacing)

	return
}

// Sets the space between every row in @table equal to @spacing.
/*

C function : gtk_table_set_row_spacings
*/
func (recv *Table) SetRowSpacings(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_row_spacings((*C.GtkTable)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Table
func (recv *Table) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Table
func (recv *Table) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A #GtkTearoffMenuItem is a special #GtkMenuItem which is used to
// tear off and reattach its menu.
//
// When its menu is shown normally, the #GtkTearoffMenuItem is drawn as a
// dotted line indicating that the menu can be torn off.  Activating it
// causes its menu to be torn off and displayed in its own window
// as a tearoff menu.
//
// When its menu is shown as a tearoff menu, the #GtkTearoffMenuItem is drawn
// as a dotted line which has a left pointing arrow graphic indicating that
// the tearoff menu can be reattached.  Activating it will erase the tearoff
// menu window.
//
// > #GtkTearoffMenuItem is deprecated and should not be used in newly
// > written code. Menus are not meant to be torn around.
/*

C record/class : GtkTearoffMenuItem
*/
type TearoffMenuItem struct {
	native *C.GtkTearoffMenuItem
	// menu_item : record
	// Private : priv
}

func TearoffMenuItemNewFromC(u unsafe.Pointer) *TearoffMenuItem {
	c := (*C.GtkTearoffMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &TearoffMenuItem{native: c}

	return g
}

func (recv *TearoffMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItem upcasts to *MenuItem
func (recv *TearoffMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *TearoffMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *TearoffMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *TearoffMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TearoffMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TearoffMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitary Object to TearoffMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a TearoffMenuItem.
func CastToTearoffMenuItem(object *gobject.Object) *TearoffMenuItem {
	return TearoffMenuItemNewFromC(object.ToC())
}

// Creates a new #GtkTearoffMenuItem.
/*

C function : gtk_tearoff_menu_item_new
*/
func TearoffMenuItemNew() *TearoffMenuItem {
	retC := C.gtk_tearoff_menu_item_new()
	retGo := TearoffMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// You may wish to begin by reading the
// [text widget conceptual overview][TextWidget]
// which gives an overview of all the objects and data
// types related to the text widget and how they work together.
/*

C record/class : GtkTextBuffer
*/
type TextBuffer struct {
	native *C.GtkTextBuffer
	// parent_instance : record
	// priv : record
}

func TextBufferNewFromC(u unsafe.Pointer) *TextBuffer {
	c := (*C.GtkTextBuffer)(u)
	if c == nil {
		return nil
	}

	g := &TextBuffer{native: c}

	return g
}

func (recv *TextBuffer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextBuffer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextBuffer.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextBuffer.
func CastToTextBuffer(object *gobject.Object) *TextBuffer {
	return TextBufferNewFromC(object.ToC())
}

type signalTextBufferApplyTagDetail struct {
	callback  TextBufferSignalApplyTagCallback
	handlerID C.gulong
}

var signalTextBufferApplyTagId int
var signalTextBufferApplyTagMap = make(map[int]signalTextBufferApplyTagDetail)
var signalTextBufferApplyTagLock sync.Mutex

// TextBufferSignalApplyTagCallback is a callback function for a 'apply-tag' signal emitted from a TextBuffer.
type TextBufferSignalApplyTagCallback func(tag *TextTag, start *TextIter, end *TextIter)

/*
ConnectApplyTag connects the callback to the 'apply-tag' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectApplyTag to remove it.
*/
func (recv *TextBuffer) ConnectApplyTag(callback TextBufferSignalApplyTagCallback) int {
	signalTextBufferApplyTagLock.Lock()
	defer signalTextBufferApplyTagLock.Unlock()

	signalTextBufferApplyTagId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_apply_tag(instance, C.gpointer(uintptr(signalTextBufferApplyTagId)))

	detail := signalTextBufferApplyTagDetail{callback, handlerID}
	signalTextBufferApplyTagMap[signalTextBufferApplyTagId] = detail

	return signalTextBufferApplyTagId
}

/*
DisconnectApplyTag disconnects a callback from the 'apply-tag' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectApplyTag.
*/
func (recv *TextBuffer) DisconnectApplyTag(connectionID int) {
	signalTextBufferApplyTagLock.Lock()
	defer signalTextBufferApplyTagLock.Unlock()

	detail, exists := signalTextBufferApplyTagMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferApplyTagMap, connectionID)
}

//export textbuffer_applyTagHandler
func textbuffer_applyTagHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferApplyTagMap[index].callback
	callback(tag, start, end)
}

type signalTextBufferBeginUserActionDetail struct {
	callback  TextBufferSignalBeginUserActionCallback
	handlerID C.gulong
}

var signalTextBufferBeginUserActionId int
var signalTextBufferBeginUserActionMap = make(map[int]signalTextBufferBeginUserActionDetail)
var signalTextBufferBeginUserActionLock sync.Mutex

// TextBufferSignalBeginUserActionCallback is a callback function for a 'begin-user-action' signal emitted from a TextBuffer.
type TextBufferSignalBeginUserActionCallback func()

/*
ConnectBeginUserAction connects the callback to the 'begin-user-action' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectBeginUserAction to remove it.
*/
func (recv *TextBuffer) ConnectBeginUserAction(callback TextBufferSignalBeginUserActionCallback) int {
	signalTextBufferBeginUserActionLock.Lock()
	defer signalTextBufferBeginUserActionLock.Unlock()

	signalTextBufferBeginUserActionId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_begin_user_action(instance, C.gpointer(uintptr(signalTextBufferBeginUserActionId)))

	detail := signalTextBufferBeginUserActionDetail{callback, handlerID}
	signalTextBufferBeginUserActionMap[signalTextBufferBeginUserActionId] = detail

	return signalTextBufferBeginUserActionId
}

/*
DisconnectBeginUserAction disconnects a callback from the 'begin-user-action' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectBeginUserAction.
*/
func (recv *TextBuffer) DisconnectBeginUserAction(connectionID int) {
	signalTextBufferBeginUserActionLock.Lock()
	defer signalTextBufferBeginUserActionLock.Unlock()

	detail, exists := signalTextBufferBeginUserActionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferBeginUserActionMap, connectionID)
}

//export textbuffer_beginUserActionHandler
func textbuffer_beginUserActionHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextBufferBeginUserActionMap[index].callback
	callback()
}

type signalTextBufferChangedDetail struct {
	callback  TextBufferSignalChangedCallback
	handlerID C.gulong
}

var signalTextBufferChangedId int
var signalTextBufferChangedMap = make(map[int]signalTextBufferChangedDetail)
var signalTextBufferChangedLock sync.Mutex

// TextBufferSignalChangedCallback is a callback function for a 'changed' signal emitted from a TextBuffer.
type TextBufferSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *TextBuffer) ConnectChanged(callback TextBufferSignalChangedCallback) int {
	signalTextBufferChangedLock.Lock()
	defer signalTextBufferChangedLock.Unlock()

	signalTextBufferChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_changed(instance, C.gpointer(uintptr(signalTextBufferChangedId)))

	detail := signalTextBufferChangedDetail{callback, handlerID}
	signalTextBufferChangedMap[signalTextBufferChangedId] = detail

	return signalTextBufferChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *TextBuffer) DisconnectChanged(connectionID int) {
	signalTextBufferChangedLock.Lock()
	defer signalTextBufferChangedLock.Unlock()

	detail, exists := signalTextBufferChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferChangedMap, connectionID)
}

//export textbuffer_changedHandler
func textbuffer_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextBufferChangedMap[index].callback
	callback()
}

type signalTextBufferDeleteRangeDetail struct {
	callback  TextBufferSignalDeleteRangeCallback
	handlerID C.gulong
}

var signalTextBufferDeleteRangeId int
var signalTextBufferDeleteRangeMap = make(map[int]signalTextBufferDeleteRangeDetail)
var signalTextBufferDeleteRangeLock sync.Mutex

// TextBufferSignalDeleteRangeCallback is a callback function for a 'delete-range' signal emitted from a TextBuffer.
type TextBufferSignalDeleteRangeCallback func(start *TextIter, end *TextIter)

/*
ConnectDeleteRange connects the callback to the 'delete-range' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectDeleteRange to remove it.
*/
func (recv *TextBuffer) ConnectDeleteRange(callback TextBufferSignalDeleteRangeCallback) int {
	signalTextBufferDeleteRangeLock.Lock()
	defer signalTextBufferDeleteRangeLock.Unlock()

	signalTextBufferDeleteRangeId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_delete_range(instance, C.gpointer(uintptr(signalTextBufferDeleteRangeId)))

	detail := signalTextBufferDeleteRangeDetail{callback, handlerID}
	signalTextBufferDeleteRangeMap[signalTextBufferDeleteRangeId] = detail

	return signalTextBufferDeleteRangeId
}

/*
DisconnectDeleteRange disconnects a callback from the 'delete-range' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectDeleteRange.
*/
func (recv *TextBuffer) DisconnectDeleteRange(connectionID int) {
	signalTextBufferDeleteRangeLock.Lock()
	defer signalTextBufferDeleteRangeLock.Unlock()

	detail, exists := signalTextBufferDeleteRangeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferDeleteRangeMap, connectionID)
}

//export textbuffer_deleteRangeHandler
func textbuffer_deleteRangeHandler(_ *C.GObject, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferDeleteRangeMap[index].callback
	callback(start, end)
}

type signalTextBufferEndUserActionDetail struct {
	callback  TextBufferSignalEndUserActionCallback
	handlerID C.gulong
}

var signalTextBufferEndUserActionId int
var signalTextBufferEndUserActionMap = make(map[int]signalTextBufferEndUserActionDetail)
var signalTextBufferEndUserActionLock sync.Mutex

// TextBufferSignalEndUserActionCallback is a callback function for a 'end-user-action' signal emitted from a TextBuffer.
type TextBufferSignalEndUserActionCallback func()

/*
ConnectEndUserAction connects the callback to the 'end-user-action' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectEndUserAction to remove it.
*/
func (recv *TextBuffer) ConnectEndUserAction(callback TextBufferSignalEndUserActionCallback) int {
	signalTextBufferEndUserActionLock.Lock()
	defer signalTextBufferEndUserActionLock.Unlock()

	signalTextBufferEndUserActionId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_end_user_action(instance, C.gpointer(uintptr(signalTextBufferEndUserActionId)))

	detail := signalTextBufferEndUserActionDetail{callback, handlerID}
	signalTextBufferEndUserActionMap[signalTextBufferEndUserActionId] = detail

	return signalTextBufferEndUserActionId
}

/*
DisconnectEndUserAction disconnects a callback from the 'end-user-action' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectEndUserAction.
*/
func (recv *TextBuffer) DisconnectEndUserAction(connectionID int) {
	signalTextBufferEndUserActionLock.Lock()
	defer signalTextBufferEndUserActionLock.Unlock()

	detail, exists := signalTextBufferEndUserActionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferEndUserActionMap, connectionID)
}

//export textbuffer_endUserActionHandler
func textbuffer_endUserActionHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextBufferEndUserActionMap[index].callback
	callback()
}

type signalTextBufferInsertChildAnchorDetail struct {
	callback  TextBufferSignalInsertChildAnchorCallback
	handlerID C.gulong
}

var signalTextBufferInsertChildAnchorId int
var signalTextBufferInsertChildAnchorMap = make(map[int]signalTextBufferInsertChildAnchorDetail)
var signalTextBufferInsertChildAnchorLock sync.Mutex

// TextBufferSignalInsertChildAnchorCallback is a callback function for a 'insert-child-anchor' signal emitted from a TextBuffer.
type TextBufferSignalInsertChildAnchorCallback func(location *TextIter, anchor *TextChildAnchor)

/*
ConnectInsertChildAnchor connects the callback to the 'insert-child-anchor' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertChildAnchor to remove it.
*/
func (recv *TextBuffer) ConnectInsertChildAnchor(callback TextBufferSignalInsertChildAnchorCallback) int {
	signalTextBufferInsertChildAnchorLock.Lock()
	defer signalTextBufferInsertChildAnchorLock.Unlock()

	signalTextBufferInsertChildAnchorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_child_anchor(instance, C.gpointer(uintptr(signalTextBufferInsertChildAnchorId)))

	detail := signalTextBufferInsertChildAnchorDetail{callback, handlerID}
	signalTextBufferInsertChildAnchorMap[signalTextBufferInsertChildAnchorId] = detail

	return signalTextBufferInsertChildAnchorId
}

/*
DisconnectInsertChildAnchor disconnects a callback from the 'insert-child-anchor' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertChildAnchor.
*/
func (recv *TextBuffer) DisconnectInsertChildAnchor(connectionID int) {
	signalTextBufferInsertChildAnchorLock.Lock()
	defer signalTextBufferInsertChildAnchorLock.Unlock()

	detail, exists := signalTextBufferInsertChildAnchorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertChildAnchorMap, connectionID)
}

//export textbuffer_insertChildAnchorHandler
func textbuffer_insertChildAnchorHandler(_ *C.GObject, c_location *C.GtkTextIter, c_anchor *C.GtkTextChildAnchor, data C.gpointer) {
	location := TextIterNewFromC(unsafe.Pointer(c_location))

	anchor := TextChildAnchorNewFromC(unsafe.Pointer(c_anchor))

	index := int(uintptr(data))
	callback := signalTextBufferInsertChildAnchorMap[index].callback
	callback(location, anchor)
}

type signalTextBufferInsertPixbufDetail struct {
	callback  TextBufferSignalInsertPixbufCallback
	handlerID C.gulong
}

var signalTextBufferInsertPixbufId int
var signalTextBufferInsertPixbufMap = make(map[int]signalTextBufferInsertPixbufDetail)
var signalTextBufferInsertPixbufLock sync.Mutex

// TextBufferSignalInsertPixbufCallback is a callback function for a 'insert-pixbuf' signal emitted from a TextBuffer.
type TextBufferSignalInsertPixbufCallback func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf)

/*
ConnectInsertPixbuf connects the callback to the 'insert-pixbuf' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertPixbuf to remove it.
*/
func (recv *TextBuffer) ConnectInsertPixbuf(callback TextBufferSignalInsertPixbufCallback) int {
	signalTextBufferInsertPixbufLock.Lock()
	defer signalTextBufferInsertPixbufLock.Unlock()

	signalTextBufferInsertPixbufId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_pixbuf(instance, C.gpointer(uintptr(signalTextBufferInsertPixbufId)))

	detail := signalTextBufferInsertPixbufDetail{callback, handlerID}
	signalTextBufferInsertPixbufMap[signalTextBufferInsertPixbufId] = detail

	return signalTextBufferInsertPixbufId
}

/*
DisconnectInsertPixbuf disconnects a callback from the 'insert-pixbuf' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertPixbuf.
*/
func (recv *TextBuffer) DisconnectInsertPixbuf(connectionID int) {
	signalTextBufferInsertPixbufLock.Lock()
	defer signalTextBufferInsertPixbufLock.Unlock()

	detail, exists := signalTextBufferInsertPixbufMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertPixbufMap, connectionID)
}

//export textbuffer_insertPixbufHandler
func textbuffer_insertPixbufHandler(_ *C.GObject, c_location *C.GtkTextIter, c_pixbuf *C.GdkPixbuf, data C.gpointer) {
	location := TextIterNewFromC(unsafe.Pointer(c_location))

	pixbuf := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(c_pixbuf))

	index := int(uintptr(data))
	callback := signalTextBufferInsertPixbufMap[index].callback
	callback(location, pixbuf)
}

// Unsupported signal 'insert-text' for TextBuffer : unsupported parameter text : type utf8 :

type signalTextBufferMarkDeletedDetail struct {
	callback  TextBufferSignalMarkDeletedCallback
	handlerID C.gulong
}

var signalTextBufferMarkDeletedId int
var signalTextBufferMarkDeletedMap = make(map[int]signalTextBufferMarkDeletedDetail)
var signalTextBufferMarkDeletedLock sync.Mutex

// TextBufferSignalMarkDeletedCallback is a callback function for a 'mark-deleted' signal emitted from a TextBuffer.
type TextBufferSignalMarkDeletedCallback func(mark *TextMark)

/*
ConnectMarkDeleted connects the callback to the 'mark-deleted' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectMarkDeleted to remove it.
*/
func (recv *TextBuffer) ConnectMarkDeleted(callback TextBufferSignalMarkDeletedCallback) int {
	signalTextBufferMarkDeletedLock.Lock()
	defer signalTextBufferMarkDeletedLock.Unlock()

	signalTextBufferMarkDeletedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_mark_deleted(instance, C.gpointer(uintptr(signalTextBufferMarkDeletedId)))

	detail := signalTextBufferMarkDeletedDetail{callback, handlerID}
	signalTextBufferMarkDeletedMap[signalTextBufferMarkDeletedId] = detail

	return signalTextBufferMarkDeletedId
}

/*
DisconnectMarkDeleted disconnects a callback from the 'mark-deleted' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectMarkDeleted.
*/
func (recv *TextBuffer) DisconnectMarkDeleted(connectionID int) {
	signalTextBufferMarkDeletedLock.Lock()
	defer signalTextBufferMarkDeletedLock.Unlock()

	detail, exists := signalTextBufferMarkDeletedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferMarkDeletedMap, connectionID)
}

//export textbuffer_markDeletedHandler
func textbuffer_markDeletedHandler(_ *C.GObject, c_mark *C.GtkTextMark, data C.gpointer) {
	mark := TextMarkNewFromC(unsafe.Pointer(c_mark))

	index := int(uintptr(data))
	callback := signalTextBufferMarkDeletedMap[index].callback
	callback(mark)
}

type signalTextBufferMarkSetDetail struct {
	callback  TextBufferSignalMarkSetCallback
	handlerID C.gulong
}

var signalTextBufferMarkSetId int
var signalTextBufferMarkSetMap = make(map[int]signalTextBufferMarkSetDetail)
var signalTextBufferMarkSetLock sync.Mutex

// TextBufferSignalMarkSetCallback is a callback function for a 'mark-set' signal emitted from a TextBuffer.
type TextBufferSignalMarkSetCallback func(location *TextIter, mark *TextMark)

/*
ConnectMarkSet connects the callback to the 'mark-set' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectMarkSet to remove it.
*/
func (recv *TextBuffer) ConnectMarkSet(callback TextBufferSignalMarkSetCallback) int {
	signalTextBufferMarkSetLock.Lock()
	defer signalTextBufferMarkSetLock.Unlock()

	signalTextBufferMarkSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_mark_set(instance, C.gpointer(uintptr(signalTextBufferMarkSetId)))

	detail := signalTextBufferMarkSetDetail{callback, handlerID}
	signalTextBufferMarkSetMap[signalTextBufferMarkSetId] = detail

	return signalTextBufferMarkSetId
}

/*
DisconnectMarkSet disconnects a callback from the 'mark-set' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectMarkSet.
*/
func (recv *TextBuffer) DisconnectMarkSet(connectionID int) {
	signalTextBufferMarkSetLock.Lock()
	defer signalTextBufferMarkSetLock.Unlock()

	detail, exists := signalTextBufferMarkSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferMarkSetMap, connectionID)
}

//export textbuffer_markSetHandler
func textbuffer_markSetHandler(_ *C.GObject, c_location *C.GtkTextIter, c_mark *C.GtkTextMark, data C.gpointer) {
	location := TextIterNewFromC(unsafe.Pointer(c_location))

	mark := TextMarkNewFromC(unsafe.Pointer(c_mark))

	index := int(uintptr(data))
	callback := signalTextBufferMarkSetMap[index].callback
	callback(location, mark)
}

type signalTextBufferModifiedChangedDetail struct {
	callback  TextBufferSignalModifiedChangedCallback
	handlerID C.gulong
}

var signalTextBufferModifiedChangedId int
var signalTextBufferModifiedChangedMap = make(map[int]signalTextBufferModifiedChangedDetail)
var signalTextBufferModifiedChangedLock sync.Mutex

// TextBufferSignalModifiedChangedCallback is a callback function for a 'modified-changed' signal emitted from a TextBuffer.
type TextBufferSignalModifiedChangedCallback func()

/*
ConnectModifiedChanged connects the callback to the 'modified-changed' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectModifiedChanged to remove it.
*/
func (recv *TextBuffer) ConnectModifiedChanged(callback TextBufferSignalModifiedChangedCallback) int {
	signalTextBufferModifiedChangedLock.Lock()
	defer signalTextBufferModifiedChangedLock.Unlock()

	signalTextBufferModifiedChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_modified_changed(instance, C.gpointer(uintptr(signalTextBufferModifiedChangedId)))

	detail := signalTextBufferModifiedChangedDetail{callback, handlerID}
	signalTextBufferModifiedChangedMap[signalTextBufferModifiedChangedId] = detail

	return signalTextBufferModifiedChangedId
}

/*
DisconnectModifiedChanged disconnects a callback from the 'modified-changed' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectModifiedChanged.
*/
func (recv *TextBuffer) DisconnectModifiedChanged(connectionID int) {
	signalTextBufferModifiedChangedLock.Lock()
	defer signalTextBufferModifiedChangedLock.Unlock()

	detail, exists := signalTextBufferModifiedChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferModifiedChangedMap, connectionID)
}

//export textbuffer_modifiedChangedHandler
func textbuffer_modifiedChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextBufferModifiedChangedMap[index].callback
	callback()
}

type signalTextBufferRemoveTagDetail struct {
	callback  TextBufferSignalRemoveTagCallback
	handlerID C.gulong
}

var signalTextBufferRemoveTagId int
var signalTextBufferRemoveTagMap = make(map[int]signalTextBufferRemoveTagDetail)
var signalTextBufferRemoveTagLock sync.Mutex

// TextBufferSignalRemoveTagCallback is a callback function for a 'remove-tag' signal emitted from a TextBuffer.
type TextBufferSignalRemoveTagCallback func(tag *TextTag, start *TextIter, end *TextIter)

/*
ConnectRemoveTag connects the callback to the 'remove-tag' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectRemoveTag to remove it.
*/
func (recv *TextBuffer) ConnectRemoveTag(callback TextBufferSignalRemoveTagCallback) int {
	signalTextBufferRemoveTagLock.Lock()
	defer signalTextBufferRemoveTagLock.Unlock()

	signalTextBufferRemoveTagId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_remove_tag(instance, C.gpointer(uintptr(signalTextBufferRemoveTagId)))

	detail := signalTextBufferRemoveTagDetail{callback, handlerID}
	signalTextBufferRemoveTagMap[signalTextBufferRemoveTagId] = detail

	return signalTextBufferRemoveTagId
}

/*
DisconnectRemoveTag disconnects a callback from the 'remove-tag' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectRemoveTag.
*/
func (recv *TextBuffer) DisconnectRemoveTag(connectionID int) {
	signalTextBufferRemoveTagLock.Lock()
	defer signalTextBufferRemoveTagLock.Unlock()

	detail, exists := signalTextBufferRemoveTagMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferRemoveTagMap, connectionID)
}

//export textbuffer_removeTagHandler
func textbuffer_removeTagHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferRemoveTagMap[index].callback
	callback(tag, start, end)
}

// Creates a new text buffer.
/*

C function : gtk_text_buffer_new
*/
func TextBufferNew(table *TextTagTable) *TextBuffer {
	c_table := (*C.GtkTextTagTable)(C.NULL)
	if table != nil {
		c_table = (*C.GtkTextTagTable)(table.ToC())
	}

	retC := C.gtk_text_buffer_new(c_table)
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds @clipboard to the list of clipboards in which the selection
// contents of @buffer are available. In most cases, @clipboard will be
// the #GtkClipboard of type %GDK_SELECTION_PRIMARY for a view of @buffer.
/*

C function : gtk_text_buffer_add_selection_clipboard
*/
func (recv *TextBuffer) AddSelectionClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_add_selection_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// Emits the apply-tag signal on @buffer. The default
// handler for the signal applies @tag to the given range.
// @start and @end do not have to be in order.
/*

C function : gtk_text_buffer_apply_tag
*/
func (recv *TextBuffer) ApplyTag(tag *TextTag, start *TextIter, end *TextIter) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_apply_tag((*C.GtkTextBuffer)(recv.native), c_tag, c_start, c_end)

	return
}

// Calls gtk_text_tag_table_lookup() on the buffers tag table to
// get a #GtkTextTag, then calls gtk_text_buffer_apply_tag().
/*

C function : gtk_text_buffer_apply_tag_by_name
*/
func (recv *TextBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_apply_tag_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_start, c_end)

	return
}

// Called to indicate that the buffer operations between here and a
// call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when creating
// an undo stack. #GtkTextBuffer maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with
// a call to gtk_text_buffer_end_user_action(), and emits the
// begin-user-action and end-user-action signals only for the
// outermost pair of calls. This allows you to build user actions
// from other user actions.
//
// The interactive buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end
// user action around the buffer operations they perform, so there's
// no need to add extra calls if you user action consists solely of a
// single call to one of those functions.
/*

C function : gtk_text_buffer_begin_user_action
*/
func (recv *TextBuffer) BeginUserAction() {
	C.gtk_text_buffer_begin_user_action((*C.GtkTextBuffer)(recv.native))

	return
}

// Copies the currently-selected text to a clipboard.
/*

C function : gtk_text_buffer_copy_clipboard
*/
func (recv *TextBuffer) CopyClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_copy_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// This is a convenience function which simply creates a child anchor
// with gtk_text_child_anchor_new() and inserts it into the buffer
// with gtk_text_buffer_insert_child_anchor(). The new anchor is
// owned by the buffer; no reference count is returned to
// the caller of gtk_text_buffer_create_child_anchor().
/*

C function : gtk_text_buffer_create_child_anchor
*/
func (recv *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_buffer_create_child_anchor((*C.GtkTextBuffer)(recv.native), c_iter)
	retGo := TextChildAnchorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a mark at position @where. If @mark_name is %NULL, the mark
// is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
// inserted at the marks current location, the mark will be moved to
// the left of the newly-inserted text. If the mark has right gravity
// (@left_gravity = %FALSE), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark
// with right gravity (when you type, the cursor stays on the right
// side of the text youre typing).
//
// The caller of this function does not own a
// reference to the returned #GtkTextMark, so you can ignore the
// return value if you like. Marks are owned by the buffer and go
// away when the buffer does.
//
// Emits the #GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
/*

C function : gtk_text_buffer_create_mark
*/
func (recv *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	c_mark_name := C.CString(markName)
	defer C.free(unsafe.Pointer(c_mark_name))

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	c_left_gravity :=
		boolToGboolean(leftGravity)

	retC := C.gtk_text_buffer_create_mark((*C.GtkTextBuffer)(recv.native), c_mark_name, c_where, c_left_gravity)
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_text_buffer_create_tag : unsupported parameter ... : varargs

// Copies the currently-selected text to a clipboard, then deletes
// said text if its editable.
/*

C function : gtk_text_buffer_cut_clipboard
*/
func (recv *TextBuffer) CutClipboard(clipboard *Clipboard, defaultEditable bool) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	C.gtk_text_buffer_cut_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard, c_default_editable)

	return
}

// Deletes text between @start and @end. The order of @start and @end
// is not actually relevant; gtk_text_buffer_delete() will reorder
// them. This function actually emits the delete-range signal, and
// the default handler of that signal deletes the text. Because the
// buffer is modified, all outstanding iterators become invalid after
// calling this function; however, the @start and @end will be
// re-initialized to point to the location where text was deleted.
/*

C function : gtk_text_buffer_delete
*/
func (recv *TextBuffer) Delete(start *TextIter, end *TextIter) {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_delete((*C.GtkTextBuffer)(recv.native), c_start, c_end)

	return
}

// Deletes all editable text in the given range.
// Calls gtk_text_buffer_delete() for each editable sub-range of
// [@start,@end). @start and @end are revalidated to point to
// the location of the last deleted range, or left untouched if
// no text was deleted.
/*

C function : gtk_text_buffer_delete_interactive
*/
func (recv *TextBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	c_start_iter := (*C.GtkTextIter)(C.NULL)
	if startIter != nil {
		c_start_iter = (*C.GtkTextIter)(startIter.ToC())
	}

	c_end_iter := (*C.GtkTextIter)(C.NULL)
	if endIter != nil {
		c_end_iter = (*C.GtkTextIter)(endIter.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_delete_interactive((*C.GtkTextBuffer)(recv.native), c_start_iter, c_end_iter, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Deletes @mark, so that its no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if
// you havent called g_object_ref() on the mark, it will be freed. Even
// if the mark isnt freed, most operations on @mark become
// invalid, until it gets added to a buffer again with
// gtk_text_buffer_add_mark(). Use gtk_text_mark_get_deleted() to
// find out if a mark has been removed from its buffer.
// The #GtkTextBuffer::mark-deleted signal will be emitted as notification after
// the mark is deleted.
/*

C function : gtk_text_buffer_delete_mark
*/
func (recv *TextBuffer) DeleteMark(mark *TextMark) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_buffer_delete_mark((*C.GtkTextBuffer)(recv.native), c_mark)

	return
}

// Deletes the mark named @name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
/*

C function : gtk_text_buffer_delete_mark_by_name
*/
func (recv *TextBuffer) DeleteMarkByName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_text_buffer_delete_mark_by_name((*C.GtkTextBuffer)(recv.native), c_name)

	return
}

// Deletes the range between the insert and selection_bound marks,
// that is, the currently-selected text. If @interactive is %TRUE,
// the editability of the selection will be considered (users cant delete
// uneditable text).
/*

C function : gtk_text_buffer_delete_selection
*/
func (recv *TextBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	c_interactive :=
		boolToGboolean(interactive)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_delete_selection((*C.GtkTextBuffer)(recv.native), c_interactive, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Should be paired with a call to gtk_text_buffer_begin_user_action().
// See that function for a full explanation.
/*

C function : gtk_text_buffer_end_user_action
*/
func (recv *TextBuffer) EndUserAction() {
	C.gtk_text_buffer_end_user_action((*C.GtkTextBuffer)(recv.native))

	return
}

// Retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
/*

C function : gtk_text_buffer_get_bounds
*/
func (recv *TextBuffer) GetBounds() (*TextIter, *TextIter) {
	var c_start C.GtkTextIter

	var c_end C.GtkTextIter

	C.gtk_text_buffer_get_bounds((*C.GtkTextBuffer)(recv.native), &c_start, &c_end)

	start := TextIterNewFromC(unsafe.Pointer(&c_start))

	end := TextIterNewFromC(unsafe.Pointer(&c_end))

	return start, end
}

// Gets the number of characters in the buffer; note that characters
// and bytes are not the same, you cant e.g. expect the contents of
// the buffer in string form to be this many bytes long. The character
// count is cached, so this function is very fast.
/*

C function : gtk_text_buffer_get_char_count
*/
func (recv *TextBuffer) GetCharCount() int32 {
	retC := C.gtk_text_buffer_get_char_count((*C.GtkTextBuffer)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Initializes @iter with the end iterator, one past the last valid
// character in the text buffer. If dereferenced with
// gtk_text_iter_get_char(), the end iterator has a character value of 0.
// The entire buffer lies in the range from the first position in
// the buffer (call gtk_text_buffer_get_start_iter() to get
// character position 0) to the end iterator.
/*

C function : gtk_text_buffer_get_end_iter
*/
func (recv *TextBuffer) GetEndIter() *TextIter {
	var c_iter C.GtkTextIter

	C.gtk_text_buffer_get_end_iter((*C.GtkTextBuffer)(recv.native), &c_iter)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark
// named insert, but very slightly more efficient, and involves less
// typing.
/*

C function : gtk_text_buffer_get_insert
*/
func (recv *TextBuffer) GetInsert() *TextMark {
	retC := C.gtk_text_buffer_get_insert((*C.GtkTextBuffer)(recv.native))
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Obtains the location of @anchor within @buffer.
/*

C function : gtk_text_buffer_get_iter_at_child_anchor
*/
func (recv *TextBuffer) GetIterAtChildAnchor(anchor *TextChildAnchor) *TextIter {
	var c_iter C.GtkTextIter

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_buffer_get_iter_at_child_anchor((*C.GtkTextBuffer)(recv.native), &c_iter, c_anchor)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Initializes @iter to the start of the given line. If @line_number is greater
// than the number of lines in the @buffer, the end iterator is returned.
/*

C function : gtk_text_buffer_get_iter_at_line
*/
func (recv *TextBuffer) GetIterAtLine(lineNumber int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	C.gtk_text_buffer_get_iter_at_line((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Obtains an iterator pointing to @byte_index within the given line.
// @byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of lines
// in the @buffer, the end iterator is returned. And if @byte_index is off the
// end of the line, the iterator at the end of the line is returned.
/*

C function : gtk_text_buffer_get_iter_at_line_index
*/
func (recv *TextBuffer) GetIterAtLineIndex(lineNumber int32, byteIndex int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	c_byte_index := (C.gint)(byteIndex)

	C.gtk_text_buffer_get_iter_at_line_index((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number, c_byte_index)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Obtains an iterator pointing to @char_offset within the given line. Note
// characters, not bytes; UTF-8 may encode one character as multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of lines
// in the @buffer, the end iterator is returned. And if @char_offset is off the
// end of the line, the iterator at the end of the line is returned.
/*

C function : gtk_text_buffer_get_iter_at_line_offset
*/
func (recv *TextBuffer) GetIterAtLineOffset(lineNumber int32, charOffset int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	c_char_offset := (C.gint)(charOffset)

	C.gtk_text_buffer_get_iter_at_line_offset((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number, c_char_offset)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Initializes @iter with the current position of @mark.
/*

C function : gtk_text_buffer_get_iter_at_mark
*/
func (recv *TextBuffer) GetIterAtMark(mark *TextMark) *TextIter {
	var c_iter C.GtkTextIter

	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_buffer_get_iter_at_mark((*C.GtkTextBuffer)(recv.native), &c_iter, c_mark)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Initializes @iter to a position @char_offset chars from the start
// of the entire buffer. If @char_offset is -1 or greater than the number
// of characters in the buffer, @iter is initialized to the end iterator,
// the iterator one past the last valid character in the buffer.
/*

C function : gtk_text_buffer_get_iter_at_offset
*/
func (recv *TextBuffer) GetIterAtOffset(charOffset int32) *TextIter {
	var c_iter C.GtkTextIter

	c_char_offset := (C.gint)(charOffset)

	C.gtk_text_buffer_get_iter_at_offset((*C.GtkTextBuffer)(recv.native), &c_iter, c_char_offset)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Obtains the number of lines in the buffer. This value is cached, so
// the function is very fast.
/*

C function : gtk_text_buffer_get_line_count
*/
func (recv *TextBuffer) GetLineCount() int32 {
	retC := C.gtk_text_buffer_get_line_count((*C.GtkTextBuffer)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the mark named @name in buffer @buffer, or %NULL if no such
// mark exists in the buffer.
/*

C function : gtk_text_buffer_get_mark
*/
func (recv *TextBuffer) GetMark(name string) *TextMark {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_buffer_get_mark((*C.GtkTextBuffer)(recv.native), c_name)
	var retGo (*TextMark)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TextMarkNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Indicates whether the buffer has been modified since the last call
// to gtk_text_buffer_set_modified() set the modification flag to
// %FALSE. Used for example to enable a save function in a text
// editor.
/*

C function : gtk_text_buffer_get_modified
*/
func (recv *TextBuffer) GetModified() bool {
	retC := C.gtk_text_buffer_get_modified((*C.GtkTextBuffer)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the mark that represents the selection bound.  Equivalent
// to calling gtk_text_buffer_get_mark() to get the mark named
// selection_bound, but very slightly more efficient, and involves
// less typing.
//
// The currently-selected text in @buffer is the region between the
// selection_bound and insert marks. If selection_bound and
// insert are in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function
// for handling the selection, if you just want to know whether theres a
// selection and what its bounds are.
/*

C function : gtk_text_buffer_get_selection_bound
*/
func (recv *TextBuffer) GetSelectionBound() *TextMark {
	retC := C.gtk_text_buffer_get_selection_bound((*C.GtkTextBuffer)(recv.native))
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if some text is selected; places the bounds
// of the selection in @start and @end (if the selection has length 0,
// then @start and @end are filled in with the same value).
// @start and @end will be in ascending order. If @start and @end are
// NULL, then they are not filled in, but the return value still indicates
// whether text is selected.
/*

C function : gtk_text_buffer_get_selection_bounds
*/
func (recv *TextBuffer) GetSelectionBounds() (bool, *TextIter, *TextIter) {
	var c_start C.GtkTextIter

	var c_end C.GtkTextIter

	retC := C.gtk_text_buffer_get_selection_bounds((*C.GtkTextBuffer)(recv.native), &c_start, &c_end)
	retGo := retC == C.TRUE

	start := TextIterNewFromC(unsafe.Pointer(&c_start))

	end := TextIterNewFromC(unsafe.Pointer(&c_end))

	return retGo, start, end
}

// Returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is %FALSE. The returned string includes a
// 0xFFFC character whenever the buffer contains
// embedded images, so byte and character indexes into
// the returned string do correspond to byte
// and character indexes into the buffer. Contrast with
// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal
// text as well, so it is not a reliable indicator that a pixbuf or
// widget is in the buffer.
/*

C function : gtk_text_buffer_get_slice
*/
func (recv *TextBuffer) GetSlice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_include_hidden_chars :=
		boolToGboolean(includeHiddenChars)

	retC := C.gtk_text_buffer_get_slice((*C.GtkTextBuffer)(recv.native), c_start, c_end, c_include_hidden_chars)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Initialized @iter with the first position in the text buffer. This
// is the same as using gtk_text_buffer_get_iter_at_offset() to get
// the iter at character offset 0.
/*

C function : gtk_text_buffer_get_start_iter
*/
func (recv *TextBuffer) GetStartIter() *TextIter {
	var c_iter C.GtkTextIter

	C.gtk_text_buffer_get_start_iter((*C.GtkTextBuffer)(recv.native), &c_iter)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Get the #GtkTextTagTable associated with this buffer.
/*

C function : gtk_text_buffer_get_tag_table
*/
func (recv *TextBuffer) GetTagTable() *TextTagTable {
	retC := C.gtk_text_buffer_get_tag_table((*C.GtkTextBuffer)(recv.native))
	retGo := TextTagTableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is %FALSE. Does not include characters
// representing embedded images, so byte and character indexes into
// the returned string do not correspond to byte
// and character indexes into the buffer. Contrast with
// gtk_text_buffer_get_slice().
/*

C function : gtk_text_buffer_get_text
*/
func (recv *TextBuffer) GetText(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_include_hidden_chars :=
		boolToGboolean(includeHiddenChars)

	retC := C.gtk_text_buffer_get_text((*C.GtkTextBuffer)(recv.native), c_start, c_end, c_include_hidden_chars)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Inserts @len bytes of @text at position @iter.  If @len is -1,
// @text must be nul-terminated and will be inserted in its
// entirety. Emits the insert-text signal; insertion actually occurs
// in the default handler for the signal. @iter is invalidated when
// insertion occurs (because the buffer contents change), but the
// default signal handler revalidates it to point to the end of the
// inserted text.
/*

C function : gtk_text_buffer_insert
*/
func (recv *TextBuffer) Insert(iter *TextIter, text string, len int32) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_insert((*C.GtkTextBuffer)(recv.native), c_iter, c_text, c_len)

	return
}

// Simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
/*

C function : gtk_text_buffer_insert_at_cursor
*/
func (recv *TextBuffer) InsertAtCursor(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_insert_at_cursor((*C.GtkTextBuffer)(recv.native), c_text, c_len)

	return
}

// Inserts a child widget anchor into the text buffer at @iter. The
// anchor will be counted as one character in character counts, and
// when obtaining the buffer contents as a string, will be represented
// by the Unicode object replacement character 0xFFFC. Note that the
// slice variants for obtaining portions of the buffer as a string
// include this character for child anchors, but the text variants do
// not. E.g. see gtk_text_buffer_get_slice() and
// gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient
// alternative to this function. The buffer will add a reference to
// the anchor, so you can unref it after insertion.
/*

C function : gtk_text_buffer_insert_child_anchor
*/
func (recv *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_buffer_insert_child_anchor((*C.GtkTextBuffer)(recv.native), c_iter, c_anchor)

	return
}

// Like gtk_text_buffer_insert(), but the insertion will not occur if
// @iter is at a non-editable location in the buffer. Usually you
// want to prevent insertions at ineditable locations if the insertion
// results from a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't
// have a tag affecting editability applied to it. Typically the
// result of gtk_text_view_get_editable() is appropriate here.
/*

C function : gtk_text_buffer_insert_interactive
*/
func (recv *TextBuffer) InsertInteractive(iter *TextIter, text string, len int32, defaultEditable bool) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_interactive((*C.GtkTextBuffer)(recv.native), c_iter, c_text, c_len, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Calls gtk_text_buffer_insert_interactive() at the cursor
// position.
//
// @default_editable indicates the editability of text that doesn't
// have a tag affecting editability applied to it. Typically the
// result of gtk_text_view_get_editable() is appropriate here.
/*

C function : gtk_text_buffer_insert_interactive_at_cursor
*/
func (recv *TextBuffer) InsertInteractiveAtCursor(text string, len int32, defaultEditable bool) bool {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_interactive_at_cursor((*C.GtkTextBuffer)(recv.native), c_text, c_len, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Inserts an image into the text buffer at @iter. The image will be
// counted as one character in character counts, and when obtaining
// the buffer contents as a string, will be represented by the Unicode
// object replacement character 0xFFFC. Note that the slice
// variants for obtaining portions of the buffer as a string include
// this character for pixbufs, but the text variants do
// not. e.g. see gtk_text_buffer_get_slice() and
// gtk_text_buffer_get_text().
/*

C function : gtk_text_buffer_insert_pixbuf
*/
func (recv *TextBuffer) InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_text_buffer_insert_pixbuf((*C.GtkTextBuffer)(recv.native), c_iter, c_pixbuf)

	return
}

// Copies text, tags, and pixbufs between @start and @end (the order
// of @start and @end doesnt matter) and inserts the copy at @iter.
// Used instead of simply getting/inserting text because it preserves
// images and tags. If @start and @end are in a different buffer from
// @buffer, the two buffers must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals,
// so expect those.
/*

C function : gtk_text_buffer_insert_range
*/
func (recv *TextBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_insert_range((*C.GtkTextBuffer)(recv.native), c_iter, c_start, c_end)

	return
}

// Same as gtk_text_buffer_insert_range(), but does nothing if the
// insertion point isnt editable. The @default_editable parameter
// indicates whether the text is editable at @iter if no tags
// enclosing @iter affect editability. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
/*

C function : gtk_text_buffer_insert_range_interactive
*/
func (recv *TextBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_range_interactive((*C.GtkTextBuffer)(recv.native), c_iter, c_start, c_end, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_text_buffer_insert_with_tags : unsupported parameter ... : varargs

// Unsupported : gtk_text_buffer_insert_with_tags_by_name : unsupported parameter ... : varargs

// Moves @mark to the new location @where. Emits the #GtkTextBuffer::mark-set
// signal as notification of the move.
/*

C function : gtk_text_buffer_move_mark
*/
func (recv *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_move_mark((*C.GtkTextBuffer)(recv.native), c_mark, c_where)

	return
}

// Moves the mark named @name (which must exist) to location @where.
// See gtk_text_buffer_move_mark() for details.
/*

C function : gtk_text_buffer_move_mark_by_name
*/
func (recv *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_move_mark_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_where)

	return
}

// Pastes the contents of a clipboard. If @override_location is %NULL, the
// pasted text will be inserted at the cursor position, or the buffer selection
// will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, well ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
/*

C function : gtk_text_buffer_paste_clipboard
*/
func (recv *TextBuffer) PasteClipboard(clipboard *Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	c_override_location := (*C.GtkTextIter)(C.NULL)
	if overrideLocation != nil {
		c_override_location = (*C.GtkTextIter)(overrideLocation.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	C.gtk_text_buffer_paste_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard, c_override_location, c_default_editable)

	return
}

// This function moves the insert and selection_bound marks
// simultaneously.  If you move them to the same place in two steps
// with gtk_text_buffer_move_mark(), you will temporarily select a
// region in between their old and new locations, which can be pretty
// inefficient since the temporarily-selected region will force stuff
// to be recalculated. This function moves them as a unit, which can
// be optimized.
/*

C function : gtk_text_buffer_place_cursor
*/
func (recv *TextBuffer) PlaceCursor(where *TextIter) {
	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_place_cursor((*C.GtkTextBuffer)(recv.native), c_where)

	return
}

// Removes all tags in the range between @start and @end.  Be careful
// with this function; it could remove tags added in code unrelated to
// the code youre currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections
// that add tags.
/*

C function : gtk_text_buffer_remove_all_tags
*/
func (recv *TextBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_all_tags((*C.GtkTextBuffer)(recv.native), c_start, c_end)

	return
}

// Removes a #GtkClipboard added with
// gtk_text_buffer_add_selection_clipboard().
/*

C function : gtk_text_buffer_remove_selection_clipboard
*/
func (recv *TextBuffer) RemoveSelectionClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_remove_selection_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// Emits the remove-tag signal. The default handler for the signal
// removes all occurrences of @tag from the given range. @start and
// @end dont have to be in order.
/*

C function : gtk_text_buffer_remove_tag
*/
func (recv *TextBuffer) RemoveTag(tag *TextTag, start *TextIter, end *TextIter) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_tag((*C.GtkTextBuffer)(recv.native), c_tag, c_start, c_end)

	return
}

// Calls gtk_text_tag_table_lookup() on the buffers tag table to
// get a #GtkTextTag, then calls gtk_text_buffer_remove_tag().
/*

C function : gtk_text_buffer_remove_tag_by_name
*/
func (recv *TextBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_tag_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_start, c_end)

	return
}

// Used to keep track of whether the buffer has been modified since the
// last time it was saved. Whenever the buffer is saved to disk, call
// gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is modified,
// it will automatically toggled on the modified bit again. When the modified
// bit flips, the buffer emits the #GtkTextBuffer::modified-changed signal.
/*

C function : gtk_text_buffer_set_modified
*/
func (recv *TextBuffer) SetModified(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_buffer_set_modified((*C.GtkTextBuffer)(recv.native), c_setting)

	return
}

// Deletes current contents of @buffer, and inserts @text instead. If
// @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
/*

C function : gtk_text_buffer_set_text
*/
func (recv *TextBuffer) SetText(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_set_text((*C.GtkTextBuffer)(recv.native), c_text, c_len)

	return
}

/*

C record/class : GtkTextCellAccessible
*/
type TextCellAccessible struct {
	native *C.GtkTextCellAccessible
	// parent : record
	// priv : record
}

func TextCellAccessibleNewFromC(u unsafe.Pointer) *TextCellAccessible {
	c := (*C.GtkTextCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TextCellAccessible{native: c}

	return g
}

func (recv *TextCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *TextCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *TextCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TextCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TextCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to TextCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextCellAccessible.
func CastToTextCellAccessible(object *gobject.Object) *TextCellAccessible {
	return TextCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// A #GtkTextChildAnchor is a spot in the buffer where child widgets can
// be anchored (inserted inline, as if they were characters). The anchor
// can have multiple widgets anchored, to allow for multiple views.
/*

C record/class : GtkTextChildAnchor
*/
type TextChildAnchor struct {
	native *C.GtkTextChildAnchor
	// parent_instance : record
	// Private : segment
}

func TextChildAnchorNewFromC(u unsafe.Pointer) *TextChildAnchor {
	c := (*C.GtkTextChildAnchor)(u)
	if c == nil {
		return nil
	}

	g := &TextChildAnchor{native: c}

	return g
}

func (recv *TextChildAnchor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextChildAnchor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextChildAnchor.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextChildAnchor.
func CastToTextChildAnchor(object *gobject.Object) *TextChildAnchor {
	return TextChildAnchorNewFromC(object.ToC())
}

// Creates a new #GtkTextChildAnchor. Usually you would then insert
// it into a #GtkTextBuffer with gtk_text_buffer_insert_child_anchor().
// To perform the creation and insertion in one step, use the
// convenience function gtk_text_buffer_create_child_anchor().
/*

C function : gtk_text_child_anchor_new
*/
func TextChildAnchorNew() *TextChildAnchor {
	retC := C.gtk_text_child_anchor_new()
	retGo := TextChildAnchorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Determines whether a child anchor has been deleted from
// the buffer. Keep in mind that the child anchor will be
// unreferenced when removed from the buffer, so you need to
// hold your own reference (with g_object_ref()) if you plan
// to use this function  otherwise all deleted child anchors
// will also be finalized.
/*

C function : gtk_text_child_anchor_get_deleted
*/
func (recv *TextChildAnchor) GetDeleted() bool {
	retC := C.gtk_text_child_anchor_get_deleted((*C.GtkTextChildAnchor)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets a list of all widgets anchored at this child anchor.
// The returned list should be freed with g_list_free().
/*

C function : gtk_text_child_anchor_get_widgets
*/
func (recv *TextChildAnchor) GetWidgets() *glib.List {
	retC := C.gtk_text_child_anchor_get_widgets((*C.GtkTextChildAnchor)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// You may wish to begin by reading the
// [text widget conceptual overview][TextWidget]
// which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// A #GtkTextMark is like a bookmark in a text buffer; it preserves a position in
// the text. You can convert the mark to an iterator using
// gtk_text_buffer_get_iter_at_mark(). Unlike iterators, marks remain valid across
// buffer mutations, because their behavior is defined when text is inserted or
// deleted. When text containing a mark is deleted, the mark remains in the
// position originally occupied by the deleted text. When text is inserted at a
// mark, a mark with left gravity will be moved to the
// beginning of the newly-inserted text, and a mark with right
// gravity will be moved to the end.
//
// Note that left and right here refer to logical direction (left
// is the toward the start of the buffer); in some languages such as
// Hebrew the logically-leftmost text is not actually on the left when
// displayed.
//
// Marks are reference counted, but the reference count only controls the validity
// of the memory; marks can be deleted from the buffer at any time with
// gtk_text_buffer_delete_mark(). Once deleted from the buffer, a mark is
// essentially useless.
//
// Marks optionally have names; these can be convenient to avoid passing the
// #GtkTextMark object around.
//
// Marks are typically created using the gtk_text_buffer_create_mark() function.
/*

C record/class : GtkTextMark
*/
type TextMark struct {
	native *C.GtkTextMark
	// parent_instance : record
	// Private : segment
}

func TextMarkNewFromC(u unsafe.Pointer) *TextMark {
	c := (*C.GtkTextMark)(u)
	if c == nil {
		return nil
	}

	g := &TextMark{native: c}

	return g
}

func (recv *TextMark) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextMark) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextMark.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextMark.
func CastToTextMark(object *gobject.Object) *TextMark {
	return TextMarkNewFromC(object.ToC())
}

// Gets the buffer this mark is located inside,
// or %NULL if the mark is deleted.
/*

C function : gtk_text_mark_get_buffer
*/
func (recv *TextMark) GetBuffer() *TextBuffer {
	retC := C.gtk_text_mark_get_buffer((*C.GtkTextMark)(recv.native))
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if the mark has been removed from its buffer
// with gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark()
// for a way to add it to a buffer again.
/*

C function : gtk_text_mark_get_deleted
*/
func (recv *TextMark) GetDeleted() bool {
	retC := C.gtk_text_mark_get_deleted((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Determines whether the mark has left gravity.
/*

C function : gtk_text_mark_get_left_gravity
*/
func (recv *TextMark) GetLeftGravity() bool {
	retC := C.gtk_text_mark_get_left_gravity((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the mark name; returns NULL for anonymous marks.
/*

C function : gtk_text_mark_get_name
*/
func (recv *TextMark) GetName() string {
	retC := C.gtk_text_mark_get_name((*C.GtkTextMark)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Returns %TRUE if the mark is visible (i.e. a cursor is displayed
// for it).
/*

C function : gtk_text_mark_get_visible
*/
func (recv *TextMark) GetVisible() bool {
	retC := C.gtk_text_mark_get_visible((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the visibility of @mark; the insertion point is normally
// visible, i.e. you can see it as a vertical bar. Also, the text
// widget uses a visible mark to indicate where a drop will occur when
// dragging-and-dropping text. Most other marks are not visible.
// Marks are not visible by default.
/*

C function : gtk_text_mark_set_visible
*/
func (recv *TextMark) SetVisible(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_mark_set_visible((*C.GtkTextMark)(recv.native), c_setting)

	return
}

// You may wish to begin by reading the
// [text widget conceptual overview][TextWidget]
// which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// Tags should be in the #GtkTextTagTable for a given #GtkTextBuffer
// before using them with that buffer.
//
// gtk_text_buffer_create_tag() is the best way to create tags.
// See gtk3-demo for numerous examples.
//
// For each property of #GtkTextTag, there is a set property, e.g.
// font-set corresponds to font. These set properties reflect
// whether a property has been set or not.
// They are maintained by GTK+ and you should not set them independently.
/*

C record/class : GtkTextTag
*/
type TextTag struct {
	native *C.GtkTextTag
	// parent_instance : record
	// priv : record
}

func TextTagNewFromC(u unsafe.Pointer) *TextTag {
	c := (*C.GtkTextTag)(u)
	if c == nil {
		return nil
	}

	g := &TextTag{native: c}

	return g
}

func (recv *TextTag) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextTag) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextTag.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextTag.
func CastToTextTag(object *gobject.Object) *TextTag {
	return TextTagNewFromC(object.ToC())
}

// Unsupported signal 'event' for TextTag : unsupported parameter event : no type generator for Gdk.Event,

// Creates a #GtkTextTag. Configure the tag using object arguments,
// i.e. using g_object_set().
/*

C function : gtk_text_tag_new
*/
func TextTagNew(name string) *TextTag {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_tag_new(c_name)
	retGo := TextTagNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_text_tag_event : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Get the tag priority.
/*

C function : gtk_text_tag_get_priority
*/
func (recv *TextTag) GetPriority() int32 {
	retC := C.gtk_text_tag_get_priority((*C.GtkTextTag)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Sets the priority of a #GtkTextTag. Valid priorities
// start at 0 and go to one less than gtk_text_tag_table_get_size().
// Each tag in a table has a unique priority; setting the priority
// of one tag shifts the priorities of all the other tags in the
// table to maintain a unique priority for each tag. Higher priority
// tags win if two tags both set the same text attribute. When adding
// a tag to a tag table, it will be assigned the highest priority in
// the table by default; so normally the precedence of a set of tags
// is the order in which they were added to the table, or created with
// gtk_text_buffer_create_tag(), which adds the tag to the buffers table
// automatically.
/*

C function : gtk_text_tag_set_priority
*/
func (recv *TextTag) SetPriority(priority int32) {
	c_priority := (C.gint)(priority)

	C.gtk_text_tag_set_priority((*C.GtkTextTag)(recv.native), c_priority)

	return
}

// You may wish to begin by reading the
// [text widget conceptual overview][TextWidget]
// which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// # GtkTextTagTables as GtkBuildable
//
// The GtkTextTagTable implementation of the GtkBuildable interface
// supports adding tags by specifying tag as the type attribute
// of a <child> element.
//
// An example of a UI definition fragment specifying tags:
// |[
// <object class="GtkTextTagTable">
// <child type="tag">
// <object class="GtkTextTag"/>
// </child>
// </object>
// ]|
/*

C record/class : GtkTextTagTable
*/
type TextTagTable struct {
	native *C.GtkTextTagTable
	// parent_instance : record
	// priv : record
}

func TextTagTableNewFromC(u unsafe.Pointer) *TextTagTable {
	c := (*C.GtkTextTagTable)(u)
	if c == nil {
		return nil
	}

	g := &TextTagTable{native: c}

	return g
}

func (recv *TextTagTable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextTagTable) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextTagTable.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextTagTable.
func CastToTextTagTable(object *gobject.Object) *TextTagTable {
	return TextTagTableNewFromC(object.ToC())
}

type signalTextTagTableTagAddedDetail struct {
	callback  TextTagTableSignalTagAddedCallback
	handlerID C.gulong
}

var signalTextTagTableTagAddedId int
var signalTextTagTableTagAddedMap = make(map[int]signalTextTagTableTagAddedDetail)
var signalTextTagTableTagAddedLock sync.Mutex

// TextTagTableSignalTagAddedCallback is a callback function for a 'tag-added' signal emitted from a TextTagTable.
type TextTagTableSignalTagAddedCallback func(tag *TextTag)

/*
ConnectTagAdded connects the callback to the 'tag-added' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagAdded to remove it.
*/
func (recv *TextTagTable) ConnectTagAdded(callback TextTagTableSignalTagAddedCallback) int {
	signalTextTagTableTagAddedLock.Lock()
	defer signalTextTagTableTagAddedLock.Unlock()

	signalTextTagTableTagAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_added(instance, C.gpointer(uintptr(signalTextTagTableTagAddedId)))

	detail := signalTextTagTableTagAddedDetail{callback, handlerID}
	signalTextTagTableTagAddedMap[signalTextTagTableTagAddedId] = detail

	return signalTextTagTableTagAddedId
}

/*
DisconnectTagAdded disconnects a callback from the 'tag-added' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagAdded.
*/
func (recv *TextTagTable) DisconnectTagAdded(connectionID int) {
	signalTextTagTableTagAddedLock.Lock()
	defer signalTextTagTableTagAddedLock.Unlock()

	detail, exists := signalTextTagTableTagAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagAddedMap, connectionID)
}

//export texttagtable_tagAddedHandler
func texttagtable_tagAddedHandler(_ *C.GObject, c_tag *C.GtkTextTag, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	index := int(uintptr(data))
	callback := signalTextTagTableTagAddedMap[index].callback
	callback(tag)
}

type signalTextTagTableTagChangedDetail struct {
	callback  TextTagTableSignalTagChangedCallback
	handlerID C.gulong
}

var signalTextTagTableTagChangedId int
var signalTextTagTableTagChangedMap = make(map[int]signalTextTagTableTagChangedDetail)
var signalTextTagTableTagChangedLock sync.Mutex

// TextTagTableSignalTagChangedCallback is a callback function for a 'tag-changed' signal emitted from a TextTagTable.
type TextTagTableSignalTagChangedCallback func(tag *TextTag, sizeChanged bool)

/*
ConnectTagChanged connects the callback to the 'tag-changed' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagChanged to remove it.
*/
func (recv *TextTagTable) ConnectTagChanged(callback TextTagTableSignalTagChangedCallback) int {
	signalTextTagTableTagChangedLock.Lock()
	defer signalTextTagTableTagChangedLock.Unlock()

	signalTextTagTableTagChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_changed(instance, C.gpointer(uintptr(signalTextTagTableTagChangedId)))

	detail := signalTextTagTableTagChangedDetail{callback, handlerID}
	signalTextTagTableTagChangedMap[signalTextTagTableTagChangedId] = detail

	return signalTextTagTableTagChangedId
}

/*
DisconnectTagChanged disconnects a callback from the 'tag-changed' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagChanged.
*/
func (recv *TextTagTable) DisconnectTagChanged(connectionID int) {
	signalTextTagTableTagChangedLock.Lock()
	defer signalTextTagTableTagChangedLock.Unlock()

	detail, exists := signalTextTagTableTagChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagChangedMap, connectionID)
}

//export texttagtable_tagChangedHandler
func texttagtable_tagChangedHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_size_changed C.gboolean, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	sizeChanged := c_size_changed == C.TRUE

	index := int(uintptr(data))
	callback := signalTextTagTableTagChangedMap[index].callback
	callback(tag, sizeChanged)
}

type signalTextTagTableTagRemovedDetail struct {
	callback  TextTagTableSignalTagRemovedCallback
	handlerID C.gulong
}

var signalTextTagTableTagRemovedId int
var signalTextTagTableTagRemovedMap = make(map[int]signalTextTagTableTagRemovedDetail)
var signalTextTagTableTagRemovedLock sync.Mutex

// TextTagTableSignalTagRemovedCallback is a callback function for a 'tag-removed' signal emitted from a TextTagTable.
type TextTagTableSignalTagRemovedCallback func(tag *TextTag)

/*
ConnectTagRemoved connects the callback to the 'tag-removed' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagRemoved to remove it.
*/
func (recv *TextTagTable) ConnectTagRemoved(callback TextTagTableSignalTagRemovedCallback) int {
	signalTextTagTableTagRemovedLock.Lock()
	defer signalTextTagTableTagRemovedLock.Unlock()

	signalTextTagTableTagRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_removed(instance, C.gpointer(uintptr(signalTextTagTableTagRemovedId)))

	detail := signalTextTagTableTagRemovedDetail{callback, handlerID}
	signalTextTagTableTagRemovedMap[signalTextTagTableTagRemovedId] = detail

	return signalTextTagTableTagRemovedId
}

/*
DisconnectTagRemoved disconnects a callback from the 'tag-removed' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagRemoved.
*/
func (recv *TextTagTable) DisconnectTagRemoved(connectionID int) {
	signalTextTagTableTagRemovedLock.Lock()
	defer signalTextTagTableTagRemovedLock.Unlock()

	detail, exists := signalTextTagTableTagRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagRemovedMap, connectionID)
}

//export texttagtable_tagRemovedHandler
func texttagtable_tagRemovedHandler(_ *C.GObject, c_tag *C.GtkTextTag, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	index := int(uintptr(data))
	callback := signalTextTagTableTagRemovedMap[index].callback
	callback(tag)
}

// Creates a new #GtkTextTagTable. The table contains no tags by
// default.
/*

C function : gtk_text_tag_table_new
*/
func TextTagTableNew() *TextTagTable {
	retC := C.gtk_text_tag_table_new()
	retGo := TextTagTableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Add a tag to the table. The tag is assigned the highest priority
// in the table.
//
// @tag must not be in a tag table already, and may not have
// the same name as an already-added tag.
/*

C function : gtk_text_tag_table_add
*/
func (recv *TextTagTable) Add(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_tag_table_add((*C.GtkTextTagTable)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_text_tag_table_foreach : unsupported parameter func : no type generator for TextTagTableForeach (GtkTextTagTableForeach) for param func

// Returns the size of the table (number of tags)
/*

C function : gtk_text_tag_table_get_size
*/
func (recv *TextTagTable) GetSize() int32 {
	retC := C.gtk_text_tag_table_get_size((*C.GtkTextTagTable)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Look up a named tag.
/*

C function : gtk_text_tag_table_lookup
*/
func (recv *TextTagTable) Lookup(name string) *TextTag {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_tag_table_lookup((*C.GtkTextTagTable)(recv.native), c_name)
	var retGo (*TextTag)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TextTagNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Remove a tag from the table. If a #GtkTextBuffer has @table as its tag table,
// the tag is removed from the buffer. The tables reference to the tag is
// removed, so the tag will end up destroyed if you dont have a reference to
// it.
/*

C function : gtk_text_tag_table_remove
*/
func (recv *TextTagTable) Remove(tag *TextTag) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	C.gtk_text_tag_table_remove((*C.GtkTextTagTable)(recv.native), c_tag)

	return
}

// Buildable returns the Buildable interface implemented by TextTagTable
func (recv *TextTagTable) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// You may wish to begin by reading the
// [text widget conceptual overview][TextWidget]
// which gives an overview of all the objects and data
// types related to the text widget and how they work together.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// textview.view
//  border.top
//  border.left
//  text
//     [selection]
//  border.right
//  border.bottom
//  [window.popup]
// ]|
//
// GtkTextView has a main css node with name textview and style class .view,
// and subnodes for each of the border windows, and the main text area,
// with names border and text, respectively. The border nodes each get
// one of the style classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode
// of the main node.
/*

C record/class : GtkTextView
*/
type TextView struct {
	native *C.GtkTextView
	// parent_instance : record
	// Private : priv
}

func TextViewNewFromC(u unsafe.Pointer) *TextView {
	c := (*C.GtkTextView)(u)
	if c == nil {
		return nil
	}

	g := &TextView{native: c}

	return g
}

func (recv *TextView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *TextView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *TextView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TextView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TextView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to TextView.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextView.
func CastToTextView(object *gobject.Object) *TextView {
	return TextViewNewFromC(object.ToC())
}

type signalTextViewBackspaceDetail struct {
	callback  TextViewSignalBackspaceCallback
	handlerID C.gulong
}

var signalTextViewBackspaceId int
var signalTextViewBackspaceMap = make(map[int]signalTextViewBackspaceDetail)
var signalTextViewBackspaceLock sync.Mutex

// TextViewSignalBackspaceCallback is a callback function for a 'backspace' signal emitted from a TextView.
type TextViewSignalBackspaceCallback func()

/*
ConnectBackspace connects the callback to the 'backspace' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectBackspace to remove it.
*/
func (recv *TextView) ConnectBackspace(callback TextViewSignalBackspaceCallback) int {
	signalTextViewBackspaceLock.Lock()
	defer signalTextViewBackspaceLock.Unlock()

	signalTextViewBackspaceId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_backspace(instance, C.gpointer(uintptr(signalTextViewBackspaceId)))

	detail := signalTextViewBackspaceDetail{callback, handlerID}
	signalTextViewBackspaceMap[signalTextViewBackspaceId] = detail

	return signalTextViewBackspaceId
}

/*
DisconnectBackspace disconnects a callback from the 'backspace' signal for the TextView.

The connectionID should be a value returned from a call to ConnectBackspace.
*/
func (recv *TextView) DisconnectBackspace(connectionID int) {
	signalTextViewBackspaceLock.Lock()
	defer signalTextViewBackspaceLock.Unlock()

	detail, exists := signalTextViewBackspaceMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewBackspaceMap, connectionID)
}

//export textview_backspaceHandler
func textview_backspaceHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewBackspaceMap[index].callback
	callback()
}

type signalTextViewCopyClipboardDetail struct {
	callback  TextViewSignalCopyClipboardCallback
	handlerID C.gulong
}

var signalTextViewCopyClipboardId int
var signalTextViewCopyClipboardMap = make(map[int]signalTextViewCopyClipboardDetail)
var signalTextViewCopyClipboardLock sync.Mutex

// TextViewSignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a TextView.
type TextViewSignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *TextView) ConnectCopyClipboard(callback TextViewSignalCopyClipboardCallback) int {
	signalTextViewCopyClipboardLock.Lock()
	defer signalTextViewCopyClipboardLock.Unlock()

	signalTextViewCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalTextViewCopyClipboardId)))

	detail := signalTextViewCopyClipboardDetail{callback, handlerID}
	signalTextViewCopyClipboardMap[signalTextViewCopyClipboardId] = detail

	return signalTextViewCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *TextView) DisconnectCopyClipboard(connectionID int) {
	signalTextViewCopyClipboardLock.Lock()
	defer signalTextViewCopyClipboardLock.Unlock()

	detail, exists := signalTextViewCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewCopyClipboardMap, connectionID)
}

//export textview_copyClipboardHandler
func textview_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewCopyClipboardMap[index].callback
	callback()
}

type signalTextViewCutClipboardDetail struct {
	callback  TextViewSignalCutClipboardCallback
	handlerID C.gulong
}

var signalTextViewCutClipboardId int
var signalTextViewCutClipboardMap = make(map[int]signalTextViewCutClipboardDetail)
var signalTextViewCutClipboardLock sync.Mutex

// TextViewSignalCutClipboardCallback is a callback function for a 'cut-clipboard' signal emitted from a TextView.
type TextViewSignalCutClipboardCallback func()

/*
ConnectCutClipboard connects the callback to the 'cut-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectCutClipboard to remove it.
*/
func (recv *TextView) ConnectCutClipboard(callback TextViewSignalCutClipboardCallback) int {
	signalTextViewCutClipboardLock.Lock()
	defer signalTextViewCutClipboardLock.Unlock()

	signalTextViewCutClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_cut_clipboard(instance, C.gpointer(uintptr(signalTextViewCutClipboardId)))

	detail := signalTextViewCutClipboardDetail{callback, handlerID}
	signalTextViewCutClipboardMap[signalTextViewCutClipboardId] = detail

	return signalTextViewCutClipboardId
}

/*
DisconnectCutClipboard disconnects a callback from the 'cut-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectCutClipboard.
*/
func (recv *TextView) DisconnectCutClipboard(connectionID int) {
	signalTextViewCutClipboardLock.Lock()
	defer signalTextViewCutClipboardLock.Unlock()

	detail, exists := signalTextViewCutClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewCutClipboardMap, connectionID)
}

//export textview_cutClipboardHandler
func textview_cutClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewCutClipboardMap[index].callback
	callback()
}

// Unsupported signal 'delete-from-cursor' for TextView : unsupported parameter type : type DeleteType :

// Unsupported signal 'insert-at-cursor' for TextView : unsupported parameter string : type utf8 :

// Unsupported signal 'move-cursor' for TextView : unsupported parameter step : type MovementStep :

// Unsupported signal 'move-viewport' for TextView : unsupported parameter step : type ScrollStep :

type signalTextViewPasteClipboardDetail struct {
	callback  TextViewSignalPasteClipboardCallback
	handlerID C.gulong
}

var signalTextViewPasteClipboardId int
var signalTextViewPasteClipboardMap = make(map[int]signalTextViewPasteClipboardDetail)
var signalTextViewPasteClipboardLock sync.Mutex

// TextViewSignalPasteClipboardCallback is a callback function for a 'paste-clipboard' signal emitted from a TextView.
type TextViewSignalPasteClipboardCallback func()

/*
ConnectPasteClipboard connects the callback to the 'paste-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectPasteClipboard to remove it.
*/
func (recv *TextView) ConnectPasteClipboard(callback TextViewSignalPasteClipboardCallback) int {
	signalTextViewPasteClipboardLock.Lock()
	defer signalTextViewPasteClipboardLock.Unlock()

	signalTextViewPasteClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_paste_clipboard(instance, C.gpointer(uintptr(signalTextViewPasteClipboardId)))

	detail := signalTextViewPasteClipboardDetail{callback, handlerID}
	signalTextViewPasteClipboardMap[signalTextViewPasteClipboardId] = detail

	return signalTextViewPasteClipboardId
}

/*
DisconnectPasteClipboard disconnects a callback from the 'paste-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectPasteClipboard.
*/
func (recv *TextView) DisconnectPasteClipboard(connectionID int) {
	signalTextViewPasteClipboardLock.Lock()
	defer signalTextViewPasteClipboardLock.Unlock()

	detail, exists := signalTextViewPasteClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewPasteClipboardMap, connectionID)
}

//export textview_pasteClipboardHandler
func textview_pasteClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewPasteClipboardMap[index].callback
	callback()
}

type signalTextViewPopulatePopupDetail struct {
	callback  TextViewSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalTextViewPopulatePopupId int
var signalTextViewPopulatePopupMap = make(map[int]signalTextViewPopulatePopupDetail)
var signalTextViewPopulatePopupLock sync.Mutex

// TextViewSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a TextView.
type TextViewSignalPopulatePopupCallback func(popup *Widget)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *TextView) ConnectPopulatePopup(callback TextViewSignalPopulatePopupCallback) int {
	signalTextViewPopulatePopupLock.Lock()
	defer signalTextViewPopulatePopupLock.Unlock()

	signalTextViewPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalTextViewPopulatePopupId)))

	detail := signalTextViewPopulatePopupDetail{callback, handlerID}
	signalTextViewPopulatePopupMap[signalTextViewPopulatePopupId] = detail

	return signalTextViewPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the TextView.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *TextView) DisconnectPopulatePopup(connectionID int) {
	signalTextViewPopulatePopupLock.Lock()
	defer signalTextViewPopulatePopupLock.Unlock()

	detail, exists := signalTextViewPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewPopulatePopupMap, connectionID)
}

//export textview_populatePopupHandler
func textview_populatePopupHandler(_ *C.GObject, c_popup *C.GtkWidget, data C.gpointer) {
	popup := WidgetNewFromC(unsafe.Pointer(c_popup))

	index := int(uintptr(data))
	callback := signalTextViewPopulatePopupMap[index].callback
	callback(popup)
}

type signalTextViewSelectAllDetail struct {
	callback  TextViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalTextViewSelectAllId int
var signalTextViewSelectAllMap = make(map[int]signalTextViewSelectAllDetail)
var signalTextViewSelectAllLock sync.Mutex

// TextViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a TextView.
type TextViewSignalSelectAllCallback func(select_ bool)

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *TextView) ConnectSelectAll(callback TextViewSignalSelectAllCallback) int {
	signalTextViewSelectAllLock.Lock()
	defer signalTextViewSelectAllLock.Unlock()

	signalTextViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_select_all(instance, C.gpointer(uintptr(signalTextViewSelectAllId)))

	detail := signalTextViewSelectAllDetail{callback, handlerID}
	signalTextViewSelectAllMap[signalTextViewSelectAllId] = detail

	return signalTextViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the TextView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *TextView) DisconnectSelectAll(connectionID int) {
	signalTextViewSelectAllLock.Lock()
	defer signalTextViewSelectAllLock.Unlock()

	detail, exists := signalTextViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewSelectAllMap, connectionID)
}

//export textview_selectAllHandler
func textview_selectAllHandler(_ *C.GObject, c_select C.gboolean, data C.gpointer) {
	select_ := c_select == C.TRUE

	index := int(uintptr(data))
	callback := signalTextViewSelectAllMap[index].callback
	callback(select_)
}

type signalTextViewSetAnchorDetail struct {
	callback  TextViewSignalSetAnchorCallback
	handlerID C.gulong
}

var signalTextViewSetAnchorId int
var signalTextViewSetAnchorMap = make(map[int]signalTextViewSetAnchorDetail)
var signalTextViewSetAnchorLock sync.Mutex

// TextViewSignalSetAnchorCallback is a callback function for a 'set-anchor' signal emitted from a TextView.
type TextViewSignalSetAnchorCallback func()

/*
ConnectSetAnchor connects the callback to the 'set-anchor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectSetAnchor to remove it.
*/
func (recv *TextView) ConnectSetAnchor(callback TextViewSignalSetAnchorCallback) int {
	signalTextViewSetAnchorLock.Lock()
	defer signalTextViewSetAnchorLock.Unlock()

	signalTextViewSetAnchorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_set_anchor(instance, C.gpointer(uintptr(signalTextViewSetAnchorId)))

	detail := signalTextViewSetAnchorDetail{callback, handlerID}
	signalTextViewSetAnchorMap[signalTextViewSetAnchorId] = detail

	return signalTextViewSetAnchorId
}

/*
DisconnectSetAnchor disconnects a callback from the 'set-anchor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectSetAnchor.
*/
func (recv *TextView) DisconnectSetAnchor(connectionID int) {
	signalTextViewSetAnchorLock.Lock()
	defer signalTextViewSetAnchorLock.Unlock()

	detail, exists := signalTextViewSetAnchorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewSetAnchorMap, connectionID)
}

//export textview_setAnchorHandler
func textview_setAnchorHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewSetAnchorMap[index].callback
	callback()
}

type signalTextViewToggleCursorVisibleDetail struct {
	callback  TextViewSignalToggleCursorVisibleCallback
	handlerID C.gulong
}

var signalTextViewToggleCursorVisibleId int
var signalTextViewToggleCursorVisibleMap = make(map[int]signalTextViewToggleCursorVisibleDetail)
var signalTextViewToggleCursorVisibleLock sync.Mutex

// TextViewSignalToggleCursorVisibleCallback is a callback function for a 'toggle-cursor-visible' signal emitted from a TextView.
type TextViewSignalToggleCursorVisibleCallback func()

/*
ConnectToggleCursorVisible connects the callback to the 'toggle-cursor-visible' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorVisible to remove it.
*/
func (recv *TextView) ConnectToggleCursorVisible(callback TextViewSignalToggleCursorVisibleCallback) int {
	signalTextViewToggleCursorVisibleLock.Lock()
	defer signalTextViewToggleCursorVisibleLock.Unlock()

	signalTextViewToggleCursorVisibleId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_toggle_cursor_visible(instance, C.gpointer(uintptr(signalTextViewToggleCursorVisibleId)))

	detail := signalTextViewToggleCursorVisibleDetail{callback, handlerID}
	signalTextViewToggleCursorVisibleMap[signalTextViewToggleCursorVisibleId] = detail

	return signalTextViewToggleCursorVisibleId
}

/*
DisconnectToggleCursorVisible disconnects a callback from the 'toggle-cursor-visible' signal for the TextView.

The connectionID should be a value returned from a call to ConnectToggleCursorVisible.
*/
func (recv *TextView) DisconnectToggleCursorVisible(connectionID int) {
	signalTextViewToggleCursorVisibleLock.Lock()
	defer signalTextViewToggleCursorVisibleLock.Unlock()

	detail, exists := signalTextViewToggleCursorVisibleMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewToggleCursorVisibleMap, connectionID)
}

//export textview_toggleCursorVisibleHandler
func textview_toggleCursorVisibleHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewToggleCursorVisibleMap[index].callback
	callback()
}

type signalTextViewToggleOverwriteDetail struct {
	callback  TextViewSignalToggleOverwriteCallback
	handlerID C.gulong
}

var signalTextViewToggleOverwriteId int
var signalTextViewToggleOverwriteMap = make(map[int]signalTextViewToggleOverwriteDetail)
var signalTextViewToggleOverwriteLock sync.Mutex

// TextViewSignalToggleOverwriteCallback is a callback function for a 'toggle-overwrite' signal emitted from a TextView.
type TextViewSignalToggleOverwriteCallback func()

/*
ConnectToggleOverwrite connects the callback to the 'toggle-overwrite' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectToggleOverwrite to remove it.
*/
func (recv *TextView) ConnectToggleOverwrite(callback TextViewSignalToggleOverwriteCallback) int {
	signalTextViewToggleOverwriteLock.Lock()
	defer signalTextViewToggleOverwriteLock.Unlock()

	signalTextViewToggleOverwriteId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_toggle_overwrite(instance, C.gpointer(uintptr(signalTextViewToggleOverwriteId)))

	detail := signalTextViewToggleOverwriteDetail{callback, handlerID}
	signalTextViewToggleOverwriteMap[signalTextViewToggleOverwriteId] = detail

	return signalTextViewToggleOverwriteId
}

/*
DisconnectToggleOverwrite disconnects a callback from the 'toggle-overwrite' signal for the TextView.

The connectionID should be a value returned from a call to ConnectToggleOverwrite.
*/
func (recv *TextView) DisconnectToggleOverwrite(connectionID int) {
	signalTextViewToggleOverwriteLock.Lock()
	defer signalTextViewToggleOverwriteLock.Unlock()

	detail, exists := signalTextViewToggleOverwriteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewToggleOverwriteMap, connectionID)
}

//export textview_toggleOverwriteHandler
func textview_toggleOverwriteHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewToggleOverwriteMap[index].callback
	callback()
}

// Creates a new #GtkTextView. If you dont call gtk_text_view_set_buffer()
// before using the text view, an empty default buffer will be created
// for you. Get the buffer with gtk_text_view_get_buffer(). If you want
// to specify your own buffer, consider gtk_text_view_new_with_buffer().
/*

C function : gtk_text_view_new
*/
func TextViewNew() *TextView {
	retC := C.gtk_text_view_new()
	retGo := TextViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkTextView widget displaying the buffer
// @buffer. One buffer can be shared among many widgets.
// @buffer may be %NULL to create a default buffer, in which case
// this function is equivalent to gtk_text_view_new(). The
// text view adds its own reference count to the buffer; it does not
// take over an existing reference.
/*

C function : gtk_text_view_new_with_buffer
*/
func TextViewNewWithBuffer(buffer *TextBuffer) *TextView {
	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	retC := C.gtk_text_view_new_with_buffer(c_buffer)
	retGo := TextViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a child widget in the text buffer, at the given @anchor.
/*

C function : gtk_text_view_add_child_at_anchor
*/
func (recv *TextView) AddChildAtAnchor(child *Widget, anchor *TextChildAnchor) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_view_add_child_at_anchor((*C.GtkTextView)(recv.native), c_child, c_anchor)

	return
}

// Adds a child at fixed coordinates in one of the text widget's
// windows.
//
// The window must have nonzero size (see
// gtk_text_view_set_border_window_size()). Note that the child
// coordinates are given relative to scrolling. When
// placing a child in #GTK_TEXT_WINDOW_WIDGET, scrolling is
// irrelevant, the child floats above all scrollable areas. But when
// placing a child in one of the scrollable windows (border windows or
// text window) it will move with the scrolling as needed.
/*

C function : gtk_text_view_add_child_in_window
*/
func (recv *TextView) AddChildInWindow(child *Widget, whichWindow TextWindowType, xpos int32, ypos int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_which_window := (C.GtkTextWindowType)(whichWindow)

	c_xpos := (C.gint)(xpos)

	c_ypos := (C.gint)(ypos)

	C.gtk_text_view_add_child_in_window((*C.GtkTextView)(recv.native), c_child, c_which_window, c_xpos, c_ypos)

	return
}

// Moves the given @iter backward by one display (wrapped) line.
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the views width; paragraphs are the same in all
// views, since they depend on the contents of the #GtkTextBuffer.
/*

C function : gtk_text_view_backward_display_line
*/
func (recv *TextView) BackwardDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_backward_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Moves the given @iter backward to the next display line start.
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the views width; paragraphs are the same in all
// views, since they depend on the contents of the #GtkTextBuffer.
/*

C function : gtk_text_view_backward_display_line_start
*/
func (recv *TextView) BackwardDisplayLineStart(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_backward_display_line_start((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Converts coordinate (@buffer_x, @buffer_y) to coordinates for the window
// @win, and stores the result in (@window_x, @window_y).
//
// Note that you cant convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
/*

C function : gtk_text_view_buffer_to_window_coords
*/
func (recv *TextView) BufferToWindowCoords(win TextWindowType, bufferX int32, bufferY int32) (int32, int32) {
	c_win := (C.GtkTextWindowType)(win)

	c_buffer_x := (C.gint)(bufferX)

	c_buffer_y := (C.gint)(bufferY)

	var c_window_x C.gint

	var c_window_y C.gint

	C.gtk_text_view_buffer_to_window_coords((*C.GtkTextView)(recv.native), c_win, c_buffer_x, c_buffer_y, &c_window_x, &c_window_y)

	windowX := (int32)(c_window_x)

	windowY := (int32)(c_window_y)

	return windowX, windowY
}

// Moves the given @iter forward by one display (wrapped) line.
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the views width; paragraphs are the same in all
// views, since they depend on the contents of the #GtkTextBuffer.
/*

C function : gtk_text_view_forward_display_line
*/
func (recv *TextView) ForwardDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_forward_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Moves the given @iter forward to the next display line end.
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the views width; paragraphs are the same in all
// views, since they depend on the contents of the #GtkTextBuffer.
/*

C function : gtk_text_view_forward_display_line_end
*/
func (recv *TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_forward_display_line_end((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Gets the width of the specified border window. See
// gtk_text_view_set_border_window_size().
/*

C function : gtk_text_view_get_border_window_size
*/
func (recv *TextView) GetBorderWindowSize(type_ TextWindowType) int32 {
	c_type := (C.GtkTextWindowType)(type_)

	retC := C.gtk_text_view_get_border_window_size((*C.GtkTextView)(recv.native), c_type)
	retGo := (int32)(retC)

	return retGo
}

// Returns the #GtkTextBuffer being displayed by this text view.
// The reference count on the buffer is not incremented; the caller
// of this function wont own a new reference.
/*

C function : gtk_text_view_get_buffer
*/
func (recv *TextView) GetBuffer() *TextBuffer {
	retC := C.gtk_text_view_get_buffer((*C.GtkTextView)(recv.native))
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Find out whether the cursor should be displayed.
/*

C function : gtk_text_view_get_cursor_visible
*/
func (recv *TextView) GetCursorVisible() bool {
	retC := C.gtk_text_view_get_cursor_visible((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Obtains a copy of the default text attributes. These are the
// attributes used for text unless a tag overrides them.
// Youd typically pass the default attributes in to
// gtk_text_iter_get_attributes() in order to get the
// attributes in effect at a given text position.
//
// The return value is a copy owned by the caller of this function,
// and should be freed with gtk_text_attributes_unref().
/*

C function : gtk_text_view_get_default_attributes
*/
func (recv *TextView) GetDefaultAttributes() *TextAttributes {
	retC := C.gtk_text_view_get_default_attributes((*C.GtkTextView)(recv.native))
	retGo := TextAttributesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the default editability of the #GtkTextView. Tags in the
// buffer may override this setting for some ranges of text.
/*

C function : gtk_text_view_get_editable
*/
func (recv *TextView) GetEditable() bool {
	retC := C.gtk_text_view_get_editable((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the default indentation of paragraphs in @text_view.
// Tags in the views buffer may override the default.
// The indentation may be negative.
/*

C function : gtk_text_view_get_indent
*/
func (recv *TextView) GetIndent() int32 {
	retC := C.gtk_text_view_get_indent((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Retrieves the iterator at buffer coordinates @x and @y. Buffer
// coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion.  If you have coordinates from an
// event, you have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
/*

C function : gtk_text_view_get_iter_at_location
*/
func (recv *TextView) GetIterAtLocation(x int32, y int32) *TextIter {
	var c_iter C.GtkTextIter

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_text_view_get_iter_at_location((*C.GtkTextView)(recv.native), &c_iter, c_x, c_y)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Unsupported : gtk_text_view_get_iter_location : unsupported parameter location : Blacklisted record : GdkRectangle

// Gets the default justification of paragraphs in @text_view.
// Tags in the buffer may override the default.
/*

C function : gtk_text_view_get_justification
*/
func (recv *TextView) GetJustification() Justification {
	retC := C.gtk_text_view_get_justification((*C.GtkTextView)(recv.native))
	retGo := (Justification)(retC)

	return retGo
}

// Gets the default left margin size of paragraphs in the @text_view.
// Tags in the buffer may override the default.
/*

C function : gtk_text_view_get_left_margin
*/
func (recv *TextView) GetLeftMargin() int32 {
	retC := C.gtk_text_view_get_left_margin((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the #GtkTextIter at the start of the line containing
// the coordinate @y. @y is in buffer coordinates, convert from
// window coordinates with gtk_text_view_window_to_buffer_coords().
// If non-%NULL, @line_top will be filled with the coordinate of the top
// edge of the line.
/*

C function : gtk_text_view_get_line_at_y
*/
func (recv *TextView) GetLineAtY(y int32) (*TextIter, int32) {
	var c_target_iter C.GtkTextIter

	c_y := (C.gint)(y)

	var c_line_top C.gint

	C.gtk_text_view_get_line_at_y((*C.GtkTextView)(recv.native), &c_target_iter, c_y, &c_line_top)

	targetIter := TextIterNewFromC(unsafe.Pointer(&c_target_iter))

	lineTop := (int32)(c_line_top)

	return targetIter, lineTop
}

// Gets the y coordinate of the top of the line containing @iter,
// and the height of the line. The coordinate is a buffer coordinate;
// convert to window coordinates with gtk_text_view_buffer_to_window_coords().
/*

C function : gtk_text_view_get_line_yrange
*/
func (recv *TextView) GetLineYrange(iter *TextIter) (int32, int32) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	var c_y C.gint

	var c_height C.gint

	C.gtk_text_view_get_line_yrange((*C.GtkTextView)(recv.native), c_iter, &c_y, &c_height)

	y := (int32)(c_y)

	height := (int32)(c_height)

	return y, height
}

// Gets the default number of pixels to put above paragraphs.
// Adding this function with gtk_text_view_get_pixels_below_lines()
// is equal to the line space between each paragraph.
/*

C function : gtk_text_view_get_pixels_above_lines
*/
func (recv *TextView) GetPixelsAboveLines() int32 {
	retC := C.gtk_text_view_get_pixels_above_lines((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the value set by gtk_text_view_set_pixels_below_lines().
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk_text_view_get_pixels_above_lines().
/*

C function : gtk_text_view_get_pixels_below_lines
*/
func (recv *TextView) GetPixelsBelowLines() int32 {
	retC := C.gtk_text_view_get_pixels_below_lines((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the value set by gtk_text_view_set_pixels_inside_wrap().
/*

C function : gtk_text_view_get_pixels_inside_wrap
*/
func (recv *TextView) GetPixelsInsideWrap() int32 {
	retC := C.gtk_text_view_get_pixels_inside_wrap((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the default right margin for text in @text_view. Tags
// in the buffer may override the default.
/*

C function : gtk_text_view_get_right_margin
*/
func (recv *TextView) GetRightMargin() int32 {
	retC := C.gtk_text_view_get_right_margin((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the default tabs for @text_view. Tags in the buffer may
// override the defaults. The returned array will be %NULL if
// standard (8-space) tabs are used. Free the return value
// with pango_tab_array_free().
/*

C function : gtk_text_view_get_tabs
*/
func (recv *TextView) GetTabs() *pango.TabArray {
	retC := C.gtk_text_view_get_tabs((*C.GtkTextView)(recv.native))
	var retGo (*pango.TabArray)
	if retC == nil {
		retGo = nil
	} else {
		retGo = pango.TabArrayNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_text_view_get_visible_rect : unsupported parameter visible_rect : Blacklisted record : GdkRectangle

// Retrieves the #GdkWindow corresponding to an area of the text view;
// possible windows include the overall widget window, child windows
// on the left, right, top, bottom, and the window that displays the
// text buffer. Windows are %NULL and nonexistent if their width or
// height is 0, and are nonexistent before the widget has been
// realized.
/*

C function : gtk_text_view_get_window
*/
func (recv *TextView) GetWindow(win TextWindowType) *gdk.Window {
	c_win := (C.GtkTextWindowType)(win)

	retC := C.gtk_text_view_get_window((*C.GtkTextView)(recv.native), c_win)
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Usually used to find out which window an event corresponds to.
//
// If you connect to an event signal on @text_view, this function
// should be called on `event->window` to see which window it was.
/*

C function : gtk_text_view_get_window_type
*/
func (recv *TextView) GetWindowType(window *gdk.Window) TextWindowType {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	retC := C.gtk_text_view_get_window_type((*C.GtkTextView)(recv.native), c_window)
	retGo := (TextWindowType)(retC)

	return retGo
}

// Gets the line wrapping for the view.
/*

C function : gtk_text_view_get_wrap_mode
*/
func (recv *TextView) GetWrapMode() WrapMode {
	retC := C.gtk_text_view_get_wrap_mode((*C.GtkTextView)(recv.native))
	retGo := (WrapMode)(retC)

	return retGo
}

// Updates the position of a child, as for gtk_text_view_add_child_in_window().
/*

C function : gtk_text_view_move_child
*/
func (recv *TextView) MoveChild(child *Widget, xpos int32, ypos int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_xpos := (C.gint)(xpos)

	c_ypos := (C.gint)(ypos)

	C.gtk_text_view_move_child((*C.GtkTextView)(recv.native), c_child, c_xpos, c_ypos)

	return
}

// Moves a mark within the buffer so that it's
// located within the currently-visible text area.
/*

C function : gtk_text_view_move_mark_onscreen
*/
func (recv *TextView) MoveMarkOnscreen(mark *TextMark) bool {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	retC := C.gtk_text_view_move_mark_onscreen((*C.GtkTextView)(recv.native), c_mark)
	retGo := retC == C.TRUE

	return retGo
}

// Move the iterator a given number of characters visually, treating
// it as the strong cursor position. If @count is positive, then the
// new strong cursor position will be @count positions to the right of
// the old cursor position. If @count is negative then the new strong
// cursor position will be @count positions to the left of the old
// cursor position.
//
// In the presence of bi-directional text, the correspondence
// between logical and visual order will depend on the direction
// of the current run, and there may be jumps when the cursor
// is moved off of the end of a run.
/*

C function : gtk_text_view_move_visually
*/
func (recv *TextView) MoveVisually(iter *TextIter, count int32) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_count := (C.gint)(count)

	retC := C.gtk_text_view_move_visually((*C.GtkTextView)(recv.native), c_iter, c_count)
	retGo := retC == C.TRUE

	return retGo
}

// Moves the cursor to the currently visible region of the
// buffer, it it isnt there already.
/*

C function : gtk_text_view_place_cursor_onscreen
*/
func (recv *TextView) PlaceCursorOnscreen() bool {
	retC := C.gtk_text_view_place_cursor_onscreen((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Scrolls @text_view the minimum distance such that @mark is contained
// within the visible area of the widget.
/*

C function : gtk_text_view_scroll_mark_onscreen
*/
func (recv *TextView) ScrollMarkOnscreen(mark *TextMark) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_view_scroll_mark_onscreen((*C.GtkTextView)(recv.native), c_mark)

	return
}

// Scrolls @text_view so that @iter is on the screen in the position
// indicated by @xalign and @yalign. An alignment of 0.0 indicates
// left or top, 1.0 indicates right or bottom, 0.5 means center.
// If @use_align is %FALSE, the text scrolls the minimal distance to
// get the mark onscreen, possibly not scrolling at all. The effective
// screen for purposes of this function is reduced by a margin of size
// @within_margin.
//
// Note that this function uses the currently-computed height of the
// lines in the text buffer. Line heights are computed in an idle
// handler; so this function may not have the desired effect if its
// called before the height computations. To avoid oddness, consider
// using gtk_text_view_scroll_to_mark() which saves a point to be
// scrolled to after line validation.
/*

C function : gtk_text_view_scroll_to_iter
*/
func (recv *TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_within_margin := (C.gdouble)(withinMargin)

	c_use_align :=
		boolToGboolean(useAlign)

	c_xalign := (C.gdouble)(xalign)

	c_yalign := (C.gdouble)(yalign)

	retC := C.gtk_text_view_scroll_to_iter((*C.GtkTextView)(recv.native), c_iter, c_within_margin, c_use_align, c_xalign, c_yalign)
	retGo := retC == C.TRUE

	return retGo
}

// Scrolls @text_view so that @mark is on the screen in the position
// indicated by @xalign and @yalign. An alignment of 0.0 indicates
// left or top, 1.0 indicates right or bottom, 0.5 means center.
// If @use_align is %FALSE, the text scrolls the minimal distance to
// get the mark onscreen, possibly not scrolling at all. The effective
// screen for purposes of this function is reduced by a margin of size
// @within_margin.
/*

C function : gtk_text_view_scroll_to_mark
*/
func (recv *TextView) ScrollToMark(mark *TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	c_within_margin := (C.gdouble)(withinMargin)

	c_use_align :=
		boolToGboolean(useAlign)

	c_xalign := (C.gdouble)(xalign)

	c_yalign := (C.gdouble)(yalign)

	C.gtk_text_view_scroll_to_mark((*C.GtkTextView)(recv.native), c_mark, c_within_margin, c_use_align, c_xalign, c_yalign)

	return
}

// Sets the width of %GTK_TEXT_WINDOW_LEFT or %GTK_TEXT_WINDOW_RIGHT,
// or the height of %GTK_TEXT_WINDOW_TOP or %GTK_TEXT_WINDOW_BOTTOM.
// Automatically destroys the corresponding window if the size is set
// to 0, and creates the window if the size is set to non-zero.  This
// function can only be used for the border windows, and it wont
// work with %GTK_TEXT_WINDOW_WIDGET, %GTK_TEXT_WINDOW_TEXT, or
// %GTK_TEXT_WINDOW_PRIVATE.
/*

C function : gtk_text_view_set_border_window_size
*/
func (recv *TextView) SetBorderWindowSize(type_ TextWindowType, size int32) {
	c_type := (C.GtkTextWindowType)(type_)

	c_size := (C.gint)(size)

	C.gtk_text_view_set_border_window_size((*C.GtkTextView)(recv.native), c_type, c_size)

	return
}

// Sets @buffer as the buffer being displayed by @text_view. The previous
// buffer displayed by the text view is unreferenced, and a reference is
// added to @buffer. If you owned a reference to @buffer before passing it
// to this function, you must remove that reference yourself; #GtkTextView
// will not adopt it.
/*

C function : gtk_text_view_set_buffer
*/
func (recv *TextView) SetBuffer(buffer *TextBuffer) {
	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	C.gtk_text_view_set_buffer((*C.GtkTextView)(recv.native), c_buffer)

	return
}

// Toggles whether the insertion point should be displayed. A buffer with
// no editable text probably shouldnt have a visible cursor, so you may
// want to turn the cursor off.
//
// Note that this property may be overridden by the
// #GtkSettings:gtk-keynave-use-caret settings.
/*

C function : gtk_text_view_set_cursor_visible
*/
func (recv *TextView) SetCursorVisible(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_view_set_cursor_visible((*C.GtkTextView)(recv.native), c_setting)

	return
}

// Sets the default editability of the #GtkTextView. You can override
// this default setting with tags in the buffer, using the editable
// attribute of tags.
/*

C function : gtk_text_view_set_editable
*/
func (recv *TextView) SetEditable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_view_set_editable((*C.GtkTextView)(recv.native), c_setting)

	return
}

// Sets the default indentation for paragraphs in @text_view.
// Tags in the buffer may override the default.
/*

C function : gtk_text_view_set_indent
*/
func (recv *TextView) SetIndent(indent int32) {
	c_indent := (C.gint)(indent)

	C.gtk_text_view_set_indent((*C.GtkTextView)(recv.native), c_indent)

	return
}

// Sets the default justification of text in @text_view.
// Tags in the views buffer may override the default.
/*

C function : gtk_text_view_set_justification
*/
func (recv *TextView) SetJustification(justification Justification) {
	c_justification := (C.GtkJustification)(justification)

	C.gtk_text_view_set_justification((*C.GtkTextView)(recv.native), c_justification)

	return
}

// Sets the default left margin for text in @text_view.
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named.
// In CSS terms, the value set here is padding.
/*

C function : gtk_text_view_set_left_margin
*/
func (recv *TextView) SetLeftMargin(leftMargin int32) {
	c_left_margin := (C.gint)(leftMargin)

	C.gtk_text_view_set_left_margin((*C.GtkTextView)(recv.native), c_left_margin)

	return
}

// Sets the default number of blank pixels above paragraphs in @text_view.
// Tags in the buffer for @text_view may override the defaults.
/*

C function : gtk_text_view_set_pixels_above_lines
*/
func (recv *TextView) SetPixelsAboveLines(pixelsAboveLines int32) {
	c_pixels_above_lines := (C.gint)(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines((*C.GtkTextView)(recv.native), c_pixels_above_lines)

	return
}

// Sets the default number of pixels of blank space
// to put below paragraphs in @text_view. May be overridden
// by tags applied to @text_views buffer.
/*

C function : gtk_text_view_set_pixels_below_lines
*/
func (recv *TextView) SetPixelsBelowLines(pixelsBelowLines int32) {
	c_pixels_below_lines := (C.gint)(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines((*C.GtkTextView)(recv.native), c_pixels_below_lines)

	return
}

// Sets the default number of pixels of blank space to leave between
// display/wrapped lines within a paragraph. May be overridden by
// tags in @text_views buffer.
/*

C function : gtk_text_view_set_pixels_inside_wrap
*/
func (recv *TextView) SetPixelsInsideWrap(pixelsInsideWrap int32) {
	c_pixels_inside_wrap := (C.gint)(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap((*C.GtkTextView)(recv.native), c_pixels_inside_wrap)

	return
}

// Sets the default right margin for text in the text view.
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named.
// In CSS terms, the value set here is padding.
/*

C function : gtk_text_view_set_right_margin
*/
func (recv *TextView) SetRightMargin(rightMargin int32) {
	c_right_margin := (C.gint)(rightMargin)

	C.gtk_text_view_set_right_margin((*C.GtkTextView)(recv.native), c_right_margin)

	return
}

// Sets the default tab stops for paragraphs in @text_view.
// Tags in the buffer may override the default.
/*

C function : gtk_text_view_set_tabs
*/
func (recv *TextView) SetTabs(tabs *pango.TabArray) {
	c_tabs := (*C.PangoTabArray)(C.NULL)
	if tabs != nil {
		c_tabs = (*C.PangoTabArray)(tabs.ToC())
	}

	C.gtk_text_view_set_tabs((*C.GtkTextView)(recv.native), c_tabs)

	return
}

// Sets the line wrapping for the view.
/*

C function : gtk_text_view_set_wrap_mode
*/
func (recv *TextView) SetWrapMode(wrapMode WrapMode) {
	c_wrap_mode := (C.GtkWrapMode)(wrapMode)

	C.gtk_text_view_set_wrap_mode((*C.GtkTextView)(recv.native), c_wrap_mode)

	return
}

// Determines whether @iter is at the start of a display line.
// See gtk_text_view_forward_display_line() for an explanation of
// display lines vs. paragraphs.
/*

C function : gtk_text_view_starts_display_line
*/
func (recv *TextView) StartsDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_starts_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Converts coordinates on the window identified by @win to buffer
// coordinates, storing the result in (@buffer_x,@buffer_y).
//
// Note that you cant convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
/*

C function : gtk_text_view_window_to_buffer_coords
*/
func (recv *TextView) WindowToBufferCoords(win TextWindowType, windowX int32, windowY int32) (int32, int32) {
	c_win := (C.GtkTextWindowType)(win)

	c_window_x := (C.gint)(windowX)

	c_window_y := (C.gint)(windowY)

	var c_buffer_x C.gint

	var c_buffer_y C.gint

	C.gtk_text_view_window_to_buffer_coords((*C.GtkTextView)(recv.native), c_win, c_window_x, c_window_y, &c_buffer_x, &c_buffer_y)

	bufferX := (int32)(c_buffer_x)

	bufferY := (int32)(c_buffer_y)

	return bufferX, bufferY
}

// ImplementorIface returns the ImplementorIface interface implemented by TextView
func (recv *TextView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TextView
func (recv *TextView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by TextView
func (recv *TextView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

/*

C record/class : GtkTextViewAccessible
*/
type TextViewAccessible struct {
	native *C.GtkTextViewAccessible
	// parent : record
	// priv : record
}

func TextViewAccessibleNewFromC(u unsafe.Pointer) *TextViewAccessible {
	c := (*C.GtkTextViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TextViewAccessible{native: c}

	return g
}

func (recv *TextViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *TextViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *TextViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TextViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TextViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to TextViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextViewAccessible.
func CastToTextViewAccessible(object *gobject.Object) *TextViewAccessible {
	return TextViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by TextViewAccessible
func (recv *TextViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by TextViewAccessible
func (recv *TextViewAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// StreamableContent returns the StreamableContent interface implemented by TextViewAccessible
func (recv *TextViewAccessible) StreamableContent() *atk.StreamableContent {
	return atk.StreamableContentNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by TextViewAccessible
func (recv *TextViewAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// #GtkThemingEngine was the object used for rendering themed content
// in GTK+ widgets. It used to allow overriding GTK+'s default
// implementation of rendering functions by allowing engines to be
// loaded as modules.
//
// #GtkThemingEngine has been deprecated in GTK+ 3.14 and will be
// ignored for rendering. The advancements in CSS theming are good
// enough to allow themers to achieve their goals without the need
// to modify source code.
/*

C record/class : GtkThemingEngine
*/
type ThemingEngine struct {
	native *C.GtkThemingEngine
	// parent_object : record
	// priv : record
}

func ThemingEngineNewFromC(u unsafe.Pointer) *ThemingEngine {
	c := (*C.GtkThemingEngine)(u)
	if c == nil {
		return nil
	}

	g := &ThemingEngine{native: c}

	return g
}

func (recv *ThemingEngine) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *ThemingEngine) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to ThemingEngine.
// Exercise care, as this is a potentially dangerous function if the Object is not a ThemingEngine.
func CastToThemingEngine(object *gobject.Object) *ThemingEngine {
	return ThemingEngineNewFromC(object.ToC())
}

// Returns the #GdkScreen to which @engine currently rendering to.
/*

C function : gtk_theming_engine_get_screen
*/
func (recv *ThemingEngine) GetScreen() *gdk.Screen {
	retC := C.gtk_theming_engine_get_screen((*C.GtkThemingEngine)(recv.native))
	var retGo (*gdk.Screen)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.ScreenNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// A #GtkToggleAction corresponds roughly to a #GtkCheckMenuItem. It has an
// active state specifying whether the action has been checked or not.
/*

C record/class : GtkToggleAction
*/
type ToggleAction struct {
	native *C.GtkToggleAction
	// parent : record
	// Private : private_data
}

func ToggleActionNewFromC(u unsafe.Pointer) *ToggleAction {
	c := (*C.GtkToggleAction)(u)
	if c == nil {
		return nil
	}

	g := &ToggleAction{native: c}

	return g
}

func (recv *ToggleAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Action upcasts to *Action
func (recv *ToggleAction) Action() *Action {
	return ActionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *ToggleAction) Object() *gobject.Object {
	return recv.Action().Object()
}

// CastToWidget down casts any arbitary Object to ToggleAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleAction.
func CastToToggleAction(object *gobject.Object) *ToggleAction {
	return ToggleActionNewFromC(object.ToC())
}

type signalToggleActionToggledDetail struct {
	callback  ToggleActionSignalToggledCallback
	handlerID C.gulong
}

var signalToggleActionToggledId int
var signalToggleActionToggledMap = make(map[int]signalToggleActionToggledDetail)
var signalToggleActionToggledLock sync.Mutex

// ToggleActionSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleAction.
type ToggleActionSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleAction.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleAction) ConnectToggled(callback ToggleActionSignalToggledCallback) int {
	signalToggleActionToggledLock.Lock()
	defer signalToggleActionToggledLock.Unlock()

	signalToggleActionToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleAction_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleActionToggledId)))

	detail := signalToggleActionToggledDetail{callback, handlerID}
	signalToggleActionToggledMap[signalToggleActionToggledId] = detail

	return signalToggleActionToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleAction.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleAction) DisconnectToggled(connectionID int) {
	signalToggleActionToggledLock.Lock()
	defer signalToggleActionToggledLock.Unlock()

	detail, exists := signalToggleActionToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleActionToggledMap, connectionID)
}

//export toggleaction_toggledHandler
func toggleaction_toggledHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToggleActionToggledMap[index].callback
	callback()
}

// Buildable returns the Buildable interface implemented by ToggleAction
func (recv *ToggleAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A #GtkToggleButton is a #GtkButton which will remain pressed-in when
// clicked. Clicking again will cause the toggle button to return to its
// normal state.
//
// A toggle button is created by calling either gtk_toggle_button_new() or
// gtk_toggle_button_new_with_label(). If using the former, it is advisable to
// pack a widget, (such as a #GtkLabel and/or a #GtkImage), into the toggle
// buttons container. (See #GtkButton for more information).
//
// The state of a #GtkToggleButton can be set specifically using
// gtk_toggle_button_set_active(), and retrieved using
// gtk_toggle_button_get_active().
//
// To simply switch the state of a toggle button, use gtk_toggle_button_toggled().
//
// # CSS nodes
//
// GtkToggleButton has a single CSS node with name button. To differentiate
// it from a plain #GtkButton, it gets the .toggle style class.
//
// ## Creating two #GtkToggleButton widgets.
//
// |[<!-- language="C" -->
// static void output_state (GtkToggleButton *source, gpointer user_data) {
// printf ("Active: %d\n", gtk_toggle_button_get_active (source));
// }
//
// void make_toggles (void) {
// GtkWidget *window, *toggle1, *toggle2;
// GtkWidget *box;
// const char *text;
//
// window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
// box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
//
// text = "Hi, Im a toggle button.";
// toggle1 = gtk_toggle_button_new_with_label (text);
//
// Makes this toggle button invisible
// gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle1),
// TRUE);
//
// g_signal_connect (toggle1, "toggled",
// G_CALLBACK (output_state),
// NULL);
// gtk_container_add (GTK_CONTAINER (box), toggle1);
//
// text = "Hi, Im a toggle button.";
// toggle2 = gtk_toggle_button_new_with_label (text);
// gtk_toggle_button_set_mode (GTK_TOGGLE_BUTTON (toggle2),
// FALSE);
// g_signal_connect (toggle2, "toggled",
// G_CALLBACK (output_state),
// NULL);
// gtk_container_add (GTK_CONTAINER (box), toggle2);
//
// gtk_container_add (GTK_CONTAINER (window), box);
// gtk_widget_show_all (window);
// }
// ]|
/*

C record/class : GtkToggleButton
*/
type ToggleButton struct {
	native *C.GtkToggleButton
	// Private : button
	// Private : priv
}

func ToggleButtonNewFromC(u unsafe.Pointer) *ToggleButton {
	c := (*C.GtkToggleButton)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButton{native: c}

	return g
}

func (recv *ToggleButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *ToggleButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ToggleButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ToggleButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ToggleButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToggleButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToggleButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to ToggleButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleButton.
func CastToToggleButton(object *gobject.Object) *ToggleButton {
	return ToggleButtonNewFromC(object.ToC())
}

type signalToggleButtonToggledDetail struct {
	callback  ToggleButtonSignalToggledCallback
	handlerID C.gulong
}

var signalToggleButtonToggledId int
var signalToggleButtonToggledMap = make(map[int]signalToggleButtonToggledDetail)
var signalToggleButtonToggledLock sync.Mutex

// ToggleButtonSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleButton.
type ToggleButtonSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleButton.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleButton) ConnectToggled(callback ToggleButtonSignalToggledCallback) int {
	signalToggleButtonToggledLock.Lock()
	defer signalToggleButtonToggledLock.Unlock()

	signalToggleButtonToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleButton_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleButtonToggledId)))

	detail := signalToggleButtonToggledDetail{callback, handlerID}
	signalToggleButtonToggledMap[signalToggleButtonToggledId] = detail

	return signalToggleButtonToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleButton.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleButton) DisconnectToggled(connectionID int) {
	signalToggleButtonToggledLock.Lock()
	defer signalToggleButtonToggledLock.Unlock()

	detail, exists := signalToggleButtonToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleButtonToggledMap, connectionID)
}

//export togglebutton_toggledHandler
func togglebutton_toggledHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToggleButtonToggledMap[index].callback
	callback()
}

// Creates a new toggle button. A widget should be packed into the button, as in gtk_button_new().
/*

C function : gtk_toggle_button_new
*/
func ToggleButtonNew() *ToggleButton {
	retC := C.gtk_toggle_button_new()
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new toggle button with a text label.
/*

C function : gtk_toggle_button_new_with_label
*/
func ToggleButtonNewWithLabel(label string) *ToggleButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_toggle_button_new_with_label(c_label)
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkToggleButton containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the button.
/*

C function : gtk_toggle_button_new_with_mnemonic
*/
func ToggleButtonNewWithMnemonic(label string) *ToggleButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_toggle_button_new_with_mnemonic(c_label)
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Queries a #GtkToggleButton and returns its current state. Returns %TRUE if
// the toggle button is pressed in and %FALSE if it is raised.
/*

C function : gtk_toggle_button_get_active
*/
func (recv *ToggleButton) GetActive() bool {
	retC := C.gtk_toggle_button_get_active((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_toggle_button_set_inconsistent().
/*

C function : gtk_toggle_button_get_inconsistent
*/
func (recv *ToggleButton) GetInconsistent() bool {
	retC := C.gtk_toggle_button_get_inconsistent((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves whether the button is displayed as a separate indicator
// and label. See gtk_toggle_button_set_mode().
/*

C function : gtk_toggle_button_get_mode
*/
func (recv *ToggleButton) GetMode() bool {
	retC := C.gtk_toggle_button_get_mode((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the status of the toggle button. Set to %TRUE if you want the
// GtkToggleButton to be pressed in, and %FALSE to raise it.
// This action causes the #GtkToggleButton::toggled signal and the
// #GtkButton::clicked signal to be emitted.
/*

C function : gtk_toggle_button_set_active
*/
func (recv *ToggleButton) SetActive(isActive bool) {
	c_is_active :=
		boolToGboolean(isActive)

	C.gtk_toggle_button_set_active((*C.GtkToggleButton)(recv.native), c_is_active)

	return
}

// If the user has selected a range of elements (such as some text or
// spreadsheet cells) that are affected by a toggle button, and the
// current values in that range are inconsistent, you may want to
// display the toggle in an in between state. This function turns on
// in between display.  Normally you would turn off the inconsistent
// state again if the user toggles the toggle button. This has to be
// done manually, gtk_toggle_button_set_inconsistent() only affects
// visual appearance, it doesnt affect the semantics of the button.
/*

C function : gtk_toggle_button_set_inconsistent
*/
func (recv *ToggleButton) SetInconsistent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_toggle_button_set_inconsistent((*C.GtkToggleButton)(recv.native), c_setting)

	return
}

// Sets whether the button is displayed as a separate indicator and label.
// You can call this function on a checkbutton or a radiobutton with
// @draw_indicator = %FALSE to make the button look like a normal button.
//
// This can be used to create linked strip of buttons that work like
// a #GtkStackSwitcher.
//
// This function only affects instances of classes like #GtkCheckButton
// and #GtkRadioButton that derive from #GtkToggleButton,
// not instances of #GtkToggleButton itself.
/*

C function : gtk_toggle_button_set_mode
*/
func (recv *ToggleButton) SetMode(drawIndicator bool) {
	c_draw_indicator :=
		boolToGboolean(drawIndicator)

	C.gtk_toggle_button_set_mode((*C.GtkToggleButton)(recv.native), c_draw_indicator)

	return
}

// Emits the #GtkToggleButton::toggled signal on the
// #GtkToggleButton. There is no good reason for an
// application ever to call this function.
/*

C function : gtk_toggle_button_toggled
*/
func (recv *ToggleButton) Toggled() {
	C.gtk_toggle_button_toggled((*C.GtkToggleButton)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ToggleButton
func (recv *ToggleButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToggleButton
func (recv *ToggleButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToggleButton
func (recv *ToggleButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToggleButton
func (recv *ToggleButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkToggleButtonAccessible
*/
type ToggleButtonAccessible struct {
	native *C.GtkToggleButtonAccessible
	// parent : record
	// priv : record
}

func ToggleButtonAccessibleNewFromC(u unsafe.Pointer) *ToggleButtonAccessible {
	c := (*C.GtkToggleButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButtonAccessible{native: c}

	return g
}

func (recv *ToggleButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *ToggleButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ToggleButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ToggleButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ToggleButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ToggleButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ToggleButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleButtonAccessible.
func CastToToggleButtonAccessible(object *gobject.Object) *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// A #GtkToggleToolButton is a #GtkToolItem that contains a toggle
// button.
//
// Use gtk_toggle_tool_button_new() to create a new GtkToggleToolButton.
//
// # CSS nodes
//
// GtkToggleToolButton has a single CSS node with name togglebutton.
/*

C record/class : GtkToggleToolButton
*/
type ToggleToolButton struct {
	native *C.GtkToggleToolButton
	// parent : record
	// Private : priv
}

func ToggleToolButtonNewFromC(u unsafe.Pointer) *ToggleToolButton {
	c := (*C.GtkToggleToolButton)(u)
	if c == nil {
		return nil
	}

	g := &ToggleToolButton{native: c}

	return g
}

func (recv *ToggleToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToolButton upcasts to *ToolButton
func (recv *ToggleToolButton) ToolButton() *ToolButton {
	return ToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolItem upcasts to *ToolItem
func (recv *ToggleToolButton) ToolItem() *ToolItem {
	return recv.ToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *ToggleToolButton) Bin() *Bin {
	return recv.ToolButton().Bin()
}

// Container upcasts to *Container
func (recv *ToggleToolButton) Container() *Container {
	return recv.ToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *ToggleToolButton) Widget() *Widget {
	return recv.ToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToggleToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToggleToolButton) Object() *gobject.Object {
	return recv.ToolButton().Object()
}

// CastToWidget down casts any arbitary Object to ToggleToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleToolButton.
func CastToToggleToolButton(object *gobject.Object) *ToggleToolButton {
	return ToggleToolButtonNewFromC(object.ToC())
}

type signalToggleToolButtonToggledDetail struct {
	callback  ToggleToolButtonSignalToggledCallback
	handlerID C.gulong
}

var signalToggleToolButtonToggledId int
var signalToggleToolButtonToggledMap = make(map[int]signalToggleToolButtonToggledDetail)
var signalToggleToolButtonToggledLock sync.Mutex

// ToggleToolButtonSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleToolButton.
type ToggleToolButtonSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleToolButton.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleToolButton) ConnectToggled(callback ToggleToolButtonSignalToggledCallback) int {
	signalToggleToolButtonToggledLock.Lock()
	defer signalToggleToolButtonToggledLock.Unlock()

	signalToggleToolButtonToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleToolButton_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleToolButtonToggledId)))

	detail := signalToggleToolButtonToggledDetail{callback, handlerID}
	signalToggleToolButtonToggledMap[signalToggleToolButtonToggledId] = detail

	return signalToggleToolButtonToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleToolButton.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleToolButton) DisconnectToggled(connectionID int) {
	signalToggleToolButtonToggledLock.Lock()
	defer signalToggleToolButtonToggledLock.Unlock()

	detail, exists := signalToggleToolButtonToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleToolButtonToggledMap, connectionID)
}

//export toggletoolbutton_toggledHandler
func toggletoolbutton_toggledHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToggleToolButtonToggledMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToggleToolButton
func (recv *ToggleToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkToolButtons are #GtkToolItems containing buttons.
//
// Use gtk_tool_button_new() to create a new #GtkToolButton.
//
// The label of a #GtkToolButton is determined by the properties
// #GtkToolButton:label-widget, #GtkToolButton:label, and
// #GtkToolButton:stock-id. If #GtkToolButton:label-widget is
// non-%NULL, then that widget is used as the label. Otherwise, if
// #GtkToolButton:label is non-%NULL, that string is used as the label.
// Otherwise, if #GtkToolButton:stock-id is non-%NULL, the label is
// determined by the stock item. Otherwise, the button does not have a label.
//
// The icon of a #GtkToolButton is determined by the properties
// #GtkToolButton:icon-widget and #GtkToolButton:stock-id. If
// #GtkToolButton:icon-widget is non-%NULL, then
// that widget is used as the icon. Otherwise, if #GtkToolButton:stock-id is
// non-%NULL, the icon is determined by the stock item. Otherwise,
// the button does not have a icon.
//
// # CSS nodes
//
// GtkToolButton has a single CSS node with name toolbutton.
/*

C record/class : GtkToolButton
*/
type ToolButton struct {
	native *C.GtkToolButton
	// parent : record
	// Private : priv
}

func ToolButtonNewFromC(u unsafe.Pointer) *ToolButton {
	c := (*C.GtkToolButton)(u)
	if c == nil {
		return nil
	}

	g := &ToolButton{native: c}

	return g
}

func (recv *ToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToolItem upcasts to *ToolItem
func (recv *ToolButton) ToolItem() *ToolItem {
	return ToolItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ToolButton) Bin() *Bin {
	return recv.ToolItem().Bin()
}

// Container upcasts to *Container
func (recv *ToolButton) Container() *Container {
	return recv.ToolItem().Container()
}

// Widget upcasts to *Widget
func (recv *ToolButton) Widget() *Widget {
	return recv.ToolItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolButton) Object() *gobject.Object {
	return recv.ToolItem().Object()
}

// CastToWidget down casts any arbitary Object to ToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolButton.
func CastToToolButton(object *gobject.Object) *ToolButton {
	return ToolButtonNewFromC(object.ToC())
}

type signalToolButtonClickedDetail struct {
	callback  ToolButtonSignalClickedCallback
	handlerID C.gulong
}

var signalToolButtonClickedId int
var signalToolButtonClickedMap = make(map[int]signalToolButtonClickedDetail)
var signalToolButtonClickedLock sync.Mutex

// ToolButtonSignalClickedCallback is a callback function for a 'clicked' signal emitted from a ToolButton.
type ToolButtonSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the ToolButton.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *ToolButton) ConnectClicked(callback ToolButtonSignalClickedCallback) int {
	signalToolButtonClickedLock.Lock()
	defer signalToolButtonClickedLock.Unlock()

	signalToolButtonClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolButton_signal_connect_clicked(instance, C.gpointer(uintptr(signalToolButtonClickedId)))

	detail := signalToolButtonClickedDetail{callback, handlerID}
	signalToolButtonClickedMap[signalToolButtonClickedId] = detail

	return signalToolButtonClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the ToolButton.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *ToolButton) DisconnectClicked(connectionID int) {
	signalToolButtonClickedLock.Lock()
	defer signalToolButtonClickedLock.Unlock()

	detail, exists := signalToolButtonClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolButtonClickedMap, connectionID)
}

//export toolbutton_clickedHandler
func toolbutton_clickedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToolButtonClickedMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolButton
func (recv *ToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToolButton
func (recv *ToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToolButton
func (recv *ToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolButton
func (recv *ToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// #GtkToolItems are widgets that can appear on a toolbar. To
// create a toolbar item that contain something else than a button, use
// gtk_tool_item_new(). Use gtk_container_add() to add a child
// widget to the tool item.
//
// For toolbar items that contain buttons, see the #GtkToolButton,
// #GtkToggleToolButton and #GtkRadioToolButton classes.
//
// See the #GtkToolbar class for a description of the toolbar widget, and
// #GtkToolShell for a description of the tool shell interface.
/*

C record/class : GtkToolItem
*/
type ToolItem struct {
	native *C.GtkToolItem
	// parent : record
	// Private : priv
}

func ToolItemNewFromC(u unsafe.Pointer) *ToolItem {
	c := (*C.GtkToolItem)(u)
	if c == nil {
		return nil
	}

	g := &ToolItem{native: c}

	return g
}

func (recv *ToolItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ToolItem) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ToolItem) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ToolItem) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolItem) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ToolItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolItem.
func CastToToolItem(object *gobject.Object) *ToolItem {
	return ToolItemNewFromC(object.ToC())
}

type signalToolItemCreateMenuProxyDetail struct {
	callback  ToolItemSignalCreateMenuProxyCallback
	handlerID C.gulong
}

var signalToolItemCreateMenuProxyId int
var signalToolItemCreateMenuProxyMap = make(map[int]signalToolItemCreateMenuProxyDetail)
var signalToolItemCreateMenuProxyLock sync.Mutex

// ToolItemSignalCreateMenuProxyCallback is a callback function for a 'create-menu-proxy' signal emitted from a ToolItem.
type ToolItemSignalCreateMenuProxyCallback func() bool

/*
ConnectCreateMenuProxy connects the callback to the 'create-menu-proxy' signal for the ToolItem.

The returned value represents the connection, and may be passed to DisconnectCreateMenuProxy to remove it.
*/
func (recv *ToolItem) ConnectCreateMenuProxy(callback ToolItemSignalCreateMenuProxyCallback) int {
	signalToolItemCreateMenuProxyLock.Lock()
	defer signalToolItemCreateMenuProxyLock.Unlock()

	signalToolItemCreateMenuProxyId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolItem_signal_connect_create_menu_proxy(instance, C.gpointer(uintptr(signalToolItemCreateMenuProxyId)))

	detail := signalToolItemCreateMenuProxyDetail{callback, handlerID}
	signalToolItemCreateMenuProxyMap[signalToolItemCreateMenuProxyId] = detail

	return signalToolItemCreateMenuProxyId
}

/*
DisconnectCreateMenuProxy disconnects a callback from the 'create-menu-proxy' signal for the ToolItem.

The connectionID should be a value returned from a call to ConnectCreateMenuProxy.
*/
func (recv *ToolItem) DisconnectCreateMenuProxy(connectionID int) {
	signalToolItemCreateMenuProxyLock.Lock()
	defer signalToolItemCreateMenuProxyLock.Unlock()

	detail, exists := signalToolItemCreateMenuProxyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolItemCreateMenuProxyMap, connectionID)
}

//export toolitem_createMenuProxyHandler
func toolitem_createMenuProxyHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalToolItemCreateMenuProxyMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalToolItemToolbarReconfiguredDetail struct {
	callback  ToolItemSignalToolbarReconfiguredCallback
	handlerID C.gulong
}

var signalToolItemToolbarReconfiguredId int
var signalToolItemToolbarReconfiguredMap = make(map[int]signalToolItemToolbarReconfiguredDetail)
var signalToolItemToolbarReconfiguredLock sync.Mutex

// ToolItemSignalToolbarReconfiguredCallback is a callback function for a 'toolbar-reconfigured' signal emitted from a ToolItem.
type ToolItemSignalToolbarReconfiguredCallback func()

/*
ConnectToolbarReconfigured connects the callback to the 'toolbar-reconfigured' signal for the ToolItem.

The returned value represents the connection, and may be passed to DisconnectToolbarReconfigured to remove it.
*/
func (recv *ToolItem) ConnectToolbarReconfigured(callback ToolItemSignalToolbarReconfiguredCallback) int {
	signalToolItemToolbarReconfiguredLock.Lock()
	defer signalToolItemToolbarReconfiguredLock.Unlock()

	signalToolItemToolbarReconfiguredId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolItem_signal_connect_toolbar_reconfigured(instance, C.gpointer(uintptr(signalToolItemToolbarReconfiguredId)))

	detail := signalToolItemToolbarReconfiguredDetail{callback, handlerID}
	signalToolItemToolbarReconfiguredMap[signalToolItemToolbarReconfiguredId] = detail

	return signalToolItemToolbarReconfiguredId
}

/*
DisconnectToolbarReconfigured disconnects a callback from the 'toolbar-reconfigured' signal for the ToolItem.

The connectionID should be a value returned from a call to ConnectToolbarReconfigured.
*/
func (recv *ToolItem) DisconnectToolbarReconfigured(connectionID int) {
	signalToolItemToolbarReconfiguredLock.Lock()
	defer signalToolItemToolbarReconfiguredLock.Unlock()

	detail, exists := signalToolItemToolbarReconfiguredMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolItemToolbarReconfiguredMap, connectionID)
}

//export toolitem_toolbarReconfiguredHandler
func toolitem_toolbarReconfiguredHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToolItemToolbarReconfiguredMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolItem
func (recv *ToolItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToolItem
func (recv *ToolItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolItem
func (recv *ToolItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A #GtkToolItemGroup is used together with #GtkToolPalette to add
// #GtkToolItems to a palette like container with different
// categories and drag and drop support.
//
// # CSS nodes
//
// GtkToolItemGroup has a single CSS node named toolitemgroup.
/*

C record/class : GtkToolItemGroup
*/
type ToolItemGroup struct {
	native *C.GtkToolItemGroup
	// parent_instance : record
	// priv : record
}

func ToolItemGroupNewFromC(u unsafe.Pointer) *ToolItemGroup {
	c := (*C.GtkToolItemGroup)(u)
	if c == nil {
		return nil
	}

	g := &ToolItemGroup{native: c}

	return g
}

func (recv *ToolItemGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *ToolItemGroup) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ToolItemGroup) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolItemGroup) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolItemGroup) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to ToolItemGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolItemGroup.
func CastToToolItemGroup(object *gobject.Object) *ToolItemGroup {
	return ToolItemGroupNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolItemGroup
func (recv *ToolItemGroup) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolItemGroup
func (recv *ToolItemGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolShell returns the ToolShell interface implemented by ToolItemGroup
func (recv *ToolItemGroup) ToolShell() *ToolShell {
	return ToolShellNewFromC(recv.ToC())
}

// A #GtkToolPalette allows you to add #GtkToolItems to a palette-like
// container with different categories and drag and drop support.
//
// A #GtkToolPalette is created with a call to gtk_tool_palette_new().
//
// #GtkToolItems cannot be added directly to a #GtkToolPalette -
// instead they are added to a #GtkToolItemGroup which can than be added
// to a #GtkToolPalette. To add a #GtkToolItemGroup to a #GtkToolPalette,
// use gtk_container_add().
//
// |[<!-- language="C" -->
// GtkWidget *palette, *group;
// GtkToolItem *item;
//
// palette = gtk_tool_palette_new ();
// group = gtk_tool_item_group_new (_("Test Category"));
// gtk_container_add (GTK_CONTAINER (palette), group);
//
// item = gtk_tool_button_new (NULL, _("_Open"));
// gtk_tool_button_set_icon_name (GTK_TOOL_BUTTON (item), "document-open");
// gtk_tool_item_group_insert (GTK_TOOL_ITEM_GROUP (group), item, -1);
// ]|
//
// The easiest way to use drag and drop with #GtkToolPalette is to call
// gtk_tool_palette_add_drag_dest() with the desired drag source @palette
// and the desired drag target @widget. Then gtk_tool_palette_get_drag_item()
// can be used to get the dragged item in the #GtkWidget::drag-data-received
// signal handler of the drag target.
//
// |[<!-- language="C" -->
// static void
// passive_canvas_drag_data_received (GtkWidget        *widget,
// GdkDragContext   *context,
// gint              x,
// gint              y,
// GtkSelectionData *selection,
// guint             info,
// guint             time,
// gpointer          data)
// {
// GtkWidget *palette;
// GtkWidget *item;
//
// Get the dragged item
// palette = gtk_widget_get_ancestor (gtk_drag_get_source_widget (context),
// GTK_TYPE_TOOL_PALETTE);
// if (palette != NULL)
// item = gtk_tool_palette_get_drag_item (GTK_TOOL_PALETTE (palette),
// selection);
//
// Do something with item
// }
//
// GtkWidget *target, palette;
//
// palette = gtk_tool_palette_new ();
// target = gtk_drawing_area_new ();
//
// g_signal_connect (G_OBJECT (target), "drag-data-received",
// G_CALLBACK (passive_canvas_drag_data_received), NULL);
// gtk_tool_palette_add_drag_dest (GTK_TOOL_PALETTE (palette), target,
// GTK_DEST_DEFAULT_ALL,
// GTK_TOOL_PALETTE_DRAG_ITEMS,
// GDK_ACTION_COPY);
// ]|
//
// # CSS nodes
//
// GtkToolPalette has a single CSS node named toolpalette.
/*

C record/class : GtkToolPalette
*/
type ToolPalette struct {
	native *C.GtkToolPalette
	// parent_instance : record
	// priv : record
}

func ToolPaletteNewFromC(u unsafe.Pointer) *ToolPalette {
	c := (*C.GtkToolPalette)(u)
	if c == nil {
		return nil
	}

	g := &ToolPalette{native: c}

	return g
}

func (recv *ToolPalette) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *ToolPalette) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ToolPalette) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolPalette) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolPalette) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to ToolPalette.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolPalette.
func CastToToolPalette(object *gobject.Object) *ToolPalette {
	return ToolPaletteNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolPalette
func (recv *ToolPalette) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolPalette
func (recv *ToolPalette) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ToolPalette
func (recv *ToolPalette) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by ToolPalette
func (recv *ToolPalette) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// A toolbar is created with a call to gtk_toolbar_new().
//
// A toolbar can contain instances of a subclass of #GtkToolItem. To add
// a #GtkToolItem to the a toolbar, use gtk_toolbar_insert(). To remove
// an item from the toolbar use gtk_container_remove(). To add a button
// to the toolbar, add an instance of #GtkToolButton.
//
// Toolbar items can be visually grouped by adding instances of
// #GtkSeparatorToolItem to the toolbar. If the GtkToolbar child property
// expand is #TRUE and the property #GtkSeparatorToolItem:draw is set to
// #FALSE, the effect is to force all following items to the end of the toolbar.
//
// By default, a toolbar can be shrunk, upon which it will add an arrow button
// to show an overflow menu offering access to any #GtkToolItem child that has
// a proxy menu item. To disable this and request enough size for all children,
// call gtk_toolbar_set_show_arrow() to set #GtkToolbar:show-arrow to %FALSE.
//
// Creating a context menu for the toolbar can be done by connecting to
// the #GtkToolbar::popup-context-menu signal.
//
// # CSS nodes
//
// GtkToolbar has a single CSS node with name toolbar.
/*

C record/class : GtkToolbar
*/
type Toolbar struct {
	native *C.GtkToolbar
	// container : record
	// priv : record
}

func ToolbarNewFromC(u unsafe.Pointer) *Toolbar {
	c := (*C.GtkToolbar)(u)
	if c == nil {
		return nil
	}

	g := &Toolbar{native: c}

	return g
}

func (recv *Toolbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Toolbar) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Toolbar) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Toolbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Toolbar) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Toolbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Toolbar.
func CastToToolbar(object *gobject.Object) *Toolbar {
	return ToolbarNewFromC(object.ToC())
}

type signalToolbarFocusHomeOrEndDetail struct {
	callback  ToolbarSignalFocusHomeOrEndCallback
	handlerID C.gulong
}

var signalToolbarFocusHomeOrEndId int
var signalToolbarFocusHomeOrEndMap = make(map[int]signalToolbarFocusHomeOrEndDetail)
var signalToolbarFocusHomeOrEndLock sync.Mutex

// ToolbarSignalFocusHomeOrEndCallback is a callback function for a 'focus-home-or-end' signal emitted from a Toolbar.
type ToolbarSignalFocusHomeOrEndCallback func(focusHome bool) bool

/*
ConnectFocusHomeOrEnd connects the callback to the 'focus-home-or-end' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectFocusHomeOrEnd to remove it.
*/
func (recv *Toolbar) ConnectFocusHomeOrEnd(callback ToolbarSignalFocusHomeOrEndCallback) int {
	signalToolbarFocusHomeOrEndLock.Lock()
	defer signalToolbarFocusHomeOrEndLock.Unlock()

	signalToolbarFocusHomeOrEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_focus_home_or_end(instance, C.gpointer(uintptr(signalToolbarFocusHomeOrEndId)))

	detail := signalToolbarFocusHomeOrEndDetail{callback, handlerID}
	signalToolbarFocusHomeOrEndMap[signalToolbarFocusHomeOrEndId] = detail

	return signalToolbarFocusHomeOrEndId
}

/*
DisconnectFocusHomeOrEnd disconnects a callback from the 'focus-home-or-end' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectFocusHomeOrEnd.
*/
func (recv *Toolbar) DisconnectFocusHomeOrEnd(connectionID int) {
	signalToolbarFocusHomeOrEndLock.Lock()
	defer signalToolbarFocusHomeOrEndLock.Unlock()

	detail, exists := signalToolbarFocusHomeOrEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarFocusHomeOrEndMap, connectionID)
}

//export toolbar_focusHomeOrEndHandler
func toolbar_focusHomeOrEndHandler(_ *C.GObject, c_focus_home C.gboolean, data C.gpointer) C.gboolean {
	focusHome := c_focus_home == C.TRUE

	index := int(uintptr(data))
	callback := signalToolbarFocusHomeOrEndMap[index].callback
	retGo := callback(focusHome)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'orientation-changed' for Toolbar : unsupported parameter orientation : type Orientation :

// Unsupported signal 'popup-context-menu' for Toolbar : unsupported parameter x : type gint :

// Unsupported signal 'style-changed' for Toolbar : unsupported parameter style : type ToolbarStyle :

// Creates a new toolbar.
/*

C function : gtk_toolbar_new
*/
func ToolbarNew() *Toolbar {
	retC := C.gtk_toolbar_new()
	retGo := ToolbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the icon size for the toolbar. See gtk_toolbar_set_icon_size().
/*

C function : gtk_toolbar_get_icon_size
*/
func (recv *Toolbar) GetIconSize() IconSize {
	retC := C.gtk_toolbar_get_icon_size((*C.GtkToolbar)(recv.native))
	retGo := (IconSize)(retC)

	return retGo
}

// Retrieves whether the toolbar has text, icons, or both . See
// gtk_toolbar_set_style().
/*

C function : gtk_toolbar_get_style
*/
func (recv *Toolbar) GetStyle() ToolbarStyle {
	retC := C.gtk_toolbar_get_style((*C.GtkToolbar)(recv.native))
	retGo := (ToolbarStyle)(retC)

	return retGo
}

// This function sets the size of stock icons in the toolbar. You
// can call it both before you add the icons and after theyve been
// added. The size you set will override user preferences for the default
// icon size.
//
// This should only be used for special-purpose toolbars, normal
// application toolbars should respect the user preferences for the
// size of icons.
/*

C function : gtk_toolbar_set_icon_size
*/
func (recv *Toolbar) SetIconSize(iconSize IconSize) {
	c_icon_size := (C.GtkIconSize)(iconSize)

	C.gtk_toolbar_set_icon_size((*C.GtkToolbar)(recv.native), c_icon_size)

	return
}

// Alters the view of @toolbar to display either icons only, text only, or both.
/*

C function : gtk_toolbar_set_style
*/
func (recv *Toolbar) SetStyle(style ToolbarStyle) {
	c_style := (C.GtkToolbarStyle)(style)

	C.gtk_toolbar_set_style((*C.GtkToolbar)(recv.native), c_style)

	return
}

// Unsets toolbar icon size set with gtk_toolbar_set_icon_size(), so that
// user preferences will be used to determine the icon size.
/*

C function : gtk_toolbar_unset_icon_size
*/
func (recv *Toolbar) UnsetIconSize() {
	C.gtk_toolbar_unset_icon_size((*C.GtkToolbar)(recv.native))

	return
}

// Unsets a toolbar style set with gtk_toolbar_set_style(), so that
// user preferences will be used to determine the toolbar style.
/*

C function : gtk_toolbar_unset_style
*/
func (recv *Toolbar) UnsetStyle() {
	C.gtk_toolbar_unset_style((*C.GtkToolbar)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Toolbar
func (recv *Toolbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Toolbar
func (recv *Toolbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Toolbar
func (recv *Toolbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ToolShell returns the ToolShell interface implemented by Toolbar
func (recv *Toolbar) ToolShell() *ToolShell {
	return ToolShellNewFromC(recv.ToC())
}

// Basic tooltips can be realized simply by using gtk_widget_set_tooltip_text()
// or gtk_widget_set_tooltip_markup() without any explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per #GtkTreeView
// row or cell, you will have to do a little more work:
//
// - Set the #GtkWidget:has-tooltip property to %TRUE, this will make GTK+
// monitor the widget for motion and related events which are needed to
// determine when and where to show a tooltip.
//
// - Connect to the #GtkWidget::query-tooltip signal.  This signal will be
// emitted when a tooltip is supposed to be shown. One of the arguments passed
// to the signal handler is a GtkTooltip object. This is the object that we
// are about to display as a tooltip, and can be manipulated in your callback
// using functions like gtk_tooltip_set_icon(). There are functions for setting
// the tooltips markup, setting an image from a named icon, or even putting in
// a custom widget.
//
// Return %TRUE from your query-tooltip handler. This causes the tooltip to be
// show. If you return %FALSE, it will not be shown.
//
// In the probably rare case where you want to have even more control over the
// tooltip that is about to be shown, you can set your own #GtkWindow which
// will be used as tooltip window.  This works as follows:
//
// - Set #GtkWidget:has-tooltip and connect to #GtkWidget::query-tooltip as before.
// Use gtk_widget_set_tooltip_window() to set a #GtkWindow created by you as
// tooltip window.
//
// - In the #GtkWidget::query-tooltip callback you can access your window using
// gtk_widget_get_tooltip_window() and manipulate as you wish. The semantics of
// the return value are exactly as before, return %TRUE to show the window,
// %FALSE to not show it.
/*

C record/class : GtkTooltip
*/
type Tooltip struct {
	native *C.GtkTooltip
}

func TooltipNewFromC(u unsafe.Pointer) *Tooltip {
	c := (*C.GtkTooltip)(u)
	if c == nil {
		return nil
	}

	g := &Tooltip{native: c}

	return g
}

func (recv *Tooltip) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Tooltip) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Tooltip.
// Exercise care, as this is a potentially dangerous function if the Object is not a Tooltip.
func CastToTooltip(object *gobject.Object) *Tooltip {
	return TooltipNewFromC(object.ToC())
}

/*

C record/class : GtkToplevelAccessible
*/
type ToplevelAccessible struct {
	native *C.GtkToplevelAccessible
	// parent : record
	// priv : record
}

func ToplevelAccessibleNewFromC(u unsafe.Pointer) *ToplevelAccessible {
	c := (*C.GtkToplevelAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ToplevelAccessible{native: c}

	return g
}

func (recv *ToplevelAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *ToplevelAccessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to ToplevelAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToplevelAccessible.
func CastToToplevelAccessible(object *gobject.Object) *ToplevelAccessible {
	return ToplevelAccessibleNewFromC(object.ToC())
}

/*

C function : gtk_toplevel_accessible_get_children
*/
func (recv *ToplevelAccessible) GetChildren() *glib.List {
	retC := C.gtk_toplevel_accessible_get_children((*C.GtkToplevelAccessible)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// A #GtkTreeModelFilter is a tree model which wraps another tree model,
// and can do the following things:
//
// - Filter specific rows, based on data from a visible column, a column
// storing booleans indicating whether the row should be filtered or not,
// or based on the return value of a visible function, which gets a
// model, iter and user_data and returns a boolean indicating whether the
// row should be filtered or not.
//
// - Modify the appearance of the model, using a modify function.
// This is extremely powerful and allows for just changing some
// values and also for creating a completely different model based
// on the given child model.
//
// - Set a different root node, also known as a virtual root. You can pass
// in a #GtkTreePath indicating the root node for the filter at construction
// time.
//
// The basic API is similar to #GtkTreeModelSort. For an example on its usage,
// see the section on #GtkTreeModelSort.
//
// When using #GtkTreeModelFilter, it is important to realize that
// #GtkTreeModelFilter maintains an internal cache of all nodes which are
// visible in its clients. The cache is likely to be a subtree of the tree
// exposed by the child model. #GtkTreeModelFilter will not cache the entire
// child model when unnecessary to not compromise the caching mechanism
// that is exposed by the reference counting scheme. If the child model
// implements reference counting, unnecessary signals may not be emitted
// because of reference counting rule 3, see the #GtkTreeModel
// documentation. (Note that e.g. #GtkTreeStore does not implement
// reference counting and will always emit all signals, even when
// the receiving node is not visible).
//
// Because of this, limitations for possible visible functions do apply.
// In general, visible functions should only use data or properties from
// the node for which the visibility state must be determined, its siblings
// or its parents. Usually, having a dependency on the state of any child
// node is not possible, unless references are taken on these explicitly.
// When no such reference exists, no signals may be received for these child
// nodes (see reference couting rule number 3 in the #GtkTreeModel section).
//
// Determining the visibility state of a given node based on the state
// of its child nodes is a frequently occurring use case. Therefore,
// #GtkTreeModelFilter explicitly supports this. For example, when a node
// does not have any children, you might not want the node to be visible.
// As soon as the first row is added to the nodes child level (or the
// last row removed), the nodes visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order
// to accommodate this, #GtkTreeModelFilter must make sure the necessary
// signals are received from the child model. This is achieved by building,
// for all nodes which are exposed as visible nodes to #GtkTreeModelFilter's
// clients, the child level (if any) and take a reference on the first node
// in this level. Furthermore, for every row-inserted, row-changed or
// row-deleted signal (also these which were not handled because the node
// was not cached), #GtkTreeModelFilter will check if the visibility state
// of any parent node has changed.
//
// Beware, however, that this explicit support is limited to these two
// cases. For example, if you want a node to be visible only if two nodes
// in a childs child level (2 levels deeper) are visible, you are on your
// own. In this case, either rely on #GtkTreeStore to emit all signals
// because it does not implement reference counting, or for models that
// do implement reference counting, obtain references on these child levels
// yourself.
/*

C record/class : GtkTreeModelFilter
*/
type TreeModelFilter struct {
	native *C.GtkTreeModelFilter
	// parent : record
	// Private : priv
}

func TreeModelFilterNewFromC(u unsafe.Pointer) *TreeModelFilter {
	c := (*C.GtkTreeModelFilter)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelFilter{native: c}

	return g
}

func (recv *TreeModelFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TreeModelFilter) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TreeModelFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeModelFilter.
func CastToTreeModelFilter(object *gobject.Object) *TreeModelFilter {
	return TreeModelFilterNewFromC(object.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeModelFilter
func (recv *TreeModelFilter) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeModelFilter
func (recv *TreeModelFilter) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// The #GtkTreeModelSort is a model which implements the #GtkTreeSortable
// interface.  It does not hold any data itself, but rather is created with
// a child model and proxies its data.  It has identical column types to
// this child model, and the changes in the child are propagated.  The
// primary purpose of this model is to provide a way to sort a different
// model without modifying it. Note that the sort function used by
// #GtkTreeModelSort is not guaranteed to be stable.
//
// The use of this is best demonstrated through an example.  In the
// following sample code we create two #GtkTreeView widgets each with a
// view of the same data.  As the model is wrapped here by a
// #GtkTreeModelSort, the two #GtkTreeViews can each sort their
// view of the data without affecting the other.  By contrast, if we
// simply put the same model in each widget, then sorting the first would
// sort the second.
//
// ## Using a #GtkTreeModelSort
//
// |[<!-- language="C" -->
// {
// GtkTreeView *tree_view1;
// GtkTreeView *tree_view2;
// GtkTreeModel *sort_model1;
// GtkTreeModel *sort_model2;
// GtkTreeModel *child_model;
//
// get the child model
// child_model = get_my_model ();
//
// Create the first tree
// sort_model1 = gtk_tree_model_sort_new_with_model (child_model);
// tree_view1 = gtk_tree_view_new_with_model (sort_model1);
//
// Create the second tree
// sort_model2 = gtk_tree_model_sort_new_with_model (child_model);
// tree_view2 = gtk_tree_view_new_with_model (sort_model2);
//
// Now we can sort the two models independently
// gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model1),
// COLUMN_1, GTK_SORT_ASCENDING);
// gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (sort_model2),
// COLUMN_1, GTK_SORT_DESCENDING);
// }
// ]|
//
// To demonstrate how to access the underlying child model from the sort
// model, the next example will be a callback for the #GtkTreeSelection
// #GtkTreeSelection::changed signal.  In this callback, we get a string
// from COLUMN_1 of the model.  We then modify the string, find the same
// selected row on the child model, and change the row there.
//
// ## Accessing the child model of in a selection changed callback
//
// |[<!-- language="C" -->
// void
// selection_changed (GtkTreeSelection *selection, gpointer data)
// {
// GtkTreeModel *sort_model = NULL;
// GtkTreeModel *child_model;
// GtkTreeIter sort_iter;
// GtkTreeIter child_iter;
// char *some_data = NULL;
// char *modified_data;
//
// Get the current selected row and the model.
// if (! gtk_tree_selection_get_selected (selection,
// &sort_model,
// &sort_iter))
// return;
//
// Look up the current value on the selected row and get
// a new value to change it to.
// gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
// COLUMN_1, &some_data,
// -1);
//
// modified_data = change_the_data (some_data);
// g_free (some_data);
//
// Get an iterator on the child model, instead of the sort model.
// gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
// &child_iter,
// &sort_iter);
//
// Get the child model and change the value of the row. In this
// example, the child model is a GtkListStore. It could be any other
// type of model, though.
// child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
// gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
// COLUMN_1, &modified_data,
// -1);
// g_free (modified_data);
// }
// ]|
/*

C record/class : GtkTreeModelSort
*/
type TreeModelSort struct {
	native *C.GtkTreeModelSort
	// parent : record
	// Private : priv
}

func TreeModelSortNewFromC(u unsafe.Pointer) *TreeModelSort {
	c := (*C.GtkTreeModelSort)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelSort{native: c}

	return g
}

func (recv *TreeModelSort) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TreeModelSort) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TreeModelSort.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeModelSort.
func CastToTreeModelSort(object *gobject.Object) *TreeModelSort {
	return TreeModelSortNewFromC(object.ToC())
}

// This function should almost never be called.  It clears the @tree_model_sort
// of any cached iterators that havent been reffed with
// gtk_tree_model_ref_node().  This might be useful if the child model being
// sorted is static (and doesnt change often) and there has been a lot of
// unreffed access to nodes.  As a side effect of this function, all unreffed
// iters will be invalid.
/*

C function : gtk_tree_model_sort_clear_cache
*/
func (recv *TreeModelSort) ClearCache() {
	C.gtk_tree_model_sort_clear_cache((*C.GtkTreeModelSort)(recv.native))

	return
}

// Sets @sort_iter to point to the row in @tree_model_sort that corresponds to
// the row pointed at by @child_iter.  If @sort_iter was not set, %FALSE
// is returned.  Note: a boolean is only returned since 2.14.
/*

C function : gtk_tree_model_sort_convert_child_iter_to_iter
*/
func (recv *TreeModelSort) ConvertChildIterToIter(childIter *TreeIter) (bool, *TreeIter) {
	var c_sort_iter C.GtkTreeIter

	c_child_iter := (*C.GtkTreeIter)(C.NULL)
	if childIter != nil {
		c_child_iter = (*C.GtkTreeIter)(childIter.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_child_iter_to_iter((*C.GtkTreeModelSort)(recv.native), &c_sort_iter, c_child_iter)
	retGo := retC == C.TRUE

	sortIter := TreeIterNewFromC(unsafe.Pointer(&c_sort_iter))

	return retGo, sortIter
}

// Converts @child_path to a path relative to @tree_model_sort.  That is,
// @child_path points to a path in the child model.  The returned path will
// point to the same row in the sorted model.  If @child_path isnt a valid
// path on the child model, then %NULL is returned.
/*

C function : gtk_tree_model_sort_convert_child_path_to_path
*/
func (recv *TreeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	c_child_path := (*C.GtkTreePath)(C.NULL)
	if childPath != nil {
		c_child_path = (*C.GtkTreePath)(childPath.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_child_path_to_path((*C.GtkTreeModelSort)(recv.native), c_child_path)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Sets @child_iter to point to the row pointed to by @sorted_iter.
/*

C function : gtk_tree_model_sort_convert_iter_to_child_iter
*/
func (recv *TreeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) *TreeIter {
	var c_child_iter C.GtkTreeIter

	c_sorted_iter := (*C.GtkTreeIter)(C.NULL)
	if sortedIter != nil {
		c_sorted_iter = (*C.GtkTreeIter)(sortedIter.ToC())
	}

	C.gtk_tree_model_sort_convert_iter_to_child_iter((*C.GtkTreeModelSort)(recv.native), &c_child_iter, c_sorted_iter)

	childIter := TreeIterNewFromC(unsafe.Pointer(&c_child_iter))

	return childIter
}

// Converts @sorted_path to a path on the child model of @tree_model_sort.
// That is, @sorted_path points to a location in @tree_model_sort.  The
// returned path will point to the same location in the model not being
// sorted.  If @sorted_path does not point to a location in the child model,
// %NULL is returned.
/*

C function : gtk_tree_model_sort_convert_path_to_child_path
*/
func (recv *TreeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
	c_sorted_path := (*C.GtkTreePath)(C.NULL)
	if sortedPath != nil {
		c_sorted_path = (*C.GtkTreePath)(sortedPath.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_path_to_child_path((*C.GtkTreeModelSort)(recv.native), c_sorted_path)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the model the #GtkTreeModelSort is sorting.
/*

C function : gtk_tree_model_sort_get_model
*/
func (recv *TreeModelSort) GetModel() *TreeModel {
	retC := C.gtk_tree_model_sort_get_model((*C.GtkTreeModelSort)(recv.native))
	retGo := TreeModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This resets the default sort function to be in the unsorted state.  That
// is, it is in the same order as the child model. It will re-sort the model
// to be in the same order as the child model only if the #GtkTreeModelSort
// is in unsorted state.
/*

C function : gtk_tree_model_sort_reset_default_sort_func
*/
func (recv *TreeModelSort) ResetDefaultSortFunc() {
	C.gtk_tree_model_sort_reset_default_sort_func((*C.GtkTreeModelSort)(recv.native))

	return
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// The #GtkTreeSelection object is a helper object to manage the selection
// for a #GtkTreeView widget.  The #GtkTreeSelection object is
// automatically created when a new #GtkTreeView widget is created, and
// cannot exist independently of this widget.  The primary reason the
// #GtkTreeSelection objects exists is for cleanliness of code and API.
// That is, there is no conceptual reason all these functions could not be
// methods on the #GtkTreeView widget instead of a separate function.
//
// The #GtkTreeSelection object is gotten from a #GtkTreeView by calling
// gtk_tree_view_get_selection().  It can be manipulated to check the
// selection status of the tree, as well as select and deselect individual
// rows.  Selection is done completely view side.  As a result, multiple
// views of the same model can have completely different selections.
// Additionally, you cannot change the selection of a row on the model that
// is not currently displayed by the view without expanding its parents
// first.
//
// One of the important things to remember when monitoring the selection of
// a view is that the #GtkTreeSelection::changed signal is mostly a hint.
// That is, it may only emit one signal when a range of rows is selected.
// Additionally, it may on occasion emit a #GtkTreeSelection::changed signal
// when nothing has happened (mostly as a result of programmers calling
// select_row on an already selected row).
/*

C record/class : GtkTreeSelection
*/
type TreeSelection struct {
	native *C.GtkTreeSelection
	// Private : parent
	// Private : priv
}

func TreeSelectionNewFromC(u unsafe.Pointer) *TreeSelection {
	c := (*C.GtkTreeSelection)(u)
	if c == nil {
		return nil
	}

	g := &TreeSelection{native: c}

	return g
}

func (recv *TreeSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TreeSelection) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TreeSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeSelection.
func CastToTreeSelection(object *gobject.Object) *TreeSelection {
	return TreeSelectionNewFromC(object.ToC())
}

type signalTreeSelectionChangedDetail struct {
	callback  TreeSelectionSignalChangedCallback
	handlerID C.gulong
}

var signalTreeSelectionChangedId int
var signalTreeSelectionChangedMap = make(map[int]signalTreeSelectionChangedDetail)
var signalTreeSelectionChangedLock sync.Mutex

// TreeSelectionSignalChangedCallback is a callback function for a 'changed' signal emitted from a TreeSelection.
type TreeSelectionSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the TreeSelection.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *TreeSelection) ConnectChanged(callback TreeSelectionSignalChangedCallback) int {
	signalTreeSelectionChangedLock.Lock()
	defer signalTreeSelectionChangedLock.Unlock()

	signalTreeSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeSelection_signal_connect_changed(instance, C.gpointer(uintptr(signalTreeSelectionChangedId)))

	detail := signalTreeSelectionChangedDetail{callback, handlerID}
	signalTreeSelectionChangedMap[signalTreeSelectionChangedId] = detail

	return signalTreeSelectionChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the TreeSelection.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *TreeSelection) DisconnectChanged(connectionID int) {
	signalTreeSelectionChangedLock.Lock()
	defer signalTreeSelectionChangedLock.Unlock()

	detail, exists := signalTreeSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeSelectionChangedMap, connectionID)
}

//export treeselection_changedHandler
func treeselection_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTreeSelectionChangedMap[index].callback
	callback()
}

// Gets the selection mode for @selection. See
// gtk_tree_selection_set_mode().
/*

C function : gtk_tree_selection_get_mode
*/
func (recv *TreeSelection) GetMode() SelectionMode {
	retC := C.gtk_tree_selection_get_mode((*C.GtkTreeSelection)(recv.native))
	retGo := (SelectionMode)(retC)

	return retGo
}

// Sets @iter to the currently selected node if @selection is set to
// #GTK_SELECTION_SINGLE or #GTK_SELECTION_BROWSE.  @iter may be NULL if you
// just want to test if @selection has any selected nodes.  @model is filled
// with the current model as a convenience.  This function will not work if you
// use @selection is #GTK_SELECTION_MULTIPLE.
/*

C function : gtk_tree_selection_get_selected
*/
func (recv *TreeSelection) GetSelected() (bool, *TreeModel, *TreeIter) {
	var c_model *C.GtkTreeModel

	var c_iter C.GtkTreeIter

	retC := C.gtk_tree_selection_get_selected((*C.GtkTreeSelection)(recv.native), &c_model, &c_iter)
	retGo := retC == C.TRUE

	model := TreeModelNewFromC(unsafe.Pointer(c_model))

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, model, iter
}

// Returns the tree view associated with @selection.
/*

C function : gtk_tree_selection_get_tree_view
*/
func (recv *TreeSelection) GetTreeView() *TreeView {
	retC := C.gtk_tree_selection_get_tree_view((*C.GtkTreeSelection)(recv.native))
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the user data for the selection function.
/*

C function : gtk_tree_selection_get_user_data
*/
func (recv *TreeSelection) GetUserData() uintptr {
	retC := C.gtk_tree_selection_get_user_data((*C.GtkTreeSelection)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if the row at @iter is currently selected.
/*

C function : gtk_tree_selection_iter_is_selected
*/
func (recv *TreeSelection) IterIsSelected(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_selection_iter_is_selected((*C.GtkTreeSelection)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Returns %TRUE if the row pointed to by @path is currently selected.  If @path
// does not point to a valid location, %FALSE is returned
/*

C function : gtk_tree_selection_path_is_selected
*/
func (recv *TreeSelection) PathIsSelected(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_selection_path_is_selected((*C.GtkTreeSelection)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// Selects all the nodes. @selection must be set to #GTK_SELECTION_MULTIPLE
// mode.
/*

C function : gtk_tree_selection_select_all
*/
func (recv *TreeSelection) SelectAll() {
	C.gtk_tree_selection_select_all((*C.GtkTreeSelection)(recv.native))

	return
}

// Selects the specified iterator.
/*

C function : gtk_tree_selection_select_iter
*/
func (recv *TreeSelection) SelectIter(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_selection_select_iter((*C.GtkTreeSelection)(recv.native), c_iter)

	return
}

// Select the row at @path.
/*

C function : gtk_tree_selection_select_path
*/
func (recv *TreeSelection) SelectPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_selection_select_path((*C.GtkTreeSelection)(recv.native), c_path)

	return
}

// Selects a range of nodes, determined by @start_path and @end_path inclusive.
// @selection must be set to #GTK_SELECTION_MULTIPLE mode.
/*

C function : gtk_tree_selection_select_range
*/
func (recv *TreeSelection) SelectRange(startPath *TreePath, endPath *TreePath) {
	c_start_path := (*C.GtkTreePath)(C.NULL)
	if startPath != nil {
		c_start_path = (*C.GtkTreePath)(startPath.ToC())
	}

	c_end_path := (*C.GtkTreePath)(C.NULL)
	if endPath != nil {
		c_end_path = (*C.GtkTreePath)(endPath.ToC())
	}

	C.gtk_tree_selection_select_range((*C.GtkTreeSelection)(recv.native), c_start_path, c_end_path)

	return
}

// Unsupported : gtk_tree_selection_selected_foreach : unsupported parameter func : no type generator for TreeSelectionForeachFunc (GtkTreeSelectionForeachFunc) for param func

// Sets the selection mode of the @selection.  If the previous type was
// #GTK_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
// previously selected.
/*

C function : gtk_tree_selection_set_mode
*/
func (recv *TreeSelection) SetMode(type_ SelectionMode) {
	c_type := (C.GtkSelectionMode)(type_)

	C.gtk_tree_selection_set_mode((*C.GtkTreeSelection)(recv.native), c_type)

	return
}

// Unsupported : gtk_tree_selection_set_select_function : unsupported parameter func : no type generator for TreeSelectionFunc (GtkTreeSelectionFunc) for param func

// Unselects all the nodes.
/*

C function : gtk_tree_selection_unselect_all
*/
func (recv *TreeSelection) UnselectAll() {
	C.gtk_tree_selection_unselect_all((*C.GtkTreeSelection)(recv.native))

	return
}

// Unselects the specified iterator.
/*

C function : gtk_tree_selection_unselect_iter
*/
func (recv *TreeSelection) UnselectIter(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_selection_unselect_iter((*C.GtkTreeSelection)(recv.native), c_iter)

	return
}

// Unselects the row at @path.
/*

C function : gtk_tree_selection_unselect_path
*/
func (recv *TreeSelection) UnselectPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_selection_unselect_path((*C.GtkTreeSelection)(recv.native), c_path)

	return
}

// The #GtkTreeStore object is a list model for use with a #GtkTreeView
// widget.  It implements the #GtkTreeModel interface, and consequentially,
// can use all of the methods available there.  It also implements the
// #GtkTreeSortable interface so it can be sorted by the view.  Finally,
// it also implements the tree
// [drag and drop][gtk3-GtkTreeView-drag-and-drop]
// interfaces.
//
// # GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the #GtkBuildable interface allows
// to specify the model columns with a <columns> element that may contain
// multiple <column> elements, each specifying one model column. The type
// attribute specifies the data type for the column.
//
// An example of a UI Definition fragment for a tree store:
// |[
// <object class="GtkTreeStore">
// <columns>
// <column type="gchararray"/>
// <column type="gchararray"/>
// <column type="gint"/>
// </columns>
// </object>
// ]|
/*

C record/class : GtkTreeStore
*/
type TreeStore struct {
	native *C.GtkTreeStore
	// parent : record
	// priv : record
}

func TreeStoreNewFromC(u unsafe.Pointer) *TreeStore {
	c := (*C.GtkTreeStore)(u)
	if c == nil {
		return nil
	}

	g := &TreeStore{native: c}

	return g
}

func (recv *TreeStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TreeStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TreeStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeStore.
func CastToTreeStore(object *gobject.Object) *TreeStore {
	return TreeStoreNewFromC(object.ToC())
}

// Unsupported : gtk_tree_store_new : unsupported parameter ... : varargs

// Non vararg creation function.  Used primarily by language bindings.
/*

C function : gtk_tree_store_newv
*/
func TreeStoreNewv(types []gobject.Type) *TreeStore {
	c_n_columns := (C.gint)(len(types))

	c_types := &types[0]

	retC := C.gtk_tree_store_newv(c_n_columns, (*C.GType)(unsafe.Pointer(c_types)))
	retGo := TreeStoreNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Appends a new row to @tree_store.  If @parent is non-%NULL, then it will append the
// new row after the last child of @parent, otherwise it will append a row to
// the top level.  @iter will be changed to point to this new row.  The row will
// be empty after this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
/*

C function : gtk_tree_store_append
*/
func (recv *TreeStore) Append(parent *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	C.gtk_tree_store_append((*C.GtkTreeStore)(recv.native), &c_iter, c_parent)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Removes all rows from @tree_store
/*

C function : gtk_tree_store_clear
*/
func (recv *TreeStore) Clear() {
	C.gtk_tree_store_clear((*C.GtkTreeStore)(recv.native))

	return
}

// Creates a new row at @position.  If parent is non-%NULL, then the row will be
// made a child of @parent.  Otherwise, the row will be created at the toplevel.
// If @position is -1 or is larger than the number of rows at that level, then
// the new row will be inserted to the end of the list.  @iter will be changed
// to point to this new row.  The row will be empty after this function is
// called.  To fill in values, you need to call gtk_tree_store_set() or
// gtk_tree_store_set_value().
/*

C function : gtk_tree_store_insert
*/
func (recv *TreeStore) Insert(parent *TreeIter, position int32) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_tree_store_insert((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_position)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Inserts a new row after @sibling.  If @sibling is %NULL, then the row will be
// prepended to @parent s children.  If @parent and @sibling are %NULL, then
// the row will be prepended to the toplevel.  If both @sibling and @parent are
// set, then @parent must be the parent of @sibling.  When @sibling is set,
// @parent is optional.
//
// @iter will be changed to point to this new row.  The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
/*

C function : gtk_tree_store_insert_after
*/
func (recv *TreeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_tree_store_insert_after((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Inserts a new row before @sibling.  If @sibling is %NULL, then the row will
// be appended to @parent s children.  If @parent and @sibling are %NULL, then
// the row will be appended to the toplevel.  If both @sibling and @parent are
// set, then @parent must be the parent of @sibling.  When @sibling is set,
// @parent is optional.
//
// @iter will be changed to point to this new row.  The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
/*

C function : gtk_tree_store_insert_before
*/
func (recv *TreeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_tree_store_insert_before((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Returns %TRUE if @iter is an ancestor of @descendant.  That is, @iter is the
// parent (or grandparent or great-grandparent) of @descendant.
/*

C function : gtk_tree_store_is_ancestor
*/
func (recv *TreeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_descendant := (*C.GtkTreeIter)(C.NULL)
	if descendant != nil {
		c_descendant = (*C.GtkTreeIter)(descendant.ToC())
	}

	retC := C.gtk_tree_store_is_ancestor((*C.GtkTreeStore)(recv.native), c_iter, c_descendant)
	retGo := retC == C.TRUE

	return retGo
}

// Returns the depth of @iter.  This will be 0 for anything on the root level, 1
// for anything down a level, etc.
/*

C function : gtk_tree_store_iter_depth
*/
func (recv *TreeStore) IterDepth(iter *TreeIter) int32 {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_store_iter_depth((*C.GtkTreeStore)(recv.native), c_iter)
	retGo := (int32)(retC)

	return retGo
}

// Prepends a new row to @tree_store.  If @parent is non-%NULL, then it will prepend
// the new row before the first child of @parent, otherwise it will prepend a row
// to the top level.  @iter will be changed to point to this new row.  The row
// will be empty after this function is called.  To fill in values, you need to
// call gtk_tree_store_set() or gtk_tree_store_set_value().
/*

C function : gtk_tree_store_prepend
*/
func (recv *TreeStore) Prepend(parent *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	C.gtk_tree_store_prepend((*C.GtkTreeStore)(recv.native), &c_iter, c_parent)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Removes @iter from @tree_store.  After being removed, @iter is set to the
// next valid row at that level, or invalidated if it previously pointed to the
// last one.
/*

C function : gtk_tree_store_remove
*/
func (recv *TreeStore) Remove(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_store_remove((*C.GtkTreeStore)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_tree_store_set : unsupported parameter ... : varargs

// This function is meant primarily for #GObjects that inherit from
// #GtkTreeStore, and should only be used when constructing a new
// #GtkTreeStore.  It will not function after a row has been added,
// or a method on the #GtkTreeModel interface is called.
/*

C function : gtk_tree_store_set_column_types
*/
func (recv *TreeStore) SetColumnTypes(types []gobject.Type) {
	c_n_columns := (C.gint)(len(types))

	c_types := &types[0]

	C.gtk_tree_store_set_column_types((*C.GtkTreeStore)(recv.native), c_n_columns, (*C.GType)(unsafe.Pointer(c_types)))

	return
}

// Unsupported : gtk_tree_store_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Sets the data in the cell specified by @iter and @column.
// The type of @value must be convertible to the type of the
// column.
/*

C function : gtk_tree_store_set_value
*/
func (recv *TreeStore) SetValue(iter *TreeIter, column int32, value *gobject.Value) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_column := (C.gint)(column)

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_tree_store_set_value((*C.GtkTreeStore)(recv.native), c_iter, c_column, c_value)

	return
}

// Buildable returns the Buildable interface implemented by TreeStore
func (recv *TreeStore) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TreeDragDest returns the TreeDragDest interface implemented by TreeStore
func (recv *TreeStore) TreeDragDest() *TreeDragDest {
	return TreeDragDestNewFromC(recv.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeStore
func (recv *TreeStore) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeStore
func (recv *TreeStore) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by TreeStore
func (recv *TreeStore) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// Widget that displays any object that implements the #GtkTreeModel interface.
//
// Please refer to the
// [tree widget conceptual overview][TreeWidget]
// for an overview of all the objects and data types related
// to the tree widget and how they work together.
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ![](tree-view-coordinates.png)
//
// Coordinate systems in GtkTreeView API:
//
// - Widget coordinates: Coordinates relative to the widget (usually `widget->window`).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of GtkTreeView. These
// coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems.  The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use gtk_tree_view_convert_widget_to_bin_window_coords()
// (and vice versa), for the latter gtk_tree_view_convert_bin_window_to_tree_coords()
// (and vice versa).
//
// # GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// #GtkTreeViewColumn objects as <child> elements and exposes the internal
// #GtkTreeSelection in UI definitions.
//
// An example of a UI definition fragment with GtkTreeView:
// |[
// <object class="GtkTreeView" id="treeview">
// <property name="model">liststore1</property>
// <child>
// <object class="GtkTreeViewColumn" id="test-column">
// <property name="title">Test</property>
// <child>
// <object class="GtkCellRendererText" id="test-renderer"/>
// <attributes>
// <attribute name="text">1</attribute>
// </attributes>
// </child>
// </object>
// </child>
// <child internal-child="selection">
// <object class="GtkTreeSelection" id="selection">
// <signal name="changed" handler="on_treeview_selection_changed"/>
// </object>
// </child>
// </object>
// ]|
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// treeview.view
//  header
//     <column header>
//    
//     <column header>
// 
//  [rubberband]
// ]|
//
// GtkTreeView has a main CSS node with name treeview and style class .view.
// It has a subnode with name header, which is the parent for all the column
// header widgets' CSS nodes.
// For rubberband selection, a subnode with name rubberband is used.
/*

C record/class : GtkTreeView
*/
type TreeView struct {
	native *C.GtkTreeView
	// parent : record
	// Private : priv
}

func TreeViewNewFromC(u unsafe.Pointer) *TreeView {
	c := (*C.GtkTreeView)(u)
	if c == nil {
		return nil
	}

	g := &TreeView{native: c}

	return g
}

func (recv *TreeView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *TreeView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *TreeView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TreeView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TreeView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to TreeView.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeView.
func CastToTreeView(object *gobject.Object) *TreeView {
	return TreeViewNewFromC(object.ToC())
}

type signalTreeViewColumnsChangedDetail struct {
	callback  TreeViewSignalColumnsChangedCallback
	handlerID C.gulong
}

var signalTreeViewColumnsChangedId int
var signalTreeViewColumnsChangedMap = make(map[int]signalTreeViewColumnsChangedDetail)
var signalTreeViewColumnsChangedLock sync.Mutex

// TreeViewSignalColumnsChangedCallback is a callback function for a 'columns-changed' signal emitted from a TreeView.
type TreeViewSignalColumnsChangedCallback func()

/*
ConnectColumnsChanged connects the callback to the 'columns-changed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectColumnsChanged to remove it.
*/
func (recv *TreeView) ConnectColumnsChanged(callback TreeViewSignalColumnsChangedCallback) int {
	signalTreeViewColumnsChangedLock.Lock()
	defer signalTreeViewColumnsChangedLock.Unlock()

	signalTreeViewColumnsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_columns_changed(instance, C.gpointer(uintptr(signalTreeViewColumnsChangedId)))

	detail := signalTreeViewColumnsChangedDetail{callback, handlerID}
	signalTreeViewColumnsChangedMap[signalTreeViewColumnsChangedId] = detail

	return signalTreeViewColumnsChangedId
}

/*
DisconnectColumnsChanged disconnects a callback from the 'columns-changed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectColumnsChanged.
*/
func (recv *TreeView) DisconnectColumnsChanged(connectionID int) {
	signalTreeViewColumnsChangedLock.Lock()
	defer signalTreeViewColumnsChangedLock.Unlock()

	detail, exists := signalTreeViewColumnsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewColumnsChangedMap, connectionID)
}

//export treeview_columnsChangedHandler
func treeview_columnsChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTreeViewColumnsChangedMap[index].callback
	callback()
}

type signalTreeViewCursorChangedDetail struct {
	callback  TreeViewSignalCursorChangedCallback
	handlerID C.gulong
}

var signalTreeViewCursorChangedId int
var signalTreeViewCursorChangedMap = make(map[int]signalTreeViewCursorChangedDetail)
var signalTreeViewCursorChangedLock sync.Mutex

// TreeViewSignalCursorChangedCallback is a callback function for a 'cursor-changed' signal emitted from a TreeView.
type TreeViewSignalCursorChangedCallback func()

/*
ConnectCursorChanged connects the callback to the 'cursor-changed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectCursorChanged to remove it.
*/
func (recv *TreeView) ConnectCursorChanged(callback TreeViewSignalCursorChangedCallback) int {
	signalTreeViewCursorChangedLock.Lock()
	defer signalTreeViewCursorChangedLock.Unlock()

	signalTreeViewCursorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_cursor_changed(instance, C.gpointer(uintptr(signalTreeViewCursorChangedId)))

	detail := signalTreeViewCursorChangedDetail{callback, handlerID}
	signalTreeViewCursorChangedMap[signalTreeViewCursorChangedId] = detail

	return signalTreeViewCursorChangedId
}

/*
DisconnectCursorChanged disconnects a callback from the 'cursor-changed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectCursorChanged.
*/
func (recv *TreeView) DisconnectCursorChanged(connectionID int) {
	signalTreeViewCursorChangedLock.Lock()
	defer signalTreeViewCursorChangedLock.Unlock()

	detail, exists := signalTreeViewCursorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewCursorChangedMap, connectionID)
}

//export treeview_cursorChangedHandler
func treeview_cursorChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTreeViewCursorChangedMap[index].callback
	callback()
}

type signalTreeViewExpandCollapseCursorRowDetail struct {
	callback  TreeViewSignalExpandCollapseCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewExpandCollapseCursorRowId int
var signalTreeViewExpandCollapseCursorRowMap = make(map[int]signalTreeViewExpandCollapseCursorRowDetail)
var signalTreeViewExpandCollapseCursorRowLock sync.Mutex

// TreeViewSignalExpandCollapseCursorRowCallback is a callback function for a 'expand-collapse-cursor-row' signal emitted from a TreeView.
type TreeViewSignalExpandCollapseCursorRowCallback func(object bool, p0 bool, p1 bool) bool

/*
ConnectExpandCollapseCursorRow connects the callback to the 'expand-collapse-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectExpandCollapseCursorRow to remove it.
*/
func (recv *TreeView) ConnectExpandCollapseCursorRow(callback TreeViewSignalExpandCollapseCursorRowCallback) int {
	signalTreeViewExpandCollapseCursorRowLock.Lock()
	defer signalTreeViewExpandCollapseCursorRowLock.Unlock()

	signalTreeViewExpandCollapseCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_expand_collapse_cursor_row(instance, C.gpointer(uintptr(signalTreeViewExpandCollapseCursorRowId)))

	detail := signalTreeViewExpandCollapseCursorRowDetail{callback, handlerID}
	signalTreeViewExpandCollapseCursorRowMap[signalTreeViewExpandCollapseCursorRowId] = detail

	return signalTreeViewExpandCollapseCursorRowId
}

/*
DisconnectExpandCollapseCursorRow disconnects a callback from the 'expand-collapse-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectExpandCollapseCursorRow.
*/
func (recv *TreeView) DisconnectExpandCollapseCursorRow(connectionID int) {
	signalTreeViewExpandCollapseCursorRowLock.Lock()
	defer signalTreeViewExpandCollapseCursorRowLock.Unlock()

	detail, exists := signalTreeViewExpandCollapseCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewExpandCollapseCursorRowMap, connectionID)
}

//export treeview_expandCollapseCursorRowHandler
func treeview_expandCollapseCursorRowHandler(_ *C.GObject, c_object C.gboolean, c_p0 C.gboolean, c_p1 C.gboolean, data C.gpointer) C.gboolean {
	object := c_object == C.TRUE

	p0 := c_p0 == C.TRUE

	p1 := c_p1 == C.TRUE

	index := int(uintptr(data))
	callback := signalTreeViewExpandCollapseCursorRowMap[index].callback
	retGo := callback(object, p0, p1)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'move-cursor' for TreeView : unsupported parameter step : type MovementStep :

type signalTreeViewRowActivatedDetail struct {
	callback  TreeViewSignalRowActivatedCallback
	handlerID C.gulong
}

var signalTreeViewRowActivatedId int
var signalTreeViewRowActivatedMap = make(map[int]signalTreeViewRowActivatedDetail)
var signalTreeViewRowActivatedLock sync.Mutex

// TreeViewSignalRowActivatedCallback is a callback function for a 'row-activated' signal emitted from a TreeView.
type TreeViewSignalRowActivatedCallback func(path *TreePath, column *TreeViewColumn)

/*
ConnectRowActivated connects the callback to the 'row-activated' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowActivated to remove it.
*/
func (recv *TreeView) ConnectRowActivated(callback TreeViewSignalRowActivatedCallback) int {
	signalTreeViewRowActivatedLock.Lock()
	defer signalTreeViewRowActivatedLock.Unlock()

	signalTreeViewRowActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_activated(instance, C.gpointer(uintptr(signalTreeViewRowActivatedId)))

	detail := signalTreeViewRowActivatedDetail{callback, handlerID}
	signalTreeViewRowActivatedMap[signalTreeViewRowActivatedId] = detail

	return signalTreeViewRowActivatedId
}

/*
DisconnectRowActivated disconnects a callback from the 'row-activated' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowActivated.
*/
func (recv *TreeView) DisconnectRowActivated(connectionID int) {
	signalTreeViewRowActivatedLock.Lock()
	defer signalTreeViewRowActivatedLock.Unlock()

	detail, exists := signalTreeViewRowActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowActivatedMap, connectionID)
}

//export treeview_rowActivatedHandler
func treeview_rowActivatedHandler(_ *C.GObject, c_path *C.GtkTreePath, c_column *C.GtkTreeViewColumn, data C.gpointer) {
	path := TreePathNewFromC(unsafe.Pointer(c_path))

	column := TreeViewColumnNewFromC(unsafe.Pointer(c_column))

	index := int(uintptr(data))
	callback := signalTreeViewRowActivatedMap[index].callback
	callback(path, column)
}

type signalTreeViewRowCollapsedDetail struct {
	callback  TreeViewSignalRowCollapsedCallback
	handlerID C.gulong
}

var signalTreeViewRowCollapsedId int
var signalTreeViewRowCollapsedMap = make(map[int]signalTreeViewRowCollapsedDetail)
var signalTreeViewRowCollapsedLock sync.Mutex

// TreeViewSignalRowCollapsedCallback is a callback function for a 'row-collapsed' signal emitted from a TreeView.
type TreeViewSignalRowCollapsedCallback func(iter *TreeIter, path *TreePath)

/*
ConnectRowCollapsed connects the callback to the 'row-collapsed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowCollapsed to remove it.
*/
func (recv *TreeView) ConnectRowCollapsed(callback TreeViewSignalRowCollapsedCallback) int {
	signalTreeViewRowCollapsedLock.Lock()
	defer signalTreeViewRowCollapsedLock.Unlock()

	signalTreeViewRowCollapsedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_collapsed(instance, C.gpointer(uintptr(signalTreeViewRowCollapsedId)))

	detail := signalTreeViewRowCollapsedDetail{callback, handlerID}
	signalTreeViewRowCollapsedMap[signalTreeViewRowCollapsedId] = detail

	return signalTreeViewRowCollapsedId
}

/*
DisconnectRowCollapsed disconnects a callback from the 'row-collapsed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowCollapsed.
*/
func (recv *TreeView) DisconnectRowCollapsed(connectionID int) {
	signalTreeViewRowCollapsedLock.Lock()
	defer signalTreeViewRowCollapsedLock.Unlock()

	detail, exists := signalTreeViewRowCollapsedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowCollapsedMap, connectionID)
}

//export treeview_rowCollapsedHandler
func treeview_rowCollapsedHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) {
	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewRowCollapsedMap[index].callback
	callback(iter, path)
}

type signalTreeViewRowExpandedDetail struct {
	callback  TreeViewSignalRowExpandedCallback
	handlerID C.gulong
}

var signalTreeViewRowExpandedId int
var signalTreeViewRowExpandedMap = make(map[int]signalTreeViewRowExpandedDetail)
var signalTreeViewRowExpandedLock sync.Mutex

// TreeViewSignalRowExpandedCallback is a callback function for a 'row-expanded' signal emitted from a TreeView.
type TreeViewSignalRowExpandedCallback func(iter *TreeIter, path *TreePath)

/*
ConnectRowExpanded connects the callback to the 'row-expanded' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowExpanded to remove it.
*/
func (recv *TreeView) ConnectRowExpanded(callback TreeViewSignalRowExpandedCallback) int {
	signalTreeViewRowExpandedLock.Lock()
	defer signalTreeViewRowExpandedLock.Unlock()

	signalTreeViewRowExpandedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_expanded(instance, C.gpointer(uintptr(signalTreeViewRowExpandedId)))

	detail := signalTreeViewRowExpandedDetail{callback, handlerID}
	signalTreeViewRowExpandedMap[signalTreeViewRowExpandedId] = detail

	return signalTreeViewRowExpandedId
}

/*
DisconnectRowExpanded disconnects a callback from the 'row-expanded' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowExpanded.
*/
func (recv *TreeView) DisconnectRowExpanded(connectionID int) {
	signalTreeViewRowExpandedLock.Lock()
	defer signalTreeViewRowExpandedLock.Unlock()

	detail, exists := signalTreeViewRowExpandedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowExpandedMap, connectionID)
}

//export treeview_rowExpandedHandler
func treeview_rowExpandedHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) {
	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewRowExpandedMap[index].callback
	callback(iter, path)
}

type signalTreeViewSelectAllDetail struct {
	callback  TreeViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalTreeViewSelectAllId int
var signalTreeViewSelectAllMap = make(map[int]signalTreeViewSelectAllDetail)
var signalTreeViewSelectAllLock sync.Mutex

// TreeViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a TreeView.
type TreeViewSignalSelectAllCallback func() bool

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *TreeView) ConnectSelectAll(callback TreeViewSignalSelectAllCallback) int {
	signalTreeViewSelectAllLock.Lock()
	defer signalTreeViewSelectAllLock.Unlock()

	signalTreeViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_all(instance, C.gpointer(uintptr(signalTreeViewSelectAllId)))

	detail := signalTreeViewSelectAllDetail{callback, handlerID}
	signalTreeViewSelectAllMap[signalTreeViewSelectAllId] = detail

	return signalTreeViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *TreeView) DisconnectSelectAll(connectionID int) {
	signalTreeViewSelectAllLock.Lock()
	defer signalTreeViewSelectAllLock.Unlock()

	detail, exists := signalTreeViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectAllMap, connectionID)
}

//export treeview_selectAllHandler
func treeview_selectAllHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewSelectAllMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewSelectCursorParentDetail struct {
	callback  TreeViewSignalSelectCursorParentCallback
	handlerID C.gulong
}

var signalTreeViewSelectCursorParentId int
var signalTreeViewSelectCursorParentMap = make(map[int]signalTreeViewSelectCursorParentDetail)
var signalTreeViewSelectCursorParentLock sync.Mutex

// TreeViewSignalSelectCursorParentCallback is a callback function for a 'select-cursor-parent' signal emitted from a TreeView.
type TreeViewSignalSelectCursorParentCallback func() bool

/*
ConnectSelectCursorParent connects the callback to the 'select-cursor-parent' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorParent to remove it.
*/
func (recv *TreeView) ConnectSelectCursorParent(callback TreeViewSignalSelectCursorParentCallback) int {
	signalTreeViewSelectCursorParentLock.Lock()
	defer signalTreeViewSelectCursorParentLock.Unlock()

	signalTreeViewSelectCursorParentId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_cursor_parent(instance, C.gpointer(uintptr(signalTreeViewSelectCursorParentId)))

	detail := signalTreeViewSelectCursorParentDetail{callback, handlerID}
	signalTreeViewSelectCursorParentMap[signalTreeViewSelectCursorParentId] = detail

	return signalTreeViewSelectCursorParentId
}

/*
DisconnectSelectCursorParent disconnects a callback from the 'select-cursor-parent' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectCursorParent.
*/
func (recv *TreeView) DisconnectSelectCursorParent(connectionID int) {
	signalTreeViewSelectCursorParentLock.Lock()
	defer signalTreeViewSelectCursorParentLock.Unlock()

	detail, exists := signalTreeViewSelectCursorParentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectCursorParentMap, connectionID)
}

//export treeview_selectCursorParentHandler
func treeview_selectCursorParentHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewSelectCursorParentMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewSelectCursorRowDetail struct {
	callback  TreeViewSignalSelectCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewSelectCursorRowId int
var signalTreeViewSelectCursorRowMap = make(map[int]signalTreeViewSelectCursorRowDetail)
var signalTreeViewSelectCursorRowLock sync.Mutex

// TreeViewSignalSelectCursorRowCallback is a callback function for a 'select-cursor-row' signal emitted from a TreeView.
type TreeViewSignalSelectCursorRowCallback func(object bool) bool

/*
ConnectSelectCursorRow connects the callback to the 'select-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorRow to remove it.
*/
func (recv *TreeView) ConnectSelectCursorRow(callback TreeViewSignalSelectCursorRowCallback) int {
	signalTreeViewSelectCursorRowLock.Lock()
	defer signalTreeViewSelectCursorRowLock.Unlock()

	signalTreeViewSelectCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_cursor_row(instance, C.gpointer(uintptr(signalTreeViewSelectCursorRowId)))

	detail := signalTreeViewSelectCursorRowDetail{callback, handlerID}
	signalTreeViewSelectCursorRowMap[signalTreeViewSelectCursorRowId] = detail

	return signalTreeViewSelectCursorRowId
}

/*
DisconnectSelectCursorRow disconnects a callback from the 'select-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectCursorRow.
*/
func (recv *TreeView) DisconnectSelectCursorRow(connectionID int) {
	signalTreeViewSelectCursorRowLock.Lock()
	defer signalTreeViewSelectCursorRowLock.Unlock()

	detail, exists := signalTreeViewSelectCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectCursorRowMap, connectionID)
}

//export treeview_selectCursorRowHandler
func treeview_selectCursorRowHandler(_ *C.GObject, c_object C.gboolean, data C.gpointer) C.gboolean {
	object := c_object == C.TRUE

	index := int(uintptr(data))
	callback := signalTreeViewSelectCursorRowMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewStartInteractiveSearchDetail struct {
	callback  TreeViewSignalStartInteractiveSearchCallback
	handlerID C.gulong
}

var signalTreeViewStartInteractiveSearchId int
var signalTreeViewStartInteractiveSearchMap = make(map[int]signalTreeViewStartInteractiveSearchDetail)
var signalTreeViewStartInteractiveSearchLock sync.Mutex

// TreeViewSignalStartInteractiveSearchCallback is a callback function for a 'start-interactive-search' signal emitted from a TreeView.
type TreeViewSignalStartInteractiveSearchCallback func() bool

/*
ConnectStartInteractiveSearch connects the callback to the 'start-interactive-search' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectStartInteractiveSearch to remove it.
*/
func (recv *TreeView) ConnectStartInteractiveSearch(callback TreeViewSignalStartInteractiveSearchCallback) int {
	signalTreeViewStartInteractiveSearchLock.Lock()
	defer signalTreeViewStartInteractiveSearchLock.Unlock()

	signalTreeViewStartInteractiveSearchId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_start_interactive_search(instance, C.gpointer(uintptr(signalTreeViewStartInteractiveSearchId)))

	detail := signalTreeViewStartInteractiveSearchDetail{callback, handlerID}
	signalTreeViewStartInteractiveSearchMap[signalTreeViewStartInteractiveSearchId] = detail

	return signalTreeViewStartInteractiveSearchId
}

/*
DisconnectStartInteractiveSearch disconnects a callback from the 'start-interactive-search' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectStartInteractiveSearch.
*/
func (recv *TreeView) DisconnectStartInteractiveSearch(connectionID int) {
	signalTreeViewStartInteractiveSearchLock.Lock()
	defer signalTreeViewStartInteractiveSearchLock.Unlock()

	detail, exists := signalTreeViewStartInteractiveSearchMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewStartInteractiveSearchMap, connectionID)
}

//export treeview_startInteractiveSearchHandler
func treeview_startInteractiveSearchHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewStartInteractiveSearchMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewTestCollapseRowDetail struct {
	callback  TreeViewSignalTestCollapseRowCallback
	handlerID C.gulong
}

var signalTreeViewTestCollapseRowId int
var signalTreeViewTestCollapseRowMap = make(map[int]signalTreeViewTestCollapseRowDetail)
var signalTreeViewTestCollapseRowLock sync.Mutex

// TreeViewSignalTestCollapseRowCallback is a callback function for a 'test-collapse-row' signal emitted from a TreeView.
type TreeViewSignalTestCollapseRowCallback func(iter *TreeIter, path *TreePath) bool

/*
ConnectTestCollapseRow connects the callback to the 'test-collapse-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectTestCollapseRow to remove it.
*/
func (recv *TreeView) ConnectTestCollapseRow(callback TreeViewSignalTestCollapseRowCallback) int {
	signalTreeViewTestCollapseRowLock.Lock()
	defer signalTreeViewTestCollapseRowLock.Unlock()

	signalTreeViewTestCollapseRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_test_collapse_row(instance, C.gpointer(uintptr(signalTreeViewTestCollapseRowId)))

	detail := signalTreeViewTestCollapseRowDetail{callback, handlerID}
	signalTreeViewTestCollapseRowMap[signalTreeViewTestCollapseRowId] = detail

	return signalTreeViewTestCollapseRowId
}

/*
DisconnectTestCollapseRow disconnects a callback from the 'test-collapse-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectTestCollapseRow.
*/
func (recv *TreeView) DisconnectTestCollapseRow(connectionID int) {
	signalTreeViewTestCollapseRowLock.Lock()
	defer signalTreeViewTestCollapseRowLock.Unlock()

	detail, exists := signalTreeViewTestCollapseRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewTestCollapseRowMap, connectionID)
}

//export treeview_testCollapseRowHandler
func treeview_testCollapseRowHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) C.gboolean {
	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewTestCollapseRowMap[index].callback
	retGo := callback(iter, path)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewTestExpandRowDetail struct {
	callback  TreeViewSignalTestExpandRowCallback
	handlerID C.gulong
}

var signalTreeViewTestExpandRowId int
var signalTreeViewTestExpandRowMap = make(map[int]signalTreeViewTestExpandRowDetail)
var signalTreeViewTestExpandRowLock sync.Mutex

// TreeViewSignalTestExpandRowCallback is a callback function for a 'test-expand-row' signal emitted from a TreeView.
type TreeViewSignalTestExpandRowCallback func(iter *TreeIter, path *TreePath) bool

/*
ConnectTestExpandRow connects the callback to the 'test-expand-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectTestExpandRow to remove it.
*/
func (recv *TreeView) ConnectTestExpandRow(callback TreeViewSignalTestExpandRowCallback) int {
	signalTreeViewTestExpandRowLock.Lock()
	defer signalTreeViewTestExpandRowLock.Unlock()

	signalTreeViewTestExpandRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_test_expand_row(instance, C.gpointer(uintptr(signalTreeViewTestExpandRowId)))

	detail := signalTreeViewTestExpandRowDetail{callback, handlerID}
	signalTreeViewTestExpandRowMap[signalTreeViewTestExpandRowId] = detail

	return signalTreeViewTestExpandRowId
}

/*
DisconnectTestExpandRow disconnects a callback from the 'test-expand-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectTestExpandRow.
*/
func (recv *TreeView) DisconnectTestExpandRow(connectionID int) {
	signalTreeViewTestExpandRowLock.Lock()
	defer signalTreeViewTestExpandRowLock.Unlock()

	detail, exists := signalTreeViewTestExpandRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewTestExpandRowMap, connectionID)
}

//export treeview_testExpandRowHandler
func treeview_testExpandRowHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) C.gboolean {
	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewTestExpandRowMap[index].callback
	retGo := callback(iter, path)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewToggleCursorRowDetail struct {
	callback  TreeViewSignalToggleCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewToggleCursorRowId int
var signalTreeViewToggleCursorRowMap = make(map[int]signalTreeViewToggleCursorRowDetail)
var signalTreeViewToggleCursorRowLock sync.Mutex

// TreeViewSignalToggleCursorRowCallback is a callback function for a 'toggle-cursor-row' signal emitted from a TreeView.
type TreeViewSignalToggleCursorRowCallback func() bool

/*
ConnectToggleCursorRow connects the callback to the 'toggle-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorRow to remove it.
*/
func (recv *TreeView) ConnectToggleCursorRow(callback TreeViewSignalToggleCursorRowCallback) int {
	signalTreeViewToggleCursorRowLock.Lock()
	defer signalTreeViewToggleCursorRowLock.Unlock()

	signalTreeViewToggleCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_toggle_cursor_row(instance, C.gpointer(uintptr(signalTreeViewToggleCursorRowId)))

	detail := signalTreeViewToggleCursorRowDetail{callback, handlerID}
	signalTreeViewToggleCursorRowMap[signalTreeViewToggleCursorRowId] = detail

	return signalTreeViewToggleCursorRowId
}

/*
DisconnectToggleCursorRow disconnects a callback from the 'toggle-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectToggleCursorRow.
*/
func (recv *TreeView) DisconnectToggleCursorRow(connectionID int) {
	signalTreeViewToggleCursorRowLock.Lock()
	defer signalTreeViewToggleCursorRowLock.Unlock()

	detail, exists := signalTreeViewToggleCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewToggleCursorRowMap, connectionID)
}

//export treeview_toggleCursorRowHandler
func treeview_toggleCursorRowHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewToggleCursorRowMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewUnselectAllDetail struct {
	callback  TreeViewSignalUnselectAllCallback
	handlerID C.gulong
}

var signalTreeViewUnselectAllId int
var signalTreeViewUnselectAllMap = make(map[int]signalTreeViewUnselectAllDetail)
var signalTreeViewUnselectAllLock sync.Mutex

// TreeViewSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a TreeView.
type TreeViewSignalUnselectAllCallback func() bool

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *TreeView) ConnectUnselectAll(callback TreeViewSignalUnselectAllCallback) int {
	signalTreeViewUnselectAllLock.Lock()
	defer signalTreeViewUnselectAllLock.Unlock()

	signalTreeViewUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalTreeViewUnselectAllId)))

	detail := signalTreeViewUnselectAllDetail{callback, handlerID}
	signalTreeViewUnselectAllMap[signalTreeViewUnselectAllId] = detail

	return signalTreeViewUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *TreeView) DisconnectUnselectAll(connectionID int) {
	signalTreeViewUnselectAllLock.Lock()
	defer signalTreeViewUnselectAllLock.Unlock()

	detail, exists := signalTreeViewUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewUnselectAllMap, connectionID)
}

//export treeview_unselectAllHandler
func treeview_unselectAllHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewUnselectAllMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Creates a new #GtkTreeView widget.
/*

C function : gtk_tree_view_new
*/
func TreeViewNew() *TreeView {
	retC := C.gtk_tree_view_new()
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkTreeView widget with the model initialized to @model.
/*

C function : gtk_tree_view_new_with_model
*/
func TreeViewNewWithModel(model *TreeModel) *TreeView {
	c_model := (*C.GtkTreeModel)(model.ToC())

	retC := C.gtk_tree_view_new_with_model(c_model)
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Appends @column to the list of columns. If @tree_view has fixed_height
// mode enabled, then @column must have its sizing property set to be
// GTK_TREE_VIEW_COLUMN_FIXED.
/*

C function : gtk_tree_view_append_column
*/
func (recv *TreeView) AppendColumn(column *TreeViewColumn) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	retC := C.gtk_tree_view_append_column((*C.GtkTreeView)(recv.native), c_column)
	retGo := (int32)(retC)

	return retGo
}

// Recursively collapses all visible, expanded nodes in @tree_view.
/*

C function : gtk_tree_view_collapse_all
*/
func (recv *TreeView) CollapseAll() {
	C.gtk_tree_view_collapse_all((*C.GtkTreeView)(recv.native))

	return
}

// Collapses a row (hides its child rows, if they exist).
/*

C function : gtk_tree_view_collapse_row
*/
func (recv *TreeView) CollapseRow(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_collapse_row((*C.GtkTreeView)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// Resizes all columns to their optimal width. Only works after the
// treeview has been realized.
/*

C function : gtk_tree_view_columns_autosize
*/
func (recv *TreeView) ColumnsAutosize() {
	C.gtk_tree_view_columns_autosize((*C.GtkTreeView)(recv.native))

	return
}

// Creates a #cairo_surface_t representation of the row at @path.
// This image is used for a drag icon.
/*

C function : gtk_tree_view_create_row_drag_icon
*/
func (recv *TreeView) CreateRowDragIcon(path *TreePath) *cairo.Surface {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_create_row_drag_icon((*C.GtkTreeView)(recv.native), c_path)
	retGo := cairo.SurfaceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_enable_model_drag_dest : unsupported parameter targets :

// Unsupported : gtk_tree_view_enable_model_drag_source : unsupported parameter targets :

// Recursively expands all nodes in the @tree_view.
/*

C function : gtk_tree_view_expand_all
*/
func (recv *TreeView) ExpandAll() {
	C.gtk_tree_view_expand_all((*C.GtkTreeView)(recv.native))

	return
}

// Opens the row so its children are visible.
/*

C function : gtk_tree_view_expand_row
*/
func (recv *TreeView) ExpandRow(path *TreePath, openAll bool) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_open_all :=
		boolToGboolean(openAll)

	retC := C.gtk_tree_view_expand_row((*C.GtkTreeView)(recv.native), c_path, c_open_all)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_tree_view_get_background_area : unsupported parameter rect : Blacklisted record : GdkRectangle

// Returns the window that @tree_view renders to.
// This is used primarily to compare to `event->window`
// to confirm that the event on @tree_view is on the right window.
/*

C function : gtk_tree_view_get_bin_window
*/
func (recv *TreeView) GetBinWindow() *gdk.Window {
	retC := C.gtk_tree_view_get_bin_window((*C.GtkTreeView)(recv.native))
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_tree_view_get_cell_area : unsupported parameter rect : Blacklisted record : GdkRectangle

// Gets the #GtkTreeViewColumn at the given position in the #tree_view.
/*

C function : gtk_tree_view_get_column
*/
func (recv *TreeView) GetColumn(n int32) *TreeViewColumn {
	c_n := (C.gint)(n)

	retC := C.gtk_tree_view_get_column((*C.GtkTreeView)(recv.native), c_n)
	var retGo (*TreeViewColumn)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreeViewColumnNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns a #GList of all the #GtkTreeViewColumn s currently in @tree_view.
// The returned list must be freed with g_list_free ().
/*

C function : gtk_tree_view_get_columns
*/
func (recv *TreeView) GetColumns() *glib.List {
	retC := C.gtk_tree_view_get_columns((*C.GtkTreeView)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Fills in @path and @focus_column with the current path and focus column.  If
// the cursor isnt currently set, then *@path will be %NULL.  If no column
// currently has focus, then *@focus_column will be %NULL.
//
// The returned #GtkTreePath must be freed with gtk_tree_path_free() when
// you are done with it.
/*

C function : gtk_tree_view_get_cursor
*/
func (recv *TreeView) GetCursor() (*TreePath, *TreeViewColumn) {
	var c_path *C.GtkTreePath

	var c_focus_column *C.GtkTreeViewColumn

	C.gtk_tree_view_get_cursor((*C.GtkTreeView)(recv.native), &c_path, &c_focus_column)

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	focusColumn := TreeViewColumnNewFromC(unsafe.Pointer(c_focus_column))

	return path, focusColumn
}

// Unsupported : gtk_tree_view_get_dest_row_at_pos : unsupported parameter pos : GtkTreeViewDropPosition* with indirection level of 1

// Unsupported : gtk_tree_view_get_drag_dest_row : unsupported parameter pos : GtkTreeViewDropPosition* with indirection level of 1

// Returns whether or not the tree allows to start interactive searching
// by typing in text.
/*

C function : gtk_tree_view_get_enable_search
*/
func (recv *TreeView) GetEnableSearch() bool {
	retC := C.gtk_tree_view_get_enable_search((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the column that is the current expander column.
// This column has the expander arrow drawn next to it.
/*

C function : gtk_tree_view_get_expander_column
*/
func (recv *TreeView) GetExpanderColumn() *TreeViewColumn {
	retC := C.gtk_tree_view_get_expander_column((*C.GtkTreeView)(recv.native))
	retGo := TreeViewColumnNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the #GtkAdjustment currently being used for the horizontal aspect.
/*

C function : gtk_tree_view_get_hadjustment
*/
func (recv *TreeView) GetHadjustment() *Adjustment {
	retC := C.gtk_tree_view_get_hadjustment((*C.GtkTreeView)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if the headers on the @tree_view are visible.
/*

C function : gtk_tree_view_get_headers_visible
*/
func (recv *TreeView) GetHeadersVisible() bool {
	retC := C.gtk_tree_view_get_headers_visible((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the model the #GtkTreeView is based on.  Returns %NULL if the
// model is unset.
/*

C function : gtk_tree_view_get_model
*/
func (recv *TreeView) GetModel() *TreeModel {
	retC := C.gtk_tree_view_get_model((*C.GtkTreeView)(recv.native))
	var retGo (*TreeModel)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreeModelNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Finds the path at the point (@x, @y), relative to bin_window coordinates
// (please see gtk_tree_view_get_bin_window()).
// That is, @x and @y are relative to an events coordinates. @x and @y must
// come from an event on the @tree_view only where `event->window ==
// gtk_tree_view_get_bin_window ()`. It is primarily for
// things like popup menus. If @path is non-%NULL, then it will be filled
// with the #GtkTreePath at that point.  This path should be freed with
// gtk_tree_path_free().  If @column is non-%NULL, then it will be filled
// with the column at that point.  @cell_x and @cell_y return the coordinates
// relative to the cell background (i.e. the @background_area passed to
// gtk_cell_renderer_render()).  This function is only meaningful if
// @tree_view is realized.  Therefore this function will always return %FALSE
// if @tree_view is not realized or does not have a model.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
/*

C function : gtk_tree_view_get_path_at_pos
*/
func (recv *TreeView) GetPathAtPos(x int32, y int32) (bool, *TreePath, *TreeViewColumn, int32, int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	var c_path *C.GtkTreePath

	var c_column *C.GtkTreeViewColumn

	var c_cell_x C.gint

	var c_cell_y C.gint

	retC := C.gtk_tree_view_get_path_at_pos((*C.GtkTreeView)(recv.native), c_x, c_y, &c_path, &c_column, &c_cell_x, &c_cell_y)
	retGo := retC == C.TRUE

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	column := TreeViewColumnNewFromC(unsafe.Pointer(c_column))

	cellX := (int32)(c_cell_x)

	cellY := (int32)(c_cell_y)

	return retGo, path, column, cellX, cellY
}

// Retrieves whether the user can reorder the tree via drag-and-drop. See
// gtk_tree_view_set_reorderable().
/*

C function : gtk_tree_view_get_reorderable
*/
func (recv *TreeView) GetReorderable() bool {
	retC := C.gtk_tree_view_get_reorderable((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the setting set by gtk_tree_view_set_rules_hint().
/*

C function : gtk_tree_view_get_rules_hint
*/
func (recv *TreeView) GetRulesHint() bool {
	retC := C.gtk_tree_view_get_rules_hint((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the column searched on by the interactive search code.
/*

C function : gtk_tree_view_get_search_column
*/
func (recv *TreeView) GetSearchColumn() int32 {
	retC := C.gtk_tree_view_get_search_column((*C.GtkTreeView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Unsupported : gtk_tree_view_get_search_equal_func : no return generator

// Gets the #GtkTreeSelection associated with @tree_view.
/*

C function : gtk_tree_view_get_selection
*/
func (recv *TreeView) GetSelection() *TreeSelection {
	retC := C.gtk_tree_view_get_selection((*C.GtkTreeView)(recv.native))
	retGo := TreeSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the #GtkAdjustment currently being used for the vertical aspect.
/*

C function : gtk_tree_view_get_vadjustment
*/
func (recv *TreeView) GetVadjustment() *Adjustment {
	retC := C.gtk_tree_view_get_vadjustment((*C.GtkTreeView)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_get_visible_rect : unsupported parameter visible_rect : Blacklisted record : GdkRectangle

// This inserts the @column into the @tree_view at @position.  If @position is
// -1, then the column is inserted at the end. If @tree_view has
// fixed_height mode enabled, then @column must have its sizing property
// set to be GTK_TREE_VIEW_COLUMN_FIXED.
/*

C function : gtk_tree_view_insert_column
*/
func (recv *TreeView) InsertColumn(column *TreeViewColumn, position int32) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_tree_view_insert_column((*C.GtkTreeView)(recv.native), c_column, c_position)
	retGo := (int32)(retC)

	return retGo
}

// Unsupported : gtk_tree_view_insert_column_with_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_tree_view_insert_column_with_data_func : unsupported parameter func : no type generator for TreeCellDataFunc (GtkTreeCellDataFunc) for param func

// Unsupported : gtk_tree_view_map_expanded_rows : unsupported parameter func : no type generator for TreeViewMappingFunc (GtkTreeViewMappingFunc) for param func

// Moves @column to be after to @base_column.  If @base_column is %NULL, then
// @column is placed in the first position.
/*

C function : gtk_tree_view_move_column_after
*/
func (recv *TreeView) MoveColumnAfter(column *TreeViewColumn, baseColumn *TreeViewColumn) {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_base_column := (*C.GtkTreeViewColumn)(C.NULL)
	if baseColumn != nil {
		c_base_column = (*C.GtkTreeViewColumn)(baseColumn.ToC())
	}

	C.gtk_tree_view_move_column_after((*C.GtkTreeView)(recv.native), c_column, c_base_column)

	return
}

// Removes @column from @tree_view.
/*

C function : gtk_tree_view_remove_column
*/
func (recv *TreeView) RemoveColumn(column *TreeViewColumn) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	retC := C.gtk_tree_view_remove_column((*C.GtkTreeView)(recv.native), c_column)
	retGo := (int32)(retC)

	return retGo
}

// Activates the cell determined by @path and @column.
/*

C function : gtk_tree_view_row_activated
*/
func (recv *TreeView) RowActivated(path *TreePath, column *TreeViewColumn) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	C.gtk_tree_view_row_activated((*C.GtkTreeView)(recv.native), c_path, c_column)

	return
}

// Returns %TRUE if the node pointed to by @path is expanded in @tree_view.
/*

C function : gtk_tree_view_row_expanded
*/
func (recv *TreeView) RowExpanded(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_row_expanded((*C.GtkTreeView)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// Moves the alignments of @tree_view to the position specified by @column and
// @path.  If @column is %NULL, then no horizontal scrolling occurs.  Likewise,
// if @path is %NULL no vertical scrolling occurs.  At a minimum, one of @column
// or @path need to be non-%NULL.  @row_align determines where the row is
// placed, and @col_align determines where @column is placed.  Both are expected
// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
// right/bottom alignment, 0.5 means center.
//
// If @use_align is %FALSE, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen.
// This means that the cell will be scrolled to the edge closest to its current
// position.  If the cell is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and @path is a valid row on the
// model.  If the model changes before the @tree_view is realized, the centered
// path will be modified to reflect this change.
/*

C function : gtk_tree_view_scroll_to_cell
*/
func (recv *TreeView) ScrollToCell(path *TreePath, column *TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_use_align :=
		boolToGboolean(useAlign)

	c_row_align := (C.gfloat)(rowAlign)

	c_col_align := (C.gfloat)(colAlign)

	C.gtk_tree_view_scroll_to_cell((*C.GtkTreeView)(recv.native), c_path, c_column, c_use_align, c_row_align, c_col_align)

	return
}

// Scrolls the tree view such that the top-left corner of the visible
// area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
// in tree coordinates.  The @tree_view must be realized before
// this function is called.  If it isn't, you probably want to be
// using gtk_tree_view_scroll_to_cell().
//
// If either @tree_x or @tree_y are -1, then that direction isnt scrolled.
/*

C function : gtk_tree_view_scroll_to_point
*/
func (recv *TreeView) ScrollToPoint(treeX int32, treeY int32) {
	c_tree_x := (C.gint)(treeX)

	c_tree_y := (C.gint)(treeY)

	C.gtk_tree_view_scroll_to_point((*C.GtkTreeView)(recv.native), c_tree_x, c_tree_y)

	return
}

// Unsupported : gtk_tree_view_set_column_drag_function : unsupported parameter func : no type generator for TreeViewColumnDropFunc (GtkTreeViewColumnDropFunc) for param func

// Sets the current keyboard focus to be at @path, and selects it.  This is
// useful when you want to focus the users attention on a particular row.  If
// @focus_column is not %NULL, then focus is given to the column specified by
// it. Additionally, if @focus_column is specified, and @start_editing is
// %TRUE, then editing should be started in the specified cell.
// This function is often followed by @gtk_widget_grab_focus (@tree_view)
// in order to give keyboard focus to the widget.  Please note that editing
// can only happen when the widget is realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
/*

C function : gtk_tree_view_set_cursor
*/
func (recv *TreeView) SetCursor(path *TreePath, focusColumn *TreeViewColumn, startEditing bool) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_focus_column := (*C.GtkTreeViewColumn)(C.NULL)
	if focusColumn != nil {
		c_focus_column = (*C.GtkTreeViewColumn)(focusColumn.ToC())
	}

	c_start_editing :=
		boolToGboolean(startEditing)

	C.gtk_tree_view_set_cursor((*C.GtkTreeView)(recv.native), c_path, c_focus_column, c_start_editing)

	return
}

// Unsupported : gtk_tree_view_set_destroy_count_func : unsupported parameter func : no type generator for TreeDestroyCountFunc (GtkTreeDestroyCountFunc) for param func

// Sets the row that is highlighted for feedback.
// If @path is %NULL, an existing highlight is removed.
/*

C function : gtk_tree_view_set_drag_dest_row
*/
func (recv *TreeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_pos := (C.GtkTreeViewDropPosition)(pos)

	C.gtk_tree_view_set_drag_dest_row((*C.GtkTreeView)(recv.native), c_path, c_pos)

	return
}

// If @enable_search is set, then the user can type in text to search through
// the tree interactively (this is sometimes called "typeahead find").
//
// Note that even if this is %FALSE, the user can still initiate a search
// using the start-interactive-search key binding.
/*

C function : gtk_tree_view_set_enable_search
*/
func (recv *TreeView) SetEnableSearch(enableSearch bool) {
	c_enable_search :=
		boolToGboolean(enableSearch)

	C.gtk_tree_view_set_enable_search((*C.GtkTreeView)(recv.native), c_enable_search)

	return
}

// Sets the column to draw the expander arrow at. It must be in @tree_view.
// If @column is %NULL, then the expander arrow is always at the first
// visible column.
//
// If you do not want expander arrow to appear in your tree, set the
// expander column to a hidden column.
/*

C function : gtk_tree_view_set_expander_column
*/
func (recv *TreeView) SetExpanderColumn(column *TreeViewColumn) {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	C.gtk_tree_view_set_expander_column((*C.GtkTreeView)(recv.native), c_column)

	return
}

// Sets the #GtkAdjustment for the current horizontal aspect.
/*

C function : gtk_tree_view_set_hadjustment
*/
func (recv *TreeView) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_tree_view_set_hadjustment((*C.GtkTreeView)(recv.native), c_adjustment)

	return
}

// Allow the column title buttons to be clicked.
/*

C function : gtk_tree_view_set_headers_clickable
*/
func (recv *TreeView) SetHeadersClickable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_set_headers_clickable((*C.GtkTreeView)(recv.native), c_setting)

	return
}

// Sets the visibility state of the headers.
/*

C function : gtk_tree_view_set_headers_visible
*/
func (recv *TreeView) SetHeadersVisible(headersVisible bool) {
	c_headers_visible :=
		boolToGboolean(headersVisible)

	C.gtk_tree_view_set_headers_visible((*C.GtkTreeView)(recv.native), c_headers_visible)

	return
}

// Sets the model for a #GtkTreeView.  If the @tree_view already has a model
// set, it will remove it before setting the new model.  If @model is %NULL,
// then it will unset the old model.
/*

C function : gtk_tree_view_set_model
*/
func (recv *TreeView) SetModel(model *TreeModel) {
	c_model := (*C.GtkTreeModel)(model.ToC())

	C.gtk_tree_view_set_model((*C.GtkTreeView)(recv.native), c_model)

	return
}

// This function is a convenience function to allow you to reorder
// models that support the #GtkTreeDragSourceIface and the
// #GtkTreeDragDestIface.  Both #GtkTreeStore and #GtkListStore support
// these.  If @reorderable is %TRUE, then the user can reorder the
// model by dragging and dropping rows. The developer can listen to
// these changes by connecting to the models #GtkTreeModel::row-inserted
// and #GtkTreeModel::row-deleted signals. The reordering is implemented
// by setting up the tree view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any
// other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed.  If more control is needed, you should probably
// handle drag and drop manually.
/*

C function : gtk_tree_view_set_reorderable
*/
func (recv *TreeView) SetReorderable(reorderable bool) {
	c_reorderable :=
		boolToGboolean(reorderable)

	C.gtk_tree_view_set_reorderable((*C.GtkTreeView)(recv.native), c_reorderable)

	return
}

// Sets a hint for the theme to draw even/odd rows in the @tree_view
// with different colors, also known as "zebra striping".
//
// This function tells the GTK+ theme that the user interface for your
// application requires users to read across tree rows and associate
// cells with one another.
//
// Do not use it just because you prefer the appearance of the ruled
// tree; thats a question for the theme. Some themes will draw tree
// rows in alternating colors even when rules are turned off, and
// users who prefer that appearance all the time can choose those
// themes. You should call this function only as a semantic hint to
// the theme engine that your tree makes alternating colors useful
// from a functional standpoint (since it has lots of columns,
// generally).
/*

C function : gtk_tree_view_set_rules_hint
*/
func (recv *TreeView) SetRulesHint(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_set_rules_hint((*C.GtkTreeView)(recv.native), c_setting)

	return
}

// Sets @column as the column where the interactive search code should
// search in for the current model.
//
// If the search column is set, users can use the start-interactive-search
// key binding to bring up search popup. The enable-search property controls
// whether simply typing text will also start an interactive search.
//
// Note that @column refers to a column of the current model. The search
// column is reset to -1 when the model is changed.
/*

C function : gtk_tree_view_set_search_column
*/
func (recv *TreeView) SetSearchColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_tree_view_set_search_column((*C.GtkTreeView)(recv.native), c_column)

	return
}

// Unsupported : gtk_tree_view_set_search_equal_func : unsupported parameter search_equal_func : no type generator for TreeViewSearchEqualFunc (GtkTreeViewSearchEqualFunc) for param search_equal_func

// Sets the #GtkAdjustment for the current vertical aspect.
/*

C function : gtk_tree_view_set_vadjustment
*/
func (recv *TreeView) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_tree_view_set_vadjustment((*C.GtkTreeView)(recv.native), c_adjustment)

	return
}

// Undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// #GtkTreeView:reorderable to %FALSE.
/*

C function : gtk_tree_view_unset_rows_drag_dest
*/
func (recv *TreeView) UnsetRowsDragDest() {
	C.gtk_tree_view_unset_rows_drag_dest((*C.GtkTreeView)(recv.native))

	return
}

// Undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// #GtkTreeView:reorderable to %FALSE.
/*

C function : gtk_tree_view_unset_rows_drag_source
*/
func (recv *TreeView) UnsetRowsDragSource() {
	C.gtk_tree_view_unset_rows_drag_source((*C.GtkTreeView)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by TreeView
func (recv *TreeView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TreeView
func (recv *TreeView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by TreeView
func (recv *TreeView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

/*

C record/class : GtkTreeViewAccessible
*/
type TreeViewAccessible struct {
	native *C.GtkTreeViewAccessible
	// parent : record
	// priv : record
}

func TreeViewAccessibleNewFromC(u unsafe.Pointer) *TreeViewAccessible {
	c := (*C.GtkTreeViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewAccessible{native: c}

	return g
}

func (recv *TreeViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *TreeViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *TreeViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TreeViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TreeViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to TreeViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeViewAccessible.
func CastToTreeViewAccessible(object *gobject.Object) *TreeViewAccessible {
	return TreeViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Table returns the Table interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Table() *atk.Table {
	return atk.TableNewFromC(recv.ToC())
}

// CellAccessibleParent returns the CellAccessibleParent interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) CellAccessibleParent() *CellAccessibleParent {
	return CellAccessibleParentNewFromC(recv.ToC())
}

// The GtkTreeViewColumn object represents a visible column in a #GtkTreeView widget.
// It allows to set properties of the column header, and functions as a holding pen for
// the cell renderers which determine how the data in the column is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget]
// for an overview of all the objects and data types related to the tree widget and how
// they work together.
/*

C record/class : GtkTreeViewColumn
*/
type TreeViewColumn struct {
	native *C.GtkTreeViewColumn
	// parent_instance : record
	// priv : record
}

func TreeViewColumnNewFromC(u unsafe.Pointer) *TreeViewColumn {
	c := (*C.GtkTreeViewColumn)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewColumn{native: c}

	return g
}

func (recv *TreeViewColumn) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TreeViewColumn) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *TreeViewColumn) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to TreeViewColumn.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeViewColumn.
func CastToTreeViewColumn(object *gobject.Object) *TreeViewColumn {
	return TreeViewColumnNewFromC(object.ToC())
}

type signalTreeViewColumnClickedDetail struct {
	callback  TreeViewColumnSignalClickedCallback
	handlerID C.gulong
}

var signalTreeViewColumnClickedId int
var signalTreeViewColumnClickedMap = make(map[int]signalTreeViewColumnClickedDetail)
var signalTreeViewColumnClickedLock sync.Mutex

// TreeViewColumnSignalClickedCallback is a callback function for a 'clicked' signal emitted from a TreeViewColumn.
type TreeViewColumnSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the TreeViewColumn.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *TreeViewColumn) ConnectClicked(callback TreeViewColumnSignalClickedCallback) int {
	signalTreeViewColumnClickedLock.Lock()
	defer signalTreeViewColumnClickedLock.Unlock()

	signalTreeViewColumnClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeViewColumn_signal_connect_clicked(instance, C.gpointer(uintptr(signalTreeViewColumnClickedId)))

	detail := signalTreeViewColumnClickedDetail{callback, handlerID}
	signalTreeViewColumnClickedMap[signalTreeViewColumnClickedId] = detail

	return signalTreeViewColumnClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the TreeViewColumn.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *TreeViewColumn) DisconnectClicked(connectionID int) {
	signalTreeViewColumnClickedLock.Lock()
	defer signalTreeViewColumnClickedLock.Unlock()

	detail, exists := signalTreeViewColumnClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewColumnClickedMap, connectionID)
}

//export treeviewcolumn_clickedHandler
func treeviewcolumn_clickedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTreeViewColumnClickedMap[index].callback
	callback()
}

// Creates a new #GtkTreeViewColumn.
/*

C function : gtk_tree_view_column_new
*/
func TreeViewColumnNew() *TreeViewColumn {
	retC := C.gtk_tree_view_column_new()
	retGo := TreeViewColumnNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_column_new_with_attributes : unsupported parameter ... : varargs

// Adds an attribute mapping to the list in @tree_column.  The @column is the
// column of the model to get a value from, and the @attribute is the
// parameter on @cell_renderer to be set from the value. So for example
// if column 2 of the model contains strings, you could have the
// text attribute of a #GtkCellRendererText get its values from
// column 2.
/*

C function : gtk_tree_view_column_add_attribute
*/
func (recv *TreeViewColumn) AddAttribute(cellRenderer *CellRenderer, attribute string, column int32) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_column := (C.gint)(column)

	C.gtk_tree_view_column_add_attribute((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer, c_attribute, c_column)

	return
}

// Obtains the horizontal position and size of a cell in a column. If the
// cell is not found in the column, @start_pos and @width are not changed and
// %FALSE is returned.
/*

C function : gtk_tree_view_column_cell_get_position
*/
func (recv *TreeViewColumn) CellGetPosition(cellRenderer *CellRenderer) (bool, int32, int32) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	var c_x_offset C.gint

	var c_width C.gint

	retC := C.gtk_tree_view_column_cell_get_position((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer, &c_x_offset, &c_width)
	retGo := retC == C.TRUE

	xOffset := (int32)(c_x_offset)

	width := (int32)(c_width)

	return retGo, xOffset, width
}

// Unsupported : gtk_tree_view_column_cell_get_size : unsupported parameter cell_area : Blacklisted record : GdkRectangle

// Returns %TRUE if any of the cells packed into the @tree_column are visible.
// For this to be meaningful, you must first initialize the cells with
// gtk_tree_view_column_cell_set_cell_data()
/*

C function : gtk_tree_view_column_cell_is_visible
*/
func (recv *TreeViewColumn) CellIsVisible() bool {
	retC := C.gtk_tree_view_column_cell_is_visible((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the cell renderer based on the @tree_model and @iter.  That is, for
// every attribute mapping in @tree_column, it will get a value from the set
// column on the @iter, and use that value to set the attribute on the cell
// renderer.  This is used primarily by the #GtkTreeView.
/*

C function : gtk_tree_view_column_cell_set_cell_data
*/
func (recv *TreeViewColumn) CellSetCellData(treeModel *TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	c_tree_model := (*C.GtkTreeModel)(treeModel.ToC())

	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_is_expander :=
		boolToGboolean(isExpander)

	c_is_expanded :=
		boolToGboolean(isExpanded)

	C.gtk_tree_view_column_cell_set_cell_data((*C.GtkTreeViewColumn)(recv.native), c_tree_model, c_iter, c_is_expander, c_is_expanded)

	return
}

// Unsets all the mappings on all renderers on the @tree_column.
/*

C function : gtk_tree_view_column_clear
*/
func (recv *TreeViewColumn) Clear() {
	C.gtk_tree_view_column_clear((*C.GtkTreeViewColumn)(recv.native))

	return
}

// Clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
/*

C function : gtk_tree_view_column_clear_attributes
*/
func (recv *TreeViewColumn) ClearAttributes(cellRenderer *CellRenderer) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	C.gtk_tree_view_column_clear_attributes((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer)

	return
}

// Emits the clicked signal on the column.  This function will only work if
// @tree_column is clickable.
/*

C function : gtk_tree_view_column_clicked
*/
func (recv *TreeViewColumn) Clicked() {
	C.gtk_tree_view_column_clicked((*C.GtkTreeViewColumn)(recv.native))

	return
}

// Returns the current x alignment of @tree_column.  This value can range
// between 0.0 and 1.0.
/*

C function : gtk_tree_view_column_get_alignment
*/
func (recv *TreeViewColumn) GetAlignment() float32 {
	retC := C.gtk_tree_view_column_get_alignment((*C.GtkTreeViewColumn)(recv.native))
	retGo := (float32)(retC)

	return retGo
}

// Returns %TRUE if the user can click on the header for the column.
/*

C function : gtk_tree_view_column_get_clickable
*/
func (recv *TreeViewColumn) GetClickable() bool {
	retC := C.gtk_tree_view_column_get_clickable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the fixed width of the column.  This may not be the actual displayed
// width of the column; for that, use gtk_tree_view_column_get_width().
/*

C function : gtk_tree_view_column_get_fixed_width
*/
func (recv *TreeViewColumn) GetFixedWidth() int32 {
	retC := C.gtk_tree_view_column_get_fixed_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the maximum width in pixels of the @tree_column, or -1 if no maximum
// width is set.
/*

C function : gtk_tree_view_column_get_max_width
*/
func (recv *TreeViewColumn) GetMaxWidth() int32 {
	retC := C.gtk_tree_view_column_get_max_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the minimum width in pixels of the @tree_column, or -1 if no minimum
// width is set.
/*

C function : gtk_tree_view_column_get_min_width
*/
func (recv *TreeViewColumn) GetMinWidth() int32 {
	retC := C.gtk_tree_view_column_get_min_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns %TRUE if the @tree_column can be reordered by the user.
/*

C function : gtk_tree_view_column_get_reorderable
*/
func (recv *TreeViewColumn) GetReorderable() bool {
	retC := C.gtk_tree_view_column_get_reorderable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns %TRUE if the @tree_column can be resized by the end user.
/*

C function : gtk_tree_view_column_get_resizable
*/
func (recv *TreeViewColumn) GetResizable() bool {
	retC := C.gtk_tree_view_column_get_resizable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the current type of @tree_column.
/*

C function : gtk_tree_view_column_get_sizing
*/
func (recv *TreeViewColumn) GetSizing() TreeViewColumnSizing {
	retC := C.gtk_tree_view_column_get_sizing((*C.GtkTreeViewColumn)(recv.native))
	retGo := (TreeViewColumnSizing)(retC)

	return retGo
}

// Gets the logical @sort_column_id that the model sorts on when this
// column is selected for sorting.
// See gtk_tree_view_column_set_sort_column_id().
/*

C function : gtk_tree_view_column_get_sort_column_id
*/
func (recv *TreeViewColumn) GetSortColumnId() int32 {
	retC := C.gtk_tree_view_column_get_sort_column_id((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the value set by gtk_tree_view_column_set_sort_indicator().
/*

C function : gtk_tree_view_column_get_sort_indicator
*/
func (recv *TreeViewColumn) GetSortIndicator() bool {
	retC := C.gtk_tree_view_column_get_sort_indicator((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_tree_view_column_set_sort_order().
/*

C function : gtk_tree_view_column_get_sort_order
*/
func (recv *TreeViewColumn) GetSortOrder() SortType {
	retC := C.gtk_tree_view_column_get_sort_order((*C.GtkTreeViewColumn)(recv.native))
	retGo := (SortType)(retC)

	return retGo
}

// Returns the spacing of @tree_column.
/*

C function : gtk_tree_view_column_get_spacing
*/
func (recv *TreeViewColumn) GetSpacing() int32 {
	retC := C.gtk_tree_view_column_get_spacing((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the title of the widget.
/*

C function : gtk_tree_view_column_get_title
*/
func (recv *TreeViewColumn) GetTitle() string {
	retC := C.gtk_tree_view_column_get_title((*C.GtkTreeViewColumn)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Returns %TRUE if @tree_column is visible.
/*

C function : gtk_tree_view_column_get_visible
*/
func (recv *TreeViewColumn) GetVisible() bool {
	retC := C.gtk_tree_view_column_get_visible((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the #GtkWidget in the button on the column header.
// If a custom widget has not been set then %NULL is returned.
/*

C function : gtk_tree_view_column_get_widget
*/
func (recv *TreeViewColumn) GetWidget() *Widget {
	retC := C.gtk_tree_view_column_get_widget((*C.GtkTreeViewColumn)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the current size of @tree_column in pixels.
/*

C function : gtk_tree_view_column_get_width
*/
func (recv *TreeViewColumn) GetWidth() int32 {
	retC := C.gtk_tree_view_column_get_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Adds the @cell to end of the column. If @expand is %FALSE, then the @cell
// is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which @expand is %TRUE.
/*

C function : gtk_tree_view_column_pack_end
*/
func (recv *TreeViewColumn) PackEnd(cell *CellRenderer, expand bool) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	C.gtk_tree_view_column_pack_end((*C.GtkTreeViewColumn)(recv.native), c_cell, c_expand)

	return
}

// Packs the @cell into the beginning of the column. If @expand is %FALSE, then
// the @cell is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which @expand is %TRUE.
/*

C function : gtk_tree_view_column_pack_start
*/
func (recv *TreeViewColumn) PackStart(cell *CellRenderer, expand bool) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	C.gtk_tree_view_column_pack_start((*C.GtkTreeViewColumn)(recv.native), c_cell, c_expand)

	return
}

// Sets the alignment of the title or custom widget inside the column header.
// The alignment determines its location inside the button -- 0.0 for left, 0.5
// for center, 1.0 for right.
/*

C function : gtk_tree_view_column_set_alignment
*/
func (recv *TreeViewColumn) SetAlignment(xalign float32) {
	c_xalign := (C.gfloat)(xalign)

	C.gtk_tree_view_column_set_alignment((*C.GtkTreeViewColumn)(recv.native), c_xalign)

	return
}

// Unsupported : gtk_tree_view_column_set_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_tree_view_column_set_cell_data_func : unsupported parameter func : no type generator for TreeCellDataFunc (GtkTreeCellDataFunc) for param func

// Sets the header to be active if @clickable is %TRUE.  When the header is
// active, then it can take keyboard focus, and can be clicked.
/*

C function : gtk_tree_view_column_set_clickable
*/
func (recv *TreeViewColumn) SetClickable(clickable bool) {
	c_clickable :=
		boolToGboolean(clickable)

	C.gtk_tree_view_column_set_clickable((*C.GtkTreeViewColumn)(recv.native), c_clickable)

	return
}

// If @fixed_width is not -1, sets the fixed width of @tree_column; otherwise
// unsets it.  The effective value of @fixed_width is clamped between the
// minimum and maximum width of the column; however, the value stored in the
// fixed-width property is not clamped.  If the column sizing is
// #GTK_TREE_VIEW_COLUMN_GROW_ONLY or #GTK_TREE_VIEW_COLUMN_AUTOSIZE, setting
// a fixed width overrides the automatically calculated width.  Note that
// @fixed_width is only a hint to GTK+; the width actually allocated to the
// column may be greater or less than requested.
//
// Along with expand, the fixed-width property changes when the column is
// resized by the user.
/*

C function : gtk_tree_view_column_set_fixed_width
*/
func (recv *TreeViewColumn) SetFixedWidth(fixedWidth int32) {
	c_fixed_width := (C.gint)(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width((*C.GtkTreeViewColumn)(recv.native), c_fixed_width)

	return
}

// Sets the maximum width of the @tree_column.  If @max_width is -1, then the
// maximum width is unset.  Note, the column can actually be wider than max
// width if its the last column in a view.  In this case, the column expands to
// fill any extra space.
/*

C function : gtk_tree_view_column_set_max_width
*/
func (recv *TreeViewColumn) SetMaxWidth(maxWidth int32) {
	c_max_width := (C.gint)(maxWidth)

	C.gtk_tree_view_column_set_max_width((*C.GtkTreeViewColumn)(recv.native), c_max_width)

	return
}

// Sets the minimum width of the @tree_column.  If @min_width is -1, then the
// minimum width is unset.
/*

C function : gtk_tree_view_column_set_min_width
*/
func (recv *TreeViewColumn) SetMinWidth(minWidth int32) {
	c_min_width := (C.gint)(minWidth)

	C.gtk_tree_view_column_set_min_width((*C.GtkTreeViewColumn)(recv.native), c_min_width)

	return
}

// If @reorderable is %TRUE, then the column can be reordered by the end user
// dragging the header.
/*

C function : gtk_tree_view_column_set_reorderable
*/
func (recv *TreeViewColumn) SetReorderable(reorderable bool) {
	c_reorderable :=
		boolToGboolean(reorderable)

	C.gtk_tree_view_column_set_reorderable((*C.GtkTreeViewColumn)(recv.native), c_reorderable)

	return
}

// If @resizable is %TRUE, then the user can explicitly resize the column by
// grabbing the outer edge of the column button.  If resizable is %TRUE and
// sizing mode of the column is #GTK_TREE_VIEW_COLUMN_AUTOSIZE, then the sizing
// mode is changed to #GTK_TREE_VIEW_COLUMN_GROW_ONLY.
/*

C function : gtk_tree_view_column_set_resizable
*/
func (recv *TreeViewColumn) SetResizable(resizable bool) {
	c_resizable :=
		boolToGboolean(resizable)

	C.gtk_tree_view_column_set_resizable((*C.GtkTreeViewColumn)(recv.native), c_resizable)

	return
}

// Sets the growth behavior of @tree_column to @type.
/*

C function : gtk_tree_view_column_set_sizing
*/
func (recv *TreeViewColumn) SetSizing(type_ TreeViewColumnSizing) {
	c_type := (C.GtkTreeViewColumnSizing)(type_)

	C.gtk_tree_view_column_set_sizing((*C.GtkTreeViewColumn)(recv.native), c_type)

	return
}

// Sets the logical @sort_column_id that this column sorts on when this column
// is selected for sorting.  Doing so makes the column header clickable.
/*

C function : gtk_tree_view_column_set_sort_column_id
*/
func (recv *TreeViewColumn) SetSortColumnId(sortColumnId int32) {
	c_sort_column_id := (C.gint)(sortColumnId)

	C.gtk_tree_view_column_set_sort_column_id((*C.GtkTreeViewColumn)(recv.native), c_sort_column_id)

	return
}

// Call this function with a @setting of %TRUE to display an arrow in
// the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of
// the arrow.
/*

C function : gtk_tree_view_column_set_sort_indicator
*/
func (recv *TreeViewColumn) SetSortIndicator(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_column_set_sort_indicator((*C.GtkTreeViewColumn)(recv.native), c_setting)

	return
}

// Changes the appearance of the sort indicator.
//
// This does not actually sort the model.  Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support.  This function is primarily for custom sorting behavior, and should
// be used in conjunction with gtk_tree_sortable_set_sort_column_id() to do
// that. For custom models, the mechanism will vary.
//
// The sort indicator changes direction to indicate normal sort or reverse sort.
// Note that you must have the sort indicator enabled to see anything when
// calling this function; see gtk_tree_view_column_set_sort_indicator().
/*

C function : gtk_tree_view_column_set_sort_order
*/
func (recv *TreeViewColumn) SetSortOrder(order SortType) {
	c_order := (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order((*C.GtkTreeViewColumn)(recv.native), c_order)

	return
}

// Sets the spacing field of @tree_column, which is the number of pixels to
// place between cell renderers packed into it.
/*

C function : gtk_tree_view_column_set_spacing
*/
func (recv *TreeViewColumn) SetSpacing(spacing int32) {
	c_spacing := (C.gint)(spacing)

	C.gtk_tree_view_column_set_spacing((*C.GtkTreeViewColumn)(recv.native), c_spacing)

	return
}

// Sets the title of the @tree_column.  If a custom widget has been set, then
// this value is ignored.
/*

C function : gtk_tree_view_column_set_title
*/
func (recv *TreeViewColumn) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_tree_view_column_set_title((*C.GtkTreeViewColumn)(recv.native), c_title)

	return
}

// Sets the visibility of @tree_column.
/*

C function : gtk_tree_view_column_set_visible
*/
func (recv *TreeViewColumn) SetVisible(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_tree_view_column_set_visible((*C.GtkTreeViewColumn)(recv.native), c_visible)

	return
}

// Sets the widget in the header to be @widget.  If widget is %NULL, then the
// header button is set with a #GtkLabel set to the title of @tree_column.
/*

C function : gtk_tree_view_column_set_widget
*/
func (recv *TreeViewColumn) SetWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_tree_view_column_set_widget((*C.GtkTreeViewColumn)(recv.native), c_widget)

	return
}

// Buildable returns the Buildable interface implemented by TreeViewColumn
func (recv *TreeViewColumn) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by TreeViewColumn
func (recv *TreeViewColumn) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// A #GtkUIManager constructs a user interface (menus and toolbars) from
// one or more UI definitions, which reference actions from one or more
// action groups.
//
// # UI Definitions # {#XML-UI}
//
// The UI definitions are specified in an XML format which can be
// roughly described by the following DTD.
//
// > Do not confuse the GtkUIManager UI Definitions described here with
// > the similarly named [GtkBuilder UI Definitions][BUILDER-UI].
//
// |[
// <!ELEMENT ui          (menubar|toolbar|popup|accelerator)* >
// <!ELEMENT menubar     (menuitem|separator|placeholder|menu)* >
// <!ELEMENT menu        (menuitem|separator|placeholder|menu)* >
// <!ELEMENT popup       (menuitem|separator|placeholder|menu)* >
// <!ELEMENT toolbar     (toolitem|separator|placeholder)* >
// <!ELEMENT placeholder (menuitem|toolitem|separator|placeholder|menu)* >
// <!ELEMENT menuitem     EMPTY >
// <!ELEMENT toolitem     (menu?) >
// <!ELEMENT separator    EMPTY >
// <!ELEMENT accelerator  EMPTY >
// <!ATTLIST menubar      name                      #IMPLIED
// action                    #IMPLIED >
// <!ATTLIST toolbar      name                      #IMPLIED
// action                    #IMPLIED >
// <!ATTLIST popup        name                      #IMPLIED
// action                    #IMPLIED
// accelerators (true|false) #IMPLIED >
// <!ATTLIST placeholder  name                      #IMPLIED
// action                    #IMPLIED >
// <!ATTLIST separator    name                      #IMPLIED
// action                    #IMPLIED
// expand       (true|false) #IMPLIED >
// <!ATTLIST menu         name                      #IMPLIED
// action                    #REQUIRED
// position     (top|bot)    #IMPLIED >
// <!ATTLIST menuitem     name                      #IMPLIED
// action                    #REQUIRED
// position     (top|bot)    #IMPLIED
// always-show-image (true|false) #IMPLIED >
// <!ATTLIST toolitem     name                      #IMPLIED
// action                    #REQUIRED
// position     (top|bot)    #IMPLIED >
// <!ATTLIST accelerator  name                      #IMPLIED
// action                    #REQUIRED >
// ]|
//
// There are some additional restrictions beyond those specified in the
// DTD, e.g. every toolitem must have a toolbar in its anchestry and
// every menuitem must have a menubar or popup in its anchestry. Since
// a #GMarkupParser is used to parse the UI description, it must not only
// be valid XML, but valid markup.
//
// If a name is not specified, it defaults to the action. If an action is
// not specified either, the element name is used. The name and action
// attributes must not contain / characters after parsing (since that
// would mess up path lookup) and must be usable as XML attributes when
// enclosed in doublequotes, thus they must not " characters or references
// to the &quot; entity.
//
// # A UI definition #
//
// |[
// <ui>
// <menubar>
// <menu name="FileMenu" action="FileMenuAction">
// <menuitem name="New" action="New2Action" />
// <placeholder name="FileMenuAdditions" />
// </menu>
// <menu name="JustifyMenu" action="JustifyMenuAction">
// <menuitem name="Left" action="justify-left"/>
// <menuitem name="Centre" action="justify-center"/>
// <menuitem name="Right" action="justify-right"/>
// <menuitem name="Fill" action="justify-fill"/>
// </menu>
// </menubar>
// <toolbar action="toolbar1">
// <placeholder name="JustifyToolItems">
// <separator/>
// <toolitem name="Left" action="justify-left"/>
// <toolitem name="Centre" action="justify-center"/>
// <toolitem name="Right" action="justify-right"/>
// <toolitem name="Fill" action="justify-fill"/>
// <separator/>
// </placeholder>
// </toolbar>
// </ui>
// ]|
//
// The constructed widget hierarchy is very similar to the element tree
// of the XML, with the exception that placeholders are merged into their
// parents. The correspondence of XML elements to widgets should be
// almost obvious:
//
// - menubar
//
// a #GtkMenuBar
//
// - toolbar
//
// a #GtkToolbar
//
// - popup
//
// a toplevel #GtkMenu
//
// - menu
//
// a #GtkMenu attached to a menuitem
//
// - menuitem
//
// a #GtkMenuItem subclass, the exact type depends on the action
//
// - toolitem
//
// a #GtkToolItem subclass, the exact type depends on the
// action. Note that toolitem elements may contain a menu element,
// but only if their associated action specifies a
// #GtkMenuToolButton as proxy.
//
// - separator
//
// a #GtkSeparatorMenuItem or #GtkSeparatorToolItem
//
// - accelerator
//
// a keyboard accelerator
//
// The position attribute determines where a constructed widget is positioned
// wrt. to its siblings in the partially constructed tree. If it is
// top, the widget is prepended, otherwise it is appended.
//
// # UI Merging # {#UI-Merging}
//
// The most remarkable feature of #GtkUIManager is that it can overlay a set
// of menuitems and toolitems over another one, and demerge them later.
//
// Merging is done based on the names of the XML elements. Each element is
// identified by a path which consists of the names of its anchestors, separated
// by slashes. For example, the menuitem named Left in the example above
// has the path `/ui/menubar/JustifyMenu/Left` and the
// toolitem with the same name has path
// `/ui/toolbar1/JustifyToolItems/Left`.
//
// # Accelerators #
//
// Every action has an accelerator path. Accelerators are installed together
// with menuitem proxies, but they can also be explicitly added with
// <accelerator> elements in the UI definition. This makes it possible to
// have accelerators for actions even if they have no visible proxies.
//
// # Smart Separators # {#Smart-Separators}
//
// The separators created by #GtkUIManager are smart, i.e. they do not show up
// in the UI unless they end up between two visible menu or tool items. Separators
// which are located at the very beginning or end of the menu or toolbar
// containing them, or multiple separators next to each other, are hidden. This
// is a useful feature, since the merging of UI elements from multiple sources
// can make it hard or impossible to determine in advance whether a separator
// will end up in such an unfortunate position.
//
// For separators in toolbars, you can set `expand="true"` to
// turn them from a small, visible separator to an expanding, invisible one.
// Toolitems following an expanding separator are effectively right-aligned.
//
// # Empty Menus
//
// Submenus pose similar problems to separators inconnection with merging. It is
// impossible to know in advance whether they will end up empty after merging.
// #GtkUIManager offers two ways to treat empty submenus:
//
// - make them disappear by hiding the menu item theyre attached to
//
// - add an insensitive Empty item
//
// The behaviour is chosen based on the hide_if_empty property of the action
// to which the submenu is associated.
//
// # GtkUIManager as GtkBuildable # {#GtkUIManager-BUILDER-UI}
//
// The GtkUIManager implementation of the GtkBuildable interface accepts
// GtkActionGroup objects as <child> elements in UI definitions.
//
// A GtkUIManager UI definition as described above can be embedded in
// an GtkUIManager <object> element in a GtkBuilder UI definition.
//
// The widgets that are constructed by a GtkUIManager can be embedded in
// other parts of the constructed user interface with the help of the
// constructor attribute. See the example below.
//
// ## An embedded GtkUIManager UI definition
//
// |[
// <object class="GtkUIManager" id="uiman">
// <child>
// <object class="GtkActionGroup" id="actiongroup">
// <child>
// <object class="GtkAction" id="file">
// <property name="label">_File</property>
// </object>
// </child>
// </object>
// </child>
// <ui>
// <menubar name="menubar1">
// <menu action="file">
// </menu>
// </menubar>
// </ui>
// </object>
// <object class="GtkWindow" id="main-window">
// <child>
// <object class="GtkMenuBar" id="menubar1" constructor="uiman"/>
// </child>
// </object>
// ]|
/*

C record/class : GtkUIManager
*/
type UIManager struct {
	native *C.GtkUIManager
	// parent : record
	// Private : private_data
}

func UIManagerNewFromC(u unsafe.Pointer) *UIManager {
	c := (*C.GtkUIManager)(u)
	if c == nil {
		return nil
	}

	g := &UIManager{native: c}

	return g
}

func (recv *UIManager) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *UIManager) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to UIManager.
// Exercise care, as this is a potentially dangerous function if the Object is not a UIManager.
func CastToUIManager(object *gobject.Object) *UIManager {
	return UIManagerNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by UIManager
func (recv *UIManager) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// A #GtkVBox is a container that organizes child widgets into a single column.
//
// Use the #GtkBox packing interface to determine the arrangement,
// spacing, height, and alignment of #GtkVBox children.
//
// All children are allocated the same width.
//
// GtkVBox has been deprecated. You can use #GtkBox instead, which is a
// very quick and easychange. If you have derived your own classes from
// GtkVBox, you can simply change the inheritance to derive directly
// from #GtkBox, and set the #GtkOrientable:orientation property to
// %GTK_ORIENTATION_VERTICAL in your instance init function, with a
// call like:
// |[<!-- language="C" -->
// gtk_orientable_set_orientation (GTK_ORIENTABLE (object),
// GTK_ORIENTATION_VERTICAL);
// ]|
// If you dont need first-child or last-child styling and want your code
// to be future-proof, the recommendation is to switch to #GtkGrid instead
// of nested boxes. For more information about migrating to #GtkGrid,
// see [Migrating from other containers to GtkGrid][gtk-migrating-GtkGrid].
/*

C record/class : GtkVBox
*/
type VBox struct {
	native *C.GtkVBox
	// box : record
}

func VBoxNewFromC(u unsafe.Pointer) *VBox {
	c := (*C.GtkVBox)(u)
	if c == nil {
		return nil
	}

	g := &VBox{native: c}

	return g
}

func (recv *VBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *VBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *VBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *VBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to VBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a VBox.
func CastToVBox(object *gobject.Object) *VBox {
	return VBoxNewFromC(object.ToC())
}

// Creates a new #GtkVBox.
/*

C function : gtk_vbox_new
*/
func VBoxNew(homogeneous bool, spacing int32) *VBox {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	c_spacing := (C.gint)(spacing)

	retC := C.gtk_vbox_new(c_homogeneous, c_spacing)
	retGo := VBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VBox
func (recv *VBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VBox
func (recv *VBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VBox
func (recv *VBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

/*

C record/class : GtkVButtonBox
*/
type VButtonBox struct {
	native *C.GtkVButtonBox
	// button_box : record
}

func VButtonBoxNewFromC(u unsafe.Pointer) *VButtonBox {
	c := (*C.GtkVButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &VButtonBox{native: c}

	return g
}

func (recv *VButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonBox upcasts to *ButtonBox
func (recv *VButtonBox) ButtonBox() *ButtonBox {
	return ButtonBoxNewFromC(unsafe.Pointer(recv.native))
}

// Box upcasts to *Box
func (recv *VButtonBox) Box() *Box {
	return recv.ButtonBox().Box()
}

// Container upcasts to *Container
func (recv *VButtonBox) Container() *Container {
	return recv.ButtonBox().Container()
}

// Widget upcasts to *Widget
func (recv *VButtonBox) Widget() *Widget {
	return recv.ButtonBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ButtonBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VButtonBox) Object() *gobject.Object {
	return recv.ButtonBox().Object()
}

// CastToWidget down casts any arbitary Object to VButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a VButtonBox.
func CastToVButtonBox(object *gobject.Object) *VButtonBox {
	return VButtonBoxNewFromC(object.ToC())
}

// Creates a new vertical button box.
/*

C function : gtk_vbutton_box_new
*/
func VButtonBoxNew() *VButtonBox {
	retC := C.gtk_vbutton_box_new()
	retGo := VButtonBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VButtonBox
func (recv *VButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VButtonBox
func (recv *VButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VButtonBox
func (recv *VButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The VPaned widget is a container widget with two
// children arranged vertically. The division between
// the two panes is adjustable by the user by dragging
// a handle. See #GtkPaned for details.
//
// GtkVPaned has been deprecated, use #GtkPaned instead.
/*

C record/class : GtkVPaned
*/
type VPaned struct {
	native *C.GtkVPaned
	// paned : record
}

func VPanedNewFromC(u unsafe.Pointer) *VPaned {
	c := (*C.GtkVPaned)(u)
	if c == nil {
		return nil
	}

	g := &VPaned{native: c}

	return g
}

func (recv *VPaned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Paned upcasts to *Paned
func (recv *VPaned) Paned() *Paned {
	return PanedNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *VPaned) Container() *Container {
	return recv.Paned().Container()
}

// Widget upcasts to *Widget
func (recv *VPaned) Widget() *Widget {
	return recv.Paned().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VPaned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Paned().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VPaned) Object() *gobject.Object {
	return recv.Paned().Object()
}

// CastToWidget down casts any arbitary Object to VPaned.
// Exercise care, as this is a potentially dangerous function if the Object is not a VPaned.
func CastToVPaned(object *gobject.Object) *VPaned {
	return VPanedNewFromC(object.ToC())
}

// Create a new #GtkVPaned
/*

C function : gtk_vpaned_new
*/
func VPanedNew() *VPaned {
	retC := C.gtk_vpaned_new()
	retGo := VPanedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VPaned
func (recv *VPaned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VPaned
func (recv *VPaned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VPaned
func (recv *VPaned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkVScale widget is used to allow the user to select a value using
// a vertical slider. To create one, use gtk_hscale_new_with_range().
//
// The position to show the current value, and the number of decimal places
// shown can be set using the parent #GtkScale classs functions.
//
// GtkVScale has been deprecated, use #GtkScale instead.
/*

C record/class : GtkVScale
*/
type VScale struct {
	native *C.GtkVScale
	// scale : record
}

func VScaleNewFromC(u unsafe.Pointer) *VScale {
	c := (*C.GtkVScale)(u)
	if c == nil {
		return nil
	}

	g := &VScale{native: c}

	return g
}

func (recv *VScale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Scale upcasts to *Scale
func (recv *VScale) Scale() *Scale {
	return ScaleNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *VScale) Range() *Range {
	return recv.Scale().Range()
}

// Widget upcasts to *Widget
func (recv *VScale) Widget() *Widget {
	return recv.Scale().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VScale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scale().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VScale) Object() *gobject.Object {
	return recv.Scale().Object()
}

// CastToWidget down casts any arbitary Object to VScale.
// Exercise care, as this is a potentially dangerous function if the Object is not a VScale.
func CastToVScale(object *gobject.Object) *VScale {
	return VScaleNewFromC(object.ToC())
}

// Creates a new #GtkVScale.
/*

C function : gtk_vscale_new
*/
func VScaleNew(adjustment *Adjustment) *VScale {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_vscale_new(c_adjustment)
	retGo := VScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new vertical scale widget that lets the user input a
// number between @min and @max (including @min and @max) with the
// increment @step.  @step must be nonzero; its the distance the
// slider moves when using the arrow keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if @step
// is a power of ten. If the resulting precision is not suitable for your
// needs, use gtk_scale_set_digits() to correct it.
/*

C function : gtk_vscale_new_with_range
*/
func VScaleNewWithRange(min float64, max float64, step float64) *VScale {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_vscale_new_with_range(c_min, c_max, c_step)
	retGo := VScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VScale
func (recv *VScale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VScale
func (recv *VScale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VScale
func (recv *VScale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkVScrollbar widget is a widget arranged vertically creating a
// scrollbar. See #GtkScrollbar for details on
// scrollbars. #GtkAdjustment pointers may be added to handle the
// adjustment of the scrollbar or it may be left %NULL in which case one
// will be created for you. See #GtkScrollbar for a description of what the
// fields in an adjustment represent for a scrollbar.
//
// GtkVScrollbar has been deprecated, use #GtkScrollbar instead.
/*

C record/class : GtkVScrollbar
*/
type VScrollbar struct {
	native *C.GtkVScrollbar
	// scrollbar : record
}

func VScrollbarNewFromC(u unsafe.Pointer) *VScrollbar {
	c := (*C.GtkVScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &VScrollbar{native: c}

	return g
}

func (recv *VScrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Scrollbar upcasts to *Scrollbar
func (recv *VScrollbar) Scrollbar() *Scrollbar {
	return ScrollbarNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *VScrollbar) Range() *Range {
	return recv.Scrollbar().Range()
}

// Widget upcasts to *Widget
func (recv *VScrollbar) Widget() *Widget {
	return recv.Scrollbar().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VScrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scrollbar().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VScrollbar) Object() *gobject.Object {
	return recv.Scrollbar().Object()
}

// CastToWidget down casts any arbitary Object to VScrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a VScrollbar.
func CastToVScrollbar(object *gobject.Object) *VScrollbar {
	return VScrollbarNewFromC(object.ToC())
}

// Creates a new vertical scrollbar.
/*

C function : gtk_vscrollbar_new
*/
func VScrollbarNew(adjustment *Adjustment) *VScrollbar {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_vscrollbar_new(c_adjustment)
	retGo := VScrollbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VScrollbar
func (recv *VScrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VScrollbar
func (recv *VScrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VScrollbar
func (recv *VScrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkVSeparator widget is a vertical separator, used to group the
// widgets within a window. It displays a vertical line with a shadow to
// make it appear sunken into the interface.
//
// GtkVSeparator has been deprecated, use #GtkSeparator instead.
/*

C record/class : GtkVSeparator
*/
type VSeparator struct {
	native *C.GtkVSeparator
	// separator : record
}

func VSeparatorNewFromC(u unsafe.Pointer) *VSeparator {
	c := (*C.GtkVSeparator)(u)
	if c == nil {
		return nil
	}

	g := &VSeparator{native: c}

	return g
}

func (recv *VSeparator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Separator upcasts to *Separator
func (recv *VSeparator) Separator() *Separator {
	return SeparatorNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *VSeparator) Widget() *Widget {
	return recv.Separator().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VSeparator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Separator().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VSeparator) Object() *gobject.Object {
	return recv.Separator().Object()
}

// CastToWidget down casts any arbitary Object to VSeparator.
// Exercise care, as this is a potentially dangerous function if the Object is not a VSeparator.
func CastToVSeparator(object *gobject.Object) *VSeparator {
	return VSeparatorNewFromC(object.ToC())
}

// Creates a new #GtkVSeparator.
/*

C function : gtk_vseparator_new
*/
func VSeparatorNew() *VSeparator {
	retC := C.gtk_vseparator_new()
	retGo := VSeparatorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VSeparator
func (recv *VSeparator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VSeparator
func (recv *VSeparator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VSeparator
func (recv *VSeparator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// The #GtkViewport widget acts as an adaptor class, implementing
// scrollability for child widgets that lack their own scrolling
// capabilities. Use GtkViewport to scroll child widgets such as
// #GtkGrid, #GtkBox, and so on.
//
// If a widget has native scrolling abilities, such as #GtkTextView,
// #GtkTreeView or #GtkIconView, it can be added to a #GtkScrolledWindow
// with gtk_container_add(). If a widget does not, you must first add the
// widget to a #GtkViewport, then add the viewport to the scrolled window.
// gtk_container_add() does this automatically if a child that does not
// implement #GtkScrollable is added to a #GtkScrolledWindow, so you can
// ignore the presence of the viewport.
//
// The GtkViewport will start scrolling content only if allocated less
// than the child widgets minimum size in a given orientation.
//
// # CSS nodes
//
// GtkViewport has a single CSS node with name viewport.
/*

C record/class : GtkViewport
*/
type Viewport struct {
	native *C.GtkViewport
	// bin : record
	// Private : priv
}

func ViewportNewFromC(u unsafe.Pointer) *Viewport {
	c := (*C.GtkViewport)(u)
	if c == nil {
		return nil
	}

	g := &Viewport{native: c}

	return g
}

func (recv *Viewport) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Viewport) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Viewport) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Viewport) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Viewport) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Viewport) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Viewport.
// Exercise care, as this is a potentially dangerous function if the Object is not a Viewport.
func CastToViewport(object *gobject.Object) *Viewport {
	return ViewportNewFromC(object.ToC())
}

// Creates a new #GtkViewport with the given adjustments, or with default
// adjustments if none are given.
/*

C function : gtk_viewport_new
*/
func ViewportNew(hadjustment *Adjustment, vadjustment *Adjustment) *Viewport {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_viewport_new(c_hadjustment, c_vadjustment)
	retGo := ViewportNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the horizontal adjustment of the viewport.
/*

C function : gtk_viewport_get_hadjustment
*/
func (recv *Viewport) GetHadjustment() *Adjustment {
	retC := C.gtk_viewport_get_hadjustment((*C.GtkViewport)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the shadow type of the #GtkViewport. See
// gtk_viewport_set_shadow_type().
/*

C function : gtk_viewport_get_shadow_type
*/
func (recv *Viewport) GetShadowType() ShadowType {
	retC := C.gtk_viewport_get_shadow_type((*C.GtkViewport)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// Returns the vertical adjustment of the viewport.
/*

C function : gtk_viewport_get_vadjustment
*/
func (recv *Viewport) GetVadjustment() *Adjustment {
	retC := C.gtk_viewport_get_vadjustment((*C.GtkViewport)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the horizontal adjustment of the viewport.
/*

C function : gtk_viewport_set_hadjustment
*/
func (recv *Viewport) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_viewport_set_hadjustment((*C.GtkViewport)(recv.native), c_adjustment)

	return
}

// Sets the shadow type of the viewport.
/*

C function : gtk_viewport_set_shadow_type
*/
func (recv *Viewport) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_viewport_set_shadow_type((*C.GtkViewport)(recv.native), c_type)

	return
}

// Sets the vertical adjustment of the viewport.
/*

C function : gtk_viewport_set_vadjustment
*/
func (recv *Viewport) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_viewport_set_vadjustment((*C.GtkViewport)(recv.native), c_adjustment)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Viewport
func (recv *Viewport) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Viewport
func (recv *Viewport) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by Viewport
func (recv *Viewport) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// #GtkVolumeButton is a subclass of #GtkScaleButton that has
// been tailored for use as a volume control widget with suitable
// icons, tooltips and accessible labels.
/*

C record/class : GtkVolumeButton
*/
type VolumeButton struct {
	native *C.GtkVolumeButton
	// parent : record
}

func VolumeButtonNewFromC(u unsafe.Pointer) *VolumeButton {
	c := (*C.GtkVolumeButton)(u)
	if c == nil {
		return nil
	}

	g := &VolumeButton{native: c}

	return g
}

func (recv *VolumeButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ScaleButton upcasts to *ScaleButton
func (recv *VolumeButton) ScaleButton() *ScaleButton {
	return ScaleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *VolumeButton) Button() *Button {
	return recv.ScaleButton().Button()
}

// Bin upcasts to *Bin
func (recv *VolumeButton) Bin() *Bin {
	return recv.ScaleButton().Bin()
}

// Container upcasts to *Container
func (recv *VolumeButton) Container() *Container {
	return recv.ScaleButton().Container()
}

// Widget upcasts to *Widget
func (recv *VolumeButton) Widget() *Widget {
	return recv.ScaleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VolumeButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ScaleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VolumeButton) Object() *gobject.Object {
	return recv.ScaleButton().Object()
}

// CastToWidget down casts any arbitary Object to VolumeButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a VolumeButton.
func CastToVolumeButton(object *gobject.Object) *VolumeButton {
	return VolumeButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by VolumeButton
func (recv *VolumeButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by VolumeButton
func (recv *VolumeButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by VolumeButton
func (recv *VolumeButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VolumeButton
func (recv *VolumeButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VolumeButton
func (recv *VolumeButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// GtkWidget is the base class all widgets in GTK+ derive from. It manages the
// widget lifecycle, states and style.
//
// # Height-for-width Geometry Management # {#geometry-management}
//
// GTK+ uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much
// vertical space it needs, depending on the amount of horizontal space
// that it is given (and similar for width-for-height). The most common
// example is a label that reflows to fill up the available width, wraps
// to fewer lines, and therefore needs less height.
//
// Height-for-width geometry management is implemented in GTK+ by way
// of five virtual methods:
//
// - #GtkWidgetClass.get_request_mode()
// - #GtkWidgetClass.get_preferred_width()
// - #GtkWidgetClass.get_preferred_height()
// - #GtkWidgetClass.get_preferred_height_for_width()
// - #GtkWidgetClass.get_preferred_width_for_height()
// - #GtkWidgetClass.get_preferred_height_and_baseline_for_width()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in container implementations.
//
// The geometry management system will query a widget hierarchy in
// only one orientation at a time. When widgets are initially queried
// for their minimum sizes it is generally done in two initial passes
// in the #GtkSizeRequestMode chosen by the toplevel.
//
// For example, when queried in the normal
// %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH mode:
// First, the default minimum and natural width for each widget
// in the interface will be computed using gtk_widget_get_preferred_width().
// Because the preferred widths for each container depend on the preferred
// widths of their children, this information propagates up the hierarchy,
// and finally a minimum and natural width is determined for the entire
// toplevel. Next, the toplevel will use the minimum width to query for the
// minimum height contextual to that width using
// gtk_widget_get_preferred_height_for_width(), which will also be a highly
// recursive operation. The minimum height for the minimum width is normally
// used to set the minimum size constraint on the toplevel
// (unless gtk_window_set_geometry_hints() is explicitly used instead).
//
// After the toplevel window has initially requested its size in both
// dimensions it can go on to allocate itself a reasonable size (or a size
// previously specified with gtk_window_set_default_size()). During the
// recursive allocation process its important to note that request cycles
// will be recursively executed while container widgets allocate their children.
// Each container widget, once allocated a size, will go on to first share the
// space in one orientation among its children and then request each child's
// height for its target allocated width or its width for allocated height,
// depending. In this way a #GtkWidget will typically be requested its size
// a number of times before actually being allocated a size. The size a
// widget is finally allocated can of course differ from the size it has
// requested. For this reason, #GtkWidget caches a  small number of results
// to avoid re-querying for the same sizes in one allocation cycle.
//
// See
// [GtkContainers geometry management section][container-geometry-management]
// to learn more about how height-for-width allocations are performed
// by container widgets.
//
// If a widget does move content around to intelligently use up the
// allocated size then it must support the request in both
// #GtkSizeRequestModes even if the widget in question only
// trades sizes in a single orientation.
//
// For instance, a #GtkLabel that does height-for-width word wrapping
// will not expect to have #GtkWidgetClass.get_preferred_height() called
// because that call is specific to a width-for-height request. In this
// case the label must return the height required for its own minimum
// possible width. By following this rule any widget that handles
// height-for-width or width-for-height requests will always be allocated
// at least enough space to fit its own content.
//
// Here are some examples of how a %GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests, for #GtkWidgetClass.get_preferred_height()
// it will do:
//
// |[<!-- language="C" -->
// static void
// foo_widget_get_preferred_height (GtkWidget *widget,
// gint *min_height,
// gint *nat_height)
// {
// if (i_am_in_height_for_width_mode)
// {
// gint min_width, nat_width;
//
// GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
// &min_width,
// &nat_width);
// GTK_WIDGET_GET_CLASS (widget)->get_preferred_height_for_width
// (widget,
// min_width,
// min_height,
// nat_height);
// }
// else
// {
// ... some widgets do both. For instance, if a GtkLabel is
// rotated to 90 degrees it will return the minimum and
// natural height for the rotated label here.
// }
// }
// ]|
//
// And in #GtkWidgetClass.get_preferred_width_for_height() it will simply return
// the minimum and natural width:
// |[<!-- language="C" -->
// static void
// foo_widget_get_preferred_width_for_height (GtkWidget *widget,
// gint for_height,
// gint *min_width,
// gint *nat_width)
// {
// if (i_am_in_height_for_width_mode)
// {
// GTK_WIDGET_GET_CLASS (widget)->get_preferred_width (widget,
// min_width,
// nat_width);
// }
// else
// {
// ... again if a widget is sometimes operating in
// width-for-height mode (like a rotated GtkLabel) it can go
// ahead and do its real width for height calculation here.
// }
// }
// ]|
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also
// compute width. Or when deciding how to use an allocation, the widget
// may need to know its natural size. In these cases, the widget should
// be careful to call its virtual methods directly, like this:
//
// |[<!-- language="C" -->
// GTK_WIDGET_GET_CLASS(widget)->get_preferred_width (widget,
// &min,
// &natural);
// ]|
//
// It will not work to use the wrapper functions, such as
// gtk_widget_get_preferred_width() inside your own size request
// implementation. These return a request adjusted by #GtkSizeGroup
// and by the #GtkWidgetClass.adjust_size_request() virtual method. If a
// widget used the wrappers inside its virtual method implementations,
// then the adjustments (such as widget margins) would be applied
// twice. GTK+ therefore does not allow this and will warn if you try
// to do it.
//
// Of course if you are getting the size request for
// another widget, such as a child of a
// container, you must use the wrapper APIs.
// Otherwise, you would not properly consider widget margins,
// #GtkSizeGroup, and so forth.
//
// Since 3.10 GTK+ also supports baseline vertical alignment of widgets. This
// means that widgets are positioned such that the typographical baseline of
// widgets in the same row are aligned. This happens if a widget supports baselines,
// has a vertical alignment of %GTK_ALIGN_BASELINE, and is inside a container
// that supports baselines and has a natural row that it aligns to the baseline,
// or a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is done by the #GtkWidgetClass.get_preferred_height_and_baseline_for_width()
// virtual function. It allows you to report a baseline in combination with the
// minimum and natural height. If there is no baseline you can return -1 to indicate
// this. The default implementation of this virtual function calls into the
// #GtkWidgetClass.get_preferred_height() and #GtkWidgetClass.get_preferred_height_for_width(),
// so if baselines are not supported it doesnt need to be implemented.
//
// If a widget ends up baseline aligned it will be allocated all the space in the parent
// as if it was %GTK_ALIGN_FILL, but the selected baseline can be found via gtk_widget_get_allocated_baseline().
// If this has a value other than -1 you need to align the widget such that the baseline
// appears at the position.
//
// # Style Properties
//
// #GtkWidget introduces style
// properties - these are basically object properties that are stored
// not on the object, but in the style object associated to the widget. Style
// properties are set in [resource files][gtk3-Resource-Files].
// This mechanism is used for configuring such things as the location of the
// scrollbar arrows through the theme, giving theme authors more control over the
// look of applications without the need to write a theme engine in C.
//
// Use gtk_widget_class_install_style_property() to install style properties for
// a widget class, gtk_widget_class_find_style_property() or
// gtk_widget_class_list_style_properties() to get information about existing
// style properties and gtk_widget_style_get_property(), gtk_widget_style_get() or
// gtk_widget_style_get_valist() to obtain the value of a style property.
//
// # GtkWidget as GtkBuildable
//
// The GtkWidget implementation of the GtkBuildable interface supports a
// custom <accelerator> element, which has attributes named key, modifiers
// and signal and allows to specify accelerators.
//
// An example of a UI definition fragment specifying an accelerator:
// |[
// <object class="GtkButton">
// <accelerator key="q" modifiers="GDK_CONTROL_MASK" signal="clicked"/>
// </object>
// ]|
//
// In addition to accelerators, GtkWidget also support a custom <accessible>
// element, which supports actions and relations. Properties on the accessible
// implementation of an object can be set by accessing the internal child
// accessible of a #GtkWidget.
//
// An example of a UI definition fragment specifying an accessible:
// |[
// <object class="GtkButton" id="label1"/>
// <property name="label">I am a Label for a Button</property>
// </object>
// <object class="GtkButton" id="button1">
// <accessibility>
// <action action_name="click" translatable="yes">Click the button.</action>
// <relation target="label1" type="labelled-by"/>
// </accessibility>
// <child internal-child="accessible">
// <object class="AtkObject" id="a11y-button1">
// <property name="accessible-name">Clickable Button</property>
// </object>
// </child>
// </object>
// ]|
//
// Finally, GtkWidget allows style information such as style classes to
// be associated with widgets, using the custom <style> element:
// |[
// <object class="GtkButton" id="button1">
// <style>
// <class name="my-special-button-class"/>
// <class name="dark-button"/>
// </style>
// </object>
// ]|
//
// # Building composite widgets from template XML ## {#composite-templates}
//
// GtkWidget exposes some facilities to automate the procedure
// of creating composite widgets using #GtkBuilder interface description
// language.
//
// To create composite widgets with #GtkBuilder XML, one must associate
// the interface description with the widget class at class initialization
// time using gtk_widget_class_set_template().
//
// The interface description semantics expected in composite template descriptions
// is slightly different from regular #GtkBuilder XML.
//
// Unlike regular interface descriptions, gtk_widget_class_set_template() will
// expect a <template> tag as a direct child of the toplevel <interface>
// tag. The <template> tag must specify the class attribute which must be
// the type name of the widget. Optionally, the parent attribute may be
// specified to specify the direct parent type of the widget type, this is
// ignored by the GtkBuilder but required for Glade to introspect what kind
// of properties and internal children exist for a given type when the actual
// type does not exist.
//
// The XML which is contained inside the <template> tag behaves as if it were
// added to the <object> tag defining @widget itself. You may set properties
// on @widget by inserting <property> tags into the <template> tag, and also
// add <child> tags to add children and extend @widget in the normal way you
// would with <object> tags.
//
// Additionally, <object> tags can also be added before and after the initial
// <template> tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// <template> tag.
//
// An example of a GtkBuilder Template Definition:
// |[
// <interface>
// <template class="FooWidget" parent="GtkBox">
// <property name="orientation">GTK_ORIENTATION_HORIZONTAL</property>
// <property name="spacing">4</property>
// <child>
// <object class="GtkButton" id="hello_button">
// <property name="label">Hello World</property>
// <signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/>
// </object>
// </child>
// <child>
// <object class="GtkButton" id="goodbye_button">
// <property name="label">Goodbye World</property>
// </object>
// </child>
// </template>
// </interface>
// ]|
//
// Typically, you'll place the template fragment into a file that is
// bundled with your project, using #GResource. In order to load the
// template, you need to call gtk_widget_class_set_template_from_resource()
// from the class initialization of your #GtkWidget type:
//
// |[<!-- language="C" -->
// static void
// foo_widget_class_init (FooWidgetClass *klass)
// {
// ...
//
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui");
// }
// ]|
//
// You will also need to call gtk_widget_init_template() from the instance
// initialization function:
//
// |[<!-- language="C" -->
// static void
// foo_widget_init (FooWidget *self)
// {
// ...
// gtk_widget_init_template (GTK_WIDGET (self));
// }
// ]|
//
// You can access widgets defined in the template using the
// gtk_widget_get_template_child() function, but you will typically declare
// a pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// gtk_widget_class_bind_template_child_private() with that name, e.g.
//
// |[<!-- language="C" -->
// typedef struct {
// GtkWidget *hello_button;
// GtkWidget *goodbye_button;
// } FooWidgetPrivate;
//
// G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
// static void
// foo_widget_class_init (FooWidgetClass *klass)
// {
// ...
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui");
// gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
// FooWidget, hello_button);
// gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
// FooWidget, goodbye_button);
// }
//
// static void
// foo_widget_init (FooWidget *widget)
// {
//
// }
// ]|
//
// You can also use gtk_widget_class_bind_template_callback() to connect a signal
// callback defined in the template with a function visible in the scope of the
// class, e.g.
//
// |[<!-- language="C" -->
// the signal handler has the instance and user data swapped
// because of the swapped="yes" attribute in the template XML
// static void
// hello_button_clicked (FooWidget *self,
// GtkButton *button)
// {
// g_print ("Hello, world!\n");
// }
//
// static void
// foo_widget_class_init (FooWidgetClass *klass)
// {
// ...
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui");
// gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
// }
// ]|
/*

C record/class : GtkWidget
*/
type Widget struct {
	native *C.GtkWidget
	// parent_instance : record
	// Private : priv
}

func WidgetNewFromC(u unsafe.Pointer) *Widget {
	c := (*C.GtkWidget)(u)
	if c == nil {
		return nil
	}

	g := &Widget{native: c}

	return g
}

func (recv *Widget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Widget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Widget) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to Widget.
// Exercise care, as this is a potentially dangerous function if the Object is not a Widget.
func CastToWidget(object *gobject.Object) *Widget {
	return WidgetNewFromC(object.ToC())
}

type signalWidgetAccelClosuresChangedDetail struct {
	callback  WidgetSignalAccelClosuresChangedCallback
	handlerID C.gulong
}

var signalWidgetAccelClosuresChangedId int
var signalWidgetAccelClosuresChangedMap = make(map[int]signalWidgetAccelClosuresChangedDetail)
var signalWidgetAccelClosuresChangedLock sync.Mutex

// WidgetSignalAccelClosuresChangedCallback is a callback function for a 'accel-closures-changed' signal emitted from a Widget.
type WidgetSignalAccelClosuresChangedCallback func()

/*
ConnectAccelClosuresChanged connects the callback to the 'accel-closures-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectAccelClosuresChanged to remove it.
*/
func (recv *Widget) ConnectAccelClosuresChanged(callback WidgetSignalAccelClosuresChangedCallback) int {
	signalWidgetAccelClosuresChangedLock.Lock()
	defer signalWidgetAccelClosuresChangedLock.Unlock()

	signalWidgetAccelClosuresChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_accel_closures_changed(instance, C.gpointer(uintptr(signalWidgetAccelClosuresChangedId)))

	detail := signalWidgetAccelClosuresChangedDetail{callback, handlerID}
	signalWidgetAccelClosuresChangedMap[signalWidgetAccelClosuresChangedId] = detail

	return signalWidgetAccelClosuresChangedId
}

/*
DisconnectAccelClosuresChanged disconnects a callback from the 'accel-closures-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectAccelClosuresChanged.
*/
func (recv *Widget) DisconnectAccelClosuresChanged(connectionID int) {
	signalWidgetAccelClosuresChangedLock.Lock()
	defer signalWidgetAccelClosuresChangedLock.Unlock()

	detail, exists := signalWidgetAccelClosuresChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetAccelClosuresChangedMap, connectionID)
}

//export widget_accelClosuresChangedHandler
func widget_accelClosuresChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetAccelClosuresChangedMap[index].callback
	callback()
}

type signalWidgetButtonPressEventDetail struct {
	callback  WidgetSignalButtonPressEventCallback
	handlerID C.gulong
}

var signalWidgetButtonPressEventId int
var signalWidgetButtonPressEventMap = make(map[int]signalWidgetButtonPressEventDetail)
var signalWidgetButtonPressEventLock sync.Mutex

// WidgetSignalButtonPressEventCallback is a callback function for a 'button-press-event' signal emitted from a Widget.
type WidgetSignalButtonPressEventCallback func(event *gdk.EventButton) bool

/*
ConnectButtonPressEvent connects the callback to the 'button-press-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectButtonPressEvent to remove it.
*/
func (recv *Widget) ConnectButtonPressEvent(callback WidgetSignalButtonPressEventCallback) int {
	signalWidgetButtonPressEventLock.Lock()
	defer signalWidgetButtonPressEventLock.Unlock()

	signalWidgetButtonPressEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_button_press_event(instance, C.gpointer(uintptr(signalWidgetButtonPressEventId)))

	detail := signalWidgetButtonPressEventDetail{callback, handlerID}
	signalWidgetButtonPressEventMap[signalWidgetButtonPressEventId] = detail

	return signalWidgetButtonPressEventId
}

/*
DisconnectButtonPressEvent disconnects a callback from the 'button-press-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectButtonPressEvent.
*/
func (recv *Widget) DisconnectButtonPressEvent(connectionID int) {
	signalWidgetButtonPressEventLock.Lock()
	defer signalWidgetButtonPressEventLock.Unlock()

	detail, exists := signalWidgetButtonPressEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetButtonPressEventMap, connectionID)
}

//export widget_buttonPressEventHandler
func widget_buttonPressEventHandler(_ *C.GObject, c_event *C.GdkEventButton, data C.gpointer) C.gboolean {
	event := gdk.EventButtonNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetButtonPressEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetButtonReleaseEventDetail struct {
	callback  WidgetSignalButtonReleaseEventCallback
	handlerID C.gulong
}

var signalWidgetButtonReleaseEventId int
var signalWidgetButtonReleaseEventMap = make(map[int]signalWidgetButtonReleaseEventDetail)
var signalWidgetButtonReleaseEventLock sync.Mutex

// WidgetSignalButtonReleaseEventCallback is a callback function for a 'button-release-event' signal emitted from a Widget.
type WidgetSignalButtonReleaseEventCallback func(event *gdk.EventButton) bool

/*
ConnectButtonReleaseEvent connects the callback to the 'button-release-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectButtonReleaseEvent to remove it.
*/
func (recv *Widget) ConnectButtonReleaseEvent(callback WidgetSignalButtonReleaseEventCallback) int {
	signalWidgetButtonReleaseEventLock.Lock()
	defer signalWidgetButtonReleaseEventLock.Unlock()

	signalWidgetButtonReleaseEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_button_release_event(instance, C.gpointer(uintptr(signalWidgetButtonReleaseEventId)))

	detail := signalWidgetButtonReleaseEventDetail{callback, handlerID}
	signalWidgetButtonReleaseEventMap[signalWidgetButtonReleaseEventId] = detail

	return signalWidgetButtonReleaseEventId
}

/*
DisconnectButtonReleaseEvent disconnects a callback from the 'button-release-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectButtonReleaseEvent.
*/
func (recv *Widget) DisconnectButtonReleaseEvent(connectionID int) {
	signalWidgetButtonReleaseEventLock.Lock()
	defer signalWidgetButtonReleaseEventLock.Unlock()

	detail, exists := signalWidgetButtonReleaseEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetButtonReleaseEventMap, connectionID)
}

//export widget_buttonReleaseEventHandler
func widget_buttonReleaseEventHandler(_ *C.GObject, c_event *C.GdkEventButton, data C.gpointer) C.gboolean {
	event := gdk.EventButtonNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetButtonReleaseEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'can-activate-accel' for Widget : unsupported parameter signal_id : type guint :

// Unsupported signal 'child-notify' for Widget : unsupported parameter child_property : type GObject.ParamSpec : Blacklisted record : GParamSpec

type signalWidgetCompositedChangedDetail struct {
	callback  WidgetSignalCompositedChangedCallback
	handlerID C.gulong
}

var signalWidgetCompositedChangedId int
var signalWidgetCompositedChangedMap = make(map[int]signalWidgetCompositedChangedDetail)
var signalWidgetCompositedChangedLock sync.Mutex

// WidgetSignalCompositedChangedCallback is a callback function for a 'composited-changed' signal emitted from a Widget.
type WidgetSignalCompositedChangedCallback func()

/*
ConnectCompositedChanged connects the callback to the 'composited-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectCompositedChanged to remove it.
*/
func (recv *Widget) ConnectCompositedChanged(callback WidgetSignalCompositedChangedCallback) int {
	signalWidgetCompositedChangedLock.Lock()
	defer signalWidgetCompositedChangedLock.Unlock()

	signalWidgetCompositedChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_composited_changed(instance, C.gpointer(uintptr(signalWidgetCompositedChangedId)))

	detail := signalWidgetCompositedChangedDetail{callback, handlerID}
	signalWidgetCompositedChangedMap[signalWidgetCompositedChangedId] = detail

	return signalWidgetCompositedChangedId
}

/*
DisconnectCompositedChanged disconnects a callback from the 'composited-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectCompositedChanged.
*/
func (recv *Widget) DisconnectCompositedChanged(connectionID int) {
	signalWidgetCompositedChangedLock.Lock()
	defer signalWidgetCompositedChangedLock.Unlock()

	detail, exists := signalWidgetCompositedChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetCompositedChangedMap, connectionID)
}

//export widget_compositedChangedHandler
func widget_compositedChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetCompositedChangedMap[index].callback
	callback()
}

type signalWidgetConfigureEventDetail struct {
	callback  WidgetSignalConfigureEventCallback
	handlerID C.gulong
}

var signalWidgetConfigureEventId int
var signalWidgetConfigureEventMap = make(map[int]signalWidgetConfigureEventDetail)
var signalWidgetConfigureEventLock sync.Mutex

// WidgetSignalConfigureEventCallback is a callback function for a 'configure-event' signal emitted from a Widget.
type WidgetSignalConfigureEventCallback func(event *gdk.EventConfigure) bool

/*
ConnectConfigureEvent connects the callback to the 'configure-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectConfigureEvent to remove it.
*/
func (recv *Widget) ConnectConfigureEvent(callback WidgetSignalConfigureEventCallback) int {
	signalWidgetConfigureEventLock.Lock()
	defer signalWidgetConfigureEventLock.Unlock()

	signalWidgetConfigureEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_configure_event(instance, C.gpointer(uintptr(signalWidgetConfigureEventId)))

	detail := signalWidgetConfigureEventDetail{callback, handlerID}
	signalWidgetConfigureEventMap[signalWidgetConfigureEventId] = detail

	return signalWidgetConfigureEventId
}

/*
DisconnectConfigureEvent disconnects a callback from the 'configure-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectConfigureEvent.
*/
func (recv *Widget) DisconnectConfigureEvent(connectionID int) {
	signalWidgetConfigureEventLock.Lock()
	defer signalWidgetConfigureEventLock.Unlock()

	detail, exists := signalWidgetConfigureEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetConfigureEventMap, connectionID)
}

//export widget_configureEventHandler
func widget_configureEventHandler(_ *C.GObject, c_event *C.GdkEventConfigure, data C.gpointer) C.gboolean {
	event := gdk.EventConfigureNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetConfigureEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'delete-event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

type signalWidgetDestroyDetail struct {
	callback  WidgetSignalDestroyCallback
	handlerID C.gulong
}

var signalWidgetDestroyId int
var signalWidgetDestroyMap = make(map[int]signalWidgetDestroyDetail)
var signalWidgetDestroyLock sync.Mutex

// WidgetSignalDestroyCallback is a callback function for a 'destroy' signal emitted from a Widget.
type WidgetSignalDestroyCallback func()

/*
ConnectDestroy connects the callback to the 'destroy' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDestroy to remove it.
*/
func (recv *Widget) ConnectDestroy(callback WidgetSignalDestroyCallback) int {
	signalWidgetDestroyLock.Lock()
	defer signalWidgetDestroyLock.Unlock()

	signalWidgetDestroyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_destroy(instance, C.gpointer(uintptr(signalWidgetDestroyId)))

	detail := signalWidgetDestroyDetail{callback, handlerID}
	signalWidgetDestroyMap[signalWidgetDestroyId] = detail

	return signalWidgetDestroyId
}

/*
DisconnectDestroy disconnects a callback from the 'destroy' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDestroy.
*/
func (recv *Widget) DisconnectDestroy(connectionID int) {
	signalWidgetDestroyLock.Lock()
	defer signalWidgetDestroyLock.Unlock()

	detail, exists := signalWidgetDestroyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDestroyMap, connectionID)
}

//export widget_destroyHandler
func widget_destroyHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetDestroyMap[index].callback
	callback()
}

// Unsupported signal 'destroy-event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

// Unsupported signal 'direction-changed' for Widget : unsupported parameter previous_direction : type TextDirection :

type signalWidgetDragBeginDetail struct {
	callback  WidgetSignalDragBeginCallback
	handlerID C.gulong
}

var signalWidgetDragBeginId int
var signalWidgetDragBeginMap = make(map[int]signalWidgetDragBeginDetail)
var signalWidgetDragBeginLock sync.Mutex

// WidgetSignalDragBeginCallback is a callback function for a 'drag-begin' signal emitted from a Widget.
type WidgetSignalDragBeginCallback func(context *gdk.DragContext)

/*
ConnectDragBegin connects the callback to the 'drag-begin' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragBegin to remove it.
*/
func (recv *Widget) ConnectDragBegin(callback WidgetSignalDragBeginCallback) int {
	signalWidgetDragBeginLock.Lock()
	defer signalWidgetDragBeginLock.Unlock()

	signalWidgetDragBeginId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_begin(instance, C.gpointer(uintptr(signalWidgetDragBeginId)))

	detail := signalWidgetDragBeginDetail{callback, handlerID}
	signalWidgetDragBeginMap[signalWidgetDragBeginId] = detail

	return signalWidgetDragBeginId
}

/*
DisconnectDragBegin disconnects a callback from the 'drag-begin' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragBegin.
*/
func (recv *Widget) DisconnectDragBegin(connectionID int) {
	signalWidgetDragBeginLock.Lock()
	defer signalWidgetDragBeginLock.Unlock()

	detail, exists := signalWidgetDragBeginMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragBeginMap, connectionID)
}

//export widget_dragBeginHandler
func widget_dragBeginHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragBeginMap[index].callback
	callback(context)
}

type signalWidgetDragDataDeleteDetail struct {
	callback  WidgetSignalDragDataDeleteCallback
	handlerID C.gulong
}

var signalWidgetDragDataDeleteId int
var signalWidgetDragDataDeleteMap = make(map[int]signalWidgetDragDataDeleteDetail)
var signalWidgetDragDataDeleteLock sync.Mutex

// WidgetSignalDragDataDeleteCallback is a callback function for a 'drag-data-delete' signal emitted from a Widget.
type WidgetSignalDragDataDeleteCallback func(context *gdk.DragContext)

/*
ConnectDragDataDelete connects the callback to the 'drag-data-delete' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDataDelete to remove it.
*/
func (recv *Widget) ConnectDragDataDelete(callback WidgetSignalDragDataDeleteCallback) int {
	signalWidgetDragDataDeleteLock.Lock()
	defer signalWidgetDragDataDeleteLock.Unlock()

	signalWidgetDragDataDeleteId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_data_delete(instance, C.gpointer(uintptr(signalWidgetDragDataDeleteId)))

	detail := signalWidgetDragDataDeleteDetail{callback, handlerID}
	signalWidgetDragDataDeleteMap[signalWidgetDragDataDeleteId] = detail

	return signalWidgetDragDataDeleteId
}

/*
DisconnectDragDataDelete disconnects a callback from the 'drag-data-delete' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDataDelete.
*/
func (recv *Widget) DisconnectDragDataDelete(connectionID int) {
	signalWidgetDragDataDeleteLock.Lock()
	defer signalWidgetDragDataDeleteLock.Unlock()

	detail, exists := signalWidgetDragDataDeleteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDataDeleteMap, connectionID)
}

//export widget_dragDataDeleteHandler
func widget_dragDataDeleteHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragDataDeleteMap[index].callback
	callback(context)
}

// Unsupported signal 'drag-data-get' for Widget : unsupported parameter info : type guint :

// Unsupported signal 'drag-data-received' for Widget : unsupported parameter x : type gint :

// Unsupported signal 'drag-drop' for Widget : unsupported parameter x : type gint :

type signalWidgetDragEndDetail struct {
	callback  WidgetSignalDragEndCallback
	handlerID C.gulong
}

var signalWidgetDragEndId int
var signalWidgetDragEndMap = make(map[int]signalWidgetDragEndDetail)
var signalWidgetDragEndLock sync.Mutex

// WidgetSignalDragEndCallback is a callback function for a 'drag-end' signal emitted from a Widget.
type WidgetSignalDragEndCallback func(context *gdk.DragContext)

/*
ConnectDragEnd connects the callback to the 'drag-end' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragEnd to remove it.
*/
func (recv *Widget) ConnectDragEnd(callback WidgetSignalDragEndCallback) int {
	signalWidgetDragEndLock.Lock()
	defer signalWidgetDragEndLock.Unlock()

	signalWidgetDragEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_end(instance, C.gpointer(uintptr(signalWidgetDragEndId)))

	detail := signalWidgetDragEndDetail{callback, handlerID}
	signalWidgetDragEndMap[signalWidgetDragEndId] = detail

	return signalWidgetDragEndId
}

/*
DisconnectDragEnd disconnects a callback from the 'drag-end' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragEnd.
*/
func (recv *Widget) DisconnectDragEnd(connectionID int) {
	signalWidgetDragEndLock.Lock()
	defer signalWidgetDragEndLock.Unlock()

	detail, exists := signalWidgetDragEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragEndMap, connectionID)
}

//export widget_dragEndHandler
func widget_dragEndHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragEndMap[index].callback
	callback(context)
}

// Unsupported signal 'drag-leave' for Widget : unsupported parameter time : type guint :

// Unsupported signal 'drag-motion' for Widget : unsupported parameter x : type gint :

type signalWidgetEnterNotifyEventDetail struct {
	callback  WidgetSignalEnterNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetEnterNotifyEventId int
var signalWidgetEnterNotifyEventMap = make(map[int]signalWidgetEnterNotifyEventDetail)
var signalWidgetEnterNotifyEventLock sync.Mutex

// WidgetSignalEnterNotifyEventCallback is a callback function for a 'enter-notify-event' signal emitted from a Widget.
type WidgetSignalEnterNotifyEventCallback func(event *gdk.EventCrossing) bool

/*
ConnectEnterNotifyEvent connects the callback to the 'enter-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectEnterNotifyEvent to remove it.
*/
func (recv *Widget) ConnectEnterNotifyEvent(callback WidgetSignalEnterNotifyEventCallback) int {
	signalWidgetEnterNotifyEventLock.Lock()
	defer signalWidgetEnterNotifyEventLock.Unlock()

	signalWidgetEnterNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_enter_notify_event(instance, C.gpointer(uintptr(signalWidgetEnterNotifyEventId)))

	detail := signalWidgetEnterNotifyEventDetail{callback, handlerID}
	signalWidgetEnterNotifyEventMap[signalWidgetEnterNotifyEventId] = detail

	return signalWidgetEnterNotifyEventId
}

/*
DisconnectEnterNotifyEvent disconnects a callback from the 'enter-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectEnterNotifyEvent.
*/
func (recv *Widget) DisconnectEnterNotifyEvent(connectionID int) {
	signalWidgetEnterNotifyEventLock.Lock()
	defer signalWidgetEnterNotifyEventLock.Unlock()

	detail, exists := signalWidgetEnterNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetEnterNotifyEventMap, connectionID)
}

//export widget_enterNotifyEventHandler
func widget_enterNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventCrossing, data C.gpointer) C.gboolean {
	event := gdk.EventCrossingNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetEnterNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

// Unsupported signal 'event-after' for Widget : unsupported parameter event : no type generator for Gdk.Event,

// Unsupported signal 'focus' for Widget : unsupported parameter direction : type DirectionType :

type signalWidgetFocusInEventDetail struct {
	callback  WidgetSignalFocusInEventCallback
	handlerID C.gulong
}

var signalWidgetFocusInEventId int
var signalWidgetFocusInEventMap = make(map[int]signalWidgetFocusInEventDetail)
var signalWidgetFocusInEventLock sync.Mutex

// WidgetSignalFocusInEventCallback is a callback function for a 'focus-in-event' signal emitted from a Widget.
type WidgetSignalFocusInEventCallback func(event *gdk.EventFocus) bool

/*
ConnectFocusInEvent connects the callback to the 'focus-in-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocusInEvent to remove it.
*/
func (recv *Widget) ConnectFocusInEvent(callback WidgetSignalFocusInEventCallback) int {
	signalWidgetFocusInEventLock.Lock()
	defer signalWidgetFocusInEventLock.Unlock()

	signalWidgetFocusInEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus_in_event(instance, C.gpointer(uintptr(signalWidgetFocusInEventId)))

	detail := signalWidgetFocusInEventDetail{callback, handlerID}
	signalWidgetFocusInEventMap[signalWidgetFocusInEventId] = detail

	return signalWidgetFocusInEventId
}

/*
DisconnectFocusInEvent disconnects a callback from the 'focus-in-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocusInEvent.
*/
func (recv *Widget) DisconnectFocusInEvent(connectionID int) {
	signalWidgetFocusInEventLock.Lock()
	defer signalWidgetFocusInEventLock.Unlock()

	detail, exists := signalWidgetFocusInEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusInEventMap, connectionID)
}

//export widget_focusInEventHandler
func widget_focusInEventHandler(_ *C.GObject, c_event *C.GdkEventFocus, data C.gpointer) C.gboolean {
	event := gdk.EventFocusNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetFocusInEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetFocusOutEventDetail struct {
	callback  WidgetSignalFocusOutEventCallback
	handlerID C.gulong
}

var signalWidgetFocusOutEventId int
var signalWidgetFocusOutEventMap = make(map[int]signalWidgetFocusOutEventDetail)
var signalWidgetFocusOutEventLock sync.Mutex

// WidgetSignalFocusOutEventCallback is a callback function for a 'focus-out-event' signal emitted from a Widget.
type WidgetSignalFocusOutEventCallback func(event *gdk.EventFocus) bool

/*
ConnectFocusOutEvent connects the callback to the 'focus-out-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocusOutEvent to remove it.
*/
func (recv *Widget) ConnectFocusOutEvent(callback WidgetSignalFocusOutEventCallback) int {
	signalWidgetFocusOutEventLock.Lock()
	defer signalWidgetFocusOutEventLock.Unlock()

	signalWidgetFocusOutEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus_out_event(instance, C.gpointer(uintptr(signalWidgetFocusOutEventId)))

	detail := signalWidgetFocusOutEventDetail{callback, handlerID}
	signalWidgetFocusOutEventMap[signalWidgetFocusOutEventId] = detail

	return signalWidgetFocusOutEventId
}

/*
DisconnectFocusOutEvent disconnects a callback from the 'focus-out-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocusOutEvent.
*/
func (recv *Widget) DisconnectFocusOutEvent(connectionID int) {
	signalWidgetFocusOutEventLock.Lock()
	defer signalWidgetFocusOutEventLock.Unlock()

	detail, exists := signalWidgetFocusOutEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusOutEventMap, connectionID)
}

//export widget_focusOutEventHandler
func widget_focusOutEventHandler(_ *C.GObject, c_event *C.GdkEventFocus, data C.gpointer) C.gboolean {
	event := gdk.EventFocusNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetFocusOutEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetGrabFocusDetail struct {
	callback  WidgetSignalGrabFocusCallback
	handlerID C.gulong
}

var signalWidgetGrabFocusId int
var signalWidgetGrabFocusMap = make(map[int]signalWidgetGrabFocusDetail)
var signalWidgetGrabFocusLock sync.Mutex

// WidgetSignalGrabFocusCallback is a callback function for a 'grab-focus' signal emitted from a Widget.
type WidgetSignalGrabFocusCallback func()

/*
ConnectGrabFocus connects the callback to the 'grab-focus' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabFocus to remove it.
*/
func (recv *Widget) ConnectGrabFocus(callback WidgetSignalGrabFocusCallback) int {
	signalWidgetGrabFocusLock.Lock()
	defer signalWidgetGrabFocusLock.Unlock()

	signalWidgetGrabFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_focus(instance, C.gpointer(uintptr(signalWidgetGrabFocusId)))

	detail := signalWidgetGrabFocusDetail{callback, handlerID}
	signalWidgetGrabFocusMap[signalWidgetGrabFocusId] = detail

	return signalWidgetGrabFocusId
}

/*
DisconnectGrabFocus disconnects a callback from the 'grab-focus' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabFocus.
*/
func (recv *Widget) DisconnectGrabFocus(connectionID int) {
	signalWidgetGrabFocusLock.Lock()
	defer signalWidgetGrabFocusLock.Unlock()

	detail, exists := signalWidgetGrabFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabFocusMap, connectionID)
}

//export widget_grabFocusHandler
func widget_grabFocusHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetGrabFocusMap[index].callback
	callback()
}

type signalWidgetGrabNotifyDetail struct {
	callback  WidgetSignalGrabNotifyCallback
	handlerID C.gulong
}

var signalWidgetGrabNotifyId int
var signalWidgetGrabNotifyMap = make(map[int]signalWidgetGrabNotifyDetail)
var signalWidgetGrabNotifyLock sync.Mutex

// WidgetSignalGrabNotifyCallback is a callback function for a 'grab-notify' signal emitted from a Widget.
type WidgetSignalGrabNotifyCallback func(wasGrabbed bool)

/*
ConnectGrabNotify connects the callback to the 'grab-notify' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabNotify to remove it.
*/
func (recv *Widget) ConnectGrabNotify(callback WidgetSignalGrabNotifyCallback) int {
	signalWidgetGrabNotifyLock.Lock()
	defer signalWidgetGrabNotifyLock.Unlock()

	signalWidgetGrabNotifyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_notify(instance, C.gpointer(uintptr(signalWidgetGrabNotifyId)))

	detail := signalWidgetGrabNotifyDetail{callback, handlerID}
	signalWidgetGrabNotifyMap[signalWidgetGrabNotifyId] = detail

	return signalWidgetGrabNotifyId
}

/*
DisconnectGrabNotify disconnects a callback from the 'grab-notify' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabNotify.
*/
func (recv *Widget) DisconnectGrabNotify(connectionID int) {
	signalWidgetGrabNotifyLock.Lock()
	defer signalWidgetGrabNotifyLock.Unlock()

	detail, exists := signalWidgetGrabNotifyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabNotifyMap, connectionID)
}

//export widget_grabNotifyHandler
func widget_grabNotifyHandler(_ *C.GObject, c_was_grabbed C.gboolean, data C.gpointer) {
	wasGrabbed := c_was_grabbed == C.TRUE

	index := int(uintptr(data))
	callback := signalWidgetGrabNotifyMap[index].callback
	callback(wasGrabbed)
}

type signalWidgetHideDetail struct {
	callback  WidgetSignalHideCallback
	handlerID C.gulong
}

var signalWidgetHideId int
var signalWidgetHideMap = make(map[int]signalWidgetHideDetail)
var signalWidgetHideLock sync.Mutex

// WidgetSignalHideCallback is a callback function for a 'hide' signal emitted from a Widget.
type WidgetSignalHideCallback func()

/*
ConnectHide connects the callback to the 'hide' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectHide to remove it.
*/
func (recv *Widget) ConnectHide(callback WidgetSignalHideCallback) int {
	signalWidgetHideLock.Lock()
	defer signalWidgetHideLock.Unlock()

	signalWidgetHideId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_hide(instance, C.gpointer(uintptr(signalWidgetHideId)))

	detail := signalWidgetHideDetail{callback, handlerID}
	signalWidgetHideMap[signalWidgetHideId] = detail

	return signalWidgetHideId
}

/*
DisconnectHide disconnects a callback from the 'hide' signal for the Widget.

The connectionID should be a value returned from a call to ConnectHide.
*/
func (recv *Widget) DisconnectHide(connectionID int) {
	signalWidgetHideLock.Lock()
	defer signalWidgetHideLock.Unlock()

	detail, exists := signalWidgetHideMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetHideMap, connectionID)
}

//export widget_hideHandler
func widget_hideHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetHideMap[index].callback
	callback()
}

type signalWidgetHierarchyChangedDetail struct {
	callback  WidgetSignalHierarchyChangedCallback
	handlerID C.gulong
}

var signalWidgetHierarchyChangedId int
var signalWidgetHierarchyChangedMap = make(map[int]signalWidgetHierarchyChangedDetail)
var signalWidgetHierarchyChangedLock sync.Mutex

// WidgetSignalHierarchyChangedCallback is a callback function for a 'hierarchy-changed' signal emitted from a Widget.
type WidgetSignalHierarchyChangedCallback func(previousToplevel *Widget)

/*
ConnectHierarchyChanged connects the callback to the 'hierarchy-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectHierarchyChanged to remove it.
*/
func (recv *Widget) ConnectHierarchyChanged(callback WidgetSignalHierarchyChangedCallback) int {
	signalWidgetHierarchyChangedLock.Lock()
	defer signalWidgetHierarchyChangedLock.Unlock()

	signalWidgetHierarchyChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_hierarchy_changed(instance, C.gpointer(uintptr(signalWidgetHierarchyChangedId)))

	detail := signalWidgetHierarchyChangedDetail{callback, handlerID}
	signalWidgetHierarchyChangedMap[signalWidgetHierarchyChangedId] = detail

	return signalWidgetHierarchyChangedId
}

/*
DisconnectHierarchyChanged disconnects a callback from the 'hierarchy-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectHierarchyChanged.
*/
func (recv *Widget) DisconnectHierarchyChanged(connectionID int) {
	signalWidgetHierarchyChangedLock.Lock()
	defer signalWidgetHierarchyChangedLock.Unlock()

	detail, exists := signalWidgetHierarchyChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetHierarchyChangedMap, connectionID)
}

//export widget_hierarchyChangedHandler
func widget_hierarchyChangedHandler(_ *C.GObject, c_previous_toplevel *C.GtkWidget, data C.gpointer) {
	previousToplevel := WidgetNewFromC(unsafe.Pointer(c_previous_toplevel))

	index := int(uintptr(data))
	callback := signalWidgetHierarchyChangedMap[index].callback
	callback(previousToplevel)
}

type signalWidgetKeyPressEventDetail struct {
	callback  WidgetSignalKeyPressEventCallback
	handlerID C.gulong
}

var signalWidgetKeyPressEventId int
var signalWidgetKeyPressEventMap = make(map[int]signalWidgetKeyPressEventDetail)
var signalWidgetKeyPressEventLock sync.Mutex

// WidgetSignalKeyPressEventCallback is a callback function for a 'key-press-event' signal emitted from a Widget.
type WidgetSignalKeyPressEventCallback func(event *gdk.EventKey) bool

/*
ConnectKeyPressEvent connects the callback to the 'key-press-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeyPressEvent to remove it.
*/
func (recv *Widget) ConnectKeyPressEvent(callback WidgetSignalKeyPressEventCallback) int {
	signalWidgetKeyPressEventLock.Lock()
	defer signalWidgetKeyPressEventLock.Unlock()

	signalWidgetKeyPressEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_key_press_event(instance, C.gpointer(uintptr(signalWidgetKeyPressEventId)))

	detail := signalWidgetKeyPressEventDetail{callback, handlerID}
	signalWidgetKeyPressEventMap[signalWidgetKeyPressEventId] = detail

	return signalWidgetKeyPressEventId
}

/*
DisconnectKeyPressEvent disconnects a callback from the 'key-press-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeyPressEvent.
*/
func (recv *Widget) DisconnectKeyPressEvent(connectionID int) {
	signalWidgetKeyPressEventLock.Lock()
	defer signalWidgetKeyPressEventLock.Unlock()

	detail, exists := signalWidgetKeyPressEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeyPressEventMap, connectionID)
}

//export widget_keyPressEventHandler
func widget_keyPressEventHandler(_ *C.GObject, c_event *C.GdkEventKey, data C.gpointer) C.gboolean {
	event := gdk.EventKeyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetKeyPressEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetKeyReleaseEventDetail struct {
	callback  WidgetSignalKeyReleaseEventCallback
	handlerID C.gulong
}

var signalWidgetKeyReleaseEventId int
var signalWidgetKeyReleaseEventMap = make(map[int]signalWidgetKeyReleaseEventDetail)
var signalWidgetKeyReleaseEventLock sync.Mutex

// WidgetSignalKeyReleaseEventCallback is a callback function for a 'key-release-event' signal emitted from a Widget.
type WidgetSignalKeyReleaseEventCallback func(event *gdk.EventKey) bool

/*
ConnectKeyReleaseEvent connects the callback to the 'key-release-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeyReleaseEvent to remove it.
*/
func (recv *Widget) ConnectKeyReleaseEvent(callback WidgetSignalKeyReleaseEventCallback) int {
	signalWidgetKeyReleaseEventLock.Lock()
	defer signalWidgetKeyReleaseEventLock.Unlock()

	signalWidgetKeyReleaseEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_key_release_event(instance, C.gpointer(uintptr(signalWidgetKeyReleaseEventId)))

	detail := signalWidgetKeyReleaseEventDetail{callback, handlerID}
	signalWidgetKeyReleaseEventMap[signalWidgetKeyReleaseEventId] = detail

	return signalWidgetKeyReleaseEventId
}

/*
DisconnectKeyReleaseEvent disconnects a callback from the 'key-release-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeyReleaseEvent.
*/
func (recv *Widget) DisconnectKeyReleaseEvent(connectionID int) {
	signalWidgetKeyReleaseEventLock.Lock()
	defer signalWidgetKeyReleaseEventLock.Unlock()

	detail, exists := signalWidgetKeyReleaseEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeyReleaseEventMap, connectionID)
}

//export widget_keyReleaseEventHandler
func widget_keyReleaseEventHandler(_ *C.GObject, c_event *C.GdkEventKey, data C.gpointer) C.gboolean {
	event := gdk.EventKeyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetKeyReleaseEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetLeaveNotifyEventDetail struct {
	callback  WidgetSignalLeaveNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetLeaveNotifyEventId int
var signalWidgetLeaveNotifyEventMap = make(map[int]signalWidgetLeaveNotifyEventDetail)
var signalWidgetLeaveNotifyEventLock sync.Mutex

// WidgetSignalLeaveNotifyEventCallback is a callback function for a 'leave-notify-event' signal emitted from a Widget.
type WidgetSignalLeaveNotifyEventCallback func(event *gdk.EventCrossing) bool

/*
ConnectLeaveNotifyEvent connects the callback to the 'leave-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectLeaveNotifyEvent to remove it.
*/
func (recv *Widget) ConnectLeaveNotifyEvent(callback WidgetSignalLeaveNotifyEventCallback) int {
	signalWidgetLeaveNotifyEventLock.Lock()
	defer signalWidgetLeaveNotifyEventLock.Unlock()

	signalWidgetLeaveNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_leave_notify_event(instance, C.gpointer(uintptr(signalWidgetLeaveNotifyEventId)))

	detail := signalWidgetLeaveNotifyEventDetail{callback, handlerID}
	signalWidgetLeaveNotifyEventMap[signalWidgetLeaveNotifyEventId] = detail

	return signalWidgetLeaveNotifyEventId
}

/*
DisconnectLeaveNotifyEvent disconnects a callback from the 'leave-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectLeaveNotifyEvent.
*/
func (recv *Widget) DisconnectLeaveNotifyEvent(connectionID int) {
	signalWidgetLeaveNotifyEventLock.Lock()
	defer signalWidgetLeaveNotifyEventLock.Unlock()

	detail, exists := signalWidgetLeaveNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetLeaveNotifyEventMap, connectionID)
}

//export widget_leaveNotifyEventHandler
func widget_leaveNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventCrossing, data C.gpointer) C.gboolean {
	event := gdk.EventCrossingNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetLeaveNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMapDetail struct {
	callback  WidgetSignalMapCallback
	handlerID C.gulong
}

var signalWidgetMapId int
var signalWidgetMapMap = make(map[int]signalWidgetMapDetail)
var signalWidgetMapLock sync.Mutex

// WidgetSignalMapCallback is a callback function for a 'map' signal emitted from a Widget.
type WidgetSignalMapCallback func()

/*
ConnectMap connects the callback to the 'map' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMap to remove it.
*/
func (recv *Widget) ConnectMap(callback WidgetSignalMapCallback) int {
	signalWidgetMapLock.Lock()
	defer signalWidgetMapLock.Unlock()

	signalWidgetMapId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_map(instance, C.gpointer(uintptr(signalWidgetMapId)))

	detail := signalWidgetMapDetail{callback, handlerID}
	signalWidgetMapMap[signalWidgetMapId] = detail

	return signalWidgetMapId
}

/*
DisconnectMap disconnects a callback from the 'map' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMap.
*/
func (recv *Widget) DisconnectMap(connectionID int) {
	signalWidgetMapLock.Lock()
	defer signalWidgetMapLock.Unlock()

	detail, exists := signalWidgetMapMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMapMap, connectionID)
}

//export widget_mapHandler
func widget_mapHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetMapMap[index].callback
	callback()
}

type signalWidgetMapEventDetail struct {
	callback  WidgetSignalMapEventCallback
	handlerID C.gulong
}

var signalWidgetMapEventId int
var signalWidgetMapEventMap = make(map[int]signalWidgetMapEventDetail)
var signalWidgetMapEventLock sync.Mutex

// WidgetSignalMapEventCallback is a callback function for a 'map-event' signal emitted from a Widget.
type WidgetSignalMapEventCallback func(event *gdk.EventAny) bool

/*
ConnectMapEvent connects the callback to the 'map-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMapEvent to remove it.
*/
func (recv *Widget) ConnectMapEvent(callback WidgetSignalMapEventCallback) int {
	signalWidgetMapEventLock.Lock()
	defer signalWidgetMapEventLock.Unlock()

	signalWidgetMapEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_map_event(instance, C.gpointer(uintptr(signalWidgetMapEventId)))

	detail := signalWidgetMapEventDetail{callback, handlerID}
	signalWidgetMapEventMap[signalWidgetMapEventId] = detail

	return signalWidgetMapEventId
}

/*
DisconnectMapEvent disconnects a callback from the 'map-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMapEvent.
*/
func (recv *Widget) DisconnectMapEvent(connectionID int) {
	signalWidgetMapEventLock.Lock()
	defer signalWidgetMapEventLock.Unlock()

	detail, exists := signalWidgetMapEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMapEventMap, connectionID)
}

//export widget_mapEventHandler
func widget_mapEventHandler(_ *C.GObject, c_event *C.GdkEventAny, data C.gpointer) C.gboolean {
	event := gdk.EventAnyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetMapEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMnemonicActivateDetail struct {
	callback  WidgetSignalMnemonicActivateCallback
	handlerID C.gulong
}

var signalWidgetMnemonicActivateId int
var signalWidgetMnemonicActivateMap = make(map[int]signalWidgetMnemonicActivateDetail)
var signalWidgetMnemonicActivateLock sync.Mutex

// WidgetSignalMnemonicActivateCallback is a callback function for a 'mnemonic-activate' signal emitted from a Widget.
type WidgetSignalMnemonicActivateCallback func(groupCycling bool) bool

/*
ConnectMnemonicActivate connects the callback to the 'mnemonic-activate' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMnemonicActivate to remove it.
*/
func (recv *Widget) ConnectMnemonicActivate(callback WidgetSignalMnemonicActivateCallback) int {
	signalWidgetMnemonicActivateLock.Lock()
	defer signalWidgetMnemonicActivateLock.Unlock()

	signalWidgetMnemonicActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_mnemonic_activate(instance, C.gpointer(uintptr(signalWidgetMnemonicActivateId)))

	detail := signalWidgetMnemonicActivateDetail{callback, handlerID}
	signalWidgetMnemonicActivateMap[signalWidgetMnemonicActivateId] = detail

	return signalWidgetMnemonicActivateId
}

/*
DisconnectMnemonicActivate disconnects a callback from the 'mnemonic-activate' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMnemonicActivate.
*/
func (recv *Widget) DisconnectMnemonicActivate(connectionID int) {
	signalWidgetMnemonicActivateLock.Lock()
	defer signalWidgetMnemonicActivateLock.Unlock()

	detail, exists := signalWidgetMnemonicActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMnemonicActivateMap, connectionID)
}

//export widget_mnemonicActivateHandler
func widget_mnemonicActivateHandler(_ *C.GObject, c_group_cycling C.gboolean, data C.gpointer) C.gboolean {
	groupCycling := c_group_cycling == C.TRUE

	index := int(uintptr(data))
	callback := signalWidgetMnemonicActivateMap[index].callback
	retGo := callback(groupCycling)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMotionNotifyEventDetail struct {
	callback  WidgetSignalMotionNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetMotionNotifyEventId int
var signalWidgetMotionNotifyEventMap = make(map[int]signalWidgetMotionNotifyEventDetail)
var signalWidgetMotionNotifyEventLock sync.Mutex

// WidgetSignalMotionNotifyEventCallback is a callback function for a 'motion-notify-event' signal emitted from a Widget.
type WidgetSignalMotionNotifyEventCallback func(event *gdk.EventMotion) bool

/*
ConnectMotionNotifyEvent connects the callback to the 'motion-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMotionNotifyEvent to remove it.
*/
func (recv *Widget) ConnectMotionNotifyEvent(callback WidgetSignalMotionNotifyEventCallback) int {
	signalWidgetMotionNotifyEventLock.Lock()
	defer signalWidgetMotionNotifyEventLock.Unlock()

	signalWidgetMotionNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_motion_notify_event(instance, C.gpointer(uintptr(signalWidgetMotionNotifyEventId)))

	detail := signalWidgetMotionNotifyEventDetail{callback, handlerID}
	signalWidgetMotionNotifyEventMap[signalWidgetMotionNotifyEventId] = detail

	return signalWidgetMotionNotifyEventId
}

/*
DisconnectMotionNotifyEvent disconnects a callback from the 'motion-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMotionNotifyEvent.
*/
func (recv *Widget) DisconnectMotionNotifyEvent(connectionID int) {
	signalWidgetMotionNotifyEventLock.Lock()
	defer signalWidgetMotionNotifyEventLock.Unlock()

	detail, exists := signalWidgetMotionNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMotionNotifyEventMap, connectionID)
}

//export widget_motionNotifyEventHandler
func widget_motionNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventMotion, data C.gpointer) C.gboolean {
	event := gdk.EventMotionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetMotionNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'move-focus' for Widget : unsupported parameter direction : type DirectionType :

type signalWidgetParentSetDetail struct {
	callback  WidgetSignalParentSetCallback
	handlerID C.gulong
}

var signalWidgetParentSetId int
var signalWidgetParentSetMap = make(map[int]signalWidgetParentSetDetail)
var signalWidgetParentSetLock sync.Mutex

// WidgetSignalParentSetCallback is a callback function for a 'parent-set' signal emitted from a Widget.
type WidgetSignalParentSetCallback func(oldParent *Widget)

/*
ConnectParentSet connects the callback to the 'parent-set' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectParentSet to remove it.
*/
func (recv *Widget) ConnectParentSet(callback WidgetSignalParentSetCallback) int {
	signalWidgetParentSetLock.Lock()
	defer signalWidgetParentSetLock.Unlock()

	signalWidgetParentSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_parent_set(instance, C.gpointer(uintptr(signalWidgetParentSetId)))

	detail := signalWidgetParentSetDetail{callback, handlerID}
	signalWidgetParentSetMap[signalWidgetParentSetId] = detail

	return signalWidgetParentSetId
}

/*
DisconnectParentSet disconnects a callback from the 'parent-set' signal for the Widget.

The connectionID should be a value returned from a call to ConnectParentSet.
*/
func (recv *Widget) DisconnectParentSet(connectionID int) {
	signalWidgetParentSetLock.Lock()
	defer signalWidgetParentSetLock.Unlock()

	detail, exists := signalWidgetParentSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetParentSetMap, connectionID)
}

//export widget_parentSetHandler
func widget_parentSetHandler(_ *C.GObject, c_old_parent *C.GtkWidget, data C.gpointer) {
	oldParent := WidgetNewFromC(unsafe.Pointer(c_old_parent))

	index := int(uintptr(data))
	callback := signalWidgetParentSetMap[index].callback
	callback(oldParent)
}

type signalWidgetPopupMenuDetail struct {
	callback  WidgetSignalPopupMenuCallback
	handlerID C.gulong
}

var signalWidgetPopupMenuId int
var signalWidgetPopupMenuMap = make(map[int]signalWidgetPopupMenuDetail)
var signalWidgetPopupMenuLock sync.Mutex

// WidgetSignalPopupMenuCallback is a callback function for a 'popup-menu' signal emitted from a Widget.
type WidgetSignalPopupMenuCallback func() bool

/*
ConnectPopupMenu connects the callback to the 'popup-menu' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectPopupMenu to remove it.
*/
func (recv *Widget) ConnectPopupMenu(callback WidgetSignalPopupMenuCallback) int {
	signalWidgetPopupMenuLock.Lock()
	defer signalWidgetPopupMenuLock.Unlock()

	signalWidgetPopupMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_popup_menu(instance, C.gpointer(uintptr(signalWidgetPopupMenuId)))

	detail := signalWidgetPopupMenuDetail{callback, handlerID}
	signalWidgetPopupMenuMap[signalWidgetPopupMenuId] = detail

	return signalWidgetPopupMenuId
}

/*
DisconnectPopupMenu disconnects a callback from the 'popup-menu' signal for the Widget.

The connectionID should be a value returned from a call to ConnectPopupMenu.
*/
func (recv *Widget) DisconnectPopupMenu(connectionID int) {
	signalWidgetPopupMenuLock.Lock()
	defer signalWidgetPopupMenuLock.Unlock()

	detail, exists := signalWidgetPopupMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetPopupMenuMap, connectionID)
}

//export widget_popupMenuHandler
func widget_popupMenuHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalWidgetPopupMenuMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetPropertyNotifyEventDetail struct {
	callback  WidgetSignalPropertyNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetPropertyNotifyEventId int
var signalWidgetPropertyNotifyEventMap = make(map[int]signalWidgetPropertyNotifyEventDetail)
var signalWidgetPropertyNotifyEventLock sync.Mutex

// WidgetSignalPropertyNotifyEventCallback is a callback function for a 'property-notify-event' signal emitted from a Widget.
type WidgetSignalPropertyNotifyEventCallback func(event *gdk.EventProperty) bool

/*
ConnectPropertyNotifyEvent connects the callback to the 'property-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectPropertyNotifyEvent to remove it.
*/
func (recv *Widget) ConnectPropertyNotifyEvent(callback WidgetSignalPropertyNotifyEventCallback) int {
	signalWidgetPropertyNotifyEventLock.Lock()
	defer signalWidgetPropertyNotifyEventLock.Unlock()

	signalWidgetPropertyNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_property_notify_event(instance, C.gpointer(uintptr(signalWidgetPropertyNotifyEventId)))

	detail := signalWidgetPropertyNotifyEventDetail{callback, handlerID}
	signalWidgetPropertyNotifyEventMap[signalWidgetPropertyNotifyEventId] = detail

	return signalWidgetPropertyNotifyEventId
}

/*
DisconnectPropertyNotifyEvent disconnects a callback from the 'property-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectPropertyNotifyEvent.
*/
func (recv *Widget) DisconnectPropertyNotifyEvent(connectionID int) {
	signalWidgetPropertyNotifyEventLock.Lock()
	defer signalWidgetPropertyNotifyEventLock.Unlock()

	detail, exists := signalWidgetPropertyNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetPropertyNotifyEventMap, connectionID)
}

//export widget_propertyNotifyEventHandler
func widget_propertyNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventProperty, data C.gpointer) C.gboolean {
	event := gdk.EventPropertyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetPropertyNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetProximityInEventDetail struct {
	callback  WidgetSignalProximityInEventCallback
	handlerID C.gulong
}

var signalWidgetProximityInEventId int
var signalWidgetProximityInEventMap = make(map[int]signalWidgetProximityInEventDetail)
var signalWidgetProximityInEventLock sync.Mutex

// WidgetSignalProximityInEventCallback is a callback function for a 'proximity-in-event' signal emitted from a Widget.
type WidgetSignalProximityInEventCallback func(event *gdk.EventProximity) bool

/*
ConnectProximityInEvent connects the callback to the 'proximity-in-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectProximityInEvent to remove it.
*/
func (recv *Widget) ConnectProximityInEvent(callback WidgetSignalProximityInEventCallback) int {
	signalWidgetProximityInEventLock.Lock()
	defer signalWidgetProximityInEventLock.Unlock()

	signalWidgetProximityInEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_proximity_in_event(instance, C.gpointer(uintptr(signalWidgetProximityInEventId)))

	detail := signalWidgetProximityInEventDetail{callback, handlerID}
	signalWidgetProximityInEventMap[signalWidgetProximityInEventId] = detail

	return signalWidgetProximityInEventId
}

/*
DisconnectProximityInEvent disconnects a callback from the 'proximity-in-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectProximityInEvent.
*/
func (recv *Widget) DisconnectProximityInEvent(connectionID int) {
	signalWidgetProximityInEventLock.Lock()
	defer signalWidgetProximityInEventLock.Unlock()

	detail, exists := signalWidgetProximityInEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetProximityInEventMap, connectionID)
}

//export widget_proximityInEventHandler
func widget_proximityInEventHandler(_ *C.GObject, c_event *C.GdkEventProximity, data C.gpointer) C.gboolean {
	event := gdk.EventProximityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetProximityInEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetProximityOutEventDetail struct {
	callback  WidgetSignalProximityOutEventCallback
	handlerID C.gulong
}

var signalWidgetProximityOutEventId int
var signalWidgetProximityOutEventMap = make(map[int]signalWidgetProximityOutEventDetail)
var signalWidgetProximityOutEventLock sync.Mutex

// WidgetSignalProximityOutEventCallback is a callback function for a 'proximity-out-event' signal emitted from a Widget.
type WidgetSignalProximityOutEventCallback func(event *gdk.EventProximity) bool

/*
ConnectProximityOutEvent connects the callback to the 'proximity-out-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectProximityOutEvent to remove it.
*/
func (recv *Widget) ConnectProximityOutEvent(callback WidgetSignalProximityOutEventCallback) int {
	signalWidgetProximityOutEventLock.Lock()
	defer signalWidgetProximityOutEventLock.Unlock()

	signalWidgetProximityOutEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_proximity_out_event(instance, C.gpointer(uintptr(signalWidgetProximityOutEventId)))

	detail := signalWidgetProximityOutEventDetail{callback, handlerID}
	signalWidgetProximityOutEventMap[signalWidgetProximityOutEventId] = detail

	return signalWidgetProximityOutEventId
}

/*
DisconnectProximityOutEvent disconnects a callback from the 'proximity-out-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectProximityOutEvent.
*/
func (recv *Widget) DisconnectProximityOutEvent(connectionID int) {
	signalWidgetProximityOutEventLock.Lock()
	defer signalWidgetProximityOutEventLock.Unlock()

	detail, exists := signalWidgetProximityOutEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetProximityOutEventMap, connectionID)
}

//export widget_proximityOutEventHandler
func widget_proximityOutEventHandler(_ *C.GObject, c_event *C.GdkEventProximity, data C.gpointer) C.gboolean {
	event := gdk.EventProximityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetProximityOutEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetRealizeDetail struct {
	callback  WidgetSignalRealizeCallback
	handlerID C.gulong
}

var signalWidgetRealizeId int
var signalWidgetRealizeMap = make(map[int]signalWidgetRealizeDetail)
var signalWidgetRealizeLock sync.Mutex

// WidgetSignalRealizeCallback is a callback function for a 'realize' signal emitted from a Widget.
type WidgetSignalRealizeCallback func()

/*
ConnectRealize connects the callback to the 'realize' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectRealize to remove it.
*/
func (recv *Widget) ConnectRealize(callback WidgetSignalRealizeCallback) int {
	signalWidgetRealizeLock.Lock()
	defer signalWidgetRealizeLock.Unlock()

	signalWidgetRealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_realize(instance, C.gpointer(uintptr(signalWidgetRealizeId)))

	detail := signalWidgetRealizeDetail{callback, handlerID}
	signalWidgetRealizeMap[signalWidgetRealizeId] = detail

	return signalWidgetRealizeId
}

/*
DisconnectRealize disconnects a callback from the 'realize' signal for the Widget.

The connectionID should be a value returned from a call to ConnectRealize.
*/
func (recv *Widget) DisconnectRealize(connectionID int) {
	signalWidgetRealizeLock.Lock()
	defer signalWidgetRealizeLock.Unlock()

	detail, exists := signalWidgetRealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetRealizeMap, connectionID)
}

//export widget_realizeHandler
func widget_realizeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetRealizeMap[index].callback
	callback()
}

type signalWidgetScreenChangedDetail struct {
	callback  WidgetSignalScreenChangedCallback
	handlerID C.gulong
}

var signalWidgetScreenChangedId int
var signalWidgetScreenChangedMap = make(map[int]signalWidgetScreenChangedDetail)
var signalWidgetScreenChangedLock sync.Mutex

// WidgetSignalScreenChangedCallback is a callback function for a 'screen-changed' signal emitted from a Widget.
type WidgetSignalScreenChangedCallback func(previousScreen *gdk.Screen)

/*
ConnectScreenChanged connects the callback to the 'screen-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectScreenChanged to remove it.
*/
func (recv *Widget) ConnectScreenChanged(callback WidgetSignalScreenChangedCallback) int {
	signalWidgetScreenChangedLock.Lock()
	defer signalWidgetScreenChangedLock.Unlock()

	signalWidgetScreenChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_screen_changed(instance, C.gpointer(uintptr(signalWidgetScreenChangedId)))

	detail := signalWidgetScreenChangedDetail{callback, handlerID}
	signalWidgetScreenChangedMap[signalWidgetScreenChangedId] = detail

	return signalWidgetScreenChangedId
}

/*
DisconnectScreenChanged disconnects a callback from the 'screen-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectScreenChanged.
*/
func (recv *Widget) DisconnectScreenChanged(connectionID int) {
	signalWidgetScreenChangedLock.Lock()
	defer signalWidgetScreenChangedLock.Unlock()

	detail, exists := signalWidgetScreenChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetScreenChangedMap, connectionID)
}

//export widget_screenChangedHandler
func widget_screenChangedHandler(_ *C.GObject, c_previous_screen *C.GdkScreen, data C.gpointer) {
	previousScreen := gdk.ScreenNewFromC(unsafe.Pointer(c_previous_screen))

	index := int(uintptr(data))
	callback := signalWidgetScreenChangedMap[index].callback
	callback(previousScreen)
}

type signalWidgetScrollEventDetail struct {
	callback  WidgetSignalScrollEventCallback
	handlerID C.gulong
}

var signalWidgetScrollEventId int
var signalWidgetScrollEventMap = make(map[int]signalWidgetScrollEventDetail)
var signalWidgetScrollEventLock sync.Mutex

// WidgetSignalScrollEventCallback is a callback function for a 'scroll-event' signal emitted from a Widget.
type WidgetSignalScrollEventCallback func(event *gdk.EventScroll) bool

/*
ConnectScrollEvent connects the callback to the 'scroll-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectScrollEvent to remove it.
*/
func (recv *Widget) ConnectScrollEvent(callback WidgetSignalScrollEventCallback) int {
	signalWidgetScrollEventLock.Lock()
	defer signalWidgetScrollEventLock.Unlock()

	signalWidgetScrollEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_scroll_event(instance, C.gpointer(uintptr(signalWidgetScrollEventId)))

	detail := signalWidgetScrollEventDetail{callback, handlerID}
	signalWidgetScrollEventMap[signalWidgetScrollEventId] = detail

	return signalWidgetScrollEventId
}

/*
DisconnectScrollEvent disconnects a callback from the 'scroll-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectScrollEvent.
*/
func (recv *Widget) DisconnectScrollEvent(connectionID int) {
	signalWidgetScrollEventLock.Lock()
	defer signalWidgetScrollEventLock.Unlock()

	detail, exists := signalWidgetScrollEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetScrollEventMap, connectionID)
}

//export widget_scrollEventHandler
func widget_scrollEventHandler(_ *C.GObject, c_event *C.GdkEventScroll, data C.gpointer) C.gboolean {
	event := gdk.EventScrollNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetScrollEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSelectionClearEventDetail struct {
	callback  WidgetSignalSelectionClearEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionClearEventId int
var signalWidgetSelectionClearEventMap = make(map[int]signalWidgetSelectionClearEventDetail)
var signalWidgetSelectionClearEventLock sync.Mutex

// WidgetSignalSelectionClearEventCallback is a callback function for a 'selection-clear-event' signal emitted from a Widget.
type WidgetSignalSelectionClearEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionClearEvent connects the callback to the 'selection-clear-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionClearEvent to remove it.
*/
func (recv *Widget) ConnectSelectionClearEvent(callback WidgetSignalSelectionClearEventCallback) int {
	signalWidgetSelectionClearEventLock.Lock()
	defer signalWidgetSelectionClearEventLock.Unlock()

	signalWidgetSelectionClearEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_clear_event(instance, C.gpointer(uintptr(signalWidgetSelectionClearEventId)))

	detail := signalWidgetSelectionClearEventDetail{callback, handlerID}
	signalWidgetSelectionClearEventMap[signalWidgetSelectionClearEventId] = detail

	return signalWidgetSelectionClearEventId
}

/*
DisconnectSelectionClearEvent disconnects a callback from the 'selection-clear-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionClearEvent.
*/
func (recv *Widget) DisconnectSelectionClearEvent(connectionID int) {
	signalWidgetSelectionClearEventLock.Lock()
	defer signalWidgetSelectionClearEventLock.Unlock()

	detail, exists := signalWidgetSelectionClearEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionClearEventMap, connectionID)
}

//export widget_selectionClearEventHandler
func widget_selectionClearEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionClearEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'selection-get' for Widget : unsupported parameter info : type guint :

type signalWidgetSelectionNotifyEventDetail struct {
	callback  WidgetSignalSelectionNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionNotifyEventId int
var signalWidgetSelectionNotifyEventMap = make(map[int]signalWidgetSelectionNotifyEventDetail)
var signalWidgetSelectionNotifyEventLock sync.Mutex

// WidgetSignalSelectionNotifyEventCallback is a callback function for a 'selection-notify-event' signal emitted from a Widget.
type WidgetSignalSelectionNotifyEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionNotifyEvent connects the callback to the 'selection-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionNotifyEvent to remove it.
*/
func (recv *Widget) ConnectSelectionNotifyEvent(callback WidgetSignalSelectionNotifyEventCallback) int {
	signalWidgetSelectionNotifyEventLock.Lock()
	defer signalWidgetSelectionNotifyEventLock.Unlock()

	signalWidgetSelectionNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_notify_event(instance, C.gpointer(uintptr(signalWidgetSelectionNotifyEventId)))

	detail := signalWidgetSelectionNotifyEventDetail{callback, handlerID}
	signalWidgetSelectionNotifyEventMap[signalWidgetSelectionNotifyEventId] = detail

	return signalWidgetSelectionNotifyEventId
}

/*
DisconnectSelectionNotifyEvent disconnects a callback from the 'selection-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionNotifyEvent.
*/
func (recv *Widget) DisconnectSelectionNotifyEvent(connectionID int) {
	signalWidgetSelectionNotifyEventLock.Lock()
	defer signalWidgetSelectionNotifyEventLock.Unlock()

	detail, exists := signalWidgetSelectionNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionNotifyEventMap, connectionID)
}

//export widget_selectionNotifyEventHandler
func widget_selectionNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'selection-received' for Widget : unsupported parameter time : type guint :

type signalWidgetSelectionRequestEventDetail struct {
	callback  WidgetSignalSelectionRequestEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionRequestEventId int
var signalWidgetSelectionRequestEventMap = make(map[int]signalWidgetSelectionRequestEventDetail)
var signalWidgetSelectionRequestEventLock sync.Mutex

// WidgetSignalSelectionRequestEventCallback is a callback function for a 'selection-request-event' signal emitted from a Widget.
type WidgetSignalSelectionRequestEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionRequestEvent connects the callback to the 'selection-request-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionRequestEvent to remove it.
*/
func (recv *Widget) ConnectSelectionRequestEvent(callback WidgetSignalSelectionRequestEventCallback) int {
	signalWidgetSelectionRequestEventLock.Lock()
	defer signalWidgetSelectionRequestEventLock.Unlock()

	signalWidgetSelectionRequestEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_request_event(instance, C.gpointer(uintptr(signalWidgetSelectionRequestEventId)))

	detail := signalWidgetSelectionRequestEventDetail{callback, handlerID}
	signalWidgetSelectionRequestEventMap[signalWidgetSelectionRequestEventId] = detail

	return signalWidgetSelectionRequestEventId
}

/*
DisconnectSelectionRequestEvent disconnects a callback from the 'selection-request-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionRequestEvent.
*/
func (recv *Widget) DisconnectSelectionRequestEvent(connectionID int) {
	signalWidgetSelectionRequestEventLock.Lock()
	defer signalWidgetSelectionRequestEventLock.Unlock()

	detail, exists := signalWidgetSelectionRequestEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionRequestEventMap, connectionID)
}

//export widget_selectionRequestEventHandler
func widget_selectionRequestEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionRequestEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetShowDetail struct {
	callback  WidgetSignalShowCallback
	handlerID C.gulong
}

var signalWidgetShowId int
var signalWidgetShowMap = make(map[int]signalWidgetShowDetail)
var signalWidgetShowLock sync.Mutex

// WidgetSignalShowCallback is a callback function for a 'show' signal emitted from a Widget.
type WidgetSignalShowCallback func()

/*
ConnectShow connects the callback to the 'show' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectShow to remove it.
*/
func (recv *Widget) ConnectShow(callback WidgetSignalShowCallback) int {
	signalWidgetShowLock.Lock()
	defer signalWidgetShowLock.Unlock()

	signalWidgetShowId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_show(instance, C.gpointer(uintptr(signalWidgetShowId)))

	detail := signalWidgetShowDetail{callback, handlerID}
	signalWidgetShowMap[signalWidgetShowId] = detail

	return signalWidgetShowId
}

/*
DisconnectShow disconnects a callback from the 'show' signal for the Widget.

The connectionID should be a value returned from a call to ConnectShow.
*/
func (recv *Widget) DisconnectShow(connectionID int) {
	signalWidgetShowLock.Lock()
	defer signalWidgetShowLock.Unlock()

	detail, exists := signalWidgetShowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetShowMap, connectionID)
}

//export widget_showHandler
func widget_showHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetShowMap[index].callback
	callback()
}

// Unsupported signal 'show-help' for Widget : unsupported parameter help_type : type WidgetHelpType :

// Unsupported signal 'size-allocate' for Widget : unsupported parameter allocation : type Allocation : Blacklisted record : GdkRectangle

// Unsupported signal 'state-changed' for Widget : unsupported parameter state : type StateType :

type signalWidgetStyleSetDetail struct {
	callback  WidgetSignalStyleSetCallback
	handlerID C.gulong
}

var signalWidgetStyleSetId int
var signalWidgetStyleSetMap = make(map[int]signalWidgetStyleSetDetail)
var signalWidgetStyleSetLock sync.Mutex

// WidgetSignalStyleSetCallback is a callback function for a 'style-set' signal emitted from a Widget.
type WidgetSignalStyleSetCallback func(previousStyle *Style)

/*
ConnectStyleSet connects the callback to the 'style-set' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectStyleSet to remove it.
*/
func (recv *Widget) ConnectStyleSet(callback WidgetSignalStyleSetCallback) int {
	signalWidgetStyleSetLock.Lock()
	defer signalWidgetStyleSetLock.Unlock()

	signalWidgetStyleSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_style_set(instance, C.gpointer(uintptr(signalWidgetStyleSetId)))

	detail := signalWidgetStyleSetDetail{callback, handlerID}
	signalWidgetStyleSetMap[signalWidgetStyleSetId] = detail

	return signalWidgetStyleSetId
}

/*
DisconnectStyleSet disconnects a callback from the 'style-set' signal for the Widget.

The connectionID should be a value returned from a call to ConnectStyleSet.
*/
func (recv *Widget) DisconnectStyleSet(connectionID int) {
	signalWidgetStyleSetLock.Lock()
	defer signalWidgetStyleSetLock.Unlock()

	detail, exists := signalWidgetStyleSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetStyleSetMap, connectionID)
}

//export widget_styleSetHandler
func widget_styleSetHandler(_ *C.GObject, c_previous_style *C.GtkStyle, data C.gpointer) {
	previousStyle := StyleNewFromC(unsafe.Pointer(c_previous_style))

	index := int(uintptr(data))
	callback := signalWidgetStyleSetMap[index].callback
	callback(previousStyle)
}

// Unsupported signal 'touch-event' for Widget : unsupported parameter object : no type generator for Gdk.Event,

type signalWidgetUnmapDetail struct {
	callback  WidgetSignalUnmapCallback
	handlerID C.gulong
}

var signalWidgetUnmapId int
var signalWidgetUnmapMap = make(map[int]signalWidgetUnmapDetail)
var signalWidgetUnmapLock sync.Mutex

// WidgetSignalUnmapCallback is a callback function for a 'unmap' signal emitted from a Widget.
type WidgetSignalUnmapCallback func()

/*
ConnectUnmap connects the callback to the 'unmap' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnmap to remove it.
*/
func (recv *Widget) ConnectUnmap(callback WidgetSignalUnmapCallback) int {
	signalWidgetUnmapLock.Lock()
	defer signalWidgetUnmapLock.Unlock()

	signalWidgetUnmapId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unmap(instance, C.gpointer(uintptr(signalWidgetUnmapId)))

	detail := signalWidgetUnmapDetail{callback, handlerID}
	signalWidgetUnmapMap[signalWidgetUnmapId] = detail

	return signalWidgetUnmapId
}

/*
DisconnectUnmap disconnects a callback from the 'unmap' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnmap.
*/
func (recv *Widget) DisconnectUnmap(connectionID int) {
	signalWidgetUnmapLock.Lock()
	defer signalWidgetUnmapLock.Unlock()

	detail, exists := signalWidgetUnmapMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnmapMap, connectionID)
}

//export widget_unmapHandler
func widget_unmapHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetUnmapMap[index].callback
	callback()
}

type signalWidgetUnmapEventDetail struct {
	callback  WidgetSignalUnmapEventCallback
	handlerID C.gulong
}

var signalWidgetUnmapEventId int
var signalWidgetUnmapEventMap = make(map[int]signalWidgetUnmapEventDetail)
var signalWidgetUnmapEventLock sync.Mutex

// WidgetSignalUnmapEventCallback is a callback function for a 'unmap-event' signal emitted from a Widget.
type WidgetSignalUnmapEventCallback func(event *gdk.EventAny) bool

/*
ConnectUnmapEvent connects the callback to the 'unmap-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnmapEvent to remove it.
*/
func (recv *Widget) ConnectUnmapEvent(callback WidgetSignalUnmapEventCallback) int {
	signalWidgetUnmapEventLock.Lock()
	defer signalWidgetUnmapEventLock.Unlock()

	signalWidgetUnmapEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unmap_event(instance, C.gpointer(uintptr(signalWidgetUnmapEventId)))

	detail := signalWidgetUnmapEventDetail{callback, handlerID}
	signalWidgetUnmapEventMap[signalWidgetUnmapEventId] = detail

	return signalWidgetUnmapEventId
}

/*
DisconnectUnmapEvent disconnects a callback from the 'unmap-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnmapEvent.
*/
func (recv *Widget) DisconnectUnmapEvent(connectionID int) {
	signalWidgetUnmapEventLock.Lock()
	defer signalWidgetUnmapEventLock.Unlock()

	detail, exists := signalWidgetUnmapEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnmapEventMap, connectionID)
}

//export widget_unmapEventHandler
func widget_unmapEventHandler(_ *C.GObject, c_event *C.GdkEventAny, data C.gpointer) C.gboolean {
	event := gdk.EventAnyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetUnmapEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetUnrealizeDetail struct {
	callback  WidgetSignalUnrealizeCallback
	handlerID C.gulong
}

var signalWidgetUnrealizeId int
var signalWidgetUnrealizeMap = make(map[int]signalWidgetUnrealizeDetail)
var signalWidgetUnrealizeLock sync.Mutex

// WidgetSignalUnrealizeCallback is a callback function for a 'unrealize' signal emitted from a Widget.
type WidgetSignalUnrealizeCallback func()

/*
ConnectUnrealize connects the callback to the 'unrealize' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnrealize to remove it.
*/
func (recv *Widget) ConnectUnrealize(callback WidgetSignalUnrealizeCallback) int {
	signalWidgetUnrealizeLock.Lock()
	defer signalWidgetUnrealizeLock.Unlock()

	signalWidgetUnrealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unrealize(instance, C.gpointer(uintptr(signalWidgetUnrealizeId)))

	detail := signalWidgetUnrealizeDetail{callback, handlerID}
	signalWidgetUnrealizeMap[signalWidgetUnrealizeId] = detail

	return signalWidgetUnrealizeId
}

/*
DisconnectUnrealize disconnects a callback from the 'unrealize' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnrealize.
*/
func (recv *Widget) DisconnectUnrealize(connectionID int) {
	signalWidgetUnrealizeLock.Lock()
	defer signalWidgetUnrealizeLock.Unlock()

	detail, exists := signalWidgetUnrealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnrealizeMap, connectionID)
}

//export widget_unrealizeHandler
func widget_unrealizeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetUnrealizeMap[index].callback
	callback()
}

type signalWidgetVisibilityNotifyEventDetail struct {
	callback  WidgetSignalVisibilityNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetVisibilityNotifyEventId int
var signalWidgetVisibilityNotifyEventMap = make(map[int]signalWidgetVisibilityNotifyEventDetail)
var signalWidgetVisibilityNotifyEventLock sync.Mutex

// WidgetSignalVisibilityNotifyEventCallback is a callback function for a 'visibility-notify-event' signal emitted from a Widget.
type WidgetSignalVisibilityNotifyEventCallback func(event *gdk.EventVisibility) bool

/*
ConnectVisibilityNotifyEvent connects the callback to the 'visibility-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectVisibilityNotifyEvent to remove it.
*/
func (recv *Widget) ConnectVisibilityNotifyEvent(callback WidgetSignalVisibilityNotifyEventCallback) int {
	signalWidgetVisibilityNotifyEventLock.Lock()
	defer signalWidgetVisibilityNotifyEventLock.Unlock()

	signalWidgetVisibilityNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_visibility_notify_event(instance, C.gpointer(uintptr(signalWidgetVisibilityNotifyEventId)))

	detail := signalWidgetVisibilityNotifyEventDetail{callback, handlerID}
	signalWidgetVisibilityNotifyEventMap[signalWidgetVisibilityNotifyEventId] = detail

	return signalWidgetVisibilityNotifyEventId
}

/*
DisconnectVisibilityNotifyEvent disconnects a callback from the 'visibility-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectVisibilityNotifyEvent.
*/
func (recv *Widget) DisconnectVisibilityNotifyEvent(connectionID int) {
	signalWidgetVisibilityNotifyEventLock.Lock()
	defer signalWidgetVisibilityNotifyEventLock.Unlock()

	detail, exists := signalWidgetVisibilityNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetVisibilityNotifyEventMap, connectionID)
}

//export widget_visibilityNotifyEventHandler
func widget_visibilityNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventVisibility, data C.gpointer) C.gboolean {
	event := gdk.EventVisibilityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetVisibilityNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetWindowStateEventDetail struct {
	callback  WidgetSignalWindowStateEventCallback
	handlerID C.gulong
}

var signalWidgetWindowStateEventId int
var signalWidgetWindowStateEventMap = make(map[int]signalWidgetWindowStateEventDetail)
var signalWidgetWindowStateEventLock sync.Mutex

// WidgetSignalWindowStateEventCallback is a callback function for a 'window-state-event' signal emitted from a Widget.
type WidgetSignalWindowStateEventCallback func(event *gdk.EventWindowState) bool

/*
ConnectWindowStateEvent connects the callback to the 'window-state-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectWindowStateEvent to remove it.
*/
func (recv *Widget) ConnectWindowStateEvent(callback WidgetSignalWindowStateEventCallback) int {
	signalWidgetWindowStateEventLock.Lock()
	defer signalWidgetWindowStateEventLock.Unlock()

	signalWidgetWindowStateEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_window_state_event(instance, C.gpointer(uintptr(signalWidgetWindowStateEventId)))

	detail := signalWidgetWindowStateEventDetail{callback, handlerID}
	signalWidgetWindowStateEventMap[signalWidgetWindowStateEventId] = detail

	return signalWidgetWindowStateEventId
}

/*
DisconnectWindowStateEvent disconnects a callback from the 'window-state-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectWindowStateEvent.
*/
func (recv *Widget) DisconnectWindowStateEvent(connectionID int) {
	signalWidgetWindowStateEventLock.Lock()
	defer signalWidgetWindowStateEventLock.Unlock()

	detail, exists := signalWidgetWindowStateEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetWindowStateEventMap, connectionID)
}

//export widget_windowStateEventHandler
func widget_windowStateEventHandler(_ *C.GObject, c_event *C.GdkEventWindowState, data C.gpointer) C.gboolean {
	event := gdk.EventWindowStateNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetWindowStateEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported : gtk_widget_new : unsupported parameter ... : varargs

// For widgets that can be activated (buttons, menu items, etc.)
// this function activates them. Activation is what happens when you
// press Enter on a widget during key navigation. If @widget isn't
// activatable, the function returns %FALSE.
/*

C function : gtk_widget_activate
*/
func (recv *Widget) Activate() bool {
	retC := C.gtk_widget_activate((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Installs an accelerator for this @widget in @accel_group that causes
// @accel_signal to be emitted if the accelerator is activated.
// The @accel_group needs to be added to the widgets toplevel via
// gtk_window_add_accel_group(), and the signal must be of type %G_SIGNAL_ACTION.
// Accelerators added through this function are not user changeable during
// runtime. If you want to support accelerators that can be changed by the
// user, use gtk_accel_map_add_entry() and gtk_widget_set_accel_path() or
// gtk_menu_item_set_accel_path() instead.
/*

C function : gtk_widget_add_accelerator
*/
func (recv *Widget) AddAccelerator(accelSignal string, accelGroup *AccelGroup, accelKey uint32, accelMods gdk.ModifierType, accelFlags AccelFlags) {
	c_accel_signal := C.CString(accelSignal)
	defer C.free(unsafe.Pointer(c_accel_signal))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	c_accel_flags := (C.GtkAccelFlags)(accelFlags)

	C.gtk_widget_add_accelerator((*C.GtkWidget)(recv.native), c_accel_signal, c_accel_group, c_accel_key, c_accel_mods, c_accel_flags)

	return
}

// Adds the events in the bitfield @events to the event mask for
// @widget. See gtk_widget_set_events() and the
// [input handling overview][event-masks] for details.
/*

C function : gtk_widget_add_events
*/
func (recv *Widget) AddEvents(events int32) {
	c_events := (C.gint)(events)

	C.gtk_widget_add_events((*C.GtkWidget)(recv.native), c_events)

	return
}

// This function is used by custom widget implementations; if you're
// writing an app, youd use gtk_widget_grab_focus() to move the focus
// to a particular widget, and gtk_container_set_focus_chain() to
// change the focus tab order. So you may want to investigate those
// functions instead.
//
// gtk_widget_child_focus() is called by containers as the user moves
// around the window using keyboard shortcuts. @direction indicates
// what kind of motion is taking place (up, down, left, right, tab
// forward, tab backward). gtk_widget_child_focus() emits the
// #GtkWidget::focus signal; widgets override the default handler
// for this signal in order to implement appropriate focus behavior.
//
// The default ::focus handler for a widget should return %TRUE if
// moving in @direction left the focus on a focusable location inside
// that widget, and %FALSE if moving in @direction moved the focus
// outside the widget. If returning %TRUE, widgets normally
// call gtk_widget_grab_focus() to place the focus accordingly;
// if returning %FALSE, they dont modify the current focus location.
/*

C function : gtk_widget_child_focus
*/
func (recv *Widget) ChildFocus(direction DirectionType) bool {
	c_direction := (C.GtkDirectionType)(direction)

	retC := C.gtk_widget_child_focus((*C.GtkWidget)(recv.native), c_direction)
	retGo := retC == C.TRUE

	return retGo
}

// Emits a #GtkWidget::child-notify signal for the
// [child property][child-properties] @child_property
// on @widget.
//
// This is the analogue of g_object_notify() for child properties.
//
// Also see gtk_container_child_notify().
/*

C function : gtk_widget_child_notify
*/
func (recv *Widget) ChildNotify(childProperty string) {
	c_child_property := C.CString(childProperty)
	defer C.free(unsafe.Pointer(c_child_property))

	C.gtk_widget_child_notify((*C.GtkWidget)(recv.native), c_child_property)

	return
}

// Same as gtk_widget_path(), but always uses the name of a widgets type,
// never uses a custom name set with gtk_widget_set_name().
/*

C function : gtk_widget_class_path
*/
func (recv *Widget) ClassPath() (uint32, string, string) {
	var c_path_length C.guint

	var c_path *C.gchar

	var c_path_reversed *C.gchar

	C.gtk_widget_class_path((*C.GtkWidget)(recv.native), &c_path_length, &c_path, &c_path_reversed)

	pathLength := (uint32)(c_path_length)

	path := C.GoString(c_path)
	defer C.free(unsafe.Pointer(c_path))

	pathReversed := C.GoString(c_path_reversed)
	defer C.free(unsafe.Pointer(c_path_reversed))

	return pathLength, path, pathReversed
}

// Computes whether a container should give this widget extra space
// when possible. Containers should check this, rather than
// looking at gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
//
// This function already checks whether the widget is visible, so
// visibility does not need to be checked separately. Non-visible
// widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly
// set on the widget itself, or, if none has been explicitly set,
// the widget may expand if some of its children do.
/*

C function : gtk_widget_compute_expand
*/
func (recv *Widget) ComputeExpand(orientation Orientation) bool {
	c_orientation := (C.GtkOrientation)(orientation)

	retC := C.gtk_widget_compute_expand((*C.GtkWidget)(recv.native), c_orientation)
	retGo := retC == C.TRUE

	return retGo
}

// Creates a new #PangoContext with the appropriate font map,
// font options, font description, and base direction for drawing
// text for this widget. See also gtk_widget_get_pango_context().
/*

C function : gtk_widget_create_pango_context
*/
func (recv *Widget) CreatePangoContext() *pango.Context {
	retC := C.gtk_widget_create_pango_context((*C.GtkWidget)(recv.native))
	retGo := pango.ContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #PangoLayout with the appropriate font map,
// font description, and base direction for drawing text for
// this widget.
//
// If you keep a #PangoLayout created in this way around, you need
// to re-create it when the widget #PangoContext is replaced.
// This can be tracked by using the #GtkWidget::screen-changed signal
// on the widget.
/*

C function : gtk_widget_create_pango_layout
*/
func (recv *Widget) CreatePangoLayout(text string) *pango.Layout {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	retC := C.gtk_widget_create_pango_layout((*C.GtkWidget)(recv.native), c_text)
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Destroys a widget.
//
// When a widget is destroyed all references it holds on other objects
// will be released:
//
// - if the widget is inside a container, it will be removed from its
// parent
// - if the widget is a container, all its children will be destroyed,
// recursively
// - if the widget is a top level, it will be removed from the list
// of top level widgets that GTK+ maintains internally
//
// It's expected that all references held on the widget will also
// be released; you should connect to the #GtkWidget::destroy signal
// if you hold a reference to @widget and you wish to remove it when
// this function is called. It is not necessary to do so if you are
// implementing a #GtkContainer, as you'll be able to use the
// #GtkContainerClass.remove() virtual function for that.
//
// It's important to notice that gtk_widget_destroy() will only cause
// the @widget to be finalized if no additional references, acquired
// using g_object_ref(), are held on it. In case additional references
// are in place, the @widget will be in an "inert" state after calling
// this function; @widget will still point to valid memory, allowing you
// to release the references you hold, but you may not query the widget's
// own state.
//
// You should typically call this function on top level widgets, and
// rarely on child widgets.
//
// See also: gtk_container_remove()
/*

C function : gtk_widget_destroy
*/
func (recv *Widget) Destroy() {
	C.gtk_widget_destroy((*C.GtkWidget)(recv.native))

	return
}

// This function sets *@widget_pointer to %NULL if @widget_pointer !=
// %NULL.  Its intended to be used as a callback connected to the
// destroy signal of a widget. You connect gtk_widget_destroyed()
// as a signal handler, and pass the address of your widget variable
// as user data. Then when the widget is destroyed, the variable will
// be set to %NULL. Useful for example to avoid multiple copies
// of the same dialog.
/*

C function : gtk_widget_destroyed
*/
func (recv *Widget) Destroyed(widgetPointer *Widget) {
	c_widget_pointer := (**C.GtkWidget)(C.NULL)
	if widgetPointer != nil {
		c_widget_pointer = (**C.GtkWidget)(widgetPointer.ToC())
	}

	C.gtk_widget_destroyed((*C.GtkWidget)(recv.native), c_widget_pointer)

	return
}

// Unsupported : gtk_drag_begin : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Checks to see if a mouse drag starting at (@start_x, @start_y) and ending
// at (@current_x, @current_y) has passed the GTK+ drag threshold, and thus
// should trigger the beginning of a drag-and-drop operation.
/*

C function : gtk_drag_check_threshold
*/
func (recv *Widget) DragCheckThreshold(startX int32, startY int32, currentX int32, currentY int32) bool {
	c_start_x := (C.gint)(startX)

	c_start_y := (C.gint)(startY)

	c_current_x := (C.gint)(currentX)

	c_current_y := (C.gint)(currentY)

	retC := C.gtk_drag_check_threshold((*C.GtkWidget)(recv.native), c_start_x, c_start_y, c_current_x, c_current_y)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_drag_dest_find_target : return type : Blacklisted record : GdkAtom

// Returns the list of targets this widget can accept from
// drag-and-drop.
/*

C function : gtk_drag_dest_get_target_list
*/
func (recv *Widget) DragDestGetTargetList() *TargetList {
	retC := C.gtk_drag_dest_get_target_list((*C.GtkWidget)(recv.native))
	var retGo (*TargetList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TargetListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_drag_dest_set : unsupported parameter targets :

// Sets this widget as a proxy for drops to another window.
/*

C function : gtk_drag_dest_set_proxy
*/
func (recv *Widget) DragDestSetProxy(proxyWindow *gdk.Window, protocol gdk.DragProtocol, useCoordinates bool) {
	c_proxy_window := (*C.GdkWindow)(C.NULL)
	if proxyWindow != nil {
		c_proxy_window = (*C.GdkWindow)(proxyWindow.ToC())
	}

	c_protocol := (C.GdkDragProtocol)(protocol)

	c_use_coordinates :=
		boolToGboolean(useCoordinates)

	C.gtk_drag_dest_set_proxy((*C.GtkWidget)(recv.native), c_proxy_window, c_protocol, c_use_coordinates)

	return
}

// Sets the target types that this widget can accept from drag-and-drop.
// The widget must first be made into a drag destination with
// gtk_drag_dest_set().
/*

C function : gtk_drag_dest_set_target_list
*/
func (recv *Widget) DragDestSetTargetList(targetList *TargetList) {
	c_target_list := (*C.GtkTargetList)(C.NULL)
	if targetList != nil {
		c_target_list = (*C.GtkTargetList)(targetList.ToC())
	}

	C.gtk_drag_dest_set_target_list((*C.GtkWidget)(recv.native), c_target_list)

	return
}

// Clears information about a drop destination set with
// gtk_drag_dest_set(). The widget will no longer receive
// notification of drags.
/*

C function : gtk_drag_dest_unset
*/
func (recv *Widget) DragDestUnset() {
	C.gtk_drag_dest_unset((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_drag_get_data : unsupported parameter target : Blacklisted record : GdkAtom

// Highlights a widget as a currently hovered drop target.
// To end the highlight, call gtk_drag_unhighlight().
// GTK+ calls this automatically if %GTK_DEST_DEFAULT_HIGHLIGHT is set.
/*

C function : gtk_drag_highlight
*/
func (recv *Widget) DragHighlight() {
	C.gtk_drag_highlight((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_drag_source_set : unsupported parameter targets :

// Sets the icon that will be used for drags from a particular widget
// from a #GdkPixbuf. GTK+ retains a reference for @pixbuf and will
// release it when it is no longer needed.
/*

C function : gtk_drag_source_set_icon_pixbuf
*/
func (recv *Widget) DragSourceSetIconPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_drag_source_set_icon_pixbuf((*C.GtkWidget)(recv.native), c_pixbuf)

	return
}

// Sets the icon that will be used for drags from a particular source
// to a stock icon.
/*

C function : gtk_drag_source_set_icon_stock
*/
func (recv *Widget) DragSourceSetIconStock(stockId string) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	C.gtk_drag_source_set_icon_stock((*C.GtkWidget)(recv.native), c_stock_id)

	return
}

// Undoes the effects of gtk_drag_source_set().
/*

C function : gtk_drag_source_unset
*/
func (recv *Widget) DragSourceUnset() {
	C.gtk_drag_source_unset((*C.GtkWidget)(recv.native))

	return
}

// Removes a highlight set by gtk_drag_highlight() from
// a widget.
/*

C function : gtk_drag_unhighlight
*/
func (recv *Widget) DragUnhighlight() {
	C.gtk_drag_unhighlight((*C.GtkWidget)(recv.native))

	return
}

// Ensures that @widget has a style (@widget->style).
//
// Not a very useful function; most of the time, if you
// want the style, the widget is realized, and realized
// widgets are guaranteed to have a style already.
/*

C function : gtk_widget_ensure_style
*/
func (recv *Widget) EnsureStyle() {
	C.gtk_widget_ensure_style((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_widget_event : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Stops emission of #GtkWidget::child-notify signals on @widget. The
// signals are queued until gtk_widget_thaw_child_notify() is called
// on @widget.
//
// This is the analogue of g_object_freeze_notify() for child properties.
/*

C function : gtk_widget_freeze_child_notify
*/
func (recv *Widget) FreezeChildNotify() {
	C.gtk_widget_freeze_child_notify((*C.GtkWidget)(recv.native))

	return
}

// Returns the accessible object that describes the widget to an
// assistive technology.
//
// If accessibility support is not available, this #AtkObject
// instance may be a no-op. Likewise, if no class-specific #AtkObject
// implementation is available for the widget instance in question,
// it will inherit an #AtkObject implementation from the first ancestor
// class for which such an implementation is defined.
//
// The documentation of the
// [ATK](http://developer.gnome.org/atk/stable/)
// library contains more information about accessible objects and their uses.
/*

C function : gtk_widget_get_accessible
*/
func (recv *Widget) GetAccessible() *atk.Object {
	retC := C.gtk_widget_get_accessible((*C.GtkWidget)(recv.native))
	retGo := atk.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the height that has currently been allocated to @widget.
// This function is intended to be used when implementing handlers
// for the #GtkWidget::draw function.
/*

C function : gtk_widget_get_allocated_height
*/
func (recv *Widget) GetAllocatedHeight() int32 {
	retC := C.gtk_widget_get_allocated_height((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the width that has currently been allocated to @widget.
// This function is intended to be used when implementing handlers
// for the #GtkWidget::draw function.
/*

C function : gtk_widget_get_allocated_width
*/
func (recv *Widget) GetAllocatedWidth() int32 {
	retC := C.gtk_widget_get_allocated_width((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the first ancestor of @widget with type @widget_type. For example,
// `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets
// the first #GtkBox thats an ancestor of @widget. No reference will be
// added to the returned widget; it should not be unreferenced. See note
// about checking for a toplevel #GtkWindow in the docs for
// gtk_widget_get_toplevel().
//
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers @widget to be an ancestor of itself.
/*

C function : gtk_widget_get_ancestor
*/
func (recv *Widget) GetAncestor(widgetType gobject.Type) *Widget {
	c_widget_type := (C.GType)(widgetType)

	retC := C.gtk_widget_get_ancestor((*C.GtkWidget)(recv.native), c_widget_type)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// This function is only for use in widget implementations. Obtains
// @widget->requisition, unless someone has forced a particular
// geometry on the widget (e.g. with gtk_widget_set_size_request()),
// in which case it returns that geometry instead of the widget's
// requisition.
//
// This function differs from gtk_widget_size_request() in that
// it retrieves the last size request value from @widget->requisition,
// while gtk_widget_size_request() actually calls the "size_request" method
// on @widget to compute the size request and fill in @widget->requisition,
// and only then returns @widget->requisition.
//
// Because this function does not call the size_request method, it
// can only be used when you know that @widget->requisition is
// up-to-date, that is, gtk_widget_size_request() has been called
// since the last time a resize was queued. In general, only container
// implementations have this information; applications should use
// gtk_widget_size_request().
/*

C function : gtk_widget_get_child_requisition
*/
func (recv *Widget) GetChildRequisition() *Requisition {
	var c_requisition C.GtkRequisition

	C.gtk_widget_get_child_requisition((*C.GtkWidget)(recv.native), &c_requisition)

	requisition := RequisitionNewFromC(unsafe.Pointer(&c_requisition))

	return requisition
}

// Gets the value set with gtk_widget_set_child_visible().
// If you feel a need to use this function, your code probably
// needs reorganization.
//
// This function is only useful for container implementations and
// never should be called by an application.
/*

C function : gtk_widget_get_child_visible
*/
func (recv *Widget) GetChildVisible() bool {
	retC := C.gtk_widget_get_child_visible((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Obtains the composite name of a widget.
/*

C function : gtk_widget_get_composite_name
*/
func (recv *Widget) GetCompositeName() string {
	retC := C.gtk_widget_get_composite_name((*C.GtkWidget)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
/*

C function : gtk_widget_get_direction
*/
func (recv *Widget) GetDirection() TextDirection {
	retC := C.gtk_widget_get_direction((*C.GtkWidget)(recv.native))
	retGo := (TextDirection)(retC)

	return retGo
}

// Returns the event mask (see #GdkEventMask) for the widget. These are the
// events that the widget will receive.
//
// Note: Internally, the widget event mask will be the logical OR of the event
// mask set through gtk_widget_set_events() or gtk_widget_add_events(), and the
// event mask necessary to cater for every #GtkEventController created for the
// widget.
/*

C function : gtk_widget_get_events
*/
func (recv *Widget) GetEvents() int32 {
	retC := C.gtk_widget_get_events((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the value of the #GtkWidget:halign property.
//
// For backwards compatibility reasons this method will never return
// %GTK_ALIGN_BASELINE, but instead it will convert it to
// %GTK_ALIGN_FILL. Baselines are not supported for horizontal
// alignment.
/*

C function : gtk_widget_get_halign
*/
func (recv *Widget) GetHalign() Align {
	retC := C.gtk_widget_get_halign((*C.GtkWidget)(recv.native))
	retGo := (Align)(retC)

	return retGo
}

// Gets whether the widget would like any available extra horizontal
// space. When a user resizes a #GtkWindow, widgets with expand=TRUE
// generally receive the extra space. For example, a list or
// scrollable area or document in your window would often be set to
// expand.
//
// Containers should use gtk_widget_compute_expand() rather than
// this function, to see whether a widget, or any of its children,
// has the expand flag set. If any child of a widget wants to
// expand, the parent may ask to expand also.
//
// This function only looks at the widgets own hexpand flag, rather
// than computing whether the entire widget tree rooted at this widget
// wants to expand.
/*

C function : gtk_widget_get_hexpand
*/
func (recv *Widget) GetHexpand() bool {
	retC := C.gtk_widget_get_hexpand((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets whether gtk_widget_set_hexpand() has been used to
// explicitly set the expand flag on this widget.
//
// If hexpand is set, then it overrides any computed
// expand value based on child widgets. If hexpand is not
// set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but its here
// for completeness and consistency.
/*

C function : gtk_widget_get_hexpand_set
*/
func (recv *Widget) GetHexpandSet() bool {
	retC := C.gtk_widget_get_hexpand_set((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the current modifier style for the widget. (As set by
// gtk_widget_modify_style().) If no style has previously set, a new
// #GtkRcStyle will be created with all values unset, and set as the
// modifier style for the widget. If you make changes to this rc
// style, you must call gtk_widget_modify_style(), passing in the
// returned rc style, to make sure that your changes take effect.
//
// Caution: passing the style back to gtk_widget_modify_style() will
// normally end up destroying it, because gtk_widget_modify_style() copies
// the passed-in style and sets the copy as the new modifier style,
// thus dropping any reference to the old modifier style. Add a reference
// to the modifier style if you want to keep it alive.
/*

C function : gtk_widget_get_modifier_style
*/
func (recv *Widget) GetModifierStyle() *RcStyle {
	retC := C.gtk_widget_get_modifier_style((*C.GtkWidget)(recv.native))
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
/*

C function : gtk_widget_get_name
*/
func (recv *Widget) GetName() string {
	retC := C.gtk_widget_get_name((*C.GtkWidget)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Gets a #PangoContext with the appropriate font map, font description,
// and base direction for this widget. Unlike the context returned
// by gtk_widget_create_pango_context(), this context is owned by
// the widget (it can be used until the screen for the widget changes
// or the widget is removed from its toplevel), and will be updated to
// match any changes to the widgets attributes. This can be tracked
// by using the #GtkWidget::screen-changed signal on the widget.
/*

C function : gtk_widget_get_pango_context
*/
func (recv *Widget) GetPangoContext() *pango.Context {
	retC := C.gtk_widget_get_pango_context((*C.GtkWidget)(recv.native))
	retGo := pango.ContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the parent container of @widget.
/*

C function : gtk_widget_get_parent
*/
func (recv *Widget) GetParent() *Widget {
	retC := C.gtk_widget_get_parent((*C.GtkWidget)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets @widgets parent window, or %NULL if it does not have one.
/*

C function : gtk_widget_get_parent_window
*/
func (recv *Widget) GetParentWindow() *gdk.Window {
	retC := C.gtk_widget_get_parent_window((*C.GtkWidget)(recv.native))
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the #GtkWidgetPath representing @widget, if the widget
// is not connected to a toplevel widget, a partial path will be
// created.
/*

C function : gtk_widget_get_path
*/
func (recv *Widget) GetPath() *WidgetPath {
	retC := C.gtk_widget_get_path((*C.GtkWidget)(recv.native))
	retGo := WidgetPathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Obtains the location of the mouse pointer in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are
// defined as @widget->window coordinates for widgets that return %TRUE for
// gtk_widget_get_has_window(); and are relative to @widget->allocation.x,
// @widget->allocation.y otherwise.
/*

C function : gtk_widget_get_pointer
*/
func (recv *Widget) GetPointer() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_widget_get_pointer((*C.GtkWidget)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// Gets the settings object holding the settings used for this widget.
//
// Note that this function can only be called when the #GtkWidget
// is attached to a toplevel, since the settings object is specific
// to a particular #GdkScreen.
/*

C function : gtk_widget_get_settings
*/
func (recv *Widget) GetSettings() *Settings {
	retC := C.gtk_widget_get_settings((*C.GtkWidget)(recv.native))
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the size request that was explicitly set for the widget using
// gtk_widget_set_size_request(). A value of -1 stored in @width or
// @height indicates that that dimension has not been set explicitly
// and the natural requisition of the widget will be used instead. See
// gtk_widget_set_size_request(). To get the size a widget will
// actually request, call gtk_widget_get_preferred_size() instead of
// this function.
/*

C function : gtk_widget_get_size_request
*/
func (recv *Widget) GetSizeRequest() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_widget_get_size_request((*C.GtkWidget)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// Simply an accessor function that returns @widget->style.
/*

C function : gtk_widget_get_style
*/
func (recv *Widget) GetStyle() *Style {
	retC := C.gtk_widget_get_style((*C.GtkWidget)(recv.native))
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the style context associated to @widget. The returned object is
// guaranteed to be the same for the lifetime of @widget.
/*

C function : gtk_widget_get_style_context
*/
func (recv *Widget) GetStyleContext() *StyleContext {
	retC := C.gtk_widget_get_style_context((*C.GtkWidget)(recv.native))
	retGo := StyleContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if @widget is multiple pointer aware. See
// gtk_widget_set_support_multidevice() for more information.
/*

C function : gtk_widget_get_support_multidevice
*/
func (recv *Widget) GetSupportMultidevice() bool {
	retC := C.gtk_widget_get_support_multidevice((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Fetch an object build from the template XML for @widget_type in this @widget instance.
//
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its
// variants.
//
// This function is only meant to be called for code which is private to the @widget_type which
// declared the child and is meant for language bindings which cannot easily make use
// of the GObject structure offsets.
/*

C function : gtk_widget_get_template_child
*/
func (recv *Widget) GetTemplateChild(widgetType gobject.Type, name string) *gobject.Object {
	c_widget_type := (C.GType)(widgetType)

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_widget_get_template_child((*C.GtkWidget)(recv.native), c_widget_type, c_name)
	retGo := gobject.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This function returns the topmost widget in the container hierarchy
// @widget is a part of. If @widget has no parent widgets, it will be
// returned as the topmost widget. No reference will be added to the
// returned widget; it should not be unreferenced.
//
// Note the difference in behavior vs. gtk_widget_get_ancestor();
// `gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW)`
// would return
// %NULL if @widget wasnt inside a toplevel window, and if the
// window was inside a #GtkWindow-derived widget which was in turn
// inside the toplevel #GtkWindow. While the second case may
// seem unlikely, it actually happens when a #GtkPlug is embedded
// inside a #GtkSocket within the same application.
//
// To reliably find the toplevel #GtkWindow, use
// gtk_widget_get_toplevel() and call GTK_IS_WINDOW()
// on the result. For instance, to get the title of a widget's toplevel
// window, one might use:
// |[<!-- language="C" -->
// static const char *
// get_widget_toplevel_title (GtkWidget *widget)
// {
// GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
// if (GTK_IS_WINDOW (toplevel))
// {
// return gtk_window_get_title (GTK_WINDOW (toplevel));
// }
//
// return NULL;
// }
// ]|
/*

C function : gtk_widget_get_toplevel
*/
func (recv *Widget) GetToplevel() *Widget {
	retC := C.gtk_widget_get_toplevel((*C.GtkWidget)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the value of the #GtkWidget:valign property.
//
// For backwards compatibility reasons this method will never return
// %GTK_ALIGN_BASELINE, but instead it will convert it to
// %GTK_ALIGN_FILL. If your widget want to support baseline aligned
// children it must use gtk_widget_get_valign_with_baseline(), or
// `g_object_get (widget, "valign", &value, NULL)`, which will
// also report the true value.
/*

C function : gtk_widget_get_valign
*/
func (recv *Widget) GetValign() Align {
	retC := C.gtk_widget_get_valign((*C.GtkWidget)(recv.native))
	retGo := (Align)(retC)

	return retGo
}

// Gets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_get_hexpand() for more detail.
/*

C function : gtk_widget_get_vexpand
*/
func (recv *Widget) GetVexpand() bool {
	retC := C.gtk_widget_get_vexpand((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets whether gtk_widget_set_vexpand() has been used to
// explicitly set the expand flag on this widget.
//
// See gtk_widget_get_hexpand_set() for more detail.
/*

C function : gtk_widget_get_vexpand_set
*/
func (recv *Widget) GetVexpandSet() bool {
	retC := C.gtk_widget_get_vexpand_set((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the visual that will be used to render @widget.
/*

C function : gtk_widget_get_visual
*/
func (recv *Widget) GetVisual() *gdk.Visual {
	retC := C.gtk_widget_get_visual((*C.GtkWidget)(recv.native))
	retGo := gdk.VisualNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Makes @widget the current grabbed widget.
//
// This means that interaction with other widgets in the same
// application is blocked and mouse as well as keyboard events
// are delivered to this widget.
//
// If @widget is not sensitive, it is not set as the current
// grabbed widget and this function does nothing.
/*

C function : gtk_grab_add
*/
func (recv *Widget) GrabAdd() {
	C.gtk_grab_add((*C.GtkWidget)(recv.native))

	return
}

// Causes @widget to become the default widget. @widget must be able to be
// a default widget; typically you would ensure this yourself
// by calling gtk_widget_set_can_default() with a %TRUE value.
// The default widget is activated when
// the user presses Enter in a window. Default widgets must be
// activatable, that is, gtk_widget_activate() should affect them. Note
// that #GtkEntry widgets require the activates-default property
// set to %TRUE before they activate the default widget when Enter
// is pressed and the #GtkEntry is focused.
/*

C function : gtk_widget_grab_default
*/
func (recv *Widget) GrabDefault() {
	C.gtk_widget_grab_default((*C.GtkWidget)(recv.native))

	return
}

// Causes @widget to have the keyboard focus for the #GtkWindow it's
// inside. @widget must be a focusable widget, such as a #GtkEntry;
// something like #GtkFrame wont work.
//
// More precisely, it must have the %GTK_CAN_FOCUS flag set. Use
// gtk_widget_set_can_focus() to modify that flag.
//
// The widget also needs to be realized and mapped. This is indicated by the
// related signals. Grabbing the focus immediately after creating the widget
// will likely fail and cause critical warnings.
/*

C function : gtk_widget_grab_focus
*/
func (recv *Widget) GrabFocus() {
	C.gtk_widget_grab_focus((*C.GtkWidget)(recv.native))

	return
}

// Removes the grab from the given widget.
//
// You have to pair calls to gtk_grab_add() and gtk_grab_remove().
//
// If @widget does not have the grab, this function does nothing.
/*

C function : gtk_grab_remove
*/
func (recv *Widget) GrabRemove() {
	C.gtk_grab_remove((*C.GtkWidget)(recv.native))

	return
}

// Reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
/*

C function : gtk_widget_hide
*/
func (recv *Widget) Hide() {
	C.gtk_widget_hide((*C.GtkWidget)(recv.native))

	return
}

// Utility function; intended to be connected to the #GtkWidget::delete-event
// signal on a #GtkWindow. The function calls gtk_widget_hide() on its
// argument, then returns %TRUE. If connected to ::delete-event, the
// result is that clicking the close button for a window (on the
// window frame, top right corner usually) will hide but not destroy
// the window. By default, GTK+ destroys windows when ::delete-event
// is received.
/*

C function : gtk_widget_hide_on_delete
*/
func (recv *Widget) HideOnDelete() bool {
	retC := C.gtk_widget_hide_on_delete((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether the widget is currently being destroyed.
// This information can sometimes be used to avoid doing
// unnecessary work.
/*

C function : gtk_widget_in_destruction
*/
func (recv *Widget) InDestruction() bool {
	retC := C.gtk_widget_in_destruction((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_widget_intersect : unsupported parameter area : Blacklisted record : GdkRectangle

// Determines whether @widget is somewhere inside @ancestor, possibly with
// intermediate containers.
/*

C function : gtk_widget_is_ancestor
*/
func (recv *Widget) IsAncestor(ancestor *Widget) bool {
	c_ancestor := (*C.GtkWidget)(C.NULL)
	if ancestor != nil {
		c_ancestor = (*C.GtkWidget)(ancestor.ToC())
	}

	retC := C.gtk_widget_is_ancestor((*C.GtkWidget)(recv.native), c_ancestor)
	retGo := retC == C.TRUE

	return retGo
}

// Determines if the widget is the focus widget within its
// toplevel. (This does not mean that the #GtkWidget:has-focus property is
// necessarily set; #GtkWidget:has-focus will only be set if the
// toplevel widget additionally has the global input focus.)
/*

C function : gtk_widget_is_focus
*/
func (recv *Widget) IsFocus() bool {
	retC := C.gtk_widget_is_focus((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Lists the closures used by @widget for accelerator group connections
// with gtk_accel_group_connect_by_path() or gtk_accel_group_connect().
// The closures can be used to monitor accelerator changes on @widget,
// by connecting to the @GtkAccelGroup::accel-changed signal of the
// #GtkAccelGroup of a closure which can be found out with
// gtk_accel_group_from_accel_closure().
/*

C function : gtk_widget_list_accel_closures
*/
func (recv *Widget) ListAccelClosures() *glib.List {
	retC := C.gtk_widget_list_accel_closures((*C.GtkWidget)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This function is only for use in widget implementations. Causes
// a widget to be mapped if it isnt already.
/*

C function : gtk_widget_map
*/
func (recv *Widget) Map() {
	C.gtk_widget_map((*C.GtkWidget)(recv.native))

	return
}

// Emits the #GtkWidget::mnemonic-activate signal.
/*

C function : gtk_widget_mnemonic_activate
*/
func (recv *Widget) MnemonicActivate(groupCycling bool) bool {
	c_group_cycling :=
		boolToGboolean(groupCycling)

	retC := C.gtk_widget_mnemonic_activate((*C.GtkWidget)(recv.native), c_group_cycling)
	retGo := retC == C.TRUE

	return retGo
}

// Sets the base color for a widget in a particular state.
// All other style values are left untouched. The base color
// is the background color used along with the text color
// (see gtk_widget_modify_text()) for widgets such as #GtkEntry
// and #GtkTextView. See also gtk_widget_modify_style().
//
// > Note that no window widgets (which have the %GTK_NO_WINDOW
// > flag set) draw on their parent containers window and thus may
// > not draw any background themselves. This is the case for e.g.
// > #GtkLabel.
// >
// > To modify the background of such widgets, you have to set the
// > base color on their parent; if you want to set the background
// > of a rectangular area around a label, try placing the label in
// > a #GtkEventBox widget and setting the base color on that.
/*

C function : gtk_widget_modify_base
*/
func (recv *Widget) ModifyBase(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_base((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Sets the background color for a widget in a particular state.
//
// All other style values are left untouched.
// See also gtk_widget_modify_style().
//
// > Note that no window widgets (which have the %GTK_NO_WINDOW
// > flag set) draw on their parent containers window and thus may
// > not draw any background themselves. This is the case for e.g.
// > #GtkLabel.
// >
// > To modify the background of such widgets, you have to set the
// > background color on their parent; if you want to set the background
// > of a rectangular area around a label, try placing the label in
// > a #GtkEventBox widget and setting the background color on that.
/*

C function : gtk_widget_modify_bg
*/
func (recv *Widget) ModifyBg(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_bg((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Sets the foreground color for a widget in a particular state.
//
// All other style values are left untouched.
// See also gtk_widget_modify_style().
/*

C function : gtk_widget_modify_fg
*/
func (recv *Widget) ModifyFg(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_fg((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Sets the font to use for a widget.
//
// All other style values are left untouched.
// See also gtk_widget_modify_style().
/*

C function : gtk_widget_modify_font
*/
func (recv *Widget) ModifyFont(fontDesc *pango.FontDescription) {
	c_font_desc := (*C.PangoFontDescription)(C.NULL)
	if fontDesc != nil {
		c_font_desc = (*C.PangoFontDescription)(fontDesc.ToC())
	}

	C.gtk_widget_modify_font((*C.GtkWidget)(recv.native), c_font_desc)

	return
}

// Modifies style values on the widget.
//
// Modifications made using this technique take precedence over
// style values set via an RC file, however, they will be overridden
// if a style is explicitly set on the widget using gtk_widget_set_style().
// The #GtkRcStyle-struct is designed so each field can either be
// set or unset, so it is possible, using this function, to modify some
// style values and leave the others unchanged.
//
// Note that modifications made with this function are not cumulative
// with previous calls to gtk_widget_modify_style() or with such
// functions as gtk_widget_modify_fg(). If you wish to retain
// previous values, you must first call gtk_widget_get_modifier_style(),
// make your modifications to the returned style, then call
// gtk_widget_modify_style() with that style. On the other hand,
// if you first call gtk_widget_modify_style(), subsequent calls
// to such functions gtk_widget_modify_fg() will have a cumulative
// effect with the initial modifications.
/*

C function : gtk_widget_modify_style
*/
func (recv *Widget) ModifyStyle(style *RcStyle) {
	c_style := (*C.GtkRcStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkRcStyle)(style.ToC())
	}

	C.gtk_widget_modify_style((*C.GtkWidget)(recv.native), c_style)

	return
}

// Sets the text color for a widget in a particular state.
//
// All other style values are left untouched.
// The text color is the foreground color used along with the
// base color (see gtk_widget_modify_base()) for widgets such
// as #GtkEntry and #GtkTextView.
// See also gtk_widget_modify_style().
/*

C function : gtk_widget_modify_text
*/
func (recv *Widget) ModifyText(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_text((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Obtains the full path to @widget. The path is simply the name of a
// widget and all its parents in the container hierarchy, separated by
// periods. The name of a widget comes from
// gtk_widget_get_name(). Paths are used to apply styles to a widget
// in gtkrc configuration files. Widget names are the type of the
// widget by default (e.g. GtkButton) or can be set to an
// application-specific value with gtk_widget_set_name(). By setting
// the name of a widget, you allow users or theme authors to apply
// styles to that specific widget in their gtkrc
// file. @path_reversed_p fills in the path in reverse order,
// i.e. starting with @widgets name instead of starting with the name
// of @widgets outermost ancestor.
/*

C function : gtk_widget_path
*/
func (recv *Widget) Path() (uint32, string, string) {
	var c_path_length C.guint

	var c_path *C.gchar

	var c_path_reversed *C.gchar

	C.gtk_widget_path((*C.GtkWidget)(recv.native), &c_path_length, &c_path, &c_path_reversed)

	pathLength := (uint32)(c_path_length)

	path := C.GoString(c_path)
	defer C.free(unsafe.Pointer(c_path))

	pathReversed := C.GoString(c_path_reversed)
	defer C.free(unsafe.Pointer(c_path_reversed))

	return pathLength, path, pathReversed
}

// Mark @widget as needing to recompute its expand flags. Call
// this function when setting legacy expand child properties
// on the child of a container.
//
// See gtk_widget_compute_expand().
/*

C function : gtk_widget_queue_compute_expand
*/
func (recv *Widget) QueueComputeExpand() {
	C.gtk_widget_queue_compute_expand((*C.GtkWidget)(recv.native))

	return
}

// Equivalent to calling gtk_widget_queue_draw_area() for the
// entire area of a widget.
/*

C function : gtk_widget_queue_draw
*/
func (recv *Widget) QueueDraw() {
	C.gtk_widget_queue_draw((*C.GtkWidget)(recv.native))

	return
}

// Convenience function that calls gtk_widget_queue_draw_region() on
// the region created from the given coordinates.
//
// The region here is specified in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are
// defined as @widget->window coordinates for widgets that return %TRUE for
// gtk_widget_get_has_window(), and are relative to @widget->allocation.x,
// @widget->allocation.y otherwise.
//
// @width or @height may be 0, in this case this function does
// nothing. Negative values for @width and @height are not allowed.
/*

C function : gtk_widget_queue_draw_area
*/
func (recv *Widget) QueueDrawArea(x int32, y int32, width int32, height int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_widget_queue_draw_area((*C.GtkWidget)(recv.native), c_x, c_y, c_width, c_height)

	return
}

// This function is only for use in widget implementations.
// Flags a widget to have its size renegotiated; should
// be called when a widget for some reason has a new size request.
// For example, when you change the text in a #GtkLabel, #GtkLabel
// queues a resize to ensure theres enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget
// from inside its implementation of the GtkWidgetClass::size_allocate
// virtual method. Calls to gtk_widget_queue_resize() from inside
// GtkWidgetClass::size_allocate will be silently ignored.
/*

C function : gtk_widget_queue_resize
*/
func (recv *Widget) QueueResize() {
	C.gtk_widget_queue_resize((*C.GtkWidget)(recv.native))

	return
}

// Creates the GDK (windowing system) resources associated with a
// widget.  For example, @widget->window will be created when a widget
// is realized.  Normally realization happens implicitly; if you show
// a widget and all its parent containers, then the widget will be
// realized and mapped automatically.
//
// Realizing a widget requires all
// the widgets parent widgets to be realized; calling
// gtk_widget_realize() realizes the widgets parents in addition to
// @widget itself. If a widget is not yet inside a toplevel window
// when you realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and
// isnt very useful otherwise. Many times when you think you might
// need it, a better approach is to connect to a signal that will be
// called after the widget is realized automatically, such as
// #GtkWidget::draw. Or simply g_signal_connect () to the
// #GtkWidget::realize signal.
/*

C function : gtk_widget_realize
*/
func (recv *Widget) Realize() {
	C.gtk_widget_realize((*C.GtkWidget)(recv.native))

	return
}

// Computes the intersection of a @widgets area and @region, returning
// the intersection. The result may be empty, use cairo_region_is_empty() to
// check.
/*

C function : gtk_widget_region_intersect
*/
func (recv *Widget) RegionIntersect(region *cairo.Region) *cairo.Region {
	c_region := (*C.cairo_region_t)(C.NULL)
	if region != nil {
		c_region = (*C.cairo_region_t)(region.ToC())
	}

	retC := C.gtk_widget_region_intersect((*C.GtkWidget)(recv.native), c_region)
	retGo := cairo.RegionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Removes an accelerator from @widget, previously installed with
// gtk_widget_add_accelerator().
/*

C function : gtk_widget_remove_accelerator
*/
func (recv *Widget) RemoveAccelerator(accelGroup *AccelGroup, accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_widget_remove_accelerator((*C.GtkWidget)(recv.native), c_accel_group, c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// A convenience function that uses the theme settings for @widget
// to look up @stock_id and render it to a pixbuf. @stock_id should
// be a stock icon ID such as #GTK_STOCK_OPEN or #GTK_STOCK_OK. @size
// should be a size such as #GTK_ICON_SIZE_MENU. @detail should be a
// string that identifies the widget or code doing the rendering, so
// that theme engines can special-case rendering for that widget or
// code.
//
// The pixels in the returned #GdkPixbuf are shared with the rest of
// the application and should not be modified. The pixbuf should be
// freed after use with g_object_unref().
/*

C function : gtk_widget_render_icon
*/
func (recv *Widget) RenderIcon(stockId string, size IconSize, detail string) *gdkpixbuf.Pixbuf {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	retC := C.gtk_widget_render_icon((*C.GtkWidget)(recv.native), c_stock_id, c_size, c_detail)
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Moves a widget from one #GtkContainer to another, handling reference
// count issues to avoid destroying the widget.
/*

C function : gtk_widget_reparent
*/
func (recv *Widget) Reparent(newParent *Widget) {
	c_new_parent := (*C.GtkWidget)(C.NULL)
	if newParent != nil {
		c_new_parent = (*C.GtkWidget)(newParent.ToC())
	}

	C.gtk_widget_reparent((*C.GtkWidget)(recv.native), c_new_parent)

	return
}

// Reset the styles of @widget and all descendents, so when
// they are looked up again, they get the correct values
// for the currently loaded RC file settings.
//
// This function is not useful for applications.
/*

C function : gtk_widget_reset_rc_styles
*/
func (recv *Widget) ResetRcStyles() {
	C.gtk_widget_reset_rc_styles((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_widget_send_expose : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Given an accelerator group, @accel_group, and an accelerator path,
// @accel_path, sets up an accelerator in @accel_group so whenever the
// key binding that is defined for @accel_path is pressed, @widget
// will be activated.  This removes any accelerators (for any
// accelerator group) installed by previous calls to
// gtk_widget_set_accel_path(). Associating accelerators with
// paths allows them to be modified by the user and the modifications
// to be saved for future use. (See gtk_accel_map_save().)
//
// This function is a low level function that would most likely
// be used by a menu creation system like #GtkUIManager. If you
// use #GtkUIManager, setting up accelerator paths will be done
// automatically.
//
// Even when you you arent using #GtkUIManager, if you only want to
// set up accelerators on menu items gtk_menu_item_set_accel_path()
// provides a somewhat more convenient interface.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
/*

C function : gtk_widget_set_accel_path
*/
func (recv *Widget) SetAccelPath(accelPath string, accelGroup *AccelGroup) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_widget_set_accel_path((*C.GtkWidget)(recv.native), c_accel_path, c_accel_group)

	return
}

// Sets whether the application intends to draw on the widget in
// an #GtkWidget::draw handler.
//
// This is a hint to the widget and does not affect the behavior of
// the GTK+ core; many widgets ignore this flag entirely. For widgets
// that do pay attention to the flag, such as #GtkEventBox and #GtkWindow,
// the effect is to suppress default themed drawing of the widget's
// background. (Children of the widget will still be drawn.) The application
// is then entirely responsible for drawing the widget background.
//
// Note that the background is still drawn when the widget is mapped.
/*

C function : gtk_widget_set_app_paintable
*/
func (recv *Widget) SetAppPaintable(appPaintable bool) {
	c_app_paintable :=
		boolToGboolean(appPaintable)

	C.gtk_widget_set_app_paintable((*C.GtkWidget)(recv.native), c_app_paintable)

	return
}

// Sets whether @widget should be mapped along with its when its parent
// is mapped and @widget has been shown with gtk_widget_show().
//
// The child visibility can be set for widget before it is added to
// a container with gtk_widget_set_parent(), to avoid mapping
// children unnecessary before immediately unmapping them. However
// it will be reset to its default state of %TRUE when the widget
// is removed from a container.
//
// Note that changing the child visibility of a widget does not
// queue a resize on the widget. Most of the time, the size of
// a widget is computed from all visible children, whether or
// not they are mapped. If this is not the case, the container
// can queue a resize itself.
//
// This function is only useful for container implementations and
// never should be called by an application.
/*

C function : gtk_widget_set_child_visible
*/
func (recv *Widget) SetChildVisible(isVisible bool) {
	c_is_visible :=
		boolToGboolean(isVisible)

	C.gtk_widget_set_child_visible((*C.GtkWidget)(recv.native), c_is_visible)

	return
}

// Sets a widgets composite name. The widget must be
// a composite child of its parent; see gtk_widget_push_composite_child().
/*

C function : gtk_widget_set_composite_name
*/
func (recv *Widget) SetCompositeName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_widget_set_composite_name((*C.GtkWidget)(recv.native), c_name)

	return
}

// Sets the reading direction on a particular widget. This direction
// controls the primary direction for widgets containing text,
// and also the direction in which the children of a container are
// packed. The ability to set the direction is present in order
// so that correct localization into languages with right-to-left
// reading directions can be done. Generally, applications will
// let the default reading direction present, except for containers
// where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
//
// If the direction is set to %GTK_TEXT_DIR_NONE, then the value
// set by gtk_widget_set_default_direction() will be used.
/*

C function : gtk_widget_set_direction
*/
func (recv *Widget) SetDirection(dir TextDirection) {
	c_dir := (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction((*C.GtkWidget)(recv.native), c_dir)

	return
}

// Widgets are double buffered by default; you can use this function
// to turn off the buffering. Double buffered simply means that
// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are called
// automatically around expose events sent to the
// widget. gdk_window_begin_draw_frame() diverts all drawing to a widget's
// window to an offscreen buffer, and gdk_window_end_draw_frame() draws the
// buffer to the screen. The result is that users see the window
// update in one smooth step, and dont see individual graphics
// primitives being rendered.
//
// In very simple terms, double buffered widgets dont flicker,
// so you would only use this function to turn off double buffering
// if you had special needs and really knew what you were doing.
//
// Note: if you turn off double-buffering, you have to handle
// expose events, since even the clearing to the background color or
// pixmap will not happen automatically (as it is done in
// gdk_window_begin_draw_frame()).
//
// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
// then expose events for double-buffered widgets are culled into a single
// event to the toplevel GDK window. If you now unset double buffering, you
// will cause a separate rendering pass for every widget. This will likely
// cause rendering problems - in particular related to stacking - and usually
// increases rendering times significantly.
/*

C function : gtk_widget_set_double_buffered
*/
func (recv *Widget) SetDoubleBuffered(doubleBuffered bool) {
	c_double_buffered :=
		boolToGboolean(doubleBuffered)

	C.gtk_widget_set_double_buffered((*C.GtkWidget)(recv.native), c_double_buffered)

	return
}

// Sets the event mask (see #GdkEventMask) for a widget. The event
// mask determines which events a widget will receive. Keep in mind
// that different widgets have different default event masks, and by
// changing the event mask you may disrupt a widgets functionality,
// so be careful. This function must be called while a widget is
// unrealized. Consider gtk_widget_add_events() for widgets that are
// already realized, or if you want to preserve the existing event
// mask. This function cant be used with widgets that have no window.
// (See gtk_widget_get_has_window()).  To get events on those widgets,
// place them inside a #GtkEventBox and receive events on the event
// box.
/*

C function : gtk_widget_set_events
*/
func (recv *Widget) SetEvents(events int32) {
	c_events := (C.gint)(events)

	C.gtk_widget_set_events((*C.GtkWidget)(recv.native), c_events)

	return
}

// Sets the horizontal alignment of @widget.
// See the #GtkWidget:halign property.
/*

C function : gtk_widget_set_halign
*/
func (recv *Widget) SetHalign(align Align) {
	c_align := (C.GtkAlign)(align)

	C.gtk_widget_set_halign((*C.GtkWidget)(recv.native), c_align)

	return
}

// Sets whether the widget would like any available extra horizontal
// space. When a user resizes a #GtkWindow, widgets with expand=TRUE
// generally receive the extra space. For example, a list or
// scrollable area or document in your window would often be set to
// expand.
//
// Call this function to set the expand flag if you would like your
// widget to become larger horizontally when the window has extra
// room.
//
// By default, widgets automatically expand if any of their children
// want to expand. (To see if a widget will automatically expand given
// its current children and state, call gtk_widget_compute_expand(). A
// container can decide how the expandability of children affects the
// expansion of the container by overriding the compute_expand virtual
// method on #GtkWidget.).
//
// Setting hexpand explicitly with this function will override the
// automatic expand behavior.
//
// This function forces the widget to expand or not to expand,
// regardless of children.  The override occurs because
// gtk_widget_set_hexpand() sets the hexpand-set property (see
// gtk_widget_set_hexpand_set()) which causes the widgets hexpand
// value to be used, rather than looking at children and widget state.
/*

C function : gtk_widget_set_hexpand
*/
func (recv *Widget) SetHexpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_widget_set_hexpand((*C.GtkWidget)(recv.native), c_expand)

	return
}

// Sets whether the hexpand flag (see gtk_widget_get_hexpand()) will
// be used.
//
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely
// reason to use this function would be to unset an explicit expand
// flag.
//
// If hexpand is set, then it overrides any computed
// expand value based on child widgets. If hexpand is not
// set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but its here
// for completeness and consistency.
/*

C function : gtk_widget_set_hexpand_set
*/
func (recv *Widget) SetHexpandSet(set bool) {
	c_set :=
		boolToGboolean(set)

	C.gtk_widget_set_hexpand_set((*C.GtkWidget)(recv.native), c_set)

	return
}

// Widgets can be named, which allows you to refer to them from a
// CSS file. You can apply a style to widgets with a particular name
// in the CSS file. See the documentation for the CSS syntax (on the
// same page as the docs for #GtkStyleContext).
//
// Note that the CSS syntax has certain special characters to delimit
// and represent elements in a selector (period, #, >, *...), so using
// these will make your widget impossible to match by name. Any combination
// of alphanumeric symbols, dashes and underscores will suffice.
/*

C function : gtk_widget_set_name
*/
func (recv *Widget) SetName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_widget_set_name((*C.GtkWidget)(recv.native), c_name)

	return
}

// This function is useful only when implementing subclasses of
// #GtkContainer.
// Sets the container as the parent of @widget, and takes care of
// some details such as updating the state and style of the child
// to reflect its new location. The opposite function is
// gtk_widget_unparent().
/*

C function : gtk_widget_set_parent
*/
func (recv *Widget) SetParent(parent *Widget) {
	c_parent := (*C.GtkWidget)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWidget)(parent.ToC())
	}

	C.gtk_widget_set_parent((*C.GtkWidget)(recv.native), c_parent)

	return
}

// Sets a non default parent window for @widget.
//
// For #GtkWindow classes, setting a @parent_window effects whether
// the window is a toplevel window or can be embedded into other
// widgets.
//
// For #GtkWindow classes, this needs to be called before the
// window is realized.
/*

C function : gtk_widget_set_parent_window
*/
func (recv *Widget) SetParentWindow(parentWindow *gdk.Window) {
	c_parent_window := (*C.GdkWindow)(C.NULL)
	if parentWindow != nil {
		c_parent_window = (*C.GdkWindow)(parentWindow.ToC())
	}

	C.gtk_widget_set_parent_window((*C.GtkWidget)(recv.native), c_parent_window)

	return
}

// Sets whether the entire widget is queued for drawing when its size
// allocation changes. By default, this setting is %TRUE and
// the entire widget is redrawn on every size change. If your widget
// leaves the upper left unchanged when made bigger, turning this
// setting off will improve performance.
//
// Note that for widgets where gtk_widget_get_has_window() is %FALSE
// setting this flag to %FALSE turns off all allocation on resizing:
// the widget will not even redraw if its position changes; this is to
// allow containers that dont draw anything to avoid excess
// invalidations. If you set this flag on a widget with no window that
// does draw on @widget->window, you are
// responsible for invalidating both the old and new allocation of the
// widget when the widget is moved and responsible for invalidating
// regions newly when the widget increases size.
/*

C function : gtk_widget_set_redraw_on_allocate
*/
func (recv *Widget) SetRedrawOnAllocate(redrawOnAllocate bool) {
	c_redraw_on_allocate :=
		boolToGboolean(redrawOnAllocate)

	C.gtk_widget_set_redraw_on_allocate((*C.GtkWidget)(recv.native), c_redraw_on_allocate)

	return
}

// Sets the sensitivity of a widget. A widget is sensitive if the user
// can interact with it. Insensitive widgets are grayed out and the
// user cant interact with them. Insensitive widgets are known as
// inactive, disabled, or ghosted in some other toolkits.
/*

C function : gtk_widget_set_sensitive
*/
func (recv *Widget) SetSensitive(sensitive bool) {
	c_sensitive :=
		boolToGboolean(sensitive)

	C.gtk_widget_set_sensitive((*C.GtkWidget)(recv.native), c_sensitive)

	return
}

// Sets the minimum size of a widget; that is, the widgets size
// request will be at least @width by @height. You can use this
// function to force a widget to be larger than it normally would be.
//
// In most cases, gtk_window_set_default_size() is a better choice for
// toplevel windows than this function; setting the default size will
// still allow users to shrink the window. Setting the size request
// will force them to leave the window at least as large as the size
// request. When dealing with window sizes,
// gtk_window_set_geometry_hints() can be a useful function as well.
//
// Note the inherent danger of setting any fixed size - themes,
// translations into other languages, different fonts, and user action
// can all change the appropriate size for a given widget. So, it's
// basically impossible to hardcode a size that will always be
// correct.
//
// The size request of a widget is the smallest size a widget can
// accept while still functioning well and drawing itself correctly.
// However in some strange cases a widget may be allocated less than
// its requested size, and in many cases a widget may be allocated more
// space than it requested.
//
// If the size request in a given direction is -1 (unset), then
// the natural size request of the widget will be used instead.
//
// The size request set here does not include any margin from the
// #GtkWidget properties margin-left, margin-right, margin-top, and
// margin-bottom, but it does include pretty much all other padding
// or border properties set by any subclass of #GtkWidget.
/*

C function : gtk_widget_set_size_request
*/
func (recv *Widget) SetSizeRequest(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_widget_set_size_request((*C.GtkWidget)(recv.native), c_width, c_height)

	return
}

// This function is for use in widget implementations. Sets the state
// of a widget (insensitive, prelighted, etc.) Usually you should set
// the state using wrapper functions such as gtk_widget_set_sensitive().
/*

C function : gtk_widget_set_state
*/
func (recv *Widget) SetState(state StateType) {
	c_state := (C.GtkStateType)(state)

	C.gtk_widget_set_state((*C.GtkWidget)(recv.native), c_state)

	return
}

// Used to set the #GtkStyle for a widget (@widget->style). Since
// GTK 3, this function does nothing, the passed in style is ignored.
/*

C function : gtk_widget_set_style
*/
func (recv *Widget) SetStyle(style *Style) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	C.gtk_widget_set_style((*C.GtkWidget)(recv.native), c_style)

	return
}

// Sets the vertical alignment of @widget.
// See the #GtkWidget:valign property.
/*

C function : gtk_widget_set_valign
*/
func (recv *Widget) SetValign(align Align) {
	c_align := (C.GtkAlign)(align)

	C.gtk_widget_set_valign((*C.GtkWidget)(recv.native), c_align)

	return
}

// Sets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_set_hexpand() for more detail.
/*

C function : gtk_widget_set_vexpand
*/
func (recv *Widget) SetVexpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_widget_set_vexpand((*C.GtkWidget)(recv.native), c_expand)

	return
}

// Sets whether the vexpand flag (see gtk_widget_get_vexpand()) will
// be used.
//
// See gtk_widget_set_hexpand_set() for more detail.
/*

C function : gtk_widget_set_vexpand_set
*/
func (recv *Widget) SetVexpandSet(set bool) {
	c_set :=
		boolToGboolean(set)

	C.gtk_widget_set_vexpand_set((*C.GtkWidget)(recv.native), c_set)

	return
}

// Sets the visual that should be used for by widget and its children for
// creating #GdkWindows. The visual must be on the same #GdkScreen as
// returned by gtk_widget_get_screen(), so handling the
// #GtkWidget::screen-changed signal is necessary.
//
// Setting a new @visual will not cause @widget to recreate its windows,
// so you should call this function before @widget is realized.
/*

C function : gtk_widget_set_visual
*/
func (recv *Widget) SetVisual(visual *gdk.Visual) {
	c_visual := (*C.GdkVisual)(C.NULL)
	if visual != nil {
		c_visual = (*C.GdkVisual)(visual.ToC())
	}

	C.gtk_widget_set_visual((*C.GtkWidget)(recv.native), c_visual)

	return
}

// Flags a widget to be displayed. Any widget that isnt shown will
// not appear on the screen. If you want to show all the widgets in a
// container, its easier to call gtk_widget_show_all() on the
// container, instead of individually showing the widgets.
//
// Remember that you have to show the containers containing a widget,
// in addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and
// mapped; other shown widgets are realized and mapped when their
// toplevel container is realized and mapped.
/*

C function : gtk_widget_show
*/
func (recv *Widget) Show() {
	C.gtk_widget_show((*C.GtkWidget)(recv.native))

	return
}

// Recursively shows a widget, and any child widgets (if the widget is
// a container).
/*

C function : gtk_widget_show_all
*/
func (recv *Widget) ShowAll() {
	C.gtk_widget_show_all((*C.GtkWidget)(recv.native))

	return
}

// Shows a widget. If the widget is an unmapped toplevel widget
// (i.e. a #GtkWindow that has not yet been shown), enter the main
// loop and wait for the window to actually be mapped. Be careful;
// because the main loop is running, anything can happen during
// this function.
/*

C function : gtk_widget_show_now
*/
func (recv *Widget) ShowNow() {
	C.gtk_widget_show_now((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_widget_size_allocate : unsupported parameter allocation : Blacklisted record : GdkRectangle

// This function is typically used when implementing a #GtkContainer
// subclass.  Obtains the preferred size of a widget. The container
// uses this information to arrange its child widgets and decide what
// size allocations to give them with gtk_widget_size_allocate().
//
// You can also call this function from an application, with some
// caveats. Most notably, getting a size request requires the widget
// to be associated with a screen, because font information may be
// needed. Multihead-aware applications should keep this in mind.
//
// Also remember that the size request is not necessarily the size
// a widget will actually be allocated.
/*

C function : gtk_widget_size_request
*/
func (recv *Widget) SizeRequest() *Requisition {
	var c_requisition C.GtkRequisition

	C.gtk_widget_size_request((*C.GtkWidget)(recv.native), &c_requisition)

	requisition := RequisitionNewFromC(unsafe.Pointer(&c_requisition))

	return requisition
}

// Unsupported : gtk_widget_style_get : unsupported parameter ... : varargs

// Gets the value of a style property of @widget.
/*

C function : gtk_widget_style_get_property
*/
func (recv *Widget) StyleGetProperty(propertyName string, value *gobject.Value) {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_widget_style_get_property((*C.GtkWidget)(recv.native), c_property_name, c_value)

	return
}

// Unsupported : gtk_widget_style_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Reverts the effect of a previous call to gtk_widget_freeze_child_notify().
// This causes all queued #GtkWidget::child-notify signals on @widget to be
// emitted.
/*

C function : gtk_widget_thaw_child_notify
*/
func (recv *Widget) ThawChildNotify() {
	C.gtk_widget_thaw_child_notify((*C.GtkWidget)(recv.native))

	return
}

// Translate coordinates relative to @src_widgets allocation to coordinates
// relative to @dest_widgets allocations. In order to perform this
// operation, both widgets must be realized, and must share a common
// toplevel.
/*

C function : gtk_widget_translate_coordinates
*/
func (recv *Widget) TranslateCoordinates(destWidget *Widget, srcX int32, srcY int32) (bool, int32, int32) {
	c_dest_widget := (*C.GtkWidget)(C.NULL)
	if destWidget != nil {
		c_dest_widget = (*C.GtkWidget)(destWidget.ToC())
	}

	c_src_x := (C.gint)(srcX)

	c_src_y := (C.gint)(srcY)

	var c_dest_x C.gint

	var c_dest_y C.gint

	retC := C.gtk_widget_translate_coordinates((*C.GtkWidget)(recv.native), c_dest_widget, c_src_x, c_src_y, &c_dest_x, &c_dest_y)
	retGo := retC == C.TRUE

	destX := (int32)(c_dest_x)

	destY := (int32)(c_dest_y)

	return retGo, destX, destY
}

// This function is only for use in widget implementations. Causes
// a widget to be unmapped if its currently mapped.
/*

C function : gtk_widget_unmap
*/
func (recv *Widget) Unmap() {
	C.gtk_widget_unmap((*C.GtkWidget)(recv.native))

	return
}

// This function is only for use in widget implementations.
// Should be called by implementations of the remove method
// on #GtkContainer, to dissociate a child from the container.
/*

C function : gtk_widget_unparent
*/
func (recv *Widget) Unparent() {
	C.gtk_widget_unparent((*C.GtkWidget)(recv.native))

	return
}

// This function is only useful in widget implementations.
// Causes a widget to be unrealized (frees all GDK resources
// associated with the widget, such as @widget->window).
/*

C function : gtk_widget_unrealize
*/
func (recv *Widget) Unrealize() {
	C.gtk_widget_unrealize((*C.GtkWidget)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Widget
func (recv *Widget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Widget
func (recv *Widget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkWidgetAccessible
*/
type WidgetAccessible struct {
	native *C.GtkWidgetAccessible
	// parent : record
	// priv : record
}

func WidgetAccessibleNewFromC(u unsafe.Pointer) *WidgetAccessible {
	c := (*C.GtkWidgetAccessible)(u)
	if c == nil {
		return nil
	}

	g := &WidgetAccessible{native: c}

	return g
}

func (recv *WidgetAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Accessible upcasts to *Accessible
func (recv *WidgetAccessible) Accessible() *Accessible {
	return AccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *WidgetAccessible) Object() *atk.Object {
	return recv.Accessible().Object()
}

// CastToWidget down casts any arbitary Object to WidgetAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a WidgetAccessible.
func CastToWidgetAccessible(object *gobject.Object) *WidgetAccessible {
	return WidgetAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by WidgetAccessible
func (recv *WidgetAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// A GtkWindow is a toplevel window which can contain other widgets.
// Windows normally have decorations that are under the control
// of the windowing system and allow the user to manipulate the window
// (resize it, move it, close it,...).
//
// # GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the GtkBuildable interface supports a
// custom <accel-groups> element, which supports any number of <group>
// elements representing the #GtkAccelGroup objects you want to add to
// your window (synonymous with gtk_window_add_accel_group().
//
// It also supports the <initial-focus> element, whose name property names
// the widget to receive the focus when the window is mapped.
//
// An example of a UI definition fragment with accel groups:
// |[
// <object class="GtkWindow">
// <accel-groups>
// <group name="accelgroup1"/>
// </accel-groups>
// <initial-focus name="thunderclap"/>
// </object>
//
// ...
//
// <object class="GtkAccelGroup" id="accelgroup1"/>
// ]|
//
// The GtkWindow implementation of the GtkBuildable interface supports
// setting a child as the titlebar by specifying titlebar as the type
// attribute of a <child> element.
//
// # CSS nodes
//
// |[<!-- language="plain" -->
// window.background
//  decoration
//  <titlebar child>.titlebar [.default-decoration]
//  <child>
// ]|
//
// GtkWindow has a main CSS node with name window and style class .background,
// and a subnode with name decoration.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .tiled, .maximized, .fullscreen. Specialized
// types of window often add their own discriminating style classes, such as
// .popup or .tooltip.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
/*

C record/class : GtkWindow
*/
type Window struct {
	native *C.GtkWindow
	// bin : record
	// priv : record
}

func WindowNewFromC(u unsafe.Pointer) *Window {
	c := (*C.GtkWindow)(u)
	if c == nil {
		return nil
	}

	g := &Window{native: c}

	return g
}

func (recv *Window) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Window) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Window) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Window) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Window) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Window) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Window.
// Exercise care, as this is a potentially dangerous function if the Object is not a Window.
func CastToWindow(object *gobject.Object) *Window {
	return WindowNewFromC(object.ToC())
}

type signalWindowActivateDefaultDetail struct {
	callback  WindowSignalActivateDefaultCallback
	handlerID C.gulong
}

var signalWindowActivateDefaultId int
var signalWindowActivateDefaultMap = make(map[int]signalWindowActivateDefaultDetail)
var signalWindowActivateDefaultLock sync.Mutex

// WindowSignalActivateDefaultCallback is a callback function for a 'activate-default' signal emitted from a Window.
type WindowSignalActivateDefaultCallback func()

/*
ConnectActivateDefault connects the callback to the 'activate-default' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectActivateDefault to remove it.
*/
func (recv *Window) ConnectActivateDefault(callback WindowSignalActivateDefaultCallback) int {
	signalWindowActivateDefaultLock.Lock()
	defer signalWindowActivateDefaultLock.Unlock()

	signalWindowActivateDefaultId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_activate_default(instance, C.gpointer(uintptr(signalWindowActivateDefaultId)))

	detail := signalWindowActivateDefaultDetail{callback, handlerID}
	signalWindowActivateDefaultMap[signalWindowActivateDefaultId] = detail

	return signalWindowActivateDefaultId
}

/*
DisconnectActivateDefault disconnects a callback from the 'activate-default' signal for the Window.

The connectionID should be a value returned from a call to ConnectActivateDefault.
*/
func (recv *Window) DisconnectActivateDefault(connectionID int) {
	signalWindowActivateDefaultLock.Lock()
	defer signalWindowActivateDefaultLock.Unlock()

	detail, exists := signalWindowActivateDefaultMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowActivateDefaultMap, connectionID)
}

//export window_activateDefaultHandler
func window_activateDefaultHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWindowActivateDefaultMap[index].callback
	callback()
}

type signalWindowActivateFocusDetail struct {
	callback  WindowSignalActivateFocusCallback
	handlerID C.gulong
}

var signalWindowActivateFocusId int
var signalWindowActivateFocusMap = make(map[int]signalWindowActivateFocusDetail)
var signalWindowActivateFocusLock sync.Mutex

// WindowSignalActivateFocusCallback is a callback function for a 'activate-focus' signal emitted from a Window.
type WindowSignalActivateFocusCallback func()

/*
ConnectActivateFocus connects the callback to the 'activate-focus' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectActivateFocus to remove it.
*/
func (recv *Window) ConnectActivateFocus(callback WindowSignalActivateFocusCallback) int {
	signalWindowActivateFocusLock.Lock()
	defer signalWindowActivateFocusLock.Unlock()

	signalWindowActivateFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_activate_focus(instance, C.gpointer(uintptr(signalWindowActivateFocusId)))

	detail := signalWindowActivateFocusDetail{callback, handlerID}
	signalWindowActivateFocusMap[signalWindowActivateFocusId] = detail

	return signalWindowActivateFocusId
}

/*
DisconnectActivateFocus disconnects a callback from the 'activate-focus' signal for the Window.

The connectionID should be a value returned from a call to ConnectActivateFocus.
*/
func (recv *Window) DisconnectActivateFocus(connectionID int) {
	signalWindowActivateFocusLock.Lock()
	defer signalWindowActivateFocusLock.Unlock()

	detail, exists := signalWindowActivateFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowActivateFocusMap, connectionID)
}

//export window_activateFocusHandler
func window_activateFocusHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWindowActivateFocusMap[index].callback
	callback()
}

type signalWindowEnableDebuggingDetail struct {
	callback  WindowSignalEnableDebuggingCallback
	handlerID C.gulong
}

var signalWindowEnableDebuggingId int
var signalWindowEnableDebuggingMap = make(map[int]signalWindowEnableDebuggingDetail)
var signalWindowEnableDebuggingLock sync.Mutex

// WindowSignalEnableDebuggingCallback is a callback function for a 'enable-debugging' signal emitted from a Window.
type WindowSignalEnableDebuggingCallback func(toggle bool) bool

/*
ConnectEnableDebugging connects the callback to the 'enable-debugging' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectEnableDebugging to remove it.
*/
func (recv *Window) ConnectEnableDebugging(callback WindowSignalEnableDebuggingCallback) int {
	signalWindowEnableDebuggingLock.Lock()
	defer signalWindowEnableDebuggingLock.Unlock()

	signalWindowEnableDebuggingId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_enable_debugging(instance, C.gpointer(uintptr(signalWindowEnableDebuggingId)))

	detail := signalWindowEnableDebuggingDetail{callback, handlerID}
	signalWindowEnableDebuggingMap[signalWindowEnableDebuggingId] = detail

	return signalWindowEnableDebuggingId
}

/*
DisconnectEnableDebugging disconnects a callback from the 'enable-debugging' signal for the Window.

The connectionID should be a value returned from a call to ConnectEnableDebugging.
*/
func (recv *Window) DisconnectEnableDebugging(connectionID int) {
	signalWindowEnableDebuggingLock.Lock()
	defer signalWindowEnableDebuggingLock.Unlock()

	detail, exists := signalWindowEnableDebuggingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowEnableDebuggingMap, connectionID)
}

//export window_enableDebuggingHandler
func window_enableDebuggingHandler(_ *C.GObject, c_toggle C.gboolean, data C.gpointer) C.gboolean {
	toggle := c_toggle == C.TRUE

	index := int(uintptr(data))
	callback := signalWindowEnableDebuggingMap[index].callback
	retGo := callback(toggle)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWindowKeysChangedDetail struct {
	callback  WindowSignalKeysChangedCallback
	handlerID C.gulong
}

var signalWindowKeysChangedId int
var signalWindowKeysChangedMap = make(map[int]signalWindowKeysChangedDetail)
var signalWindowKeysChangedLock sync.Mutex

// WindowSignalKeysChangedCallback is a callback function for a 'keys-changed' signal emitted from a Window.
type WindowSignalKeysChangedCallback func()

/*
ConnectKeysChanged connects the callback to the 'keys-changed' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectKeysChanged to remove it.
*/
func (recv *Window) ConnectKeysChanged(callback WindowSignalKeysChangedCallback) int {
	signalWindowKeysChangedLock.Lock()
	defer signalWindowKeysChangedLock.Unlock()

	signalWindowKeysChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_keys_changed(instance, C.gpointer(uintptr(signalWindowKeysChangedId)))

	detail := signalWindowKeysChangedDetail{callback, handlerID}
	signalWindowKeysChangedMap[signalWindowKeysChangedId] = detail

	return signalWindowKeysChangedId
}

/*
DisconnectKeysChanged disconnects a callback from the 'keys-changed' signal for the Window.

The connectionID should be a value returned from a call to ConnectKeysChanged.
*/
func (recv *Window) DisconnectKeysChanged(connectionID int) {
	signalWindowKeysChangedLock.Lock()
	defer signalWindowKeysChangedLock.Unlock()

	detail, exists := signalWindowKeysChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowKeysChangedMap, connectionID)
}

//export window_keysChangedHandler
func window_keysChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWindowKeysChangedMap[index].callback
	callback()
}

type signalWindowSetFocusDetail struct {
	callback  WindowSignalSetFocusCallback
	handlerID C.gulong
}

var signalWindowSetFocusId int
var signalWindowSetFocusMap = make(map[int]signalWindowSetFocusDetail)
var signalWindowSetFocusLock sync.Mutex

// WindowSignalSetFocusCallback is a callback function for a 'set-focus' signal emitted from a Window.
type WindowSignalSetFocusCallback func(object *Widget)

/*
ConnectSetFocus connects the callback to the 'set-focus' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectSetFocus to remove it.
*/
func (recv *Window) ConnectSetFocus(callback WindowSignalSetFocusCallback) int {
	signalWindowSetFocusLock.Lock()
	defer signalWindowSetFocusLock.Unlock()

	signalWindowSetFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_set_focus(instance, C.gpointer(uintptr(signalWindowSetFocusId)))

	detail := signalWindowSetFocusDetail{callback, handlerID}
	signalWindowSetFocusMap[signalWindowSetFocusId] = detail

	return signalWindowSetFocusId
}

/*
DisconnectSetFocus disconnects a callback from the 'set-focus' signal for the Window.

The connectionID should be a value returned from a call to ConnectSetFocus.
*/
func (recv *Window) DisconnectSetFocus(connectionID int) {
	signalWindowSetFocusLock.Lock()
	defer signalWindowSetFocusLock.Unlock()

	detail, exists := signalWindowSetFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowSetFocusMap, connectionID)
}

//export window_setFocusHandler
func window_setFocusHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalWindowSetFocusMap[index].callback
	callback(object)
}

// Creates a new #GtkWindow, which is a toplevel window that can
// contain other widgets. Nearly always, the type of the window should
// be #GTK_WINDOW_TOPLEVEL. If youre implementing something like a
// popup menu from scratch (which is a bad idea, just use #GtkMenu),
// you might use #GTK_WINDOW_POPUP. #GTK_WINDOW_POPUP is not for
// dialogs, though in some other toolkits dialogs are called popups.
// In GTK+, #GTK_WINDOW_POPUP means a pop-up menu or pop-up tooltip.
// On X11, popup windows are not controlled by the
// [window manager][gtk-X11-arch].
//
// If you simply want an undecorated window (no window borders), use
// gtk_window_set_decorated(), dont use #GTK_WINDOW_POPUP.
//
// All top-level windows created by gtk_window_new() are stored in
// an internal top-level window list.  This list can be obtained from
// gtk_window_list_toplevels().  Due to Gtk+ keeping a reference to
// the window internally, gtk_window_new() does not return a reference
// to the caller.
//
// To delete a #GtkWindow, call gtk_widget_destroy().
/*

C function : gtk_window_new
*/
func WindowNew(type_ WindowType) *Window {
	c_type := (C.GtkWindowType)(type_)

	retC := C.gtk_window_new(c_type)
	retGo := WindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Activates the default widget for the window, unless the current
// focused widget has been configured to receive the default action
// (see gtk_widget_set_receives_default()), in which case the
// focused widget is activated.
/*

C function : gtk_window_activate_default
*/
func (recv *Window) ActivateDefault() bool {
	retC := C.gtk_window_activate_default((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Activates the current focused widget within the window.
/*

C function : gtk_window_activate_focus
*/
func (recv *Window) ActivateFocus() bool {
	retC := C.gtk_window_activate_focus((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Associate @accel_group with @window, such that calling
// gtk_accel_groups_activate() on @window will activate accelerators
// in @accel_group.
/*

C function : gtk_window_add_accel_group
*/
func (recv *Window) AddAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_window_add_accel_group((*C.GtkWindow)(recv.native), c_accel_group)

	return
}

// Adds a mnemonic to this window.
/*

C function : gtk_window_add_mnemonic
*/
func (recv *Window) AddMnemonic(keyval uint32, target *Widget) {
	c_keyval := (C.guint)(keyval)

	c_target := (*C.GtkWidget)(C.NULL)
	if target != nil {
		c_target = (*C.GtkWidget)(target.ToC())
	}

	C.gtk_window_add_mnemonic((*C.GtkWindow)(recv.native), c_keyval, c_target)

	return
}

// Starts moving a window. This function is used if an application has
// window movement grips. When GDK can support it, the window movement
// will be done using the standard mechanism for the
// [window manager][gtk-X11-arch] or windowing
// system. Otherwise, GDK will try to emulate window movement,
// potentially not all that well, depending on the windowing system.
/*

C function : gtk_window_begin_move_drag
*/
func (recv *Window) BeginMoveDrag(button int32, rootX int32, rootY int32, timestamp uint32) {
	c_button := (C.gint)(button)

	c_root_x := (C.gint)(rootX)

	c_root_y := (C.gint)(rootY)

	c_timestamp := (C.guint32)(timestamp)

	C.gtk_window_begin_move_drag((*C.GtkWindow)(recv.native), c_button, c_root_x, c_root_y, c_timestamp)

	return
}

// Starts resizing a window. This function is used if an application
// has window resizing controls. When GDK can support it, the resize
// will be done using the standard mechanism for the
// [window manager][gtk-X11-arch] or windowing
// system. Otherwise, GDK will try to emulate window resizing,
// potentially not all that well, depending on the windowing system.
/*

C function : gtk_window_begin_resize_drag
*/
func (recv *Window) BeginResizeDrag(edge gdk.WindowEdge, button int32, rootX int32, rootY int32, timestamp uint32) {
	c_edge := (C.GdkWindowEdge)(edge)

	c_button := (C.gint)(button)

	c_root_x := (C.gint)(rootX)

	c_root_y := (C.gint)(rootY)

	c_timestamp := (C.guint32)(timestamp)

	C.gtk_window_begin_resize_drag((*C.GtkWindow)(recv.native), c_edge, c_button, c_root_x, c_root_y, c_timestamp)

	return
}

// Asks to deiconify (i.e. unminimize) the specified @window. Note
// that you shouldnt assume the window is definitely deiconified
// afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch])) could iconify it
// again before your code which assumes deiconification gets to run.
//
// You can track iconification via the window-state-event signal
// on #GtkWidget.
/*

C function : gtk_window_deiconify
*/
func (recv *Window) Deiconify() {
	C.gtk_window_deiconify((*C.GtkWindow)(recv.native))

	return
}

// Returns whether the window has been set to have decorations
// such as a title bar via gtk_window_set_decorated().
/*

C function : gtk_window_get_decorated
*/
func (recv *Window) GetDecorated() bool {
	retC := C.gtk_window_get_decorated((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the default size of the window. A value of -1 for the width or
// height indicates that a default size has not been explicitly set
// for that dimension, so the natural size of the window will be
// used.
/*

C function : gtk_window_get_default_size
*/
func (recv *Window) GetDefaultSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_window_get_default_size((*C.GtkWindow)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// Returns whether the window will be destroyed with its transient parent. See
// gtk_window_set_destroy_with_parent ().
/*

C function : gtk_window_get_destroy_with_parent
*/
func (recv *Window) GetDestroyWithParent() bool {
	retC := C.gtk_window_get_destroy_with_parent((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves the current focused widget within the window.
// Note that this is the widget that would have the focus
// if the toplevel window focused; if the toplevel window
// is not focused then  `gtk_widget_has_focus (widget)` will
// not be %TRUE for the widget.
/*

C function : gtk_window_get_focus
*/
func (recv *Window) GetFocus() *Widget {
	retC := C.gtk_window_get_focus((*C.GtkWindow)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets the value set by gtk_window_set_gravity().
/*

C function : gtk_window_get_gravity
*/
func (recv *Window) GetGravity() gdk.Gravity {
	retC := C.gtk_window_get_gravity((*C.GtkWindow)(recv.native))
	retGo := (gdk.Gravity)(retC)

	return retGo
}

// Gets the value set by gtk_window_set_icon() (or if you've
// called gtk_window_set_icon_list(), gets the first icon in
// the icon list).
/*

C function : gtk_window_get_icon
*/
func (recv *Window) GetIcon() *gdkpixbuf.Pixbuf {
	retC := C.gtk_window_get_icon((*C.GtkWindow)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the list of icons set by gtk_window_set_icon_list().
// The list is copied, but the reference count on each
// member wont be incremented.
/*

C function : gtk_window_get_icon_list
*/
func (recv *Window) GetIconList() *glib.List {
	retC := C.gtk_window_get_icon_list((*C.GtkWindow)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the mnemonic modifier for this window. See
// gtk_window_set_mnemonic_modifier().
/*

C function : gtk_window_get_mnemonic_modifier
*/
func (recv *Window) GetMnemonicModifier() gdk.ModifierType {
	retC := C.gtk_window_get_mnemonic_modifier((*C.GtkWindow)(recv.native))
	retGo := (gdk.ModifierType)(retC)

	return retGo
}

// Returns whether the window is modal. See gtk_window_set_modal().
/*

C function : gtk_window_get_modal
*/
func (recv *Window) GetModal() bool {
	retC := C.gtk_window_get_modal((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// This function returns the position you need to pass to
// gtk_window_move() to keep @window in its current position.
// This means that the meaning of the returned value varies with
// window gravity. See gtk_window_move() for more details.
//
// The reliability of this function depends on the windowing system
// currently in use. Some windowing systems, such as Wayland, do not
// support a global coordinate system, and thus the position of the
// window will always be (0, 0). Others, like X11, do not have a reliable
// way to obtain the geometry of the decorations of a window if they are
// provided by the window manager. Additionally, on X11, window manager
// have been known to mismanage window gravity, which result in windows
// moving even if you use the coordinates of the current position as
// returned by this function.
//
// If you havent changed the window gravity, its gravity will be
// #GDK_GRAVITY_NORTH_WEST. This means that gtk_window_get_position()
// gets the position of the top-left corner of the window manager
// frame for the window. gtk_window_move() sets the position of this
// same top-left corner.
//
// If a window has gravity #GDK_GRAVITY_STATIC the window manager
// frame is not relevant, and thus gtk_window_get_position() will
// always produce accurate results. However you cant use static
// gravity to do things like place a window in a corner of the screen,
// because static gravity ignores the window manager decorations.
//
// Ideally, this function should return appropriate values if the
// window has client side decorations, assuming that the windowing
// system supports global coordinates.
//
// In practice, saving the window position should not be left to
// applications, as they lack enough knowledge of the windowing
// system and the window manager state to effectively do so. The
// appropriate way to implement saving the window position is to
// use a platform-specific protocol, wherever that is available.
/*

C function : gtk_window_get_position
*/
func (recv *Window) GetPosition() (int32, int32) {
	var c_root_x C.gint

	var c_root_y C.gint

	C.gtk_window_get_position((*C.GtkWindow)(recv.native), &c_root_x, &c_root_y)

	rootX := (int32)(c_root_x)

	rootY := (int32)(c_root_y)

	return rootX, rootY
}

// Gets the value set by gtk_window_set_resizable().
/*

C function : gtk_window_get_resizable
*/
func (recv *Window) GetResizable() bool {
	retC := C.gtk_window_get_resizable((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the role of the window. See gtk_window_set_role() for
// further explanation.
/*

C function : gtk_window_get_role
*/
func (recv *Window) GetRole() string {
	retC := C.gtk_window_get_role((*C.GtkWindow)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Obtains the current size of @window.
//
// If @window is not visible on screen, this function return the size GTK+
// will suggest to the [window manager][gtk-X11-arch] for the initial window
// size (but this is not reliably the same as the size the window manager
// will actually select). See: gtk_window_set_default_size().
//
// Depending on the windowing system and the window manager constraints,
// the size returned by this function may not match the size set using
// gtk_window_resize(); additionally, since gtk_window_resize() may be
// implemented as an asynchronous operation, GTK+ cannot guarantee in any
// way that this code:
//
// |[<!-- language="C" -->
// width and height are set elsewhere
// gtk_window_resize (window, width, height);
//
// int new_width, new_height;
// gtk_window_get_size (window, &new_width, &new_height);
// ]|
//
// will result in `new_width` and `new_height` matching `width` and
// `height`, respectively.
//
// This function will return the logical size of the #GtkWindow,
// excluding the widgets used in client side decorations; there is,
// however, no guarantee that the result will be completely accurate
// because client side decoration may include widgets that depend on
// the user preferences and that may not be visibile at the time you
// call this function.
//
// The dimensions returned by this function are suitable for being
// stored across sessions; use gtk_window_set_default_size() to
// restore them when before showing the window.
//
// To avoid potential race conditions, you should only call this
// function in response to a size change notification, for instance
// inside a handler for the #GtkWidget::size-allocate signal, or
// inside a handler for the #GtkWidget::configure-event signal:
//
// |[<!-- language="C" -->
// static void
// on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
// {
// int new_width, new_height;
//
// gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
//
// ...
// }
// ]|
//
// Note that, if you connect to the #GtkWidget::size-allocate signal,
// you should not use the dimensions of the #GtkAllocation passed to
// the signal handler, as the allocation may contain client side
// decorations added by GTK+, depending on the windowing system in
// use.
//
// If you are getting a window size in order to position the window
// on the screen, you should, instead, simply set the windows semantic
// type with gtk_window_set_type_hint(), which allows the window manager
// to e.g. center dialogs. Also, if you set the transient parent of
// dialogs with gtk_window_set_transient_for() window managers will
// often center the dialog over its parent window. It's much preferred
// to let the window manager handle these cases rather than doing it
// yourself, because all apps will behave consistently and according to
// user or system preferences, if the window manager handles it. Also,
// the window manager can take into account the size of the window
// decorations and border that it may add, and of which GTK+ has no
// knowledge. Additionally, positioning windows in global screen coordinates
// may not be allowed by the windowing system. For more information,
// see: gtk_window_set_position().
/*

C function : gtk_window_get_size
*/
func (recv *Window) GetSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_window_get_size((*C.GtkWindow)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// Retrieves the title of the window. See gtk_window_set_title().
/*

C function : gtk_window_get_title
*/
func (recv *Window) GetTitle() string {
	retC := C.gtk_window_get_title((*C.GtkWindow)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Fetches the transient parent for this window. See
// gtk_window_set_transient_for().
/*

C function : gtk_window_get_transient_for
*/
func (recv *Window) GetTransientFor() *Window {
	retC := C.gtk_window_get_transient_for((*C.GtkWindow)(recv.native))
	var retGo (*Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets the type hint for this window. See gtk_window_set_type_hint().
/*

C function : gtk_window_get_type_hint
*/
func (recv *Window) GetTypeHint() gdk.WindowTypeHint {
	retC := C.gtk_window_get_type_hint((*C.GtkWindow)(recv.native))
	retGo := (gdk.WindowTypeHint)(retC)

	return retGo
}

// Returns whether @window has an explicit window group.
/*

C function : gtk_window_has_group
*/
func (recv *Window) HasGroup() bool {
	retC := C.gtk_window_has_group((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Asks to iconify (i.e. minimize) the specified @window. Note that
// you shouldnt assume the window is definitely iconified afterward,
// because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could deiconify it
// again, or there may not be a window manager in which case
// iconification isnt possible, etc. But normally the window will end
// up iconified. Just dont write code that crashes if not.
//
// Its permitted to call this function before showing a window,
// in which case the window will be iconified before it ever appears
// onscreen.
//
// You can track iconification via the window-state-event signal
// on #GtkWidget.
/*

C function : gtk_window_iconify
*/
func (recv *Window) Iconify() {
	C.gtk_window_iconify((*C.GtkWindow)(recv.native))

	return
}

// Asks to maximize @window, so that it becomes full-screen. Note that
// you shouldnt assume the window is definitely maximized afterward,
// because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could unmaximize it
// again, and not all window managers support maximization. But
// normally the window will end up maximized. Just dont write code
// that crashes if not.
//
// Its permitted to call this function before showing a window,
// in which case the window will be maximized when it appears onscreen
// initially.
//
// You can track maximization via the window-state-event signal
// on #GtkWidget, or by listening to notifications on the
// #GtkWindow:is-maximized property.
/*

C function : gtk_window_maximize
*/
func (recv *Window) Maximize() {
	C.gtk_window_maximize((*C.GtkWindow)(recv.native))

	return
}

// Activates the targets associated with the mnemonic.
/*

C function : gtk_window_mnemonic_activate
*/
func (recv *Window) MnemonicActivate(keyval uint32, modifier gdk.ModifierType) bool {
	c_keyval := (C.guint)(keyval)

	c_modifier := (C.GdkModifierType)(modifier)

	retC := C.gtk_window_mnemonic_activate((*C.GtkWindow)(recv.native), c_keyval, c_modifier)
	retGo := retC == C.TRUE

	return retGo
}

// Asks the [window manager][gtk-X11-arch] to move
// @window to the given position.  Window managers are free to ignore
// this; most window managers ignore requests for initial window
// positions (instead using a user-defined placement algorithm) and
// honor requests after the window has already been shown.
//
// Note: the position is the position of the gravity-determined
// reference point for the window. The gravity determines two things:
// first, the location of the reference point in root window
// coordinates; and second, which point on the window is positioned at
// the reference point.
//
// By default the gravity is #GDK_GRAVITY_NORTH_WEST, so the reference
// point is simply the @x, @y supplied to gtk_window_move(). The
// top-left corner of the window decorations (aka window frame or
// border) will be placed at @x, @y.  Therefore, to position a window
// at the top left of the screen, you want to use the default gravity
// (which is #GDK_GRAVITY_NORTH_WEST) and move the window to 0,0.
//
// To position a window at the bottom right corner of the screen, you
// would set #GDK_GRAVITY_SOUTH_EAST, which means that the reference
// point is at @x + the window width and @y + the window height, and
// the bottom-right corner of the window border will be placed at that
// reference point. So, to place a window in the bottom right corner
// you would first set gravity to south east, then write:
// `gtk_window_move (window, gdk_screen_width () - window_width,
// gdk_screen_height () - window_height)` (note that this
// example does not take multi-head scenarios into account).
//
// The [Extended Window Manager Hints Specification](http://www.freedesktop.org/Standards/wm-spec)
// has a nice table of gravities in the implementation notes section.
//
// The gtk_window_get_position() documentation may also be relevant.
/*

C function : gtk_window_move
*/
func (recv *Window) Move(x int32, y int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_window_move((*C.GtkWindow)(recv.native), c_x, c_y)

	return
}

// Parses a standard X Window System geometry string - see the
// manual page for X (type man X) for details on this.
// gtk_window_parse_geometry() does work on all GTK+ ports
// including Win32 but is primarily intended for an X environment.
//
// If either a size or a position can be extracted from the
// geometry string, gtk_window_parse_geometry() returns %TRUE
// and calls gtk_window_set_default_size() and/or gtk_window_move()
// to resize/move the window.
//
// If gtk_window_parse_geometry() returns %TRUE, it will also
// set the #GDK_HINT_USER_POS and/or #GDK_HINT_USER_SIZE hints
// indicating to the window manager that the size/position of
// the window was user-specified. This causes most window
// managers to honor the geometry.
//
// Note that for gtk_window_parse_geometry() to work as expected, it has
// to be called when the window has its final size, i.e. after calling
// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints()
// on the window.
// |[<!-- language="C" -->
// #include <gtk/gtk.h>
//
// static void
// fill_with_content (GtkWidget *vbox)
// {
// fill with content...
// }
//
// int
// main (int argc, char *argv[])
// {
// GtkWidget *window, *vbox;
// GdkGeometry size_hints = {
// 100, 50, 0, 0, 100, 50, 10,
// 10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
// };
//
// gtk_init (&argc, &argv);
//
// window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
// vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
//
// gtk_container_add (GTK_CONTAINER (window), vbox);
// fill_with_content (vbox);
// gtk_widget_show_all (vbox);
//
// gtk_window_set_geometry_hints (GTK_WINDOW (window),
// NULL,
// &size_hints,
// GDK_HINT_MIN_SIZE |
// GDK_HINT_BASE_SIZE |
// GDK_HINT_RESIZE_INC);
//
// if (argc > 1)
// {
// gboolean res;
// res = gtk_window_parse_geometry (GTK_WINDOW (window),
// argv[1]);
// if (! res)
// fprintf (stderr,
// "Failed to parse %s\n",
// argv[1]);
// }
//
// gtk_widget_show_all (window);
// gtk_main ();
//
// return 0;
// }
// ]|
/*

C function : gtk_window_parse_geometry
*/
func (recv *Window) ParseGeometry(geometry string) bool {
	c_geometry := C.CString(geometry)
	defer C.free(unsafe.Pointer(c_geometry))

	retC := C.gtk_window_parse_geometry((*C.GtkWindow)(recv.native), c_geometry)
	retGo := retC == C.TRUE

	return retGo
}

// Presents a window to the user. This may mean raising the window
// in the stacking order, deiconifying it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent
// on the users platform, window manager, and preferences.
//
// If @window is hidden, this function calls gtk_widget_show()
// as well.
//
// This function should be used when the user tries to open a window
// thats already open. Say for example the preferences dialog is
// currently open, and the user chooses Preferences from the menu
// a second time; use gtk_window_present() to move the already-open dialog
// where the user can see it.
//
// If you are calling this function in response to a user interaction,
// it is preferable to use gtk_window_present_with_time().
/*

C function : gtk_window_present
*/
func (recv *Window) Present() {
	C.gtk_window_present((*C.GtkWindow)(recv.native))

	return
}

// Reverses the effects of gtk_window_add_accel_group().
/*

C function : gtk_window_remove_accel_group
*/
func (recv *Window) RemoveAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_window_remove_accel_group((*C.GtkWindow)(recv.native), c_accel_group)

	return
}

// Removes a mnemonic from this window.
/*

C function : gtk_window_remove_mnemonic
*/
func (recv *Window) RemoveMnemonic(keyval uint32, target *Widget) {
	c_keyval := (C.guint)(keyval)

	c_target := (*C.GtkWidget)(C.NULL)
	if target != nil {
		c_target = (*C.GtkWidget)(target.ToC())
	}

	C.gtk_window_remove_mnemonic((*C.GtkWindow)(recv.native), c_keyval, c_target)

	return
}

// Hides @window, then reshows it, resetting the
// default size and position of the window. Used
// by GUI builders only.
/*

C function : gtk_window_reshow_with_initial_size
*/
func (recv *Window) ReshowWithInitialSize() {
	C.gtk_window_reshow_with_initial_size((*C.GtkWindow)(recv.native))

	return
}

// Resizes the window as if the user had done so, obeying geometry
// constraints. The default geometry constraint is that windows may
// not be smaller than their size request; to override this
// constraint, call gtk_widget_set_size_request() to set the window's
// request to a smaller value.
//
// If gtk_window_resize() is called before showing a window for the
// first time, it overrides any default size set with
// gtk_window_set_default_size().
//
// Windows may not be resized smaller than 1 by 1 pixels.
//
// When using client side decorations, GTK+ will do its best to adjust
// the given size so that the resulting window size matches the
// requested size without the title bar, borders and shadows added for
// the client side decorations, but there is no guarantee that the
// result will be totally accurate because these widgets added for
// client side decorations depend on the theme and may not be realized
// or visible at the time gtk_window_resize() is issued.
//
// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()), then
// typically, gtk_window_resize() will compensate for the height of the titlebar
// widget only if the height is known when the resulting GtkWindow configuration
// is issued.
// For example, if new widgets are added after the GtkWindow configuration
// and cause the titlebar widget to grow in height, this will result in a
// window content smaller that specified by gtk_window_resize() and not
// a larger window.
/*

C function : gtk_window_resize
*/
func (recv *Window) Resize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_window_resize((*C.GtkWindow)(recv.native), c_width, c_height)

	return
}

// By default, windows are decorated with a title bar, resize
// controls, etc.  Some [window managers][gtk-X11-arch]
// allow GTK+ to disable these decorations, creating a
// borderless window. If you set the decorated property to %FALSE
// using this function, GTK+ will do its best to convince the window
// manager not to decorate the window. Depending on the system, this
// function may not have any effect when called on a window that is
// already visible, so you should call it before calling gtk_widget_show().
//
// On Windows, this function always works, since theres no window manager
// policy involved.
/*

C function : gtk_window_set_decorated
*/
func (recv *Window) SetDecorated(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_decorated((*C.GtkWindow)(recv.native), c_setting)

	return
}

// The default widget is the widget thats activated when the user
// presses Enter in a dialog (for example). This function sets or
// unsets the default widget for a #GtkWindow. When setting (rather
// than unsetting) the default widget its generally easier to call
// gtk_widget_grab_default() on the widget. Before making a widget
// the default widget, you must call gtk_widget_set_can_default() on
// the widget youd like to make the default.
/*

C function : gtk_window_set_default
*/
func (recv *Window) SetDefault(defaultWidget *Widget) {
	c_default_widget := (*C.GtkWidget)(C.NULL)
	if defaultWidget != nil {
		c_default_widget = (*C.GtkWidget)(defaultWidget.ToC())
	}

	C.gtk_window_set_default((*C.GtkWindow)(recv.native), c_default_widget)

	return
}

// Sets the default size of a window. If the windows natural size
// (its size request) is larger than the default, the default will be
// ignored. More generally, if the default size does not obey the
// geometry hints for the window (gtk_window_set_geometry_hints() can
// be used to set these explicitly), the default size will be clamped
// to the nearest permitted size.
//
// Unlike gtk_widget_set_size_request(), which sets a size request for
// a widget and thus would keep users from shrinking the window, this
// function only sets the initial size, just as if the user had
// resized the window themselves. Users can still shrink the window
// again as they normally would. Setting a default size of -1 means to
// use the natural default size (the size request of the window).
//
// For more control over a windows initial size and how resizing works,
// investigate gtk_window_set_geometry_hints().
//
// For some uses, gtk_window_resize() is a more appropriate function.
// gtk_window_resize() changes the current size of the window, rather
// than the size to be used on initial display. gtk_window_resize() always
// affects the window itself, not the geometry widget.
//
// The default size of a window only affects the first time a window is
// shown; if a window is hidden and re-shown, it will remember the size
// it had prior to hiding, rather than using the default size.
//
// Windows cant actually be 0x0 in size, they must be at least 1x1, but
// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size,
// note that the appropriate size to save is the one returned by
// gtk_window_get_size(). Using the window allocation directly will not
// work in all circumstances and can lead to growing or shrinking windows.
/*

C function : gtk_window_set_default_size
*/
func (recv *Window) SetDefaultSize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_window_set_default_size((*C.GtkWindow)(recv.native), c_width, c_height)

	return
}

// If @setting is %TRUE, then destroying the transient parent of @window
// will also destroy @window itself. This is useful for dialogs that
// shouldnt persist beyond the lifetime of the main window they're
// associated with, for example.
/*

C function : gtk_window_set_destroy_with_parent
*/
func (recv *Window) SetDestroyWithParent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_destroy_with_parent((*C.GtkWindow)(recv.native), c_setting)

	return
}

// If @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the window. If @focus is %NULL, unsets
// the focus widget for this window. To set the focus to a particular
// widget in the toplevel, it is usually more convenient to use
// gtk_widget_grab_focus() instead of this function.
/*

C function : gtk_window_set_focus
*/
func (recv *Window) SetFocus(focus *Widget) {
	c_focus := (*C.GtkWidget)(C.NULL)
	if focus != nil {
		c_focus = (*C.GtkWidget)(focus.ToC())
	}

	C.gtk_window_set_focus((*C.GtkWindow)(recv.native), c_focus)

	return
}

// This function sets up hints about how a window can be resized by
// the user.  You can set a minimum and maximum size; allowed resize
// increments (e.g. for xterm, you can only resize by the size of a
// character); aspect ratios; and more. See the #GdkGeometry struct.
/*

C function : gtk_window_set_geometry_hints
*/
func (recv *Window) SetGeometryHints(geometryWidget *Widget, geometry *gdk.Geometry, geomMask gdk.WindowHints) {
	c_geometry_widget := (*C.GtkWidget)(C.NULL)
	if geometryWidget != nil {
		c_geometry_widget = (*C.GtkWidget)(geometryWidget.ToC())
	}

	c_geometry := (*C.GdkGeometry)(C.NULL)
	if geometry != nil {
		c_geometry = (*C.GdkGeometry)(geometry.ToC())
	}

	c_geom_mask := (C.GdkWindowHints)(geomMask)

	C.gtk_window_set_geometry_hints((*C.GtkWindow)(recv.native), c_geometry_widget, c_geometry, c_geom_mask)

	return
}

// Window gravity defines the meaning of coordinates passed to
// gtk_window_move(). See gtk_window_move() and #GdkGravity for
// more details.
//
// The default window gravity is #GDK_GRAVITY_NORTH_WEST which will
// typically do what you mean.
/*

C function : gtk_window_set_gravity
*/
func (recv *Window) SetGravity(gravity gdk.Gravity) {
	c_gravity := (C.GdkGravity)(gravity)

	C.gtk_window_set_gravity((*C.GtkWindow)(recv.native), c_gravity)

	return
}

// Sets up the icon representing a #GtkWindow. This icon is used when
// the window is minimized (also known as iconified).  Some window
// managers or desktop environments may also place it in the window
// frame, or display it in other contexts. On others, the icon is not
// used at all, so your mileage may vary.
//
// The icon should be provided in whatever size it was naturally
// drawn; that is, dont scale the image before passing it to
// GTK+. Scaling is postponed until the last minute, when the desired
// final size is known, to allow best quality.
//
// If you have your icon hand-drawn in multiple sizes, use
// gtk_window_set_icon_list(). Then the best size will be used.
//
// This function is equivalent to calling gtk_window_set_icon_list()
// with a 1-element list.
//
// See also gtk_window_set_default_icon_list() to set the icon
// for all windows in your application in one go.
/*

C function : gtk_window_set_icon
*/
func (recv *Window) SetIcon(icon *gdkpixbuf.Pixbuf) {
	c_icon := (*C.GdkPixbuf)(C.NULL)
	if icon != nil {
		c_icon = (*C.GdkPixbuf)(icon.ToC())
	}

	C.gtk_window_set_icon((*C.GtkWindow)(recv.native), c_icon)

	return
}

// Sets up the icon representing a #GtkWindow. The icon is used when
// the window is minimized (also known as iconified).  Some window
// managers or desktop environments may also place it in the window
// frame, or display it in other contexts. On others, the icon is not
// used at all, so your mileage may vary.
//
// gtk_window_set_icon_list() allows you to pass in the same icon in
// several hand-drawn sizes. The list should contain the natural sizes
// your icon is available in; that is, dont scale the image before
// passing it to GTK+. Scaling is postponed until the last minute,
// when the desired final size is known, to allow best quality.
//
// By passing several sizes, you may improve the final image quality
// of the icon, by reducing or eliminating automatic image scaling.
//
// Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and
// larger images (64x64, 128x128) if you have them.
//
// See also gtk_window_set_default_icon_list() to set the icon
// for all windows in your application in one go.
//
// Note that transient windows (those who have been set transient for another
// window using gtk_window_set_transient_for()) will inherit their
// icon from their transient parent. So theres no need to explicitly
// set the icon on transient windows.
/*

C function : gtk_window_set_icon_list
*/
func (recv *Window) SetIconList(list *glib.List) {
	c_list := (*C.GList)(C.NULL)
	if list != nil {
		c_list = (*C.GList)(list.ToC())
	}

	C.gtk_window_set_icon_list((*C.GtkWindow)(recv.native), c_list)

	return
}

// Sets the mnemonic modifier for this window.
/*

C function : gtk_window_set_mnemonic_modifier
*/
func (recv *Window) SetMnemonicModifier(modifier gdk.ModifierType) {
	c_modifier := (C.GdkModifierType)(modifier)

	C.gtk_window_set_mnemonic_modifier((*C.GtkWindow)(recv.native), c_modifier)

	return
}

// Sets a window modal or non-modal. Modal windows prevent interaction
// with other windows in the same application. To keep modal dialogs
// on top of main application windows, use
// gtk_window_set_transient_for() to make the dialog transient for the
// parent; most [window managers][gtk-X11-arch]
// will then disallow lowering the dialog below the parent.
/*

C function : gtk_window_set_modal
*/
func (recv *Window) SetModal(modal bool) {
	c_modal :=
		boolToGboolean(modal)

	C.gtk_window_set_modal((*C.GtkWindow)(recv.native), c_modal)

	return
}

// Sets a position constraint for this window. If the old or new
// constraint is %GTK_WIN_POS_CENTER_ALWAYS, this will also cause
// the window to be repositioned to satisfy the new constraint.
/*

C function : gtk_window_set_position
*/
func (recv *Window) SetPosition(position WindowPosition) {
	c_position := (C.GtkWindowPosition)(position)

	C.gtk_window_set_position((*C.GtkWindow)(recv.native), c_position)

	return
}

// Sets whether the user can resize a window. Windows are user resizable
// by default.
/*

C function : gtk_window_set_resizable
*/
func (recv *Window) SetResizable(resizable bool) {
	c_resizable :=
		boolToGboolean(resizable)

	C.gtk_window_set_resizable((*C.GtkWindow)(recv.native), c_resizable)

	return
}

// This function is only useful on X11, not with other GTK+ targets.
//
// In combination with the window title, the window role allows a
// [window manager][gtk-X11-arch] to identify "the
// same" window when an application is restarted. So for example you
// might set the toolbox role on your apps toolbox window, so that
// when the user restarts their session, the window manager can put
// the toolbox back in the same place.
//
// If a window already has a unique title, you dont need to set the
// role, since the WM can use the title to identify the window when
// restoring the session.
/*

C function : gtk_window_set_role
*/
func (recv *Window) SetRole(role string) {
	c_role := C.CString(role)
	defer C.free(unsafe.Pointer(c_role))

	C.gtk_window_set_role((*C.GtkWindow)(recv.native), c_role)

	return
}

// Sets the title of the #GtkWindow. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar
// is rendered by the [window manager][gtk-X11-arch],
// so exactly how the title appears to users may vary
// according to a users exact configuration. The title should help a
// user distinguish this window from other windows they may have
// open. A good title might include the application name and current
// document filename, for example.
/*

C function : gtk_window_set_title
*/
func (recv *Window) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_window_set_title((*C.GtkWindow)(recv.native), c_title)

	return
}

// Dialog windows should be set transient for the main application
// window they were spawned from. This allows
// [window managers][gtk-X11-arch] to e.g. keep the
// dialog on top of the main window, or center the dialog over the
// main window. gtk_dialog_new_with_buttons() and other convenience
// functions in GTK+ will sometimes call
// gtk_window_set_transient_for() on your behalf.
//
// Passing %NULL for @parent unsets the current transient window.
//
// On Wayland, this function can also be used to attach a new
// #GTK_WINDOW_POPUP to a #GTK_WINDOW_TOPLEVEL parent already mapped
// on screen so that the #GTK_WINDOW_POPUP will be created as a
// subsurface-based window #GDK_WINDOW_SUBSURFACE which can be
// positioned at will relatively to the #GTK_WINDOW_TOPLEVEL surface.
//
// On Windows, this function puts the child window on top of the parent,
// much as the window manager would have done on X.
/*

C function : gtk_window_set_transient_for
*/
func (recv *Window) SetTransientFor(parent *Window) {
	c_parent := (*C.GtkWindow)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWindow)(parent.ToC())
	}

	C.gtk_window_set_transient_for((*C.GtkWindow)(recv.native), c_parent)

	return
}

// By setting the type hint for the window, you allow the window
// manager to decorate and handle the window in a way which is
// suitable to the function of the window in your application.
//
// This function should be called before the window becomes visible.
//
// gtk_dialog_new_with_buttons() and other convenience functions in GTK+
// will sometimes call gtk_window_set_type_hint() on your behalf.
/*

C function : gtk_window_set_type_hint
*/
func (recv *Window) SetTypeHint(hint gdk.WindowTypeHint) {
	c_hint := (C.GdkWindowTypeHint)(hint)

	C.gtk_window_set_type_hint((*C.GtkWindow)(recv.native), c_hint)

	return
}

// Dont use this function. It sets the X Window System class and
// name hints for a window.  According to the ICCCM, you should
// always set these to the same value for all windows in an
// application, and GTK+ sets them to that value by default, so calling
// this function is sort of pointless. However, you may want to call
// gtk_window_set_role() on each window in your application, for the
// benefit of the session manager. Setting the role allows the window
// manager to restore window positions when loading a saved session.
/*

C function : gtk_window_set_wmclass
*/
func (recv *Window) SetWmclass(wmclassName string, wmclassClass string) {
	c_wmclass_name := C.CString(wmclassName)
	defer C.free(unsafe.Pointer(c_wmclass_name))

	c_wmclass_class := C.CString(wmclassClass)
	defer C.free(unsafe.Pointer(c_wmclass_class))

	C.gtk_window_set_wmclass((*C.GtkWindow)(recv.native), c_wmclass_name, c_wmclass_class)

	return
}

// Asks to stick @window, which means that it will appear on all user
// desktops. Note that you shouldnt assume the window is definitely
// stuck afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch] could unstick it
// again, and some window managers do not support sticking
// windows. But normally the window will end up stuck. Just don't
// write code that crashes if not.
//
// Its permitted to call this function before showing a window.
//
// You can track stickiness via the window-state-event signal
// on #GtkWidget.
/*

C function : gtk_window_stick
*/
func (recv *Window) Stick() {
	C.gtk_window_stick((*C.GtkWindow)(recv.native))

	return
}

// Asks to unmaximize @window. Note that you shouldnt assume the
// window is definitely unmaximized afterward, because other entities
// (e.g. the user or [window manager][gtk-X11-arch])
// could maximize it again, and not all window
// managers honor requests to unmaximize. But normally the window will
// end up unmaximized. Just dont write code that crashes if not.
//
// You can track maximization via the window-state-event signal
// on #GtkWidget.
/*

C function : gtk_window_unmaximize
*/
func (recv *Window) Unmaximize() {
	C.gtk_window_unmaximize((*C.GtkWindow)(recv.native))

	return
}

// Asks to unstick @window, which means that it will appear on only
// one of the users desktops. Note that you shouldnt assume the
// window is definitely unstuck afterward, because other entities
// (e.g. the user or [window manager][gtk-X11-arch]) could
// stick it again. But normally the window will
// end up stuck. Just dont write code that crashes if not.
//
// You can track stickiness via the window-state-event signal
// on #GtkWidget.
/*

C function : gtk_window_unstick
*/
func (recv *Window) Unstick() {
	C.gtk_window_unstick((*C.GtkWindow)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Window
func (recv *Window) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Window
func (recv *Window) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

/*

C record/class : GtkWindowAccessible
*/
type WindowAccessible struct {
	native *C.GtkWindowAccessible
	// parent : record
	// priv : record
}

func WindowAccessibleNewFromC(u unsafe.Pointer) *WindowAccessible {
	c := (*C.GtkWindowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &WindowAccessible{native: c}

	return g
}

func (recv *WindowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *WindowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *WindowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *WindowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *WindowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to WindowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a WindowAccessible.
func CastToWindowAccessible(object *gobject.Object) *WindowAccessible {
	return WindowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by WindowAccessible
func (recv *WindowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Window returns the Window interface implemented by WindowAccessible
func (recv *WindowAccessible) Window() *atk.Window {
	return atk.WindowNewFromC(recv.ToC())
}

// A #GtkWindowGroup restricts the effect of grabs to windows
// in the same group, thereby making window groups almost behave
// like separate applications.
//
// A window can be a member in at most one window group at a time.
// Windows that have not been explicitly assigned to a group are
// implicitly treated like windows of the default window group.
//
// GtkWindowGroup objects are referenced by each window in the group,
// so once you have added all windows to a GtkWindowGroup, you can drop
// the initial reference to the window group with g_object_unref(). If the
// windows in the window group are subsequently destroyed, then they will
// be removed from the window group and drop their references on the window
// group; when all window have been removed, the window group will be
// freed.
/*

C record/class : GtkWindowGroup
*/
type WindowGroup struct {
	native *C.GtkWindowGroup
	// parent_instance : record
	// priv : record
}

func WindowGroupNewFromC(u unsafe.Pointer) *WindowGroup {
	c := (*C.GtkWindowGroup)(u)
	if c == nil {
		return nil
	}

	g := &WindowGroup{native: c}

	return g
}

func (recv *WindowGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *WindowGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to WindowGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a WindowGroup.
func CastToWindowGroup(object *gobject.Object) *WindowGroup {
	return WindowGroupNewFromC(object.ToC())
}

// Creates a new #GtkWindowGroup object. Grabs added with
// gtk_grab_add() only affect windows within the same #GtkWindowGroup.
/*

C function : gtk_window_group_new
*/
func WindowGroupNew() *WindowGroup {
	retC := C.gtk_window_group_new()
	retGo := WindowGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a window to a #GtkWindowGroup.
/*

C function : gtk_window_group_add_window
*/
func (recv *WindowGroup) AddWindow(window *Window) {
	c_window := (*C.GtkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GtkWindow)(window.ToC())
	}

	C.gtk_window_group_add_window((*C.GtkWindowGroup)(recv.native), c_window)

	return
}

// Removes a window from a #GtkWindowGroup.
/*

C function : gtk_window_group_remove_window
*/
func (recv *WindowGroup) RemoveWindow(window *Window) {
	c_window := (*C.GtkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GtkWindow)(window.ToC())
	}

	C.gtk_window_group_remove_window((*C.GtkWindowGroup)(recv.native), c_window)

	return
}
