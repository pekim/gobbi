// This is a generated file - DO NOT EDIT

package gtk

import (
	atk "github.com/pekim/gobbi/lib/atk"
	gdk "github.com/pekim/gobbi/lib/gdk"
	gdkpixbuf "github.com/pekim/gobbi/lib/gdkpixbuf"
	gio "github.com/pekim/gobbi/lib/gio"
	glib "github.com/pekim/gobbi/lib/glib"
	gobject "github.com/pekim/gobbi/lib/gobject"
	"runtime"
	"sync"
	"unsafe"
)

// #cgo CFLAGS: -Wno-deprecated-declarations
// #cgo CFLAGS: -Wno-format-security
// #cgo CFLAGS: -Wno-incompatible-pointer-types
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// #include <stdlib.h>
/*

	gboolean accelgroup_accelActivateHandler(GObject *, GObject *, guint, guint, gpointer);

	static gulong AccelGroup_signal_connect_accel_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-activate", G_CALLBACK(accelgroup_accelActivateHandler), data);
	}

*/
/*

	void accelgroup_accelChangedHandler(GObject *, guint, guint, GClosure *, gpointer);

	static gulong AccelGroup_signal_connect_accel_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-changed", G_CALLBACK(accelgroup_accelChangedHandler), data);
	}

*/
/*

	void adjustment_changedHandler(GObject *, gpointer);

	static gulong Adjustment_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(adjustment_changedHandler), data);
	}

*/
/*

	void adjustment_valueChangedHandler(GObject *, gpointer);

	static gulong Adjustment_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(adjustment_valueChangedHandler), data);
	}

*/
/*

	void appchooserbutton_customItemActivatedHandler(GObject *, gchar*, gpointer);

	static gulong AppChooserButton_signal_connect_custom_item_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "custom-item-activated", G_CALLBACK(appchooserbutton_customItemActivatedHandler), data);
	}

*/
/*

	void appchooserwidget_applicationActivatedHandler(GObject *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_application_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "application-activated", G_CALLBACK(appchooserwidget_applicationActivatedHandler), data);
	}

*/
/*

	void appchooserwidget_applicationSelectedHandler(GObject *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_application_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "application-selected", G_CALLBACK(appchooserwidget_applicationSelectedHandler), data);
	}

*/
/*

	void appchooserwidget_populatePopupHandler(GObject *, GtkMenu *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(appchooserwidget_populatePopupHandler), data);
	}

*/
/*

	void assistant_escapeHandler(GObject *, gpointer);

	static gulong Assistant_signal_connect_escape(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "escape", G_CALLBACK(assistant_escapeHandler), data);
	}

*/
/*

	void button_activateHandler(GObject *, gpointer);

	static gulong Button_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(button_activateHandler), data);
	}

*/
/*

	void button_clickedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(button_clickedHandler), data);
	}

*/
/*

	void button_enterHandler(GObject *, gpointer);

	static gulong Button_signal_connect_enter(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enter", G_CALLBACK(button_enterHandler), data);
	}

*/
/*

	void button_leaveHandler(GObject *, gpointer);

	static gulong Button_signal_connect_leave(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "leave", G_CALLBACK(button_leaveHandler), data);
	}

*/
/*

	void button_pressedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_pressed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "pressed", G_CALLBACK(button_pressedHandler), data);
	}

*/
/*

	void button_releasedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_released(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "released", G_CALLBACK(button_releasedHandler), data);
	}

*/
/*

	void calendar_daySelectedHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_day_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "day-selected", G_CALLBACK(calendar_daySelectedHandler), data);
	}

*/
/*

	void calendar_daySelectedDoubleClickHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_day_selected_double_click(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "day-selected-double-click", G_CALLBACK(calendar_daySelectedDoubleClickHandler), data);
	}

*/
/*

	void calendar_monthChangedHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_month_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "month-changed", G_CALLBACK(calendar_monthChangedHandler), data);
	}

*/
/*

	void calendar_nextMonthHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_next_month(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "next-month", G_CALLBACK(calendar_nextMonthHandler), data);
	}

*/
/*

	void calendar_nextYearHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_next_year(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "next-year", G_CALLBACK(calendar_nextYearHandler), data);
	}

*/
/*

	void calendar_prevMonthHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_prev_month(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prev-month", G_CALLBACK(calendar_prevMonthHandler), data);
	}

*/
/*

	void calendar_prevYearHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_prev_year(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prev-year", G_CALLBACK(calendar_prevYearHandler), data);
	}

*/
/*

	void cellrenderertext_editedHandler(GObject *, gchar*, gchar*, gpointer);

	static gulong CellRendererText_signal_connect_edited(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "edited", G_CALLBACK(cellrenderertext_editedHandler), data);
	}

*/
/*

	void cellrenderertoggle_toggledHandler(GObject *, gchar*, gpointer);

	static gulong CellRendererToggle_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(cellrenderertoggle_toggledHandler), data);
	}

*/
/*

	void checkmenuitem_toggledHandler(GObject *, gpointer);

	static gulong CheckMenuItem_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(checkmenuitem_toggledHandler), data);
	}

*/
/*

	void colorselection_colorChangedHandler(GObject *, gpointer);

	static gulong ColorSelection_signal_connect_color_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "color-changed", G_CALLBACK(colorselection_colorChangedHandler), data);
	}

*/
/*

	void container_addHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_add(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "add", G_CALLBACK(container_addHandler), data);
	}

*/
/*

	void container_checkResizeHandler(GObject *, gpointer);

	static gulong Container_signal_connect_check_resize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "check-resize", G_CALLBACK(container_checkResizeHandler), data);
	}

*/
/*

	void container_removeHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_remove(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove", G_CALLBACK(container_removeHandler), data);
	}

*/
/*

	void container_setFocusChildHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_set_focus_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-focus-child", G_CALLBACK(container_setFocusChildHandler), data);
	}

*/
/*

	void cssprovider_parsingErrorHandler(GObject *, GtkCssSection *, GError *, gpointer);

	static gulong CssProvider_signal_connect_parsing_error(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "parsing-error", G_CALLBACK(cssprovider_parsingErrorHandler), data);
	}

*/
/*

	void dialog_closeHandler(GObject *, gpointer);

	static gulong Dialog_signal_connect_close(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "close", G_CALLBACK(dialog_closeHandler), data);
	}

*/
/*

	void dialog_responseHandler(GObject *, gint, gpointer);

	static gulong Dialog_signal_connect_response(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "response", G_CALLBACK(dialog_responseHandler), data);
	}

*/
/*

	void entry_activateHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(entry_activateHandler), data);
	}

*/
/*

	void entry_backspaceHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_backspace(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "backspace", G_CALLBACK(entry_backspaceHandler), data);
	}

*/
/*

	void entry_copyClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(entry_copyClipboardHandler), data);
	}

*/
/*

	void entry_cutClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_cut_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cut-clipboard", G_CALLBACK(entry_cutClipboardHandler), data);
	}

*/
/*

	void entry_deleteFromCursorHandler(GObject *, GtkDeleteType, gint, gpointer);

	static gulong Entry_signal_connect_delete_from_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-from-cursor", G_CALLBACK(entry_deleteFromCursorHandler), data);
	}

*/
/*

	void entry_insertAtCursorHandler(GObject *, gchar*, gpointer);

	static gulong Entry_signal_connect_insert_at_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-at-cursor", G_CALLBACK(entry_insertAtCursorHandler), data);
	}

*/
/*

	void entry_moveCursorHandler(GObject *, GtkMovementStep, gint, gboolean, gpointer);

	static gulong Entry_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(entry_moveCursorHandler), data);
	}

*/
/*

	void entry_pasteClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_paste_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paste-clipboard", G_CALLBACK(entry_pasteClipboardHandler), data);
	}

*/
/*

	void entry_populatePopupHandler(GObject *, GtkWidget *, gpointer);

	static gulong Entry_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(entry_populatePopupHandler), data);
	}

*/
/*

	void entry_toggleOverwriteHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_toggle_overwrite(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-overwrite", G_CALLBACK(entry_toggleOverwriteHandler), data);
	}

*/
/*

	void expander_activateHandler(GObject *, gpointer);

	static gulong Expander_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(expander_activateHandler), data);
	}

*/
/*

	void filechooserwidget_desktopFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_desktop_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "desktop-folder", G_CALLBACK(filechooserwidget_desktopFolderHandler), data);
	}

*/
/*

	void filechooserwidget_downFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_down_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "down-folder", G_CALLBACK(filechooserwidget_downFolderHandler), data);
	}

*/
/*

	void filechooserwidget_homeFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_home_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "home-folder", G_CALLBACK(filechooserwidget_homeFolderHandler), data);
	}

*/
/*

	void filechooserwidget_locationPopupHandler(GObject *, gchar*, gpointer);

	static gulong FileChooserWidget_signal_connect_location_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-popup", G_CALLBACK(filechooserwidget_locationPopupHandler), data);
	}

*/
/*

	void filechooserwidget_locationPopupOnPasteHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_location_popup_on_paste(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-popup-on-paste", G_CALLBACK(filechooserwidget_locationPopupOnPasteHandler), data);
	}

*/
/*

	void filechooserwidget_locationTogglePopupHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_location_toggle_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-toggle-popup", G_CALLBACK(filechooserwidget_locationTogglePopupHandler), data);
	}

*/
/*

	void filechooserwidget_placesShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_places_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "places-shortcut", G_CALLBACK(filechooserwidget_placesShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_quickBookmarkHandler(GObject *, gint, gpointer);

	static gulong FileChooserWidget_signal_connect_quick_bookmark(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "quick-bookmark", G_CALLBACK(filechooserwidget_quickBookmarkHandler), data);
	}

*/
/*

	void filechooserwidget_recentShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_recent_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "recent-shortcut", G_CALLBACK(filechooserwidget_recentShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_searchShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_search_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "search-shortcut", G_CALLBACK(filechooserwidget_searchShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_showHiddenHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_show_hidden(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-hidden", G_CALLBACK(filechooserwidget_showHiddenHandler), data);
	}

*/
/*

	void filechooserwidget_upFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_up_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "up-folder", G_CALLBACK(filechooserwidget_upFolderHandler), data);
	}

*/
/*

	void flowbox_activateCursorChildHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_activate_cursor_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-child", G_CALLBACK(flowbox_activateCursorChildHandler), data);
	}

*/
/*

	void flowbox_childActivatedHandler(GObject *, GtkFlowBoxChild *, gpointer);

	static gulong FlowBox_signal_connect_child_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-activated", G_CALLBACK(flowbox_childActivatedHandler), data);
	}

*/
/*

	gboolean flowbox_moveCursorHandler(GObject *, GtkMovementStep, gint, gpointer);

	static gulong FlowBox_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(flowbox_moveCursorHandler), data);
	}

*/
/*

	void flowbox_selectAllHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(flowbox_selectAllHandler), data);
	}

*/
/*

	void flowbox_selectedChildrenChangedHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_selected_children_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selected-children-changed", G_CALLBACK(flowbox_selectedChildrenChangedHandler), data);
	}

*/
/*

	void flowbox_toggleCursorChildHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_toggle_cursor_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-child", G_CALLBACK(flowbox_toggleCursorChildHandler), data);
	}

*/
/*

	void flowbox_unselectAllHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(flowbox_unselectAllHandler), data);
	}

*/
/*

	void flowboxchild_activateHandler(GObject *, gpointer);

	static gulong FlowBoxChild_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(flowboxchild_activateHandler), data);
	}

*/
/*

	void hsv_changedHandler(GObject *, gpointer);

	static gulong HSV_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(hsv_changedHandler), data);
	}

*/
/*

	void hsv_moveHandler(GObject *, GtkDirectionType, gpointer);

	static gulong HSV_signal_connect_move(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move", G_CALLBACK(hsv_moveHandler), data);
	}

*/
/*

	void handlebox_childAttachedHandler(GObject *, GtkWidget *, gpointer);

	static gulong HandleBox_signal_connect_child_attached(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-attached", G_CALLBACK(handlebox_childAttachedHandler), data);
	}

*/
/*

	void handlebox_childDetachedHandler(GObject *, GtkWidget *, gpointer);

	static gulong HandleBox_signal_connect_child_detached(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-detached", G_CALLBACK(handlebox_childDetachedHandler), data);
	}

*/
/*

	void imcontext_commitHandler(GObject *, gchar*, gpointer);

	static gulong IMContext_signal_connect_commit(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "commit", G_CALLBACK(imcontext_commitHandler), data);
	}

*/
/*

	gboolean imcontext_deleteSurroundingHandler(GObject *, gint, gint, gpointer);

	static gulong IMContext_signal_connect_delete_surrounding(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-surrounding", G_CALLBACK(imcontext_deleteSurroundingHandler), data);
	}

*/
/*

	void imcontext_preeditChangedHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-changed", G_CALLBACK(imcontext_preeditChangedHandler), data);
	}

*/
/*

	void imcontext_preeditEndHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-end", G_CALLBACK(imcontext_preeditEndHandler), data);
	}

*/
/*

	void imcontext_preeditStartHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_start(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-start", G_CALLBACK(imcontext_preeditStartHandler), data);
	}

*/
/*

	gboolean imcontext_retrieveSurroundingHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_retrieve_surrounding(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "retrieve-surrounding", G_CALLBACK(imcontext_retrieveSurroundingHandler), data);
	}

*/
/*

	void icontheme_changedHandler(GObject *, gpointer);

	static gulong IconTheme_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(icontheme_changedHandler), data);
	}

*/
/*

	gboolean iconview_activateCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_activate_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-item", G_CALLBACK(iconview_activateCursorItemHandler), data);
	}

*/
/*

	void iconview_itemActivatedHandler(GObject *, GtkTreePath *, gpointer);

	static gulong IconView_signal_connect_item_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "item-activated", G_CALLBACK(iconview_itemActivatedHandler), data);
	}

*/
/*

	gboolean iconview_moveCursorHandler(GObject *, GtkMovementStep, gint, gpointer);

	static gulong IconView_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(iconview_moveCursorHandler), data);
	}

*/
/*

	void iconview_selectAllHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(iconview_selectAllHandler), data);
	}

*/
/*

	void iconview_selectCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_select_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-item", G_CALLBACK(iconview_selectCursorItemHandler), data);
	}

*/
/*

	void iconview_selectionChangedHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_selection_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-changed", G_CALLBACK(iconview_selectionChangedHandler), data);
	}

*/
/*

	void iconview_toggleCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_toggle_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-item", G_CALLBACK(iconview_toggleCursorItemHandler), data);
	}

*/
/*

	void iconview_unselectAllHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(iconview_unselectAllHandler), data);
	}

*/
/*

	void label_copyClipboardHandler(GObject *, gpointer);

	static gulong Label_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(label_copyClipboardHandler), data);
	}

*/
/*

	void label_moveCursorHandler(GObject *, GtkMovementStep, gint, gboolean, gpointer);

	static gulong Label_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(label_moveCursorHandler), data);
	}

*/
/*

	void label_populatePopupHandler(GObject *, GtkMenu *, gpointer);

	static gulong Label_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(label_populatePopupHandler), data);
	}

*/
/*

	gboolean linkbutton_activateLinkHandler(GObject *, gpointer);

	static gulong LinkButton_signal_connect_activate_link(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-link", G_CALLBACK(linkbutton_activateLinkHandler), data);
	}

*/
/*

	void listbox_activateCursorRowHandler(GObject *, gpointer);

	static gulong ListBox_signal_connect_activate_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-row", G_CALLBACK(listbox_activateCursorRowHandler), data);
	}

*/
/*

	void listbox_moveCursorHandler(GObject *, GtkMovementStep, gint, gpointer);

	static gulong ListBox_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(listbox_moveCursorHandler), data);
	}

*/
/*

	void listbox_toggleCursorRowHandler(GObject *, gpointer);

	static gulong ListBox_signal_connect_toggle_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-row", G_CALLBACK(listbox_toggleCursorRowHandler), data);
	}

*/
/*

	void menu_moveScrollHandler(GObject *, GtkScrollType, gpointer);

	static gulong Menu_signal_connect_move_scroll(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-scroll", G_CALLBACK(menu_moveScrollHandler), data);
	}

*/
/*

	void menuitem_activateHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(menuitem_activateHandler), data);
	}

*/
/*

	void menuitem_activateItemHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_activate_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-item", G_CALLBACK(menuitem_activateItemHandler), data);
	}

*/
/*

	void menuitem_deselectHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_deselect(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "deselect", G_CALLBACK(menuitem_deselectHandler), data);
	}

*/
/*

	void menuitem_selectHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_select(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select", G_CALLBACK(menuitem_selectHandler), data);
	}

*/
/*

	void menuitem_toggleSizeAllocateHandler(GObject *, gint, gpointer);

	static gulong MenuItem_signal_connect_toggle_size_allocate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-size-allocate", G_CALLBACK(menuitem_toggleSizeAllocateHandler), data);
	}

*/
/*

	void menushell_activateCurrentHandler(GObject *, gboolean, gpointer);

	static gulong MenuShell_signal_connect_activate_current(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-current", G_CALLBACK(menushell_activateCurrentHandler), data);
	}

*/
/*

	void menushell_cancelHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_cancel(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cancel", G_CALLBACK(menushell_cancelHandler), data);
	}

*/
/*

	void menushell_cycleFocusHandler(GObject *, GtkDirectionType, gpointer);

	static gulong MenuShell_signal_connect_cycle_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cycle-focus", G_CALLBACK(menushell_cycleFocusHandler), data);
	}

*/
/*

	void menushell_deactivateHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_deactivate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "deactivate", G_CALLBACK(menushell_deactivateHandler), data);
	}

*/
/*

	void menushell_moveCurrentHandler(GObject *, GtkMenuDirectionType, gpointer);

	static gulong MenuShell_signal_connect_move_current(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-current", G_CALLBACK(menushell_moveCurrentHandler), data);
	}

*/
/*

	void menushell_selectionDoneHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_selection_done(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-done", G_CALLBACK(menushell_selectionDoneHandler), data);
	}

*/
/*

	void menutoolbutton_showMenuHandler(GObject *, gpointer);

	static gulong MenuToolButton_signal_connect_show_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-menu", G_CALLBACK(menutoolbutton_showMenuHandler), data);
	}

*/
/*

	gboolean notebook_changeCurrentPageHandler(GObject *, gint, gpointer);

	static gulong Notebook_signal_connect_change_current_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "change-current-page", G_CALLBACK(notebook_changeCurrentPageHandler), data);
	}

*/
/*

	gboolean notebook_focusTabHandler(GObject *, GtkNotebookTab, gpointer);

	static gulong Notebook_signal_connect_focus_tab(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-tab", G_CALLBACK(notebook_focusTabHandler), data);
	}

*/
/*

	void notebook_moveFocusOutHandler(GObject *, GtkDirectionType, gpointer);

	static gulong Notebook_signal_connect_move_focus_out(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-focus-out", G_CALLBACK(notebook_moveFocusOutHandler), data);
	}

*/
/*

	gboolean notebook_reorderTabHandler(GObject *, GtkDirectionType, gboolean, gpointer);

	static gulong Notebook_signal_connect_reorder_tab(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "reorder-tab", G_CALLBACK(notebook_reorderTabHandler), data);
	}

*/
/*

	gboolean notebook_selectPageHandler(GObject *, gboolean, gpointer);

	static gulong Notebook_signal_connect_select_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-page", G_CALLBACK(notebook_selectPageHandler), data);
	}

*/
/*

	void notebook_switchPageHandler(GObject *, GtkWidget *, guint, gpointer);

	static gulong Notebook_signal_connect_switch_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "switch-page", G_CALLBACK(notebook_switchPageHandler), data);
	}

*/
/*

	void placessidebar_showConnectToServerHandler(GObject *, gpointer);

	static gulong PlacesSidebar_signal_connect_show_connect_to_server(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-connect-to-server", G_CALLBACK(placessidebar_showConnectToServerHandler), data);
	}

*/
/*

	void popover_closedHandler(GObject *, gpointer);

	static gulong Popover_signal_connect_closed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "closed", G_CALLBACK(popover_closedHandler), data);
	}

*/
/*

	void radiomenuitem_groupChangedHandler(GObject *, gpointer);

	static gulong RadioMenuItem_signal_connect_group_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "group-changed", G_CALLBACK(radiomenuitem_groupChangedHandler), data);
	}

*/
/*

	void range_adjustBoundsHandler(GObject *, gdouble, gpointer);

	static gulong Range_signal_connect_adjust_bounds(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "adjust-bounds", G_CALLBACK(range_adjustBoundsHandler), data);
	}

*/
/*

	void range_moveSliderHandler(GObject *, GtkScrollType, gpointer);

	static gulong Range_signal_connect_move_slider(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-slider", G_CALLBACK(range_moveSliderHandler), data);
	}

*/
/*

	void range_valueChangedHandler(GObject *, gpointer);

	static gulong Range_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(range_valueChangedHandler), data);
	}

*/
/*

	void scrolledwindow_moveFocusOutHandler(GObject *, GtkDirectionType, gpointer);

	static gulong ScrolledWindow_signal_connect_move_focus_out(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-focus-out", G_CALLBACK(scrolledwindow_moveFocusOutHandler), data);
	}

*/
/*

	gboolean scrolledwindow_scrollChildHandler(GObject *, GtkScrollType, gboolean, gpointer);

	static gulong ScrolledWindow_signal_connect_scroll_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "scroll-child", G_CALLBACK(scrolledwindow_scrollChildHandler), data);
	}

*/
/*

	void spinbutton_changeValueHandler(GObject *, GtkScrollType, gpointer);

	static gulong SpinButton_signal_connect_change_value(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "change-value", G_CALLBACK(spinbutton_changeValueHandler), data);
	}

*/
/*

	gboolean spinbutton_outputHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_output(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "output", G_CALLBACK(spinbutton_outputHandler), data);
	}

*/
/*

	void spinbutton_valueChangedHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(spinbutton_valueChangedHandler), data);
	}

*/
/*

	void statusbar_textPoppedHandler(GObject *, guint, gchar*, gpointer);

	static gulong Statusbar_signal_connect_text_popped(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "text-popped", G_CALLBACK(statusbar_textPoppedHandler), data);
	}

*/
/*

	void statusbar_textPushedHandler(GObject *, guint, gchar*, gpointer);

	static gulong Statusbar_signal_connect_text_pushed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "text-pushed", G_CALLBACK(statusbar_textPushedHandler), data);
	}

*/
/*

	void switch_activateHandler(GObject *, gpointer);

	static gulong Switch_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(switch_activateHandler), data);
	}

*/
/*

	void textbuffer_applyTagHandler(GObject *, GtkTextTag *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_apply_tag(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "apply-tag", G_CALLBACK(textbuffer_applyTagHandler), data);
	}

*/
/*

	void textbuffer_beginUserActionHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_begin_user_action(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "begin-user-action", G_CALLBACK(textbuffer_beginUserActionHandler), data);
	}

*/
/*

	void textbuffer_changedHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(textbuffer_changedHandler), data);
	}

*/
/*

	void textbuffer_deleteRangeHandler(GObject *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_delete_range(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-range", G_CALLBACK(textbuffer_deleteRangeHandler), data);
	}

*/
/*

	void textbuffer_endUserActionHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_end_user_action(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "end-user-action", G_CALLBACK(textbuffer_endUserActionHandler), data);
	}

*/
/*

	void textbuffer_insertChildAnchorHandler(GObject *, GtkTextIter *, GtkTextChildAnchor *, gpointer);

	static gulong TextBuffer_signal_connect_insert_child_anchor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-child-anchor", G_CALLBACK(textbuffer_insertChildAnchorHandler), data);
	}

*/
/*

	void textbuffer_insertPixbufHandler(GObject *, GtkTextIter *, GdkPixbuf *, gpointer);

	static gulong TextBuffer_signal_connect_insert_pixbuf(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-pixbuf", G_CALLBACK(textbuffer_insertPixbufHandler), data);
	}

*/
/*

	void textbuffer_insertTextHandler(GObject *, GtkTextIter *, gchar*, gint, gpointer);

	static gulong TextBuffer_signal_connect_insert_text(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-text", G_CALLBACK(textbuffer_insertTextHandler), data);
	}

*/
/*

	void textbuffer_markDeletedHandler(GObject *, GtkTextMark *, gpointer);

	static gulong TextBuffer_signal_connect_mark_deleted(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mark-deleted", G_CALLBACK(textbuffer_markDeletedHandler), data);
	}

*/
/*

	void textbuffer_markSetHandler(GObject *, GtkTextIter *, GtkTextMark *, gpointer);

	static gulong TextBuffer_signal_connect_mark_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mark-set", G_CALLBACK(textbuffer_markSetHandler), data);
	}

*/
/*

	void textbuffer_modifiedChangedHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_modified_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "modified-changed", G_CALLBACK(textbuffer_modifiedChangedHandler), data);
	}

*/
/*

	void textbuffer_removeTagHandler(GObject *, GtkTextTag *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_remove_tag(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove-tag", G_CALLBACK(textbuffer_removeTagHandler), data);
	}

*/
/*

	void texttagtable_tagAddedHandler(GObject *, GtkTextTag *, gpointer);

	static gulong TextTagTable_signal_connect_tag_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-added", G_CALLBACK(texttagtable_tagAddedHandler), data);
	}

*/
/*

	void texttagtable_tagChangedHandler(GObject *, GtkTextTag *, gboolean, gpointer);

	static gulong TextTagTable_signal_connect_tag_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-changed", G_CALLBACK(texttagtable_tagChangedHandler), data);
	}

*/
/*

	void texttagtable_tagRemovedHandler(GObject *, GtkTextTag *, gpointer);

	static gulong TextTagTable_signal_connect_tag_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-removed", G_CALLBACK(texttagtable_tagRemovedHandler), data);
	}

*/
/*

	void textview_backspaceHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_backspace(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "backspace", G_CALLBACK(textview_backspaceHandler), data);
	}

*/
/*

	void textview_copyClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(textview_copyClipboardHandler), data);
	}

*/
/*

	void textview_cutClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_cut_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cut-clipboard", G_CALLBACK(textview_cutClipboardHandler), data);
	}

*/
/*

	void textview_deleteFromCursorHandler(GObject *, GtkDeleteType, gint, gpointer);

	static gulong TextView_signal_connect_delete_from_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-from-cursor", G_CALLBACK(textview_deleteFromCursorHandler), data);
	}

*/
/*

	void textview_insertAtCursorHandler(GObject *, gchar*, gpointer);

	static gulong TextView_signal_connect_insert_at_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-at-cursor", G_CALLBACK(textview_insertAtCursorHandler), data);
	}

*/
/*

	void textview_moveCursorHandler(GObject *, GtkMovementStep, gint, gboolean, gpointer);

	static gulong TextView_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(textview_moveCursorHandler), data);
	}

*/
/*

	void textview_moveViewportHandler(GObject *, GtkScrollStep, gint, gpointer);

	static gulong TextView_signal_connect_move_viewport(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-viewport", G_CALLBACK(textview_moveViewportHandler), data);
	}

*/
/*

	void textview_pasteClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_paste_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paste-clipboard", G_CALLBACK(textview_pasteClipboardHandler), data);
	}

*/
/*

	void textview_populatePopupHandler(GObject *, GtkWidget *, gpointer);

	static gulong TextView_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(textview_populatePopupHandler), data);
	}

*/
/*

	void textview_selectAllHandler(GObject *, gboolean, gpointer);

	static gulong TextView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(textview_selectAllHandler), data);
	}

*/
/*

	void textview_setAnchorHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_set_anchor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-anchor", G_CALLBACK(textview_setAnchorHandler), data);
	}

*/
/*

	void textview_toggleCursorVisibleHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_toggle_cursor_visible(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-visible", G_CALLBACK(textview_toggleCursorVisibleHandler), data);
	}

*/
/*

	void textview_toggleOverwriteHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_toggle_overwrite(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-overwrite", G_CALLBACK(textview_toggleOverwriteHandler), data);
	}

*/
/*

	void toggleaction_toggledHandler(GObject *, gpointer);

	static gulong ToggleAction_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(toggleaction_toggledHandler), data);
	}

*/
/*

	void togglebutton_toggledHandler(GObject *, gpointer);

	static gulong ToggleButton_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(togglebutton_toggledHandler), data);
	}

*/
/*

	void toggletoolbutton_toggledHandler(GObject *, gpointer);

	static gulong ToggleToolButton_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(toggletoolbutton_toggledHandler), data);
	}

*/
/*

	void toolbutton_clickedHandler(GObject *, gpointer);

	static gulong ToolButton_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(toolbutton_clickedHandler), data);
	}

*/
/*

	gboolean toolitem_createMenuProxyHandler(GObject *, gpointer);

	static gulong ToolItem_signal_connect_create_menu_proxy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "create-menu-proxy", G_CALLBACK(toolitem_createMenuProxyHandler), data);
	}

*/
/*

	void toolitem_toolbarReconfiguredHandler(GObject *, gpointer);

	static gulong ToolItem_signal_connect_toolbar_reconfigured(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toolbar-reconfigured", G_CALLBACK(toolitem_toolbarReconfiguredHandler), data);
	}

*/
/*

	gboolean toolbar_focusHomeOrEndHandler(GObject *, gboolean, gpointer);

	static gulong Toolbar_signal_connect_focus_home_or_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-home-or-end", G_CALLBACK(toolbar_focusHomeOrEndHandler), data);
	}

*/
/*

	void toolbar_orientationChangedHandler(GObject *, GtkOrientation, gpointer);

	static gulong Toolbar_signal_connect_orientation_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "orientation-changed", G_CALLBACK(toolbar_orientationChangedHandler), data);
	}

*/
/*

	gboolean toolbar_popupContextMenuHandler(GObject *, gint, gint, gint, gpointer);

	static gulong Toolbar_signal_connect_popup_context_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup-context-menu", G_CALLBACK(toolbar_popupContextMenuHandler), data);
	}

*/
/*

	void toolbar_styleChangedHandler(GObject *, GtkToolbarStyle, gpointer);

	static gulong Toolbar_signal_connect_style_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "style-changed", G_CALLBACK(toolbar_styleChangedHandler), data);
	}

*/
/*

	void treeselection_changedHandler(GObject *, gpointer);

	static gulong TreeSelection_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(treeselection_changedHandler), data);
	}

*/
/*

	void treeview_columnsChangedHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_columns_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "columns-changed", G_CALLBACK(treeview_columnsChangedHandler), data);
	}

*/
/*

	void treeview_cursorChangedHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_cursor_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cursor-changed", G_CALLBACK(treeview_cursorChangedHandler), data);
	}

*/
/*

	gboolean treeview_expandCollapseCursorRowHandler(GObject *, gboolean, gboolean, gboolean, gpointer);

	static gulong TreeView_signal_connect_expand_collapse_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "expand-collapse-cursor-row", G_CALLBACK(treeview_expandCollapseCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_moveCursorHandler(GObject *, GtkMovementStep, gint, gpointer);

	static gulong TreeView_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(treeview_moveCursorHandler), data);
	}

*/
/*

	void treeview_rowActivatedHandler(GObject *, GtkTreePath *, GtkTreeViewColumn *, gpointer);

	static gulong TreeView_signal_connect_row_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-activated", G_CALLBACK(treeview_rowActivatedHandler), data);
	}

*/
/*

	void treeview_rowCollapsedHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_row_collapsed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-collapsed", G_CALLBACK(treeview_rowCollapsedHandler), data);
	}

*/
/*

	void treeview_rowExpandedHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_row_expanded(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-expanded", G_CALLBACK(treeview_rowExpandedHandler), data);
	}

*/
/*

	gboolean treeview_selectAllHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(treeview_selectAllHandler), data);
	}

*/
/*

	gboolean treeview_selectCursorParentHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_select_cursor_parent(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-parent", G_CALLBACK(treeview_selectCursorParentHandler), data);
	}

*/
/*

	gboolean treeview_selectCursorRowHandler(GObject *, gboolean, gpointer);

	static gulong TreeView_signal_connect_select_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-row", G_CALLBACK(treeview_selectCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_startInteractiveSearchHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_start_interactive_search(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "start-interactive-search", G_CALLBACK(treeview_startInteractiveSearchHandler), data);
	}

*/
/*

	gboolean treeview_testCollapseRowHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_test_collapse_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "test-collapse-row", G_CALLBACK(treeview_testCollapseRowHandler), data);
	}

*/
/*

	gboolean treeview_testExpandRowHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_test_expand_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "test-expand-row", G_CALLBACK(treeview_testExpandRowHandler), data);
	}

*/
/*

	gboolean treeview_toggleCursorRowHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_toggle_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-row", G_CALLBACK(treeview_toggleCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_unselectAllHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(treeview_unselectAllHandler), data);
	}

*/
/*

	void treeviewcolumn_clickedHandler(GObject *, gpointer);

	static gulong TreeViewColumn_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(treeviewcolumn_clickedHandler), data);
	}

*/
/*

	void widget_accelClosuresChangedHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_accel_closures_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-closures-changed", G_CALLBACK(widget_accelClosuresChangedHandler), data);
	}

*/
/*

	gboolean widget_buttonPressEventHandler(GObject *, GdkEventButton *, gpointer);

	static gulong Widget_signal_connect_button_press_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "button-press-event", G_CALLBACK(widget_buttonPressEventHandler), data);
	}

*/
/*

	gboolean widget_buttonReleaseEventHandler(GObject *, GdkEventButton *, gpointer);

	static gulong Widget_signal_connect_button_release_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "button-release-event", G_CALLBACK(widget_buttonReleaseEventHandler), data);
	}

*/
/*

	gboolean widget_canActivateAccelHandler(GObject *, guint, gpointer);

	static gulong Widget_signal_connect_can_activate_accel(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "can-activate-accel", G_CALLBACK(widget_canActivateAccelHandler), data);
	}

*/
/*

	void widget_childNotifyHandler(GObject *, GParamSpec *, gpointer);

	static gulong Widget_signal_connect_child_notify(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-notify", G_CALLBACK(widget_childNotifyHandler), data);
	}

*/
/*

	void widget_compositedChangedHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_composited_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "composited-changed", G_CALLBACK(widget_compositedChangedHandler), data);
	}

*/
/*

	gboolean widget_configureEventHandler(GObject *, GdkEventConfigure *, gpointer);

	static gulong Widget_signal_connect_configure_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "configure-event", G_CALLBACK(widget_configureEventHandler), data);
	}

*/
/*

	void widget_destroyHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_destroy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "destroy", G_CALLBACK(widget_destroyHandler), data);
	}

*/
/*

	void widget_directionChangedHandler(GObject *, GtkTextDirection, gpointer);

	static gulong Widget_signal_connect_direction_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "direction-changed", G_CALLBACK(widget_directionChangedHandler), data);
	}

*/
/*

	void widget_dragBeginHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_begin(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-begin", G_CALLBACK(widget_dragBeginHandler), data);
	}

*/
/*

	void widget_dragDataDeleteHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_data_delete(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-data-delete", G_CALLBACK(widget_dragDataDeleteHandler), data);
	}

*/
/*

	void widget_dragDataGetHandler(GObject *, GdkDragContext *, GtkSelectionData *, guint, guint, gpointer);

	static gulong Widget_signal_connect_drag_data_get(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-data-get", G_CALLBACK(widget_dragDataGetHandler), data);
	}

*/
/*

	void widget_dragDataReceivedHandler(GObject *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint, gpointer);

	static gulong Widget_signal_connect_drag_data_received(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-data-received", G_CALLBACK(widget_dragDataReceivedHandler), data);
	}

*/
/*

	gboolean widget_dragDropHandler(GObject *, GdkDragContext *, gint, gint, guint, gpointer);

	static gulong Widget_signal_connect_drag_drop(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-drop", G_CALLBACK(widget_dragDropHandler), data);
	}

*/
/*

	void widget_dragEndHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-end", G_CALLBACK(widget_dragEndHandler), data);
	}

*/
/*

	void widget_dragLeaveHandler(GObject *, GdkDragContext *, guint, gpointer);

	static gulong Widget_signal_connect_drag_leave(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-leave", G_CALLBACK(widget_dragLeaveHandler), data);
	}

*/
/*

	gboolean widget_dragMotionHandler(GObject *, GdkDragContext *, gint, gint, guint, gpointer);

	static gulong Widget_signal_connect_drag_motion(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-motion", G_CALLBACK(widget_dragMotionHandler), data);
	}

*/
/*

	gboolean widget_enterNotifyEventHandler(GObject *, GdkEventCrossing *, gpointer);

	static gulong Widget_signal_connect_enter_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enter-notify-event", G_CALLBACK(widget_enterNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_focusHandler(GObject *, GtkDirectionType, gpointer);

	static gulong Widget_signal_connect_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus", G_CALLBACK(widget_focusHandler), data);
	}

*/
/*

	gboolean widget_focusInEventHandler(GObject *, GdkEventFocus *, gpointer);

	static gulong Widget_signal_connect_focus_in_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-in-event", G_CALLBACK(widget_focusInEventHandler), data);
	}

*/
/*

	gboolean widget_focusOutEventHandler(GObject *, GdkEventFocus *, gpointer);

	static gulong Widget_signal_connect_focus_out_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-out-event", G_CALLBACK(widget_focusOutEventHandler), data);
	}

*/
/*

	void widget_grabFocusHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_grab_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-focus", G_CALLBACK(widget_grabFocusHandler), data);
	}

*/
/*

	void widget_grabNotifyHandler(GObject *, gboolean, gpointer);

	static gulong Widget_signal_connect_grab_notify(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-notify", G_CALLBACK(widget_grabNotifyHandler), data);
	}

*/
/*

	void widget_hideHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_hide(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "hide", G_CALLBACK(widget_hideHandler), data);
	}

*/
/*

	void widget_hierarchyChangedHandler(GObject *, GtkWidget *, gpointer);

	static gulong Widget_signal_connect_hierarchy_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "hierarchy-changed", G_CALLBACK(widget_hierarchyChangedHandler), data);
	}

*/
/*

	gboolean widget_keyPressEventHandler(GObject *, GdkEventKey *, gpointer);

	static gulong Widget_signal_connect_key_press_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "key-press-event", G_CALLBACK(widget_keyPressEventHandler), data);
	}

*/
/*

	gboolean widget_keyReleaseEventHandler(GObject *, GdkEventKey *, gpointer);

	static gulong Widget_signal_connect_key_release_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "key-release-event", G_CALLBACK(widget_keyReleaseEventHandler), data);
	}

*/
/*

	gboolean widget_leaveNotifyEventHandler(GObject *, GdkEventCrossing *, gpointer);

	static gulong Widget_signal_connect_leave_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "leave-notify-event", G_CALLBACK(widget_leaveNotifyEventHandler), data);
	}

*/
/*

	void widget_mapHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_map(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "map", G_CALLBACK(widget_mapHandler), data);
	}

*/
/*

	gboolean widget_mapEventHandler(GObject *, GdkEventAny *, gpointer);

	static gulong Widget_signal_connect_map_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "map-event", G_CALLBACK(widget_mapEventHandler), data);
	}

*/
/*

	gboolean widget_mnemonicActivateHandler(GObject *, gboolean, gpointer);

	static gulong Widget_signal_connect_mnemonic_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mnemonic-activate", G_CALLBACK(widget_mnemonicActivateHandler), data);
	}

*/
/*

	gboolean widget_motionNotifyEventHandler(GObject *, GdkEventMotion *, gpointer);

	static gulong Widget_signal_connect_motion_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "motion-notify-event", G_CALLBACK(widget_motionNotifyEventHandler), data);
	}

*/
/*

	void widget_moveFocusHandler(GObject *, GtkDirectionType, gpointer);

	static gulong Widget_signal_connect_move_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-focus", G_CALLBACK(widget_moveFocusHandler), data);
	}

*/
/*

	void widget_parentSetHandler(GObject *, GtkWidget *, gpointer);

	static gulong Widget_signal_connect_parent_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "parent-set", G_CALLBACK(widget_parentSetHandler), data);
	}

*/
/*

	gboolean widget_popupMenuHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_popup_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup-menu", G_CALLBACK(widget_popupMenuHandler), data);
	}

*/
/*

	gboolean widget_propertyNotifyEventHandler(GObject *, GdkEventProperty *, gpointer);

	static gulong Widget_signal_connect_property_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "property-notify-event", G_CALLBACK(widget_propertyNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_proximityInEventHandler(GObject *, GdkEventProximity *, gpointer);

	static gulong Widget_signal_connect_proximity_in_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "proximity-in-event", G_CALLBACK(widget_proximityInEventHandler), data);
	}

*/
/*

	gboolean widget_proximityOutEventHandler(GObject *, GdkEventProximity *, gpointer);

	static gulong Widget_signal_connect_proximity_out_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "proximity-out-event", G_CALLBACK(widget_proximityOutEventHandler), data);
	}

*/
/*

	void widget_realizeHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_realize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "realize", G_CALLBACK(widget_realizeHandler), data);
	}

*/
/*

	void widget_screenChangedHandler(GObject *, GdkScreen *, gpointer);

	static gulong Widget_signal_connect_screen_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "screen-changed", G_CALLBACK(widget_screenChangedHandler), data);
	}

*/
/*

	gboolean widget_scrollEventHandler(GObject *, GdkEventScroll *, gpointer);

	static gulong Widget_signal_connect_scroll_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "scroll-event", G_CALLBACK(widget_scrollEventHandler), data);
	}

*/
/*

	gboolean widget_selectionClearEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_clear_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-clear-event", G_CALLBACK(widget_selectionClearEventHandler), data);
	}

*/
/*

	void widget_selectionGetHandler(GObject *, GtkSelectionData *, guint, guint, gpointer);

	static gulong Widget_signal_connect_selection_get(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-get", G_CALLBACK(widget_selectionGetHandler), data);
	}

*/
/*

	gboolean widget_selectionNotifyEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-notify-event", G_CALLBACK(widget_selectionNotifyEventHandler), data);
	}

*/
/*

	void widget_selectionReceivedHandler(GObject *, GtkSelectionData *, guint, gpointer);

	static gulong Widget_signal_connect_selection_received(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-received", G_CALLBACK(widget_selectionReceivedHandler), data);
	}

*/
/*

	gboolean widget_selectionRequestEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_request_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-request-event", G_CALLBACK(widget_selectionRequestEventHandler), data);
	}

*/
/*

	void widget_showHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_show(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show", G_CALLBACK(widget_showHandler), data);
	}

*/
/*

	gboolean widget_showHelpHandler(GObject *, GtkWidgetHelpType, gpointer);

	static gulong Widget_signal_connect_show_help(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-help", G_CALLBACK(widget_showHelpHandler), data);
	}

*/
/*

	void widget_sizeAllocateHandler(GObject *, GdkRectangle *, gpointer);

	static gulong Widget_signal_connect_size_allocate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "size-allocate", G_CALLBACK(widget_sizeAllocateHandler), data);
	}

*/
/*

	void widget_stateChangedHandler(GObject *, GtkStateType, gpointer);

	static gulong Widget_signal_connect_state_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "state-changed", G_CALLBACK(widget_stateChangedHandler), data);
	}

*/
/*

	void widget_styleSetHandler(GObject *, GtkStyle *, gpointer);

	static gulong Widget_signal_connect_style_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "style-set", G_CALLBACK(widget_styleSetHandler), data);
	}

*/
/*

	void widget_unmapHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_unmap(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmap", G_CALLBACK(widget_unmapHandler), data);
	}

*/
/*

	gboolean widget_unmapEventHandler(GObject *, GdkEventAny *, gpointer);

	static gulong Widget_signal_connect_unmap_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmap-event", G_CALLBACK(widget_unmapEventHandler), data);
	}

*/
/*

	void widget_unrealizeHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_unrealize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unrealize", G_CALLBACK(widget_unrealizeHandler), data);
	}

*/
/*

	gboolean widget_visibilityNotifyEventHandler(GObject *, GdkEventVisibility *, gpointer);

	static gulong Widget_signal_connect_visibility_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "visibility-notify-event", G_CALLBACK(widget_visibilityNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_windowStateEventHandler(GObject *, GdkEventWindowState *, gpointer);

	static gulong Widget_signal_connect_window_state_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "window-state-event", G_CALLBACK(widget_windowStateEventHandler), data);
	}

*/
/*

	void window_activateDefaultHandler(GObject *, gpointer);

	static gulong Window_signal_connect_activate_default(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-default", G_CALLBACK(window_activateDefaultHandler), data);
	}

*/
/*

	void window_activateFocusHandler(GObject *, gpointer);

	static gulong Window_signal_connect_activate_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-focus", G_CALLBACK(window_activateFocusHandler), data);
	}

*/
/*

	gboolean window_enableDebuggingHandler(GObject *, gboolean, gpointer);

	static gulong Window_signal_connect_enable_debugging(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enable-debugging", G_CALLBACK(window_enableDebuggingHandler), data);
	}

*/
/*

	void window_keysChangedHandler(GObject *, gpointer);

	static gulong Window_signal_connect_keys_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "keys-changed", G_CALLBACK(window_keysChangedHandler), data);
	}

*/
/*

	void window_setFocusHandler(GObject *, GtkWidget *, gpointer);

	static gulong Window_signal_connect_set_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-focus", G_CALLBACK(window_setFocusHandler), data);
	}

*/
import "C"

// AboutDialog is a wrapper around the C record GtkAboutDialog.
type AboutDialog struct {
	native *C.GtkAboutDialog
	// parent_instance : record
	// Private : priv
}

func AboutDialogNewFromC(u unsafe.Pointer) *AboutDialog {
	c := (*C.GtkAboutDialog)(u)
	if c == nil {
		return nil
	}

	g := &AboutDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AboutDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AboutDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AboutDialog with another AboutDialog, and returns true if they represent the same GObject.
func (recv *AboutDialog) Equals(other *AboutDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *AboutDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *AboutDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *AboutDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *AboutDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *AboutDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AboutDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AboutDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to AboutDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a AboutDialog.
func CastToAboutDialog(object *gobject.Object) *AboutDialog {
	return AboutDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by AboutDialog
func (recv *AboutDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AboutDialog
func (recv *AboutDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AccelGroup is a wrapper around the C record GtkAccelGroup.
type AccelGroup struct {
	native *C.GtkAccelGroup
	// parent : record
	// priv : record
}

func AccelGroupNewFromC(u unsafe.Pointer) *AccelGroup {
	c := (*C.GtkAccelGroup)(u)
	if c == nil {
		return nil
	}

	g := &AccelGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AccelGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AccelGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelGroup with another AccelGroup, and returns true if they represent the same GObject.
func (recv *AccelGroup) Equals(other *AccelGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *AccelGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to AccelGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelGroup.
func CastToAccelGroup(object *gobject.Object) *AccelGroup {
	return AccelGroupNewFromC(object.ToC())
}

type signalAccelGroupAccelActivateDetail struct {
	callback  AccelGroupSignalAccelActivateCallback
	handlerID C.gulong
}

var signalAccelGroupAccelActivateId int
var signalAccelGroupAccelActivateMap = make(map[int]signalAccelGroupAccelActivateDetail)
var signalAccelGroupAccelActivateLock sync.RWMutex

// AccelGroupSignalAccelActivateCallback is a callback function for a 'accel-activate' signal emitted from a AccelGroup.
type AccelGroupSignalAccelActivateCallback func(acceleratable *gobject.Object, keyval uint32, modifier gdk.ModifierType) bool

/*
ConnectAccelActivate connects the callback to the 'accel-activate' signal for the AccelGroup.

The returned value represents the connection, and may be passed to DisconnectAccelActivate to remove it.
*/
func (recv *AccelGroup) ConnectAccelActivate(callback AccelGroupSignalAccelActivateCallback) int {
	signalAccelGroupAccelActivateLock.Lock()
	defer signalAccelGroupAccelActivateLock.Unlock()

	signalAccelGroupAccelActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.AccelGroup_signal_connect_accel_activate(instance, C.gpointer(uintptr(signalAccelGroupAccelActivateId)))

	detail := signalAccelGroupAccelActivateDetail{callback, handlerID}
	signalAccelGroupAccelActivateMap[signalAccelGroupAccelActivateId] = detail

	return signalAccelGroupAccelActivateId
}

/*
DisconnectAccelActivate disconnects a callback from the 'accel-activate' signal for the AccelGroup.

The connectionID should be a value returned from a call to ConnectAccelActivate.
*/
func (recv *AccelGroup) DisconnectAccelActivate(connectionID int) {
	signalAccelGroupAccelActivateLock.Lock()
	defer signalAccelGroupAccelActivateLock.Unlock()

	detail, exists := signalAccelGroupAccelActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAccelGroupAccelActivateMap, connectionID)
}

//export accelgroup_accelActivateHandler
func accelgroup_accelActivateHandler(_ *C.GObject, c_acceleratable *C.GObject, c_keyval C.guint, c_modifier C.guint, data C.gpointer) C.gboolean {
	signalAccelGroupAccelActivateLock.RLock()
	defer signalAccelGroupAccelActivateLock.RUnlock()

	acceleratable := gobject.ObjectNewFromC(unsafe.Pointer(c_acceleratable))

	keyval := uint32(c_keyval)

	modifier := gdk.ModifierType(c_modifier)

	index := int(uintptr(data))
	callback := signalAccelGroupAccelActivateMap[index].callback
	retGo := callback(acceleratable, keyval, modifier)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalAccelGroupAccelChangedDetail struct {
	callback  AccelGroupSignalAccelChangedCallback
	handlerID C.gulong
}

var signalAccelGroupAccelChangedId int
var signalAccelGroupAccelChangedMap = make(map[int]signalAccelGroupAccelChangedDetail)
var signalAccelGroupAccelChangedLock sync.RWMutex

// AccelGroupSignalAccelChangedCallback is a callback function for a 'accel-changed' signal emitted from a AccelGroup.
type AccelGroupSignalAccelChangedCallback func(keyval uint32, modifier gdk.ModifierType, accelClosure *gobject.Closure)

/*
ConnectAccelChanged connects the callback to the 'accel-changed' signal for the AccelGroup.

The returned value represents the connection, and may be passed to DisconnectAccelChanged to remove it.
*/
func (recv *AccelGroup) ConnectAccelChanged(callback AccelGroupSignalAccelChangedCallback) int {
	signalAccelGroupAccelChangedLock.Lock()
	defer signalAccelGroupAccelChangedLock.Unlock()

	signalAccelGroupAccelChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AccelGroup_signal_connect_accel_changed(instance, C.gpointer(uintptr(signalAccelGroupAccelChangedId)))

	detail := signalAccelGroupAccelChangedDetail{callback, handlerID}
	signalAccelGroupAccelChangedMap[signalAccelGroupAccelChangedId] = detail

	return signalAccelGroupAccelChangedId
}

/*
DisconnectAccelChanged disconnects a callback from the 'accel-changed' signal for the AccelGroup.

The connectionID should be a value returned from a call to ConnectAccelChanged.
*/
func (recv *AccelGroup) DisconnectAccelChanged(connectionID int) {
	signalAccelGroupAccelChangedLock.Lock()
	defer signalAccelGroupAccelChangedLock.Unlock()

	detail, exists := signalAccelGroupAccelChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAccelGroupAccelChangedMap, connectionID)
}

//export accelgroup_accelChangedHandler
func accelgroup_accelChangedHandler(_ *C.GObject, c_keyval C.guint, c_modifier C.guint, c_accel_closure *C.GClosure, data C.gpointer) {
	signalAccelGroupAccelChangedLock.RLock()
	defer signalAccelGroupAccelChangedLock.RUnlock()

	keyval := uint32(c_keyval)

	modifier := gdk.ModifierType(c_modifier)

	accelClosure := gobject.ClosureNewFromC(unsafe.Pointer(c_accel_closure))

	index := int(uintptr(data))
	callback := signalAccelGroupAccelChangedMap[index].callback
	callback(keyval, modifier, accelClosure)
}

// Blacklisted : gtk_accel_group_new

// Blacklisted : gtk_accel_group_from_accel_closure

// Blacklisted : gtk_accel_group_activate

// Blacklisted : gtk_accel_group_connect

// Blacklisted : gtk_accel_group_connect_by_path

// Blacklisted : gtk_accel_group_disconnect

// Blacklisted : gtk_accel_group_disconnect_key

// Unsupported : gtk_accel_group_find : unsupported parameter find_func : no type generator for AccelGroupFindFunc (GtkAccelGroupFindFunc) for param find_func

// Blacklisted : gtk_accel_group_lock

// Unsupported : gtk_accel_group_query : array return type :

// Blacklisted : gtk_accel_group_unlock

// AccelLabel is a wrapper around the C record GtkAccelLabel.
type AccelLabel struct {
	native *C.GtkAccelLabel
	// label : record
	// priv : record
}

func AccelLabelNewFromC(u unsafe.Pointer) *AccelLabel {
	c := (*C.GtkAccelLabel)(u)
	if c == nil {
		return nil
	}

	g := &AccelLabel{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AccelLabel) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AccelLabel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelLabel with another AccelLabel, and returns true if they represent the same GObject.
func (recv *AccelLabel) Equals(other *AccelLabel) bool {
	return other.ToC() == recv.ToC()
}

// Label upcasts to *Label
func (recv *AccelLabel) Label() *Label {
	return LabelNewFromC(unsafe.Pointer(recv.native))
}

// Misc upcasts to *Misc
func (recv *AccelLabel) Misc() *Misc {
	return recv.Label().Misc()
}

// Widget upcasts to *Widget
func (recv *AccelLabel) Widget() *Widget {
	return recv.Label().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AccelLabel) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Label().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AccelLabel) Object() *gobject.Object {
	return recv.Label().Object()
}

// CastToWidget down casts any arbitrary Object to AccelLabel.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelLabel.
func CastToAccelLabel(object *gobject.Object) *AccelLabel {
	return AccelLabelNewFromC(object.ToC())
}

// Blacklisted : gtk_accel_label_new

// Blacklisted : gtk_accel_label_get_accel_widget

// Blacklisted : gtk_accel_label_get_accel_width

// Blacklisted : gtk_accel_label_refetch

// Blacklisted : gtk_accel_label_set_accel_closure

// Blacklisted : gtk_accel_label_set_accel_widget

// ImplementorIface returns the ImplementorIface interface implemented by AccelLabel
func (recv *AccelLabel) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AccelLabel
func (recv *AccelLabel) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AccelMap is a wrapper around the C record GtkAccelMap.
type AccelMap struct {
	native *C.GtkAccelMap
}

func AccelMapNewFromC(u unsafe.Pointer) *AccelMap {
	c := (*C.GtkAccelMap)(u)
	if c == nil {
		return nil
	}

	g := &AccelMap{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AccelMap) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AccelMap) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelMap with another AccelMap, and returns true if they represent the same GObject.
func (recv *AccelMap) Equals(other *AccelMap) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *AccelMap) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to AccelMap.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelMap.
func CastToAccelMap(object *gobject.Object) *AccelMap {
	return AccelMapNewFromC(object.ToC())
}

// Blacklisted : gtk_accel_map_add_entry

// Blacklisted : gtk_accel_map_add_filter

// Blacklisted : gtk_accel_map_change_entry

// gtk_accel_map_foreach : unsupported parameter data : no type generator for gpointer (gpointer) for param data
// gtk_accel_map_foreach_unfiltered : unsupported parameter data : no type generator for gpointer (gpointer) for param data
// Blacklisted : gtk_accel_map_load

// Blacklisted : gtk_accel_map_load_fd

// Blacklisted : gtk_accel_map_load_scanner

// Blacklisted : gtk_accel_map_lookup_entry

// Blacklisted : gtk_accel_map_save

// Blacklisted : gtk_accel_map_save_fd

// Accessible is a wrapper around the C record GtkAccessible.
type Accessible struct {
	native *C.GtkAccessible
	// parent : record
	// Private : priv
}

func AccessibleNewFromC(u unsafe.Pointer) *Accessible {
	c := (*C.GtkAccessible)(u)
	if c == nil {
		return nil
	}

	g := &Accessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Accessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Accessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Accessible with another Accessible, and returns true if they represent the same GObject.
func (recv *Accessible) Equals(other *Accessible) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Accessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Accessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a Accessible.
func CastToAccessible(object *gobject.Object) *Accessible {
	return AccessibleNewFromC(object.ToC())
}

// Blacklisted : gtk_accessible_connect_widget_destroyed

// Action is a wrapper around the C record GtkAction.
type Action struct {
	native *C.GtkAction
	// object : record
	// Private : private_data
}

func ActionNewFromC(u unsafe.Pointer) *Action {
	c := (*C.GtkAction)(u)
	if c == nil {
		return nil
	}

	g := &Action{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Action) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Action) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Action with another Action, and returns true if they represent the same GObject.
func (recv *Action) Equals(other *Action) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Action) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Action.
// Exercise care, as this is a potentially dangerous function if the Object is not a Action.
func CastToAction(object *gobject.Object) *Action {
	return ActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by Action
func (recv *Action) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ActionBar is a wrapper around the C record GtkActionBar.
type ActionBar struct {
	native *C.GtkActionBar
	// Private : bin
}

func ActionBarNewFromC(u unsafe.Pointer) *ActionBar {
	c := (*C.GtkActionBar)(u)
	if c == nil {
		return nil
	}

	g := &ActionBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ActionBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ActionBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionBar with another ActionBar, and returns true if they represent the same GObject.
func (recv *ActionBar) Equals(other *ActionBar) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ActionBar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ActionBar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ActionBar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ActionBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ActionBar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ActionBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a ActionBar.
func CastToActionBar(object *gobject.Object) *ActionBar {
	return ActionBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ActionBar
func (recv *ActionBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ActionBar
func (recv *ActionBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ActionGroup is a wrapper around the C record GtkActionGroup.
type ActionGroup struct {
	native *C.GtkActionGroup
	// parent : record
	// Private : priv
}

func ActionGroupNewFromC(u unsafe.Pointer) *ActionGroup {
	c := (*C.GtkActionGroup)(u)
	if c == nil {
		return nil
	}

	g := &ActionGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ActionGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ActionGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionGroup with another ActionGroup, and returns true if they represent the same GObject.
func (recv *ActionGroup) Equals(other *ActionGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ActionGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ActionGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a ActionGroup.
func CastToActionGroup(object *gobject.Object) *ActionGroup {
	return ActionGroupNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by ActionGroup
func (recv *ActionGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Adjustment is a wrapper around the C record GtkAdjustment.
type Adjustment struct {
	native *C.GtkAdjustment
	// parent_instance : record
	// priv : record
}

func AdjustmentNewFromC(u unsafe.Pointer) *Adjustment {
	c := (*C.GtkAdjustment)(u)
	if c == nil {
		return nil
	}

	g := &Adjustment{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Adjustment) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Adjustment) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Adjustment with another Adjustment, and returns true if they represent the same GObject.
func (recv *Adjustment) Equals(other *Adjustment) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Adjustment) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Adjustment) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to Adjustment.
// Exercise care, as this is a potentially dangerous function if the Object is not a Adjustment.
func CastToAdjustment(object *gobject.Object) *Adjustment {
	return AdjustmentNewFromC(object.ToC())
}

type signalAdjustmentChangedDetail struct {
	callback  AdjustmentSignalChangedCallback
	handlerID C.gulong
}

var signalAdjustmentChangedId int
var signalAdjustmentChangedMap = make(map[int]signalAdjustmentChangedDetail)
var signalAdjustmentChangedLock sync.RWMutex

// AdjustmentSignalChangedCallback is a callback function for a 'changed' signal emitted from a Adjustment.
type AdjustmentSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the Adjustment.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Adjustment) ConnectChanged(callback AdjustmentSignalChangedCallback) int {
	signalAdjustmentChangedLock.Lock()
	defer signalAdjustmentChangedLock.Unlock()

	signalAdjustmentChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Adjustment_signal_connect_changed(instance, C.gpointer(uintptr(signalAdjustmentChangedId)))

	detail := signalAdjustmentChangedDetail{callback, handlerID}
	signalAdjustmentChangedMap[signalAdjustmentChangedId] = detail

	return signalAdjustmentChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Adjustment.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Adjustment) DisconnectChanged(connectionID int) {
	signalAdjustmentChangedLock.Lock()
	defer signalAdjustmentChangedLock.Unlock()

	detail, exists := signalAdjustmentChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAdjustmentChangedMap, connectionID)
}

//export adjustment_changedHandler
func adjustment_changedHandler(_ *C.GObject, data C.gpointer) {
	signalAdjustmentChangedLock.RLock()
	defer signalAdjustmentChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAdjustmentChangedMap[index].callback
	callback()
}

type signalAdjustmentValueChangedDetail struct {
	callback  AdjustmentSignalValueChangedCallback
	handlerID C.gulong
}

var signalAdjustmentValueChangedId int
var signalAdjustmentValueChangedMap = make(map[int]signalAdjustmentValueChangedDetail)
var signalAdjustmentValueChangedLock sync.RWMutex

// AdjustmentSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a Adjustment.
type AdjustmentSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the Adjustment.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *Adjustment) ConnectValueChanged(callback AdjustmentSignalValueChangedCallback) int {
	signalAdjustmentValueChangedLock.Lock()
	defer signalAdjustmentValueChangedLock.Unlock()

	signalAdjustmentValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Adjustment_signal_connect_value_changed(instance, C.gpointer(uintptr(signalAdjustmentValueChangedId)))

	detail := signalAdjustmentValueChangedDetail{callback, handlerID}
	signalAdjustmentValueChangedMap[signalAdjustmentValueChangedId] = detail

	return signalAdjustmentValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the Adjustment.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *Adjustment) DisconnectValueChanged(connectionID int) {
	signalAdjustmentValueChangedLock.Lock()
	defer signalAdjustmentValueChangedLock.Unlock()

	detail, exists := signalAdjustmentValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAdjustmentValueChangedMap, connectionID)
}

//export adjustment_valueChangedHandler
func adjustment_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	signalAdjustmentValueChangedLock.RLock()
	defer signalAdjustmentValueChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAdjustmentValueChangedMap[index].callback
	callback()
}

// Blacklisted : gtk_adjustment_new

// Blacklisted : gtk_adjustment_changed

// Blacklisted : gtk_adjustment_clamp_page

// Blacklisted : gtk_adjustment_get_value

// Blacklisted : gtk_adjustment_set_value

// Blacklisted : gtk_adjustment_value_changed

// Alignment is a wrapper around the C record GtkAlignment.
type Alignment struct {
	native *C.GtkAlignment
	// bin : record
	// Private : priv
}

func AlignmentNewFromC(u unsafe.Pointer) *Alignment {
	c := (*C.GtkAlignment)(u)
	if c == nil {
		return nil
	}

	g := &Alignment{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Alignment) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Alignment) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Alignment with another Alignment, and returns true if they represent the same GObject.
func (recv *Alignment) Equals(other *Alignment) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Alignment) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Alignment) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Alignment) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Alignment) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Alignment) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Alignment.
// Exercise care, as this is a potentially dangerous function if the Object is not a Alignment.
func CastToAlignment(object *gobject.Object) *Alignment {
	return AlignmentNewFromC(object.ToC())
}

// Blacklisted : gtk_alignment_new

// Blacklisted : gtk_alignment_set

// ImplementorIface returns the ImplementorIface interface implemented by Alignment
func (recv *Alignment) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Alignment
func (recv *Alignment) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AppChooserButton is a wrapper around the C record GtkAppChooserButton.
type AppChooserButton struct {
	native *C.GtkAppChooserButton
	// parent : record
	// Private : priv
}

func AppChooserButtonNewFromC(u unsafe.Pointer) *AppChooserButton {
	c := (*C.GtkAppChooserButton)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AppChooserButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AppChooserButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserButton with another AppChooserButton, and returns true if they represent the same GObject.
func (recv *AppChooserButton) Equals(other *AppChooserButton) bool {
	return other.ToC() == recv.ToC()
}

// ComboBox upcasts to *ComboBox
func (recv *AppChooserButton) ComboBox() *ComboBox {
	return ComboBoxNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *AppChooserButton) Bin() *Bin {
	return recv.ComboBox().Bin()
}

// Container upcasts to *Container
func (recv *AppChooserButton) Container() *Container {
	return recv.ComboBox().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserButton) Widget() *Widget {
	return recv.ComboBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ComboBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserButton) Object() *gobject.Object {
	return recv.ComboBox().Object()
}

// CastToWidget down casts any arbitrary Object to AppChooserButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserButton.
func CastToAppChooserButton(object *gobject.Object) *AppChooserButton {
	return AppChooserButtonNewFromC(object.ToC())
}

type signalAppChooserButtonCustomItemActivatedDetail struct {
	callback  AppChooserButtonSignalCustomItemActivatedCallback
	handlerID C.gulong
}

var signalAppChooserButtonCustomItemActivatedId int
var signalAppChooserButtonCustomItemActivatedMap = make(map[int]signalAppChooserButtonCustomItemActivatedDetail)
var signalAppChooserButtonCustomItemActivatedLock sync.RWMutex

// AppChooserButtonSignalCustomItemActivatedCallback is a callback function for a 'custom-item-activated' signal emitted from a AppChooserButton.
type AppChooserButtonSignalCustomItemActivatedCallback func(itemName string)

/*
ConnectCustomItemActivated connects the callback to the 'custom-item-activated' signal for the AppChooserButton.

The returned value represents the connection, and may be passed to DisconnectCustomItemActivated to remove it.
*/
func (recv *AppChooserButton) ConnectCustomItemActivated(callback AppChooserButtonSignalCustomItemActivatedCallback) int {
	signalAppChooserButtonCustomItemActivatedLock.Lock()
	defer signalAppChooserButtonCustomItemActivatedLock.Unlock()

	signalAppChooserButtonCustomItemActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserButton_signal_connect_custom_item_activated(instance, C.gpointer(uintptr(signalAppChooserButtonCustomItemActivatedId)))

	detail := signalAppChooserButtonCustomItemActivatedDetail{callback, handlerID}
	signalAppChooserButtonCustomItemActivatedMap[signalAppChooserButtonCustomItemActivatedId] = detail

	return signalAppChooserButtonCustomItemActivatedId
}

/*
DisconnectCustomItemActivated disconnects a callback from the 'custom-item-activated' signal for the AppChooserButton.

The connectionID should be a value returned from a call to ConnectCustomItemActivated.
*/
func (recv *AppChooserButton) DisconnectCustomItemActivated(connectionID int) {
	signalAppChooserButtonCustomItemActivatedLock.Lock()
	defer signalAppChooserButtonCustomItemActivatedLock.Unlock()

	detail, exists := signalAppChooserButtonCustomItemActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserButtonCustomItemActivatedMap, connectionID)
}

//export appchooserbutton_customItemActivatedHandler
func appchooserbutton_customItemActivatedHandler(_ *C.GObject, c_item_name *C.gchar, data C.gpointer) {
	signalAppChooserButtonCustomItemActivatedLock.RLock()
	defer signalAppChooserButtonCustomItemActivatedLock.RUnlock()

	itemName := C.GoString(c_item_name)

	index := int(uintptr(data))
	callback := signalAppChooserButtonCustomItemActivatedMap[index].callback
	callback(itemName)
}

// Blacklisted : gtk_app_chooser_button_get_heading

// Blacklisted : gtk_app_chooser_button_set_heading

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserButton
func (recv *AppChooserButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserButton
func (recv *AppChooserButton) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserButton
func (recv *AppChooserButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by AppChooserButton
func (recv *AppChooserButton) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by AppChooserButton
func (recv *AppChooserButton) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// AppChooserDialog is a wrapper around the C record GtkAppChooserDialog.
type AppChooserDialog struct {
	native *C.GtkAppChooserDialog
	// parent : record
	// Private : priv
}

func AppChooserDialogNewFromC(u unsafe.Pointer) *AppChooserDialog {
	c := (*C.GtkAppChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AppChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AppChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserDialog with another AppChooserDialog, and returns true if they represent the same GObject.
func (recv *AppChooserDialog) Equals(other *AppChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *AppChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *AppChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *AppChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *AppChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to AppChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserDialog.
func CastToAppChooserDialog(object *gobject.Object) *AppChooserDialog {
	return AppChooserDialogNewFromC(object.ToC())
}

// Blacklisted : gtk_app_chooser_dialog_get_heading

// Blacklisted : gtk_app_chooser_dialog_set_heading

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserDialog
func (recv *AppChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserDialog
func (recv *AppChooserDialog) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserDialog
func (recv *AppChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AppChooserWidget is a wrapper around the C record GtkAppChooserWidget.
type AppChooserWidget struct {
	native *C.GtkAppChooserWidget
	// parent : record
	// Private : priv
}

func AppChooserWidgetNewFromC(u unsafe.Pointer) *AppChooserWidget {
	c := (*C.GtkAppChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AppChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AppChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserWidget with another AppChooserWidget, and returns true if they represent the same GObject.
func (recv *AppChooserWidget) Equals(other *AppChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *AppChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *AppChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to AppChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserWidget.
func CastToAppChooserWidget(object *gobject.Object) *AppChooserWidget {
	return AppChooserWidgetNewFromC(object.ToC())
}

type signalAppChooserWidgetApplicationActivatedDetail struct {
	callback  AppChooserWidgetSignalApplicationActivatedCallback
	handlerID C.gulong
}

var signalAppChooserWidgetApplicationActivatedId int
var signalAppChooserWidgetApplicationActivatedMap = make(map[int]signalAppChooserWidgetApplicationActivatedDetail)
var signalAppChooserWidgetApplicationActivatedLock sync.RWMutex

// AppChooserWidgetSignalApplicationActivatedCallback is a callback function for a 'application-activated' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalApplicationActivatedCallback func(application *gio.AppInfo)

/*
ConnectApplicationActivated connects the callback to the 'application-activated' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectApplicationActivated to remove it.
*/
func (recv *AppChooserWidget) ConnectApplicationActivated(callback AppChooserWidgetSignalApplicationActivatedCallback) int {
	signalAppChooserWidgetApplicationActivatedLock.Lock()
	defer signalAppChooserWidgetApplicationActivatedLock.Unlock()

	signalAppChooserWidgetApplicationActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_application_activated(instance, C.gpointer(uintptr(signalAppChooserWidgetApplicationActivatedId)))

	detail := signalAppChooserWidgetApplicationActivatedDetail{callback, handlerID}
	signalAppChooserWidgetApplicationActivatedMap[signalAppChooserWidgetApplicationActivatedId] = detail

	return signalAppChooserWidgetApplicationActivatedId
}

/*
DisconnectApplicationActivated disconnects a callback from the 'application-activated' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectApplicationActivated.
*/
func (recv *AppChooserWidget) DisconnectApplicationActivated(connectionID int) {
	signalAppChooserWidgetApplicationActivatedLock.Lock()
	defer signalAppChooserWidgetApplicationActivatedLock.Unlock()

	detail, exists := signalAppChooserWidgetApplicationActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetApplicationActivatedMap, connectionID)
}

//export appchooserwidget_applicationActivatedHandler
func appchooserwidget_applicationActivatedHandler(_ *C.GObject, c_application *C.GAppInfo, data C.gpointer) {
	signalAppChooserWidgetApplicationActivatedLock.RLock()
	defer signalAppChooserWidgetApplicationActivatedLock.RUnlock()

	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetApplicationActivatedMap[index].callback
	callback(application)
}

type signalAppChooserWidgetApplicationSelectedDetail struct {
	callback  AppChooserWidgetSignalApplicationSelectedCallback
	handlerID C.gulong
}

var signalAppChooserWidgetApplicationSelectedId int
var signalAppChooserWidgetApplicationSelectedMap = make(map[int]signalAppChooserWidgetApplicationSelectedDetail)
var signalAppChooserWidgetApplicationSelectedLock sync.RWMutex

// AppChooserWidgetSignalApplicationSelectedCallback is a callback function for a 'application-selected' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalApplicationSelectedCallback func(application *gio.AppInfo)

/*
ConnectApplicationSelected connects the callback to the 'application-selected' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectApplicationSelected to remove it.
*/
func (recv *AppChooserWidget) ConnectApplicationSelected(callback AppChooserWidgetSignalApplicationSelectedCallback) int {
	signalAppChooserWidgetApplicationSelectedLock.Lock()
	defer signalAppChooserWidgetApplicationSelectedLock.Unlock()

	signalAppChooserWidgetApplicationSelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_application_selected(instance, C.gpointer(uintptr(signalAppChooserWidgetApplicationSelectedId)))

	detail := signalAppChooserWidgetApplicationSelectedDetail{callback, handlerID}
	signalAppChooserWidgetApplicationSelectedMap[signalAppChooserWidgetApplicationSelectedId] = detail

	return signalAppChooserWidgetApplicationSelectedId
}

/*
DisconnectApplicationSelected disconnects a callback from the 'application-selected' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectApplicationSelected.
*/
func (recv *AppChooserWidget) DisconnectApplicationSelected(connectionID int) {
	signalAppChooserWidgetApplicationSelectedLock.Lock()
	defer signalAppChooserWidgetApplicationSelectedLock.Unlock()

	detail, exists := signalAppChooserWidgetApplicationSelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetApplicationSelectedMap, connectionID)
}

//export appchooserwidget_applicationSelectedHandler
func appchooserwidget_applicationSelectedHandler(_ *C.GObject, c_application *C.GAppInfo, data C.gpointer) {
	signalAppChooserWidgetApplicationSelectedLock.RLock()
	defer signalAppChooserWidgetApplicationSelectedLock.RUnlock()

	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetApplicationSelectedMap[index].callback
	callback(application)
}

type signalAppChooserWidgetPopulatePopupDetail struct {
	callback  AppChooserWidgetSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalAppChooserWidgetPopulatePopupId int
var signalAppChooserWidgetPopulatePopupMap = make(map[int]signalAppChooserWidgetPopulatePopupDetail)
var signalAppChooserWidgetPopulatePopupLock sync.RWMutex

// AppChooserWidgetSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalPopulatePopupCallback func(menu *Menu, application *gio.AppInfo)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *AppChooserWidget) ConnectPopulatePopup(callback AppChooserWidgetSignalPopulatePopupCallback) int {
	signalAppChooserWidgetPopulatePopupLock.Lock()
	defer signalAppChooserWidgetPopulatePopupLock.Unlock()

	signalAppChooserWidgetPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalAppChooserWidgetPopulatePopupId)))

	detail := signalAppChooserWidgetPopulatePopupDetail{callback, handlerID}
	signalAppChooserWidgetPopulatePopupMap[signalAppChooserWidgetPopulatePopupId] = detail

	return signalAppChooserWidgetPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *AppChooserWidget) DisconnectPopulatePopup(connectionID int) {
	signalAppChooserWidgetPopulatePopupLock.Lock()
	defer signalAppChooserWidgetPopulatePopupLock.Unlock()

	detail, exists := signalAppChooserWidgetPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetPopulatePopupMap, connectionID)
}

//export appchooserwidget_populatePopupHandler
func appchooserwidget_populatePopupHandler(_ *C.GObject, c_menu *C.GtkMenu, c_application *C.GAppInfo, data C.gpointer) {
	signalAppChooserWidgetPopulatePopupLock.RLock()
	defer signalAppChooserWidgetPopulatePopupLock.RUnlock()

	menu := MenuNewFromC(unsafe.Pointer(c_menu))

	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetPopulatePopupMap[index].callback
	callback(menu, application)
}

// Blacklisted : gtk_app_chooser_widget_set_default_text

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserWidget
func (recv *AppChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserWidget
func (recv *AppChooserWidget) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserWidget
func (recv *AppChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by AppChooserWidget
func (recv *AppChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Application is a wrapper around the C record GtkApplication.
type Application struct {
	native *C.GtkApplication
	// parent : record
	// Private : priv
}

func ApplicationNewFromC(u unsafe.Pointer) *Application {
	c := (*C.GtkApplication)(u)
	if c == nil {
		return nil
	}

	g := &Application{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Application) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Application) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Application with another Application, and returns true if they represent the same GObject.
func (recv *Application) Equals(other *Application) bool {
	return other.ToC() == recv.ToC()
}

// Application upcasts to *Application
func (recv *Application) Application() *gio.Application {
	return gio.ApplicationNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Application) Object() *gobject.Object {
	return recv.Application().Object()
}

// CastToWidget down casts any arbitrary Object to Application.
// Exercise care, as this is a potentially dangerous function if the Object is not a Application.
func CastToApplication(object *gobject.Object) *Application {
	return ApplicationNewFromC(object.ToC())
}

// ActionGroup returns the ActionGroup interface implemented by Application
func (recv *Application) ActionGroup() *gio.ActionGroup {
	return gio.ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by Application
func (recv *Application) ActionMap() *gio.ActionMap {
	return gio.ActionMapNewFromC(recv.ToC())
}

// ApplicationWindow is a wrapper around the C record GtkApplicationWindow.
type ApplicationWindow struct {
	native *C.GtkApplicationWindow
	// parent_instance : record
	// Private : priv
}

func ApplicationWindowNewFromC(u unsafe.Pointer) *ApplicationWindow {
	c := (*C.GtkApplicationWindow)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationWindow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ApplicationWindow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ApplicationWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationWindow with another ApplicationWindow, and returns true if they represent the same GObject.
func (recv *ApplicationWindow) Equals(other *ApplicationWindow) bool {
	return other.ToC() == recv.ToC()
}

// Window upcasts to *Window
func (recv *ApplicationWindow) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ApplicationWindow) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *ApplicationWindow) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *ApplicationWindow) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ApplicationWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ApplicationWindow) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitrary Object to ApplicationWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ApplicationWindow.
func CastToApplicationWindow(object *gobject.Object) *ApplicationWindow {
	return ApplicationWindowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// ActionGroup returns the ActionGroup interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ActionGroup() *gio.ActionGroup {
	return gio.ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ActionMap() *gio.ActionMap {
	return gio.ActionMapNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ApplicationWindow
func (recv *ApplicationWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Arrow is a wrapper around the C record GtkArrow.
type Arrow struct {
	native *C.GtkArrow
	// misc : record
	// Private : priv
}

func ArrowNewFromC(u unsafe.Pointer) *Arrow {
	c := (*C.GtkArrow)(u)
	if c == nil {
		return nil
	}

	g := &Arrow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Arrow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Arrow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Arrow with another Arrow, and returns true if they represent the same GObject.
func (recv *Arrow) Equals(other *Arrow) bool {
	return other.ToC() == recv.ToC()
}

// Misc upcasts to *Misc
func (recv *Arrow) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Arrow) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Arrow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Arrow) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitrary Object to Arrow.
// Exercise care, as this is a potentially dangerous function if the Object is not a Arrow.
func CastToArrow(object *gobject.Object) *Arrow {
	return ArrowNewFromC(object.ToC())
}

// Blacklisted : gtk_arrow_new

// Blacklisted : gtk_arrow_set

// ImplementorIface returns the ImplementorIface interface implemented by Arrow
func (recv *Arrow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Arrow
func (recv *Arrow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ArrowAccessible is a wrapper around the C record GtkArrowAccessible.
type ArrowAccessible struct {
	native *C.GtkArrowAccessible
	// parent : record
	// priv : record
}

func ArrowAccessibleNewFromC(u unsafe.Pointer) *ArrowAccessible {
	c := (*C.GtkArrowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ArrowAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ArrowAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ArrowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ArrowAccessible with another ArrowAccessible, and returns true if they represent the same GObject.
func (recv *ArrowAccessible) Equals(other *ArrowAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ArrowAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ArrowAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ArrowAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ArrowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ArrowAccessible.
func CastToArrowAccessible(object *gobject.Object) *ArrowAccessible {
	return ArrowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ArrowAccessible
func (recv *ArrowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ArrowAccessible
func (recv *ArrowAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// AspectFrame is a wrapper around the C record GtkAspectFrame.
type AspectFrame struct {
	native *C.GtkAspectFrame
	// frame : record
	// Private : priv
}

func AspectFrameNewFromC(u unsafe.Pointer) *AspectFrame {
	c := (*C.GtkAspectFrame)(u)
	if c == nil {
		return nil
	}

	g := &AspectFrame{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AspectFrame) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AspectFrame) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AspectFrame with another AspectFrame, and returns true if they represent the same GObject.
func (recv *AspectFrame) Equals(other *AspectFrame) bool {
	return other.ToC() == recv.ToC()
}

// Frame upcasts to *Frame
func (recv *AspectFrame) Frame() *Frame {
	return FrameNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *AspectFrame) Bin() *Bin {
	return recv.Frame().Bin()
}

// Container upcasts to *Container
func (recv *AspectFrame) Container() *Container {
	return recv.Frame().Container()
}

// Widget upcasts to *Widget
func (recv *AspectFrame) Widget() *Widget {
	return recv.Frame().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AspectFrame) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Frame().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AspectFrame) Object() *gobject.Object {
	return recv.Frame().Object()
}

// CastToWidget down casts any arbitrary Object to AspectFrame.
// Exercise care, as this is a potentially dangerous function if the Object is not a AspectFrame.
func CastToAspectFrame(object *gobject.Object) *AspectFrame {
	return AspectFrameNewFromC(object.ToC())
}

// Blacklisted : gtk_aspect_frame_new

// Blacklisted : gtk_aspect_frame_set

// ImplementorIface returns the ImplementorIface interface implemented by AspectFrame
func (recv *AspectFrame) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AspectFrame
func (recv *AspectFrame) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Assistant is a wrapper around the C record GtkAssistant.
type Assistant struct {
	native *C.GtkAssistant
	// parent : record
	// Private : priv
}

func AssistantNewFromC(u unsafe.Pointer) *Assistant {
	c := (*C.GtkAssistant)(u)
	if c == nil {
		return nil
	}

	g := &Assistant{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Assistant) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Assistant) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Assistant with another Assistant, and returns true if they represent the same GObject.
func (recv *Assistant) Equals(other *Assistant) bool {
	return other.ToC() == recv.ToC()
}

// Window upcasts to *Window
func (recv *Assistant) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *Assistant) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *Assistant) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *Assistant) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Assistant) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Assistant) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitrary Object to Assistant.
// Exercise care, as this is a potentially dangerous function if the Object is not a Assistant.
func CastToAssistant(object *gobject.Object) *Assistant {
	return AssistantNewFromC(object.ToC())
}

type signalAssistantEscapeDetail struct {
	callback  AssistantSignalEscapeCallback
	handlerID C.gulong
}

var signalAssistantEscapeId int
var signalAssistantEscapeMap = make(map[int]signalAssistantEscapeDetail)
var signalAssistantEscapeLock sync.RWMutex

// AssistantSignalEscapeCallback is a callback function for a 'escape' signal emitted from a Assistant.
type AssistantSignalEscapeCallback func()

/*
ConnectEscape connects the callback to the 'escape' signal for the Assistant.

The returned value represents the connection, and may be passed to DisconnectEscape to remove it.
*/
func (recv *Assistant) ConnectEscape(callback AssistantSignalEscapeCallback) int {
	signalAssistantEscapeLock.Lock()
	defer signalAssistantEscapeLock.Unlock()

	signalAssistantEscapeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Assistant_signal_connect_escape(instance, C.gpointer(uintptr(signalAssistantEscapeId)))

	detail := signalAssistantEscapeDetail{callback, handlerID}
	signalAssistantEscapeMap[signalAssistantEscapeId] = detail

	return signalAssistantEscapeId
}

/*
DisconnectEscape disconnects a callback from the 'escape' signal for the Assistant.

The connectionID should be a value returned from a call to ConnectEscape.
*/
func (recv *Assistant) DisconnectEscape(connectionID int) {
	signalAssistantEscapeLock.Lock()
	defer signalAssistantEscapeLock.Unlock()

	detail, exists := signalAssistantEscapeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAssistantEscapeMap, connectionID)
}

//export assistant_escapeHandler
func assistant_escapeHandler(_ *C.GObject, data C.gpointer) {
	signalAssistantEscapeLock.RLock()
	defer signalAssistantEscapeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAssistantEscapeMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Assistant
func (recv *Assistant) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Assistant
func (recv *Assistant) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Bin is a wrapper around the C record GtkBin.
type Bin struct {
	native *C.GtkBin
	// container : record
	// Private : priv
}

func BinNewFromC(u unsafe.Pointer) *Bin {
	c := (*C.GtkBin)(u)
	if c == nil {
		return nil
	}

	g := &Bin{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Bin) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Bin) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Bin with another Bin, and returns true if they represent the same GObject.
func (recv *Bin) Equals(other *Bin) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Bin) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Bin) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Bin) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Bin) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Bin.
// Exercise care, as this is a potentially dangerous function if the Object is not a Bin.
func CastToBin(object *gobject.Object) *Bin {
	return BinNewFromC(object.ToC())
}

// Blacklisted : gtk_bin_get_child

// ImplementorIface returns the ImplementorIface interface implemented by Bin
func (recv *Bin) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Bin
func (recv *Bin) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// BooleanCellAccessible is a wrapper around the C record GtkBooleanCellAccessible.
type BooleanCellAccessible struct {
	native *C.GtkBooleanCellAccessible
	// parent : record
	// priv : record
}

func BooleanCellAccessibleNewFromC(u unsafe.Pointer) *BooleanCellAccessible {
	c := (*C.GtkBooleanCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &BooleanCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *BooleanCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *BooleanCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BooleanCellAccessible with another BooleanCellAccessible, and returns true if they represent the same GObject.
func (recv *BooleanCellAccessible) Equals(other *BooleanCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *BooleanCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *BooleanCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *BooleanCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *BooleanCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to BooleanCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a BooleanCellAccessible.
func CastToBooleanCellAccessible(object *gobject.Object) *BooleanCellAccessible {
	return BooleanCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by BooleanCellAccessible
func (recv *BooleanCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by BooleanCellAccessible
func (recv *BooleanCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Box is a wrapper around the C record GtkBox.
type Box struct {
	native *C.GtkBox
	// container : record
	// Private : priv
}

func BoxNewFromC(u unsafe.Pointer) *Box {
	c := (*C.GtkBox)(u)
	if c == nil {
		return nil
	}

	g := &Box{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Box) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Box) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Box with another Box, and returns true if they represent the same GObject.
func (recv *Box) Equals(other *Box) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Box) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Box) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Box) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Box) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Box.
// Exercise care, as this is a potentially dangerous function if the Object is not a Box.
func CastToBox(object *gobject.Object) *Box {
	return BoxNewFromC(object.ToC())
}

// Blacklisted : gtk_box_get_homogeneous

// Blacklisted : gtk_box_get_spacing

// Blacklisted : gtk_box_pack_end

// Blacklisted : gtk_box_pack_start

// Unsupported : gtk_box_query_child_packing : unsupported parameter pack_type : GtkPackType* with indirection level of 1

// Blacklisted : gtk_box_reorder_child

// Blacklisted : gtk_box_set_child_packing

// Blacklisted : gtk_box_set_homogeneous

// Blacklisted : gtk_box_set_spacing

// ImplementorIface returns the ImplementorIface interface implemented by Box
func (recv *Box) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Box
func (recv *Box) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Box
func (recv *Box) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Builder is a wrapper around the C record GtkBuilder.
type Builder struct {
	native *C.GtkBuilder
	// parent_instance : record
	// priv : record
}

func BuilderNewFromC(u unsafe.Pointer) *Builder {
	c := (*C.GtkBuilder)(u)
	if c == nil {
		return nil
	}

	g := &Builder{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Builder) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Builder) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Builder with another Builder, and returns true if they represent the same GObject.
func (recv *Builder) Equals(other *Builder) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Builder) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Builder.
// Exercise care, as this is a potentially dangerous function if the Object is not a Builder.
func CastToBuilder(object *gobject.Object) *Builder {
	return BuilderNewFromC(object.ToC())
}

// Blacklisted : gtk_builder_extend_with_template

// Button is a wrapper around the C record GtkButton.
type Button struct {
	native *C.GtkButton
	// Private : bin
	// Private : priv
}

func ButtonNewFromC(u unsafe.Pointer) *Button {
	c := (*C.GtkButton)(u)
	if c == nil {
		return nil
	}

	g := &Button{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Button) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Button) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Button with another Button, and returns true if they represent the same GObject.
func (recv *Button) Equals(other *Button) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Button) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Button) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Button) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Button) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Button) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Button.
// Exercise care, as this is a potentially dangerous function if the Object is not a Button.
func CastToButton(object *gobject.Object) *Button {
	return ButtonNewFromC(object.ToC())
}

type signalButtonActivateDetail struct {
	callback  ButtonSignalActivateCallback
	handlerID C.gulong
}

var signalButtonActivateId int
var signalButtonActivateMap = make(map[int]signalButtonActivateDetail)
var signalButtonActivateLock sync.RWMutex

// ButtonSignalActivateCallback is a callback function for a 'activate' signal emitted from a Button.
type ButtonSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Button) ConnectActivate(callback ButtonSignalActivateCallback) int {
	signalButtonActivateLock.Lock()
	defer signalButtonActivateLock.Unlock()

	signalButtonActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_activate(instance, C.gpointer(uintptr(signalButtonActivateId)))

	detail := signalButtonActivateDetail{callback, handlerID}
	signalButtonActivateMap[signalButtonActivateId] = detail

	return signalButtonActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Button.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Button) DisconnectActivate(connectionID int) {
	signalButtonActivateLock.Lock()
	defer signalButtonActivateLock.Unlock()

	detail, exists := signalButtonActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonActivateMap, connectionID)
}

//export button_activateHandler
func button_activateHandler(_ *C.GObject, data C.gpointer) {
	signalButtonActivateLock.RLock()
	defer signalButtonActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonActivateMap[index].callback
	callback()
}

type signalButtonClickedDetail struct {
	callback  ButtonSignalClickedCallback
	handlerID C.gulong
}

var signalButtonClickedId int
var signalButtonClickedMap = make(map[int]signalButtonClickedDetail)
var signalButtonClickedLock sync.RWMutex

// ButtonSignalClickedCallback is a callback function for a 'clicked' signal emitted from a Button.
type ButtonSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *Button) ConnectClicked(callback ButtonSignalClickedCallback) int {
	signalButtonClickedLock.Lock()
	defer signalButtonClickedLock.Unlock()

	signalButtonClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_clicked(instance, C.gpointer(uintptr(signalButtonClickedId)))

	detail := signalButtonClickedDetail{callback, handlerID}
	signalButtonClickedMap[signalButtonClickedId] = detail

	return signalButtonClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the Button.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *Button) DisconnectClicked(connectionID int) {
	signalButtonClickedLock.Lock()
	defer signalButtonClickedLock.Unlock()

	detail, exists := signalButtonClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonClickedMap, connectionID)
}

//export button_clickedHandler
func button_clickedHandler(_ *C.GObject, data C.gpointer) {
	signalButtonClickedLock.RLock()
	defer signalButtonClickedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonClickedMap[index].callback
	callback()
}

type signalButtonEnterDetail struct {
	callback  ButtonSignalEnterCallback
	handlerID C.gulong
}

var signalButtonEnterId int
var signalButtonEnterMap = make(map[int]signalButtonEnterDetail)
var signalButtonEnterLock sync.RWMutex

// ButtonSignalEnterCallback is a callback function for a 'enter' signal emitted from a Button.
type ButtonSignalEnterCallback func()

/*
ConnectEnter connects the callback to the 'enter' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectEnter to remove it.
*/
func (recv *Button) ConnectEnter(callback ButtonSignalEnterCallback) int {
	signalButtonEnterLock.Lock()
	defer signalButtonEnterLock.Unlock()

	signalButtonEnterId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_enter(instance, C.gpointer(uintptr(signalButtonEnterId)))

	detail := signalButtonEnterDetail{callback, handlerID}
	signalButtonEnterMap[signalButtonEnterId] = detail

	return signalButtonEnterId
}

/*
DisconnectEnter disconnects a callback from the 'enter' signal for the Button.

The connectionID should be a value returned from a call to ConnectEnter.
*/
func (recv *Button) DisconnectEnter(connectionID int) {
	signalButtonEnterLock.Lock()
	defer signalButtonEnterLock.Unlock()

	detail, exists := signalButtonEnterMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonEnterMap, connectionID)
}

//export button_enterHandler
func button_enterHandler(_ *C.GObject, data C.gpointer) {
	signalButtonEnterLock.RLock()
	defer signalButtonEnterLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonEnterMap[index].callback
	callback()
}

type signalButtonLeaveDetail struct {
	callback  ButtonSignalLeaveCallback
	handlerID C.gulong
}

var signalButtonLeaveId int
var signalButtonLeaveMap = make(map[int]signalButtonLeaveDetail)
var signalButtonLeaveLock sync.RWMutex

// ButtonSignalLeaveCallback is a callback function for a 'leave' signal emitted from a Button.
type ButtonSignalLeaveCallback func()

/*
ConnectLeave connects the callback to the 'leave' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectLeave to remove it.
*/
func (recv *Button) ConnectLeave(callback ButtonSignalLeaveCallback) int {
	signalButtonLeaveLock.Lock()
	defer signalButtonLeaveLock.Unlock()

	signalButtonLeaveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_leave(instance, C.gpointer(uintptr(signalButtonLeaveId)))

	detail := signalButtonLeaveDetail{callback, handlerID}
	signalButtonLeaveMap[signalButtonLeaveId] = detail

	return signalButtonLeaveId
}

/*
DisconnectLeave disconnects a callback from the 'leave' signal for the Button.

The connectionID should be a value returned from a call to ConnectLeave.
*/
func (recv *Button) DisconnectLeave(connectionID int) {
	signalButtonLeaveLock.Lock()
	defer signalButtonLeaveLock.Unlock()

	detail, exists := signalButtonLeaveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonLeaveMap, connectionID)
}

//export button_leaveHandler
func button_leaveHandler(_ *C.GObject, data C.gpointer) {
	signalButtonLeaveLock.RLock()
	defer signalButtonLeaveLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonLeaveMap[index].callback
	callback()
}

type signalButtonPressedDetail struct {
	callback  ButtonSignalPressedCallback
	handlerID C.gulong
}

var signalButtonPressedId int
var signalButtonPressedMap = make(map[int]signalButtonPressedDetail)
var signalButtonPressedLock sync.RWMutex

// ButtonSignalPressedCallback is a callback function for a 'pressed' signal emitted from a Button.
type ButtonSignalPressedCallback func()

/*
ConnectPressed connects the callback to the 'pressed' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectPressed to remove it.
*/
func (recv *Button) ConnectPressed(callback ButtonSignalPressedCallback) int {
	signalButtonPressedLock.Lock()
	defer signalButtonPressedLock.Unlock()

	signalButtonPressedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_pressed(instance, C.gpointer(uintptr(signalButtonPressedId)))

	detail := signalButtonPressedDetail{callback, handlerID}
	signalButtonPressedMap[signalButtonPressedId] = detail

	return signalButtonPressedId
}

/*
DisconnectPressed disconnects a callback from the 'pressed' signal for the Button.

The connectionID should be a value returned from a call to ConnectPressed.
*/
func (recv *Button) DisconnectPressed(connectionID int) {
	signalButtonPressedLock.Lock()
	defer signalButtonPressedLock.Unlock()

	detail, exists := signalButtonPressedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonPressedMap, connectionID)
}

//export button_pressedHandler
func button_pressedHandler(_ *C.GObject, data C.gpointer) {
	signalButtonPressedLock.RLock()
	defer signalButtonPressedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonPressedMap[index].callback
	callback()
}

type signalButtonReleasedDetail struct {
	callback  ButtonSignalReleasedCallback
	handlerID C.gulong
}

var signalButtonReleasedId int
var signalButtonReleasedMap = make(map[int]signalButtonReleasedDetail)
var signalButtonReleasedLock sync.RWMutex

// ButtonSignalReleasedCallback is a callback function for a 'released' signal emitted from a Button.
type ButtonSignalReleasedCallback func()

/*
ConnectReleased connects the callback to the 'released' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectReleased to remove it.
*/
func (recv *Button) ConnectReleased(callback ButtonSignalReleasedCallback) int {
	signalButtonReleasedLock.Lock()
	defer signalButtonReleasedLock.Unlock()

	signalButtonReleasedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_released(instance, C.gpointer(uintptr(signalButtonReleasedId)))

	detail := signalButtonReleasedDetail{callback, handlerID}
	signalButtonReleasedMap[signalButtonReleasedId] = detail

	return signalButtonReleasedId
}

/*
DisconnectReleased disconnects a callback from the 'released' signal for the Button.

The connectionID should be a value returned from a call to ConnectReleased.
*/
func (recv *Button) DisconnectReleased(connectionID int) {
	signalButtonReleasedLock.Lock()
	defer signalButtonReleasedLock.Unlock()

	detail, exists := signalButtonReleasedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonReleasedMap, connectionID)
}

//export button_releasedHandler
func button_releasedHandler(_ *C.GObject, data C.gpointer) {
	signalButtonReleasedLock.RLock()
	defer signalButtonReleasedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonReleasedMap[index].callback
	callback()
}

// Blacklisted : gtk_button_new

// Blacklisted : gtk_button_new_from_stock

// Blacklisted : gtk_button_new_with_label

// Blacklisted : gtk_button_new_with_mnemonic

// Blacklisted : gtk_button_clicked

// Blacklisted : gtk_button_enter

// Blacklisted : gtk_button_get_label

// Blacklisted : gtk_button_get_relief

// Blacklisted : gtk_button_get_use_stock

// Blacklisted : gtk_button_get_use_underline

// Blacklisted : gtk_button_leave

// Blacklisted : gtk_button_pressed

// Blacklisted : gtk_button_released

// Blacklisted : gtk_button_set_label

// Blacklisted : gtk_button_set_relief

// Blacklisted : gtk_button_set_use_stock

// Blacklisted : gtk_button_set_use_underline

// ImplementorIface returns the ImplementorIface interface implemented by Button
func (recv *Button) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by Button
func (recv *Button) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by Button
func (recv *Button) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Button
func (recv *Button) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ButtonAccessible is a wrapper around the C record GtkButtonAccessible.
type ButtonAccessible struct {
	native *C.GtkButtonAccessible
	// parent : record
	// priv : record
}

func ButtonAccessibleNewFromC(u unsafe.Pointer) *ButtonAccessible {
	c := (*C.GtkButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonAccessible with another ButtonAccessible, and returns true if they represent the same GObject.
func (recv *ButtonAccessible) Equals(other *ButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ButtonAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ButtonAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ButtonAccessible.
func CastToButtonAccessible(object *gobject.Object) *ButtonAccessible {
	return ButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ButtonBox is a wrapper around the C record GtkButtonBox.
type ButtonBox struct {
	native *C.GtkButtonBox
	// box : record
	// Private : priv
}

func ButtonBoxNewFromC(u unsafe.Pointer) *ButtonBox {
	c := (*C.GtkButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &ButtonBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ButtonBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonBox with another ButtonBox, and returns true if they represent the same GObject.
func (recv *ButtonBox) Equals(other *ButtonBox) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *ButtonBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ButtonBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ButtonBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ButtonBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to ButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ButtonBox.
func CastToButtonBox(object *gobject.Object) *ButtonBox {
	return ButtonBoxNewFromC(object.ToC())
}

// Blacklisted : gtk_button_box_get_layout

// Blacklisted : gtk_button_box_set_child_secondary

// Blacklisted : gtk_button_box_set_layout

// ImplementorIface returns the ImplementorIface interface implemented by ButtonBox
func (recv *ButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ButtonBox
func (recv *ButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ButtonBox
func (recv *ButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Calendar is a wrapper around the C record GtkCalendar.
type Calendar struct {
	native *C.GtkCalendar
	// widget : record
	// priv : record
}

func CalendarNewFromC(u unsafe.Pointer) *Calendar {
	c := (*C.GtkCalendar)(u)
	if c == nil {
		return nil
	}

	g := &Calendar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Calendar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Calendar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Calendar with another Calendar, and returns true if they represent the same GObject.
func (recv *Calendar) Equals(other *Calendar) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Calendar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Calendar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Calendar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Calendar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Calendar.
func CastToCalendar(object *gobject.Object) *Calendar {
	return CalendarNewFromC(object.ToC())
}

type signalCalendarDaySelectedDetail struct {
	callback  CalendarSignalDaySelectedCallback
	handlerID C.gulong
}

var signalCalendarDaySelectedId int
var signalCalendarDaySelectedMap = make(map[int]signalCalendarDaySelectedDetail)
var signalCalendarDaySelectedLock sync.RWMutex

// CalendarSignalDaySelectedCallback is a callback function for a 'day-selected' signal emitted from a Calendar.
type CalendarSignalDaySelectedCallback func()

/*
ConnectDaySelected connects the callback to the 'day-selected' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectDaySelected to remove it.
*/
func (recv *Calendar) ConnectDaySelected(callback CalendarSignalDaySelectedCallback) int {
	signalCalendarDaySelectedLock.Lock()
	defer signalCalendarDaySelectedLock.Unlock()

	signalCalendarDaySelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_day_selected(instance, C.gpointer(uintptr(signalCalendarDaySelectedId)))

	detail := signalCalendarDaySelectedDetail{callback, handlerID}
	signalCalendarDaySelectedMap[signalCalendarDaySelectedId] = detail

	return signalCalendarDaySelectedId
}

/*
DisconnectDaySelected disconnects a callback from the 'day-selected' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectDaySelected.
*/
func (recv *Calendar) DisconnectDaySelected(connectionID int) {
	signalCalendarDaySelectedLock.Lock()
	defer signalCalendarDaySelectedLock.Unlock()

	detail, exists := signalCalendarDaySelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarDaySelectedMap, connectionID)
}

//export calendar_daySelectedHandler
func calendar_daySelectedHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarDaySelectedLock.RLock()
	defer signalCalendarDaySelectedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarDaySelectedMap[index].callback
	callback()
}

type signalCalendarDaySelectedDoubleClickDetail struct {
	callback  CalendarSignalDaySelectedDoubleClickCallback
	handlerID C.gulong
}

var signalCalendarDaySelectedDoubleClickId int
var signalCalendarDaySelectedDoubleClickMap = make(map[int]signalCalendarDaySelectedDoubleClickDetail)
var signalCalendarDaySelectedDoubleClickLock sync.RWMutex

// CalendarSignalDaySelectedDoubleClickCallback is a callback function for a 'day-selected-double-click' signal emitted from a Calendar.
type CalendarSignalDaySelectedDoubleClickCallback func()

/*
ConnectDaySelectedDoubleClick connects the callback to the 'day-selected-double-click' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectDaySelectedDoubleClick to remove it.
*/
func (recv *Calendar) ConnectDaySelectedDoubleClick(callback CalendarSignalDaySelectedDoubleClickCallback) int {
	signalCalendarDaySelectedDoubleClickLock.Lock()
	defer signalCalendarDaySelectedDoubleClickLock.Unlock()

	signalCalendarDaySelectedDoubleClickId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_day_selected_double_click(instance, C.gpointer(uintptr(signalCalendarDaySelectedDoubleClickId)))

	detail := signalCalendarDaySelectedDoubleClickDetail{callback, handlerID}
	signalCalendarDaySelectedDoubleClickMap[signalCalendarDaySelectedDoubleClickId] = detail

	return signalCalendarDaySelectedDoubleClickId
}

/*
DisconnectDaySelectedDoubleClick disconnects a callback from the 'day-selected-double-click' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectDaySelectedDoubleClick.
*/
func (recv *Calendar) DisconnectDaySelectedDoubleClick(connectionID int) {
	signalCalendarDaySelectedDoubleClickLock.Lock()
	defer signalCalendarDaySelectedDoubleClickLock.Unlock()

	detail, exists := signalCalendarDaySelectedDoubleClickMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarDaySelectedDoubleClickMap, connectionID)
}

//export calendar_daySelectedDoubleClickHandler
func calendar_daySelectedDoubleClickHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarDaySelectedDoubleClickLock.RLock()
	defer signalCalendarDaySelectedDoubleClickLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarDaySelectedDoubleClickMap[index].callback
	callback()
}

type signalCalendarMonthChangedDetail struct {
	callback  CalendarSignalMonthChangedCallback
	handlerID C.gulong
}

var signalCalendarMonthChangedId int
var signalCalendarMonthChangedMap = make(map[int]signalCalendarMonthChangedDetail)
var signalCalendarMonthChangedLock sync.RWMutex

// CalendarSignalMonthChangedCallback is a callback function for a 'month-changed' signal emitted from a Calendar.
type CalendarSignalMonthChangedCallback func()

/*
ConnectMonthChanged connects the callback to the 'month-changed' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectMonthChanged to remove it.
*/
func (recv *Calendar) ConnectMonthChanged(callback CalendarSignalMonthChangedCallback) int {
	signalCalendarMonthChangedLock.Lock()
	defer signalCalendarMonthChangedLock.Unlock()

	signalCalendarMonthChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_month_changed(instance, C.gpointer(uintptr(signalCalendarMonthChangedId)))

	detail := signalCalendarMonthChangedDetail{callback, handlerID}
	signalCalendarMonthChangedMap[signalCalendarMonthChangedId] = detail

	return signalCalendarMonthChangedId
}

/*
DisconnectMonthChanged disconnects a callback from the 'month-changed' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectMonthChanged.
*/
func (recv *Calendar) DisconnectMonthChanged(connectionID int) {
	signalCalendarMonthChangedLock.Lock()
	defer signalCalendarMonthChangedLock.Unlock()

	detail, exists := signalCalendarMonthChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarMonthChangedMap, connectionID)
}

//export calendar_monthChangedHandler
func calendar_monthChangedHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarMonthChangedLock.RLock()
	defer signalCalendarMonthChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarMonthChangedMap[index].callback
	callback()
}

type signalCalendarNextMonthDetail struct {
	callback  CalendarSignalNextMonthCallback
	handlerID C.gulong
}

var signalCalendarNextMonthId int
var signalCalendarNextMonthMap = make(map[int]signalCalendarNextMonthDetail)
var signalCalendarNextMonthLock sync.RWMutex

// CalendarSignalNextMonthCallback is a callback function for a 'next-month' signal emitted from a Calendar.
type CalendarSignalNextMonthCallback func()

/*
ConnectNextMonth connects the callback to the 'next-month' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectNextMonth to remove it.
*/
func (recv *Calendar) ConnectNextMonth(callback CalendarSignalNextMonthCallback) int {
	signalCalendarNextMonthLock.Lock()
	defer signalCalendarNextMonthLock.Unlock()

	signalCalendarNextMonthId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_next_month(instance, C.gpointer(uintptr(signalCalendarNextMonthId)))

	detail := signalCalendarNextMonthDetail{callback, handlerID}
	signalCalendarNextMonthMap[signalCalendarNextMonthId] = detail

	return signalCalendarNextMonthId
}

/*
DisconnectNextMonth disconnects a callback from the 'next-month' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectNextMonth.
*/
func (recv *Calendar) DisconnectNextMonth(connectionID int) {
	signalCalendarNextMonthLock.Lock()
	defer signalCalendarNextMonthLock.Unlock()

	detail, exists := signalCalendarNextMonthMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarNextMonthMap, connectionID)
}

//export calendar_nextMonthHandler
func calendar_nextMonthHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarNextMonthLock.RLock()
	defer signalCalendarNextMonthLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarNextMonthMap[index].callback
	callback()
}

type signalCalendarNextYearDetail struct {
	callback  CalendarSignalNextYearCallback
	handlerID C.gulong
}

var signalCalendarNextYearId int
var signalCalendarNextYearMap = make(map[int]signalCalendarNextYearDetail)
var signalCalendarNextYearLock sync.RWMutex

// CalendarSignalNextYearCallback is a callback function for a 'next-year' signal emitted from a Calendar.
type CalendarSignalNextYearCallback func()

/*
ConnectNextYear connects the callback to the 'next-year' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectNextYear to remove it.
*/
func (recv *Calendar) ConnectNextYear(callback CalendarSignalNextYearCallback) int {
	signalCalendarNextYearLock.Lock()
	defer signalCalendarNextYearLock.Unlock()

	signalCalendarNextYearId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_next_year(instance, C.gpointer(uintptr(signalCalendarNextYearId)))

	detail := signalCalendarNextYearDetail{callback, handlerID}
	signalCalendarNextYearMap[signalCalendarNextYearId] = detail

	return signalCalendarNextYearId
}

/*
DisconnectNextYear disconnects a callback from the 'next-year' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectNextYear.
*/
func (recv *Calendar) DisconnectNextYear(connectionID int) {
	signalCalendarNextYearLock.Lock()
	defer signalCalendarNextYearLock.Unlock()

	detail, exists := signalCalendarNextYearMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarNextYearMap, connectionID)
}

//export calendar_nextYearHandler
func calendar_nextYearHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarNextYearLock.RLock()
	defer signalCalendarNextYearLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarNextYearMap[index].callback
	callback()
}

type signalCalendarPrevMonthDetail struct {
	callback  CalendarSignalPrevMonthCallback
	handlerID C.gulong
}

var signalCalendarPrevMonthId int
var signalCalendarPrevMonthMap = make(map[int]signalCalendarPrevMonthDetail)
var signalCalendarPrevMonthLock sync.RWMutex

// CalendarSignalPrevMonthCallback is a callback function for a 'prev-month' signal emitted from a Calendar.
type CalendarSignalPrevMonthCallback func()

/*
ConnectPrevMonth connects the callback to the 'prev-month' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectPrevMonth to remove it.
*/
func (recv *Calendar) ConnectPrevMonth(callback CalendarSignalPrevMonthCallback) int {
	signalCalendarPrevMonthLock.Lock()
	defer signalCalendarPrevMonthLock.Unlock()

	signalCalendarPrevMonthId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_prev_month(instance, C.gpointer(uintptr(signalCalendarPrevMonthId)))

	detail := signalCalendarPrevMonthDetail{callback, handlerID}
	signalCalendarPrevMonthMap[signalCalendarPrevMonthId] = detail

	return signalCalendarPrevMonthId
}

/*
DisconnectPrevMonth disconnects a callback from the 'prev-month' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectPrevMonth.
*/
func (recv *Calendar) DisconnectPrevMonth(connectionID int) {
	signalCalendarPrevMonthLock.Lock()
	defer signalCalendarPrevMonthLock.Unlock()

	detail, exists := signalCalendarPrevMonthMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarPrevMonthMap, connectionID)
}

//export calendar_prevMonthHandler
func calendar_prevMonthHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarPrevMonthLock.RLock()
	defer signalCalendarPrevMonthLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarPrevMonthMap[index].callback
	callback()
}

type signalCalendarPrevYearDetail struct {
	callback  CalendarSignalPrevYearCallback
	handlerID C.gulong
}

var signalCalendarPrevYearId int
var signalCalendarPrevYearMap = make(map[int]signalCalendarPrevYearDetail)
var signalCalendarPrevYearLock sync.RWMutex

// CalendarSignalPrevYearCallback is a callback function for a 'prev-year' signal emitted from a Calendar.
type CalendarSignalPrevYearCallback func()

/*
ConnectPrevYear connects the callback to the 'prev-year' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectPrevYear to remove it.
*/
func (recv *Calendar) ConnectPrevYear(callback CalendarSignalPrevYearCallback) int {
	signalCalendarPrevYearLock.Lock()
	defer signalCalendarPrevYearLock.Unlock()

	signalCalendarPrevYearId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_prev_year(instance, C.gpointer(uintptr(signalCalendarPrevYearId)))

	detail := signalCalendarPrevYearDetail{callback, handlerID}
	signalCalendarPrevYearMap[signalCalendarPrevYearId] = detail

	return signalCalendarPrevYearId
}

/*
DisconnectPrevYear disconnects a callback from the 'prev-year' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectPrevYear.
*/
func (recv *Calendar) DisconnectPrevYear(connectionID int) {
	signalCalendarPrevYearLock.Lock()
	defer signalCalendarPrevYearLock.Unlock()

	detail, exists := signalCalendarPrevYearMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarPrevYearMap, connectionID)
}

//export calendar_prevYearHandler
func calendar_prevYearHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarPrevYearLock.RLock()
	defer signalCalendarPrevYearLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarPrevYearMap[index].callback
	callback()
}

// Blacklisted : gtk_calendar_new

// Blacklisted : gtk_calendar_clear_marks

// Blacklisted : gtk_calendar_get_date

// Blacklisted : gtk_calendar_mark_day

// Blacklisted : gtk_calendar_select_day

// Blacklisted : gtk_calendar_select_month

// Blacklisted : gtk_calendar_unmark_day

// ImplementorIface returns the ImplementorIface interface implemented by Calendar
func (recv *Calendar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Calendar
func (recv *Calendar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellAccessible is a wrapper around the C record GtkCellAccessible.
type CellAccessible struct {
	native *C.GtkCellAccessible
	// parent : record
	// priv : record
}

func CellAccessibleNewFromC(u unsafe.Pointer) *CellAccessible {
	c := (*C.GtkCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &CellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAccessible with another CellAccessible, and returns true if they represent the same GObject.
func (recv *CellAccessible) Equals(other *CellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// Accessible upcasts to *Accessible
func (recv *CellAccessible) Accessible() *Accessible {
	return AccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellAccessible) Object() *atk.Object {
	return recv.Accessible().Object()
}

// CastToWidget down casts any arbitrary Object to CellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAccessible.
func CastToCellAccessible(object *gobject.Object) *CellAccessible {
	return CellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by CellAccessible
func (recv *CellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by CellAccessible
func (recv *CellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// CellArea is a wrapper around the C record GtkCellArea.
type CellArea struct {
	native *C.GtkCellArea
	// Private : parent_instance
	// Private : priv
}

func CellAreaNewFromC(u unsafe.Pointer) *CellArea {
	c := (*C.GtkCellArea)(u)
	if c == nil {
		return nil
	}

	g := &CellArea{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellArea) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellArea) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellArea with another CellArea, and returns true if they represent the same GObject.
func (recv *CellArea) Equals(other *CellArea) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellArea) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellArea) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to CellArea.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellArea.
func CastToCellArea(object *gobject.Object) *CellArea {
	return CellAreaNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by CellArea
func (recv *CellArea) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellArea
func (recv *CellArea) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// CellAreaBox is a wrapper around the C record GtkCellAreaBox.
type CellAreaBox struct {
	native *C.GtkCellAreaBox
	// Private : parent_instance
	// Private : priv
}

func CellAreaBoxNewFromC(u unsafe.Pointer) *CellAreaBox {
	c := (*C.GtkCellAreaBox)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellAreaBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellAreaBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaBox with another CellAreaBox, and returns true if they represent the same GObject.
func (recv *CellAreaBox) Equals(other *CellAreaBox) bool {
	return other.ToC() == recv.ToC()
}

// CellArea upcasts to *CellArea
func (recv *CellAreaBox) CellArea() *CellArea {
	return CellAreaNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellAreaBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellArea().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellAreaBox) Object() *gobject.Object {
	return recv.CellArea().Object()
}

// CastToWidget down casts any arbitrary Object to CellAreaBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAreaBox.
func CastToCellAreaBox(object *gobject.Object) *CellAreaBox {
	return CellAreaBoxNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by CellAreaBox
func (recv *CellAreaBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellAreaBox
func (recv *CellAreaBox) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by CellAreaBox
func (recv *CellAreaBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CellAreaContext is a wrapper around the C record GtkCellAreaContext.
type CellAreaContext struct {
	native *C.GtkCellAreaContext
	// Private : parent_instance
	// Private : priv
}

func CellAreaContextNewFromC(u unsafe.Pointer) *CellAreaContext {
	c := (*C.GtkCellAreaContext)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellAreaContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellAreaContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaContext with another CellAreaContext, and returns true if they represent the same GObject.
func (recv *CellAreaContext) Equals(other *CellAreaContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *CellAreaContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to CellAreaContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAreaContext.
func CastToCellAreaContext(object *gobject.Object) *CellAreaContext {
	return CellAreaContextNewFromC(object.ToC())
}

// Blacklisted : gtk_cell_area_context_allocate

// Blacklisted : gtk_cell_area_context_reset

// CellRenderer is a wrapper around the C record GtkCellRenderer.
type CellRenderer struct {
	native *C.GtkCellRenderer
	// parent_instance : record
	// Private : priv
}

func CellRendererNewFromC(u unsafe.Pointer) *CellRenderer {
	c := (*C.GtkCellRenderer)(u)
	if c == nil {
		return nil
	}

	g := &CellRenderer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRenderer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRenderer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRenderer with another CellRenderer, and returns true if they represent the same GObject.
func (recv *CellRenderer) Equals(other *CellRenderer) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRenderer) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellRenderer) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to CellRenderer.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRenderer.
func CastToCellRenderer(object *gobject.Object) *CellRenderer {
	return CellRendererNewFromC(object.ToC())
}

// Unsupported : gtk_cell_renderer_activate : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Blacklisted : gtk_cell_renderer_get_fixed_size

// Blacklisted : gtk_cell_renderer_get_size

// Blacklisted : gtk_cell_renderer_render

// Blacklisted : gtk_cell_renderer_set_fixed_size

// Unsupported : gtk_cell_renderer_start_editing : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// CellRendererAccel is a wrapper around the C record GtkCellRendererAccel.
type CellRendererAccel struct {
	native *C.GtkCellRendererAccel
	// parent : record
	// Private : priv
}

func CellRendererAccelNewFromC(u unsafe.Pointer) *CellRendererAccel {
	c := (*C.GtkCellRendererAccel)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererAccel{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererAccel) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererAccel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererAccel with another CellRendererAccel, and returns true if they represent the same GObject.
func (recv *CellRendererAccel) Equals(other *CellRendererAccel) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererAccel) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererAccel) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererAccel) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererAccel) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererAccel.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererAccel.
func CastToCellRendererAccel(object *gobject.Object) *CellRendererAccel {
	return CellRendererAccelNewFromC(object.ToC())
}

// CellRendererCombo is a wrapper around the C record GtkCellRendererCombo.
type CellRendererCombo struct {
	native *C.GtkCellRendererCombo
	// parent : record
	// Private : priv
}

func CellRendererComboNewFromC(u unsafe.Pointer) *CellRendererCombo {
	c := (*C.GtkCellRendererCombo)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererCombo{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererCombo) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererCombo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererCombo with another CellRendererCombo, and returns true if they represent the same GObject.
func (recv *CellRendererCombo) Equals(other *CellRendererCombo) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererCombo) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererCombo) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererCombo) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererCombo) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererCombo.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererCombo.
func CastToCellRendererCombo(object *gobject.Object) *CellRendererCombo {
	return CellRendererComboNewFromC(object.ToC())
}

// CellRendererPixbuf is a wrapper around the C record GtkCellRendererPixbuf.
type CellRendererPixbuf struct {
	native *C.GtkCellRendererPixbuf
	// parent : record
	// Private : priv
}

func CellRendererPixbufNewFromC(u unsafe.Pointer) *CellRendererPixbuf {
	c := (*C.GtkCellRendererPixbuf)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererPixbuf{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererPixbuf) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererPixbuf) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererPixbuf with another CellRendererPixbuf, and returns true if they represent the same GObject.
func (recv *CellRendererPixbuf) Equals(other *CellRendererPixbuf) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererPixbuf) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererPixbuf) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererPixbuf) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererPixbuf.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererPixbuf.
func CastToCellRendererPixbuf(object *gobject.Object) *CellRendererPixbuf {
	return CellRendererPixbufNewFromC(object.ToC())
}

// Blacklisted : gtk_cell_renderer_pixbuf_new

// CellRendererProgress is a wrapper around the C record GtkCellRendererProgress.
type CellRendererProgress struct {
	native *C.GtkCellRendererProgress
	// parent_instance : record
	// Private : priv
}

func CellRendererProgressNewFromC(u unsafe.Pointer) *CellRendererProgress {
	c := (*C.GtkCellRendererProgress)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererProgress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererProgress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererProgress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererProgress with another CellRendererProgress, and returns true if they represent the same GObject.
func (recv *CellRendererProgress) Equals(other *CellRendererProgress) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererProgress) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererProgress) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererProgress) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererProgress.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererProgress.
func CastToCellRendererProgress(object *gobject.Object) *CellRendererProgress {
	return CellRendererProgressNewFromC(object.ToC())
}

// Orientable returns the Orientable interface implemented by CellRendererProgress
func (recv *CellRendererProgress) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CellRendererSpin is a wrapper around the C record GtkCellRendererSpin.
type CellRendererSpin struct {
	native *C.GtkCellRendererSpin
	// parent : record
	// Private : priv
}

func CellRendererSpinNewFromC(u unsafe.Pointer) *CellRendererSpin {
	c := (*C.GtkCellRendererSpin)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpin{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererSpin) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererSpin) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererSpin with another CellRendererSpin, and returns true if they represent the same GObject.
func (recv *CellRendererSpin) Equals(other *CellRendererSpin) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererSpin) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererSpin) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererSpin) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererSpin) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererSpin.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererSpin.
func CastToCellRendererSpin(object *gobject.Object) *CellRendererSpin {
	return CellRendererSpinNewFromC(object.ToC())
}

// CellRendererSpinner is a wrapper around the C record GtkCellRendererSpinner.
type CellRendererSpinner struct {
	native *C.GtkCellRendererSpinner
	// parent : record
	// Private : priv
}

func CellRendererSpinnerNewFromC(u unsafe.Pointer) *CellRendererSpinner {
	c := (*C.GtkCellRendererSpinner)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpinner{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererSpinner) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererSpinner) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererSpinner with another CellRendererSpinner, and returns true if they represent the same GObject.
func (recv *CellRendererSpinner) Equals(other *CellRendererSpinner) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererSpinner) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererSpinner) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererSpinner) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererSpinner.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererSpinner.
func CastToCellRendererSpinner(object *gobject.Object) *CellRendererSpinner {
	return CellRendererSpinnerNewFromC(object.ToC())
}

// CellRendererText is a wrapper around the C record GtkCellRendererText.
type CellRendererText struct {
	native *C.GtkCellRendererText
	// parent : record
	// Private : priv
}

func CellRendererTextNewFromC(u unsafe.Pointer) *CellRendererText {
	c := (*C.GtkCellRendererText)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererText{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererText) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererText) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererText with another CellRendererText, and returns true if they represent the same GObject.
func (recv *CellRendererText) Equals(other *CellRendererText) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererText) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererText) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererText) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererText.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererText.
func CastToCellRendererText(object *gobject.Object) *CellRendererText {
	return CellRendererTextNewFromC(object.ToC())
}

type signalCellRendererTextEditedDetail struct {
	callback  CellRendererTextSignalEditedCallback
	handlerID C.gulong
}

var signalCellRendererTextEditedId int
var signalCellRendererTextEditedMap = make(map[int]signalCellRendererTextEditedDetail)
var signalCellRendererTextEditedLock sync.RWMutex

// CellRendererTextSignalEditedCallback is a callback function for a 'edited' signal emitted from a CellRendererText.
type CellRendererTextSignalEditedCallback func(path string, newText string)

/*
ConnectEdited connects the callback to the 'edited' signal for the CellRendererText.

The returned value represents the connection, and may be passed to DisconnectEdited to remove it.
*/
func (recv *CellRendererText) ConnectEdited(callback CellRendererTextSignalEditedCallback) int {
	signalCellRendererTextEditedLock.Lock()
	defer signalCellRendererTextEditedLock.Unlock()

	signalCellRendererTextEditedId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellRendererText_signal_connect_edited(instance, C.gpointer(uintptr(signalCellRendererTextEditedId)))

	detail := signalCellRendererTextEditedDetail{callback, handlerID}
	signalCellRendererTextEditedMap[signalCellRendererTextEditedId] = detail

	return signalCellRendererTextEditedId
}

/*
DisconnectEdited disconnects a callback from the 'edited' signal for the CellRendererText.

The connectionID should be a value returned from a call to ConnectEdited.
*/
func (recv *CellRendererText) DisconnectEdited(connectionID int) {
	signalCellRendererTextEditedLock.Lock()
	defer signalCellRendererTextEditedLock.Unlock()

	detail, exists := signalCellRendererTextEditedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellRendererTextEditedMap, connectionID)
}

//export cellrenderertext_editedHandler
func cellrenderertext_editedHandler(_ *C.GObject, c_path *C.gchar, c_new_text *C.gchar, data C.gpointer) {
	signalCellRendererTextEditedLock.RLock()
	defer signalCellRendererTextEditedLock.RUnlock()

	path := C.GoString(c_path)

	newText := C.GoString(c_new_text)

	index := int(uintptr(data))
	callback := signalCellRendererTextEditedMap[index].callback
	callback(path, newText)
}

// Blacklisted : gtk_cell_renderer_text_new

// Blacklisted : gtk_cell_renderer_text_set_fixed_height_from_font

// CellRendererToggle is a wrapper around the C record GtkCellRendererToggle.
type CellRendererToggle struct {
	native *C.GtkCellRendererToggle
	// parent : record
	// Private : priv
}

func CellRendererToggleNewFromC(u unsafe.Pointer) *CellRendererToggle {
	c := (*C.GtkCellRendererToggle)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererToggle{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererToggle) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererToggle) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererToggle with another CellRendererToggle, and returns true if they represent the same GObject.
func (recv *CellRendererToggle) Equals(other *CellRendererToggle) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererToggle) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererToggle) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererToggle) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererToggle.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererToggle.
func CastToCellRendererToggle(object *gobject.Object) *CellRendererToggle {
	return CellRendererToggleNewFromC(object.ToC())
}

type signalCellRendererToggleToggledDetail struct {
	callback  CellRendererToggleSignalToggledCallback
	handlerID C.gulong
}

var signalCellRendererToggleToggledId int
var signalCellRendererToggleToggledMap = make(map[int]signalCellRendererToggleToggledDetail)
var signalCellRendererToggleToggledLock sync.RWMutex

// CellRendererToggleSignalToggledCallback is a callback function for a 'toggled' signal emitted from a CellRendererToggle.
type CellRendererToggleSignalToggledCallback func(path string)

/*
ConnectToggled connects the callback to the 'toggled' signal for the CellRendererToggle.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *CellRendererToggle) ConnectToggled(callback CellRendererToggleSignalToggledCallback) int {
	signalCellRendererToggleToggledLock.Lock()
	defer signalCellRendererToggleToggledLock.Unlock()

	signalCellRendererToggleToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellRendererToggle_signal_connect_toggled(instance, C.gpointer(uintptr(signalCellRendererToggleToggledId)))

	detail := signalCellRendererToggleToggledDetail{callback, handlerID}
	signalCellRendererToggleToggledMap[signalCellRendererToggleToggledId] = detail

	return signalCellRendererToggleToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the CellRendererToggle.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *CellRendererToggle) DisconnectToggled(connectionID int) {
	signalCellRendererToggleToggledLock.Lock()
	defer signalCellRendererToggleToggledLock.Unlock()

	detail, exists := signalCellRendererToggleToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellRendererToggleToggledMap, connectionID)
}

//export cellrenderertoggle_toggledHandler
func cellrenderertoggle_toggledHandler(_ *C.GObject, c_path *C.gchar, data C.gpointer) {
	signalCellRendererToggleToggledLock.RLock()
	defer signalCellRendererToggleToggledLock.RUnlock()

	path := C.GoString(c_path)

	index := int(uintptr(data))
	callback := signalCellRendererToggleToggledMap[index].callback
	callback(path)
}

// Blacklisted : gtk_cell_renderer_toggle_new

// Blacklisted : gtk_cell_renderer_toggle_get_active

// Blacklisted : gtk_cell_renderer_toggle_get_radio

// Blacklisted : gtk_cell_renderer_toggle_set_active

// Blacklisted : gtk_cell_renderer_toggle_set_radio

// CellView is a wrapper around the C record GtkCellView.
type CellView struct {
	native *C.GtkCellView
	// parent_instance : record
	// Private : priv
}

func CellViewNewFromC(u unsafe.Pointer) *CellView {
	c := (*C.GtkCellView)(u)
	if c == nil {
		return nil
	}

	g := &CellView{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellView) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellView with another CellView, and returns true if they represent the same GObject.
func (recv *CellView) Equals(other *CellView) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *CellView) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellView) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to CellView.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellView.
func CastToCellView(object *gobject.Object) *CellView {
	return CellViewNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by CellView
func (recv *CellView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CellView
func (recv *CellView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellView
func (recv *CellView) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by CellView
func (recv *CellView) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CheckButton is a wrapper around the C record GtkCheckButton.
type CheckButton struct {
	native *C.GtkCheckButton
	// toggle_button : record
}

func CheckButtonNewFromC(u unsafe.Pointer) *CheckButton {
	c := (*C.GtkCheckButton)(u)
	if c == nil {
		return nil
	}

	g := &CheckButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CheckButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CheckButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckButton with another CheckButton, and returns true if they represent the same GObject.
func (recv *CheckButton) Equals(other *CheckButton) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButton upcasts to *ToggleButton
func (recv *CheckButton) ToggleButton() *ToggleButton {
	return ToggleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *CheckButton) Button() *Button {
	return recv.ToggleButton().Button()
}

// Bin upcasts to *Bin
func (recv *CheckButton) Bin() *Bin {
	return recv.ToggleButton().Bin()
}

// Container upcasts to *Container
func (recv *CheckButton) Container() *Container {
	return recv.ToggleButton().Container()
}

// Widget upcasts to *Widget
func (recv *CheckButton) Widget() *Widget {
	return recv.ToggleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CheckButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CheckButton) Object() *gobject.Object {
	return recv.ToggleButton().Object()
}

// CastToWidget down casts any arbitrary Object to CheckButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckButton.
func CastToCheckButton(object *gobject.Object) *CheckButton {
	return CheckButtonNewFromC(object.ToC())
}

// Blacklisted : gtk_check_button_new

// Blacklisted : gtk_check_button_new_with_label

// Blacklisted : gtk_check_button_new_with_mnemonic

// ImplementorIface returns the ImplementorIface interface implemented by CheckButton
func (recv *CheckButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by CheckButton
func (recv *CheckButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by CheckButton
func (recv *CheckButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CheckButton
func (recv *CheckButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CheckMenuItem is a wrapper around the C record GtkCheckMenuItem.
type CheckMenuItem struct {
	native *C.GtkCheckMenuItem
	// menu_item : record
	// Private : priv
}

func CheckMenuItemNewFromC(u unsafe.Pointer) *CheckMenuItem {
	c := (*C.GtkCheckMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CheckMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CheckMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckMenuItem with another CheckMenuItem, and returns true if they represent the same GObject.
func (recv *CheckMenuItem) Equals(other *CheckMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// MenuItem upcasts to *MenuItem
func (recv *CheckMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *CheckMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *CheckMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *CheckMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CheckMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CheckMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to CheckMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckMenuItem.
func CastToCheckMenuItem(object *gobject.Object) *CheckMenuItem {
	return CheckMenuItemNewFromC(object.ToC())
}

type signalCheckMenuItemToggledDetail struct {
	callback  CheckMenuItemSignalToggledCallback
	handlerID C.gulong
}

var signalCheckMenuItemToggledId int
var signalCheckMenuItemToggledMap = make(map[int]signalCheckMenuItemToggledDetail)
var signalCheckMenuItemToggledLock sync.RWMutex

// CheckMenuItemSignalToggledCallback is a callback function for a 'toggled' signal emitted from a CheckMenuItem.
type CheckMenuItemSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the CheckMenuItem.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *CheckMenuItem) ConnectToggled(callback CheckMenuItemSignalToggledCallback) int {
	signalCheckMenuItemToggledLock.Lock()
	defer signalCheckMenuItemToggledLock.Unlock()

	signalCheckMenuItemToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.CheckMenuItem_signal_connect_toggled(instance, C.gpointer(uintptr(signalCheckMenuItemToggledId)))

	detail := signalCheckMenuItemToggledDetail{callback, handlerID}
	signalCheckMenuItemToggledMap[signalCheckMenuItemToggledId] = detail

	return signalCheckMenuItemToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the CheckMenuItem.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *CheckMenuItem) DisconnectToggled(connectionID int) {
	signalCheckMenuItemToggledLock.Lock()
	defer signalCheckMenuItemToggledLock.Unlock()

	detail, exists := signalCheckMenuItemToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCheckMenuItemToggledMap, connectionID)
}

//export checkmenuitem_toggledHandler
func checkmenuitem_toggledHandler(_ *C.GObject, data C.gpointer) {
	signalCheckMenuItemToggledLock.RLock()
	defer signalCheckMenuItemToggledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCheckMenuItemToggledMap[index].callback
	callback()
}

// Blacklisted : gtk_check_menu_item_new

// Blacklisted : gtk_check_menu_item_new_with_label

// Blacklisted : gtk_check_menu_item_new_with_mnemonic

// Blacklisted : gtk_check_menu_item_get_active

// Blacklisted : gtk_check_menu_item_get_inconsistent

// Blacklisted : gtk_check_menu_item_set_active

// Blacklisted : gtk_check_menu_item_set_inconsistent

// Blacklisted : gtk_check_menu_item_toggled

// ImplementorIface returns the ImplementorIface interface implemented by CheckMenuItem
func (recv *CheckMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CheckMenuItemAccessible is a wrapper around the C record GtkCheckMenuItemAccessible.
type CheckMenuItemAccessible struct {
	native *C.GtkCheckMenuItemAccessible
	// parent : record
	// priv : record
}

func CheckMenuItemAccessibleNewFromC(u unsafe.Pointer) *CheckMenuItemAccessible {
	c := (*C.GtkCheckMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItemAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CheckMenuItemAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CheckMenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckMenuItemAccessible with another CheckMenuItemAccessible, and returns true if they represent the same GObject.
func (recv *CheckMenuItemAccessible) Equals(other *CheckMenuItemAccessible) bool {
	return other.ToC() == recv.ToC()
}

// MenuItemAccessible upcasts to *MenuItemAccessible
func (recv *CheckMenuItemAccessible) MenuItemAccessible() *MenuItemAccessible {
	return MenuItemAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *CheckMenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.MenuItemAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *CheckMenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.MenuItemAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *CheckMenuItemAccessible) Accessible() *Accessible {
	return recv.MenuItemAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *CheckMenuItemAccessible) Object() *atk.Object {
	return recv.MenuItemAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to CheckMenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckMenuItemAccessible.
func CastToCheckMenuItemAccessible(object *gobject.Object) *CheckMenuItemAccessible {
	return CheckMenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Clipboard is a wrapper around the C record GtkClipboard.
type Clipboard struct {
	native *C.GtkClipboard
}

func ClipboardNewFromC(u unsafe.Pointer) *Clipboard {
	c := (*C.GtkClipboard)(u)
	if c == nil {
		return nil
	}

	g := &Clipboard{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Clipboard) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Clipboard) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Clipboard with another Clipboard, and returns true if they represent the same GObject.
func (recv *Clipboard) Equals(other *Clipboard) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Clipboard) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Clipboard.
// Exercise care, as this is a potentially dangerous function if the Object is not a Clipboard.
func CastToClipboard(object *gobject.Object) *Clipboard {
	return ClipboardNewFromC(object.ToC())
}

// Blacklisted : gtk_clipboard_get

// Blacklisted : gtk_clipboard_clear

// Blacklisted : gtk_clipboard_get_owner

// Unsupported : gtk_clipboard_request_contents : unsupported parameter callback : no type generator for ClipboardReceivedFunc (GtkClipboardReceivedFunc) for param callback

// Unsupported : gtk_clipboard_request_text : unsupported parameter callback : no type generator for ClipboardTextReceivedFunc (GtkClipboardTextReceivedFunc) for param callback

// SetText is a wrapper around the C function gtk_clipboard_set_text.
func (recv *Clipboard) SetText(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_clipboard_set_text((*C.GtkClipboard)(recv.native), c_text, c_len)

	return
}

// Unsupported : gtk_clipboard_set_with_data : unsupported parameter targets :

// Unsupported : gtk_clipboard_set_with_owner : unsupported parameter targets :

// Blacklisted : gtk_clipboard_wait_for_contents

// Blacklisted : gtk_clipboard_wait_for_text

// Blacklisted : gtk_clipboard_wait_is_text_available

// ColorButton is a wrapper around the C record GtkColorButton.
type ColorButton struct {
	native *C.GtkColorButton
	// button : record
	// Private : priv
}

func ColorButtonNewFromC(u unsafe.Pointer) *ColorButton {
	c := (*C.GtkColorButton)(u)
	if c == nil {
		return nil
	}

	g := &ColorButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorButton with another ColorButton, and returns true if they represent the same GObject.
func (recv *ColorButton) Equals(other *ColorButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *ColorButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ColorButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ColorButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ColorButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to ColorButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorButton.
func CastToColorButton(object *gobject.Object) *ColorButton {
	return ColorButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorButton
func (recv *ColorButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ColorButton
func (recv *ColorButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ColorButton
func (recv *ColorButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorButton
func (recv *ColorButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorButton
func (recv *ColorButton) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// ColorChooserDialog is a wrapper around the C record GtkColorChooserDialog.
type ColorChooserDialog struct {
	native *C.GtkColorChooserDialog
	// parent_instance : record
	// Private : priv
}

func ColorChooserDialogNewFromC(u unsafe.Pointer) *ColorChooserDialog {
	c := (*C.GtkColorChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserDialog with another ColorChooserDialog, and returns true if they represent the same GObject.
func (recv *ColorChooserDialog) Equals(other *ColorChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *ColorChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *ColorChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *ColorChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *ColorChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *ColorChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to ColorChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorChooserDialog.
func CastToColorChooserDialog(object *gobject.Object) *ColorChooserDialog {
	return ColorChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// ColorChooserWidget is a wrapper around the C record GtkColorChooserWidget.
type ColorChooserWidget struct {
	native *C.GtkColorChooserWidget
	// parent_instance : record
	// Private : priv
}

func ColorChooserWidgetNewFromC(u unsafe.Pointer) *ColorChooserWidget {
	c := (*C.GtkColorChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserWidget with another ColorChooserWidget, and returns true if they represent the same GObject.
func (recv *ColorChooserWidget) Equals(other *ColorChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *ColorChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ColorChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ColorChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to ColorChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorChooserWidget.
func CastToColorChooserWidget(object *gobject.Object) *ColorChooserWidget {
	return ColorChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ColorSelection is a wrapper around the C record GtkColorSelection.
type ColorSelection struct {
	native *C.GtkColorSelection
	// parent_instance : record
	// Private : private_data
}

func ColorSelectionNewFromC(u unsafe.Pointer) *ColorSelection {
	c := (*C.GtkColorSelection)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorSelection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorSelection with another ColorSelection, and returns true if they represent the same GObject.
func (recv *ColorSelection) Equals(other *ColorSelection) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *ColorSelection) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ColorSelection) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ColorSelection) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorSelection) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorSelection) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to ColorSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorSelection.
func CastToColorSelection(object *gobject.Object) *ColorSelection {
	return ColorSelectionNewFromC(object.ToC())
}

type signalColorSelectionColorChangedDetail struct {
	callback  ColorSelectionSignalColorChangedCallback
	handlerID C.gulong
}

var signalColorSelectionColorChangedId int
var signalColorSelectionColorChangedMap = make(map[int]signalColorSelectionColorChangedDetail)
var signalColorSelectionColorChangedLock sync.RWMutex

// ColorSelectionSignalColorChangedCallback is a callback function for a 'color-changed' signal emitted from a ColorSelection.
type ColorSelectionSignalColorChangedCallback func()

/*
ConnectColorChanged connects the callback to the 'color-changed' signal for the ColorSelection.

The returned value represents the connection, and may be passed to DisconnectColorChanged to remove it.
*/
func (recv *ColorSelection) ConnectColorChanged(callback ColorSelectionSignalColorChangedCallback) int {
	signalColorSelectionColorChangedLock.Lock()
	defer signalColorSelectionColorChangedLock.Unlock()

	signalColorSelectionColorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ColorSelection_signal_connect_color_changed(instance, C.gpointer(uintptr(signalColorSelectionColorChangedId)))

	detail := signalColorSelectionColorChangedDetail{callback, handlerID}
	signalColorSelectionColorChangedMap[signalColorSelectionColorChangedId] = detail

	return signalColorSelectionColorChangedId
}

/*
DisconnectColorChanged disconnects a callback from the 'color-changed' signal for the ColorSelection.

The connectionID should be a value returned from a call to ConnectColorChanged.
*/
func (recv *ColorSelection) DisconnectColorChanged(connectionID int) {
	signalColorSelectionColorChangedLock.Lock()
	defer signalColorSelectionColorChangedLock.Unlock()

	detail, exists := signalColorSelectionColorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalColorSelectionColorChangedMap, connectionID)
}

//export colorselection_colorChangedHandler
func colorselection_colorChangedHandler(_ *C.GObject, data C.gpointer) {
	signalColorSelectionColorChangedLock.RLock()
	defer signalColorSelectionColorChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalColorSelectionColorChangedMap[index].callback
	callback()
}

// Blacklisted : gtk_color_selection_new

// gtk_color_selection_palette_from_string : unsupported parameter colors : output array param colors
// gtk_color_selection_palette_to_string : unsupported parameter colors :
// Blacklisted : gtk_color_selection_get_current_alpha

// Blacklisted : gtk_color_selection_get_current_color

// Blacklisted : gtk_color_selection_get_has_opacity_control

// Blacklisted : gtk_color_selection_get_has_palette

// Blacklisted : gtk_color_selection_get_previous_alpha

// Blacklisted : gtk_color_selection_get_previous_color

// Blacklisted : gtk_color_selection_is_adjusting

// Blacklisted : gtk_color_selection_set_current_alpha

// Blacklisted : gtk_color_selection_set_current_color

// Blacklisted : gtk_color_selection_set_has_opacity_control

// Blacklisted : gtk_color_selection_set_has_palette

// Blacklisted : gtk_color_selection_set_previous_alpha

// Blacklisted : gtk_color_selection_set_previous_color

// ImplementorIface returns the ImplementorIface interface implemented by ColorSelection
func (recv *ColorSelection) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorSelection
func (recv *ColorSelection) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ColorSelection
func (recv *ColorSelection) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ColorSelectionDialog is a wrapper around the C record GtkColorSelectionDialog.
type ColorSelectionDialog struct {
	native *C.GtkColorSelectionDialog
	// parent_instance : record
	// Private : priv
}

func ColorSelectionDialogNewFromC(u unsafe.Pointer) *ColorSelectionDialog {
	c := (*C.GtkColorSelectionDialog)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelectionDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorSelectionDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorSelectionDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorSelectionDialog with another ColorSelectionDialog, and returns true if they represent the same GObject.
func (recv *ColorSelectionDialog) Equals(other *ColorSelectionDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *ColorSelectionDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *ColorSelectionDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *ColorSelectionDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *ColorSelectionDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *ColorSelectionDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorSelectionDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorSelectionDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to ColorSelectionDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorSelectionDialog.
func CastToColorSelectionDialog(object *gobject.Object) *ColorSelectionDialog {
	return ColorSelectionDialogNewFromC(object.ToC())
}

// Blacklisted : gtk_color_selection_dialog_new

// ImplementorIface returns the ImplementorIface interface implemented by ColorSelectionDialog
func (recv *ColorSelectionDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorSelectionDialog
func (recv *ColorSelectionDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ComboBox is a wrapper around the C record GtkComboBox.
type ComboBox struct {
	native *C.GtkComboBox
	// parent_instance : record
	// Private : priv
}

func ComboBoxNewFromC(u unsafe.Pointer) *ComboBox {
	c := (*C.GtkComboBox)(u)
	if c == nil {
		return nil
	}

	g := &ComboBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ComboBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ComboBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBox with another ComboBox, and returns true if they represent the same GObject.
func (recv *ComboBox) Equals(other *ComboBox) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ComboBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ComboBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ComboBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ComboBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ComboBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ComboBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBox.
func CastToComboBox(object *gobject.Object) *ComboBox {
	return ComboBoxNewFromC(object.ToC())
}

// Blacklisted : gtk_combo_box_new_with_area

// Blacklisted : gtk_combo_box_new_with_area_and_entry

// Blacklisted : gtk_combo_box_get_add_tearoffs

// ImplementorIface returns the ImplementorIface interface implemented by ComboBox
func (recv *ComboBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ComboBox
func (recv *ComboBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by ComboBox
func (recv *ComboBox) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by ComboBox
func (recv *ComboBox) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// ComboBoxAccessible is a wrapper around the C record GtkComboBoxAccessible.
type ComboBoxAccessible struct {
	native *C.GtkComboBoxAccessible
	// parent : record
	// priv : record
}

func ComboBoxAccessibleNewFromC(u unsafe.Pointer) *ComboBoxAccessible {
	c := (*C.GtkComboBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ComboBoxAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ComboBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxAccessible with another ComboBoxAccessible, and returns true if they represent the same GObject.
func (recv *ComboBoxAccessible) Equals(other *ComboBoxAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ComboBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ComboBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ComboBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ComboBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ComboBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBoxAccessible.
func CastToComboBoxAccessible(object *gobject.Object) *ComboBoxAccessible {
	return ComboBoxAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// ComboBoxText is a wrapper around the C record GtkComboBoxText.
type ComboBoxText struct {
	native *C.GtkComboBoxText
	// Private : parent_instance
	// Private : priv
}

func ComboBoxTextNewFromC(u unsafe.Pointer) *ComboBoxText {
	c := (*C.GtkComboBoxText)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxText{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ComboBoxText) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ComboBoxText) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxText with another ComboBoxText, and returns true if they represent the same GObject.
func (recv *ComboBoxText) Equals(other *ComboBoxText) bool {
	return other.ToC() == recv.ToC()
}

// ComboBox upcasts to *ComboBox
func (recv *ComboBoxText) ComboBox() *ComboBox {
	return ComboBoxNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ComboBoxText) Bin() *Bin {
	return recv.ComboBox().Bin()
}

// Container upcasts to *Container
func (recv *ComboBoxText) Container() *Container {
	return recv.ComboBox().Container()
}

// Widget upcasts to *Widget
func (recv *ComboBoxText) Widget() *Widget {
	return recv.ComboBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ComboBoxText) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ComboBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ComboBoxText) Object() *gobject.Object {
	return recv.ComboBox().Object()
}

// CastToWidget down casts any arbitrary Object to ComboBoxText.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBoxText.
func CastToComboBoxText(object *gobject.Object) *ComboBoxText {
	return ComboBoxTextNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ComboBoxText
func (recv *ComboBoxText) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ComboBoxText
func (recv *ComboBoxText) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by ComboBoxText
func (recv *ComboBoxText) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by ComboBoxText
func (recv *ComboBoxText) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Container is a wrapper around the C record GtkContainer.
type Container struct {
	native *C.GtkContainer
	// widget : record
	// Private : priv
}

func ContainerNewFromC(u unsafe.Pointer) *Container {
	c := (*C.GtkContainer)(u)
	if c == nil {
		return nil
	}

	g := &Container{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Container) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Container) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Container with another Container, and returns true if they represent the same GObject.
func (recv *Container) Equals(other *Container) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Container) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Container) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Container) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Container.
// Exercise care, as this is a potentially dangerous function if the Object is not a Container.
func CastToContainer(object *gobject.Object) *Container {
	return ContainerNewFromC(object.ToC())
}

type signalContainerAddDetail struct {
	callback  ContainerSignalAddCallback
	handlerID C.gulong
}

var signalContainerAddId int
var signalContainerAddMap = make(map[int]signalContainerAddDetail)
var signalContainerAddLock sync.RWMutex

// ContainerSignalAddCallback is a callback function for a 'add' signal emitted from a Container.
type ContainerSignalAddCallback func(object *Widget)

/*
ConnectAdd connects the callback to the 'add' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectAdd to remove it.
*/
func (recv *Container) ConnectAdd(callback ContainerSignalAddCallback) int {
	signalContainerAddLock.Lock()
	defer signalContainerAddLock.Unlock()

	signalContainerAddId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_add(instance, C.gpointer(uintptr(signalContainerAddId)))

	detail := signalContainerAddDetail{callback, handlerID}
	signalContainerAddMap[signalContainerAddId] = detail

	return signalContainerAddId
}

/*
DisconnectAdd disconnects a callback from the 'add' signal for the Container.

The connectionID should be a value returned from a call to ConnectAdd.
*/
func (recv *Container) DisconnectAdd(connectionID int) {
	signalContainerAddLock.Lock()
	defer signalContainerAddLock.Unlock()

	detail, exists := signalContainerAddMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerAddMap, connectionID)
}

//export container_addHandler
func container_addHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	signalContainerAddLock.RLock()
	defer signalContainerAddLock.RUnlock()

	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerAddMap[index].callback
	callback(object)
}

type signalContainerCheckResizeDetail struct {
	callback  ContainerSignalCheckResizeCallback
	handlerID C.gulong
}

var signalContainerCheckResizeId int
var signalContainerCheckResizeMap = make(map[int]signalContainerCheckResizeDetail)
var signalContainerCheckResizeLock sync.RWMutex

// ContainerSignalCheckResizeCallback is a callback function for a 'check-resize' signal emitted from a Container.
type ContainerSignalCheckResizeCallback func()

/*
ConnectCheckResize connects the callback to the 'check-resize' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectCheckResize to remove it.
*/
func (recv *Container) ConnectCheckResize(callback ContainerSignalCheckResizeCallback) int {
	signalContainerCheckResizeLock.Lock()
	defer signalContainerCheckResizeLock.Unlock()

	signalContainerCheckResizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_check_resize(instance, C.gpointer(uintptr(signalContainerCheckResizeId)))

	detail := signalContainerCheckResizeDetail{callback, handlerID}
	signalContainerCheckResizeMap[signalContainerCheckResizeId] = detail

	return signalContainerCheckResizeId
}

/*
DisconnectCheckResize disconnects a callback from the 'check-resize' signal for the Container.

The connectionID should be a value returned from a call to ConnectCheckResize.
*/
func (recv *Container) DisconnectCheckResize(connectionID int) {
	signalContainerCheckResizeLock.Lock()
	defer signalContainerCheckResizeLock.Unlock()

	detail, exists := signalContainerCheckResizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerCheckResizeMap, connectionID)
}

//export container_checkResizeHandler
func container_checkResizeHandler(_ *C.GObject, data C.gpointer) {
	signalContainerCheckResizeLock.RLock()
	defer signalContainerCheckResizeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalContainerCheckResizeMap[index].callback
	callback()
}

type signalContainerRemoveDetail struct {
	callback  ContainerSignalRemoveCallback
	handlerID C.gulong
}

var signalContainerRemoveId int
var signalContainerRemoveMap = make(map[int]signalContainerRemoveDetail)
var signalContainerRemoveLock sync.RWMutex

// ContainerSignalRemoveCallback is a callback function for a 'remove' signal emitted from a Container.
type ContainerSignalRemoveCallback func(object *Widget)

/*
ConnectRemove connects the callback to the 'remove' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectRemove to remove it.
*/
func (recv *Container) ConnectRemove(callback ContainerSignalRemoveCallback) int {
	signalContainerRemoveLock.Lock()
	defer signalContainerRemoveLock.Unlock()

	signalContainerRemoveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_remove(instance, C.gpointer(uintptr(signalContainerRemoveId)))

	detail := signalContainerRemoveDetail{callback, handlerID}
	signalContainerRemoveMap[signalContainerRemoveId] = detail

	return signalContainerRemoveId
}

/*
DisconnectRemove disconnects a callback from the 'remove' signal for the Container.

The connectionID should be a value returned from a call to ConnectRemove.
*/
func (recv *Container) DisconnectRemove(connectionID int) {
	signalContainerRemoveLock.Lock()
	defer signalContainerRemoveLock.Unlock()

	detail, exists := signalContainerRemoveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerRemoveMap, connectionID)
}

//export container_removeHandler
func container_removeHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	signalContainerRemoveLock.RLock()
	defer signalContainerRemoveLock.RUnlock()

	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerRemoveMap[index].callback
	callback(object)
}

type signalContainerSetFocusChildDetail struct {
	callback  ContainerSignalSetFocusChildCallback
	handlerID C.gulong
}

var signalContainerSetFocusChildId int
var signalContainerSetFocusChildMap = make(map[int]signalContainerSetFocusChildDetail)
var signalContainerSetFocusChildLock sync.RWMutex

// ContainerSignalSetFocusChildCallback is a callback function for a 'set-focus-child' signal emitted from a Container.
type ContainerSignalSetFocusChildCallback func(object *Widget)

/*
ConnectSetFocusChild connects the callback to the 'set-focus-child' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectSetFocusChild to remove it.
*/
func (recv *Container) ConnectSetFocusChild(callback ContainerSignalSetFocusChildCallback) int {
	signalContainerSetFocusChildLock.Lock()
	defer signalContainerSetFocusChildLock.Unlock()

	signalContainerSetFocusChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_set_focus_child(instance, C.gpointer(uintptr(signalContainerSetFocusChildId)))

	detail := signalContainerSetFocusChildDetail{callback, handlerID}
	signalContainerSetFocusChildMap[signalContainerSetFocusChildId] = detail

	return signalContainerSetFocusChildId
}

/*
DisconnectSetFocusChild disconnects a callback from the 'set-focus-child' signal for the Container.

The connectionID should be a value returned from a call to ConnectSetFocusChild.
*/
func (recv *Container) DisconnectSetFocusChild(connectionID int) {
	signalContainerSetFocusChildLock.Lock()
	defer signalContainerSetFocusChildLock.Unlock()

	detail, exists := signalContainerSetFocusChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerSetFocusChildMap, connectionID)
}

//export container_setFocusChildHandler
func container_setFocusChildHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	signalContainerSetFocusChildLock.RLock()
	defer signalContainerSetFocusChildLock.RUnlock()

	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerSetFocusChildMap[index].callback
	callback(object)
}

// Blacklisted : gtk_container_add

// Unsupported : gtk_container_add_with_properties : unsupported parameter ... : varargs

// Blacklisted : gtk_container_check_resize

// Unsupported : gtk_container_child_get : unsupported parameter ... : varargs

// Blacklisted : gtk_container_child_get_property

// Unsupported : gtk_container_child_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Unsupported : gtk_container_child_set : unsupported parameter ... : varargs

// Blacklisted : gtk_container_child_set_property

// Unsupported : gtk_container_child_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Blacklisted : gtk_container_child_type

// Unsupported : gtk_container_forall : unsupported parameter callback : no type generator for Callback (GtkCallback) for param callback

// Unsupported : gtk_container_foreach : unsupported parameter callback : no type generator for Callback (GtkCallback) for param callback

// Blacklisted : gtk_container_get_border_width

// Blacklisted : gtk_container_get_children

// Blacklisted : gtk_container_get_focus_chain

// Blacklisted : gtk_container_get_focus_hadjustment

// Blacklisted : gtk_container_get_focus_vadjustment

// Blacklisted : gtk_container_get_path_for_child

// Blacklisted : gtk_container_get_resize_mode

// Blacklisted : gtk_container_propagate_draw

// Blacklisted : gtk_container_remove

// Blacklisted : gtk_container_resize_children

// Blacklisted : gtk_container_set_border_width

// Blacklisted : gtk_container_set_focus_chain

// Blacklisted : gtk_container_set_focus_child

// Blacklisted : gtk_container_set_focus_hadjustment

// Blacklisted : gtk_container_set_focus_vadjustment

// Blacklisted : gtk_container_set_reallocate_redraws

// Blacklisted : gtk_container_set_resize_mode

// Blacklisted : gtk_container_unset_focus_chain

// ImplementorIface returns the ImplementorIface interface implemented by Container
func (recv *Container) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Container
func (recv *Container) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ContainerAccessible is a wrapper around the C record GtkContainerAccessible.
type ContainerAccessible struct {
	native *C.GtkContainerAccessible
	// parent : record
	// priv : record
}

func ContainerAccessibleNewFromC(u unsafe.Pointer) *ContainerAccessible {
	c := (*C.GtkContainerAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ContainerAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ContainerAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ContainerAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerAccessible with another ContainerAccessible, and returns true if they represent the same GObject.
func (recv *ContainerAccessible) Equals(other *ContainerAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ContainerAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ContainerAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ContainerAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ContainerAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ContainerAccessible.
func CastToContainerAccessible(object *gobject.Object) *ContainerAccessible {
	return ContainerAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ContainerAccessible
func (recv *ContainerAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// ContainerCellAccessible is a wrapper around the C record GtkContainerCellAccessible.
type ContainerCellAccessible struct {
	native *C.GtkContainerCellAccessible
	// parent : record
	// priv : record
}

func ContainerCellAccessibleNewFromC(u unsafe.Pointer) *ContainerCellAccessible {
	c := (*C.GtkContainerCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ContainerCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ContainerCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ContainerCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerCellAccessible with another ContainerCellAccessible, and returns true if they represent the same GObject.
func (recv *ContainerCellAccessible) Equals(other *ContainerCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// CellAccessible upcasts to *CellAccessible
func (recv *ContainerCellAccessible) CellAccessible() *CellAccessible {
	return CellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ContainerCellAccessible) Accessible() *Accessible {
	return recv.CellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ContainerCellAccessible) Object() *atk.Object {
	return recv.CellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ContainerCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ContainerCellAccessible.
func CastToContainerCellAccessible(object *gobject.Object) *ContainerCellAccessible {
	return ContainerCellAccessibleNewFromC(object.ToC())
}

// Blacklisted : gtk_container_cell_accessible_new

// Blacklisted : gtk_container_cell_accessible_add_child

// Blacklisted : gtk_container_cell_accessible_get_children

// Blacklisted : gtk_container_cell_accessible_remove_child

// Action returns the Action interface implemented by ContainerCellAccessible
func (recv *ContainerCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ContainerCellAccessible
func (recv *ContainerCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// CssProvider is a wrapper around the C record GtkCssProvider.
type CssProvider struct {
	native *C.GtkCssProvider
	// parent_instance : record
	// priv : record
}

func CssProviderNewFromC(u unsafe.Pointer) *CssProvider {
	c := (*C.GtkCssProvider)(u)
	if c == nil {
		return nil
	}

	g := &CssProvider{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CssProvider) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CssProvider) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CssProvider with another CssProvider, and returns true if they represent the same GObject.
func (recv *CssProvider) Equals(other *CssProvider) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *CssProvider) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to CssProvider.
// Exercise care, as this is a potentially dangerous function if the Object is not a CssProvider.
func CastToCssProvider(object *gobject.Object) *CssProvider {
	return CssProviderNewFromC(object.ToC())
}

type signalCssProviderParsingErrorDetail struct {
	callback  CssProviderSignalParsingErrorCallback
	handlerID C.gulong
}

var signalCssProviderParsingErrorId int
var signalCssProviderParsingErrorMap = make(map[int]signalCssProviderParsingErrorDetail)
var signalCssProviderParsingErrorLock sync.RWMutex

// CssProviderSignalParsingErrorCallback is a callback function for a 'parsing-error' signal emitted from a CssProvider.
type CssProviderSignalParsingErrorCallback func(section *CssSection, error *glib.Error)

/*
ConnectParsingError connects the callback to the 'parsing-error' signal for the CssProvider.

The returned value represents the connection, and may be passed to DisconnectParsingError to remove it.
*/
func (recv *CssProvider) ConnectParsingError(callback CssProviderSignalParsingErrorCallback) int {
	signalCssProviderParsingErrorLock.Lock()
	defer signalCssProviderParsingErrorLock.Unlock()

	signalCssProviderParsingErrorId++
	instance := C.gpointer(recv.native)
	handlerID := C.CssProvider_signal_connect_parsing_error(instance, C.gpointer(uintptr(signalCssProviderParsingErrorId)))

	detail := signalCssProviderParsingErrorDetail{callback, handlerID}
	signalCssProviderParsingErrorMap[signalCssProviderParsingErrorId] = detail

	return signalCssProviderParsingErrorId
}

/*
DisconnectParsingError disconnects a callback from the 'parsing-error' signal for the CssProvider.

The connectionID should be a value returned from a call to ConnectParsingError.
*/
func (recv *CssProvider) DisconnectParsingError(connectionID int) {
	signalCssProviderParsingErrorLock.Lock()
	defer signalCssProviderParsingErrorLock.Unlock()

	detail, exists := signalCssProviderParsingErrorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCssProviderParsingErrorMap, connectionID)
}

//export cssprovider_parsingErrorHandler
func cssprovider_parsingErrorHandler(_ *C.GObject, c_section *C.GtkCssSection, c_error *C.GError, data C.gpointer) {
	signalCssProviderParsingErrorLock.RLock()
	defer signalCssProviderParsingErrorLock.RUnlock()

	section := CssSectionNewFromC(unsafe.Pointer(c_section))

	error := glib.ErrorNewFromC(unsafe.Pointer(c_error))

	index := int(uintptr(data))
	callback := signalCssProviderParsingErrorMap[index].callback
	callback(section, error)
}

// Blacklisted : gtk_css_provider_new

// Blacklisted : gtk_css_provider_get_default

// Blacklisted : gtk_css_provider_get_named

// Blacklisted : gtk_css_provider_load_from_data

// Blacklisted : gtk_css_provider_load_from_file

// Blacklisted : gtk_css_provider_load_from_path

// StyleProvider returns the StyleProvider interface implemented by CssProvider
func (recv *CssProvider) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// Dialog is a wrapper around the C record GtkDialog.
type Dialog struct {
	native *C.GtkDialog
	// window : record
	// Private : priv
}

func DialogNewFromC(u unsafe.Pointer) *Dialog {
	c := (*C.GtkDialog)(u)
	if c == nil {
		return nil
	}

	g := &Dialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Dialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Dialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Dialog with another Dialog, and returns true if they represent the same GObject.
func (recv *Dialog) Equals(other *Dialog) bool {
	return other.ToC() == recv.ToC()
}

// Window upcasts to *Window
func (recv *Dialog) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *Dialog) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *Dialog) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *Dialog) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Dialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Dialog) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitrary Object to Dialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a Dialog.
func CastToDialog(object *gobject.Object) *Dialog {
	return DialogNewFromC(object.ToC())
}

type signalDialogCloseDetail struct {
	callback  DialogSignalCloseCallback
	handlerID C.gulong
}

var signalDialogCloseId int
var signalDialogCloseMap = make(map[int]signalDialogCloseDetail)
var signalDialogCloseLock sync.RWMutex

// DialogSignalCloseCallback is a callback function for a 'close' signal emitted from a Dialog.
type DialogSignalCloseCallback func()

/*
ConnectClose connects the callback to the 'close' signal for the Dialog.

The returned value represents the connection, and may be passed to DisconnectClose to remove it.
*/
func (recv *Dialog) ConnectClose(callback DialogSignalCloseCallback) int {
	signalDialogCloseLock.Lock()
	defer signalDialogCloseLock.Unlock()

	signalDialogCloseId++
	instance := C.gpointer(recv.native)
	handlerID := C.Dialog_signal_connect_close(instance, C.gpointer(uintptr(signalDialogCloseId)))

	detail := signalDialogCloseDetail{callback, handlerID}
	signalDialogCloseMap[signalDialogCloseId] = detail

	return signalDialogCloseId
}

/*
DisconnectClose disconnects a callback from the 'close' signal for the Dialog.

The connectionID should be a value returned from a call to ConnectClose.
*/
func (recv *Dialog) DisconnectClose(connectionID int) {
	signalDialogCloseLock.Lock()
	defer signalDialogCloseLock.Unlock()

	detail, exists := signalDialogCloseMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDialogCloseMap, connectionID)
}

//export dialog_closeHandler
func dialog_closeHandler(_ *C.GObject, data C.gpointer) {
	signalDialogCloseLock.RLock()
	defer signalDialogCloseLock.RUnlock()

	index := int(uintptr(data))
	callback := signalDialogCloseMap[index].callback
	callback()
}

type signalDialogResponseDetail struct {
	callback  DialogSignalResponseCallback
	handlerID C.gulong
}

var signalDialogResponseId int
var signalDialogResponseMap = make(map[int]signalDialogResponseDetail)
var signalDialogResponseLock sync.RWMutex

// DialogSignalResponseCallback is a callback function for a 'response' signal emitted from a Dialog.
type DialogSignalResponseCallback func(responseId int32)

/*
ConnectResponse connects the callback to the 'response' signal for the Dialog.

The returned value represents the connection, and may be passed to DisconnectResponse to remove it.
*/
func (recv *Dialog) ConnectResponse(callback DialogSignalResponseCallback) int {
	signalDialogResponseLock.Lock()
	defer signalDialogResponseLock.Unlock()

	signalDialogResponseId++
	instance := C.gpointer(recv.native)
	handlerID := C.Dialog_signal_connect_response(instance, C.gpointer(uintptr(signalDialogResponseId)))

	detail := signalDialogResponseDetail{callback, handlerID}
	signalDialogResponseMap[signalDialogResponseId] = detail

	return signalDialogResponseId
}

/*
DisconnectResponse disconnects a callback from the 'response' signal for the Dialog.

The connectionID should be a value returned from a call to ConnectResponse.
*/
func (recv *Dialog) DisconnectResponse(connectionID int) {
	signalDialogResponseLock.Lock()
	defer signalDialogResponseLock.Unlock()

	detail, exists := signalDialogResponseMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDialogResponseMap, connectionID)
}

//export dialog_responseHandler
func dialog_responseHandler(_ *C.GObject, c_response_id C.gint, data C.gpointer) {
	signalDialogResponseLock.RLock()
	defer signalDialogResponseLock.RUnlock()

	responseId := int32(c_response_id)

	index := int(uintptr(data))
	callback := signalDialogResponseMap[index].callback
	callback(responseId)
}

// Blacklisted : gtk_dialog_new

// Unsupported : gtk_dialog_new_with_buttons : unsupported parameter ... : varargs

// Blacklisted : gtk_dialog_add_action_widget

// Blacklisted : gtk_dialog_add_button

// Unsupported : gtk_dialog_add_buttons : unsupported parameter ... : varargs

// Blacklisted : gtk_dialog_response

// Blacklisted : gtk_dialog_run

// Blacklisted : gtk_dialog_set_default_response

// Blacklisted : gtk_dialog_set_response_sensitive

// ImplementorIface returns the ImplementorIface interface implemented by Dialog
func (recv *Dialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Dialog
func (recv *Dialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// DrawingArea is a wrapper around the C record GtkDrawingArea.
type DrawingArea struct {
	native *C.GtkDrawingArea
	// widget : record
	// Private : dummy
}

func DrawingAreaNewFromC(u unsafe.Pointer) *DrawingArea {
	c := (*C.GtkDrawingArea)(u)
	if c == nil {
		return nil
	}

	g := &DrawingArea{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DrawingArea) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DrawingArea) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DrawingArea with another DrawingArea, and returns true if they represent the same GObject.
func (recv *DrawingArea) Equals(other *DrawingArea) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *DrawingArea) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *DrawingArea) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *DrawingArea) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to DrawingArea.
// Exercise care, as this is a potentially dangerous function if the Object is not a DrawingArea.
func CastToDrawingArea(object *gobject.Object) *DrawingArea {
	return DrawingAreaNewFromC(object.ToC())
}

// Blacklisted : gtk_drawing_area_new

// ImplementorIface returns the ImplementorIface interface implemented by DrawingArea
func (recv *DrawingArea) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by DrawingArea
func (recv *DrawingArea) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Entry is a wrapper around the C record GtkEntry.
type Entry struct {
	native *C.GtkEntry
	// Private : parent_instance
	// Private : priv
}

func EntryNewFromC(u unsafe.Pointer) *Entry {
	c := (*C.GtkEntry)(u)
	if c == nil {
		return nil
	}

	g := &Entry{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Entry) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Entry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Entry with another Entry, and returns true if they represent the same GObject.
func (recv *Entry) Equals(other *Entry) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Entry) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Entry) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Entry) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Entry.
// Exercise care, as this is a potentially dangerous function if the Object is not a Entry.
func CastToEntry(object *gobject.Object) *Entry {
	return EntryNewFromC(object.ToC())
}

type signalEntryActivateDetail struct {
	callback  EntrySignalActivateCallback
	handlerID C.gulong
}

var signalEntryActivateId int
var signalEntryActivateMap = make(map[int]signalEntryActivateDetail)
var signalEntryActivateLock sync.RWMutex

// EntrySignalActivateCallback is a callback function for a 'activate' signal emitted from a Entry.
type EntrySignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Entry) ConnectActivate(callback EntrySignalActivateCallback) int {
	signalEntryActivateLock.Lock()
	defer signalEntryActivateLock.Unlock()

	signalEntryActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_activate(instance, C.gpointer(uintptr(signalEntryActivateId)))

	detail := signalEntryActivateDetail{callback, handlerID}
	signalEntryActivateMap[signalEntryActivateId] = detail

	return signalEntryActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Entry.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Entry) DisconnectActivate(connectionID int) {
	signalEntryActivateLock.Lock()
	defer signalEntryActivateLock.Unlock()

	detail, exists := signalEntryActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryActivateMap, connectionID)
}

//export entry_activateHandler
func entry_activateHandler(_ *C.GObject, data C.gpointer) {
	signalEntryActivateLock.RLock()
	defer signalEntryActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryActivateMap[index].callback
	callback()
}

type signalEntryBackspaceDetail struct {
	callback  EntrySignalBackspaceCallback
	handlerID C.gulong
}

var signalEntryBackspaceId int
var signalEntryBackspaceMap = make(map[int]signalEntryBackspaceDetail)
var signalEntryBackspaceLock sync.RWMutex

// EntrySignalBackspaceCallback is a callback function for a 'backspace' signal emitted from a Entry.
type EntrySignalBackspaceCallback func()

/*
ConnectBackspace connects the callback to the 'backspace' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectBackspace to remove it.
*/
func (recv *Entry) ConnectBackspace(callback EntrySignalBackspaceCallback) int {
	signalEntryBackspaceLock.Lock()
	defer signalEntryBackspaceLock.Unlock()

	signalEntryBackspaceId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_backspace(instance, C.gpointer(uintptr(signalEntryBackspaceId)))

	detail := signalEntryBackspaceDetail{callback, handlerID}
	signalEntryBackspaceMap[signalEntryBackspaceId] = detail

	return signalEntryBackspaceId
}

/*
DisconnectBackspace disconnects a callback from the 'backspace' signal for the Entry.

The connectionID should be a value returned from a call to ConnectBackspace.
*/
func (recv *Entry) DisconnectBackspace(connectionID int) {
	signalEntryBackspaceLock.Lock()
	defer signalEntryBackspaceLock.Unlock()

	detail, exists := signalEntryBackspaceMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryBackspaceMap, connectionID)
}

//export entry_backspaceHandler
func entry_backspaceHandler(_ *C.GObject, data C.gpointer) {
	signalEntryBackspaceLock.RLock()
	defer signalEntryBackspaceLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryBackspaceMap[index].callback
	callback()
}

type signalEntryCopyClipboardDetail struct {
	callback  EntrySignalCopyClipboardCallback
	handlerID C.gulong
}

var signalEntryCopyClipboardId int
var signalEntryCopyClipboardMap = make(map[int]signalEntryCopyClipboardDetail)
var signalEntryCopyClipboardLock sync.RWMutex

// EntrySignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a Entry.
type EntrySignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *Entry) ConnectCopyClipboard(callback EntrySignalCopyClipboardCallback) int {
	signalEntryCopyClipboardLock.Lock()
	defer signalEntryCopyClipboardLock.Unlock()

	signalEntryCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalEntryCopyClipboardId)))

	detail := signalEntryCopyClipboardDetail{callback, handlerID}
	signalEntryCopyClipboardMap[signalEntryCopyClipboardId] = detail

	return signalEntryCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *Entry) DisconnectCopyClipboard(connectionID int) {
	signalEntryCopyClipboardLock.Lock()
	defer signalEntryCopyClipboardLock.Unlock()

	detail, exists := signalEntryCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCopyClipboardMap, connectionID)
}

//export entry_copyClipboardHandler
func entry_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalEntryCopyClipboardLock.RLock()
	defer signalEntryCopyClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryCopyClipboardMap[index].callback
	callback()
}

type signalEntryCutClipboardDetail struct {
	callback  EntrySignalCutClipboardCallback
	handlerID C.gulong
}

var signalEntryCutClipboardId int
var signalEntryCutClipboardMap = make(map[int]signalEntryCutClipboardDetail)
var signalEntryCutClipboardLock sync.RWMutex

// EntrySignalCutClipboardCallback is a callback function for a 'cut-clipboard' signal emitted from a Entry.
type EntrySignalCutClipboardCallback func()

/*
ConnectCutClipboard connects the callback to the 'cut-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectCutClipboard to remove it.
*/
func (recv *Entry) ConnectCutClipboard(callback EntrySignalCutClipboardCallback) int {
	signalEntryCutClipboardLock.Lock()
	defer signalEntryCutClipboardLock.Unlock()

	signalEntryCutClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_cut_clipboard(instance, C.gpointer(uintptr(signalEntryCutClipboardId)))

	detail := signalEntryCutClipboardDetail{callback, handlerID}
	signalEntryCutClipboardMap[signalEntryCutClipboardId] = detail

	return signalEntryCutClipboardId
}

/*
DisconnectCutClipboard disconnects a callback from the 'cut-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectCutClipboard.
*/
func (recv *Entry) DisconnectCutClipboard(connectionID int) {
	signalEntryCutClipboardLock.Lock()
	defer signalEntryCutClipboardLock.Unlock()

	detail, exists := signalEntryCutClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCutClipboardMap, connectionID)
}

//export entry_cutClipboardHandler
func entry_cutClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalEntryCutClipboardLock.RLock()
	defer signalEntryCutClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryCutClipboardMap[index].callback
	callback()
}

type signalEntryDeleteFromCursorDetail struct {
	callback  EntrySignalDeleteFromCursorCallback
	handlerID C.gulong
}

var signalEntryDeleteFromCursorId int
var signalEntryDeleteFromCursorMap = make(map[int]signalEntryDeleteFromCursorDetail)
var signalEntryDeleteFromCursorLock sync.RWMutex

// EntrySignalDeleteFromCursorCallback is a callback function for a 'delete-from-cursor' signal emitted from a Entry.
type EntrySignalDeleteFromCursorCallback func(type_ DeleteType, count int32)

/*
ConnectDeleteFromCursor connects the callback to the 'delete-from-cursor' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectDeleteFromCursor to remove it.
*/
func (recv *Entry) ConnectDeleteFromCursor(callback EntrySignalDeleteFromCursorCallback) int {
	signalEntryDeleteFromCursorLock.Lock()
	defer signalEntryDeleteFromCursorLock.Unlock()

	signalEntryDeleteFromCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_delete_from_cursor(instance, C.gpointer(uintptr(signalEntryDeleteFromCursorId)))

	detail := signalEntryDeleteFromCursorDetail{callback, handlerID}
	signalEntryDeleteFromCursorMap[signalEntryDeleteFromCursorId] = detail

	return signalEntryDeleteFromCursorId
}

/*
DisconnectDeleteFromCursor disconnects a callback from the 'delete-from-cursor' signal for the Entry.

The connectionID should be a value returned from a call to ConnectDeleteFromCursor.
*/
func (recv *Entry) DisconnectDeleteFromCursor(connectionID int) {
	signalEntryDeleteFromCursorLock.Lock()
	defer signalEntryDeleteFromCursorLock.Unlock()

	detail, exists := signalEntryDeleteFromCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryDeleteFromCursorMap, connectionID)
}

//export entry_deleteFromCursorHandler
func entry_deleteFromCursorHandler(_ *C.GObject, c_type C.GtkDeleteType, c_count C.gint, data C.gpointer) {
	signalEntryDeleteFromCursorLock.RLock()
	defer signalEntryDeleteFromCursorLock.RUnlock()

	type_ := DeleteType(c_type)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalEntryDeleteFromCursorMap[index].callback
	callback(type_, count)
}

type signalEntryInsertAtCursorDetail struct {
	callback  EntrySignalInsertAtCursorCallback
	handlerID C.gulong
}

var signalEntryInsertAtCursorId int
var signalEntryInsertAtCursorMap = make(map[int]signalEntryInsertAtCursorDetail)
var signalEntryInsertAtCursorLock sync.RWMutex

// EntrySignalInsertAtCursorCallback is a callback function for a 'insert-at-cursor' signal emitted from a Entry.
type EntrySignalInsertAtCursorCallback func(string_ string)

/*
ConnectInsertAtCursor connects the callback to the 'insert-at-cursor' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectInsertAtCursor to remove it.
*/
func (recv *Entry) ConnectInsertAtCursor(callback EntrySignalInsertAtCursorCallback) int {
	signalEntryInsertAtCursorLock.Lock()
	defer signalEntryInsertAtCursorLock.Unlock()

	signalEntryInsertAtCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_insert_at_cursor(instance, C.gpointer(uintptr(signalEntryInsertAtCursorId)))

	detail := signalEntryInsertAtCursorDetail{callback, handlerID}
	signalEntryInsertAtCursorMap[signalEntryInsertAtCursorId] = detail

	return signalEntryInsertAtCursorId
}

/*
DisconnectInsertAtCursor disconnects a callback from the 'insert-at-cursor' signal for the Entry.

The connectionID should be a value returned from a call to ConnectInsertAtCursor.
*/
func (recv *Entry) DisconnectInsertAtCursor(connectionID int) {
	signalEntryInsertAtCursorLock.Lock()
	defer signalEntryInsertAtCursorLock.Unlock()

	detail, exists := signalEntryInsertAtCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryInsertAtCursorMap, connectionID)
}

//export entry_insertAtCursorHandler
func entry_insertAtCursorHandler(_ *C.GObject, c_string *C.gchar, data C.gpointer) {
	signalEntryInsertAtCursorLock.RLock()
	defer signalEntryInsertAtCursorLock.RUnlock()

	string_ := C.GoString(c_string)

	index := int(uintptr(data))
	callback := signalEntryInsertAtCursorMap[index].callback
	callback(string_)
}

type signalEntryMoveCursorDetail struct {
	callback  EntrySignalMoveCursorCallback
	handlerID C.gulong
}

var signalEntryMoveCursorId int
var signalEntryMoveCursorMap = make(map[int]signalEntryMoveCursorDetail)
var signalEntryMoveCursorLock sync.RWMutex

// EntrySignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a Entry.
type EntrySignalMoveCursorCallback func(step MovementStep, count int32, extendSelection bool)

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *Entry) ConnectMoveCursor(callback EntrySignalMoveCursorCallback) int {
	signalEntryMoveCursorLock.Lock()
	defer signalEntryMoveCursorLock.Unlock()

	signalEntryMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalEntryMoveCursorId)))

	detail := signalEntryMoveCursorDetail{callback, handlerID}
	signalEntryMoveCursorMap[signalEntryMoveCursorId] = detail

	return signalEntryMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the Entry.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *Entry) DisconnectMoveCursor(connectionID int) {
	signalEntryMoveCursorLock.Lock()
	defer signalEntryMoveCursorLock.Unlock()

	detail, exists := signalEntryMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryMoveCursorMap, connectionID)
}

//export entry_moveCursorHandler
func entry_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, c_extend_selection C.gboolean, data C.gpointer) {
	signalEntryMoveCursorLock.RLock()
	defer signalEntryMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	extendSelection := c_extend_selection == C.TRUE

	index := int(uintptr(data))
	callback := signalEntryMoveCursorMap[index].callback
	callback(step, count, extendSelection)
}

type signalEntryPasteClipboardDetail struct {
	callback  EntrySignalPasteClipboardCallback
	handlerID C.gulong
}

var signalEntryPasteClipboardId int
var signalEntryPasteClipboardMap = make(map[int]signalEntryPasteClipboardDetail)
var signalEntryPasteClipboardLock sync.RWMutex

// EntrySignalPasteClipboardCallback is a callback function for a 'paste-clipboard' signal emitted from a Entry.
type EntrySignalPasteClipboardCallback func()

/*
ConnectPasteClipboard connects the callback to the 'paste-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectPasteClipboard to remove it.
*/
func (recv *Entry) ConnectPasteClipboard(callback EntrySignalPasteClipboardCallback) int {
	signalEntryPasteClipboardLock.Lock()
	defer signalEntryPasteClipboardLock.Unlock()

	signalEntryPasteClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_paste_clipboard(instance, C.gpointer(uintptr(signalEntryPasteClipboardId)))

	detail := signalEntryPasteClipboardDetail{callback, handlerID}
	signalEntryPasteClipboardMap[signalEntryPasteClipboardId] = detail

	return signalEntryPasteClipboardId
}

/*
DisconnectPasteClipboard disconnects a callback from the 'paste-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectPasteClipboard.
*/
func (recv *Entry) DisconnectPasteClipboard(connectionID int) {
	signalEntryPasteClipboardLock.Lock()
	defer signalEntryPasteClipboardLock.Unlock()

	detail, exists := signalEntryPasteClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryPasteClipboardMap, connectionID)
}

//export entry_pasteClipboardHandler
func entry_pasteClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalEntryPasteClipboardLock.RLock()
	defer signalEntryPasteClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryPasteClipboardMap[index].callback
	callback()
}

type signalEntryPopulatePopupDetail struct {
	callback  EntrySignalPopulatePopupCallback
	handlerID C.gulong
}

var signalEntryPopulatePopupId int
var signalEntryPopulatePopupMap = make(map[int]signalEntryPopulatePopupDetail)
var signalEntryPopulatePopupLock sync.RWMutex

// EntrySignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a Entry.
type EntrySignalPopulatePopupCallback func(widget *Widget)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *Entry) ConnectPopulatePopup(callback EntrySignalPopulatePopupCallback) int {
	signalEntryPopulatePopupLock.Lock()
	defer signalEntryPopulatePopupLock.Unlock()

	signalEntryPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalEntryPopulatePopupId)))

	detail := signalEntryPopulatePopupDetail{callback, handlerID}
	signalEntryPopulatePopupMap[signalEntryPopulatePopupId] = detail

	return signalEntryPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the Entry.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *Entry) DisconnectPopulatePopup(connectionID int) {
	signalEntryPopulatePopupLock.Lock()
	defer signalEntryPopulatePopupLock.Unlock()

	detail, exists := signalEntryPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryPopulatePopupMap, connectionID)
}

//export entry_populatePopupHandler
func entry_populatePopupHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	signalEntryPopulatePopupLock.RLock()
	defer signalEntryPopulatePopupLock.RUnlock()

	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalEntryPopulatePopupMap[index].callback
	callback(widget)
}

type signalEntryToggleOverwriteDetail struct {
	callback  EntrySignalToggleOverwriteCallback
	handlerID C.gulong
}

var signalEntryToggleOverwriteId int
var signalEntryToggleOverwriteMap = make(map[int]signalEntryToggleOverwriteDetail)
var signalEntryToggleOverwriteLock sync.RWMutex

// EntrySignalToggleOverwriteCallback is a callback function for a 'toggle-overwrite' signal emitted from a Entry.
type EntrySignalToggleOverwriteCallback func()

/*
ConnectToggleOverwrite connects the callback to the 'toggle-overwrite' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectToggleOverwrite to remove it.
*/
func (recv *Entry) ConnectToggleOverwrite(callback EntrySignalToggleOverwriteCallback) int {
	signalEntryToggleOverwriteLock.Lock()
	defer signalEntryToggleOverwriteLock.Unlock()

	signalEntryToggleOverwriteId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_toggle_overwrite(instance, C.gpointer(uintptr(signalEntryToggleOverwriteId)))

	detail := signalEntryToggleOverwriteDetail{callback, handlerID}
	signalEntryToggleOverwriteMap[signalEntryToggleOverwriteId] = detail

	return signalEntryToggleOverwriteId
}

/*
DisconnectToggleOverwrite disconnects a callback from the 'toggle-overwrite' signal for the Entry.

The connectionID should be a value returned from a call to ConnectToggleOverwrite.
*/
func (recv *Entry) DisconnectToggleOverwrite(connectionID int) {
	signalEntryToggleOverwriteLock.Lock()
	defer signalEntryToggleOverwriteLock.Unlock()

	detail, exists := signalEntryToggleOverwriteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryToggleOverwriteMap, connectionID)
}

//export entry_toggleOverwriteHandler
func entry_toggleOverwriteHandler(_ *C.GObject, data C.gpointer) {
	signalEntryToggleOverwriteLock.RLock()
	defer signalEntryToggleOverwriteLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryToggleOverwriteMap[index].callback
	callback()
}

// Blacklisted : gtk_entry_new

// Blacklisted : gtk_entry_get_activates_default

// Blacklisted : gtk_entry_get_has_frame

// Blacklisted : gtk_entry_get_invisible_char

// Blacklisted : gtk_entry_get_layout

// Blacklisted : gtk_entry_get_layout_offsets

// Blacklisted : gtk_entry_get_max_length

// GetText is a wrapper around the C function gtk_entry_get_text.
func (recv *Entry) GetText() string {
	retC := C.gtk_entry_get_text((*C.GtkEntry)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Blacklisted : gtk_entry_get_visibility

// Blacklisted : gtk_entry_get_width_chars

// Blacklisted : gtk_entry_layout_index_to_text_index

// Blacklisted : gtk_entry_set_activates_default

// Blacklisted : gtk_entry_set_has_frame

// Blacklisted : gtk_entry_set_invisible_char

// Blacklisted : gtk_entry_set_max_length

// SetText is a wrapper around the C function gtk_entry_set_text.
func (recv *Entry) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_entry_set_text((*C.GtkEntry)(recv.native), c_text)

	return
}

// Blacklisted : gtk_entry_set_visibility

// Blacklisted : gtk_entry_set_width_chars

// Blacklisted : gtk_entry_text_index_to_layout_index

// ImplementorIface returns the ImplementorIface interface implemented by Entry
func (recv *Entry) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Entry
func (recv *Entry) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by Entry
func (recv *Entry) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by Entry
func (recv *Entry) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// EntryAccessible is a wrapper around the C record GtkEntryAccessible.
type EntryAccessible struct {
	native *C.GtkEntryAccessible
	// parent : record
	// priv : record
}

func EntryAccessibleNewFromC(u unsafe.Pointer) *EntryAccessible {
	c := (*C.GtkEntryAccessible)(u)
	if c == nil {
		return nil
	}

	g := &EntryAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EntryAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EntryAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryAccessible with another EntryAccessible, and returns true if they represent the same GObject.
func (recv *EntryAccessible) Equals(other *EntryAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *EntryAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *EntryAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *EntryAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to EntryAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryAccessible.
func CastToEntryAccessible(object *gobject.Object) *EntryAccessible {
	return EntryAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by EntryAccessible
func (recv *EntryAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by EntryAccessible
func (recv *EntryAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by EntryAccessible
func (recv *EntryAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by EntryAccessible
func (recv *EntryAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// EntryBuffer is a wrapper around the C record GtkEntryBuffer.
type EntryBuffer struct {
	native *C.GtkEntryBuffer
	// parent_instance : record
	// Private : priv
}

func EntryBufferNewFromC(u unsafe.Pointer) *EntryBuffer {
	c := (*C.GtkEntryBuffer)(u)
	if c == nil {
		return nil
	}

	g := &EntryBuffer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EntryBuffer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EntryBuffer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryBuffer with another EntryBuffer, and returns true if they represent the same GObject.
func (recv *EntryBuffer) Equals(other *EntryBuffer) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *EntryBuffer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to EntryBuffer.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryBuffer.
func CastToEntryBuffer(object *gobject.Object) *EntryBuffer {
	return EntryBufferNewFromC(object.ToC())
}

// EntryCompletion is a wrapper around the C record GtkEntryCompletion.
type EntryCompletion struct {
	native *C.GtkEntryCompletion
	// parent_instance : record
	// Private : priv
}

func EntryCompletionNewFromC(u unsafe.Pointer) *EntryCompletion {
	c := (*C.GtkEntryCompletion)(u)
	if c == nil {
		return nil
	}

	g := &EntryCompletion{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EntryCompletion) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EntryCompletion) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryCompletion with another EntryCompletion, and returns true if they represent the same GObject.
func (recv *EntryCompletion) Equals(other *EntryCompletion) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *EntryCompletion) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to EntryCompletion.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryCompletion.
func CastToEntryCompletion(object *gobject.Object) *EntryCompletion {
	return EntryCompletionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by EntryCompletion
func (recv *EntryCompletion) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by EntryCompletion
func (recv *EntryCompletion) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Unsupported : EntryIconAccessible : no CType

// EventBox is a wrapper around the C record GtkEventBox.
type EventBox struct {
	native *C.GtkEventBox
	// bin : record
	// Private : priv
}

func EventBoxNewFromC(u unsafe.Pointer) *EventBox {
	c := (*C.GtkEventBox)(u)
	if c == nil {
		return nil
	}

	g := &EventBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EventBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EventBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EventBox with another EventBox, and returns true if they represent the same GObject.
func (recv *EventBox) Equals(other *EventBox) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *EventBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *EventBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *EventBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *EventBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *EventBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to EventBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a EventBox.
func CastToEventBox(object *gobject.Object) *EventBox {
	return EventBoxNewFromC(object.ToC())
}

// Blacklisted : gtk_event_box_new

// ImplementorIface returns the ImplementorIface interface implemented by EventBox
func (recv *EventBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by EventBox
func (recv *EventBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// EventController is a wrapper around the C record GtkEventController.
type EventController struct {
	native *C.GtkEventController
}

func EventControllerNewFromC(u unsafe.Pointer) *EventController {
	c := (*C.GtkEventController)(u)
	if c == nil {
		return nil
	}

	g := &EventController{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EventController) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EventController) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EventController with another EventController, and returns true if they represent the same GObject.
func (recv *EventController) Equals(other *EventController) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *EventController) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to EventController.
// Exercise care, as this is a potentially dangerous function if the Object is not a EventController.
func CastToEventController(object *gobject.Object) *EventController {
	return EventControllerNewFromC(object.ToC())
}

// Expander is a wrapper around the C record GtkExpander.
type Expander struct {
	native *C.GtkExpander
	// bin : record
	// priv : record
}

func ExpanderNewFromC(u unsafe.Pointer) *Expander {
	c := (*C.GtkExpander)(u)
	if c == nil {
		return nil
	}

	g := &Expander{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Expander) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Expander) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Expander with another Expander, and returns true if they represent the same GObject.
func (recv *Expander) Equals(other *Expander) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Expander) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Expander) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Expander) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Expander) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Expander) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Expander.
// Exercise care, as this is a potentially dangerous function if the Object is not a Expander.
func CastToExpander(object *gobject.Object) *Expander {
	return ExpanderNewFromC(object.ToC())
}

type signalExpanderActivateDetail struct {
	callback  ExpanderSignalActivateCallback
	handlerID C.gulong
}

var signalExpanderActivateId int
var signalExpanderActivateMap = make(map[int]signalExpanderActivateDetail)
var signalExpanderActivateLock sync.RWMutex

// ExpanderSignalActivateCallback is a callback function for a 'activate' signal emitted from a Expander.
type ExpanderSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Expander.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Expander) ConnectActivate(callback ExpanderSignalActivateCallback) int {
	signalExpanderActivateLock.Lock()
	defer signalExpanderActivateLock.Unlock()

	signalExpanderActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Expander_signal_connect_activate(instance, C.gpointer(uintptr(signalExpanderActivateId)))

	detail := signalExpanderActivateDetail{callback, handlerID}
	signalExpanderActivateMap[signalExpanderActivateId] = detail

	return signalExpanderActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Expander.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Expander) DisconnectActivate(connectionID int) {
	signalExpanderActivateLock.Lock()
	defer signalExpanderActivateLock.Unlock()

	detail, exists := signalExpanderActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalExpanderActivateMap, connectionID)
}

//export expander_activateHandler
func expander_activateHandler(_ *C.GObject, data C.gpointer) {
	signalExpanderActivateLock.RLock()
	defer signalExpanderActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalExpanderActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Expander
func (recv *Expander) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Expander
func (recv *Expander) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ExpanderAccessible is a wrapper around the C record GtkExpanderAccessible.
type ExpanderAccessible struct {
	native *C.GtkExpanderAccessible
	// parent : record
	// priv : record
}

func ExpanderAccessibleNewFromC(u unsafe.Pointer) *ExpanderAccessible {
	c := (*C.GtkExpanderAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ExpanderAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ExpanderAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ExpanderAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ExpanderAccessible with another ExpanderAccessible, and returns true if they represent the same GObject.
func (recv *ExpanderAccessible) Equals(other *ExpanderAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ExpanderAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ExpanderAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ExpanderAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ExpanderAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ExpanderAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ExpanderAccessible.
func CastToExpanderAccessible(object *gobject.Object) *ExpanderAccessible {
	return ExpanderAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ExpanderAccessible
func (recv *ExpanderAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ExpanderAccessible
func (recv *ExpanderAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// FileChooserButton is a wrapper around the C record GtkFileChooserButton.
type FileChooserButton struct {
	native *C.GtkFileChooserButton
	// parent : record
	// Private : priv
}

func FileChooserButtonNewFromC(u unsafe.Pointer) *FileChooserButton {
	c := (*C.GtkFileChooserButton)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileChooserButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileChooserButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserButton with another FileChooserButton, and returns true if they represent the same GObject.
func (recv *FileChooserButton) Equals(other *FileChooserButton) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *FileChooserButton) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FileChooserButton) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserButton) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserButton) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to FileChooserButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserButton.
func CastToFileChooserButton(object *gobject.Object) *FileChooserButton {
	return FileChooserButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserButton
func (recv *FileChooserButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserButton
func (recv *FileChooserButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserButton
func (recv *FileChooserButton) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FileChooserButton
func (recv *FileChooserButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FileChooserDialog is a wrapper around the C record GtkFileChooserDialog.
type FileChooserDialog struct {
	native *C.GtkFileChooserDialog
	// parent_instance : record
	// priv : record
}

func FileChooserDialogNewFromC(u unsafe.Pointer) *FileChooserDialog {
	c := (*C.GtkFileChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserDialog with another FileChooserDialog, and returns true if they represent the same GObject.
func (recv *FileChooserDialog) Equals(other *FileChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *FileChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FileChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FileChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FileChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to FileChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserDialog.
func CastToFileChooserDialog(object *gobject.Object) *FileChooserDialog {
	return FileChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserDialog
func (recv *FileChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserDialog
func (recv *FileChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserDialog
func (recv *FileChooserDialog) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// FileChooserWidget is a wrapper around the C record GtkFileChooserWidget.
type FileChooserWidget struct {
	native *C.GtkFileChooserWidget
	// parent_instance : record
	// priv : record
}

func FileChooserWidgetNewFromC(u unsafe.Pointer) *FileChooserWidget {
	c := (*C.GtkFileChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserWidget with another FileChooserWidget, and returns true if they represent the same GObject.
func (recv *FileChooserWidget) Equals(other *FileChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *FileChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FileChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to FileChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserWidget.
func CastToFileChooserWidget(object *gobject.Object) *FileChooserWidget {
	return FileChooserWidgetNewFromC(object.ToC())
}

type signalFileChooserWidgetDesktopFolderDetail struct {
	callback  FileChooserWidgetSignalDesktopFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetDesktopFolderId int
var signalFileChooserWidgetDesktopFolderMap = make(map[int]signalFileChooserWidgetDesktopFolderDetail)
var signalFileChooserWidgetDesktopFolderLock sync.RWMutex

// FileChooserWidgetSignalDesktopFolderCallback is a callback function for a 'desktop-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalDesktopFolderCallback func()

/*
ConnectDesktopFolder connects the callback to the 'desktop-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectDesktopFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectDesktopFolder(callback FileChooserWidgetSignalDesktopFolderCallback) int {
	signalFileChooserWidgetDesktopFolderLock.Lock()
	defer signalFileChooserWidgetDesktopFolderLock.Unlock()

	signalFileChooserWidgetDesktopFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_desktop_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetDesktopFolderId)))

	detail := signalFileChooserWidgetDesktopFolderDetail{callback, handlerID}
	signalFileChooserWidgetDesktopFolderMap[signalFileChooserWidgetDesktopFolderId] = detail

	return signalFileChooserWidgetDesktopFolderId
}

/*
DisconnectDesktopFolder disconnects a callback from the 'desktop-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectDesktopFolder.
*/
func (recv *FileChooserWidget) DisconnectDesktopFolder(connectionID int) {
	signalFileChooserWidgetDesktopFolderLock.Lock()
	defer signalFileChooserWidgetDesktopFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetDesktopFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetDesktopFolderMap, connectionID)
}

//export filechooserwidget_desktopFolderHandler
func filechooserwidget_desktopFolderHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetDesktopFolderLock.RLock()
	defer signalFileChooserWidgetDesktopFolderLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetDesktopFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetDownFolderDetail struct {
	callback  FileChooserWidgetSignalDownFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetDownFolderId int
var signalFileChooserWidgetDownFolderMap = make(map[int]signalFileChooserWidgetDownFolderDetail)
var signalFileChooserWidgetDownFolderLock sync.RWMutex

// FileChooserWidgetSignalDownFolderCallback is a callback function for a 'down-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalDownFolderCallback func()

/*
ConnectDownFolder connects the callback to the 'down-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectDownFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectDownFolder(callback FileChooserWidgetSignalDownFolderCallback) int {
	signalFileChooserWidgetDownFolderLock.Lock()
	defer signalFileChooserWidgetDownFolderLock.Unlock()

	signalFileChooserWidgetDownFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_down_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetDownFolderId)))

	detail := signalFileChooserWidgetDownFolderDetail{callback, handlerID}
	signalFileChooserWidgetDownFolderMap[signalFileChooserWidgetDownFolderId] = detail

	return signalFileChooserWidgetDownFolderId
}

/*
DisconnectDownFolder disconnects a callback from the 'down-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectDownFolder.
*/
func (recv *FileChooserWidget) DisconnectDownFolder(connectionID int) {
	signalFileChooserWidgetDownFolderLock.Lock()
	defer signalFileChooserWidgetDownFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetDownFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetDownFolderMap, connectionID)
}

//export filechooserwidget_downFolderHandler
func filechooserwidget_downFolderHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetDownFolderLock.RLock()
	defer signalFileChooserWidgetDownFolderLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetDownFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetHomeFolderDetail struct {
	callback  FileChooserWidgetSignalHomeFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetHomeFolderId int
var signalFileChooserWidgetHomeFolderMap = make(map[int]signalFileChooserWidgetHomeFolderDetail)
var signalFileChooserWidgetHomeFolderLock sync.RWMutex

// FileChooserWidgetSignalHomeFolderCallback is a callback function for a 'home-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalHomeFolderCallback func()

/*
ConnectHomeFolder connects the callback to the 'home-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectHomeFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectHomeFolder(callback FileChooserWidgetSignalHomeFolderCallback) int {
	signalFileChooserWidgetHomeFolderLock.Lock()
	defer signalFileChooserWidgetHomeFolderLock.Unlock()

	signalFileChooserWidgetHomeFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_home_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetHomeFolderId)))

	detail := signalFileChooserWidgetHomeFolderDetail{callback, handlerID}
	signalFileChooserWidgetHomeFolderMap[signalFileChooserWidgetHomeFolderId] = detail

	return signalFileChooserWidgetHomeFolderId
}

/*
DisconnectHomeFolder disconnects a callback from the 'home-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectHomeFolder.
*/
func (recv *FileChooserWidget) DisconnectHomeFolder(connectionID int) {
	signalFileChooserWidgetHomeFolderLock.Lock()
	defer signalFileChooserWidgetHomeFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetHomeFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetHomeFolderMap, connectionID)
}

//export filechooserwidget_homeFolderHandler
func filechooserwidget_homeFolderHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetHomeFolderLock.RLock()
	defer signalFileChooserWidgetHomeFolderLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetHomeFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetLocationPopupDetail struct {
	callback  FileChooserWidgetSignalLocationPopupCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationPopupId int
var signalFileChooserWidgetLocationPopupMap = make(map[int]signalFileChooserWidgetLocationPopupDetail)
var signalFileChooserWidgetLocationPopupLock sync.RWMutex

// FileChooserWidgetSignalLocationPopupCallback is a callback function for a 'location-popup' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationPopupCallback func(path string)

/*
ConnectLocationPopup connects the callback to the 'location-popup' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationPopup to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationPopup(callback FileChooserWidgetSignalLocationPopupCallback) int {
	signalFileChooserWidgetLocationPopupLock.Lock()
	defer signalFileChooserWidgetLocationPopupLock.Unlock()

	signalFileChooserWidgetLocationPopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_popup(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationPopupId)))

	detail := signalFileChooserWidgetLocationPopupDetail{callback, handlerID}
	signalFileChooserWidgetLocationPopupMap[signalFileChooserWidgetLocationPopupId] = detail

	return signalFileChooserWidgetLocationPopupId
}

/*
DisconnectLocationPopup disconnects a callback from the 'location-popup' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationPopup.
*/
func (recv *FileChooserWidget) DisconnectLocationPopup(connectionID int) {
	signalFileChooserWidgetLocationPopupLock.Lock()
	defer signalFileChooserWidgetLocationPopupLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationPopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationPopupMap, connectionID)
}

//export filechooserwidget_locationPopupHandler
func filechooserwidget_locationPopupHandler(_ *C.GObject, c_path *C.gchar, data C.gpointer) {
	signalFileChooserWidgetLocationPopupLock.RLock()
	defer signalFileChooserWidgetLocationPopupLock.RUnlock()

	path := C.GoString(c_path)

	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationPopupMap[index].callback
	callback(path)
}

type signalFileChooserWidgetLocationPopupOnPasteDetail struct {
	callback  FileChooserWidgetSignalLocationPopupOnPasteCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationPopupOnPasteId int
var signalFileChooserWidgetLocationPopupOnPasteMap = make(map[int]signalFileChooserWidgetLocationPopupOnPasteDetail)
var signalFileChooserWidgetLocationPopupOnPasteLock sync.RWMutex

// FileChooserWidgetSignalLocationPopupOnPasteCallback is a callback function for a 'location-popup-on-paste' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationPopupOnPasteCallback func()

/*
ConnectLocationPopupOnPaste connects the callback to the 'location-popup-on-paste' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationPopupOnPaste to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationPopupOnPaste(callback FileChooserWidgetSignalLocationPopupOnPasteCallback) int {
	signalFileChooserWidgetLocationPopupOnPasteLock.Lock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.Unlock()

	signalFileChooserWidgetLocationPopupOnPasteId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_popup_on_paste(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationPopupOnPasteId)))

	detail := signalFileChooserWidgetLocationPopupOnPasteDetail{callback, handlerID}
	signalFileChooserWidgetLocationPopupOnPasteMap[signalFileChooserWidgetLocationPopupOnPasteId] = detail

	return signalFileChooserWidgetLocationPopupOnPasteId
}

/*
DisconnectLocationPopupOnPaste disconnects a callback from the 'location-popup-on-paste' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationPopupOnPaste.
*/
func (recv *FileChooserWidget) DisconnectLocationPopupOnPaste(connectionID int) {
	signalFileChooserWidgetLocationPopupOnPasteLock.Lock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationPopupOnPasteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationPopupOnPasteMap, connectionID)
}

//export filechooserwidget_locationPopupOnPasteHandler
func filechooserwidget_locationPopupOnPasteHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetLocationPopupOnPasteLock.RLock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationPopupOnPasteMap[index].callback
	callback()
}

type signalFileChooserWidgetLocationTogglePopupDetail struct {
	callback  FileChooserWidgetSignalLocationTogglePopupCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationTogglePopupId int
var signalFileChooserWidgetLocationTogglePopupMap = make(map[int]signalFileChooserWidgetLocationTogglePopupDetail)
var signalFileChooserWidgetLocationTogglePopupLock sync.RWMutex

// FileChooserWidgetSignalLocationTogglePopupCallback is a callback function for a 'location-toggle-popup' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationTogglePopupCallback func()

/*
ConnectLocationTogglePopup connects the callback to the 'location-toggle-popup' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationTogglePopup to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationTogglePopup(callback FileChooserWidgetSignalLocationTogglePopupCallback) int {
	signalFileChooserWidgetLocationTogglePopupLock.Lock()
	defer signalFileChooserWidgetLocationTogglePopupLock.Unlock()

	signalFileChooserWidgetLocationTogglePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_toggle_popup(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationTogglePopupId)))

	detail := signalFileChooserWidgetLocationTogglePopupDetail{callback, handlerID}
	signalFileChooserWidgetLocationTogglePopupMap[signalFileChooserWidgetLocationTogglePopupId] = detail

	return signalFileChooserWidgetLocationTogglePopupId
}

/*
DisconnectLocationTogglePopup disconnects a callback from the 'location-toggle-popup' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationTogglePopup.
*/
func (recv *FileChooserWidget) DisconnectLocationTogglePopup(connectionID int) {
	signalFileChooserWidgetLocationTogglePopupLock.Lock()
	defer signalFileChooserWidgetLocationTogglePopupLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationTogglePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationTogglePopupMap, connectionID)
}

//export filechooserwidget_locationTogglePopupHandler
func filechooserwidget_locationTogglePopupHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetLocationTogglePopupLock.RLock()
	defer signalFileChooserWidgetLocationTogglePopupLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationTogglePopupMap[index].callback
	callback()
}

type signalFileChooserWidgetPlacesShortcutDetail struct {
	callback  FileChooserWidgetSignalPlacesShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetPlacesShortcutId int
var signalFileChooserWidgetPlacesShortcutMap = make(map[int]signalFileChooserWidgetPlacesShortcutDetail)
var signalFileChooserWidgetPlacesShortcutLock sync.RWMutex

// FileChooserWidgetSignalPlacesShortcutCallback is a callback function for a 'places-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalPlacesShortcutCallback func()

/*
ConnectPlacesShortcut connects the callback to the 'places-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectPlacesShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectPlacesShortcut(callback FileChooserWidgetSignalPlacesShortcutCallback) int {
	signalFileChooserWidgetPlacesShortcutLock.Lock()
	defer signalFileChooserWidgetPlacesShortcutLock.Unlock()

	signalFileChooserWidgetPlacesShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_places_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetPlacesShortcutId)))

	detail := signalFileChooserWidgetPlacesShortcutDetail{callback, handlerID}
	signalFileChooserWidgetPlacesShortcutMap[signalFileChooserWidgetPlacesShortcutId] = detail

	return signalFileChooserWidgetPlacesShortcutId
}

/*
DisconnectPlacesShortcut disconnects a callback from the 'places-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectPlacesShortcut.
*/
func (recv *FileChooserWidget) DisconnectPlacesShortcut(connectionID int) {
	signalFileChooserWidgetPlacesShortcutLock.Lock()
	defer signalFileChooserWidgetPlacesShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetPlacesShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetPlacesShortcutMap, connectionID)
}

//export filechooserwidget_placesShortcutHandler
func filechooserwidget_placesShortcutHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetPlacesShortcutLock.RLock()
	defer signalFileChooserWidgetPlacesShortcutLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetPlacesShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetQuickBookmarkDetail struct {
	callback  FileChooserWidgetSignalQuickBookmarkCallback
	handlerID C.gulong
}

var signalFileChooserWidgetQuickBookmarkId int
var signalFileChooserWidgetQuickBookmarkMap = make(map[int]signalFileChooserWidgetQuickBookmarkDetail)
var signalFileChooserWidgetQuickBookmarkLock sync.RWMutex

// FileChooserWidgetSignalQuickBookmarkCallback is a callback function for a 'quick-bookmark' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalQuickBookmarkCallback func(bookmarkIndex int32)

/*
ConnectQuickBookmark connects the callback to the 'quick-bookmark' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectQuickBookmark to remove it.
*/
func (recv *FileChooserWidget) ConnectQuickBookmark(callback FileChooserWidgetSignalQuickBookmarkCallback) int {
	signalFileChooserWidgetQuickBookmarkLock.Lock()
	defer signalFileChooserWidgetQuickBookmarkLock.Unlock()

	signalFileChooserWidgetQuickBookmarkId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_quick_bookmark(instance, C.gpointer(uintptr(signalFileChooserWidgetQuickBookmarkId)))

	detail := signalFileChooserWidgetQuickBookmarkDetail{callback, handlerID}
	signalFileChooserWidgetQuickBookmarkMap[signalFileChooserWidgetQuickBookmarkId] = detail

	return signalFileChooserWidgetQuickBookmarkId
}

/*
DisconnectQuickBookmark disconnects a callback from the 'quick-bookmark' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectQuickBookmark.
*/
func (recv *FileChooserWidget) DisconnectQuickBookmark(connectionID int) {
	signalFileChooserWidgetQuickBookmarkLock.Lock()
	defer signalFileChooserWidgetQuickBookmarkLock.Unlock()

	detail, exists := signalFileChooserWidgetQuickBookmarkMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetQuickBookmarkMap, connectionID)
}

//export filechooserwidget_quickBookmarkHandler
func filechooserwidget_quickBookmarkHandler(_ *C.GObject, c_bookmark_index C.gint, data C.gpointer) {
	signalFileChooserWidgetQuickBookmarkLock.RLock()
	defer signalFileChooserWidgetQuickBookmarkLock.RUnlock()

	bookmarkIndex := int32(c_bookmark_index)

	index := int(uintptr(data))
	callback := signalFileChooserWidgetQuickBookmarkMap[index].callback
	callback(bookmarkIndex)
}

type signalFileChooserWidgetRecentShortcutDetail struct {
	callback  FileChooserWidgetSignalRecentShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetRecentShortcutId int
var signalFileChooserWidgetRecentShortcutMap = make(map[int]signalFileChooserWidgetRecentShortcutDetail)
var signalFileChooserWidgetRecentShortcutLock sync.RWMutex

// FileChooserWidgetSignalRecentShortcutCallback is a callback function for a 'recent-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalRecentShortcutCallback func()

/*
ConnectRecentShortcut connects the callback to the 'recent-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectRecentShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectRecentShortcut(callback FileChooserWidgetSignalRecentShortcutCallback) int {
	signalFileChooserWidgetRecentShortcutLock.Lock()
	defer signalFileChooserWidgetRecentShortcutLock.Unlock()

	signalFileChooserWidgetRecentShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_recent_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetRecentShortcutId)))

	detail := signalFileChooserWidgetRecentShortcutDetail{callback, handlerID}
	signalFileChooserWidgetRecentShortcutMap[signalFileChooserWidgetRecentShortcutId] = detail

	return signalFileChooserWidgetRecentShortcutId
}

/*
DisconnectRecentShortcut disconnects a callback from the 'recent-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectRecentShortcut.
*/
func (recv *FileChooserWidget) DisconnectRecentShortcut(connectionID int) {
	signalFileChooserWidgetRecentShortcutLock.Lock()
	defer signalFileChooserWidgetRecentShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetRecentShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetRecentShortcutMap, connectionID)
}

//export filechooserwidget_recentShortcutHandler
func filechooserwidget_recentShortcutHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetRecentShortcutLock.RLock()
	defer signalFileChooserWidgetRecentShortcutLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetRecentShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetSearchShortcutDetail struct {
	callback  FileChooserWidgetSignalSearchShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetSearchShortcutId int
var signalFileChooserWidgetSearchShortcutMap = make(map[int]signalFileChooserWidgetSearchShortcutDetail)
var signalFileChooserWidgetSearchShortcutLock sync.RWMutex

// FileChooserWidgetSignalSearchShortcutCallback is a callback function for a 'search-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalSearchShortcutCallback func()

/*
ConnectSearchShortcut connects the callback to the 'search-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectSearchShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectSearchShortcut(callback FileChooserWidgetSignalSearchShortcutCallback) int {
	signalFileChooserWidgetSearchShortcutLock.Lock()
	defer signalFileChooserWidgetSearchShortcutLock.Unlock()

	signalFileChooserWidgetSearchShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_search_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetSearchShortcutId)))

	detail := signalFileChooserWidgetSearchShortcutDetail{callback, handlerID}
	signalFileChooserWidgetSearchShortcutMap[signalFileChooserWidgetSearchShortcutId] = detail

	return signalFileChooserWidgetSearchShortcutId
}

/*
DisconnectSearchShortcut disconnects a callback from the 'search-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectSearchShortcut.
*/
func (recv *FileChooserWidget) DisconnectSearchShortcut(connectionID int) {
	signalFileChooserWidgetSearchShortcutLock.Lock()
	defer signalFileChooserWidgetSearchShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetSearchShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetSearchShortcutMap, connectionID)
}

//export filechooserwidget_searchShortcutHandler
func filechooserwidget_searchShortcutHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetSearchShortcutLock.RLock()
	defer signalFileChooserWidgetSearchShortcutLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetSearchShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetShowHiddenDetail struct {
	callback  FileChooserWidgetSignalShowHiddenCallback
	handlerID C.gulong
}

var signalFileChooserWidgetShowHiddenId int
var signalFileChooserWidgetShowHiddenMap = make(map[int]signalFileChooserWidgetShowHiddenDetail)
var signalFileChooserWidgetShowHiddenLock sync.RWMutex

// FileChooserWidgetSignalShowHiddenCallback is a callback function for a 'show-hidden' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalShowHiddenCallback func()

/*
ConnectShowHidden connects the callback to the 'show-hidden' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectShowHidden to remove it.
*/
func (recv *FileChooserWidget) ConnectShowHidden(callback FileChooserWidgetSignalShowHiddenCallback) int {
	signalFileChooserWidgetShowHiddenLock.Lock()
	defer signalFileChooserWidgetShowHiddenLock.Unlock()

	signalFileChooserWidgetShowHiddenId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_show_hidden(instance, C.gpointer(uintptr(signalFileChooserWidgetShowHiddenId)))

	detail := signalFileChooserWidgetShowHiddenDetail{callback, handlerID}
	signalFileChooserWidgetShowHiddenMap[signalFileChooserWidgetShowHiddenId] = detail

	return signalFileChooserWidgetShowHiddenId
}

/*
DisconnectShowHidden disconnects a callback from the 'show-hidden' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectShowHidden.
*/
func (recv *FileChooserWidget) DisconnectShowHidden(connectionID int) {
	signalFileChooserWidgetShowHiddenLock.Lock()
	defer signalFileChooserWidgetShowHiddenLock.Unlock()

	detail, exists := signalFileChooserWidgetShowHiddenMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetShowHiddenMap, connectionID)
}

//export filechooserwidget_showHiddenHandler
func filechooserwidget_showHiddenHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetShowHiddenLock.RLock()
	defer signalFileChooserWidgetShowHiddenLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetShowHiddenMap[index].callback
	callback()
}

type signalFileChooserWidgetUpFolderDetail struct {
	callback  FileChooserWidgetSignalUpFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetUpFolderId int
var signalFileChooserWidgetUpFolderMap = make(map[int]signalFileChooserWidgetUpFolderDetail)
var signalFileChooserWidgetUpFolderLock sync.RWMutex

// FileChooserWidgetSignalUpFolderCallback is a callback function for a 'up-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalUpFolderCallback func()

/*
ConnectUpFolder connects the callback to the 'up-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectUpFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectUpFolder(callback FileChooserWidgetSignalUpFolderCallback) int {
	signalFileChooserWidgetUpFolderLock.Lock()
	defer signalFileChooserWidgetUpFolderLock.Unlock()

	signalFileChooserWidgetUpFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_up_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetUpFolderId)))

	detail := signalFileChooserWidgetUpFolderDetail{callback, handlerID}
	signalFileChooserWidgetUpFolderMap[signalFileChooserWidgetUpFolderId] = detail

	return signalFileChooserWidgetUpFolderId
}

/*
DisconnectUpFolder disconnects a callback from the 'up-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectUpFolder.
*/
func (recv *FileChooserWidget) DisconnectUpFolder(connectionID int) {
	signalFileChooserWidgetUpFolderLock.Lock()
	defer signalFileChooserWidgetUpFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetUpFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetUpFolderMap, connectionID)
}

//export filechooserwidget_upFolderHandler
func filechooserwidget_upFolderHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetUpFolderLock.RLock()
	defer signalFileChooserWidgetUpFolderLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetUpFolderMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserWidget
func (recv *FileChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserWidget
func (recv *FileChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserWidget
func (recv *FileChooserWidget) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FileChooserWidget
func (recv *FileChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FileFilter is a wrapper around the C record GtkFileFilter.
type FileFilter struct {
	native *C.GtkFileFilter
}

func FileFilterNewFromC(u unsafe.Pointer) *FileFilter {
	c := (*C.GtkFileFilter)(u)
	if c == nil {
		return nil
	}

	g := &FileFilter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileFilter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileFilter with another FileFilter, and returns true if they represent the same GObject.
func (recv *FileFilter) Equals(other *FileFilter) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileFilter) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FileFilter) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to FileFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileFilter.
func CastToFileFilter(object *gobject.Object) *FileFilter {
	return FileFilterNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by FileFilter
func (recv *FileFilter) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Fixed is a wrapper around the C record GtkFixed.
type Fixed struct {
	native *C.GtkFixed
	// container : record
	// Private : priv
}

func FixedNewFromC(u unsafe.Pointer) *Fixed {
	c := (*C.GtkFixed)(u)
	if c == nil {
		return nil
	}

	g := &Fixed{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Fixed) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Fixed) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Fixed with another Fixed, and returns true if they represent the same GObject.
func (recv *Fixed) Equals(other *Fixed) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Fixed) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Fixed) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Fixed) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Fixed) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Fixed.
// Exercise care, as this is a potentially dangerous function if the Object is not a Fixed.
func CastToFixed(object *gobject.Object) *Fixed {
	return FixedNewFromC(object.ToC())
}

// Blacklisted : gtk_fixed_new

// Blacklisted : gtk_fixed_move

// Blacklisted : gtk_fixed_put

// ImplementorIface returns the ImplementorIface interface implemented by Fixed
func (recv *Fixed) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Fixed
func (recv *Fixed) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FlowBox is a wrapper around the C record GtkFlowBox.
type FlowBox struct {
	native *C.GtkFlowBox
	// container : record
}

func FlowBoxNewFromC(u unsafe.Pointer) *FlowBox {
	c := (*C.GtkFlowBox)(u)
	if c == nil {
		return nil
	}

	g := &FlowBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FlowBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FlowBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBox with another FlowBox, and returns true if they represent the same GObject.
func (recv *FlowBox) Equals(other *FlowBox) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *FlowBox) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *FlowBox) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FlowBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FlowBox) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to FlowBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBox.
func CastToFlowBox(object *gobject.Object) *FlowBox {
	return FlowBoxNewFromC(object.ToC())
}

type signalFlowBoxActivateCursorChildDetail struct {
	callback  FlowBoxSignalActivateCursorChildCallback
	handlerID C.gulong
}

var signalFlowBoxActivateCursorChildId int
var signalFlowBoxActivateCursorChildMap = make(map[int]signalFlowBoxActivateCursorChildDetail)
var signalFlowBoxActivateCursorChildLock sync.RWMutex

// FlowBoxSignalActivateCursorChildCallback is a callback function for a 'activate-cursor-child' signal emitted from a FlowBox.
type FlowBoxSignalActivateCursorChildCallback func()

/*
ConnectActivateCursorChild connects the callback to the 'activate-cursor-child' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectActivateCursorChild to remove it.
*/
func (recv *FlowBox) ConnectActivateCursorChild(callback FlowBoxSignalActivateCursorChildCallback) int {
	signalFlowBoxActivateCursorChildLock.Lock()
	defer signalFlowBoxActivateCursorChildLock.Unlock()

	signalFlowBoxActivateCursorChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_activate_cursor_child(instance, C.gpointer(uintptr(signalFlowBoxActivateCursorChildId)))

	detail := signalFlowBoxActivateCursorChildDetail{callback, handlerID}
	signalFlowBoxActivateCursorChildMap[signalFlowBoxActivateCursorChildId] = detail

	return signalFlowBoxActivateCursorChildId
}

/*
DisconnectActivateCursorChild disconnects a callback from the 'activate-cursor-child' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectActivateCursorChild.
*/
func (recv *FlowBox) DisconnectActivateCursorChild(connectionID int) {
	signalFlowBoxActivateCursorChildLock.Lock()
	defer signalFlowBoxActivateCursorChildLock.Unlock()

	detail, exists := signalFlowBoxActivateCursorChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxActivateCursorChildMap, connectionID)
}

//export flowbox_activateCursorChildHandler
func flowbox_activateCursorChildHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxActivateCursorChildLock.RLock()
	defer signalFlowBoxActivateCursorChildLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxActivateCursorChildMap[index].callback
	callback()
}

type signalFlowBoxChildActivatedDetail struct {
	callback  FlowBoxSignalChildActivatedCallback
	handlerID C.gulong
}

var signalFlowBoxChildActivatedId int
var signalFlowBoxChildActivatedMap = make(map[int]signalFlowBoxChildActivatedDetail)
var signalFlowBoxChildActivatedLock sync.RWMutex

// FlowBoxSignalChildActivatedCallback is a callback function for a 'child-activated' signal emitted from a FlowBox.
type FlowBoxSignalChildActivatedCallback func(child *FlowBoxChild)

/*
ConnectChildActivated connects the callback to the 'child-activated' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectChildActivated to remove it.
*/
func (recv *FlowBox) ConnectChildActivated(callback FlowBoxSignalChildActivatedCallback) int {
	signalFlowBoxChildActivatedLock.Lock()
	defer signalFlowBoxChildActivatedLock.Unlock()

	signalFlowBoxChildActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_child_activated(instance, C.gpointer(uintptr(signalFlowBoxChildActivatedId)))

	detail := signalFlowBoxChildActivatedDetail{callback, handlerID}
	signalFlowBoxChildActivatedMap[signalFlowBoxChildActivatedId] = detail

	return signalFlowBoxChildActivatedId
}

/*
DisconnectChildActivated disconnects a callback from the 'child-activated' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectChildActivated.
*/
func (recv *FlowBox) DisconnectChildActivated(connectionID int) {
	signalFlowBoxChildActivatedLock.Lock()
	defer signalFlowBoxChildActivatedLock.Unlock()

	detail, exists := signalFlowBoxChildActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxChildActivatedMap, connectionID)
}

//export flowbox_childActivatedHandler
func flowbox_childActivatedHandler(_ *C.GObject, c_child *C.GtkFlowBoxChild, data C.gpointer) {
	signalFlowBoxChildActivatedLock.RLock()
	defer signalFlowBoxChildActivatedLock.RUnlock()

	child := FlowBoxChildNewFromC(unsafe.Pointer(c_child))

	index := int(uintptr(data))
	callback := signalFlowBoxChildActivatedMap[index].callback
	callback(child)
}

type signalFlowBoxMoveCursorDetail struct {
	callback  FlowBoxSignalMoveCursorCallback
	handlerID C.gulong
}

var signalFlowBoxMoveCursorId int
var signalFlowBoxMoveCursorMap = make(map[int]signalFlowBoxMoveCursorDetail)
var signalFlowBoxMoveCursorLock sync.RWMutex

// FlowBoxSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a FlowBox.
type FlowBoxSignalMoveCursorCallback func(step MovementStep, count int32) bool

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *FlowBox) ConnectMoveCursor(callback FlowBoxSignalMoveCursorCallback) int {
	signalFlowBoxMoveCursorLock.Lock()
	defer signalFlowBoxMoveCursorLock.Unlock()

	signalFlowBoxMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalFlowBoxMoveCursorId)))

	detail := signalFlowBoxMoveCursorDetail{callback, handlerID}
	signalFlowBoxMoveCursorMap[signalFlowBoxMoveCursorId] = detail

	return signalFlowBoxMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *FlowBox) DisconnectMoveCursor(connectionID int) {
	signalFlowBoxMoveCursorLock.Lock()
	defer signalFlowBoxMoveCursorLock.Unlock()

	detail, exists := signalFlowBoxMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxMoveCursorMap, connectionID)
}

//export flowbox_moveCursorHandler
func flowbox_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, data C.gpointer) C.gboolean {
	signalFlowBoxMoveCursorLock.RLock()
	defer signalFlowBoxMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalFlowBoxMoveCursorMap[index].callback
	retGo := callback(step, count)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalFlowBoxSelectAllDetail struct {
	callback  FlowBoxSignalSelectAllCallback
	handlerID C.gulong
}

var signalFlowBoxSelectAllId int
var signalFlowBoxSelectAllMap = make(map[int]signalFlowBoxSelectAllDetail)
var signalFlowBoxSelectAllLock sync.RWMutex

// FlowBoxSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a FlowBox.
type FlowBoxSignalSelectAllCallback func()

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *FlowBox) ConnectSelectAll(callback FlowBoxSignalSelectAllCallback) int {
	signalFlowBoxSelectAllLock.Lock()
	defer signalFlowBoxSelectAllLock.Unlock()

	signalFlowBoxSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_select_all(instance, C.gpointer(uintptr(signalFlowBoxSelectAllId)))

	detail := signalFlowBoxSelectAllDetail{callback, handlerID}
	signalFlowBoxSelectAllMap[signalFlowBoxSelectAllId] = detail

	return signalFlowBoxSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *FlowBox) DisconnectSelectAll(connectionID int) {
	signalFlowBoxSelectAllLock.Lock()
	defer signalFlowBoxSelectAllLock.Unlock()

	detail, exists := signalFlowBoxSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxSelectAllMap, connectionID)
}

//export flowbox_selectAllHandler
func flowbox_selectAllHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxSelectAllLock.RLock()
	defer signalFlowBoxSelectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxSelectAllMap[index].callback
	callback()
}

type signalFlowBoxSelectedChildrenChangedDetail struct {
	callback  FlowBoxSignalSelectedChildrenChangedCallback
	handlerID C.gulong
}

var signalFlowBoxSelectedChildrenChangedId int
var signalFlowBoxSelectedChildrenChangedMap = make(map[int]signalFlowBoxSelectedChildrenChangedDetail)
var signalFlowBoxSelectedChildrenChangedLock sync.RWMutex

// FlowBoxSignalSelectedChildrenChangedCallback is a callback function for a 'selected-children-changed' signal emitted from a FlowBox.
type FlowBoxSignalSelectedChildrenChangedCallback func()

/*
ConnectSelectedChildrenChanged connects the callback to the 'selected-children-changed' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectSelectedChildrenChanged to remove it.
*/
func (recv *FlowBox) ConnectSelectedChildrenChanged(callback FlowBoxSignalSelectedChildrenChangedCallback) int {
	signalFlowBoxSelectedChildrenChangedLock.Lock()
	defer signalFlowBoxSelectedChildrenChangedLock.Unlock()

	signalFlowBoxSelectedChildrenChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_selected_children_changed(instance, C.gpointer(uintptr(signalFlowBoxSelectedChildrenChangedId)))

	detail := signalFlowBoxSelectedChildrenChangedDetail{callback, handlerID}
	signalFlowBoxSelectedChildrenChangedMap[signalFlowBoxSelectedChildrenChangedId] = detail

	return signalFlowBoxSelectedChildrenChangedId
}

/*
DisconnectSelectedChildrenChanged disconnects a callback from the 'selected-children-changed' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectSelectedChildrenChanged.
*/
func (recv *FlowBox) DisconnectSelectedChildrenChanged(connectionID int) {
	signalFlowBoxSelectedChildrenChangedLock.Lock()
	defer signalFlowBoxSelectedChildrenChangedLock.Unlock()

	detail, exists := signalFlowBoxSelectedChildrenChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxSelectedChildrenChangedMap, connectionID)
}

//export flowbox_selectedChildrenChangedHandler
func flowbox_selectedChildrenChangedHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxSelectedChildrenChangedLock.RLock()
	defer signalFlowBoxSelectedChildrenChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxSelectedChildrenChangedMap[index].callback
	callback()
}

type signalFlowBoxToggleCursorChildDetail struct {
	callback  FlowBoxSignalToggleCursorChildCallback
	handlerID C.gulong
}

var signalFlowBoxToggleCursorChildId int
var signalFlowBoxToggleCursorChildMap = make(map[int]signalFlowBoxToggleCursorChildDetail)
var signalFlowBoxToggleCursorChildLock sync.RWMutex

// FlowBoxSignalToggleCursorChildCallback is a callback function for a 'toggle-cursor-child' signal emitted from a FlowBox.
type FlowBoxSignalToggleCursorChildCallback func()

/*
ConnectToggleCursorChild connects the callback to the 'toggle-cursor-child' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectToggleCursorChild to remove it.
*/
func (recv *FlowBox) ConnectToggleCursorChild(callback FlowBoxSignalToggleCursorChildCallback) int {
	signalFlowBoxToggleCursorChildLock.Lock()
	defer signalFlowBoxToggleCursorChildLock.Unlock()

	signalFlowBoxToggleCursorChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_toggle_cursor_child(instance, C.gpointer(uintptr(signalFlowBoxToggleCursorChildId)))

	detail := signalFlowBoxToggleCursorChildDetail{callback, handlerID}
	signalFlowBoxToggleCursorChildMap[signalFlowBoxToggleCursorChildId] = detail

	return signalFlowBoxToggleCursorChildId
}

/*
DisconnectToggleCursorChild disconnects a callback from the 'toggle-cursor-child' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectToggleCursorChild.
*/
func (recv *FlowBox) DisconnectToggleCursorChild(connectionID int) {
	signalFlowBoxToggleCursorChildLock.Lock()
	defer signalFlowBoxToggleCursorChildLock.Unlock()

	detail, exists := signalFlowBoxToggleCursorChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxToggleCursorChildMap, connectionID)
}

//export flowbox_toggleCursorChildHandler
func flowbox_toggleCursorChildHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxToggleCursorChildLock.RLock()
	defer signalFlowBoxToggleCursorChildLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxToggleCursorChildMap[index].callback
	callback()
}

type signalFlowBoxUnselectAllDetail struct {
	callback  FlowBoxSignalUnselectAllCallback
	handlerID C.gulong
}

var signalFlowBoxUnselectAllId int
var signalFlowBoxUnselectAllMap = make(map[int]signalFlowBoxUnselectAllDetail)
var signalFlowBoxUnselectAllLock sync.RWMutex

// FlowBoxSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a FlowBox.
type FlowBoxSignalUnselectAllCallback func()

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *FlowBox) ConnectUnselectAll(callback FlowBoxSignalUnselectAllCallback) int {
	signalFlowBoxUnselectAllLock.Lock()
	defer signalFlowBoxUnselectAllLock.Unlock()

	signalFlowBoxUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalFlowBoxUnselectAllId)))

	detail := signalFlowBoxUnselectAllDetail{callback, handlerID}
	signalFlowBoxUnselectAllMap[signalFlowBoxUnselectAllId] = detail

	return signalFlowBoxUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *FlowBox) DisconnectUnselectAll(connectionID int) {
	signalFlowBoxUnselectAllLock.Lock()
	defer signalFlowBoxUnselectAllLock.Unlock()

	detail, exists := signalFlowBoxUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxUnselectAllMap, connectionID)
}

//export flowbox_unselectAllHandler
func flowbox_unselectAllHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxUnselectAllLock.RLock()
	defer signalFlowBoxUnselectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxUnselectAllMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FlowBox
func (recv *FlowBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FlowBox
func (recv *FlowBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FlowBox
func (recv *FlowBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FlowBoxAccessible is a wrapper around the C record GtkFlowBoxAccessible.
type FlowBoxAccessible struct {
	native *C.GtkFlowBoxAccessible
	// parent : record
	// priv : record
}

func FlowBoxAccessibleNewFromC(u unsafe.Pointer) *FlowBoxAccessible {
	c := (*C.GtkFlowBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FlowBoxAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FlowBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxAccessible with another FlowBoxAccessible, and returns true if they represent the same GObject.
func (recv *FlowBoxAccessible) Equals(other *FlowBoxAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FlowBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FlowBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FlowBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FlowBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to FlowBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxAccessible.
func CastToFlowBoxAccessible(object *gobject.Object) *FlowBoxAccessible {
	return FlowBoxAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FlowBoxAccessible
func (recv *FlowBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by FlowBoxAccessible
func (recv *FlowBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// FlowBoxChild is a wrapper around the C record GtkFlowBoxChild.
type FlowBoxChild struct {
	native *C.GtkFlowBoxChild
	// parent_instance : record
}

func FlowBoxChildNewFromC(u unsafe.Pointer) *FlowBoxChild {
	c := (*C.GtkFlowBoxChild)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChild{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FlowBoxChild) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FlowBoxChild) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxChild with another FlowBoxChild, and returns true if they represent the same GObject.
func (recv *FlowBoxChild) Equals(other *FlowBoxChild) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *FlowBoxChild) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FlowBoxChild) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *FlowBoxChild) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FlowBoxChild) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FlowBoxChild) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to FlowBoxChild.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxChild.
func CastToFlowBoxChild(object *gobject.Object) *FlowBoxChild {
	return FlowBoxChildNewFromC(object.ToC())
}

type signalFlowBoxChildActivateDetail struct {
	callback  FlowBoxChildSignalActivateCallback
	handlerID C.gulong
}

var signalFlowBoxChildActivateId int
var signalFlowBoxChildActivateMap = make(map[int]signalFlowBoxChildActivateDetail)
var signalFlowBoxChildActivateLock sync.RWMutex

// FlowBoxChildSignalActivateCallback is a callback function for a 'activate' signal emitted from a FlowBoxChild.
type FlowBoxChildSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the FlowBoxChild.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *FlowBoxChild) ConnectActivate(callback FlowBoxChildSignalActivateCallback) int {
	signalFlowBoxChildActivateLock.Lock()
	defer signalFlowBoxChildActivateLock.Unlock()

	signalFlowBoxChildActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBoxChild_signal_connect_activate(instance, C.gpointer(uintptr(signalFlowBoxChildActivateId)))

	detail := signalFlowBoxChildActivateDetail{callback, handlerID}
	signalFlowBoxChildActivateMap[signalFlowBoxChildActivateId] = detail

	return signalFlowBoxChildActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the FlowBoxChild.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *FlowBoxChild) DisconnectActivate(connectionID int) {
	signalFlowBoxChildActivateLock.Lock()
	defer signalFlowBoxChildActivateLock.Unlock()

	detail, exists := signalFlowBoxChildActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxChildActivateMap, connectionID)
}

//export flowboxchild_activateHandler
func flowboxchild_activateHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxChildActivateLock.RLock()
	defer signalFlowBoxChildActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxChildActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FlowBoxChild
func (recv *FlowBoxChild) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FlowBoxChild
func (recv *FlowBoxChild) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FlowBoxChildAccessible is a wrapper around the C record GtkFlowBoxChildAccessible.
type FlowBoxChildAccessible struct {
	native *C.GtkFlowBoxChildAccessible
	// parent : record
}

func FlowBoxChildAccessibleNewFromC(u unsafe.Pointer) *FlowBoxChildAccessible {
	c := (*C.GtkFlowBoxChildAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChildAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FlowBoxChildAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FlowBoxChildAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxChildAccessible with another FlowBoxChildAccessible, and returns true if they represent the same GObject.
func (recv *FlowBoxChildAccessible) Equals(other *FlowBoxChildAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FlowBoxChildAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FlowBoxChildAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FlowBoxChildAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FlowBoxChildAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to FlowBoxChildAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxChildAccessible.
func CastToFlowBoxChildAccessible(object *gobject.Object) *FlowBoxChildAccessible {
	return FlowBoxChildAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FlowBoxChildAccessible
func (recv *FlowBoxChildAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// FontButton is a wrapper around the C record GtkFontButton.
type FontButton struct {
	native *C.GtkFontButton
	// button : record
	// Private : priv
}

func FontButtonNewFromC(u unsafe.Pointer) *FontButton {
	c := (*C.GtkFontButton)(u)
	if c == nil {
		return nil
	}

	g := &FontButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontButton with another FontButton, and returns true if they represent the same GObject.
func (recv *FontButton) Equals(other *FontButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *FontButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *FontButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *FontButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *FontButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to FontButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontButton.
func CastToFontButton(object *gobject.Object) *FontButton {
	return FontButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontButton
func (recv *FontButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by FontButton
func (recv *FontButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by FontButton
func (recv *FontButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontButton
func (recv *FontButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontButton
func (recv *FontButton) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// FontChooserDialog is a wrapper around the C record GtkFontChooserDialog.
type FontChooserDialog struct {
	native *C.GtkFontChooserDialog
	// parent_instance : record
	// Private : priv
}

func FontChooserDialogNewFromC(u unsafe.Pointer) *FontChooserDialog {
	c := (*C.GtkFontChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserDialog with another FontChooserDialog, and returns true if they represent the same GObject.
func (recv *FontChooserDialog) Equals(other *FontChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *FontChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FontChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FontChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FontChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FontChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to FontChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontChooserDialog.
func CastToFontChooserDialog(object *gobject.Object) *FontChooserDialog {
	return FontChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontChooserDialog
func (recv *FontChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontChooserDialog
func (recv *FontChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontChooserDialog
func (recv *FontChooserDialog) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// FontChooserWidget is a wrapper around the C record GtkFontChooserWidget.
type FontChooserWidget struct {
	native *C.GtkFontChooserWidget
	// parent_instance : record
	// Private : priv
}

func FontChooserWidgetNewFromC(u unsafe.Pointer) *FontChooserWidget {
	c := (*C.GtkFontChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserWidget with another FontChooserWidget, and returns true if they represent the same GObject.
func (recv *FontChooserWidget) Equals(other *FontChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *FontChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FontChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FontChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to FontChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontChooserWidget.
func CastToFontChooserWidget(object *gobject.Object) *FontChooserWidget {
	return FontChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontChooserWidget
func (recv *FontChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontChooserWidget
func (recv *FontChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontChooserWidget
func (recv *FontChooserWidget) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FontChooserWidget
func (recv *FontChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FontSelection is a wrapper around the C record GtkFontSelection.
type FontSelection struct {
	native *C.GtkFontSelection
	// parent_instance : record
	// Private : priv
}

func FontSelectionNewFromC(u unsafe.Pointer) *FontSelection {
	c := (*C.GtkFontSelection)(u)
	if c == nil {
		return nil
	}

	g := &FontSelection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontSelection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontSelection with another FontSelection, and returns true if they represent the same GObject.
func (recv *FontSelection) Equals(other *FontSelection) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *FontSelection) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FontSelection) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FontSelection) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontSelection) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontSelection) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to FontSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontSelection.
func CastToFontSelection(object *gobject.Object) *FontSelection {
	return FontSelectionNewFromC(object.ToC())
}

// Blacklisted : gtk_font_selection_new

// Blacklisted : gtk_font_selection_get_font_name

// Blacklisted : gtk_font_selection_get_preview_text

// Blacklisted : gtk_font_selection_set_font_name

// Blacklisted : gtk_font_selection_set_preview_text

// ImplementorIface returns the ImplementorIface interface implemented by FontSelection
func (recv *FontSelection) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontSelection
func (recv *FontSelection) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FontSelection
func (recv *FontSelection) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FontSelectionDialog is a wrapper around the C record GtkFontSelectionDialog.
type FontSelectionDialog struct {
	native *C.GtkFontSelectionDialog
	// parent_instance : record
	// Private : priv
}

func FontSelectionDialogNewFromC(u unsafe.Pointer) *FontSelectionDialog {
	c := (*C.GtkFontSelectionDialog)(u)
	if c == nil {
		return nil
	}

	g := &FontSelectionDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontSelectionDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontSelectionDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontSelectionDialog with another FontSelectionDialog, and returns true if they represent the same GObject.
func (recv *FontSelectionDialog) Equals(other *FontSelectionDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *FontSelectionDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FontSelectionDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FontSelectionDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FontSelectionDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FontSelectionDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontSelectionDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontSelectionDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to FontSelectionDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontSelectionDialog.
func CastToFontSelectionDialog(object *gobject.Object) *FontSelectionDialog {
	return FontSelectionDialogNewFromC(object.ToC())
}

// Blacklisted : gtk_font_selection_dialog_new

// Blacklisted : gtk_font_selection_dialog_get_font_name

// Blacklisted : gtk_font_selection_dialog_get_preview_text

// Blacklisted : gtk_font_selection_dialog_set_font_name

// Blacklisted : gtk_font_selection_dialog_set_preview_text

// ImplementorIface returns the ImplementorIface interface implemented by FontSelectionDialog
func (recv *FontSelectionDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontSelectionDialog
func (recv *FontSelectionDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Frame is a wrapper around the C record GtkFrame.
type Frame struct {
	native *C.GtkFrame
	// bin : record
	// Private : priv
}

func FrameNewFromC(u unsafe.Pointer) *Frame {
	c := (*C.GtkFrame)(u)
	if c == nil {
		return nil
	}

	g := &Frame{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Frame) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Frame) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Frame with another Frame, and returns true if they represent the same GObject.
func (recv *Frame) Equals(other *Frame) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Frame) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Frame) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Frame) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Frame) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Frame) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Frame.
// Exercise care, as this is a potentially dangerous function if the Object is not a Frame.
func CastToFrame(object *gobject.Object) *Frame {
	return FrameNewFromC(object.ToC())
}

// Blacklisted : gtk_frame_new

// Blacklisted : gtk_frame_get_label

// Blacklisted : gtk_frame_get_label_align

// Blacklisted : gtk_frame_get_label_widget

// Blacklisted : gtk_frame_get_shadow_type

// Blacklisted : gtk_frame_set_label

// Blacklisted : gtk_frame_set_label_align

// Blacklisted : gtk_frame_set_label_widget

// Blacklisted : gtk_frame_set_shadow_type

// ImplementorIface returns the ImplementorIface interface implemented by Frame
func (recv *Frame) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Frame
func (recv *Frame) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FrameAccessible is a wrapper around the C record GtkFrameAccessible.
type FrameAccessible struct {
	native *C.GtkFrameAccessible
	// parent : record
	// priv : record
}

func FrameAccessibleNewFromC(u unsafe.Pointer) *FrameAccessible {
	c := (*C.GtkFrameAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FrameAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FrameAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FrameAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FrameAccessible with another FrameAccessible, and returns true if they represent the same GObject.
func (recv *FrameAccessible) Equals(other *FrameAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FrameAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FrameAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FrameAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FrameAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to FrameAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FrameAccessible.
func CastToFrameAccessible(object *gobject.Object) *FrameAccessible {
	return FrameAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FrameAccessible
func (recv *FrameAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Gesture is a wrapper around the C record GtkGesture.
type Gesture struct {
	native *C.GtkGesture
}

func GestureNewFromC(u unsafe.Pointer) *Gesture {
	c := (*C.GtkGesture)(u)
	if c == nil {
		return nil
	}

	g := &Gesture{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Gesture) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Gesture) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Gesture with another Gesture, and returns true if they represent the same GObject.
func (recv *Gesture) Equals(other *Gesture) bool {
	return other.ToC() == recv.ToC()
}

// EventController upcasts to *EventController
func (recv *Gesture) EventController() *EventController {
	return EventControllerNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Gesture) Object() *gobject.Object {
	return recv.EventController().Object()
}

// CastToWidget down casts any arbitrary Object to Gesture.
// Exercise care, as this is a potentially dangerous function if the Object is not a Gesture.
func CastToGesture(object *gobject.Object) *Gesture {
	return GestureNewFromC(object.ToC())
}

// Unsupported : gtk_gesture_get_last_event : no return generator

// GestureDrag is a wrapper around the C record GtkGestureDrag.
type GestureDrag struct {
	native *C.GtkGestureDrag
}

func GestureDragNewFromC(u unsafe.Pointer) *GestureDrag {
	c := (*C.GtkGestureDrag)(u)
	if c == nil {
		return nil
	}

	g := &GestureDrag{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureDrag) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureDrag) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureDrag with another GestureDrag, and returns true if they represent the same GObject.
func (recv *GestureDrag) Equals(other *GestureDrag) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureDrag) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureDrag) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureDrag) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureDrag) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitrary Object to GestureDrag.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureDrag.
func CastToGestureDrag(object *gobject.Object) *GestureDrag {
	return GestureDragNewFromC(object.ToC())
}

// GestureLongPress is a wrapper around the C record GtkGestureLongPress.
type GestureLongPress struct {
	native *C.GtkGestureLongPress
}

func GestureLongPressNewFromC(u unsafe.Pointer) *GestureLongPress {
	c := (*C.GtkGestureLongPress)(u)
	if c == nil {
		return nil
	}

	g := &GestureLongPress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureLongPress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureLongPress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureLongPress with another GestureLongPress, and returns true if they represent the same GObject.
func (recv *GestureLongPress) Equals(other *GestureLongPress) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureLongPress) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureLongPress) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureLongPress) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureLongPress) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitrary Object to GestureLongPress.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureLongPress.
func CastToGestureLongPress(object *gobject.Object) *GestureLongPress {
	return GestureLongPressNewFromC(object.ToC())
}

// GestureMultiPress is a wrapper around the C record GtkGestureMultiPress.
type GestureMultiPress struct {
	native *C.GtkGestureMultiPress
}

func GestureMultiPressNewFromC(u unsafe.Pointer) *GestureMultiPress {
	c := (*C.GtkGestureMultiPress)(u)
	if c == nil {
		return nil
	}

	g := &GestureMultiPress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureMultiPress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureMultiPress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureMultiPress with another GestureMultiPress, and returns true if they represent the same GObject.
func (recv *GestureMultiPress) Equals(other *GestureMultiPress) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureMultiPress) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureMultiPress) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureMultiPress) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureMultiPress) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitrary Object to GestureMultiPress.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureMultiPress.
func CastToGestureMultiPress(object *gobject.Object) *GestureMultiPress {
	return GestureMultiPressNewFromC(object.ToC())
}

// GesturePan is a wrapper around the C record GtkGesturePan.
type GesturePan struct {
	native *C.GtkGesturePan
}

func GesturePanNewFromC(u unsafe.Pointer) *GesturePan {
	c := (*C.GtkGesturePan)(u)
	if c == nil {
		return nil
	}

	g := &GesturePan{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GesturePan) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GesturePan) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GesturePan with another GesturePan, and returns true if they represent the same GObject.
func (recv *GesturePan) Equals(other *GesturePan) bool {
	return other.ToC() == recv.ToC()
}

// GestureDrag upcasts to *GestureDrag
func (recv *GesturePan) GestureDrag() *GestureDrag {
	return GestureDragNewFromC(unsafe.Pointer(recv.native))
}

// GestureSingle upcasts to *GestureSingle
func (recv *GesturePan) GestureSingle() *GestureSingle {
	return recv.GestureDrag().GestureSingle()
}

// Gesture upcasts to *Gesture
func (recv *GesturePan) Gesture() *Gesture {
	return recv.GestureDrag().Gesture()
}

// EventController upcasts to *EventController
func (recv *GesturePan) EventController() *EventController {
	return recv.GestureDrag().EventController()
}

// Object upcasts to *Object
func (recv *GesturePan) Object() *gobject.Object {
	return recv.GestureDrag().Object()
}

// CastToWidget down casts any arbitrary Object to GesturePan.
// Exercise care, as this is a potentially dangerous function if the Object is not a GesturePan.
func CastToGesturePan(object *gobject.Object) *GesturePan {
	return GesturePanNewFromC(object.ToC())
}

// GestureRotate is a wrapper around the C record GtkGestureRotate.
type GestureRotate struct {
	native *C.GtkGestureRotate
}

func GestureRotateNewFromC(u unsafe.Pointer) *GestureRotate {
	c := (*C.GtkGestureRotate)(u)
	if c == nil {
		return nil
	}

	g := &GestureRotate{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureRotate) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureRotate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureRotate with another GestureRotate, and returns true if they represent the same GObject.
func (recv *GestureRotate) Equals(other *GestureRotate) bool {
	return other.ToC() == recv.ToC()
}

// Gesture upcasts to *Gesture
func (recv *GestureRotate) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureRotate) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureRotate) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitrary Object to GestureRotate.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureRotate.
func CastToGestureRotate(object *gobject.Object) *GestureRotate {
	return GestureRotateNewFromC(object.ToC())
}

// GestureSingle is a wrapper around the C record GtkGestureSingle.
type GestureSingle struct {
	native *C.GtkGestureSingle
}

func GestureSingleNewFromC(u unsafe.Pointer) *GestureSingle {
	c := (*C.GtkGestureSingle)(u)
	if c == nil {
		return nil
	}

	g := &GestureSingle{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureSingle) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureSingle) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureSingle with another GestureSingle, and returns true if they represent the same GObject.
func (recv *GestureSingle) Equals(other *GestureSingle) bool {
	return other.ToC() == recv.ToC()
}

// Gesture upcasts to *Gesture
func (recv *GestureSingle) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureSingle) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureSingle) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitrary Object to GestureSingle.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureSingle.
func CastToGestureSingle(object *gobject.Object) *GestureSingle {
	return GestureSingleNewFromC(object.ToC())
}

// GestureSwipe is a wrapper around the C record GtkGestureSwipe.
type GestureSwipe struct {
	native *C.GtkGestureSwipe
}

func GestureSwipeNewFromC(u unsafe.Pointer) *GestureSwipe {
	c := (*C.GtkGestureSwipe)(u)
	if c == nil {
		return nil
	}

	g := &GestureSwipe{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureSwipe) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureSwipe) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureSwipe with another GestureSwipe, and returns true if they represent the same GObject.
func (recv *GestureSwipe) Equals(other *GestureSwipe) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureSwipe) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureSwipe) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureSwipe) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureSwipe) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitrary Object to GestureSwipe.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureSwipe.
func CastToGestureSwipe(object *gobject.Object) *GestureSwipe {
	return GestureSwipeNewFromC(object.ToC())
}

// GestureZoom is a wrapper around the C record GtkGestureZoom.
type GestureZoom struct {
	native *C.GtkGestureZoom
}

func GestureZoomNewFromC(u unsafe.Pointer) *GestureZoom {
	c := (*C.GtkGestureZoom)(u)
	if c == nil {
		return nil
	}

	g := &GestureZoom{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureZoom) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureZoom) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureZoom with another GestureZoom, and returns true if they represent the same GObject.
func (recv *GestureZoom) Equals(other *GestureZoom) bool {
	return other.ToC() == recv.ToC()
}

// Gesture upcasts to *Gesture
func (recv *GestureZoom) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureZoom) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureZoom) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitrary Object to GestureZoom.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureZoom.
func CastToGestureZoom(object *gobject.Object) *GestureZoom {
	return GestureZoomNewFromC(object.ToC())
}

// Grid is a wrapper around the C record GtkGrid.
type Grid struct {
	native *C.GtkGrid
	// Private : container
	// Private : priv
}

func GridNewFromC(u unsafe.Pointer) *Grid {
	c := (*C.GtkGrid)(u)
	if c == nil {
		return nil
	}

	g := &Grid{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Grid) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Grid) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Grid with another Grid, and returns true if they represent the same GObject.
func (recv *Grid) Equals(other *Grid) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Grid) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Grid) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Grid) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Grid) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Grid.
// Exercise care, as this is a potentially dangerous function if the Object is not a Grid.
func CastToGrid(object *gobject.Object) *Grid {
	return GridNewFromC(object.ToC())
}

// Blacklisted : gtk_grid_new

// Blacklisted : gtk_grid_attach

// Blacklisted : gtk_grid_attach_next_to

// Blacklisted : gtk_grid_get_column_homogeneous

// Blacklisted : gtk_grid_get_column_spacing

// Blacklisted : gtk_grid_get_row_homogeneous

// Blacklisted : gtk_grid_get_row_spacing

// Blacklisted : gtk_grid_set_column_homogeneous

// Blacklisted : gtk_grid_set_column_spacing

// Blacklisted : gtk_grid_set_row_homogeneous

// Blacklisted : gtk_grid_set_row_spacing

// ImplementorIface returns the ImplementorIface interface implemented by Grid
func (recv *Grid) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Grid
func (recv *Grid) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Grid
func (recv *Grid) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HBox is a wrapper around the C record GtkHBox.
type HBox struct {
	native *C.GtkHBox
	// box : record
}

func HBoxNewFromC(u unsafe.Pointer) *HBox {
	c := (*C.GtkHBox)(u)
	if c == nil {
		return nil
	}

	g := &HBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HBox with another HBox, and returns true if they represent the same GObject.
func (recv *HBox) Equals(other *HBox) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *HBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *HBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to HBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HBox.
func CastToHBox(object *gobject.Object) *HBox {
	return HBoxNewFromC(object.ToC())
}

// Blacklisted : gtk_hbox_new

// ImplementorIface returns the ImplementorIface interface implemented by HBox
func (recv *HBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HBox
func (recv *HBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HBox
func (recv *HBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HButtonBox is a wrapper around the C record GtkHButtonBox.
type HButtonBox struct {
	native *C.GtkHButtonBox
	// button_box : record
}

func HButtonBoxNewFromC(u unsafe.Pointer) *HButtonBox {
	c := (*C.GtkHButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &HButtonBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HButtonBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HButtonBox with another HButtonBox, and returns true if they represent the same GObject.
func (recv *HButtonBox) Equals(other *HButtonBox) bool {
	return other.ToC() == recv.ToC()
}

// ButtonBox upcasts to *ButtonBox
func (recv *HButtonBox) ButtonBox() *ButtonBox {
	return ButtonBoxNewFromC(unsafe.Pointer(recv.native))
}

// Box upcasts to *Box
func (recv *HButtonBox) Box() *Box {
	return recv.ButtonBox().Box()
}

// Container upcasts to *Container
func (recv *HButtonBox) Container() *Container {
	return recv.ButtonBox().Container()
}

// Widget upcasts to *Widget
func (recv *HButtonBox) Widget() *Widget {
	return recv.ButtonBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ButtonBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HButtonBox) Object() *gobject.Object {
	return recv.ButtonBox().Object()
}

// CastToWidget down casts any arbitrary Object to HButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HButtonBox.
func CastToHButtonBox(object *gobject.Object) *HButtonBox {
	return HButtonBoxNewFromC(object.ToC())
}

// Blacklisted : gtk_hbutton_box_new

// ImplementorIface returns the ImplementorIface interface implemented by HButtonBox
func (recv *HButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HButtonBox
func (recv *HButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HButtonBox
func (recv *HButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HPaned is a wrapper around the C record GtkHPaned.
type HPaned struct {
	native *C.GtkHPaned
	// paned : record
}

func HPanedNewFromC(u unsafe.Pointer) *HPaned {
	c := (*C.GtkHPaned)(u)
	if c == nil {
		return nil
	}

	g := &HPaned{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HPaned) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HPaned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HPaned with another HPaned, and returns true if they represent the same GObject.
func (recv *HPaned) Equals(other *HPaned) bool {
	return other.ToC() == recv.ToC()
}

// Paned upcasts to *Paned
func (recv *HPaned) Paned() *Paned {
	return PanedNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HPaned) Container() *Container {
	return recv.Paned().Container()
}

// Widget upcasts to *Widget
func (recv *HPaned) Widget() *Widget {
	return recv.Paned().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HPaned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Paned().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HPaned) Object() *gobject.Object {
	return recv.Paned().Object()
}

// CastToWidget down casts any arbitrary Object to HPaned.
// Exercise care, as this is a potentially dangerous function if the Object is not a HPaned.
func CastToHPaned(object *gobject.Object) *HPaned {
	return HPanedNewFromC(object.ToC())
}

// Blacklisted : gtk_hpaned_new

// ImplementorIface returns the ImplementorIface interface implemented by HPaned
func (recv *HPaned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HPaned
func (recv *HPaned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HPaned
func (recv *HPaned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HSV is a wrapper around the C record GtkHSV.
type HSV struct {
	native *C.GtkHSV
	// parent_instance : record
	// Private : priv
}

func HSVNewFromC(u unsafe.Pointer) *HSV {
	c := (*C.GtkHSV)(u)
	if c == nil {
		return nil
	}

	g := &HSV{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HSV) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HSV) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HSV with another HSV, and returns true if they represent the same GObject.
func (recv *HSV) Equals(other *HSV) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *HSV) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HSV) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HSV) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to HSV.
// Exercise care, as this is a potentially dangerous function if the Object is not a HSV.
func CastToHSV(object *gobject.Object) *HSV {
	return HSVNewFromC(object.ToC())
}

type signalHSVChangedDetail struct {
	callback  HSVSignalChangedCallback
	handlerID C.gulong
}

var signalHSVChangedId int
var signalHSVChangedMap = make(map[int]signalHSVChangedDetail)
var signalHSVChangedLock sync.RWMutex

// HSVSignalChangedCallback is a callback function for a 'changed' signal emitted from a HSV.
type HSVSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the HSV.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *HSV) ConnectChanged(callback HSVSignalChangedCallback) int {
	signalHSVChangedLock.Lock()
	defer signalHSVChangedLock.Unlock()

	signalHSVChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HSV_signal_connect_changed(instance, C.gpointer(uintptr(signalHSVChangedId)))

	detail := signalHSVChangedDetail{callback, handlerID}
	signalHSVChangedMap[signalHSVChangedId] = detail

	return signalHSVChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the HSV.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *HSV) DisconnectChanged(connectionID int) {
	signalHSVChangedLock.Lock()
	defer signalHSVChangedLock.Unlock()

	detail, exists := signalHSVChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHSVChangedMap, connectionID)
}

//export hsv_changedHandler
func hsv_changedHandler(_ *C.GObject, data C.gpointer) {
	signalHSVChangedLock.RLock()
	defer signalHSVChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalHSVChangedMap[index].callback
	callback()
}

type signalHSVMoveDetail struct {
	callback  HSVSignalMoveCallback
	handlerID C.gulong
}

var signalHSVMoveId int
var signalHSVMoveMap = make(map[int]signalHSVMoveDetail)
var signalHSVMoveLock sync.RWMutex

// HSVSignalMoveCallback is a callback function for a 'move' signal emitted from a HSV.
type HSVSignalMoveCallback func(object DirectionType)

/*
ConnectMove connects the callback to the 'move' signal for the HSV.

The returned value represents the connection, and may be passed to DisconnectMove to remove it.
*/
func (recv *HSV) ConnectMove(callback HSVSignalMoveCallback) int {
	signalHSVMoveLock.Lock()
	defer signalHSVMoveLock.Unlock()

	signalHSVMoveId++
	instance := C.gpointer(recv.native)
	handlerID := C.HSV_signal_connect_move(instance, C.gpointer(uintptr(signalHSVMoveId)))

	detail := signalHSVMoveDetail{callback, handlerID}
	signalHSVMoveMap[signalHSVMoveId] = detail

	return signalHSVMoveId
}

/*
DisconnectMove disconnects a callback from the 'move' signal for the HSV.

The connectionID should be a value returned from a call to ConnectMove.
*/
func (recv *HSV) DisconnectMove(connectionID int) {
	signalHSVMoveLock.Lock()
	defer signalHSVMoveLock.Unlock()

	detail, exists := signalHSVMoveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHSVMoveMap, connectionID)
}

//export hsv_moveHandler
func hsv_moveHandler(_ *C.GObject, c_object C.GtkDirectionType, data C.gpointer) {
	signalHSVMoveLock.RLock()
	defer signalHSVMoveLock.RUnlock()

	object := DirectionType(c_object)

	index := int(uintptr(data))
	callback := signalHSVMoveMap[index].callback
	callback(object)
}

// ImplementorIface returns the ImplementorIface interface implemented by HSV
func (recv *HSV) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HSV
func (recv *HSV) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// HScale is a wrapper around the C record GtkHScale.
type HScale struct {
	native *C.GtkHScale
	// scale : record
}

func HScaleNewFromC(u unsafe.Pointer) *HScale {
	c := (*C.GtkHScale)(u)
	if c == nil {
		return nil
	}

	g := &HScale{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HScale) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HScale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HScale with another HScale, and returns true if they represent the same GObject.
func (recv *HScale) Equals(other *HScale) bool {
	return other.ToC() == recv.ToC()
}

// Scale upcasts to *Scale
func (recv *HScale) Scale() *Scale {
	return ScaleNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *HScale) Range() *Range {
	return recv.Scale().Range()
}

// Widget upcasts to *Widget
func (recv *HScale) Widget() *Widget {
	return recv.Scale().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HScale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scale().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HScale) Object() *gobject.Object {
	return recv.Scale().Object()
}

// CastToWidget down casts any arbitrary Object to HScale.
// Exercise care, as this is a potentially dangerous function if the Object is not a HScale.
func CastToHScale(object *gobject.Object) *HScale {
	return HScaleNewFromC(object.ToC())
}

// Blacklisted : gtk_hscale_new

// Blacklisted : gtk_hscale_new_with_range

// ImplementorIface returns the ImplementorIface interface implemented by HScale
func (recv *HScale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HScale
func (recv *HScale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HScale
func (recv *HScale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HScrollbar is a wrapper around the C record GtkHScrollbar.
type HScrollbar struct {
	native *C.GtkHScrollbar
	// scrollbar : record
}

func HScrollbarNewFromC(u unsafe.Pointer) *HScrollbar {
	c := (*C.GtkHScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &HScrollbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HScrollbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HScrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HScrollbar with another HScrollbar, and returns true if they represent the same GObject.
func (recv *HScrollbar) Equals(other *HScrollbar) bool {
	return other.ToC() == recv.ToC()
}

// Scrollbar upcasts to *Scrollbar
func (recv *HScrollbar) Scrollbar() *Scrollbar {
	return ScrollbarNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *HScrollbar) Range() *Range {
	return recv.Scrollbar().Range()
}

// Widget upcasts to *Widget
func (recv *HScrollbar) Widget() *Widget {
	return recv.Scrollbar().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HScrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scrollbar().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HScrollbar) Object() *gobject.Object {
	return recv.Scrollbar().Object()
}

// CastToWidget down casts any arbitrary Object to HScrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a HScrollbar.
func CastToHScrollbar(object *gobject.Object) *HScrollbar {
	return HScrollbarNewFromC(object.ToC())
}

// Blacklisted : gtk_hscrollbar_new

// ImplementorIface returns the ImplementorIface interface implemented by HScrollbar
func (recv *HScrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HScrollbar
func (recv *HScrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HScrollbar
func (recv *HScrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HSeparator is a wrapper around the C record GtkHSeparator.
type HSeparator struct {
	native *C.GtkHSeparator
	// separator : record
}

func HSeparatorNewFromC(u unsafe.Pointer) *HSeparator {
	c := (*C.GtkHSeparator)(u)
	if c == nil {
		return nil
	}

	g := &HSeparator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HSeparator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HSeparator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HSeparator with another HSeparator, and returns true if they represent the same GObject.
func (recv *HSeparator) Equals(other *HSeparator) bool {
	return other.ToC() == recv.ToC()
}

// Separator upcasts to *Separator
func (recv *HSeparator) Separator() *Separator {
	return SeparatorNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *HSeparator) Widget() *Widget {
	return recv.Separator().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HSeparator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Separator().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HSeparator) Object() *gobject.Object {
	return recv.Separator().Object()
}

// CastToWidget down casts any arbitrary Object to HSeparator.
// Exercise care, as this is a potentially dangerous function if the Object is not a HSeparator.
func CastToHSeparator(object *gobject.Object) *HSeparator {
	return HSeparatorNewFromC(object.ToC())
}

// Blacklisted : gtk_hseparator_new

// ImplementorIface returns the ImplementorIface interface implemented by HSeparator
func (recv *HSeparator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HSeparator
func (recv *HSeparator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HSeparator
func (recv *HSeparator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HandleBox is a wrapper around the C record GtkHandleBox.
type HandleBox struct {
	native *C.GtkHandleBox
	// bin : record
	// Private : priv
}

func HandleBoxNewFromC(u unsafe.Pointer) *HandleBox {
	c := (*C.GtkHandleBox)(u)
	if c == nil {
		return nil
	}

	g := &HandleBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HandleBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HandleBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HandleBox with another HandleBox, and returns true if they represent the same GObject.
func (recv *HandleBox) Equals(other *HandleBox) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *HandleBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HandleBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *HandleBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HandleBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HandleBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to HandleBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HandleBox.
func CastToHandleBox(object *gobject.Object) *HandleBox {
	return HandleBoxNewFromC(object.ToC())
}

type signalHandleBoxChildAttachedDetail struct {
	callback  HandleBoxSignalChildAttachedCallback
	handlerID C.gulong
}

var signalHandleBoxChildAttachedId int
var signalHandleBoxChildAttachedMap = make(map[int]signalHandleBoxChildAttachedDetail)
var signalHandleBoxChildAttachedLock sync.RWMutex

// HandleBoxSignalChildAttachedCallback is a callback function for a 'child-attached' signal emitted from a HandleBox.
type HandleBoxSignalChildAttachedCallback func(widget *Widget)

/*
ConnectChildAttached connects the callback to the 'child-attached' signal for the HandleBox.

The returned value represents the connection, and may be passed to DisconnectChildAttached to remove it.
*/
func (recv *HandleBox) ConnectChildAttached(callback HandleBoxSignalChildAttachedCallback) int {
	signalHandleBoxChildAttachedLock.Lock()
	defer signalHandleBoxChildAttachedLock.Unlock()

	signalHandleBoxChildAttachedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HandleBox_signal_connect_child_attached(instance, C.gpointer(uintptr(signalHandleBoxChildAttachedId)))

	detail := signalHandleBoxChildAttachedDetail{callback, handlerID}
	signalHandleBoxChildAttachedMap[signalHandleBoxChildAttachedId] = detail

	return signalHandleBoxChildAttachedId
}

/*
DisconnectChildAttached disconnects a callback from the 'child-attached' signal for the HandleBox.

The connectionID should be a value returned from a call to ConnectChildAttached.
*/
func (recv *HandleBox) DisconnectChildAttached(connectionID int) {
	signalHandleBoxChildAttachedLock.Lock()
	defer signalHandleBoxChildAttachedLock.Unlock()

	detail, exists := signalHandleBoxChildAttachedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHandleBoxChildAttachedMap, connectionID)
}

//export handlebox_childAttachedHandler
func handlebox_childAttachedHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	signalHandleBoxChildAttachedLock.RLock()
	defer signalHandleBoxChildAttachedLock.RUnlock()

	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalHandleBoxChildAttachedMap[index].callback
	callback(widget)
}

type signalHandleBoxChildDetachedDetail struct {
	callback  HandleBoxSignalChildDetachedCallback
	handlerID C.gulong
}

var signalHandleBoxChildDetachedId int
var signalHandleBoxChildDetachedMap = make(map[int]signalHandleBoxChildDetachedDetail)
var signalHandleBoxChildDetachedLock sync.RWMutex

// HandleBoxSignalChildDetachedCallback is a callback function for a 'child-detached' signal emitted from a HandleBox.
type HandleBoxSignalChildDetachedCallback func(widget *Widget)

/*
ConnectChildDetached connects the callback to the 'child-detached' signal for the HandleBox.

The returned value represents the connection, and may be passed to DisconnectChildDetached to remove it.
*/
func (recv *HandleBox) ConnectChildDetached(callback HandleBoxSignalChildDetachedCallback) int {
	signalHandleBoxChildDetachedLock.Lock()
	defer signalHandleBoxChildDetachedLock.Unlock()

	signalHandleBoxChildDetachedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HandleBox_signal_connect_child_detached(instance, C.gpointer(uintptr(signalHandleBoxChildDetachedId)))

	detail := signalHandleBoxChildDetachedDetail{callback, handlerID}
	signalHandleBoxChildDetachedMap[signalHandleBoxChildDetachedId] = detail

	return signalHandleBoxChildDetachedId
}

/*
DisconnectChildDetached disconnects a callback from the 'child-detached' signal for the HandleBox.

The connectionID should be a value returned from a call to ConnectChildDetached.
*/
func (recv *HandleBox) DisconnectChildDetached(connectionID int) {
	signalHandleBoxChildDetachedLock.Lock()
	defer signalHandleBoxChildDetachedLock.Unlock()

	detail, exists := signalHandleBoxChildDetachedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHandleBoxChildDetachedMap, connectionID)
}

//export handlebox_childDetachedHandler
func handlebox_childDetachedHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	signalHandleBoxChildDetachedLock.RLock()
	defer signalHandleBoxChildDetachedLock.RUnlock()

	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalHandleBoxChildDetachedMap[index].callback
	callback(widget)
}

// Blacklisted : gtk_handle_box_new

// Blacklisted : gtk_handle_box_get_handle_position

// Blacklisted : gtk_handle_box_get_shadow_type

// Blacklisted : gtk_handle_box_get_snap_edge

// Blacklisted : gtk_handle_box_set_handle_position

// Blacklisted : gtk_handle_box_set_shadow_type

// Blacklisted : gtk_handle_box_set_snap_edge

// ImplementorIface returns the ImplementorIface interface implemented by HandleBox
func (recv *HandleBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HandleBox
func (recv *HandleBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// HeaderBar is a wrapper around the C record GtkHeaderBar.
type HeaderBar struct {
	native *C.GtkHeaderBar
	// container : record
}

func HeaderBarNewFromC(u unsafe.Pointer) *HeaderBar {
	c := (*C.GtkHeaderBar)(u)
	if c == nil {
		return nil
	}

	g := &HeaderBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HeaderBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HeaderBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HeaderBar with another HeaderBar, and returns true if they represent the same GObject.
func (recv *HeaderBar) Equals(other *HeaderBar) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *HeaderBar) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *HeaderBar) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HeaderBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HeaderBar) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to HeaderBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a HeaderBar.
func CastToHeaderBar(object *gobject.Object) *HeaderBar {
	return HeaderBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by HeaderBar
func (recv *HeaderBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HeaderBar
func (recv *HeaderBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// IMContext is a wrapper around the C record GtkIMContext.
type IMContext struct {
	native *C.GtkIMContext
	// parent_instance : record
}

func IMContextNewFromC(u unsafe.Pointer) *IMContext {
	c := (*C.GtkIMContext)(u)
	if c == nil {
		return nil
	}

	g := &IMContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IMContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IMContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMContext with another IMContext, and returns true if they represent the same GObject.
func (recv *IMContext) Equals(other *IMContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IMContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IMContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMContext.
func CastToIMContext(object *gobject.Object) *IMContext {
	return IMContextNewFromC(object.ToC())
}

type signalIMContextCommitDetail struct {
	callback  IMContextSignalCommitCallback
	handlerID C.gulong
}

var signalIMContextCommitId int
var signalIMContextCommitMap = make(map[int]signalIMContextCommitDetail)
var signalIMContextCommitLock sync.RWMutex

// IMContextSignalCommitCallback is a callback function for a 'commit' signal emitted from a IMContext.
type IMContextSignalCommitCallback func(str string)

/*
ConnectCommit connects the callback to the 'commit' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectCommit to remove it.
*/
func (recv *IMContext) ConnectCommit(callback IMContextSignalCommitCallback) int {
	signalIMContextCommitLock.Lock()
	defer signalIMContextCommitLock.Unlock()

	signalIMContextCommitId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_commit(instance, C.gpointer(uintptr(signalIMContextCommitId)))

	detail := signalIMContextCommitDetail{callback, handlerID}
	signalIMContextCommitMap[signalIMContextCommitId] = detail

	return signalIMContextCommitId
}

/*
DisconnectCommit disconnects a callback from the 'commit' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectCommit.
*/
func (recv *IMContext) DisconnectCommit(connectionID int) {
	signalIMContextCommitLock.Lock()
	defer signalIMContextCommitLock.Unlock()

	detail, exists := signalIMContextCommitMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextCommitMap, connectionID)
}

//export imcontext_commitHandler
func imcontext_commitHandler(_ *C.GObject, c_str *C.gchar, data C.gpointer) {
	signalIMContextCommitLock.RLock()
	defer signalIMContextCommitLock.RUnlock()

	str := C.GoString(c_str)

	index := int(uintptr(data))
	callback := signalIMContextCommitMap[index].callback
	callback(str)
}

type signalIMContextDeleteSurroundingDetail struct {
	callback  IMContextSignalDeleteSurroundingCallback
	handlerID C.gulong
}

var signalIMContextDeleteSurroundingId int
var signalIMContextDeleteSurroundingMap = make(map[int]signalIMContextDeleteSurroundingDetail)
var signalIMContextDeleteSurroundingLock sync.RWMutex

// IMContextSignalDeleteSurroundingCallback is a callback function for a 'delete-surrounding' signal emitted from a IMContext.
type IMContextSignalDeleteSurroundingCallback func(offset int32, nChars int32) bool

/*
ConnectDeleteSurrounding connects the callback to the 'delete-surrounding' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectDeleteSurrounding to remove it.
*/
func (recv *IMContext) ConnectDeleteSurrounding(callback IMContextSignalDeleteSurroundingCallback) int {
	signalIMContextDeleteSurroundingLock.Lock()
	defer signalIMContextDeleteSurroundingLock.Unlock()

	signalIMContextDeleteSurroundingId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_delete_surrounding(instance, C.gpointer(uintptr(signalIMContextDeleteSurroundingId)))

	detail := signalIMContextDeleteSurroundingDetail{callback, handlerID}
	signalIMContextDeleteSurroundingMap[signalIMContextDeleteSurroundingId] = detail

	return signalIMContextDeleteSurroundingId
}

/*
DisconnectDeleteSurrounding disconnects a callback from the 'delete-surrounding' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectDeleteSurrounding.
*/
func (recv *IMContext) DisconnectDeleteSurrounding(connectionID int) {
	signalIMContextDeleteSurroundingLock.Lock()
	defer signalIMContextDeleteSurroundingLock.Unlock()

	detail, exists := signalIMContextDeleteSurroundingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextDeleteSurroundingMap, connectionID)
}

//export imcontext_deleteSurroundingHandler
func imcontext_deleteSurroundingHandler(_ *C.GObject, c_offset C.gint, c_n_chars C.gint, data C.gpointer) C.gboolean {
	signalIMContextDeleteSurroundingLock.RLock()
	defer signalIMContextDeleteSurroundingLock.RUnlock()

	offset := int32(c_offset)

	nChars := int32(c_n_chars)

	index := int(uintptr(data))
	callback := signalIMContextDeleteSurroundingMap[index].callback
	retGo := callback(offset, nChars)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalIMContextPreeditChangedDetail struct {
	callback  IMContextSignalPreeditChangedCallback
	handlerID C.gulong
}

var signalIMContextPreeditChangedId int
var signalIMContextPreeditChangedMap = make(map[int]signalIMContextPreeditChangedDetail)
var signalIMContextPreeditChangedLock sync.RWMutex

// IMContextSignalPreeditChangedCallback is a callback function for a 'preedit-changed' signal emitted from a IMContext.
type IMContextSignalPreeditChangedCallback func()

/*
ConnectPreeditChanged connects the callback to the 'preedit-changed' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditChanged to remove it.
*/
func (recv *IMContext) ConnectPreeditChanged(callback IMContextSignalPreeditChangedCallback) int {
	signalIMContextPreeditChangedLock.Lock()
	defer signalIMContextPreeditChangedLock.Unlock()

	signalIMContextPreeditChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_changed(instance, C.gpointer(uintptr(signalIMContextPreeditChangedId)))

	detail := signalIMContextPreeditChangedDetail{callback, handlerID}
	signalIMContextPreeditChangedMap[signalIMContextPreeditChangedId] = detail

	return signalIMContextPreeditChangedId
}

/*
DisconnectPreeditChanged disconnects a callback from the 'preedit-changed' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditChanged.
*/
func (recv *IMContext) DisconnectPreeditChanged(connectionID int) {
	signalIMContextPreeditChangedLock.Lock()
	defer signalIMContextPreeditChangedLock.Unlock()

	detail, exists := signalIMContextPreeditChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditChangedMap, connectionID)
}

//export imcontext_preeditChangedHandler
func imcontext_preeditChangedHandler(_ *C.GObject, data C.gpointer) {
	signalIMContextPreeditChangedLock.RLock()
	defer signalIMContextPreeditChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIMContextPreeditChangedMap[index].callback
	callback()
}

type signalIMContextPreeditEndDetail struct {
	callback  IMContextSignalPreeditEndCallback
	handlerID C.gulong
}

var signalIMContextPreeditEndId int
var signalIMContextPreeditEndMap = make(map[int]signalIMContextPreeditEndDetail)
var signalIMContextPreeditEndLock sync.RWMutex

// IMContextSignalPreeditEndCallback is a callback function for a 'preedit-end' signal emitted from a IMContext.
type IMContextSignalPreeditEndCallback func()

/*
ConnectPreeditEnd connects the callback to the 'preedit-end' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditEnd to remove it.
*/
func (recv *IMContext) ConnectPreeditEnd(callback IMContextSignalPreeditEndCallback) int {
	signalIMContextPreeditEndLock.Lock()
	defer signalIMContextPreeditEndLock.Unlock()

	signalIMContextPreeditEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_end(instance, C.gpointer(uintptr(signalIMContextPreeditEndId)))

	detail := signalIMContextPreeditEndDetail{callback, handlerID}
	signalIMContextPreeditEndMap[signalIMContextPreeditEndId] = detail

	return signalIMContextPreeditEndId
}

/*
DisconnectPreeditEnd disconnects a callback from the 'preedit-end' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditEnd.
*/
func (recv *IMContext) DisconnectPreeditEnd(connectionID int) {
	signalIMContextPreeditEndLock.Lock()
	defer signalIMContextPreeditEndLock.Unlock()

	detail, exists := signalIMContextPreeditEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditEndMap, connectionID)
}

//export imcontext_preeditEndHandler
func imcontext_preeditEndHandler(_ *C.GObject, data C.gpointer) {
	signalIMContextPreeditEndLock.RLock()
	defer signalIMContextPreeditEndLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIMContextPreeditEndMap[index].callback
	callback()
}

type signalIMContextPreeditStartDetail struct {
	callback  IMContextSignalPreeditStartCallback
	handlerID C.gulong
}

var signalIMContextPreeditStartId int
var signalIMContextPreeditStartMap = make(map[int]signalIMContextPreeditStartDetail)
var signalIMContextPreeditStartLock sync.RWMutex

// IMContextSignalPreeditStartCallback is a callback function for a 'preedit-start' signal emitted from a IMContext.
type IMContextSignalPreeditStartCallback func()

/*
ConnectPreeditStart connects the callback to the 'preedit-start' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditStart to remove it.
*/
func (recv *IMContext) ConnectPreeditStart(callback IMContextSignalPreeditStartCallback) int {
	signalIMContextPreeditStartLock.Lock()
	defer signalIMContextPreeditStartLock.Unlock()

	signalIMContextPreeditStartId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_start(instance, C.gpointer(uintptr(signalIMContextPreeditStartId)))

	detail := signalIMContextPreeditStartDetail{callback, handlerID}
	signalIMContextPreeditStartMap[signalIMContextPreeditStartId] = detail

	return signalIMContextPreeditStartId
}

/*
DisconnectPreeditStart disconnects a callback from the 'preedit-start' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditStart.
*/
func (recv *IMContext) DisconnectPreeditStart(connectionID int) {
	signalIMContextPreeditStartLock.Lock()
	defer signalIMContextPreeditStartLock.Unlock()

	detail, exists := signalIMContextPreeditStartMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditStartMap, connectionID)
}

//export imcontext_preeditStartHandler
func imcontext_preeditStartHandler(_ *C.GObject, data C.gpointer) {
	signalIMContextPreeditStartLock.RLock()
	defer signalIMContextPreeditStartLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIMContextPreeditStartMap[index].callback
	callback()
}

type signalIMContextRetrieveSurroundingDetail struct {
	callback  IMContextSignalRetrieveSurroundingCallback
	handlerID C.gulong
}

var signalIMContextRetrieveSurroundingId int
var signalIMContextRetrieveSurroundingMap = make(map[int]signalIMContextRetrieveSurroundingDetail)
var signalIMContextRetrieveSurroundingLock sync.RWMutex

// IMContextSignalRetrieveSurroundingCallback is a callback function for a 'retrieve-surrounding' signal emitted from a IMContext.
type IMContextSignalRetrieveSurroundingCallback func() bool

/*
ConnectRetrieveSurrounding connects the callback to the 'retrieve-surrounding' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectRetrieveSurrounding to remove it.
*/
func (recv *IMContext) ConnectRetrieveSurrounding(callback IMContextSignalRetrieveSurroundingCallback) int {
	signalIMContextRetrieveSurroundingLock.Lock()
	defer signalIMContextRetrieveSurroundingLock.Unlock()

	signalIMContextRetrieveSurroundingId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_retrieve_surrounding(instance, C.gpointer(uintptr(signalIMContextRetrieveSurroundingId)))

	detail := signalIMContextRetrieveSurroundingDetail{callback, handlerID}
	signalIMContextRetrieveSurroundingMap[signalIMContextRetrieveSurroundingId] = detail

	return signalIMContextRetrieveSurroundingId
}

/*
DisconnectRetrieveSurrounding disconnects a callback from the 'retrieve-surrounding' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectRetrieveSurrounding.
*/
func (recv *IMContext) DisconnectRetrieveSurrounding(connectionID int) {
	signalIMContextRetrieveSurroundingLock.Lock()
	defer signalIMContextRetrieveSurroundingLock.Unlock()

	detail, exists := signalIMContextRetrieveSurroundingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextRetrieveSurroundingMap, connectionID)
}

//export imcontext_retrieveSurroundingHandler
func imcontext_retrieveSurroundingHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalIMContextRetrieveSurroundingLock.RLock()
	defer signalIMContextRetrieveSurroundingLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIMContextRetrieveSurroundingMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Blacklisted : gtk_im_context_delete_surrounding

// Blacklisted : gtk_im_context_filter_keypress

// Blacklisted : gtk_im_context_focus_in

// Blacklisted : gtk_im_context_focus_out

// Blacklisted : gtk_im_context_get_preedit_string

// Blacklisted : gtk_im_context_get_surrounding

// Blacklisted : gtk_im_context_reset

// Blacklisted : gtk_im_context_set_client_window

// Blacklisted : gtk_im_context_set_cursor_location

// Blacklisted : gtk_im_context_set_surrounding

// Blacklisted : gtk_im_context_set_use_preedit

// IMContextSimple is a wrapper around the C record GtkIMContextSimple.
type IMContextSimple struct {
	native *C.GtkIMContextSimple
	// object : record
	// Private : priv
}

func IMContextSimpleNewFromC(u unsafe.Pointer) *IMContextSimple {
	c := (*C.GtkIMContextSimple)(u)
	if c == nil {
		return nil
	}

	g := &IMContextSimple{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IMContextSimple) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IMContextSimple) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMContextSimple with another IMContextSimple, and returns true if they represent the same GObject.
func (recv *IMContextSimple) Equals(other *IMContextSimple) bool {
	return other.ToC() == recv.ToC()
}

// IMContext upcasts to *IMContext
func (recv *IMContextSimple) IMContext() *IMContext {
	return IMContextNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *IMContextSimple) Object() *gobject.Object {
	return recv.IMContext().Object()
}

// CastToWidget down casts any arbitrary Object to IMContextSimple.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMContextSimple.
func CastToIMContextSimple(object *gobject.Object) *IMContextSimple {
	return IMContextSimpleNewFromC(object.ToC())
}

// Blacklisted : gtk_im_context_simple_new

// Blacklisted : gtk_im_context_simple_add_compose_file

// Blacklisted : gtk_im_context_simple_add_table

// IMMulticontext is a wrapper around the C record GtkIMMulticontext.
type IMMulticontext struct {
	native *C.GtkIMMulticontext
	// object : record
	// Private : priv
}

func IMMulticontextNewFromC(u unsafe.Pointer) *IMMulticontext {
	c := (*C.GtkIMMulticontext)(u)
	if c == nil {
		return nil
	}

	g := &IMMulticontext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IMMulticontext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IMMulticontext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMMulticontext with another IMMulticontext, and returns true if they represent the same GObject.
func (recv *IMMulticontext) Equals(other *IMMulticontext) bool {
	return other.ToC() == recv.ToC()
}

// IMContext upcasts to *IMContext
func (recv *IMMulticontext) IMContext() *IMContext {
	return IMContextNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *IMMulticontext) Object() *gobject.Object {
	return recv.IMContext().Object()
}

// CastToWidget down casts any arbitrary Object to IMMulticontext.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMMulticontext.
func CastToIMMulticontext(object *gobject.Object) *IMMulticontext {
	return IMMulticontextNewFromC(object.ToC())
}

// Blacklisted : gtk_im_multicontext_new

// Blacklisted : gtk_im_multicontext_append_menuitems

// IconFactory is a wrapper around the C record GtkIconFactory.
type IconFactory struct {
	native *C.GtkIconFactory
	// parent_instance : record
	// Private : priv
}

func IconFactoryNewFromC(u unsafe.Pointer) *IconFactory {
	c := (*C.GtkIconFactory)(u)
	if c == nil {
		return nil
	}

	g := &IconFactory{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconFactory) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconFactory) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconFactory with another IconFactory, and returns true if they represent the same GObject.
func (recv *IconFactory) Equals(other *IconFactory) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IconFactory) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IconFactory.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconFactory.
func CastToIconFactory(object *gobject.Object) *IconFactory {
	return IconFactoryNewFromC(object.ToC())
}

// Blacklisted : gtk_icon_factory_new

// Blacklisted : gtk_icon_factory_lookup_default

// Blacklisted : gtk_icon_factory_add

// Blacklisted : gtk_icon_factory_add_default

// Blacklisted : gtk_icon_factory_lookup

// Blacklisted : gtk_icon_factory_remove_default

// Buildable returns the Buildable interface implemented by IconFactory
func (recv *IconFactory) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// IconInfo is a wrapper around the C record GtkIconInfo.
type IconInfo struct {
	native *C.GtkIconInfo
}

func IconInfoNewFromC(u unsafe.Pointer) *IconInfo {
	c := (*C.GtkIconInfo)(u)
	if c == nil {
		return nil
	}

	g := &IconInfo{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconInfo) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconInfo with another IconInfo, and returns true if they represent the same GObject.
func (recv *IconInfo) Equals(other *IconInfo) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IconInfo) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IconInfo.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconInfo.
func CastToIconInfo(object *gobject.Object) *IconInfo {
	return IconInfoNewFromC(object.ToC())
}

// IconTheme is a wrapper around the C record GtkIconTheme.
type IconTheme struct {
	native *C.GtkIconTheme
	// Private : parent_instance
	// Private : priv
}

func IconThemeNewFromC(u unsafe.Pointer) *IconTheme {
	c := (*C.GtkIconTheme)(u)
	if c == nil {
		return nil
	}

	g := &IconTheme{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconTheme) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconTheme) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconTheme with another IconTheme, and returns true if they represent the same GObject.
func (recv *IconTheme) Equals(other *IconTheme) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IconTheme) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IconTheme.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconTheme.
func CastToIconTheme(object *gobject.Object) *IconTheme {
	return IconThemeNewFromC(object.ToC())
}

type signalIconThemeChangedDetail struct {
	callback  IconThemeSignalChangedCallback
	handlerID C.gulong
}

var signalIconThemeChangedId int
var signalIconThemeChangedMap = make(map[int]signalIconThemeChangedDetail)
var signalIconThemeChangedLock sync.RWMutex

// IconThemeSignalChangedCallback is a callback function for a 'changed' signal emitted from a IconTheme.
type IconThemeSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the IconTheme.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *IconTheme) ConnectChanged(callback IconThemeSignalChangedCallback) int {
	signalIconThemeChangedLock.Lock()
	defer signalIconThemeChangedLock.Unlock()

	signalIconThemeChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconTheme_signal_connect_changed(instance, C.gpointer(uintptr(signalIconThemeChangedId)))

	detail := signalIconThemeChangedDetail{callback, handlerID}
	signalIconThemeChangedMap[signalIconThemeChangedId] = detail

	return signalIconThemeChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the IconTheme.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *IconTheme) DisconnectChanged(connectionID int) {
	signalIconThemeChangedLock.Lock()
	defer signalIconThemeChangedLock.Unlock()

	detail, exists := signalIconThemeChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconThemeChangedMap, connectionID)
}

//export icontheme_changedHandler
func icontheme_changedHandler(_ *C.GObject, data C.gpointer) {
	signalIconThemeChangedLock.RLock()
	defer signalIconThemeChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconThemeChangedMap[index].callback
	callback()
}

// IconView is a wrapper around the C record GtkIconView.
type IconView struct {
	native *C.GtkIconView
	// parent : record
	// Private : priv
}

func IconViewNewFromC(u unsafe.Pointer) *IconView {
	c := (*C.GtkIconView)(u)
	if c == nil {
		return nil
	}

	g := &IconView{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconView) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconView with another IconView, and returns true if they represent the same GObject.
func (recv *IconView) Equals(other *IconView) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *IconView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *IconView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *IconView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *IconView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to IconView.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconView.
func CastToIconView(object *gobject.Object) *IconView {
	return IconViewNewFromC(object.ToC())
}

type signalIconViewActivateCursorItemDetail struct {
	callback  IconViewSignalActivateCursorItemCallback
	handlerID C.gulong
}

var signalIconViewActivateCursorItemId int
var signalIconViewActivateCursorItemMap = make(map[int]signalIconViewActivateCursorItemDetail)
var signalIconViewActivateCursorItemLock sync.RWMutex

// IconViewSignalActivateCursorItemCallback is a callback function for a 'activate-cursor-item' signal emitted from a IconView.
type IconViewSignalActivateCursorItemCallback func() bool

/*
ConnectActivateCursorItem connects the callback to the 'activate-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectActivateCursorItem to remove it.
*/
func (recv *IconView) ConnectActivateCursorItem(callback IconViewSignalActivateCursorItemCallback) int {
	signalIconViewActivateCursorItemLock.Lock()
	defer signalIconViewActivateCursorItemLock.Unlock()

	signalIconViewActivateCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_activate_cursor_item(instance, C.gpointer(uintptr(signalIconViewActivateCursorItemId)))

	detail := signalIconViewActivateCursorItemDetail{callback, handlerID}
	signalIconViewActivateCursorItemMap[signalIconViewActivateCursorItemId] = detail

	return signalIconViewActivateCursorItemId
}

/*
DisconnectActivateCursorItem disconnects a callback from the 'activate-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectActivateCursorItem.
*/
func (recv *IconView) DisconnectActivateCursorItem(connectionID int) {
	signalIconViewActivateCursorItemLock.Lock()
	defer signalIconViewActivateCursorItemLock.Unlock()

	detail, exists := signalIconViewActivateCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewActivateCursorItemMap, connectionID)
}

//export iconview_activateCursorItemHandler
func iconview_activateCursorItemHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalIconViewActivateCursorItemLock.RLock()
	defer signalIconViewActivateCursorItemLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewActivateCursorItemMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalIconViewItemActivatedDetail struct {
	callback  IconViewSignalItemActivatedCallback
	handlerID C.gulong
}

var signalIconViewItemActivatedId int
var signalIconViewItemActivatedMap = make(map[int]signalIconViewItemActivatedDetail)
var signalIconViewItemActivatedLock sync.RWMutex

// IconViewSignalItemActivatedCallback is a callback function for a 'item-activated' signal emitted from a IconView.
type IconViewSignalItemActivatedCallback func(path *TreePath)

/*
ConnectItemActivated connects the callback to the 'item-activated' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectItemActivated to remove it.
*/
func (recv *IconView) ConnectItemActivated(callback IconViewSignalItemActivatedCallback) int {
	signalIconViewItemActivatedLock.Lock()
	defer signalIconViewItemActivatedLock.Unlock()

	signalIconViewItemActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_item_activated(instance, C.gpointer(uintptr(signalIconViewItemActivatedId)))

	detail := signalIconViewItemActivatedDetail{callback, handlerID}
	signalIconViewItemActivatedMap[signalIconViewItemActivatedId] = detail

	return signalIconViewItemActivatedId
}

/*
DisconnectItemActivated disconnects a callback from the 'item-activated' signal for the IconView.

The connectionID should be a value returned from a call to ConnectItemActivated.
*/
func (recv *IconView) DisconnectItemActivated(connectionID int) {
	signalIconViewItemActivatedLock.Lock()
	defer signalIconViewItemActivatedLock.Unlock()

	detail, exists := signalIconViewItemActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewItemActivatedMap, connectionID)
}

//export iconview_itemActivatedHandler
func iconview_itemActivatedHandler(_ *C.GObject, c_path *C.GtkTreePath, data C.gpointer) {
	signalIconViewItemActivatedLock.RLock()
	defer signalIconViewItemActivatedLock.RUnlock()

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalIconViewItemActivatedMap[index].callback
	callback(path)
}

type signalIconViewMoveCursorDetail struct {
	callback  IconViewSignalMoveCursorCallback
	handlerID C.gulong
}

var signalIconViewMoveCursorId int
var signalIconViewMoveCursorMap = make(map[int]signalIconViewMoveCursorDetail)
var signalIconViewMoveCursorLock sync.RWMutex

// IconViewSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a IconView.
type IconViewSignalMoveCursorCallback func(step MovementStep, count int32) bool

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *IconView) ConnectMoveCursor(callback IconViewSignalMoveCursorCallback) int {
	signalIconViewMoveCursorLock.Lock()
	defer signalIconViewMoveCursorLock.Unlock()

	signalIconViewMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalIconViewMoveCursorId)))

	detail := signalIconViewMoveCursorDetail{callback, handlerID}
	signalIconViewMoveCursorMap[signalIconViewMoveCursorId] = detail

	return signalIconViewMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the IconView.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *IconView) DisconnectMoveCursor(connectionID int) {
	signalIconViewMoveCursorLock.Lock()
	defer signalIconViewMoveCursorLock.Unlock()

	detail, exists := signalIconViewMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewMoveCursorMap, connectionID)
}

//export iconview_moveCursorHandler
func iconview_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, data C.gpointer) C.gboolean {
	signalIconViewMoveCursorLock.RLock()
	defer signalIconViewMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalIconViewMoveCursorMap[index].callback
	retGo := callback(step, count)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalIconViewSelectAllDetail struct {
	callback  IconViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalIconViewSelectAllId int
var signalIconViewSelectAllMap = make(map[int]signalIconViewSelectAllDetail)
var signalIconViewSelectAllLock sync.RWMutex

// IconViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a IconView.
type IconViewSignalSelectAllCallback func()

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *IconView) ConnectSelectAll(callback IconViewSignalSelectAllCallback) int {
	signalIconViewSelectAllLock.Lock()
	defer signalIconViewSelectAllLock.Unlock()

	signalIconViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_select_all(instance, C.gpointer(uintptr(signalIconViewSelectAllId)))

	detail := signalIconViewSelectAllDetail{callback, handlerID}
	signalIconViewSelectAllMap[signalIconViewSelectAllId] = detail

	return signalIconViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *IconView) DisconnectSelectAll(connectionID int) {
	signalIconViewSelectAllLock.Lock()
	defer signalIconViewSelectAllLock.Unlock()

	detail, exists := signalIconViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectAllMap, connectionID)
}

//export iconview_selectAllHandler
func iconview_selectAllHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewSelectAllLock.RLock()
	defer signalIconViewSelectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewSelectAllMap[index].callback
	callback()
}

type signalIconViewSelectCursorItemDetail struct {
	callback  IconViewSignalSelectCursorItemCallback
	handlerID C.gulong
}

var signalIconViewSelectCursorItemId int
var signalIconViewSelectCursorItemMap = make(map[int]signalIconViewSelectCursorItemDetail)
var signalIconViewSelectCursorItemLock sync.RWMutex

// IconViewSignalSelectCursorItemCallback is a callback function for a 'select-cursor-item' signal emitted from a IconView.
type IconViewSignalSelectCursorItemCallback func()

/*
ConnectSelectCursorItem connects the callback to the 'select-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorItem to remove it.
*/
func (recv *IconView) ConnectSelectCursorItem(callback IconViewSignalSelectCursorItemCallback) int {
	signalIconViewSelectCursorItemLock.Lock()
	defer signalIconViewSelectCursorItemLock.Unlock()

	signalIconViewSelectCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_select_cursor_item(instance, C.gpointer(uintptr(signalIconViewSelectCursorItemId)))

	detail := signalIconViewSelectCursorItemDetail{callback, handlerID}
	signalIconViewSelectCursorItemMap[signalIconViewSelectCursorItemId] = detail

	return signalIconViewSelectCursorItemId
}

/*
DisconnectSelectCursorItem disconnects a callback from the 'select-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectCursorItem.
*/
func (recv *IconView) DisconnectSelectCursorItem(connectionID int) {
	signalIconViewSelectCursorItemLock.Lock()
	defer signalIconViewSelectCursorItemLock.Unlock()

	detail, exists := signalIconViewSelectCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectCursorItemMap, connectionID)
}

//export iconview_selectCursorItemHandler
func iconview_selectCursorItemHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewSelectCursorItemLock.RLock()
	defer signalIconViewSelectCursorItemLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewSelectCursorItemMap[index].callback
	callback()
}

type signalIconViewSelectionChangedDetail struct {
	callback  IconViewSignalSelectionChangedCallback
	handlerID C.gulong
}

var signalIconViewSelectionChangedId int
var signalIconViewSelectionChangedMap = make(map[int]signalIconViewSelectionChangedDetail)
var signalIconViewSelectionChangedLock sync.RWMutex

// IconViewSignalSelectionChangedCallback is a callback function for a 'selection-changed' signal emitted from a IconView.
type IconViewSignalSelectionChangedCallback func()

/*
ConnectSelectionChanged connects the callback to the 'selection-changed' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectionChanged to remove it.
*/
func (recv *IconView) ConnectSelectionChanged(callback IconViewSignalSelectionChangedCallback) int {
	signalIconViewSelectionChangedLock.Lock()
	defer signalIconViewSelectionChangedLock.Unlock()

	signalIconViewSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_selection_changed(instance, C.gpointer(uintptr(signalIconViewSelectionChangedId)))

	detail := signalIconViewSelectionChangedDetail{callback, handlerID}
	signalIconViewSelectionChangedMap[signalIconViewSelectionChangedId] = detail

	return signalIconViewSelectionChangedId
}

/*
DisconnectSelectionChanged disconnects a callback from the 'selection-changed' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectionChanged.
*/
func (recv *IconView) DisconnectSelectionChanged(connectionID int) {
	signalIconViewSelectionChangedLock.Lock()
	defer signalIconViewSelectionChangedLock.Unlock()

	detail, exists := signalIconViewSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectionChangedMap, connectionID)
}

//export iconview_selectionChangedHandler
func iconview_selectionChangedHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewSelectionChangedLock.RLock()
	defer signalIconViewSelectionChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewSelectionChangedMap[index].callback
	callback()
}

type signalIconViewToggleCursorItemDetail struct {
	callback  IconViewSignalToggleCursorItemCallback
	handlerID C.gulong
}

var signalIconViewToggleCursorItemId int
var signalIconViewToggleCursorItemMap = make(map[int]signalIconViewToggleCursorItemDetail)
var signalIconViewToggleCursorItemLock sync.RWMutex

// IconViewSignalToggleCursorItemCallback is a callback function for a 'toggle-cursor-item' signal emitted from a IconView.
type IconViewSignalToggleCursorItemCallback func()

/*
ConnectToggleCursorItem connects the callback to the 'toggle-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorItem to remove it.
*/
func (recv *IconView) ConnectToggleCursorItem(callback IconViewSignalToggleCursorItemCallback) int {
	signalIconViewToggleCursorItemLock.Lock()
	defer signalIconViewToggleCursorItemLock.Unlock()

	signalIconViewToggleCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_toggle_cursor_item(instance, C.gpointer(uintptr(signalIconViewToggleCursorItemId)))

	detail := signalIconViewToggleCursorItemDetail{callback, handlerID}
	signalIconViewToggleCursorItemMap[signalIconViewToggleCursorItemId] = detail

	return signalIconViewToggleCursorItemId
}

/*
DisconnectToggleCursorItem disconnects a callback from the 'toggle-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectToggleCursorItem.
*/
func (recv *IconView) DisconnectToggleCursorItem(connectionID int) {
	signalIconViewToggleCursorItemLock.Lock()
	defer signalIconViewToggleCursorItemLock.Unlock()

	detail, exists := signalIconViewToggleCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewToggleCursorItemMap, connectionID)
}

//export iconview_toggleCursorItemHandler
func iconview_toggleCursorItemHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewToggleCursorItemLock.RLock()
	defer signalIconViewToggleCursorItemLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewToggleCursorItemMap[index].callback
	callback()
}

type signalIconViewUnselectAllDetail struct {
	callback  IconViewSignalUnselectAllCallback
	handlerID C.gulong
}

var signalIconViewUnselectAllId int
var signalIconViewUnselectAllMap = make(map[int]signalIconViewUnselectAllDetail)
var signalIconViewUnselectAllLock sync.RWMutex

// IconViewSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a IconView.
type IconViewSignalUnselectAllCallback func()

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *IconView) ConnectUnselectAll(callback IconViewSignalUnselectAllCallback) int {
	signalIconViewUnselectAllLock.Lock()
	defer signalIconViewUnselectAllLock.Unlock()

	signalIconViewUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalIconViewUnselectAllId)))

	detail := signalIconViewUnselectAllDetail{callback, handlerID}
	signalIconViewUnselectAllMap[signalIconViewUnselectAllId] = detail

	return signalIconViewUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the IconView.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *IconView) DisconnectUnselectAll(connectionID int) {
	signalIconViewUnselectAllLock.Lock()
	defer signalIconViewUnselectAllLock.Unlock()

	detail, exists := signalIconViewUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewUnselectAllMap, connectionID)
}

//export iconview_unselectAllHandler
func iconview_unselectAllHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewUnselectAllLock.RLock()
	defer signalIconViewUnselectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewUnselectAllMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by IconView
func (recv *IconView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by IconView
func (recv *IconView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by IconView
func (recv *IconView) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by IconView
func (recv *IconView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// IconViewAccessible is a wrapper around the C record GtkIconViewAccessible.
type IconViewAccessible struct {
	native *C.GtkIconViewAccessible
	// parent : record
	// priv : record
}

func IconViewAccessibleNewFromC(u unsafe.Pointer) *IconViewAccessible {
	c := (*C.GtkIconViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &IconViewAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconViewAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconViewAccessible with another IconViewAccessible, and returns true if they represent the same GObject.
func (recv *IconViewAccessible) Equals(other *IconViewAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *IconViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *IconViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *IconViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *IconViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to IconViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconViewAccessible.
func CastToIconViewAccessible(object *gobject.Object) *IconViewAccessible {
	return IconViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by IconViewAccessible
func (recv *IconViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by IconViewAccessible
func (recv *IconViewAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Image is a wrapper around the C record GtkImage.
type Image struct {
	native *C.GtkImage
	// misc : record
	// Private : priv
}

func ImageNewFromC(u unsafe.Pointer) *Image {
	c := (*C.GtkImage)(u)
	if c == nil {
		return nil
	}

	g := &Image{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Image) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Image) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Image with another Image, and returns true if they represent the same GObject.
func (recv *Image) Equals(other *Image) bool {
	return other.ToC() == recv.ToC()
}

// Misc upcasts to *Misc
func (recv *Image) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Image) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Image) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Image) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitrary Object to Image.
// Exercise care, as this is a potentially dangerous function if the Object is not a Image.
func CastToImage(object *gobject.Object) *Image {
	return ImageNewFromC(object.ToC())
}

// Blacklisted : gtk_image_new

// Blacklisted : gtk_image_new_from_animation

// Blacklisted : gtk_image_new_from_file

// Blacklisted : gtk_image_new_from_icon_set

// Blacklisted : gtk_image_new_from_pixbuf

// Blacklisted : gtk_image_new_from_stock

// Blacklisted : gtk_image_get_animation

// Blacklisted : gtk_image_get_icon_set

// Blacklisted : gtk_image_get_pixbuf

// Blacklisted : gtk_image_get_stock

// Blacklisted : gtk_image_get_storage_type

// Blacklisted : gtk_image_set_from_animation

// Blacklisted : gtk_image_set_from_file

// Blacklisted : gtk_image_set_from_icon_set

// Blacklisted : gtk_image_set_from_pixbuf

// Blacklisted : gtk_image_set_from_resource

// Blacklisted : gtk_image_set_from_stock

// ImplementorIface returns the ImplementorIface interface implemented by Image
func (recv *Image) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Image
func (recv *Image) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ImageAccessible is a wrapper around the C record GtkImageAccessible.
type ImageAccessible struct {
	native *C.GtkImageAccessible
	// parent : record
	// priv : record
}

func ImageAccessibleNewFromC(u unsafe.Pointer) *ImageAccessible {
	c := (*C.GtkImageAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ImageAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ImageAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ImageAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageAccessible with another ImageAccessible, and returns true if they represent the same GObject.
func (recv *ImageAccessible) Equals(other *ImageAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ImageAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ImageAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ImageAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ImageAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageAccessible.
func CastToImageAccessible(object *gobject.Object) *ImageAccessible {
	return ImageAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ImageAccessible
func (recv *ImageAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ImageAccessible
func (recv *ImageAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ImageCellAccessible is a wrapper around the C record GtkImageCellAccessible.
type ImageCellAccessible struct {
	native *C.GtkImageCellAccessible
	// parent : record
	// priv : record
}

func ImageCellAccessibleNewFromC(u unsafe.Pointer) *ImageCellAccessible {
	c := (*C.GtkImageCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ImageCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ImageCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ImageCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageCellAccessible with another ImageCellAccessible, and returns true if they represent the same GObject.
func (recv *ImageCellAccessible) Equals(other *ImageCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *ImageCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *ImageCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ImageCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ImageCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ImageCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageCellAccessible.
func CastToImageCellAccessible(object *gobject.Object) *ImageCellAccessible {
	return ImageCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ImageMenuItem is a wrapper around the C record GtkImageMenuItem.
type ImageMenuItem struct {
	native *C.GtkImageMenuItem
	// menu_item : record
	// Private : priv
}

func ImageMenuItemNewFromC(u unsafe.Pointer) *ImageMenuItem {
	c := (*C.GtkImageMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &ImageMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ImageMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ImageMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageMenuItem with another ImageMenuItem, and returns true if they represent the same GObject.
func (recv *ImageMenuItem) Equals(other *ImageMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// MenuItem upcasts to *MenuItem
func (recv *ImageMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ImageMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *ImageMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *ImageMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ImageMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ImageMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to ImageMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageMenuItem.
func CastToImageMenuItem(object *gobject.Object) *ImageMenuItem {
	return ImageMenuItemNewFromC(object.ToC())
}

// Blacklisted : gtk_image_menu_item_new

// Blacklisted : gtk_image_menu_item_new_from_stock

// Blacklisted : gtk_image_menu_item_new_with_label

// Blacklisted : gtk_image_menu_item_new_with_mnemonic

// Blacklisted : gtk_image_menu_item_get_image

// Blacklisted : gtk_image_menu_item_set_image

// ImplementorIface returns the ImplementorIface interface implemented by ImageMenuItem
func (recv *ImageMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// InfoBar is a wrapper around the C record GtkInfoBar.
type InfoBar struct {
	native *C.GtkInfoBar
	// parent : record
	// Private : priv
}

func InfoBarNewFromC(u unsafe.Pointer) *InfoBar {
	c := (*C.GtkInfoBar)(u)
	if c == nil {
		return nil
	}

	g := &InfoBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *InfoBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *InfoBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InfoBar with another InfoBar, and returns true if they represent the same GObject.
func (recv *InfoBar) Equals(other *InfoBar) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *InfoBar) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *InfoBar) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *InfoBar) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *InfoBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *InfoBar) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to InfoBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a InfoBar.
func CastToInfoBar(object *gobject.Object) *InfoBar {
	return InfoBarNewFromC(object.ToC())
}

// Unsupported : gtk_info_bar_new_with_buttons : unsupported parameter ... : varargs

// ImplementorIface returns the ImplementorIface interface implemented by InfoBar
func (recv *InfoBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by InfoBar
func (recv *InfoBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by InfoBar
func (recv *InfoBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Invisible is a wrapper around the C record GtkInvisible.
type Invisible struct {
	native *C.GtkInvisible
	// widget : record
	// Private : priv
}

func InvisibleNewFromC(u unsafe.Pointer) *Invisible {
	c := (*C.GtkInvisible)(u)
	if c == nil {
		return nil
	}

	g := &Invisible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Invisible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Invisible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Invisible with another Invisible, and returns true if they represent the same GObject.
func (recv *Invisible) Equals(other *Invisible) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Invisible) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Invisible) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Invisible) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Invisible.
// Exercise care, as this is a potentially dangerous function if the Object is not a Invisible.
func CastToInvisible(object *gobject.Object) *Invisible {
	return InvisibleNewFromC(object.ToC())
}

// Blacklisted : gtk_invisible_new

// ImplementorIface returns the ImplementorIface interface implemented by Invisible
func (recv *Invisible) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Invisible
func (recv *Invisible) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Label is a wrapper around the C record GtkLabel.
type Label struct {
	native *C.GtkLabel
	// misc : record
	// Private : priv
}

func LabelNewFromC(u unsafe.Pointer) *Label {
	c := (*C.GtkLabel)(u)
	if c == nil {
		return nil
	}

	g := &Label{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Label) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Label) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Label with another Label, and returns true if they represent the same GObject.
func (recv *Label) Equals(other *Label) bool {
	return other.ToC() == recv.ToC()
}

// Misc upcasts to *Misc
func (recv *Label) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Label) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Label) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Label) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitrary Object to Label.
// Exercise care, as this is a potentially dangerous function if the Object is not a Label.
func CastToLabel(object *gobject.Object) *Label {
	return LabelNewFromC(object.ToC())
}

type signalLabelCopyClipboardDetail struct {
	callback  LabelSignalCopyClipboardCallback
	handlerID C.gulong
}

var signalLabelCopyClipboardId int
var signalLabelCopyClipboardMap = make(map[int]signalLabelCopyClipboardDetail)
var signalLabelCopyClipboardLock sync.RWMutex

// LabelSignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a Label.
type LabelSignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *Label) ConnectCopyClipboard(callback LabelSignalCopyClipboardCallback) int {
	signalLabelCopyClipboardLock.Lock()
	defer signalLabelCopyClipboardLock.Unlock()

	signalLabelCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalLabelCopyClipboardId)))

	detail := signalLabelCopyClipboardDetail{callback, handlerID}
	signalLabelCopyClipboardMap[signalLabelCopyClipboardId] = detail

	return signalLabelCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the Label.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *Label) DisconnectCopyClipboard(connectionID int) {
	signalLabelCopyClipboardLock.Lock()
	defer signalLabelCopyClipboardLock.Unlock()

	detail, exists := signalLabelCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelCopyClipboardMap, connectionID)
}

//export label_copyClipboardHandler
func label_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalLabelCopyClipboardLock.RLock()
	defer signalLabelCopyClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalLabelCopyClipboardMap[index].callback
	callback()
}

type signalLabelMoveCursorDetail struct {
	callback  LabelSignalMoveCursorCallback
	handlerID C.gulong
}

var signalLabelMoveCursorId int
var signalLabelMoveCursorMap = make(map[int]signalLabelMoveCursorDetail)
var signalLabelMoveCursorLock sync.RWMutex

// LabelSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a Label.
type LabelSignalMoveCursorCallback func(step MovementStep, count int32, extendSelection bool)

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *Label) ConnectMoveCursor(callback LabelSignalMoveCursorCallback) int {
	signalLabelMoveCursorLock.Lock()
	defer signalLabelMoveCursorLock.Unlock()

	signalLabelMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalLabelMoveCursorId)))

	detail := signalLabelMoveCursorDetail{callback, handlerID}
	signalLabelMoveCursorMap[signalLabelMoveCursorId] = detail

	return signalLabelMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the Label.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *Label) DisconnectMoveCursor(connectionID int) {
	signalLabelMoveCursorLock.Lock()
	defer signalLabelMoveCursorLock.Unlock()

	detail, exists := signalLabelMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelMoveCursorMap, connectionID)
}

//export label_moveCursorHandler
func label_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, c_extend_selection C.gboolean, data C.gpointer) {
	signalLabelMoveCursorLock.RLock()
	defer signalLabelMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	extendSelection := c_extend_selection == C.TRUE

	index := int(uintptr(data))
	callback := signalLabelMoveCursorMap[index].callback
	callback(step, count, extendSelection)
}

type signalLabelPopulatePopupDetail struct {
	callback  LabelSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalLabelPopulatePopupId int
var signalLabelPopulatePopupMap = make(map[int]signalLabelPopulatePopupDetail)
var signalLabelPopulatePopupLock sync.RWMutex

// LabelSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a Label.
type LabelSignalPopulatePopupCallback func(menu *Menu)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *Label) ConnectPopulatePopup(callback LabelSignalPopulatePopupCallback) int {
	signalLabelPopulatePopupLock.Lock()
	defer signalLabelPopulatePopupLock.Unlock()

	signalLabelPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalLabelPopulatePopupId)))

	detail := signalLabelPopulatePopupDetail{callback, handlerID}
	signalLabelPopulatePopupMap[signalLabelPopulatePopupId] = detail

	return signalLabelPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the Label.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *Label) DisconnectPopulatePopup(connectionID int) {
	signalLabelPopulatePopupLock.Lock()
	defer signalLabelPopulatePopupLock.Unlock()

	detail, exists := signalLabelPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelPopulatePopupMap, connectionID)
}

//export label_populatePopupHandler
func label_populatePopupHandler(_ *C.GObject, c_menu *C.GtkMenu, data C.gpointer) {
	signalLabelPopulatePopupLock.RLock()
	defer signalLabelPopulatePopupLock.RUnlock()

	menu := MenuNewFromC(unsafe.Pointer(c_menu))

	index := int(uintptr(data))
	callback := signalLabelPopulatePopupMap[index].callback
	callback(menu)
}

// LabelNew is a wrapper around the C function gtk_label_new.
func LabelNew(str string) *Label {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	retC := C.gtk_label_new(c_str)
	retGo := LabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Blacklisted : gtk_label_new_with_mnemonic

// Blacklisted : gtk_label_get_attributes

// Blacklisted : gtk_label_get_justify

// Blacklisted : gtk_label_get_label

// Blacklisted : gtk_label_get_layout

// Blacklisted : gtk_label_get_layout_offsets

// Blacklisted : gtk_label_get_line_wrap

// Blacklisted : gtk_label_get_mnemonic_keyval

// Blacklisted : gtk_label_get_mnemonic_widget

// Blacklisted : gtk_label_get_selectable

// Blacklisted : gtk_label_get_selection_bounds

// GetText is a wrapper around the C function gtk_label_get_text.
func (recv *Label) GetText() string {
	retC := C.gtk_label_get_text((*C.GtkLabel)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Blacklisted : gtk_label_get_use_markup

// Blacklisted : gtk_label_get_use_underline

// Blacklisted : gtk_label_select_region

// Blacklisted : gtk_label_set_attributes

// Blacklisted : gtk_label_set_justify

// Blacklisted : gtk_label_set_label

// Blacklisted : gtk_label_set_line_wrap

// Blacklisted : gtk_label_set_markup

// Blacklisted : gtk_label_set_markup_with_mnemonic

// Blacklisted : gtk_label_set_mnemonic_widget

// Blacklisted : gtk_label_set_pattern

// Blacklisted : gtk_label_set_selectable

// SetText is a wrapper around the C function gtk_label_set_text.
func (recv *Label) SetText(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_text((*C.GtkLabel)(recv.native), c_str)

	return
}

// Blacklisted : gtk_label_set_text_with_mnemonic

// Blacklisted : gtk_label_set_use_markup

// Blacklisted : gtk_label_set_use_underline

// ImplementorIface returns the ImplementorIface interface implemented by Label
func (recv *Label) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Label
func (recv *Label) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LabelAccessible is a wrapper around the C record GtkLabelAccessible.
type LabelAccessible struct {
	native *C.GtkLabelAccessible
	// parent : record
	// priv : record
}

func LabelAccessibleNewFromC(u unsafe.Pointer) *LabelAccessible {
	c := (*C.GtkLabelAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LabelAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LabelAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LabelAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LabelAccessible with another LabelAccessible, and returns true if they represent the same GObject.
func (recv *LabelAccessible) Equals(other *LabelAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LabelAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *LabelAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LabelAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to LabelAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LabelAccessible.
func CastToLabelAccessible(object *gobject.Object) *LabelAccessible {
	return LabelAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by LabelAccessible
func (recv *LabelAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Hypertext returns the Hypertext interface implemented by LabelAccessible
func (recv *LabelAccessible) Hypertext() *atk.Hypertext {
	return atk.HypertextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by LabelAccessible
func (recv *LabelAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// Layout is a wrapper around the C record GtkLayout.
type Layout struct {
	native *C.GtkLayout
	// container : record
	// Private : priv
}

func LayoutNewFromC(u unsafe.Pointer) *Layout {
	c := (*C.GtkLayout)(u)
	if c == nil {
		return nil
	}

	g := &Layout{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Layout) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Layout) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Layout with another Layout, and returns true if they represent the same GObject.
func (recv *Layout) Equals(other *Layout) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Layout) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Layout) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Layout) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Layout) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Layout.
// Exercise care, as this is a potentially dangerous function if the Object is not a Layout.
func CastToLayout(object *gobject.Object) *Layout {
	return LayoutNewFromC(object.ToC())
}

// Blacklisted : gtk_layout_new

// Blacklisted : gtk_layout_get_hadjustment

// Blacklisted : gtk_layout_get_size

// Blacklisted : gtk_layout_get_vadjustment

// Blacklisted : gtk_layout_move

// Blacklisted : gtk_layout_put

// Blacklisted : gtk_layout_set_hadjustment

// Blacklisted : gtk_layout_set_size

// Blacklisted : gtk_layout_set_vadjustment

// ImplementorIface returns the ImplementorIface interface implemented by Layout
func (recv *Layout) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Layout
func (recv *Layout) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by Layout
func (recv *Layout) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// LevelBar is a wrapper around the C record GtkLevelBar.
type LevelBar struct {
	native *C.GtkLevelBar
	// Private : parent
	// Private : priv
}

func LevelBarNewFromC(u unsafe.Pointer) *LevelBar {
	c := (*C.GtkLevelBar)(u)
	if c == nil {
		return nil
	}

	g := &LevelBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LevelBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LevelBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LevelBar with another LevelBar, and returns true if they represent the same GObject.
func (recv *LevelBar) Equals(other *LevelBar) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *LevelBar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LevelBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LevelBar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to LevelBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a LevelBar.
func CastToLevelBar(object *gobject.Object) *LevelBar {
	return LevelBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by LevelBar
func (recv *LevelBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LevelBar
func (recv *LevelBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by LevelBar
func (recv *LevelBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// LevelBarAccessible is a wrapper around the C record GtkLevelBarAccessible.
type LevelBarAccessible struct {
	native *C.GtkLevelBarAccessible
	// parent : record
	// priv : record
}

func LevelBarAccessibleNewFromC(u unsafe.Pointer) *LevelBarAccessible {
	c := (*C.GtkLevelBarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LevelBarAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LevelBarAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LevelBarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LevelBarAccessible with another LevelBarAccessible, and returns true if they represent the same GObject.
func (recv *LevelBarAccessible) Equals(other *LevelBarAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LevelBarAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *LevelBarAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LevelBarAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to LevelBarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LevelBarAccessible.
func CastToLevelBarAccessible(object *gobject.Object) *LevelBarAccessible {
	return LevelBarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by LevelBarAccessible
func (recv *LevelBarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by LevelBarAccessible
func (recv *LevelBarAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// LinkButton is a wrapper around the C record GtkLinkButton.
type LinkButton struct {
	native *C.GtkLinkButton
	// Private : parent_instance
	// Private : priv
}

func LinkButtonNewFromC(u unsafe.Pointer) *LinkButton {
	c := (*C.GtkLinkButton)(u)
	if c == nil {
		return nil
	}

	g := &LinkButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LinkButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LinkButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LinkButton with another LinkButton, and returns true if they represent the same GObject.
func (recv *LinkButton) Equals(other *LinkButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *LinkButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *LinkButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *LinkButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *LinkButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LinkButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LinkButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to LinkButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a LinkButton.
func CastToLinkButton(object *gobject.Object) *LinkButton {
	return LinkButtonNewFromC(object.ToC())
}

type signalLinkButtonActivateLinkDetail struct {
	callback  LinkButtonSignalActivateLinkCallback
	handlerID C.gulong
}

var signalLinkButtonActivateLinkId int
var signalLinkButtonActivateLinkMap = make(map[int]signalLinkButtonActivateLinkDetail)
var signalLinkButtonActivateLinkLock sync.RWMutex

// LinkButtonSignalActivateLinkCallback is a callback function for a 'activate-link' signal emitted from a LinkButton.
type LinkButtonSignalActivateLinkCallback func() bool

/*
ConnectActivateLink connects the callback to the 'activate-link' signal for the LinkButton.

The returned value represents the connection, and may be passed to DisconnectActivateLink to remove it.
*/
func (recv *LinkButton) ConnectActivateLink(callback LinkButtonSignalActivateLinkCallback) int {
	signalLinkButtonActivateLinkLock.Lock()
	defer signalLinkButtonActivateLinkLock.Unlock()

	signalLinkButtonActivateLinkId++
	instance := C.gpointer(recv.native)
	handlerID := C.LinkButton_signal_connect_activate_link(instance, C.gpointer(uintptr(signalLinkButtonActivateLinkId)))

	detail := signalLinkButtonActivateLinkDetail{callback, handlerID}
	signalLinkButtonActivateLinkMap[signalLinkButtonActivateLinkId] = detail

	return signalLinkButtonActivateLinkId
}

/*
DisconnectActivateLink disconnects a callback from the 'activate-link' signal for the LinkButton.

The connectionID should be a value returned from a call to ConnectActivateLink.
*/
func (recv *LinkButton) DisconnectActivateLink(connectionID int) {
	signalLinkButtonActivateLinkLock.Lock()
	defer signalLinkButtonActivateLinkLock.Unlock()

	detail, exists := signalLinkButtonActivateLinkMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLinkButtonActivateLinkMap, connectionID)
}

//export linkbutton_activateLinkHandler
func linkbutton_activateLinkHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalLinkButtonActivateLinkLock.RLock()
	defer signalLinkButtonActivateLinkLock.RUnlock()

	index := int(uintptr(data))
	callback := signalLinkButtonActivateLinkMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// ImplementorIface returns the ImplementorIface interface implemented by LinkButton
func (recv *LinkButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by LinkButton
func (recv *LinkButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by LinkButton
func (recv *LinkButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LinkButton
func (recv *LinkButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LinkButtonAccessible is a wrapper around the C record GtkLinkButtonAccessible.
type LinkButtonAccessible struct {
	native *C.GtkLinkButtonAccessible
	// parent : record
	// priv : record
}

func LinkButtonAccessibleNewFromC(u unsafe.Pointer) *LinkButtonAccessible {
	c := (*C.GtkLinkButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LinkButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LinkButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LinkButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LinkButtonAccessible with another LinkButtonAccessible, and returns true if they represent the same GObject.
func (recv *LinkButtonAccessible) Equals(other *LinkButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *LinkButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *LinkButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LinkButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *LinkButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LinkButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to LinkButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LinkButtonAccessible.
func CastToLinkButtonAccessible(object *gobject.Object) *LinkButtonAccessible {
	return LinkButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// HyperlinkImpl returns the HyperlinkImpl interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) HyperlinkImpl() *atk.HyperlinkImpl {
	return atk.HyperlinkImplNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ListBox is a wrapper around the C record GtkListBox.
type ListBox struct {
	native *C.GtkListBox
	// parent_instance : record
}

func ListBoxNewFromC(u unsafe.Pointer) *ListBox {
	c := (*C.GtkListBox)(u)
	if c == nil {
		return nil
	}

	g := &ListBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBox with another ListBox, and returns true if they represent the same GObject.
func (recv *ListBox) Equals(other *ListBox) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *ListBox) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ListBox) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ListBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ListBox) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to ListBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBox.
func CastToListBox(object *gobject.Object) *ListBox {
	return ListBoxNewFromC(object.ToC())
}

type signalListBoxActivateCursorRowDetail struct {
	callback  ListBoxSignalActivateCursorRowCallback
	handlerID C.gulong
}

var signalListBoxActivateCursorRowId int
var signalListBoxActivateCursorRowMap = make(map[int]signalListBoxActivateCursorRowDetail)
var signalListBoxActivateCursorRowLock sync.RWMutex

// ListBoxSignalActivateCursorRowCallback is a callback function for a 'activate-cursor-row' signal emitted from a ListBox.
type ListBoxSignalActivateCursorRowCallback func()

/*
ConnectActivateCursorRow connects the callback to the 'activate-cursor-row' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectActivateCursorRow to remove it.
*/
func (recv *ListBox) ConnectActivateCursorRow(callback ListBoxSignalActivateCursorRowCallback) int {
	signalListBoxActivateCursorRowLock.Lock()
	defer signalListBoxActivateCursorRowLock.Unlock()

	signalListBoxActivateCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_activate_cursor_row(instance, C.gpointer(uintptr(signalListBoxActivateCursorRowId)))

	detail := signalListBoxActivateCursorRowDetail{callback, handlerID}
	signalListBoxActivateCursorRowMap[signalListBoxActivateCursorRowId] = detail

	return signalListBoxActivateCursorRowId
}

/*
DisconnectActivateCursorRow disconnects a callback from the 'activate-cursor-row' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectActivateCursorRow.
*/
func (recv *ListBox) DisconnectActivateCursorRow(connectionID int) {
	signalListBoxActivateCursorRowLock.Lock()
	defer signalListBoxActivateCursorRowLock.Unlock()

	detail, exists := signalListBoxActivateCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxActivateCursorRowMap, connectionID)
}

//export listbox_activateCursorRowHandler
func listbox_activateCursorRowHandler(_ *C.GObject, data C.gpointer) {
	signalListBoxActivateCursorRowLock.RLock()
	defer signalListBoxActivateCursorRowLock.RUnlock()

	index := int(uintptr(data))
	callback := signalListBoxActivateCursorRowMap[index].callback
	callback()
}

type signalListBoxMoveCursorDetail struct {
	callback  ListBoxSignalMoveCursorCallback
	handlerID C.gulong
}

var signalListBoxMoveCursorId int
var signalListBoxMoveCursorMap = make(map[int]signalListBoxMoveCursorDetail)
var signalListBoxMoveCursorLock sync.RWMutex

// ListBoxSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a ListBox.
type ListBoxSignalMoveCursorCallback func(object MovementStep, p0 int32)

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *ListBox) ConnectMoveCursor(callback ListBoxSignalMoveCursorCallback) int {
	signalListBoxMoveCursorLock.Lock()
	defer signalListBoxMoveCursorLock.Unlock()

	signalListBoxMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalListBoxMoveCursorId)))

	detail := signalListBoxMoveCursorDetail{callback, handlerID}
	signalListBoxMoveCursorMap[signalListBoxMoveCursorId] = detail

	return signalListBoxMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *ListBox) DisconnectMoveCursor(connectionID int) {
	signalListBoxMoveCursorLock.Lock()
	defer signalListBoxMoveCursorLock.Unlock()

	detail, exists := signalListBoxMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxMoveCursorMap, connectionID)
}

//export listbox_moveCursorHandler
func listbox_moveCursorHandler(_ *C.GObject, c_object C.GtkMovementStep, c_p0 C.gint, data C.gpointer) {
	signalListBoxMoveCursorLock.RLock()
	defer signalListBoxMoveCursorLock.RUnlock()

	object := MovementStep(c_object)

	p0 := int32(c_p0)

	index := int(uintptr(data))
	callback := signalListBoxMoveCursorMap[index].callback
	callback(object, p0)
}

type signalListBoxToggleCursorRowDetail struct {
	callback  ListBoxSignalToggleCursorRowCallback
	handlerID C.gulong
}

var signalListBoxToggleCursorRowId int
var signalListBoxToggleCursorRowMap = make(map[int]signalListBoxToggleCursorRowDetail)
var signalListBoxToggleCursorRowLock sync.RWMutex

// ListBoxSignalToggleCursorRowCallback is a callback function for a 'toggle-cursor-row' signal emitted from a ListBox.
type ListBoxSignalToggleCursorRowCallback func()

/*
ConnectToggleCursorRow connects the callback to the 'toggle-cursor-row' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectToggleCursorRow to remove it.
*/
func (recv *ListBox) ConnectToggleCursorRow(callback ListBoxSignalToggleCursorRowCallback) int {
	signalListBoxToggleCursorRowLock.Lock()
	defer signalListBoxToggleCursorRowLock.Unlock()

	signalListBoxToggleCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_toggle_cursor_row(instance, C.gpointer(uintptr(signalListBoxToggleCursorRowId)))

	detail := signalListBoxToggleCursorRowDetail{callback, handlerID}
	signalListBoxToggleCursorRowMap[signalListBoxToggleCursorRowId] = detail

	return signalListBoxToggleCursorRowId
}

/*
DisconnectToggleCursorRow disconnects a callback from the 'toggle-cursor-row' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectToggleCursorRow.
*/
func (recv *ListBox) DisconnectToggleCursorRow(connectionID int) {
	signalListBoxToggleCursorRowLock.Lock()
	defer signalListBoxToggleCursorRowLock.Unlock()

	detail, exists := signalListBoxToggleCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxToggleCursorRowMap, connectionID)
}

//export listbox_toggleCursorRowHandler
func listbox_toggleCursorRowHandler(_ *C.GObject, data C.gpointer) {
	signalListBoxToggleCursorRowLock.RLock()
	defer signalListBoxToggleCursorRowLock.RUnlock()

	index := int(uintptr(data))
	callback := signalListBoxToggleCursorRowMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ListBox
func (recv *ListBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ListBox
func (recv *ListBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ListBoxAccessible is a wrapper around the C record GtkListBoxAccessible.
type ListBoxAccessible struct {
	native *C.GtkListBoxAccessible
	// parent : record
	// priv : record
}

func ListBoxAccessibleNewFromC(u unsafe.Pointer) *ListBoxAccessible {
	c := (*C.GtkListBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListBoxAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxAccessible with another ListBoxAccessible, and returns true if they represent the same GObject.
func (recv *ListBoxAccessible) Equals(other *ListBoxAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ListBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ListBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ListBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ListBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ListBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxAccessible.
func CastToListBoxAccessible(object *gobject.Object) *ListBoxAccessible {
	return ListBoxAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ListBoxAccessible
func (recv *ListBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by ListBoxAccessible
func (recv *ListBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// ListBoxRow is a wrapper around the C record GtkListBoxRow.
type ListBoxRow struct {
	native *C.GtkListBoxRow
	// parent_instance : record
}

func ListBoxRowNewFromC(u unsafe.Pointer) *ListBoxRow {
	c := (*C.GtkListBoxRow)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListBoxRow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListBoxRow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxRow with another ListBoxRow, and returns true if they represent the same GObject.
func (recv *ListBoxRow) Equals(other *ListBoxRow) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ListBoxRow) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ListBoxRow) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ListBoxRow) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ListBoxRow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ListBoxRow) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ListBoxRow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxRow.
func CastToListBoxRow(object *gobject.Object) *ListBoxRow {
	return ListBoxRowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ListBoxRow
func (recv *ListBoxRow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ListBoxRow
func (recv *ListBoxRow) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ListBoxRow
func (recv *ListBoxRow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ListBoxRowAccessible is a wrapper around the C record GtkListBoxRowAccessible.
type ListBoxRowAccessible struct {
	native *C.GtkListBoxRowAccessible
	// parent : record
}

func ListBoxRowAccessibleNewFromC(u unsafe.Pointer) *ListBoxRowAccessible {
	c := (*C.GtkListBoxRowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRowAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListBoxRowAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListBoxRowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxRowAccessible with another ListBoxRowAccessible, and returns true if they represent the same GObject.
func (recv *ListBoxRowAccessible) Equals(other *ListBoxRowAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ListBoxRowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ListBoxRowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ListBoxRowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ListBoxRowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ListBoxRowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxRowAccessible.
func CastToListBoxRowAccessible(object *gobject.Object) *ListBoxRowAccessible {
	return ListBoxRowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ListBoxRowAccessible
func (recv *ListBoxRowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// ListStore is a wrapper around the C record GtkListStore.
type ListStore struct {
	native *C.GtkListStore
	// parent : record
	// Private : priv
}

func ListStoreNewFromC(u unsafe.Pointer) *ListStore {
	c := (*C.GtkListStore)(u)
	if c == nil {
		return nil
	}

	g := &ListStore{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListStore) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListStore with another ListStore, and returns true if they represent the same GObject.
func (recv *ListStore) Equals(other *ListStore) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ListStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ListStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListStore.
func CastToListStore(object *gobject.Object) *ListStore {
	return ListStoreNewFromC(object.ToC())
}

// Unsupported : gtk_list_store_new : unsupported parameter ... : varargs

// ListStoreNewv is a wrapper around the C function gtk_list_store_newv.
func ListStoreNewv(types []gobject.Type) *ListStore {
	c_n_columns := (C.gint)(len(types))

	c_types_array := make([]C.GType, len(types)+1, len(types)+1)
	for i, item := range types {
		c := (C.GType)(item)
		c_types_array[i] = c
	}
	c_types_array[len(types)] = 0
	c_types_arrayPtr := &c_types_array[0]
	c_types := (*C.GType)(unsafe.Pointer(c_types_arrayPtr))

	retC := C.gtk_list_store_newv(c_n_columns, c_types)
	retGo := ListStoreNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Blacklisted : gtk_list_store_append

// Blacklisted : gtk_list_store_clear

// Blacklisted : gtk_list_store_insert

// Blacklisted : gtk_list_store_insert_after

// Blacklisted : gtk_list_store_insert_before

// Blacklisted : gtk_list_store_prepend

// Blacklisted : gtk_list_store_remove

// Unsupported : gtk_list_store_set : unsupported parameter ... : varargs

// Blacklisted : gtk_list_store_set_column_types

// Unsupported : gtk_list_store_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Blacklisted : gtk_list_store_set_value

// Buildable returns the Buildable interface implemented by ListStore
func (recv *ListStore) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TreeDragDest returns the TreeDragDest interface implemented by ListStore
func (recv *ListStore) TreeDragDest() *TreeDragDest {
	return TreeDragDestNewFromC(recv.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by ListStore
func (recv *ListStore) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by ListStore
func (recv *ListStore) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by ListStore
func (recv *ListStore) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// LockButton is a wrapper around the C record GtkLockButton.
type LockButton struct {
	native *C.GtkLockButton
	// parent : record
	// priv : record
}

func LockButtonNewFromC(u unsafe.Pointer) *LockButton {
	c := (*C.GtkLockButton)(u)
	if c == nil {
		return nil
	}

	g := &LockButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LockButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LockButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LockButton with another LockButton, and returns true if they represent the same GObject.
func (recv *LockButton) Equals(other *LockButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *LockButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *LockButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *LockButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *LockButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LockButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LockButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to LockButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a LockButton.
func CastToLockButton(object *gobject.Object) *LockButton {
	return LockButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by LockButton
func (recv *LockButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by LockButton
func (recv *LockButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by LockButton
func (recv *LockButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LockButton
func (recv *LockButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LockButtonAccessible is a wrapper around the C record GtkLockButtonAccessible.
type LockButtonAccessible struct {
	native *C.GtkLockButtonAccessible
	// parent : record
	// priv : record
}

func LockButtonAccessibleNewFromC(u unsafe.Pointer) *LockButtonAccessible {
	c := (*C.GtkLockButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LockButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LockButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LockButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LockButtonAccessible with another LockButtonAccessible, and returns true if they represent the same GObject.
func (recv *LockButtonAccessible) Equals(other *LockButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *LockButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *LockButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LockButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *LockButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LockButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to LockButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LockButtonAccessible.
func CastToLockButtonAccessible(object *gobject.Object) *LockButtonAccessible {
	return LockButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Menu is a wrapper around the C record GtkMenu.
type Menu struct {
	native *C.GtkMenu
	// menu_shell : record
	// Private : priv
}

func MenuNewFromC(u unsafe.Pointer) *Menu {
	c := (*C.GtkMenu)(u)
	if c == nil {
		return nil
	}

	g := &Menu{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Menu) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Menu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Menu with another Menu, and returns true if they represent the same GObject.
func (recv *Menu) Equals(other *Menu) bool {
	return other.ToC() == recv.ToC()
}

// MenuShell upcasts to *MenuShell
func (recv *Menu) MenuShell() *MenuShell {
	return MenuShellNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Menu) Container() *Container {
	return recv.MenuShell().Container()
}

// Widget upcasts to *Widget
func (recv *Menu) Widget() *Widget {
	return recv.MenuShell().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Menu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuShell().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Menu) Object() *gobject.Object {
	return recv.MenuShell().Object()
}

// CastToWidget down casts any arbitrary Object to Menu.
// Exercise care, as this is a potentially dangerous function if the Object is not a Menu.
func CastToMenu(object *gobject.Object) *Menu {
	return MenuNewFromC(object.ToC())
}

type signalMenuMoveScrollDetail struct {
	callback  MenuSignalMoveScrollCallback
	handlerID C.gulong
}

var signalMenuMoveScrollId int
var signalMenuMoveScrollMap = make(map[int]signalMenuMoveScrollDetail)
var signalMenuMoveScrollLock sync.RWMutex

// MenuSignalMoveScrollCallback is a callback function for a 'move-scroll' signal emitted from a Menu.
type MenuSignalMoveScrollCallback func(scrollType ScrollType)

/*
ConnectMoveScroll connects the callback to the 'move-scroll' signal for the Menu.

The returned value represents the connection, and may be passed to DisconnectMoveScroll to remove it.
*/
func (recv *Menu) ConnectMoveScroll(callback MenuSignalMoveScrollCallback) int {
	signalMenuMoveScrollLock.Lock()
	defer signalMenuMoveScrollLock.Unlock()

	signalMenuMoveScrollId++
	instance := C.gpointer(recv.native)
	handlerID := C.Menu_signal_connect_move_scroll(instance, C.gpointer(uintptr(signalMenuMoveScrollId)))

	detail := signalMenuMoveScrollDetail{callback, handlerID}
	signalMenuMoveScrollMap[signalMenuMoveScrollId] = detail

	return signalMenuMoveScrollId
}

/*
DisconnectMoveScroll disconnects a callback from the 'move-scroll' signal for the Menu.

The connectionID should be a value returned from a call to ConnectMoveScroll.
*/
func (recv *Menu) DisconnectMoveScroll(connectionID int) {
	signalMenuMoveScrollLock.Lock()
	defer signalMenuMoveScrollLock.Unlock()

	detail, exists := signalMenuMoveScrollMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuMoveScrollMap, connectionID)
}

//export menu_moveScrollHandler
func menu_moveScrollHandler(_ *C.GObject, c_scroll_type C.GtkScrollType, data C.gpointer) {
	signalMenuMoveScrollLock.RLock()
	defer signalMenuMoveScrollLock.RUnlock()

	scrollType := ScrollType(c_scroll_type)

	index := int(uintptr(data))
	callback := signalMenuMoveScrollMap[index].callback
	callback(scrollType)
}

// Blacklisted : gtk_menu_new

// Unsupported : gtk_menu_attach_to_widget : unsupported parameter detacher : no type generator for MenuDetachFunc (GtkMenuDetachFunc) for param detacher

// Blacklisted : gtk_menu_detach

// Blacklisted : gtk_menu_get_accel_group

// Blacklisted : gtk_menu_get_active

// Blacklisted : gtk_menu_get_attach_widget

// Blacklisted : gtk_menu_get_tearoff_state

// GetTitle is a wrapper around the C function gtk_menu_get_title.
func (recv *Menu) GetTitle() string {
	retC := C.gtk_menu_get_title((*C.GtkMenu)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Blacklisted : gtk_menu_popdown

// Unsupported : gtk_menu_popup : unsupported parameter func : no type generator for MenuPositionFunc (GtkMenuPositionFunc) for param func

// Blacklisted : gtk_menu_reorder_child

// Blacklisted : gtk_menu_reposition

// Blacklisted : gtk_menu_set_accel_group

// Blacklisted : gtk_menu_set_accel_path

// Blacklisted : gtk_menu_set_active

// Blacklisted : gtk_menu_set_tearoff_state

// SetTitle is a wrapper around the C function gtk_menu_set_title.
func (recv *Menu) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_menu_set_title((*C.GtkMenu)(recv.native), c_title)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Menu
func (recv *Menu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Menu
func (recv *Menu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuAccessible is a wrapper around the C record GtkMenuAccessible.
type MenuAccessible struct {
	native *C.GtkMenuAccessible
	// parent : record
	// priv : record
}

func MenuAccessibleNewFromC(u unsafe.Pointer) *MenuAccessible {
	c := (*C.GtkMenuAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuAccessible with another MenuAccessible, and returns true if they represent the same GObject.
func (recv *MenuAccessible) Equals(other *MenuAccessible) bool {
	return other.ToC() == recv.ToC()
}

// MenuShellAccessible upcasts to *MenuShellAccessible
func (recv *MenuAccessible) MenuShellAccessible() *MenuShellAccessible {
	return MenuShellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.MenuShellAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.MenuShellAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuAccessible) Accessible() *Accessible {
	return recv.MenuShellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuAccessible) Object() *atk.Object {
	return recv.MenuShellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to MenuAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuAccessible.
func CastToMenuAccessible(object *gobject.Object) *MenuAccessible {
	return MenuAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by MenuAccessible
func (recv *MenuAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuAccessible
func (recv *MenuAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuBar is a wrapper around the C record GtkMenuBar.
type MenuBar struct {
	native *C.GtkMenuBar
	// menu_shell : record
	// Private : priv
}

func MenuBarNewFromC(u unsafe.Pointer) *MenuBar {
	c := (*C.GtkMenuBar)(u)
	if c == nil {
		return nil
	}

	g := &MenuBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuBar with another MenuBar, and returns true if they represent the same GObject.
func (recv *MenuBar) Equals(other *MenuBar) bool {
	return other.ToC() == recv.ToC()
}

// MenuShell upcasts to *MenuShell
func (recv *MenuBar) MenuShell() *MenuShell {
	return MenuShellNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *MenuBar) Container() *Container {
	return recv.MenuShell().Container()
}

// Widget upcasts to *Widget
func (recv *MenuBar) Widget() *Widget {
	return recv.MenuShell().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuShell().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuBar) Object() *gobject.Object {
	return recv.MenuShell().Object()
}

// CastToWidget down casts any arbitrary Object to MenuBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuBar.
func CastToMenuBar(object *gobject.Object) *MenuBar {
	return MenuBarNewFromC(object.ToC())
}

// Blacklisted : gtk_menu_bar_new

// ImplementorIface returns the ImplementorIface interface implemented by MenuBar
func (recv *MenuBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuBar
func (recv *MenuBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuButton is a wrapper around the C record GtkMenuButton.
type MenuButton struct {
	native *C.GtkMenuButton
	// parent : record
	// Private : priv
}

func MenuButtonNewFromC(u unsafe.Pointer) *MenuButton {
	c := (*C.GtkMenuButton)(u)
	if c == nil {
		return nil
	}

	g := &MenuButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuButton with another MenuButton, and returns true if they represent the same GObject.
func (recv *MenuButton) Equals(other *MenuButton) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButton upcasts to *ToggleButton
func (recv *MenuButton) ToggleButton() *ToggleButton {
	return ToggleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *MenuButton) Button() *Button {
	return recv.ToggleButton().Button()
}

// Bin upcasts to *Bin
func (recv *MenuButton) Bin() *Bin {
	return recv.ToggleButton().Bin()
}

// Container upcasts to *Container
func (recv *MenuButton) Container() *Container {
	return recv.ToggleButton().Container()
}

// Widget upcasts to *Widget
func (recv *MenuButton) Widget() *Widget {
	return recv.ToggleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuButton) Object() *gobject.Object {
	return recv.ToggleButton().Object()
}

// CastToWidget down casts any arbitrary Object to MenuButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuButton.
func CastToMenuButton(object *gobject.Object) *MenuButton {
	return MenuButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuButton
func (recv *MenuButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuButton
func (recv *MenuButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuButton
func (recv *MenuButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuButton
func (recv *MenuButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuButtonAccessible is a wrapper around the C record GtkMenuButtonAccessible.
type MenuButtonAccessible struct {
	native *C.GtkMenuButtonAccessible
	// parent : record
	// priv : record
}

func MenuButtonAccessibleNewFromC(u unsafe.Pointer) *MenuButtonAccessible {
	c := (*C.GtkMenuButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuButtonAccessible with another MenuButtonAccessible, and returns true if they represent the same GObject.
func (recv *MenuButtonAccessible) Equals(other *MenuButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButtonAccessible upcasts to *ToggleButtonAccessible
func (recv *MenuButtonAccessible) ToggleButtonAccessible() *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *MenuButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return recv.ToggleButtonAccessible().ButtonAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ToggleButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ToggleButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuButtonAccessible) Accessible() *Accessible {
	return recv.ToggleButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuButtonAccessible) Object() *atk.Object {
	return recv.ToggleButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to MenuButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuButtonAccessible.
func CastToMenuButtonAccessible(object *gobject.Object) *MenuButtonAccessible {
	return MenuButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// MenuItem is a wrapper around the C record GtkMenuItem.
type MenuItem struct {
	native *C.GtkMenuItem
	// bin : record
	// Private : priv
}

func MenuItemNewFromC(u unsafe.Pointer) *MenuItem {
	c := (*C.GtkMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &MenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItem with another MenuItem, and returns true if they represent the same GObject.
func (recv *MenuItem) Equals(other *MenuItem) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *MenuItem) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *MenuItem) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *MenuItem) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuItem) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to MenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItem.
func CastToMenuItem(object *gobject.Object) *MenuItem {
	return MenuItemNewFromC(object.ToC())
}

type signalMenuItemActivateDetail struct {
	callback  MenuItemSignalActivateCallback
	handlerID C.gulong
}

var signalMenuItemActivateId int
var signalMenuItemActivateMap = make(map[int]signalMenuItemActivateDetail)
var signalMenuItemActivateLock sync.RWMutex

// MenuItemSignalActivateCallback is a callback function for a 'activate' signal emitted from a MenuItem.
type MenuItemSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *MenuItem) ConnectActivate(callback MenuItemSignalActivateCallback) int {
	signalMenuItemActivateLock.Lock()
	defer signalMenuItemActivateLock.Unlock()

	signalMenuItemActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_activate(instance, C.gpointer(uintptr(signalMenuItemActivateId)))

	detail := signalMenuItemActivateDetail{callback, handlerID}
	signalMenuItemActivateMap[signalMenuItemActivateId] = detail

	return signalMenuItemActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *MenuItem) DisconnectActivate(connectionID int) {
	signalMenuItemActivateLock.Lock()
	defer signalMenuItemActivateLock.Unlock()

	detail, exists := signalMenuItemActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemActivateMap, connectionID)
}

//export menuitem_activateHandler
func menuitem_activateHandler(_ *C.GObject, data C.gpointer) {
	signalMenuItemActivateLock.RLock()
	defer signalMenuItemActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuItemActivateMap[index].callback
	callback()
}

type signalMenuItemActivateItemDetail struct {
	callback  MenuItemSignalActivateItemCallback
	handlerID C.gulong
}

var signalMenuItemActivateItemId int
var signalMenuItemActivateItemMap = make(map[int]signalMenuItemActivateItemDetail)
var signalMenuItemActivateItemLock sync.RWMutex

// MenuItemSignalActivateItemCallback is a callback function for a 'activate-item' signal emitted from a MenuItem.
type MenuItemSignalActivateItemCallback func()

/*
ConnectActivateItem connects the callback to the 'activate-item' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectActivateItem to remove it.
*/
func (recv *MenuItem) ConnectActivateItem(callback MenuItemSignalActivateItemCallback) int {
	signalMenuItemActivateItemLock.Lock()
	defer signalMenuItemActivateItemLock.Unlock()

	signalMenuItemActivateItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_activate_item(instance, C.gpointer(uintptr(signalMenuItemActivateItemId)))

	detail := signalMenuItemActivateItemDetail{callback, handlerID}
	signalMenuItemActivateItemMap[signalMenuItemActivateItemId] = detail

	return signalMenuItemActivateItemId
}

/*
DisconnectActivateItem disconnects a callback from the 'activate-item' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectActivateItem.
*/
func (recv *MenuItem) DisconnectActivateItem(connectionID int) {
	signalMenuItemActivateItemLock.Lock()
	defer signalMenuItemActivateItemLock.Unlock()

	detail, exists := signalMenuItemActivateItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemActivateItemMap, connectionID)
}

//export menuitem_activateItemHandler
func menuitem_activateItemHandler(_ *C.GObject, data C.gpointer) {
	signalMenuItemActivateItemLock.RLock()
	defer signalMenuItemActivateItemLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuItemActivateItemMap[index].callback
	callback()
}

type signalMenuItemDeselectDetail struct {
	callback  MenuItemSignalDeselectCallback
	handlerID C.gulong
}

var signalMenuItemDeselectId int
var signalMenuItemDeselectMap = make(map[int]signalMenuItemDeselectDetail)
var signalMenuItemDeselectLock sync.RWMutex

// MenuItemSignalDeselectCallback is a callback function for a 'deselect' signal emitted from a MenuItem.
type MenuItemSignalDeselectCallback func()

/*
ConnectDeselect connects the callback to the 'deselect' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectDeselect to remove it.
*/
func (recv *MenuItem) ConnectDeselect(callback MenuItemSignalDeselectCallback) int {
	signalMenuItemDeselectLock.Lock()
	defer signalMenuItemDeselectLock.Unlock()

	signalMenuItemDeselectId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_deselect(instance, C.gpointer(uintptr(signalMenuItemDeselectId)))

	detail := signalMenuItemDeselectDetail{callback, handlerID}
	signalMenuItemDeselectMap[signalMenuItemDeselectId] = detail

	return signalMenuItemDeselectId
}

/*
DisconnectDeselect disconnects a callback from the 'deselect' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectDeselect.
*/
func (recv *MenuItem) DisconnectDeselect(connectionID int) {
	signalMenuItemDeselectLock.Lock()
	defer signalMenuItemDeselectLock.Unlock()

	detail, exists := signalMenuItemDeselectMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemDeselectMap, connectionID)
}

//export menuitem_deselectHandler
func menuitem_deselectHandler(_ *C.GObject, data C.gpointer) {
	signalMenuItemDeselectLock.RLock()
	defer signalMenuItemDeselectLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuItemDeselectMap[index].callback
	callback()
}

type signalMenuItemSelectDetail struct {
	callback  MenuItemSignalSelectCallback
	handlerID C.gulong
}

var signalMenuItemSelectId int
var signalMenuItemSelectMap = make(map[int]signalMenuItemSelectDetail)
var signalMenuItemSelectLock sync.RWMutex

// MenuItemSignalSelectCallback is a callback function for a 'select' signal emitted from a MenuItem.
type MenuItemSignalSelectCallback func()

/*
ConnectSelect connects the callback to the 'select' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectSelect to remove it.
*/
func (recv *MenuItem) ConnectSelect(callback MenuItemSignalSelectCallback) int {
	signalMenuItemSelectLock.Lock()
	defer signalMenuItemSelectLock.Unlock()

	signalMenuItemSelectId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_select(instance, C.gpointer(uintptr(signalMenuItemSelectId)))

	detail := signalMenuItemSelectDetail{callback, handlerID}
	signalMenuItemSelectMap[signalMenuItemSelectId] = detail

	return signalMenuItemSelectId
}

/*
DisconnectSelect disconnects a callback from the 'select' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectSelect.
*/
func (recv *MenuItem) DisconnectSelect(connectionID int) {
	signalMenuItemSelectLock.Lock()
	defer signalMenuItemSelectLock.Unlock()

	detail, exists := signalMenuItemSelectMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemSelectMap, connectionID)
}

//export menuitem_selectHandler
func menuitem_selectHandler(_ *C.GObject, data C.gpointer) {
	signalMenuItemSelectLock.RLock()
	defer signalMenuItemSelectLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuItemSelectMap[index].callback
	callback()
}

type signalMenuItemToggleSizeAllocateDetail struct {
	callback  MenuItemSignalToggleSizeAllocateCallback
	handlerID C.gulong
}

var signalMenuItemToggleSizeAllocateId int
var signalMenuItemToggleSizeAllocateMap = make(map[int]signalMenuItemToggleSizeAllocateDetail)
var signalMenuItemToggleSizeAllocateLock sync.RWMutex

// MenuItemSignalToggleSizeAllocateCallback is a callback function for a 'toggle-size-allocate' signal emitted from a MenuItem.
type MenuItemSignalToggleSizeAllocateCallback func(object int32)

/*
ConnectToggleSizeAllocate connects the callback to the 'toggle-size-allocate' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectToggleSizeAllocate to remove it.
*/
func (recv *MenuItem) ConnectToggleSizeAllocate(callback MenuItemSignalToggleSizeAllocateCallback) int {
	signalMenuItemToggleSizeAllocateLock.Lock()
	defer signalMenuItemToggleSizeAllocateLock.Unlock()

	signalMenuItemToggleSizeAllocateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_toggle_size_allocate(instance, C.gpointer(uintptr(signalMenuItemToggleSizeAllocateId)))

	detail := signalMenuItemToggleSizeAllocateDetail{callback, handlerID}
	signalMenuItemToggleSizeAllocateMap[signalMenuItemToggleSizeAllocateId] = detail

	return signalMenuItemToggleSizeAllocateId
}

/*
DisconnectToggleSizeAllocate disconnects a callback from the 'toggle-size-allocate' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectToggleSizeAllocate.
*/
func (recv *MenuItem) DisconnectToggleSizeAllocate(connectionID int) {
	signalMenuItemToggleSizeAllocateLock.Lock()
	defer signalMenuItemToggleSizeAllocateLock.Unlock()

	detail, exists := signalMenuItemToggleSizeAllocateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemToggleSizeAllocateMap, connectionID)
}

//export menuitem_toggleSizeAllocateHandler
func menuitem_toggleSizeAllocateHandler(_ *C.GObject, c_object C.gint, data C.gpointer) {
	signalMenuItemToggleSizeAllocateLock.RLock()
	defer signalMenuItemToggleSizeAllocateLock.RUnlock()

	object := int32(c_object)

	index := int(uintptr(data))
	callback := signalMenuItemToggleSizeAllocateMap[index].callback
	callback(object)
}

// Unsupported signal 'toggle-size-request' for MenuItem : unsupported parameter object : no type generator for gpointer, gpointer

// Blacklisted : gtk_menu_item_new

// Blacklisted : gtk_menu_item_new_with_label

// Blacklisted : gtk_menu_item_new_with_mnemonic

// Blacklisted : gtk_menu_item_activate

// Blacklisted : gtk_menu_item_deselect

// Blacklisted : gtk_menu_item_get_right_justified

// Blacklisted : gtk_menu_item_get_submenu

// Blacklisted : gtk_menu_item_select

// Blacklisted : gtk_menu_item_set_accel_path

// Blacklisted : gtk_menu_item_set_right_justified

// Blacklisted : gtk_menu_item_set_submenu

// Blacklisted : gtk_menu_item_toggle_size_allocate

// Blacklisted : gtk_menu_item_toggle_size_request

// ImplementorIface returns the ImplementorIface interface implemented by MenuItem
func (recv *MenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuItem
func (recv *MenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuItem
func (recv *MenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuItem
func (recv *MenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuItemAccessible is a wrapper around the C record GtkMenuItemAccessible.
type MenuItemAccessible struct {
	native *C.GtkMenuItemAccessible
	// parent : record
	// priv : record
}

func MenuItemAccessibleNewFromC(u unsafe.Pointer) *MenuItemAccessible {
	c := (*C.GtkMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuItemAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuItemAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItemAccessible with another MenuItemAccessible, and returns true if they represent the same GObject.
func (recv *MenuItemAccessible) Equals(other *MenuItemAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuItemAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuItemAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to MenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItemAccessible.
func CastToMenuItemAccessible(object *gobject.Object) *MenuItemAccessible {
	return MenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuShell is a wrapper around the C record GtkMenuShell.
type MenuShell struct {
	native *C.GtkMenuShell
	// container : record
	// Private : priv
}

func MenuShellNewFromC(u unsafe.Pointer) *MenuShell {
	c := (*C.GtkMenuShell)(u)
	if c == nil {
		return nil
	}

	g := &MenuShell{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuShell) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuShell) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuShell with another MenuShell, and returns true if they represent the same GObject.
func (recv *MenuShell) Equals(other *MenuShell) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *MenuShell) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *MenuShell) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuShell) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuShell) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to MenuShell.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuShell.
func CastToMenuShell(object *gobject.Object) *MenuShell {
	return MenuShellNewFromC(object.ToC())
}

type signalMenuShellActivateCurrentDetail struct {
	callback  MenuShellSignalActivateCurrentCallback
	handlerID C.gulong
}

var signalMenuShellActivateCurrentId int
var signalMenuShellActivateCurrentMap = make(map[int]signalMenuShellActivateCurrentDetail)
var signalMenuShellActivateCurrentLock sync.RWMutex

// MenuShellSignalActivateCurrentCallback is a callback function for a 'activate-current' signal emitted from a MenuShell.
type MenuShellSignalActivateCurrentCallback func(forceHide bool)

/*
ConnectActivateCurrent connects the callback to the 'activate-current' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectActivateCurrent to remove it.
*/
func (recv *MenuShell) ConnectActivateCurrent(callback MenuShellSignalActivateCurrentCallback) int {
	signalMenuShellActivateCurrentLock.Lock()
	defer signalMenuShellActivateCurrentLock.Unlock()

	signalMenuShellActivateCurrentId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_activate_current(instance, C.gpointer(uintptr(signalMenuShellActivateCurrentId)))

	detail := signalMenuShellActivateCurrentDetail{callback, handlerID}
	signalMenuShellActivateCurrentMap[signalMenuShellActivateCurrentId] = detail

	return signalMenuShellActivateCurrentId
}

/*
DisconnectActivateCurrent disconnects a callback from the 'activate-current' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectActivateCurrent.
*/
func (recv *MenuShell) DisconnectActivateCurrent(connectionID int) {
	signalMenuShellActivateCurrentLock.Lock()
	defer signalMenuShellActivateCurrentLock.Unlock()

	detail, exists := signalMenuShellActivateCurrentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellActivateCurrentMap, connectionID)
}

//export menushell_activateCurrentHandler
func menushell_activateCurrentHandler(_ *C.GObject, c_force_hide C.gboolean, data C.gpointer) {
	signalMenuShellActivateCurrentLock.RLock()
	defer signalMenuShellActivateCurrentLock.RUnlock()

	forceHide := c_force_hide == C.TRUE

	index := int(uintptr(data))
	callback := signalMenuShellActivateCurrentMap[index].callback
	callback(forceHide)
}

type signalMenuShellCancelDetail struct {
	callback  MenuShellSignalCancelCallback
	handlerID C.gulong
}

var signalMenuShellCancelId int
var signalMenuShellCancelMap = make(map[int]signalMenuShellCancelDetail)
var signalMenuShellCancelLock sync.RWMutex

// MenuShellSignalCancelCallback is a callback function for a 'cancel' signal emitted from a MenuShell.
type MenuShellSignalCancelCallback func()

/*
ConnectCancel connects the callback to the 'cancel' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectCancel to remove it.
*/
func (recv *MenuShell) ConnectCancel(callback MenuShellSignalCancelCallback) int {
	signalMenuShellCancelLock.Lock()
	defer signalMenuShellCancelLock.Unlock()

	signalMenuShellCancelId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_cancel(instance, C.gpointer(uintptr(signalMenuShellCancelId)))

	detail := signalMenuShellCancelDetail{callback, handlerID}
	signalMenuShellCancelMap[signalMenuShellCancelId] = detail

	return signalMenuShellCancelId
}

/*
DisconnectCancel disconnects a callback from the 'cancel' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectCancel.
*/
func (recv *MenuShell) DisconnectCancel(connectionID int) {
	signalMenuShellCancelLock.Lock()
	defer signalMenuShellCancelLock.Unlock()

	detail, exists := signalMenuShellCancelMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellCancelMap, connectionID)
}

//export menushell_cancelHandler
func menushell_cancelHandler(_ *C.GObject, data C.gpointer) {
	signalMenuShellCancelLock.RLock()
	defer signalMenuShellCancelLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuShellCancelMap[index].callback
	callback()
}

type signalMenuShellCycleFocusDetail struct {
	callback  MenuShellSignalCycleFocusCallback
	handlerID C.gulong
}

var signalMenuShellCycleFocusId int
var signalMenuShellCycleFocusMap = make(map[int]signalMenuShellCycleFocusDetail)
var signalMenuShellCycleFocusLock sync.RWMutex

// MenuShellSignalCycleFocusCallback is a callback function for a 'cycle-focus' signal emitted from a MenuShell.
type MenuShellSignalCycleFocusCallback func(direction DirectionType)

/*
ConnectCycleFocus connects the callback to the 'cycle-focus' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectCycleFocus to remove it.
*/
func (recv *MenuShell) ConnectCycleFocus(callback MenuShellSignalCycleFocusCallback) int {
	signalMenuShellCycleFocusLock.Lock()
	defer signalMenuShellCycleFocusLock.Unlock()

	signalMenuShellCycleFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_cycle_focus(instance, C.gpointer(uintptr(signalMenuShellCycleFocusId)))

	detail := signalMenuShellCycleFocusDetail{callback, handlerID}
	signalMenuShellCycleFocusMap[signalMenuShellCycleFocusId] = detail

	return signalMenuShellCycleFocusId
}

/*
DisconnectCycleFocus disconnects a callback from the 'cycle-focus' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectCycleFocus.
*/
func (recv *MenuShell) DisconnectCycleFocus(connectionID int) {
	signalMenuShellCycleFocusLock.Lock()
	defer signalMenuShellCycleFocusLock.Unlock()

	detail, exists := signalMenuShellCycleFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellCycleFocusMap, connectionID)
}

//export menushell_cycleFocusHandler
func menushell_cycleFocusHandler(_ *C.GObject, c_direction C.GtkDirectionType, data C.gpointer) {
	signalMenuShellCycleFocusLock.RLock()
	defer signalMenuShellCycleFocusLock.RUnlock()

	direction := DirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalMenuShellCycleFocusMap[index].callback
	callback(direction)
}

type signalMenuShellDeactivateDetail struct {
	callback  MenuShellSignalDeactivateCallback
	handlerID C.gulong
}

var signalMenuShellDeactivateId int
var signalMenuShellDeactivateMap = make(map[int]signalMenuShellDeactivateDetail)
var signalMenuShellDeactivateLock sync.RWMutex

// MenuShellSignalDeactivateCallback is a callback function for a 'deactivate' signal emitted from a MenuShell.
type MenuShellSignalDeactivateCallback func()

/*
ConnectDeactivate connects the callback to the 'deactivate' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectDeactivate to remove it.
*/
func (recv *MenuShell) ConnectDeactivate(callback MenuShellSignalDeactivateCallback) int {
	signalMenuShellDeactivateLock.Lock()
	defer signalMenuShellDeactivateLock.Unlock()

	signalMenuShellDeactivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_deactivate(instance, C.gpointer(uintptr(signalMenuShellDeactivateId)))

	detail := signalMenuShellDeactivateDetail{callback, handlerID}
	signalMenuShellDeactivateMap[signalMenuShellDeactivateId] = detail

	return signalMenuShellDeactivateId
}

/*
DisconnectDeactivate disconnects a callback from the 'deactivate' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectDeactivate.
*/
func (recv *MenuShell) DisconnectDeactivate(connectionID int) {
	signalMenuShellDeactivateLock.Lock()
	defer signalMenuShellDeactivateLock.Unlock()

	detail, exists := signalMenuShellDeactivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellDeactivateMap, connectionID)
}

//export menushell_deactivateHandler
func menushell_deactivateHandler(_ *C.GObject, data C.gpointer) {
	signalMenuShellDeactivateLock.RLock()
	defer signalMenuShellDeactivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuShellDeactivateMap[index].callback
	callback()
}

type signalMenuShellMoveCurrentDetail struct {
	callback  MenuShellSignalMoveCurrentCallback
	handlerID C.gulong
}

var signalMenuShellMoveCurrentId int
var signalMenuShellMoveCurrentMap = make(map[int]signalMenuShellMoveCurrentDetail)
var signalMenuShellMoveCurrentLock sync.RWMutex

// MenuShellSignalMoveCurrentCallback is a callback function for a 'move-current' signal emitted from a MenuShell.
type MenuShellSignalMoveCurrentCallback func(direction MenuDirectionType)

/*
ConnectMoveCurrent connects the callback to the 'move-current' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectMoveCurrent to remove it.
*/
func (recv *MenuShell) ConnectMoveCurrent(callback MenuShellSignalMoveCurrentCallback) int {
	signalMenuShellMoveCurrentLock.Lock()
	defer signalMenuShellMoveCurrentLock.Unlock()

	signalMenuShellMoveCurrentId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_move_current(instance, C.gpointer(uintptr(signalMenuShellMoveCurrentId)))

	detail := signalMenuShellMoveCurrentDetail{callback, handlerID}
	signalMenuShellMoveCurrentMap[signalMenuShellMoveCurrentId] = detail

	return signalMenuShellMoveCurrentId
}

/*
DisconnectMoveCurrent disconnects a callback from the 'move-current' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectMoveCurrent.
*/
func (recv *MenuShell) DisconnectMoveCurrent(connectionID int) {
	signalMenuShellMoveCurrentLock.Lock()
	defer signalMenuShellMoveCurrentLock.Unlock()

	detail, exists := signalMenuShellMoveCurrentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellMoveCurrentMap, connectionID)
}

//export menushell_moveCurrentHandler
func menushell_moveCurrentHandler(_ *C.GObject, c_direction C.GtkMenuDirectionType, data C.gpointer) {
	signalMenuShellMoveCurrentLock.RLock()
	defer signalMenuShellMoveCurrentLock.RUnlock()

	direction := MenuDirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalMenuShellMoveCurrentMap[index].callback
	callback(direction)
}

type signalMenuShellSelectionDoneDetail struct {
	callback  MenuShellSignalSelectionDoneCallback
	handlerID C.gulong
}

var signalMenuShellSelectionDoneId int
var signalMenuShellSelectionDoneMap = make(map[int]signalMenuShellSelectionDoneDetail)
var signalMenuShellSelectionDoneLock sync.RWMutex

// MenuShellSignalSelectionDoneCallback is a callback function for a 'selection-done' signal emitted from a MenuShell.
type MenuShellSignalSelectionDoneCallback func()

/*
ConnectSelectionDone connects the callback to the 'selection-done' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectSelectionDone to remove it.
*/
func (recv *MenuShell) ConnectSelectionDone(callback MenuShellSignalSelectionDoneCallback) int {
	signalMenuShellSelectionDoneLock.Lock()
	defer signalMenuShellSelectionDoneLock.Unlock()

	signalMenuShellSelectionDoneId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_selection_done(instance, C.gpointer(uintptr(signalMenuShellSelectionDoneId)))

	detail := signalMenuShellSelectionDoneDetail{callback, handlerID}
	signalMenuShellSelectionDoneMap[signalMenuShellSelectionDoneId] = detail

	return signalMenuShellSelectionDoneId
}

/*
DisconnectSelectionDone disconnects a callback from the 'selection-done' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectSelectionDone.
*/
func (recv *MenuShell) DisconnectSelectionDone(connectionID int) {
	signalMenuShellSelectionDoneLock.Lock()
	defer signalMenuShellSelectionDoneLock.Unlock()

	detail, exists := signalMenuShellSelectionDoneMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellSelectionDoneMap, connectionID)
}

//export menushell_selectionDoneHandler
func menushell_selectionDoneHandler(_ *C.GObject, data C.gpointer) {
	signalMenuShellSelectionDoneLock.RLock()
	defer signalMenuShellSelectionDoneLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuShellSelectionDoneMap[index].callback
	callback()
}

// Blacklisted : gtk_menu_shell_activate_item

// Blacklisted : gtk_menu_shell_append

// Blacklisted : gtk_menu_shell_deactivate

// Blacklisted : gtk_menu_shell_deselect

// Blacklisted : gtk_menu_shell_insert

// Blacklisted : gtk_menu_shell_prepend

// Blacklisted : gtk_menu_shell_select_item

// ImplementorIface returns the ImplementorIface interface implemented by MenuShell
func (recv *MenuShell) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuShell
func (recv *MenuShell) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuShellAccessible is a wrapper around the C record GtkMenuShellAccessible.
type MenuShellAccessible struct {
	native *C.GtkMenuShellAccessible
	// parent : record
	// priv : record
}

func MenuShellAccessibleNewFromC(u unsafe.Pointer) *MenuShellAccessible {
	c := (*C.GtkMenuShellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuShellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuShellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuShellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuShellAccessible with another MenuShellAccessible, and returns true if they represent the same GObject.
func (recv *MenuShellAccessible) Equals(other *MenuShellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuShellAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuShellAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuShellAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuShellAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to MenuShellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuShellAccessible.
func CastToMenuShellAccessible(object *gobject.Object) *MenuShellAccessible {
	return MenuShellAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by MenuShellAccessible
func (recv *MenuShellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuShellAccessible
func (recv *MenuShellAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuToolButton is a wrapper around the C record GtkMenuToolButton.
type MenuToolButton struct {
	native *C.GtkMenuToolButton
	// parent : record
	// Private : priv
}

func MenuToolButtonNewFromC(u unsafe.Pointer) *MenuToolButton {
	c := (*C.GtkMenuToolButton)(u)
	if c == nil {
		return nil
	}

	g := &MenuToolButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuToolButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuToolButton with another MenuToolButton, and returns true if they represent the same GObject.
func (recv *MenuToolButton) Equals(other *MenuToolButton) bool {
	return other.ToC() == recv.ToC()
}

// ToolButton upcasts to *ToolButton
func (recv *MenuToolButton) ToolButton() *ToolButton {
	return ToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolItem upcasts to *ToolItem
func (recv *MenuToolButton) ToolItem() *ToolItem {
	return recv.ToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *MenuToolButton) Bin() *Bin {
	return recv.ToolButton().Bin()
}

// Container upcasts to *Container
func (recv *MenuToolButton) Container() *Container {
	return recv.ToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *MenuToolButton) Widget() *Widget {
	return recv.ToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuToolButton) Object() *gobject.Object {
	return recv.ToolButton().Object()
}

// CastToWidget down casts any arbitrary Object to MenuToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuToolButton.
func CastToMenuToolButton(object *gobject.Object) *MenuToolButton {
	return MenuToolButtonNewFromC(object.ToC())
}

type signalMenuToolButtonShowMenuDetail struct {
	callback  MenuToolButtonSignalShowMenuCallback
	handlerID C.gulong
}

var signalMenuToolButtonShowMenuId int
var signalMenuToolButtonShowMenuMap = make(map[int]signalMenuToolButtonShowMenuDetail)
var signalMenuToolButtonShowMenuLock sync.RWMutex

// MenuToolButtonSignalShowMenuCallback is a callback function for a 'show-menu' signal emitted from a MenuToolButton.
type MenuToolButtonSignalShowMenuCallback func()

/*
ConnectShowMenu connects the callback to the 'show-menu' signal for the MenuToolButton.

The returned value represents the connection, and may be passed to DisconnectShowMenu to remove it.
*/
func (recv *MenuToolButton) ConnectShowMenu(callback MenuToolButtonSignalShowMenuCallback) int {
	signalMenuToolButtonShowMenuLock.Lock()
	defer signalMenuToolButtonShowMenuLock.Unlock()

	signalMenuToolButtonShowMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuToolButton_signal_connect_show_menu(instance, C.gpointer(uintptr(signalMenuToolButtonShowMenuId)))

	detail := signalMenuToolButtonShowMenuDetail{callback, handlerID}
	signalMenuToolButtonShowMenuMap[signalMenuToolButtonShowMenuId] = detail

	return signalMenuToolButtonShowMenuId
}

/*
DisconnectShowMenu disconnects a callback from the 'show-menu' signal for the MenuToolButton.

The connectionID should be a value returned from a call to ConnectShowMenu.
*/
func (recv *MenuToolButton) DisconnectShowMenu(connectionID int) {
	signalMenuToolButtonShowMenuLock.Lock()
	defer signalMenuToolButtonShowMenuLock.Unlock()

	detail, exists := signalMenuToolButtonShowMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuToolButtonShowMenuMap, connectionID)
}

//export menutoolbutton_showMenuHandler
func menutoolbutton_showMenuHandler(_ *C.GObject, data C.gpointer) {
	signalMenuToolButtonShowMenuLock.RLock()
	defer signalMenuToolButtonShowMenuLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuToolButtonShowMenuMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuToolButton
func (recv *MenuToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuToolButton
func (recv *MenuToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuToolButton
func (recv *MenuToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuToolButton
func (recv *MenuToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MessageDialog is a wrapper around the C record GtkMessageDialog.
type MessageDialog struct {
	native *C.GtkMessageDialog
	// parent_instance : record
	// Private : priv
}

func MessageDialogNewFromC(u unsafe.Pointer) *MessageDialog {
	c := (*C.GtkMessageDialog)(u)
	if c == nil {
		return nil
	}

	g := &MessageDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MessageDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MessageDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MessageDialog with another MessageDialog, and returns true if they represent the same GObject.
func (recv *MessageDialog) Equals(other *MessageDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *MessageDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *MessageDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *MessageDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *MessageDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *MessageDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MessageDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MessageDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to MessageDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a MessageDialog.
func CastToMessageDialog(object *gobject.Object) *MessageDialog {
	return MessageDialogNewFromC(object.ToC())
}

// Blacklisted : gtk_message_dialog_new

// ImplementorIface returns the ImplementorIface interface implemented by MessageDialog
func (recv *MessageDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MessageDialog
func (recv *MessageDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Misc is a wrapper around the C record GtkMisc.
type Misc struct {
	native *C.GtkMisc
	// widget : record
	// Private : priv
}

func MiscNewFromC(u unsafe.Pointer) *Misc {
	c := (*C.GtkMisc)(u)
	if c == nil {
		return nil
	}

	g := &Misc{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Misc) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Misc) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Misc with another Misc, and returns true if they represent the same GObject.
func (recv *Misc) Equals(other *Misc) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Misc) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Misc) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Misc) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Misc.
// Exercise care, as this is a potentially dangerous function if the Object is not a Misc.
func CastToMisc(object *gobject.Object) *Misc {
	return MiscNewFromC(object.ToC())
}

// Blacklisted : gtk_misc_get_alignment

// Blacklisted : gtk_misc_get_padding

// Blacklisted : gtk_misc_set_alignment

// Blacklisted : gtk_misc_set_padding

// ImplementorIface returns the ImplementorIface interface implemented by Misc
func (recv *Misc) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Misc
func (recv *Misc) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ModelButton is a wrapper around the C record GtkModelButton.
type ModelButton struct {
	native *C.GtkModelButton
}

func ModelButtonNewFromC(u unsafe.Pointer) *ModelButton {
	c := (*C.GtkModelButton)(u)
	if c == nil {
		return nil
	}

	g := &ModelButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ModelButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ModelButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ModelButton with another ModelButton, and returns true if they represent the same GObject.
func (recv *ModelButton) Equals(other *ModelButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *ModelButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ModelButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ModelButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ModelButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ModelButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ModelButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to ModelButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ModelButton.
func CastToModelButton(object *gobject.Object) *ModelButton {
	return ModelButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ModelButton
func (recv *ModelButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ModelButton
func (recv *ModelButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ModelButton
func (recv *ModelButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ModelButton
func (recv *ModelButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MountOperation is a wrapper around the C record GtkMountOperation.
type MountOperation struct {
	native *C.GtkMountOperation
	// parent_instance : record
	// priv : record
}

func MountOperationNewFromC(u unsafe.Pointer) *MountOperation {
	c := (*C.GtkMountOperation)(u)
	if c == nil {
		return nil
	}

	g := &MountOperation{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MountOperation) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MountOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MountOperation with another MountOperation, and returns true if they represent the same GObject.
func (recv *MountOperation) Equals(other *MountOperation) bool {
	return other.ToC() == recv.ToC()
}

// MountOperation upcasts to *MountOperation
func (recv *MountOperation) MountOperation() *gio.MountOperation {
	return gio.MountOperationNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *MountOperation) Object() *gobject.Object {
	return recv.MountOperation().Object()
}

// CastToWidget down casts any arbitrary Object to MountOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a MountOperation.
func CastToMountOperation(object *gobject.Object) *MountOperation {
	return MountOperationNewFromC(object.ToC())
}

// Notebook is a wrapper around the C record GtkNotebook.
type Notebook struct {
	native *C.GtkNotebook
	// Private : container
	// Private : priv
}

func NotebookNewFromC(u unsafe.Pointer) *Notebook {
	c := (*C.GtkNotebook)(u)
	if c == nil {
		return nil
	}

	g := &Notebook{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Notebook) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Notebook) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Notebook with another Notebook, and returns true if they represent the same GObject.
func (recv *Notebook) Equals(other *Notebook) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Notebook) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Notebook) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Notebook) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Notebook) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Notebook.
// Exercise care, as this is a potentially dangerous function if the Object is not a Notebook.
func CastToNotebook(object *gobject.Object) *Notebook {
	return NotebookNewFromC(object.ToC())
}

type signalNotebookChangeCurrentPageDetail struct {
	callback  NotebookSignalChangeCurrentPageCallback
	handlerID C.gulong
}

var signalNotebookChangeCurrentPageId int
var signalNotebookChangeCurrentPageMap = make(map[int]signalNotebookChangeCurrentPageDetail)
var signalNotebookChangeCurrentPageLock sync.RWMutex

// NotebookSignalChangeCurrentPageCallback is a callback function for a 'change-current-page' signal emitted from a Notebook.
type NotebookSignalChangeCurrentPageCallback func(object int32) bool

/*
ConnectChangeCurrentPage connects the callback to the 'change-current-page' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectChangeCurrentPage to remove it.
*/
func (recv *Notebook) ConnectChangeCurrentPage(callback NotebookSignalChangeCurrentPageCallback) int {
	signalNotebookChangeCurrentPageLock.Lock()
	defer signalNotebookChangeCurrentPageLock.Unlock()

	signalNotebookChangeCurrentPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_change_current_page(instance, C.gpointer(uintptr(signalNotebookChangeCurrentPageId)))

	detail := signalNotebookChangeCurrentPageDetail{callback, handlerID}
	signalNotebookChangeCurrentPageMap[signalNotebookChangeCurrentPageId] = detail

	return signalNotebookChangeCurrentPageId
}

/*
DisconnectChangeCurrentPage disconnects a callback from the 'change-current-page' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectChangeCurrentPage.
*/
func (recv *Notebook) DisconnectChangeCurrentPage(connectionID int) {
	signalNotebookChangeCurrentPageLock.Lock()
	defer signalNotebookChangeCurrentPageLock.Unlock()

	detail, exists := signalNotebookChangeCurrentPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookChangeCurrentPageMap, connectionID)
}

//export notebook_changeCurrentPageHandler
func notebook_changeCurrentPageHandler(_ *C.GObject, c_object C.gint, data C.gpointer) C.gboolean {
	signalNotebookChangeCurrentPageLock.RLock()
	defer signalNotebookChangeCurrentPageLock.RUnlock()

	object := int32(c_object)

	index := int(uintptr(data))
	callback := signalNotebookChangeCurrentPageMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalNotebookFocusTabDetail struct {
	callback  NotebookSignalFocusTabCallback
	handlerID C.gulong
}

var signalNotebookFocusTabId int
var signalNotebookFocusTabMap = make(map[int]signalNotebookFocusTabDetail)
var signalNotebookFocusTabLock sync.RWMutex

// NotebookSignalFocusTabCallback is a callback function for a 'focus-tab' signal emitted from a Notebook.
type NotebookSignalFocusTabCallback func(object NotebookTab) bool

/*
ConnectFocusTab connects the callback to the 'focus-tab' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectFocusTab to remove it.
*/
func (recv *Notebook) ConnectFocusTab(callback NotebookSignalFocusTabCallback) int {
	signalNotebookFocusTabLock.Lock()
	defer signalNotebookFocusTabLock.Unlock()

	signalNotebookFocusTabId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_focus_tab(instance, C.gpointer(uintptr(signalNotebookFocusTabId)))

	detail := signalNotebookFocusTabDetail{callback, handlerID}
	signalNotebookFocusTabMap[signalNotebookFocusTabId] = detail

	return signalNotebookFocusTabId
}

/*
DisconnectFocusTab disconnects a callback from the 'focus-tab' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectFocusTab.
*/
func (recv *Notebook) DisconnectFocusTab(connectionID int) {
	signalNotebookFocusTabLock.Lock()
	defer signalNotebookFocusTabLock.Unlock()

	detail, exists := signalNotebookFocusTabMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookFocusTabMap, connectionID)
}

//export notebook_focusTabHandler
func notebook_focusTabHandler(_ *C.GObject, c_object C.GtkNotebookTab, data C.gpointer) C.gboolean {
	signalNotebookFocusTabLock.RLock()
	defer signalNotebookFocusTabLock.RUnlock()

	object := NotebookTab(c_object)

	index := int(uintptr(data))
	callback := signalNotebookFocusTabMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalNotebookMoveFocusOutDetail struct {
	callback  NotebookSignalMoveFocusOutCallback
	handlerID C.gulong
}

var signalNotebookMoveFocusOutId int
var signalNotebookMoveFocusOutMap = make(map[int]signalNotebookMoveFocusOutDetail)
var signalNotebookMoveFocusOutLock sync.RWMutex

// NotebookSignalMoveFocusOutCallback is a callback function for a 'move-focus-out' signal emitted from a Notebook.
type NotebookSignalMoveFocusOutCallback func(object DirectionType)

/*
ConnectMoveFocusOut connects the callback to the 'move-focus-out' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectMoveFocusOut to remove it.
*/
func (recv *Notebook) ConnectMoveFocusOut(callback NotebookSignalMoveFocusOutCallback) int {
	signalNotebookMoveFocusOutLock.Lock()
	defer signalNotebookMoveFocusOutLock.Unlock()

	signalNotebookMoveFocusOutId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_move_focus_out(instance, C.gpointer(uintptr(signalNotebookMoveFocusOutId)))

	detail := signalNotebookMoveFocusOutDetail{callback, handlerID}
	signalNotebookMoveFocusOutMap[signalNotebookMoveFocusOutId] = detail

	return signalNotebookMoveFocusOutId
}

/*
DisconnectMoveFocusOut disconnects a callback from the 'move-focus-out' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectMoveFocusOut.
*/
func (recv *Notebook) DisconnectMoveFocusOut(connectionID int) {
	signalNotebookMoveFocusOutLock.Lock()
	defer signalNotebookMoveFocusOutLock.Unlock()

	detail, exists := signalNotebookMoveFocusOutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookMoveFocusOutMap, connectionID)
}

//export notebook_moveFocusOutHandler
func notebook_moveFocusOutHandler(_ *C.GObject, c_object C.GtkDirectionType, data C.gpointer) {
	signalNotebookMoveFocusOutLock.RLock()
	defer signalNotebookMoveFocusOutLock.RUnlock()

	object := DirectionType(c_object)

	index := int(uintptr(data))
	callback := signalNotebookMoveFocusOutMap[index].callback
	callback(object)
}

type signalNotebookReorderTabDetail struct {
	callback  NotebookSignalReorderTabCallback
	handlerID C.gulong
}

var signalNotebookReorderTabId int
var signalNotebookReorderTabMap = make(map[int]signalNotebookReorderTabDetail)
var signalNotebookReorderTabLock sync.RWMutex

// NotebookSignalReorderTabCallback is a callback function for a 'reorder-tab' signal emitted from a Notebook.
type NotebookSignalReorderTabCallback func(object DirectionType, p0 bool) bool

/*
ConnectReorderTab connects the callback to the 'reorder-tab' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectReorderTab to remove it.
*/
func (recv *Notebook) ConnectReorderTab(callback NotebookSignalReorderTabCallback) int {
	signalNotebookReorderTabLock.Lock()
	defer signalNotebookReorderTabLock.Unlock()

	signalNotebookReorderTabId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_reorder_tab(instance, C.gpointer(uintptr(signalNotebookReorderTabId)))

	detail := signalNotebookReorderTabDetail{callback, handlerID}
	signalNotebookReorderTabMap[signalNotebookReorderTabId] = detail

	return signalNotebookReorderTabId
}

/*
DisconnectReorderTab disconnects a callback from the 'reorder-tab' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectReorderTab.
*/
func (recv *Notebook) DisconnectReorderTab(connectionID int) {
	signalNotebookReorderTabLock.Lock()
	defer signalNotebookReorderTabLock.Unlock()

	detail, exists := signalNotebookReorderTabMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookReorderTabMap, connectionID)
}

//export notebook_reorderTabHandler
func notebook_reorderTabHandler(_ *C.GObject, c_object C.GtkDirectionType, c_p0 C.gboolean, data C.gpointer) C.gboolean {
	signalNotebookReorderTabLock.RLock()
	defer signalNotebookReorderTabLock.RUnlock()

	object := DirectionType(c_object)

	p0 := c_p0 == C.TRUE

	index := int(uintptr(data))
	callback := signalNotebookReorderTabMap[index].callback
	retGo := callback(object, p0)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalNotebookSelectPageDetail struct {
	callback  NotebookSignalSelectPageCallback
	handlerID C.gulong
}

var signalNotebookSelectPageId int
var signalNotebookSelectPageMap = make(map[int]signalNotebookSelectPageDetail)
var signalNotebookSelectPageLock sync.RWMutex

// NotebookSignalSelectPageCallback is a callback function for a 'select-page' signal emitted from a Notebook.
type NotebookSignalSelectPageCallback func(object bool) bool

/*
ConnectSelectPage connects the callback to the 'select-page' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectSelectPage to remove it.
*/
func (recv *Notebook) ConnectSelectPage(callback NotebookSignalSelectPageCallback) int {
	signalNotebookSelectPageLock.Lock()
	defer signalNotebookSelectPageLock.Unlock()

	signalNotebookSelectPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_select_page(instance, C.gpointer(uintptr(signalNotebookSelectPageId)))

	detail := signalNotebookSelectPageDetail{callback, handlerID}
	signalNotebookSelectPageMap[signalNotebookSelectPageId] = detail

	return signalNotebookSelectPageId
}

/*
DisconnectSelectPage disconnects a callback from the 'select-page' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectSelectPage.
*/
func (recv *Notebook) DisconnectSelectPage(connectionID int) {
	signalNotebookSelectPageLock.Lock()
	defer signalNotebookSelectPageLock.Unlock()

	detail, exists := signalNotebookSelectPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookSelectPageMap, connectionID)
}

//export notebook_selectPageHandler
func notebook_selectPageHandler(_ *C.GObject, c_object C.gboolean, data C.gpointer) C.gboolean {
	signalNotebookSelectPageLock.RLock()
	defer signalNotebookSelectPageLock.RUnlock()

	object := c_object == C.TRUE

	index := int(uintptr(data))
	callback := signalNotebookSelectPageMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalNotebookSwitchPageDetail struct {
	callback  NotebookSignalSwitchPageCallback
	handlerID C.gulong
}

var signalNotebookSwitchPageId int
var signalNotebookSwitchPageMap = make(map[int]signalNotebookSwitchPageDetail)
var signalNotebookSwitchPageLock sync.RWMutex

// NotebookSignalSwitchPageCallback is a callback function for a 'switch-page' signal emitted from a Notebook.
type NotebookSignalSwitchPageCallback func(page *Widget, pageNum uint32)

/*
ConnectSwitchPage connects the callback to the 'switch-page' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectSwitchPage to remove it.
*/
func (recv *Notebook) ConnectSwitchPage(callback NotebookSignalSwitchPageCallback) int {
	signalNotebookSwitchPageLock.Lock()
	defer signalNotebookSwitchPageLock.Unlock()

	signalNotebookSwitchPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_switch_page(instance, C.gpointer(uintptr(signalNotebookSwitchPageId)))

	detail := signalNotebookSwitchPageDetail{callback, handlerID}
	signalNotebookSwitchPageMap[signalNotebookSwitchPageId] = detail

	return signalNotebookSwitchPageId
}

/*
DisconnectSwitchPage disconnects a callback from the 'switch-page' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectSwitchPage.
*/
func (recv *Notebook) DisconnectSwitchPage(connectionID int) {
	signalNotebookSwitchPageLock.Lock()
	defer signalNotebookSwitchPageLock.Unlock()

	detail, exists := signalNotebookSwitchPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookSwitchPageMap, connectionID)
}

//export notebook_switchPageHandler
func notebook_switchPageHandler(_ *C.GObject, c_page *C.GtkWidget, c_page_num C.guint, data C.gpointer) {
	signalNotebookSwitchPageLock.RLock()
	defer signalNotebookSwitchPageLock.RUnlock()

	page := WidgetNewFromC(unsafe.Pointer(c_page))

	pageNum := uint32(c_page_num)

	index := int(uintptr(data))
	callback := signalNotebookSwitchPageMap[index].callback
	callback(page, pageNum)
}

// Blacklisted : gtk_notebook_new

// Blacklisted : gtk_notebook_append_page

// Blacklisted : gtk_notebook_append_page_menu

// Blacklisted : gtk_notebook_get_current_page

// Blacklisted : gtk_notebook_get_menu_label

// Blacklisted : gtk_notebook_get_menu_label_text

// Blacklisted : gtk_notebook_get_nth_page

// Blacklisted : gtk_notebook_get_scrollable

// Blacklisted : gtk_notebook_get_show_border

// Blacklisted : gtk_notebook_get_show_tabs

// Blacklisted : gtk_notebook_get_tab_label

// Blacklisted : gtk_notebook_get_tab_label_text

// Blacklisted : gtk_notebook_get_tab_pos

// Blacklisted : gtk_notebook_insert_page

// Blacklisted : gtk_notebook_insert_page_menu

// Blacklisted : gtk_notebook_next_page

// Blacklisted : gtk_notebook_page_num

// Blacklisted : gtk_notebook_popup_disable

// Blacklisted : gtk_notebook_popup_enable

// Blacklisted : gtk_notebook_prepend_page

// Blacklisted : gtk_notebook_prepend_page_menu

// Blacklisted : gtk_notebook_prev_page

// Blacklisted : gtk_notebook_remove_page

// Blacklisted : gtk_notebook_reorder_child

// Blacklisted : gtk_notebook_set_current_page

// Blacklisted : gtk_notebook_set_menu_label

// Blacklisted : gtk_notebook_set_menu_label_text

// Blacklisted : gtk_notebook_set_scrollable

// Blacklisted : gtk_notebook_set_show_border

// Blacklisted : gtk_notebook_set_show_tabs

// Blacklisted : gtk_notebook_set_tab_label

// Blacklisted : gtk_notebook_set_tab_label_text

// Blacklisted : gtk_notebook_set_tab_pos

// ImplementorIface returns the ImplementorIface interface implemented by Notebook
func (recv *Notebook) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Notebook
func (recv *Notebook) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// NotebookAccessible is a wrapper around the C record GtkNotebookAccessible.
type NotebookAccessible struct {
	native *C.GtkNotebookAccessible
	// parent : record
	// priv : record
}

func NotebookAccessibleNewFromC(u unsafe.Pointer) *NotebookAccessible {
	c := (*C.GtkNotebookAccessible)(u)
	if c == nil {
		return nil
	}

	g := &NotebookAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NotebookAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NotebookAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookAccessible with another NotebookAccessible, and returns true if they represent the same GObject.
func (recv *NotebookAccessible) Equals(other *NotebookAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *NotebookAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *NotebookAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *NotebookAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *NotebookAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to NotebookAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a NotebookAccessible.
func CastToNotebookAccessible(object *gobject.Object) *NotebookAccessible {
	return NotebookAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by NotebookAccessible
func (recv *NotebookAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by NotebookAccessible
func (recv *NotebookAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// NotebookPageAccessible is a wrapper around the C record GtkNotebookPageAccessible.
type NotebookPageAccessible struct {
	native *C.GtkNotebookPageAccessible
	// parent : record
	// priv : record
}

func NotebookPageAccessibleNewFromC(u unsafe.Pointer) *NotebookPageAccessible {
	c := (*C.GtkNotebookPageAccessible)(u)
	if c == nil {
		return nil
	}

	g := &NotebookPageAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NotebookPageAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NotebookPageAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookPageAccessible with another NotebookPageAccessible, and returns true if they represent the same GObject.
func (recv *NotebookPageAccessible) Equals(other *NotebookPageAccessible) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *NotebookPageAccessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to NotebookPageAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a NotebookPageAccessible.
func CastToNotebookPageAccessible(object *gobject.Object) *NotebookPageAccessible {
	return NotebookPageAccessibleNewFromC(object.ToC())
}

// Blacklisted : gtk_notebook_page_accessible_new

// Blacklisted : gtk_notebook_page_accessible_invalidate

// Component returns the Component interface implemented by NotebookPageAccessible
func (recv *NotebookPageAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// NumerableIcon is a wrapper around the C record GtkNumerableIcon.
type NumerableIcon struct {
	native *C.GtkNumerableIcon
	// parent : record
	// Private : priv
}

func NumerableIconNewFromC(u unsafe.Pointer) *NumerableIcon {
	c := (*C.GtkNumerableIcon)(u)
	if c == nil {
		return nil
	}

	g := &NumerableIcon{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NumerableIcon) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NumerableIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NumerableIcon with another NumerableIcon, and returns true if they represent the same GObject.
func (recv *NumerableIcon) Equals(other *NumerableIcon) bool {
	return other.ToC() == recv.ToC()
}

// EmblemedIcon upcasts to *EmblemedIcon
func (recv *NumerableIcon) EmblemedIcon() *gio.EmblemedIcon {
	return gio.EmblemedIconNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *NumerableIcon) Object() *gobject.Object {
	return recv.EmblemedIcon().Object()
}

// CastToWidget down casts any arbitrary Object to NumerableIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a NumerableIcon.
func CastToNumerableIcon(object *gobject.Object) *NumerableIcon {
	return NumerableIconNewFromC(object.ToC())
}

// Icon returns the Icon interface implemented by NumerableIcon
func (recv *NumerableIcon) Icon() *gio.Icon {
	return gio.IconNewFromC(recv.ToC())
}

// OffscreenWindow is a wrapper around the C record GtkOffscreenWindow.
type OffscreenWindow struct {
	native *C.GtkOffscreenWindow
	// parent_object : record
}

func OffscreenWindowNewFromC(u unsafe.Pointer) *OffscreenWindow {
	c := (*C.GtkOffscreenWindow)(u)
	if c == nil {
		return nil
	}

	g := &OffscreenWindow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *OffscreenWindow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *OffscreenWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OffscreenWindow with another OffscreenWindow, and returns true if they represent the same GObject.
func (recv *OffscreenWindow) Equals(other *OffscreenWindow) bool {
	return other.ToC() == recv.ToC()
}

// Window upcasts to *Window
func (recv *OffscreenWindow) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *OffscreenWindow) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *OffscreenWindow) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *OffscreenWindow) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *OffscreenWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *OffscreenWindow) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitrary Object to OffscreenWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a OffscreenWindow.
func CastToOffscreenWindow(object *gobject.Object) *OffscreenWindow {
	return OffscreenWindowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by OffscreenWindow
func (recv *OffscreenWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by OffscreenWindow
func (recv *OffscreenWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Overlay is a wrapper around the C record GtkOverlay.
type Overlay struct {
	native *C.GtkOverlay
	// parent : record
	// priv : record
}

func OverlayNewFromC(u unsafe.Pointer) *Overlay {
	c := (*C.GtkOverlay)(u)
	if c == nil {
		return nil
	}

	g := &Overlay{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Overlay) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Overlay) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Overlay with another Overlay, and returns true if they represent the same GObject.
func (recv *Overlay) Equals(other *Overlay) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Overlay) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Overlay) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Overlay) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Overlay) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Overlay) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Overlay.
// Exercise care, as this is a potentially dangerous function if the Object is not a Overlay.
func CastToOverlay(object *gobject.Object) *Overlay {
	return OverlayNewFromC(object.ToC())
}

// Unsupported signal 'get-child-position' for Overlay : unsupported parameter allocation : direction is 'out'

// ImplementorIface returns the ImplementorIface interface implemented by Overlay
func (recv *Overlay) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Overlay
func (recv *Overlay) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PageSetup is a wrapper around the C record GtkPageSetup.
type PageSetup struct {
	native *C.GtkPageSetup
}

func PageSetupNewFromC(u unsafe.Pointer) *PageSetup {
	c := (*C.GtkPageSetup)(u)
	if c == nil {
		return nil
	}

	g := &PageSetup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PageSetup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PageSetup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PageSetup with another PageSetup, and returns true if they represent the same GObject.
func (recv *PageSetup) Equals(other *PageSetup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *PageSetup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to PageSetup.
// Exercise care, as this is a potentially dangerous function if the Object is not a PageSetup.
func CastToPageSetup(object *gobject.Object) *PageSetup {
	return PageSetupNewFromC(object.ToC())
}

// Paned is a wrapper around the C record GtkPaned.
type Paned struct {
	native *C.GtkPaned
	// container : record
	// Private : priv
}

func PanedNewFromC(u unsafe.Pointer) *Paned {
	c := (*C.GtkPaned)(u)
	if c == nil {
		return nil
	}

	g := &Paned{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Paned) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Paned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Paned with another Paned, and returns true if they represent the same GObject.
func (recv *Paned) Equals(other *Paned) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Paned) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Paned) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Paned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Paned) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Paned.
// Exercise care, as this is a potentially dangerous function if the Object is not a Paned.
func CastToPaned(object *gobject.Object) *Paned {
	return PanedNewFromC(object.ToC())
}

// Blacklisted : gtk_paned_add1

// Blacklisted : gtk_paned_add2

// Blacklisted : gtk_paned_get_position

// Blacklisted : gtk_paned_pack1

// Blacklisted : gtk_paned_pack2

// Blacklisted : gtk_paned_set_position

// ImplementorIface returns the ImplementorIface interface implemented by Paned
func (recv *Paned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Paned
func (recv *Paned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Paned
func (recv *Paned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// PanedAccessible is a wrapper around the C record GtkPanedAccessible.
type PanedAccessible struct {
	native *C.GtkPanedAccessible
	// parent : record
	// priv : record
}

func PanedAccessibleNewFromC(u unsafe.Pointer) *PanedAccessible {
	c := (*C.GtkPanedAccessible)(u)
	if c == nil {
		return nil
	}

	g := &PanedAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PanedAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PanedAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PanedAccessible with another PanedAccessible, and returns true if they represent the same GObject.
func (recv *PanedAccessible) Equals(other *PanedAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *PanedAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *PanedAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *PanedAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *PanedAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to PanedAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a PanedAccessible.
func CastToPanedAccessible(object *gobject.Object) *PanedAccessible {
	return PanedAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by PanedAccessible
func (recv *PanedAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by PanedAccessible
func (recv *PanedAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// PlacesSidebar is a wrapper around the C record GtkPlacesSidebar.
type PlacesSidebar struct {
	native *C.GtkPlacesSidebar
}

func PlacesSidebarNewFromC(u unsafe.Pointer) *PlacesSidebar {
	c := (*C.GtkPlacesSidebar)(u)
	if c == nil {
		return nil
	}

	g := &PlacesSidebar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PlacesSidebar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PlacesSidebar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PlacesSidebar with another PlacesSidebar, and returns true if they represent the same GObject.
func (recv *PlacesSidebar) Equals(other *PlacesSidebar) bool {
	return other.ToC() == recv.ToC()
}

// ScrolledWindow upcasts to *ScrolledWindow
func (recv *PlacesSidebar) ScrolledWindow() *ScrolledWindow {
	return ScrolledWindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *PlacesSidebar) Bin() *Bin {
	return recv.ScrolledWindow().Bin()
}

// Container upcasts to *Container
func (recv *PlacesSidebar) Container() *Container {
	return recv.ScrolledWindow().Container()
}

// Widget upcasts to *Widget
func (recv *PlacesSidebar) Widget() *Widget {
	return recv.ScrolledWindow().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *PlacesSidebar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ScrolledWindow().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *PlacesSidebar) Object() *gobject.Object {
	return recv.ScrolledWindow().Object()
}

// CastToWidget down casts any arbitrary Object to PlacesSidebar.
// Exercise care, as this is a potentially dangerous function if the Object is not a PlacesSidebar.
func CastToPlacesSidebar(object *gobject.Object) *PlacesSidebar {
	return PlacesSidebarNewFromC(object.ToC())
}

type signalPlacesSidebarShowConnectToServerDetail struct {
	callback  PlacesSidebarSignalShowConnectToServerCallback
	handlerID C.gulong
}

var signalPlacesSidebarShowConnectToServerId int
var signalPlacesSidebarShowConnectToServerMap = make(map[int]signalPlacesSidebarShowConnectToServerDetail)
var signalPlacesSidebarShowConnectToServerLock sync.RWMutex

// PlacesSidebarSignalShowConnectToServerCallback is a callback function for a 'show-connect-to-server' signal emitted from a PlacesSidebar.
type PlacesSidebarSignalShowConnectToServerCallback func()

/*
ConnectShowConnectToServer connects the callback to the 'show-connect-to-server' signal for the PlacesSidebar.

The returned value represents the connection, and may be passed to DisconnectShowConnectToServer to remove it.
*/
func (recv *PlacesSidebar) ConnectShowConnectToServer(callback PlacesSidebarSignalShowConnectToServerCallback) int {
	signalPlacesSidebarShowConnectToServerLock.Lock()
	defer signalPlacesSidebarShowConnectToServerLock.Unlock()

	signalPlacesSidebarShowConnectToServerId++
	instance := C.gpointer(recv.native)
	handlerID := C.PlacesSidebar_signal_connect_show_connect_to_server(instance, C.gpointer(uintptr(signalPlacesSidebarShowConnectToServerId)))

	detail := signalPlacesSidebarShowConnectToServerDetail{callback, handlerID}
	signalPlacesSidebarShowConnectToServerMap[signalPlacesSidebarShowConnectToServerId] = detail

	return signalPlacesSidebarShowConnectToServerId
}

/*
DisconnectShowConnectToServer disconnects a callback from the 'show-connect-to-server' signal for the PlacesSidebar.

The connectionID should be a value returned from a call to ConnectShowConnectToServer.
*/
func (recv *PlacesSidebar) DisconnectShowConnectToServer(connectionID int) {
	signalPlacesSidebarShowConnectToServerLock.Lock()
	defer signalPlacesSidebarShowConnectToServerLock.Unlock()

	detail, exists := signalPlacesSidebarShowConnectToServerMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPlacesSidebarShowConnectToServerMap, connectionID)
}

//export placessidebar_showConnectToServerHandler
func placessidebar_showConnectToServerHandler(_ *C.GObject, data C.gpointer) {
	signalPlacesSidebarShowConnectToServerLock.RLock()
	defer signalPlacesSidebarShowConnectToServerLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPlacesSidebarShowConnectToServerMap[index].callback
	callback()
}

// Blacklisted : gtk_places_sidebar_get_show_connect_to_server

// ImplementorIface returns the ImplementorIface interface implemented by PlacesSidebar
func (recv *PlacesSidebar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by PlacesSidebar
func (recv *PlacesSidebar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkPlug

// Popover is a wrapper around the C record GtkPopover.
type Popover struct {
	native *C.GtkPopover
	// parent_instance : record
	// Private : priv
}

func PopoverNewFromC(u unsafe.Pointer) *Popover {
	c := (*C.GtkPopover)(u)
	if c == nil {
		return nil
	}

	g := &Popover{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Popover) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Popover) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Popover with another Popover, and returns true if they represent the same GObject.
func (recv *Popover) Equals(other *Popover) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Popover) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Popover) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Popover) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Popover) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Popover) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Popover.
// Exercise care, as this is a potentially dangerous function if the Object is not a Popover.
func CastToPopover(object *gobject.Object) *Popover {
	return PopoverNewFromC(object.ToC())
}

type signalPopoverClosedDetail struct {
	callback  PopoverSignalClosedCallback
	handlerID C.gulong
}

var signalPopoverClosedId int
var signalPopoverClosedMap = make(map[int]signalPopoverClosedDetail)
var signalPopoverClosedLock sync.RWMutex

// PopoverSignalClosedCallback is a callback function for a 'closed' signal emitted from a Popover.
type PopoverSignalClosedCallback func()

/*
ConnectClosed connects the callback to the 'closed' signal for the Popover.

The returned value represents the connection, and may be passed to DisconnectClosed to remove it.
*/
func (recv *Popover) ConnectClosed(callback PopoverSignalClosedCallback) int {
	signalPopoverClosedLock.Lock()
	defer signalPopoverClosedLock.Unlock()

	signalPopoverClosedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Popover_signal_connect_closed(instance, C.gpointer(uintptr(signalPopoverClosedId)))

	detail := signalPopoverClosedDetail{callback, handlerID}
	signalPopoverClosedMap[signalPopoverClosedId] = detail

	return signalPopoverClosedId
}

/*
DisconnectClosed disconnects a callback from the 'closed' signal for the Popover.

The connectionID should be a value returned from a call to ConnectClosed.
*/
func (recv *Popover) DisconnectClosed(connectionID int) {
	signalPopoverClosedLock.Lock()
	defer signalPopoverClosedLock.Unlock()

	detail, exists := signalPopoverClosedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPopoverClosedMap, connectionID)
}

//export popover_closedHandler
func popover_closedHandler(_ *C.GObject, data C.gpointer) {
	signalPopoverClosedLock.RLock()
	defer signalPopoverClosedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPopoverClosedMap[index].callback
	callback()
}

// Blacklisted : gtk_popover_get_pointing_to

// Blacklisted : gtk_popover_get_position

// ImplementorIface returns the ImplementorIface interface implemented by Popover
func (recv *Popover) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Popover
func (recv *Popover) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PopoverAccessible is a wrapper around the C record GtkPopoverAccessible.
type PopoverAccessible struct {
	native *C.GtkPopoverAccessible
	// parent : record
}

func PopoverAccessibleNewFromC(u unsafe.Pointer) *PopoverAccessible {
	c := (*C.GtkPopoverAccessible)(u)
	if c == nil {
		return nil
	}

	g := &PopoverAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PopoverAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PopoverAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PopoverAccessible with another PopoverAccessible, and returns true if they represent the same GObject.
func (recv *PopoverAccessible) Equals(other *PopoverAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *PopoverAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *PopoverAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *PopoverAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *PopoverAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to PopoverAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a PopoverAccessible.
func CastToPopoverAccessible(object *gobject.Object) *PopoverAccessible {
	return PopoverAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by PopoverAccessible
func (recv *PopoverAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// PopoverMenu is a wrapper around the C record GtkPopoverMenu.
type PopoverMenu struct {
	native *C.GtkPopoverMenu
}

func PopoverMenuNewFromC(u unsafe.Pointer) *PopoverMenu {
	c := (*C.GtkPopoverMenu)(u)
	if c == nil {
		return nil
	}

	g := &PopoverMenu{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PopoverMenu) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PopoverMenu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PopoverMenu with another PopoverMenu, and returns true if they represent the same GObject.
func (recv *PopoverMenu) Equals(other *PopoverMenu) bool {
	return other.ToC() == recv.ToC()
}

// Popover upcasts to *Popover
func (recv *PopoverMenu) Popover() *Popover {
	return PopoverNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *PopoverMenu) Bin() *Bin {
	return recv.Popover().Bin()
}

// Container upcasts to *Container
func (recv *PopoverMenu) Container() *Container {
	return recv.Popover().Container()
}

// Widget upcasts to *Widget
func (recv *PopoverMenu) Widget() *Widget {
	return recv.Popover().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *PopoverMenu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Popover().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *PopoverMenu) Object() *gobject.Object {
	return recv.Popover().Object()
}

// CastToWidget down casts any arbitrary Object to PopoverMenu.
// Exercise care, as this is a potentially dangerous function if the Object is not a PopoverMenu.
func CastToPopoverMenu(object *gobject.Object) *PopoverMenu {
	return PopoverMenuNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by PopoverMenu
func (recv *PopoverMenu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by PopoverMenu
func (recv *PopoverMenu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PrintContext is a wrapper around the C record GtkPrintContext.
type PrintContext struct {
	native *C.GtkPrintContext
}

func PrintContextNewFromC(u unsafe.Pointer) *PrintContext {
	c := (*C.GtkPrintContext)(u)
	if c == nil {
		return nil
	}

	g := &PrintContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PrintContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PrintContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintContext with another PrintContext, and returns true if they represent the same GObject.
func (recv *PrintContext) Equals(other *PrintContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *PrintContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to PrintContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintContext.
func CastToPrintContext(object *gobject.Object) *PrintContext {
	return PrintContextNewFromC(object.ToC())
}

// PrintOperation is a wrapper around the C record GtkPrintOperation.
type PrintOperation struct {
	native *C.GtkPrintOperation
	// parent_instance : record
	// Private : priv
}

func PrintOperationNewFromC(u unsafe.Pointer) *PrintOperation {
	c := (*C.GtkPrintOperation)(u)
	if c == nil {
		return nil
	}

	g := &PrintOperation{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PrintOperation) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PrintOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintOperation with another PrintOperation, and returns true if they represent the same GObject.
func (recv *PrintOperation) Equals(other *PrintOperation) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *PrintOperation) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to PrintOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintOperation.
func CastToPrintOperation(object *gobject.Object) *PrintOperation {
	return PrintOperationNewFromC(object.ToC())
}

// PrintOperationPreview returns the PrintOperationPreview interface implemented by PrintOperation
func (recv *PrintOperation) PrintOperationPreview() *PrintOperationPreview {
	return PrintOperationPreviewNewFromC(recv.ToC())
}

// PrintSettings is a wrapper around the C record GtkPrintSettings.
type PrintSettings struct {
	native *C.GtkPrintSettings
}

func PrintSettingsNewFromC(u unsafe.Pointer) *PrintSettings {
	c := (*C.GtkPrintSettings)(u)
	if c == nil {
		return nil
	}

	g := &PrintSettings{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PrintSettings) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PrintSettings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintSettings with another PrintSettings, and returns true if they represent the same GObject.
func (recv *PrintSettings) Equals(other *PrintSettings) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *PrintSettings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to PrintSettings.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintSettings.
func CastToPrintSettings(object *gobject.Object) *PrintSettings {
	return PrintSettingsNewFromC(object.ToC())
}

// ProgressBar is a wrapper around the C record GtkProgressBar.
type ProgressBar struct {
	native *C.GtkProgressBar
	// parent : record
	// Private : priv
}

func ProgressBarNewFromC(u unsafe.Pointer) *ProgressBar {
	c := (*C.GtkProgressBar)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ProgressBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ProgressBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProgressBar with another ProgressBar, and returns true if they represent the same GObject.
func (recv *ProgressBar) Equals(other *ProgressBar) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *ProgressBar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ProgressBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ProgressBar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to ProgressBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProgressBar.
func CastToProgressBar(object *gobject.Object) *ProgressBar {
	return ProgressBarNewFromC(object.ToC())
}

// Blacklisted : gtk_progress_bar_new

// Blacklisted : gtk_progress_bar_get_fraction

// Blacklisted : gtk_progress_bar_get_inverted

// Blacklisted : gtk_progress_bar_get_pulse_step

// GetText is a wrapper around the C function gtk_progress_bar_get_text.
func (recv *ProgressBar) GetText() string {
	retC := C.gtk_progress_bar_get_text((*C.GtkProgressBar)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Blacklisted : gtk_progress_bar_pulse

// Blacklisted : gtk_progress_bar_set_fraction

// Blacklisted : gtk_progress_bar_set_inverted

// Blacklisted : gtk_progress_bar_set_pulse_step

// SetText is a wrapper around the C function gtk_progress_bar_set_text.
func (recv *ProgressBar) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_progress_bar_set_text((*C.GtkProgressBar)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ProgressBar
func (recv *ProgressBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ProgressBar
func (recv *ProgressBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ProgressBar
func (recv *ProgressBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ProgressBarAccessible is a wrapper around the C record GtkProgressBarAccessible.
type ProgressBarAccessible struct {
	native *C.GtkProgressBarAccessible
	// parent : record
	// priv : record
}

func ProgressBarAccessibleNewFromC(u unsafe.Pointer) *ProgressBarAccessible {
	c := (*C.GtkProgressBarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBarAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ProgressBarAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ProgressBarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProgressBarAccessible with another ProgressBarAccessible, and returns true if they represent the same GObject.
func (recv *ProgressBarAccessible) Equals(other *ProgressBarAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ProgressBarAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ProgressBarAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ProgressBarAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ProgressBarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProgressBarAccessible.
func CastToProgressBarAccessible(object *gobject.Object) *ProgressBarAccessible {
	return ProgressBarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ProgressBarAccessible
func (recv *ProgressBarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ProgressBarAccessible
func (recv *ProgressBarAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// RadioAction is a wrapper around the C record GtkRadioAction.
type RadioAction struct {
	native *C.GtkRadioAction
	// parent : record
	// Private : private_data
}

func RadioActionNewFromC(u unsafe.Pointer) *RadioAction {
	c := (*C.GtkRadioAction)(u)
	if c == nil {
		return nil
	}

	g := &RadioAction{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioAction) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioAction with another RadioAction, and returns true if they represent the same GObject.
func (recv *RadioAction) Equals(other *RadioAction) bool {
	return other.ToC() == recv.ToC()
}

// ToggleAction upcasts to *ToggleAction
func (recv *RadioAction) ToggleAction() *ToggleAction {
	return ToggleActionNewFromC(unsafe.Pointer(recv.native))
}

// Action upcasts to *Action
func (recv *RadioAction) Action() *Action {
	return recv.ToggleAction().Action()
}

// Object upcasts to *Object
func (recv *RadioAction) Object() *gobject.Object {
	return recv.ToggleAction().Object()
}

// CastToWidget down casts any arbitrary Object to RadioAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioAction.
func CastToRadioAction(object *gobject.Object) *RadioAction {
	return RadioActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RadioAction
func (recv *RadioAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioButton is a wrapper around the C record GtkRadioButton.
type RadioButton struct {
	native *C.GtkRadioButton
	// check_button : record
	// Private : priv
}

func RadioButtonNewFromC(u unsafe.Pointer) *RadioButton {
	c := (*C.GtkRadioButton)(u)
	if c == nil {
		return nil
	}

	g := &RadioButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioButton with another RadioButton, and returns true if they represent the same GObject.
func (recv *RadioButton) Equals(other *RadioButton) bool {
	return other.ToC() == recv.ToC()
}

// CheckButton upcasts to *CheckButton
func (recv *RadioButton) CheckButton() *CheckButton {
	return CheckButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToggleButton upcasts to *ToggleButton
func (recv *RadioButton) ToggleButton() *ToggleButton {
	return recv.CheckButton().ToggleButton()
}

// Button upcasts to *Button
func (recv *RadioButton) Button() *Button {
	return recv.CheckButton().Button()
}

// Bin upcasts to *Bin
func (recv *RadioButton) Bin() *Bin {
	return recv.CheckButton().Bin()
}

// Container upcasts to *Container
func (recv *RadioButton) Container() *Container {
	return recv.CheckButton().Container()
}

// Widget upcasts to *Widget
func (recv *RadioButton) Widget() *Widget {
	return recv.CheckButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CheckButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioButton) Object() *gobject.Object {
	return recv.CheckButton().Object()
}

// CastToWidget down casts any arbitrary Object to RadioButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioButton.
func CastToRadioButton(object *gobject.Object) *RadioButton {
	return RadioButtonNewFromC(object.ToC())
}

// Blacklisted : gtk_radio_button_new

// Blacklisted : gtk_radio_button_new_from_widget

// Blacklisted : gtk_radio_button_new_with_label

// Blacklisted : gtk_radio_button_new_with_label_from_widget

// Blacklisted : gtk_radio_button_new_with_mnemonic

// Blacklisted : gtk_radio_button_new_with_mnemonic_from_widget

// Blacklisted : gtk_radio_button_get_group

// Blacklisted : gtk_radio_button_set_group

// ImplementorIface returns the ImplementorIface interface implemented by RadioButton
func (recv *RadioButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioButton
func (recv *RadioButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioButton
func (recv *RadioButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioButton
func (recv *RadioButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioButtonAccessible is a wrapper around the C record GtkRadioButtonAccessible.
type RadioButtonAccessible struct {
	native *C.GtkRadioButtonAccessible
	// parent : record
	// priv : record
}

func RadioButtonAccessibleNewFromC(u unsafe.Pointer) *RadioButtonAccessible {
	c := (*C.GtkRadioButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RadioButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioButtonAccessible with another RadioButtonAccessible, and returns true if they represent the same GObject.
func (recv *RadioButtonAccessible) Equals(other *RadioButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButtonAccessible upcasts to *ToggleButtonAccessible
func (recv *RadioButtonAccessible) ToggleButtonAccessible() *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *RadioButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return recv.ToggleButtonAccessible().ButtonAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *RadioButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ToggleButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RadioButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ToggleButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *RadioButtonAccessible) Accessible() *Accessible {
	return recv.ToggleButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RadioButtonAccessible) Object() *atk.Object {
	return recv.ToggleButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to RadioButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioButtonAccessible.
func CastToRadioButtonAccessible(object *gobject.Object) *RadioButtonAccessible {
	return RadioButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// RadioMenuItem is a wrapper around the C record GtkRadioMenuItem.
type RadioMenuItem struct {
	native *C.GtkRadioMenuItem
	// check_menu_item : record
	// Private : priv
}

func RadioMenuItemNewFromC(u unsafe.Pointer) *RadioMenuItem {
	c := (*C.GtkRadioMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioMenuItem with another RadioMenuItem, and returns true if they represent the same GObject.
func (recv *RadioMenuItem) Equals(other *RadioMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// CheckMenuItem upcasts to *CheckMenuItem
func (recv *RadioMenuItem) CheckMenuItem() *CheckMenuItem {
	return CheckMenuItemNewFromC(unsafe.Pointer(recv.native))
}

// MenuItem upcasts to *MenuItem
func (recv *RadioMenuItem) MenuItem() *MenuItem {
	return recv.CheckMenuItem().MenuItem()
}

// Bin upcasts to *Bin
func (recv *RadioMenuItem) Bin() *Bin {
	return recv.CheckMenuItem().Bin()
}

// Container upcasts to *Container
func (recv *RadioMenuItem) Container() *Container {
	return recv.CheckMenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *RadioMenuItem) Widget() *Widget {
	return recv.CheckMenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CheckMenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioMenuItem) Object() *gobject.Object {
	return recv.CheckMenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to RadioMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioMenuItem.
func CastToRadioMenuItem(object *gobject.Object) *RadioMenuItem {
	return RadioMenuItemNewFromC(object.ToC())
}

type signalRadioMenuItemGroupChangedDetail struct {
	callback  RadioMenuItemSignalGroupChangedCallback
	handlerID C.gulong
}

var signalRadioMenuItemGroupChangedId int
var signalRadioMenuItemGroupChangedMap = make(map[int]signalRadioMenuItemGroupChangedDetail)
var signalRadioMenuItemGroupChangedLock sync.RWMutex

// RadioMenuItemSignalGroupChangedCallback is a callback function for a 'group-changed' signal emitted from a RadioMenuItem.
type RadioMenuItemSignalGroupChangedCallback func()

/*
ConnectGroupChanged connects the callback to the 'group-changed' signal for the RadioMenuItem.

The returned value represents the connection, and may be passed to DisconnectGroupChanged to remove it.
*/
func (recv *RadioMenuItem) ConnectGroupChanged(callback RadioMenuItemSignalGroupChangedCallback) int {
	signalRadioMenuItemGroupChangedLock.Lock()
	defer signalRadioMenuItemGroupChangedLock.Unlock()

	signalRadioMenuItemGroupChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RadioMenuItem_signal_connect_group_changed(instance, C.gpointer(uintptr(signalRadioMenuItemGroupChangedId)))

	detail := signalRadioMenuItemGroupChangedDetail{callback, handlerID}
	signalRadioMenuItemGroupChangedMap[signalRadioMenuItemGroupChangedId] = detail

	return signalRadioMenuItemGroupChangedId
}

/*
DisconnectGroupChanged disconnects a callback from the 'group-changed' signal for the RadioMenuItem.

The connectionID should be a value returned from a call to ConnectGroupChanged.
*/
func (recv *RadioMenuItem) DisconnectGroupChanged(connectionID int) {
	signalRadioMenuItemGroupChangedLock.Lock()
	defer signalRadioMenuItemGroupChangedLock.Unlock()

	detail, exists := signalRadioMenuItemGroupChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRadioMenuItemGroupChangedMap, connectionID)
}

//export radiomenuitem_groupChangedHandler
func radiomenuitem_groupChangedHandler(_ *C.GObject, data C.gpointer) {
	signalRadioMenuItemGroupChangedLock.RLock()
	defer signalRadioMenuItemGroupChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalRadioMenuItemGroupChangedMap[index].callback
	callback()
}

// Blacklisted : gtk_radio_menu_item_new

// Blacklisted : gtk_radio_menu_item_new_with_label

// Blacklisted : gtk_radio_menu_item_new_with_mnemonic

// Blacklisted : gtk_radio_menu_item_get_group

// Blacklisted : gtk_radio_menu_item_set_group

// ImplementorIface returns the ImplementorIface interface implemented by RadioMenuItem
func (recv *RadioMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioMenuItemAccessible is a wrapper around the C record GtkRadioMenuItemAccessible.
type RadioMenuItemAccessible struct {
	native *C.GtkRadioMenuItemAccessible
	// parent : record
	// priv : record
}

func RadioMenuItemAccessibleNewFromC(u unsafe.Pointer) *RadioMenuItemAccessible {
	c := (*C.GtkRadioMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItemAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioMenuItemAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioMenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioMenuItemAccessible with another RadioMenuItemAccessible, and returns true if they represent the same GObject.
func (recv *RadioMenuItemAccessible) Equals(other *RadioMenuItemAccessible) bool {
	return other.ToC() == recv.ToC()
}

// CheckMenuItemAccessible upcasts to *CheckMenuItemAccessible
func (recv *RadioMenuItemAccessible) CheckMenuItemAccessible() *CheckMenuItemAccessible {
	return CheckMenuItemAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// MenuItemAccessible upcasts to *MenuItemAccessible
func (recv *RadioMenuItemAccessible) MenuItemAccessible() *MenuItemAccessible {
	return recv.CheckMenuItemAccessible().MenuItemAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *RadioMenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.CheckMenuItemAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RadioMenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.CheckMenuItemAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *RadioMenuItemAccessible) Accessible() *Accessible {
	return recv.CheckMenuItemAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RadioMenuItemAccessible) Object() *atk.Object {
	return recv.CheckMenuItemAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to RadioMenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioMenuItemAccessible.
func CastToRadioMenuItemAccessible(object *gobject.Object) *RadioMenuItemAccessible {
	return RadioMenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// RadioToolButton is a wrapper around the C record GtkRadioToolButton.
type RadioToolButton struct {
	native *C.GtkRadioToolButton
	// parent : record
}

func RadioToolButtonNewFromC(u unsafe.Pointer) *RadioToolButton {
	c := (*C.GtkRadioToolButton)(u)
	if c == nil {
		return nil
	}

	g := &RadioToolButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioToolButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioToolButton with another RadioToolButton, and returns true if they represent the same GObject.
func (recv *RadioToolButton) Equals(other *RadioToolButton) bool {
	return other.ToC() == recv.ToC()
}

// ToggleToolButton upcasts to *ToggleToolButton
func (recv *RadioToolButton) ToggleToolButton() *ToggleToolButton {
	return ToggleToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolButton upcasts to *ToolButton
func (recv *RadioToolButton) ToolButton() *ToolButton {
	return recv.ToggleToolButton().ToolButton()
}

// ToolItem upcasts to *ToolItem
func (recv *RadioToolButton) ToolItem() *ToolItem {
	return recv.ToggleToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *RadioToolButton) Bin() *Bin {
	return recv.ToggleToolButton().Bin()
}

// Container upcasts to *Container
func (recv *RadioToolButton) Container() *Container {
	return recv.ToggleToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *RadioToolButton) Widget() *Widget {
	return recv.ToggleToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioToolButton) Object() *gobject.Object {
	return recv.ToggleToolButton().Object()
}

// CastToWidget down casts any arbitrary Object to RadioToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioToolButton.
func CastToRadioToolButton(object *gobject.Object) *RadioToolButton {
	return RadioToolButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioToolButton
func (recv *RadioToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioToolButton
func (recv *RadioToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioToolButton
func (recv *RadioToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioToolButton
func (recv *RadioToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Range is a wrapper around the C record GtkRange.
type Range struct {
	native *C.GtkRange
	// widget : record
	// priv : record
}

func RangeNewFromC(u unsafe.Pointer) *Range {
	c := (*C.GtkRange)(u)
	if c == nil {
		return nil
	}

	g := &Range{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Range) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Range) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Range with another Range, and returns true if they represent the same GObject.
func (recv *Range) Equals(other *Range) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Range) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Range) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Range) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Range.
// Exercise care, as this is a potentially dangerous function if the Object is not a Range.
func CastToRange(object *gobject.Object) *Range {
	return RangeNewFromC(object.ToC())
}

type signalRangeAdjustBoundsDetail struct {
	callback  RangeSignalAdjustBoundsCallback
	handlerID C.gulong
}

var signalRangeAdjustBoundsId int
var signalRangeAdjustBoundsMap = make(map[int]signalRangeAdjustBoundsDetail)
var signalRangeAdjustBoundsLock sync.RWMutex

// RangeSignalAdjustBoundsCallback is a callback function for a 'adjust-bounds' signal emitted from a Range.
type RangeSignalAdjustBoundsCallback func(value float64)

/*
ConnectAdjustBounds connects the callback to the 'adjust-bounds' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectAdjustBounds to remove it.
*/
func (recv *Range) ConnectAdjustBounds(callback RangeSignalAdjustBoundsCallback) int {
	signalRangeAdjustBoundsLock.Lock()
	defer signalRangeAdjustBoundsLock.Unlock()

	signalRangeAdjustBoundsId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_adjust_bounds(instance, C.gpointer(uintptr(signalRangeAdjustBoundsId)))

	detail := signalRangeAdjustBoundsDetail{callback, handlerID}
	signalRangeAdjustBoundsMap[signalRangeAdjustBoundsId] = detail

	return signalRangeAdjustBoundsId
}

/*
DisconnectAdjustBounds disconnects a callback from the 'adjust-bounds' signal for the Range.

The connectionID should be a value returned from a call to ConnectAdjustBounds.
*/
func (recv *Range) DisconnectAdjustBounds(connectionID int) {
	signalRangeAdjustBoundsLock.Lock()
	defer signalRangeAdjustBoundsLock.Unlock()

	detail, exists := signalRangeAdjustBoundsMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeAdjustBoundsMap, connectionID)
}

//export range_adjustBoundsHandler
func range_adjustBoundsHandler(_ *C.GObject, c_value C.gdouble, data C.gpointer) {
	signalRangeAdjustBoundsLock.RLock()
	defer signalRangeAdjustBoundsLock.RUnlock()

	value := float64(c_value)

	index := int(uintptr(data))
	callback := signalRangeAdjustBoundsMap[index].callback
	callback(value)
}

type signalRangeMoveSliderDetail struct {
	callback  RangeSignalMoveSliderCallback
	handlerID C.gulong
}

var signalRangeMoveSliderId int
var signalRangeMoveSliderMap = make(map[int]signalRangeMoveSliderDetail)
var signalRangeMoveSliderLock sync.RWMutex

// RangeSignalMoveSliderCallback is a callback function for a 'move-slider' signal emitted from a Range.
type RangeSignalMoveSliderCallback func(step ScrollType)

/*
ConnectMoveSlider connects the callback to the 'move-slider' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectMoveSlider to remove it.
*/
func (recv *Range) ConnectMoveSlider(callback RangeSignalMoveSliderCallback) int {
	signalRangeMoveSliderLock.Lock()
	defer signalRangeMoveSliderLock.Unlock()

	signalRangeMoveSliderId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_move_slider(instance, C.gpointer(uintptr(signalRangeMoveSliderId)))

	detail := signalRangeMoveSliderDetail{callback, handlerID}
	signalRangeMoveSliderMap[signalRangeMoveSliderId] = detail

	return signalRangeMoveSliderId
}

/*
DisconnectMoveSlider disconnects a callback from the 'move-slider' signal for the Range.

The connectionID should be a value returned from a call to ConnectMoveSlider.
*/
func (recv *Range) DisconnectMoveSlider(connectionID int) {
	signalRangeMoveSliderLock.Lock()
	defer signalRangeMoveSliderLock.Unlock()

	detail, exists := signalRangeMoveSliderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeMoveSliderMap, connectionID)
}

//export range_moveSliderHandler
func range_moveSliderHandler(_ *C.GObject, c_step C.GtkScrollType, data C.gpointer) {
	signalRangeMoveSliderLock.RLock()
	defer signalRangeMoveSliderLock.RUnlock()

	step := ScrollType(c_step)

	index := int(uintptr(data))
	callback := signalRangeMoveSliderMap[index].callback
	callback(step)
}

type signalRangeValueChangedDetail struct {
	callback  RangeSignalValueChangedCallback
	handlerID C.gulong
}

var signalRangeValueChangedId int
var signalRangeValueChangedMap = make(map[int]signalRangeValueChangedDetail)
var signalRangeValueChangedLock sync.RWMutex

// RangeSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a Range.
type RangeSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *Range) ConnectValueChanged(callback RangeSignalValueChangedCallback) int {
	signalRangeValueChangedLock.Lock()
	defer signalRangeValueChangedLock.Unlock()

	signalRangeValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_value_changed(instance, C.gpointer(uintptr(signalRangeValueChangedId)))

	detail := signalRangeValueChangedDetail{callback, handlerID}
	signalRangeValueChangedMap[signalRangeValueChangedId] = detail

	return signalRangeValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the Range.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *Range) DisconnectValueChanged(connectionID int) {
	signalRangeValueChangedLock.Lock()
	defer signalRangeValueChangedLock.Unlock()

	detail, exists := signalRangeValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeValueChangedMap, connectionID)
}

//export range_valueChangedHandler
func range_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	signalRangeValueChangedLock.RLock()
	defer signalRangeValueChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalRangeValueChangedMap[index].callback
	callback()
}

// Blacklisted : gtk_range_get_adjustment

// Blacklisted : gtk_range_get_inverted

// Blacklisted : gtk_range_get_value

// Blacklisted : gtk_range_set_adjustment

// Blacklisted : gtk_range_set_increments

// Blacklisted : gtk_range_set_inverted

// Blacklisted : gtk_range_set_range

// Blacklisted : gtk_range_set_value

// ImplementorIface returns the ImplementorIface interface implemented by Range
func (recv *Range) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Range
func (recv *Range) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Range
func (recv *Range) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// RangeAccessible is a wrapper around the C record GtkRangeAccessible.
type RangeAccessible struct {
	native *C.GtkRangeAccessible
	// parent : record
	// priv : record
}

func RangeAccessibleNewFromC(u unsafe.Pointer) *RangeAccessible {
	c := (*C.GtkRangeAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RangeAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RangeAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RangeAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RangeAccessible with another RangeAccessible, and returns true if they represent the same GObject.
func (recv *RangeAccessible) Equals(other *RangeAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RangeAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *RangeAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RangeAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to RangeAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RangeAccessible.
func CastToRangeAccessible(object *gobject.Object) *RangeAccessible {
	return RangeAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by RangeAccessible
func (recv *RangeAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by RangeAccessible
func (recv *RangeAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// RcStyle is a wrapper around the C record GtkRcStyle.
type RcStyle struct {
	native *C.GtkRcStyle
	// parent_instance : record
	Name string
	// no type for bg_pixmap_name
	// font_desc : record
	// no type for color_flags
	// no type for fg
	// no type for bg
	// no type for text
	// no type for base
	Xthickness int32
	Ythickness int32
	// Private : rc_properties
	// Private : rc_style_lists
	// Private : icon_factories
	// Private : engine_specified
}

func RcStyleNewFromC(u unsafe.Pointer) *RcStyle {
	c := (*C.GtkRcStyle)(u)
	if c == nil {
		return nil
	}

	g := &RcStyle{
		Name:       C.GoString(c.name),
		Xthickness: (int32)(c.xthickness),
		Ythickness: (int32)(c.ythickness),
		native:     c,
	}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RcStyle) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RcStyle) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native.xthickness =
		(C.gint)(recv.Xthickness)
	recv.native.ythickness =
		(C.gint)(recv.Ythickness)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RcStyle with another RcStyle, and returns true if they represent the same GObject.
func (recv *RcStyle) Equals(other *RcStyle) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *RcStyle) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to RcStyle.
// Exercise care, as this is a potentially dangerous function if the Object is not a RcStyle.
func CastToRcStyle(object *gobject.Object) *RcStyle {
	return RcStyleNewFromC(object.ToC())
}

// Blacklisted : gtk_rc_style_new

// Blacklisted : gtk_rc_style_copy

// RecentAction is a wrapper around the C record GtkRecentAction.
type RecentAction struct {
	native *C.GtkRecentAction
	// parent_instance : record
	// Private : priv
}

func RecentActionNewFromC(u unsafe.Pointer) *RecentAction {
	c := (*C.GtkRecentAction)(u)
	if c == nil {
		return nil
	}

	g := &RecentAction{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentAction) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentAction with another RecentAction, and returns true if they represent the same GObject.
func (recv *RecentAction) Equals(other *RecentAction) bool {
	return other.ToC() == recv.ToC()
}

// Action upcasts to *Action
func (recv *RecentAction) Action() *Action {
	return ActionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *RecentAction) Object() *gobject.Object {
	return recv.Action().Object()
}

// CastToWidget down casts any arbitrary Object to RecentAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentAction.
func CastToRecentAction(object *gobject.Object) *RecentAction {
	return RecentActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RecentAction
func (recv *RecentAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentAction
func (recv *RecentAction) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserDialog is a wrapper around the C record GtkRecentChooserDialog.
type RecentChooserDialog struct {
	native *C.GtkRecentChooserDialog
	// parent_instance : record
	// Private : priv
}

func RecentChooserDialogNewFromC(u unsafe.Pointer) *RecentChooserDialog {
	c := (*C.GtkRecentChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserDialog with another RecentChooserDialog, and returns true if they represent the same GObject.
func (recv *RecentChooserDialog) Equals(other *RecentChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *RecentChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *RecentChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *RecentChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *RecentChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to RecentChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserDialog.
func CastToRecentChooserDialog(object *gobject.Object) *RecentChooserDialog {
	return RecentChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserMenu is a wrapper around the C record GtkRecentChooserMenu.
type RecentChooserMenu struct {
	native *C.GtkRecentChooserMenu
	// parent_instance : record
	// Private : priv
}

func RecentChooserMenuNewFromC(u unsafe.Pointer) *RecentChooserMenu {
	c := (*C.GtkRecentChooserMenu)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserMenu{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentChooserMenu) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentChooserMenu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserMenu with another RecentChooserMenu, and returns true if they represent the same GObject.
func (recv *RecentChooserMenu) Equals(other *RecentChooserMenu) bool {
	return other.ToC() == recv.ToC()
}

// Menu upcasts to *Menu
func (recv *RecentChooserMenu) Menu() *Menu {
	return MenuNewFromC(unsafe.Pointer(recv.native))
}

// MenuShell upcasts to *MenuShell
func (recv *RecentChooserMenu) MenuShell() *MenuShell {
	return recv.Menu().MenuShell()
}

// Container upcasts to *Container
func (recv *RecentChooserMenu) Container() *Container {
	return recv.Menu().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserMenu) Widget() *Widget {
	return recv.Menu().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserMenu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Menu().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserMenu) Object() *gobject.Object {
	return recv.Menu().Object()
}

// CastToWidget down casts any arbitrary Object to RecentChooserMenu.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserMenu.
func CastToRecentChooserMenu(object *gobject.Object) *RecentChooserMenu {
	return RecentChooserMenuNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserWidget is a wrapper around the C record GtkRecentChooserWidget.
type RecentChooserWidget struct {
	native *C.GtkRecentChooserWidget
	// parent_instance : record
	// Private : priv
}

func RecentChooserWidgetNewFromC(u unsafe.Pointer) *RecentChooserWidget {
	c := (*C.GtkRecentChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserWidget with another RecentChooserWidget, and returns true if they represent the same GObject.
func (recv *RecentChooserWidget) Equals(other *RecentChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *RecentChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *RecentChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to RecentChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserWidget.
func CastToRecentChooserWidget(object *gobject.Object) *RecentChooserWidget {
	return RecentChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentFilter is a wrapper around the C record GtkRecentFilter.
type RecentFilter struct {
	native *C.GtkRecentFilter
}

func RecentFilterNewFromC(u unsafe.Pointer) *RecentFilter {
	c := (*C.GtkRecentFilter)(u)
	if c == nil {
		return nil
	}

	g := &RecentFilter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentFilter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentFilter with another RecentFilter, and returns true if they represent the same GObject.
func (recv *RecentFilter) Equals(other *RecentFilter) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentFilter) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *RecentFilter) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to RecentFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentFilter.
func CastToRecentFilter(object *gobject.Object) *RecentFilter {
	return RecentFilterNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RecentFilter
func (recv *RecentFilter) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RendererCellAccessible is a wrapper around the C record GtkRendererCellAccessible.
type RendererCellAccessible struct {
	native *C.GtkRendererCellAccessible
	// parent : record
	// priv : record
}

func RendererCellAccessibleNewFromC(u unsafe.Pointer) *RendererCellAccessible {
	c := (*C.GtkRendererCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RendererCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RendererCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RendererCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RendererCellAccessible with another RendererCellAccessible, and returns true if they represent the same GObject.
func (recv *RendererCellAccessible) Equals(other *RendererCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// CellAccessible upcasts to *CellAccessible
func (recv *RendererCellAccessible) CellAccessible() *CellAccessible {
	return CellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *RendererCellAccessible) Accessible() *Accessible {
	return recv.CellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RendererCellAccessible) Object() *atk.Object {
	return recv.CellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to RendererCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RendererCellAccessible.
func CastToRendererCellAccessible(object *gobject.Object) *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(object.ToC())
}

// Blacklisted : gtk_renderer_cell_accessible_new

// Action returns the Action interface implemented by RendererCellAccessible
func (recv *RendererCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RendererCellAccessible
func (recv *RendererCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Revealer is a wrapper around the C record GtkRevealer.
type Revealer struct {
	native *C.GtkRevealer
	// parent_instance : record
}

func RevealerNewFromC(u unsafe.Pointer) *Revealer {
	c := (*C.GtkRevealer)(u)
	if c == nil {
		return nil
	}

	g := &Revealer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Revealer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Revealer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Revealer with another Revealer, and returns true if they represent the same GObject.
func (recv *Revealer) Equals(other *Revealer) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Revealer) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Revealer) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Revealer) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Revealer) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Revealer) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Revealer.
// Exercise care, as this is a potentially dangerous function if the Object is not a Revealer.
func CastToRevealer(object *gobject.Object) *Revealer {
	return RevealerNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Revealer
func (recv *Revealer) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Revealer
func (recv *Revealer) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scale is a wrapper around the C record GtkScale.
type Scale struct {
	native *C.GtkScale
	// range : record
	// Private : priv
}

func ScaleNewFromC(u unsafe.Pointer) *Scale {
	c := (*C.GtkScale)(u)
	if c == nil {
		return nil
	}

	g := &Scale{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Scale) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Scale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Scale with another Scale, and returns true if they represent the same GObject.
func (recv *Scale) Equals(other *Scale) bool {
	return other.ToC() == recv.ToC()
}

// Range upcasts to *Range
func (recv *Scale) Range() *Range {
	return RangeNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Scale) Widget() *Widget {
	return recv.Range().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Scale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Range().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Scale) Object() *gobject.Object {
	return recv.Range().Object()
}

// CastToWidget down casts any arbitrary Object to Scale.
// Exercise care, as this is a potentially dangerous function if the Object is not a Scale.
func CastToScale(object *gobject.Object) *Scale {
	return ScaleNewFromC(object.ToC())
}

// Unsupported signal 'format-value' for Scale : return value utf8 :

// Blacklisted : gtk_scale_get_digits

// Blacklisted : gtk_scale_get_draw_value

// Blacklisted : gtk_scale_get_value_pos

// Blacklisted : gtk_scale_set_digits

// Blacklisted : gtk_scale_set_draw_value

// Blacklisted : gtk_scale_set_value_pos

// ImplementorIface returns the ImplementorIface interface implemented by Scale
func (recv *Scale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Scale
func (recv *Scale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Scale
func (recv *Scale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScaleAccessible is a wrapper around the C record GtkScaleAccessible.
type ScaleAccessible struct {
	native *C.GtkScaleAccessible
	// parent : record
	// priv : record
}

func ScaleAccessibleNewFromC(u unsafe.Pointer) *ScaleAccessible {
	c := (*C.GtkScaleAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScaleAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScaleAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScaleAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleAccessible with another ScaleAccessible, and returns true if they represent the same GObject.
func (recv *ScaleAccessible) Equals(other *ScaleAccessible) bool {
	return other.ToC() == recv.ToC()
}

// RangeAccessible upcasts to *RangeAccessible
func (recv *ScaleAccessible) RangeAccessible() *RangeAccessible {
	return RangeAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScaleAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.RangeAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScaleAccessible) Accessible() *Accessible {
	return recv.RangeAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScaleAccessible) Object() *atk.Object {
	return recv.RangeAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ScaleAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleAccessible.
func CastToScaleAccessible(object *gobject.Object) *ScaleAccessible {
	return ScaleAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ScaleAccessible
func (recv *ScaleAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ScaleAccessible
func (recv *ScaleAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// ScaleButton is a wrapper around the C record GtkScaleButton.
type ScaleButton struct {
	native *C.GtkScaleButton
	// parent : record
	// Private : priv
}

func ScaleButtonNewFromC(u unsafe.Pointer) *ScaleButton {
	c := (*C.GtkScaleButton)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScaleButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScaleButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleButton with another ScaleButton, and returns true if they represent the same GObject.
func (recv *ScaleButton) Equals(other *ScaleButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *ScaleButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ScaleButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ScaleButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ScaleButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ScaleButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ScaleButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to ScaleButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleButton.
func CastToScaleButton(object *gobject.Object) *ScaleButton {
	return ScaleButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ScaleButton
func (recv *ScaleButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ScaleButton
func (recv *ScaleButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ScaleButton
func (recv *ScaleButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ScaleButton
func (recv *ScaleButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ScaleButton
func (recv *ScaleButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScaleButtonAccessible is a wrapper around the C record GtkScaleButtonAccessible.
type ScaleButtonAccessible struct {
	native *C.GtkScaleButtonAccessible
	// parent : record
	// priv : record
}

func ScaleButtonAccessibleNewFromC(u unsafe.Pointer) *ScaleButtonAccessible {
	c := (*C.GtkScaleButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScaleButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScaleButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleButtonAccessible with another ScaleButtonAccessible, and returns true if they represent the same GObject.
func (recv *ScaleButtonAccessible) Equals(other *ScaleButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *ScaleButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ScaleButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScaleButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScaleButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScaleButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ScaleButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleButtonAccessible.
func CastToScaleButtonAccessible(object *gobject.Object) *ScaleButtonAccessible {
	return ScaleButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// Scrollbar is a wrapper around the C record GtkScrollbar.
type Scrollbar struct {
	native *C.GtkScrollbar
	// range : record
}

func ScrollbarNewFromC(u unsafe.Pointer) *Scrollbar {
	c := (*C.GtkScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &Scrollbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Scrollbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Scrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Scrollbar with another Scrollbar, and returns true if they represent the same GObject.
func (recv *Scrollbar) Equals(other *Scrollbar) bool {
	return other.ToC() == recv.ToC()
}

// Range upcasts to *Range
func (recv *Scrollbar) Range() *Range {
	return RangeNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Scrollbar) Widget() *Widget {
	return recv.Range().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Scrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Range().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Scrollbar) Object() *gobject.Object {
	return recv.Range().Object()
}

// CastToWidget down casts any arbitrary Object to Scrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Scrollbar.
func CastToScrollbar(object *gobject.Object) *Scrollbar {
	return ScrollbarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Scrollbar
func (recv *Scrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Scrollbar
func (recv *Scrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Scrollbar
func (recv *Scrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScrolledWindow is a wrapper around the C record GtkScrolledWindow.
type ScrolledWindow struct {
	native *C.GtkScrolledWindow
	// container : record
	// priv : record
}

func ScrolledWindowNewFromC(u unsafe.Pointer) *ScrolledWindow {
	c := (*C.GtkScrolledWindow)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScrolledWindow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScrolledWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrolledWindow with another ScrolledWindow, and returns true if they represent the same GObject.
func (recv *ScrolledWindow) Equals(other *ScrolledWindow) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ScrolledWindow) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ScrolledWindow) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ScrolledWindow) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ScrolledWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ScrolledWindow) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ScrolledWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScrolledWindow.
func CastToScrolledWindow(object *gobject.Object) *ScrolledWindow {
	return ScrolledWindowNewFromC(object.ToC())
}

type signalScrolledWindowMoveFocusOutDetail struct {
	callback  ScrolledWindowSignalMoveFocusOutCallback
	handlerID C.gulong
}

var signalScrolledWindowMoveFocusOutId int
var signalScrolledWindowMoveFocusOutMap = make(map[int]signalScrolledWindowMoveFocusOutDetail)
var signalScrolledWindowMoveFocusOutLock sync.RWMutex

// ScrolledWindowSignalMoveFocusOutCallback is a callback function for a 'move-focus-out' signal emitted from a ScrolledWindow.
type ScrolledWindowSignalMoveFocusOutCallback func(directionType DirectionType)

/*
ConnectMoveFocusOut connects the callback to the 'move-focus-out' signal for the ScrolledWindow.

The returned value represents the connection, and may be passed to DisconnectMoveFocusOut to remove it.
*/
func (recv *ScrolledWindow) ConnectMoveFocusOut(callback ScrolledWindowSignalMoveFocusOutCallback) int {
	signalScrolledWindowMoveFocusOutLock.Lock()
	defer signalScrolledWindowMoveFocusOutLock.Unlock()

	signalScrolledWindowMoveFocusOutId++
	instance := C.gpointer(recv.native)
	handlerID := C.ScrolledWindow_signal_connect_move_focus_out(instance, C.gpointer(uintptr(signalScrolledWindowMoveFocusOutId)))

	detail := signalScrolledWindowMoveFocusOutDetail{callback, handlerID}
	signalScrolledWindowMoveFocusOutMap[signalScrolledWindowMoveFocusOutId] = detail

	return signalScrolledWindowMoveFocusOutId
}

/*
DisconnectMoveFocusOut disconnects a callback from the 'move-focus-out' signal for the ScrolledWindow.

The connectionID should be a value returned from a call to ConnectMoveFocusOut.
*/
func (recv *ScrolledWindow) DisconnectMoveFocusOut(connectionID int) {
	signalScrolledWindowMoveFocusOutLock.Lock()
	defer signalScrolledWindowMoveFocusOutLock.Unlock()

	detail, exists := signalScrolledWindowMoveFocusOutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalScrolledWindowMoveFocusOutMap, connectionID)
}

//export scrolledwindow_moveFocusOutHandler
func scrolledwindow_moveFocusOutHandler(_ *C.GObject, c_direction_type C.GtkDirectionType, data C.gpointer) {
	signalScrolledWindowMoveFocusOutLock.RLock()
	defer signalScrolledWindowMoveFocusOutLock.RUnlock()

	directionType := DirectionType(c_direction_type)

	index := int(uintptr(data))
	callback := signalScrolledWindowMoveFocusOutMap[index].callback
	callback(directionType)
}

type signalScrolledWindowScrollChildDetail struct {
	callback  ScrolledWindowSignalScrollChildCallback
	handlerID C.gulong
}

var signalScrolledWindowScrollChildId int
var signalScrolledWindowScrollChildMap = make(map[int]signalScrolledWindowScrollChildDetail)
var signalScrolledWindowScrollChildLock sync.RWMutex

// ScrolledWindowSignalScrollChildCallback is a callback function for a 'scroll-child' signal emitted from a ScrolledWindow.
type ScrolledWindowSignalScrollChildCallback func(scroll ScrollType, horizontal bool) bool

/*
ConnectScrollChild connects the callback to the 'scroll-child' signal for the ScrolledWindow.

The returned value represents the connection, and may be passed to DisconnectScrollChild to remove it.
*/
func (recv *ScrolledWindow) ConnectScrollChild(callback ScrolledWindowSignalScrollChildCallback) int {
	signalScrolledWindowScrollChildLock.Lock()
	defer signalScrolledWindowScrollChildLock.Unlock()

	signalScrolledWindowScrollChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.ScrolledWindow_signal_connect_scroll_child(instance, C.gpointer(uintptr(signalScrolledWindowScrollChildId)))

	detail := signalScrolledWindowScrollChildDetail{callback, handlerID}
	signalScrolledWindowScrollChildMap[signalScrolledWindowScrollChildId] = detail

	return signalScrolledWindowScrollChildId
}

/*
DisconnectScrollChild disconnects a callback from the 'scroll-child' signal for the ScrolledWindow.

The connectionID should be a value returned from a call to ConnectScrollChild.
*/
func (recv *ScrolledWindow) DisconnectScrollChild(connectionID int) {
	signalScrolledWindowScrollChildLock.Lock()
	defer signalScrolledWindowScrollChildLock.Unlock()

	detail, exists := signalScrolledWindowScrollChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalScrolledWindowScrollChildMap, connectionID)
}

//export scrolledwindow_scrollChildHandler
func scrolledwindow_scrollChildHandler(_ *C.GObject, c_scroll C.GtkScrollType, c_horizontal C.gboolean, data C.gpointer) C.gboolean {
	signalScrolledWindowScrollChildLock.RLock()
	defer signalScrolledWindowScrollChildLock.RUnlock()

	scroll := ScrollType(c_scroll)

	horizontal := c_horizontal == C.TRUE

	index := int(uintptr(data))
	callback := signalScrolledWindowScrollChildMap[index].callback
	retGo := callback(scroll, horizontal)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Blacklisted : gtk_scrolled_window_new

// Blacklisted : gtk_scrolled_window_add_with_viewport

// Blacklisted : gtk_scrolled_window_get_hadjustment

// Blacklisted : gtk_scrolled_window_get_placement

// Unsupported : gtk_scrolled_window_get_policy : unsupported parameter hscrollbar_policy : GtkPolicyType* with indirection level of 1

// Blacklisted : gtk_scrolled_window_get_shadow_type

// Blacklisted : gtk_scrolled_window_get_vadjustment

// Blacklisted : gtk_scrolled_window_set_hadjustment

// Blacklisted : gtk_scrolled_window_set_placement

// Blacklisted : gtk_scrolled_window_set_policy

// Blacklisted : gtk_scrolled_window_set_shadow_type

// Blacklisted : gtk_scrolled_window_set_vadjustment

// ImplementorIface returns the ImplementorIface interface implemented by ScrolledWindow
func (recv *ScrolledWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ScrolledWindow
func (recv *ScrolledWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ScrolledWindowAccessible is a wrapper around the C record GtkScrolledWindowAccessible.
type ScrolledWindowAccessible struct {
	native *C.GtkScrolledWindowAccessible
	// parent : record
	// priv : record
}

func ScrolledWindowAccessibleNewFromC(u unsafe.Pointer) *ScrolledWindowAccessible {
	c := (*C.GtkScrolledWindowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindowAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScrolledWindowAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScrolledWindowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrolledWindowAccessible with another ScrolledWindowAccessible, and returns true if they represent the same GObject.
func (recv *ScrolledWindowAccessible) Equals(other *ScrolledWindowAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ScrolledWindowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScrolledWindowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScrolledWindowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScrolledWindowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ScrolledWindowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScrolledWindowAccessible.
func CastToScrolledWindowAccessible(object *gobject.Object) *ScrolledWindowAccessible {
	return ScrolledWindowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ScrolledWindowAccessible
func (recv *ScrolledWindowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// SearchBar is a wrapper around the C record GtkSearchBar.
type SearchBar struct {
	native *C.GtkSearchBar
	// Private : parent
}

func SearchBarNewFromC(u unsafe.Pointer) *SearchBar {
	c := (*C.GtkSearchBar)(u)
	if c == nil {
		return nil
	}

	g := &SearchBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SearchBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SearchBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SearchBar with another SearchBar, and returns true if they represent the same GObject.
func (recv *SearchBar) Equals(other *SearchBar) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *SearchBar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *SearchBar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *SearchBar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SearchBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SearchBar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to SearchBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a SearchBar.
func CastToSearchBar(object *gobject.Object) *SearchBar {
	return SearchBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SearchBar
func (recv *SearchBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SearchBar
func (recv *SearchBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SearchEntry is a wrapper around the C record GtkSearchEntry.
type SearchEntry struct {
	native *C.GtkSearchEntry
	// parent : record
}

func SearchEntryNewFromC(u unsafe.Pointer) *SearchEntry {
	c := (*C.GtkSearchEntry)(u)
	if c == nil {
		return nil
	}

	g := &SearchEntry{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SearchEntry) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SearchEntry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SearchEntry with another SearchEntry, and returns true if they represent the same GObject.
func (recv *SearchEntry) Equals(other *SearchEntry) bool {
	return other.ToC() == recv.ToC()
}

// Entry upcasts to *Entry
func (recv *SearchEntry) Entry() *Entry {
	return EntryNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *SearchEntry) Widget() *Widget {
	return recv.Entry().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SearchEntry) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Entry().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SearchEntry) Object() *gobject.Object {
	return recv.Entry().Object()
}

// CastToWidget down casts any arbitrary Object to SearchEntry.
// Exercise care, as this is a potentially dangerous function if the Object is not a SearchEntry.
func CastToSearchEntry(object *gobject.Object) *SearchEntry {
	return SearchEntryNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SearchEntry
func (recv *SearchEntry) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SearchEntry
func (recv *SearchEntry) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by SearchEntry
func (recv *SearchEntry) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by SearchEntry
func (recv *SearchEntry) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// Separator is a wrapper around the C record GtkSeparator.
type Separator struct {
	native *C.GtkSeparator
	// widget : record
	// priv : record
}

func SeparatorNewFromC(u unsafe.Pointer) *Separator {
	c := (*C.GtkSeparator)(u)
	if c == nil {
		return nil
	}

	g := &Separator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Separator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Separator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Separator with another Separator, and returns true if they represent the same GObject.
func (recv *Separator) Equals(other *Separator) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Separator) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Separator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Separator) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Separator.
// Exercise care, as this is a potentially dangerous function if the Object is not a Separator.
func CastToSeparator(object *gobject.Object) *Separator {
	return SeparatorNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Separator
func (recv *Separator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Separator
func (recv *Separator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Separator
func (recv *Separator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// SeparatorMenuItem is a wrapper around the C record GtkSeparatorMenuItem.
type SeparatorMenuItem struct {
	native *C.GtkSeparatorMenuItem
	// menu_item : record
}

func SeparatorMenuItemNewFromC(u unsafe.Pointer) *SeparatorMenuItem {
	c := (*C.GtkSeparatorMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SeparatorMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SeparatorMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorMenuItem with another SeparatorMenuItem, and returns true if they represent the same GObject.
func (recv *SeparatorMenuItem) Equals(other *SeparatorMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// MenuItem upcasts to *MenuItem
func (recv *SeparatorMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *SeparatorMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *SeparatorMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *SeparatorMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SeparatorMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SeparatorMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to SeparatorMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a SeparatorMenuItem.
func CastToSeparatorMenuItem(object *gobject.Object) *SeparatorMenuItem {
	return SeparatorMenuItemNewFromC(object.ToC())
}

// Blacklisted : gtk_separator_menu_item_new

// ImplementorIface returns the ImplementorIface interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SeparatorToolItem is a wrapper around the C record GtkSeparatorToolItem.
type SeparatorToolItem struct {
	native *C.GtkSeparatorToolItem
	// parent : record
	// Private : priv
}

func SeparatorToolItemNewFromC(u unsafe.Pointer) *SeparatorToolItem {
	c := (*C.GtkSeparatorToolItem)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorToolItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SeparatorToolItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SeparatorToolItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorToolItem with another SeparatorToolItem, and returns true if they represent the same GObject.
func (recv *SeparatorToolItem) Equals(other *SeparatorToolItem) bool {
	return other.ToC() == recv.ToC()
}

// ToolItem upcasts to *ToolItem
func (recv *SeparatorToolItem) ToolItem() *ToolItem {
	return ToolItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *SeparatorToolItem) Bin() *Bin {
	return recv.ToolItem().Bin()
}

// Container upcasts to *Container
func (recv *SeparatorToolItem) Container() *Container {
	return recv.ToolItem().Container()
}

// Widget upcasts to *Widget
func (recv *SeparatorToolItem) Widget() *Widget {
	return recv.ToolItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SeparatorToolItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SeparatorToolItem) Object() *gobject.Object {
	return recv.ToolItem().Object()
}

// CastToWidget down casts any arbitrary Object to SeparatorToolItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a SeparatorToolItem.
func CastToSeparatorToolItem(object *gobject.Object) *SeparatorToolItem {
	return SeparatorToolItemNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Settings is a wrapper around the C record GtkSettings.
type Settings struct {
	native *C.GtkSettings
	// parent_instance : record
	// Private : priv
}

func SettingsNewFromC(u unsafe.Pointer) *Settings {
	c := (*C.GtkSettings)(u)
	if c == nil {
		return nil
	}

	g := &Settings{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Settings) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Settings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Settings with another Settings, and returns true if they represent the same GObject.
func (recv *Settings) Equals(other *Settings) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Settings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Settings.
// Exercise care, as this is a potentially dangerous function if the Object is not a Settings.
func CastToSettings(object *gobject.Object) *Settings {
	return SettingsNewFromC(object.ToC())
}

// Blacklisted : gtk_settings_get_default

// Blacklisted : gtk_settings_install_property

// gtk_settings_install_property_parser : unsupported parameter parser : no type generator for RcPropertyParser (GtkRcPropertyParser) for param parser
// Blacklisted : gtk_settings_set_double_property

// Blacklisted : gtk_settings_set_long_property

// Blacklisted : gtk_settings_set_property_value

// Blacklisted : gtk_settings_set_string_property

// StyleProvider returns the StyleProvider interface implemented by Settings
func (recv *Settings) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// SizeGroup is a wrapper around the C record GtkSizeGroup.
type SizeGroup struct {
	native *C.GtkSizeGroup
	// parent_instance : record
	// Private : priv
}

func SizeGroupNewFromC(u unsafe.Pointer) *SizeGroup {
	c := (*C.GtkSizeGroup)(u)
	if c == nil {
		return nil
	}

	g := &SizeGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SizeGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SizeGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SizeGroup with another SizeGroup, and returns true if they represent the same GObject.
func (recv *SizeGroup) Equals(other *SizeGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SizeGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SizeGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a SizeGroup.
func CastToSizeGroup(object *gobject.Object) *SizeGroup {
	return SizeGroupNewFromC(object.ToC())
}

// Blacklisted : gtk_size_group_new

// Blacklisted : gtk_size_group_add_widget

// Blacklisted : gtk_size_group_get_mode

// Blacklisted : gtk_size_group_remove_widget

// Blacklisted : gtk_size_group_set_mode

// Buildable returns the Buildable interface implemented by SizeGroup
func (recv *SizeGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkSocket

// SpinButton is a wrapper around the C record GtkSpinButton.
type SpinButton struct {
	native *C.GtkSpinButton
	// entry : record
	// Private : priv
}

func SpinButtonNewFromC(u unsafe.Pointer) *SpinButton {
	c := (*C.GtkSpinButton)(u)
	if c == nil {
		return nil
	}

	g := &SpinButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SpinButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SpinButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinButton with another SpinButton, and returns true if they represent the same GObject.
func (recv *SpinButton) Equals(other *SpinButton) bool {
	return other.ToC() == recv.ToC()
}

// Entry upcasts to *Entry
func (recv *SpinButton) Entry() *Entry {
	return EntryNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *SpinButton) Widget() *Widget {
	return recv.Entry().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SpinButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Entry().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SpinButton) Object() *gobject.Object {
	return recv.Entry().Object()
}

// CastToWidget down casts any arbitrary Object to SpinButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinButton.
func CastToSpinButton(object *gobject.Object) *SpinButton {
	return SpinButtonNewFromC(object.ToC())
}

type signalSpinButtonChangeValueDetail struct {
	callback  SpinButtonSignalChangeValueCallback
	handlerID C.gulong
}

var signalSpinButtonChangeValueId int
var signalSpinButtonChangeValueMap = make(map[int]signalSpinButtonChangeValueDetail)
var signalSpinButtonChangeValueLock sync.RWMutex

// SpinButtonSignalChangeValueCallback is a callback function for a 'change-value' signal emitted from a SpinButton.
type SpinButtonSignalChangeValueCallback func(scroll ScrollType)

/*
ConnectChangeValue connects the callback to the 'change-value' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectChangeValue to remove it.
*/
func (recv *SpinButton) ConnectChangeValue(callback SpinButtonSignalChangeValueCallback) int {
	signalSpinButtonChangeValueLock.Lock()
	defer signalSpinButtonChangeValueLock.Unlock()

	signalSpinButtonChangeValueId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_change_value(instance, C.gpointer(uintptr(signalSpinButtonChangeValueId)))

	detail := signalSpinButtonChangeValueDetail{callback, handlerID}
	signalSpinButtonChangeValueMap[signalSpinButtonChangeValueId] = detail

	return signalSpinButtonChangeValueId
}

/*
DisconnectChangeValue disconnects a callback from the 'change-value' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectChangeValue.
*/
func (recv *SpinButton) DisconnectChangeValue(connectionID int) {
	signalSpinButtonChangeValueLock.Lock()
	defer signalSpinButtonChangeValueLock.Unlock()

	detail, exists := signalSpinButtonChangeValueMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonChangeValueMap, connectionID)
}

//export spinbutton_changeValueHandler
func spinbutton_changeValueHandler(_ *C.GObject, c_scroll C.GtkScrollType, data C.gpointer) {
	signalSpinButtonChangeValueLock.RLock()
	defer signalSpinButtonChangeValueLock.RUnlock()

	scroll := ScrollType(c_scroll)

	index := int(uintptr(data))
	callback := signalSpinButtonChangeValueMap[index].callback
	callback(scroll)
}

// Unsupported signal 'input' for SpinButton : unsupported parameter new_value : direction is 'out'

type signalSpinButtonOutputDetail struct {
	callback  SpinButtonSignalOutputCallback
	handlerID C.gulong
}

var signalSpinButtonOutputId int
var signalSpinButtonOutputMap = make(map[int]signalSpinButtonOutputDetail)
var signalSpinButtonOutputLock sync.RWMutex

// SpinButtonSignalOutputCallback is a callback function for a 'output' signal emitted from a SpinButton.
type SpinButtonSignalOutputCallback func() bool

/*
ConnectOutput connects the callback to the 'output' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectOutput to remove it.
*/
func (recv *SpinButton) ConnectOutput(callback SpinButtonSignalOutputCallback) int {
	signalSpinButtonOutputLock.Lock()
	defer signalSpinButtonOutputLock.Unlock()

	signalSpinButtonOutputId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_output(instance, C.gpointer(uintptr(signalSpinButtonOutputId)))

	detail := signalSpinButtonOutputDetail{callback, handlerID}
	signalSpinButtonOutputMap[signalSpinButtonOutputId] = detail

	return signalSpinButtonOutputId
}

/*
DisconnectOutput disconnects a callback from the 'output' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectOutput.
*/
func (recv *SpinButton) DisconnectOutput(connectionID int) {
	signalSpinButtonOutputLock.Lock()
	defer signalSpinButtonOutputLock.Unlock()

	detail, exists := signalSpinButtonOutputMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonOutputMap, connectionID)
}

//export spinbutton_outputHandler
func spinbutton_outputHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalSpinButtonOutputLock.RLock()
	defer signalSpinButtonOutputLock.RUnlock()

	index := int(uintptr(data))
	callback := signalSpinButtonOutputMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalSpinButtonValueChangedDetail struct {
	callback  SpinButtonSignalValueChangedCallback
	handlerID C.gulong
}

var signalSpinButtonValueChangedId int
var signalSpinButtonValueChangedMap = make(map[int]signalSpinButtonValueChangedDetail)
var signalSpinButtonValueChangedLock sync.RWMutex

// SpinButtonSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a SpinButton.
type SpinButtonSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *SpinButton) ConnectValueChanged(callback SpinButtonSignalValueChangedCallback) int {
	signalSpinButtonValueChangedLock.Lock()
	defer signalSpinButtonValueChangedLock.Unlock()

	signalSpinButtonValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_value_changed(instance, C.gpointer(uintptr(signalSpinButtonValueChangedId)))

	detail := signalSpinButtonValueChangedDetail{callback, handlerID}
	signalSpinButtonValueChangedMap[signalSpinButtonValueChangedId] = detail

	return signalSpinButtonValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *SpinButton) DisconnectValueChanged(connectionID int) {
	signalSpinButtonValueChangedLock.Lock()
	defer signalSpinButtonValueChangedLock.Unlock()

	detail, exists := signalSpinButtonValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonValueChangedMap, connectionID)
}

//export spinbutton_valueChangedHandler
func spinbutton_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	signalSpinButtonValueChangedLock.RLock()
	defer signalSpinButtonValueChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalSpinButtonValueChangedMap[index].callback
	callback()
}

// Blacklisted : gtk_spin_button_new

// Blacklisted : gtk_spin_button_new_with_range

// Blacklisted : gtk_spin_button_configure

// Blacklisted : gtk_spin_button_get_adjustment

// Blacklisted : gtk_spin_button_get_digits

// Blacklisted : gtk_spin_button_get_increments

// Blacklisted : gtk_spin_button_get_numeric

// Blacklisted : gtk_spin_button_get_range

// Blacklisted : gtk_spin_button_get_snap_to_ticks

// Blacklisted : gtk_spin_button_get_update_policy

// Blacklisted : gtk_spin_button_get_value

// Blacklisted : gtk_spin_button_get_value_as_int

// Blacklisted : gtk_spin_button_get_wrap

// Blacklisted : gtk_spin_button_set_adjustment

// Blacklisted : gtk_spin_button_set_digits

// Blacklisted : gtk_spin_button_set_increments

// Blacklisted : gtk_spin_button_set_numeric

// Blacklisted : gtk_spin_button_set_range

// Blacklisted : gtk_spin_button_set_snap_to_ticks

// Blacklisted : gtk_spin_button_set_update_policy

// Blacklisted : gtk_spin_button_set_value

// Blacklisted : gtk_spin_button_set_wrap

// Blacklisted : gtk_spin_button_spin

// Blacklisted : gtk_spin_button_update

// ImplementorIface returns the ImplementorIface interface implemented by SpinButton
func (recv *SpinButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SpinButton
func (recv *SpinButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by SpinButton
func (recv *SpinButton) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by SpinButton
func (recv *SpinButton) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by SpinButton
func (recv *SpinButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// SpinButtonAccessible is a wrapper around the C record GtkSpinButtonAccessible.
type SpinButtonAccessible struct {
	native *C.GtkSpinButtonAccessible
	// parent : record
	// priv : record
}

func SpinButtonAccessibleNewFromC(u unsafe.Pointer) *SpinButtonAccessible {
	c := (*C.GtkSpinButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SpinButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SpinButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SpinButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinButtonAccessible with another SpinButtonAccessible, and returns true if they represent the same GObject.
func (recv *SpinButtonAccessible) Equals(other *SpinButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// EntryAccessible upcasts to *EntryAccessible
func (recv *SpinButtonAccessible) EntryAccessible() *EntryAccessible {
	return EntryAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SpinButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.EntryAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *SpinButtonAccessible) Accessible() *Accessible {
	return recv.EntryAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SpinButtonAccessible) Object() *atk.Object {
	return recv.EntryAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to SpinButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinButtonAccessible.
func CastToSpinButtonAccessible(object *gobject.Object) *SpinButtonAccessible {
	return SpinButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// Spinner is a wrapper around the C record GtkSpinner.
type Spinner struct {
	native *C.GtkSpinner
	// parent : record
	// Private : priv
}

func SpinnerNewFromC(u unsafe.Pointer) *Spinner {
	c := (*C.GtkSpinner)(u)
	if c == nil {
		return nil
	}

	g := &Spinner{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Spinner) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Spinner) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Spinner with another Spinner, and returns true if they represent the same GObject.
func (recv *Spinner) Equals(other *Spinner) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Spinner) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Spinner) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Spinner) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Spinner.
// Exercise care, as this is a potentially dangerous function if the Object is not a Spinner.
func CastToSpinner(object *gobject.Object) *Spinner {
	return SpinnerNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Spinner
func (recv *Spinner) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Spinner
func (recv *Spinner) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SpinnerAccessible is a wrapper around the C record GtkSpinnerAccessible.
type SpinnerAccessible struct {
	native *C.GtkSpinnerAccessible
	// parent : record
	// priv : record
}

func SpinnerAccessibleNewFromC(u unsafe.Pointer) *SpinnerAccessible {
	c := (*C.GtkSpinnerAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SpinnerAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SpinnerAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SpinnerAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinnerAccessible with another SpinnerAccessible, and returns true if they represent the same GObject.
func (recv *SpinnerAccessible) Equals(other *SpinnerAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SpinnerAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *SpinnerAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SpinnerAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to SpinnerAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinnerAccessible.
func CastToSpinnerAccessible(object *gobject.Object) *SpinnerAccessible {
	return SpinnerAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by SpinnerAccessible
func (recv *SpinnerAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by SpinnerAccessible
func (recv *SpinnerAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Stack is a wrapper around the C record GtkStack.
type Stack struct {
	native *C.GtkStack
	// parent_instance : record
}

func StackNewFromC(u unsafe.Pointer) *Stack {
	c := (*C.GtkStack)(u)
	if c == nil {
		return nil
	}

	g := &Stack{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Stack) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Stack) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Stack with another Stack, and returns true if they represent the same GObject.
func (recv *Stack) Equals(other *Stack) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Stack) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Stack) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Stack) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Stack) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Stack.
// Exercise care, as this is a potentially dangerous function if the Object is not a Stack.
func CastToStack(object *gobject.Object) *Stack {
	return StackNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Stack
func (recv *Stack) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Stack
func (recv *Stack) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkStackAccessible

// StackSidebar is a wrapper around the C record GtkStackSidebar.
type StackSidebar struct {
	native *C.GtkStackSidebar
	// parent : record
}

func StackSidebarNewFromC(u unsafe.Pointer) *StackSidebar {
	c := (*C.GtkStackSidebar)(u)
	if c == nil {
		return nil
	}

	g := &StackSidebar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StackSidebar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StackSidebar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StackSidebar with another StackSidebar, and returns true if they represent the same GObject.
func (recv *StackSidebar) Equals(other *StackSidebar) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *StackSidebar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *StackSidebar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *StackSidebar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *StackSidebar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *StackSidebar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to StackSidebar.
// Exercise care, as this is a potentially dangerous function if the Object is not a StackSidebar.
func CastToStackSidebar(object *gobject.Object) *StackSidebar {
	return StackSidebarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by StackSidebar
func (recv *StackSidebar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by StackSidebar
func (recv *StackSidebar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// StackSwitcher is a wrapper around the C record GtkStackSwitcher.
type StackSwitcher struct {
	native *C.GtkStackSwitcher
	// widget : record
}

func StackSwitcherNewFromC(u unsafe.Pointer) *StackSwitcher {
	c := (*C.GtkStackSwitcher)(u)
	if c == nil {
		return nil
	}

	g := &StackSwitcher{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StackSwitcher) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StackSwitcher) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StackSwitcher with another StackSwitcher, and returns true if they represent the same GObject.
func (recv *StackSwitcher) Equals(other *StackSwitcher) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *StackSwitcher) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *StackSwitcher) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *StackSwitcher) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *StackSwitcher) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *StackSwitcher) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to StackSwitcher.
// Exercise care, as this is a potentially dangerous function if the Object is not a StackSwitcher.
func CastToStackSwitcher(object *gobject.Object) *StackSwitcher {
	return StackSwitcherNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by StackSwitcher
func (recv *StackSwitcher) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by StackSwitcher
func (recv *StackSwitcher) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by StackSwitcher
func (recv *StackSwitcher) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// StatusIcon is a wrapper around the C record GtkStatusIcon.
type StatusIcon struct {
	native *C.GtkStatusIcon
	// parent_instance : record
	// priv : record
}

func StatusIconNewFromC(u unsafe.Pointer) *StatusIcon {
	c := (*C.GtkStatusIcon)(u)
	if c == nil {
		return nil
	}

	g := &StatusIcon{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StatusIcon) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StatusIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusIcon with another StatusIcon, and returns true if they represent the same GObject.
func (recv *StatusIcon) Equals(other *StatusIcon) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *StatusIcon) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to StatusIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a StatusIcon.
func CastToStatusIcon(object *gobject.Object) *StatusIcon {
	return StatusIconNewFromC(object.ToC())
}

// Statusbar is a wrapper around the C record GtkStatusbar.
type Statusbar struct {
	native *C.GtkStatusbar
	// parent_widget : record
	// Private : priv
}

func StatusbarNewFromC(u unsafe.Pointer) *Statusbar {
	c := (*C.GtkStatusbar)(u)
	if c == nil {
		return nil
	}

	g := &Statusbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Statusbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Statusbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Statusbar with another Statusbar, and returns true if they represent the same GObject.
func (recv *Statusbar) Equals(other *Statusbar) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *Statusbar) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Statusbar) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *Statusbar) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Statusbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Statusbar) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to Statusbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Statusbar.
func CastToStatusbar(object *gobject.Object) *Statusbar {
	return StatusbarNewFromC(object.ToC())
}

type signalStatusbarTextPoppedDetail struct {
	callback  StatusbarSignalTextPoppedCallback
	handlerID C.gulong
}

var signalStatusbarTextPoppedId int
var signalStatusbarTextPoppedMap = make(map[int]signalStatusbarTextPoppedDetail)
var signalStatusbarTextPoppedLock sync.RWMutex

// StatusbarSignalTextPoppedCallback is a callback function for a 'text-popped' signal emitted from a Statusbar.
type StatusbarSignalTextPoppedCallback func(contextId uint32, text string)

/*
ConnectTextPopped connects the callback to the 'text-popped' signal for the Statusbar.

The returned value represents the connection, and may be passed to DisconnectTextPopped to remove it.
*/
func (recv *Statusbar) ConnectTextPopped(callback StatusbarSignalTextPoppedCallback) int {
	signalStatusbarTextPoppedLock.Lock()
	defer signalStatusbarTextPoppedLock.Unlock()

	signalStatusbarTextPoppedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Statusbar_signal_connect_text_popped(instance, C.gpointer(uintptr(signalStatusbarTextPoppedId)))

	detail := signalStatusbarTextPoppedDetail{callback, handlerID}
	signalStatusbarTextPoppedMap[signalStatusbarTextPoppedId] = detail

	return signalStatusbarTextPoppedId
}

/*
DisconnectTextPopped disconnects a callback from the 'text-popped' signal for the Statusbar.

The connectionID should be a value returned from a call to ConnectTextPopped.
*/
func (recv *Statusbar) DisconnectTextPopped(connectionID int) {
	signalStatusbarTextPoppedLock.Lock()
	defer signalStatusbarTextPoppedLock.Unlock()

	detail, exists := signalStatusbarTextPoppedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStatusbarTextPoppedMap, connectionID)
}

//export statusbar_textPoppedHandler
func statusbar_textPoppedHandler(_ *C.GObject, c_context_id C.guint, c_text *C.gchar, data C.gpointer) {
	signalStatusbarTextPoppedLock.RLock()
	defer signalStatusbarTextPoppedLock.RUnlock()

	contextId := uint32(c_context_id)

	text := C.GoString(c_text)

	index := int(uintptr(data))
	callback := signalStatusbarTextPoppedMap[index].callback
	callback(contextId, text)
}

type signalStatusbarTextPushedDetail struct {
	callback  StatusbarSignalTextPushedCallback
	handlerID C.gulong
}

var signalStatusbarTextPushedId int
var signalStatusbarTextPushedMap = make(map[int]signalStatusbarTextPushedDetail)
var signalStatusbarTextPushedLock sync.RWMutex

// StatusbarSignalTextPushedCallback is a callback function for a 'text-pushed' signal emitted from a Statusbar.
type StatusbarSignalTextPushedCallback func(contextId uint32, text string)

/*
ConnectTextPushed connects the callback to the 'text-pushed' signal for the Statusbar.

The returned value represents the connection, and may be passed to DisconnectTextPushed to remove it.
*/
func (recv *Statusbar) ConnectTextPushed(callback StatusbarSignalTextPushedCallback) int {
	signalStatusbarTextPushedLock.Lock()
	defer signalStatusbarTextPushedLock.Unlock()

	signalStatusbarTextPushedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Statusbar_signal_connect_text_pushed(instance, C.gpointer(uintptr(signalStatusbarTextPushedId)))

	detail := signalStatusbarTextPushedDetail{callback, handlerID}
	signalStatusbarTextPushedMap[signalStatusbarTextPushedId] = detail

	return signalStatusbarTextPushedId
}

/*
DisconnectTextPushed disconnects a callback from the 'text-pushed' signal for the Statusbar.

The connectionID should be a value returned from a call to ConnectTextPushed.
*/
func (recv *Statusbar) DisconnectTextPushed(connectionID int) {
	signalStatusbarTextPushedLock.Lock()
	defer signalStatusbarTextPushedLock.Unlock()

	detail, exists := signalStatusbarTextPushedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStatusbarTextPushedMap, connectionID)
}

//export statusbar_textPushedHandler
func statusbar_textPushedHandler(_ *C.GObject, c_context_id C.guint, c_text *C.gchar, data C.gpointer) {
	signalStatusbarTextPushedLock.RLock()
	defer signalStatusbarTextPushedLock.RUnlock()

	contextId := uint32(c_context_id)

	text := C.GoString(c_text)

	index := int(uintptr(data))
	callback := signalStatusbarTextPushedMap[index].callback
	callback(contextId, text)
}

// Blacklisted : gtk_statusbar_new

// Blacklisted : gtk_statusbar_get_context_id

// Blacklisted : gtk_statusbar_pop

// Blacklisted : gtk_statusbar_push

// Blacklisted : gtk_statusbar_remove

// ImplementorIface returns the ImplementorIface interface implemented by Statusbar
func (recv *Statusbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Statusbar
func (recv *Statusbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Statusbar
func (recv *Statusbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// StatusbarAccessible is a wrapper around the C record GtkStatusbarAccessible.
type StatusbarAccessible struct {
	native *C.GtkStatusbarAccessible
	// parent : record
	// priv : record
}

func StatusbarAccessibleNewFromC(u unsafe.Pointer) *StatusbarAccessible {
	c := (*C.GtkStatusbarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &StatusbarAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StatusbarAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StatusbarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusbarAccessible with another StatusbarAccessible, and returns true if they represent the same GObject.
func (recv *StatusbarAccessible) Equals(other *StatusbarAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *StatusbarAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *StatusbarAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *StatusbarAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *StatusbarAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to StatusbarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a StatusbarAccessible.
func CastToStatusbarAccessible(object *gobject.Object) *StatusbarAccessible {
	return StatusbarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by StatusbarAccessible
func (recv *StatusbarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Style is a wrapper around the C record GtkStyle.
type Style struct {
	native *C.GtkStyle
	// Private : parent_instance
	// no type for fg
	// no type for bg
	// no type for light
	// no type for dark
	// no type for mid
	// no type for text
	// no type for base
	// no type for text_aa
	// black : record
	// white : record
	// font_desc : record
	Xthickness int32
	Ythickness int32
	// no type for background
	// Private : attach_count
	// Private : visual
	// Private : private_font_desc
	// Private : rc_style
	// Private : styles
	// Private : property_cache
	// Private : icon_factories
}

func StyleNewFromC(u unsafe.Pointer) *Style {
	c := (*C.GtkStyle)(u)
	if c == nil {
		return nil
	}

	g := &Style{
		Xthickness: (int32)(c.xthickness),
		Ythickness: (int32)(c.ythickness),
		native:     c,
	}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Style) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Style) ToC() unsafe.Pointer {
	recv.native.xthickness =
		(C.gint)(recv.Xthickness)
	recv.native.ythickness =
		(C.gint)(recv.Ythickness)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Style with another Style, and returns true if they represent the same GObject.
func (recv *Style) Equals(other *Style) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Style) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Style.
// Exercise care, as this is a potentially dangerous function if the Object is not a Style.
func CastToStyle(object *gobject.Object) *Style {
	return StyleNewFromC(object.ToC())
}

// Blacklisted : gtk_style_new

// Blacklisted : gtk_style_apply_default_background

// Blacklisted : gtk_style_attach

// Blacklisted : gtk_style_copy

// Blacklisted : gtk_style_detach

// Blacklisted : gtk_style_lookup_icon_set

// Blacklisted : gtk_style_render_icon

// Blacklisted : gtk_style_set_background

// StyleContext is a wrapper around the C record GtkStyleContext.
type StyleContext struct {
	native *C.GtkStyleContext
	// parent_object : record
	// priv : record
}

func StyleContextNewFromC(u unsafe.Pointer) *StyleContext {
	c := (*C.GtkStyleContext)(u)
	if c == nil {
		return nil
	}

	g := &StyleContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StyleContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StyleContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleContext with another StyleContext, and returns true if they represent the same GObject.
func (recv *StyleContext) Equals(other *StyleContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *StyleContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to StyleContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a StyleContext.
func CastToStyleContext(object *gobject.Object) *StyleContext {
	return StyleContextNewFromC(object.ToC())
}

// Blacklisted : gtk_style_context_new

// Blacklisted : gtk_style_context_get_screen

// Blacklisted : gtk_style_context_get_section

// Blacklisted : gtk_style_context_get_style_property

// Blacklisted : gtk_style_context_lookup_color

// Blacklisted : gtk_style_context_lookup_icon_set

// StyleProperties is a wrapper around the C record GtkStyleProperties.
type StyleProperties struct {
	native *C.GtkStyleProperties
	// Private : parent_object
	// Private : priv
}

func StylePropertiesNewFromC(u unsafe.Pointer) *StyleProperties {
	c := (*C.GtkStyleProperties)(u)
	if c == nil {
		return nil
	}

	g := &StyleProperties{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StyleProperties) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StyleProperties) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleProperties with another StyleProperties, and returns true if they represent the same GObject.
func (recv *StyleProperties) Equals(other *StyleProperties) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *StyleProperties) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to StyleProperties.
// Exercise care, as this is a potentially dangerous function if the Object is not a StyleProperties.
func CastToStyleProperties(object *gobject.Object) *StyleProperties {
	return StylePropertiesNewFromC(object.ToC())
}

// Blacklisted : gtk_style_properties_new

// Blacklisted : gtk_style_properties_clear

// StyleProvider returns the StyleProvider interface implemented by StyleProperties
func (recv *StyleProperties) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// Switch is a wrapper around the C record GtkSwitch.
type Switch struct {
	native *C.GtkSwitch
	// Private : parent_instance
	// Private : priv
}

func SwitchNewFromC(u unsafe.Pointer) *Switch {
	c := (*C.GtkSwitch)(u)
	if c == nil {
		return nil
	}

	g := &Switch{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Switch) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Switch) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Switch with another Switch, and returns true if they represent the same GObject.
func (recv *Switch) Equals(other *Switch) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Switch) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Switch) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Switch) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Switch.
// Exercise care, as this is a potentially dangerous function if the Object is not a Switch.
func CastToSwitch(object *gobject.Object) *Switch {
	return SwitchNewFromC(object.ToC())
}

type signalSwitchActivateDetail struct {
	callback  SwitchSignalActivateCallback
	handlerID C.gulong
}

var signalSwitchActivateId int
var signalSwitchActivateMap = make(map[int]signalSwitchActivateDetail)
var signalSwitchActivateLock sync.RWMutex

// SwitchSignalActivateCallback is a callback function for a 'activate' signal emitted from a Switch.
type SwitchSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Switch.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Switch) ConnectActivate(callback SwitchSignalActivateCallback) int {
	signalSwitchActivateLock.Lock()
	defer signalSwitchActivateLock.Unlock()

	signalSwitchActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Switch_signal_connect_activate(instance, C.gpointer(uintptr(signalSwitchActivateId)))

	detail := signalSwitchActivateDetail{callback, handlerID}
	signalSwitchActivateMap[signalSwitchActivateId] = detail

	return signalSwitchActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Switch.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Switch) DisconnectActivate(connectionID int) {
	signalSwitchActivateLock.Lock()
	defer signalSwitchActivateLock.Unlock()

	detail, exists := signalSwitchActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSwitchActivateMap, connectionID)
}

//export switch_activateHandler
func switch_activateHandler(_ *C.GObject, data C.gpointer) {
	signalSwitchActivateLock.RLock()
	defer signalSwitchActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalSwitchActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Switch
func (recv *Switch) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by Switch
func (recv *Switch) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by Switch
func (recv *Switch) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Switch
func (recv *Switch) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SwitchAccessible is a wrapper around the C record GtkSwitchAccessible.
type SwitchAccessible struct {
	native *C.GtkSwitchAccessible
	// parent : record
	// priv : record
}

func SwitchAccessibleNewFromC(u unsafe.Pointer) *SwitchAccessible {
	c := (*C.GtkSwitchAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SwitchAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SwitchAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SwitchAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SwitchAccessible with another SwitchAccessible, and returns true if they represent the same GObject.
func (recv *SwitchAccessible) Equals(other *SwitchAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SwitchAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *SwitchAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SwitchAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to SwitchAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SwitchAccessible.
func CastToSwitchAccessible(object *gobject.Object) *SwitchAccessible {
	return SwitchAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by SwitchAccessible
func (recv *SwitchAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by SwitchAccessible
func (recv *SwitchAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Table is a wrapper around the C record GtkTable.
type Table struct {
	native *C.GtkTable
	// container : record
	// Private : priv
}

func TableNewFromC(u unsafe.Pointer) *Table {
	c := (*C.GtkTable)(u)
	if c == nil {
		return nil
	}

	g := &Table{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Table) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Table) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Table with another Table, and returns true if they represent the same GObject.
func (recv *Table) Equals(other *Table) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Table) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Table) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Table) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Table) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Table.
// Exercise care, as this is a potentially dangerous function if the Object is not a Table.
func CastToTable(object *gobject.Object) *Table {
	return TableNewFromC(object.ToC())
}

// Blacklisted : gtk_table_new

// Blacklisted : gtk_table_attach

// Blacklisted : gtk_table_attach_defaults

// Blacklisted : gtk_table_get_col_spacing

// Blacklisted : gtk_table_get_default_col_spacing

// Blacklisted : gtk_table_get_default_row_spacing

// Blacklisted : gtk_table_get_homogeneous

// Blacklisted : gtk_table_get_row_spacing

// Blacklisted : gtk_table_resize

// Blacklisted : gtk_table_set_col_spacing

// Blacklisted : gtk_table_set_col_spacings

// Blacklisted : gtk_table_set_homogeneous

// Blacklisted : gtk_table_set_row_spacing

// Blacklisted : gtk_table_set_row_spacings

// ImplementorIface returns the ImplementorIface interface implemented by Table
func (recv *Table) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Table
func (recv *Table) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TearoffMenuItem is a wrapper around the C record GtkTearoffMenuItem.
type TearoffMenuItem struct {
	native *C.GtkTearoffMenuItem
	// menu_item : record
	// Private : priv
}

func TearoffMenuItemNewFromC(u unsafe.Pointer) *TearoffMenuItem {
	c := (*C.GtkTearoffMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &TearoffMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TearoffMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TearoffMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TearoffMenuItem with another TearoffMenuItem, and returns true if they represent the same GObject.
func (recv *TearoffMenuItem) Equals(other *TearoffMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// MenuItem upcasts to *MenuItem
func (recv *TearoffMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *TearoffMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *TearoffMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *TearoffMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TearoffMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TearoffMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to TearoffMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a TearoffMenuItem.
func CastToTearoffMenuItem(object *gobject.Object) *TearoffMenuItem {
	return TearoffMenuItemNewFromC(object.ToC())
}

// Blacklisted : gtk_tearoff_menu_item_new

// ImplementorIface returns the ImplementorIface interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TextBuffer is a wrapper around the C record GtkTextBuffer.
type TextBuffer struct {
	native *C.GtkTextBuffer
	// parent_instance : record
	// priv : record
}

func TextBufferNewFromC(u unsafe.Pointer) *TextBuffer {
	c := (*C.GtkTextBuffer)(u)
	if c == nil {
		return nil
	}

	g := &TextBuffer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextBuffer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextBuffer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextBuffer with another TextBuffer, and returns true if they represent the same GObject.
func (recv *TextBuffer) Equals(other *TextBuffer) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextBuffer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextBuffer.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextBuffer.
func CastToTextBuffer(object *gobject.Object) *TextBuffer {
	return TextBufferNewFromC(object.ToC())
}

type signalTextBufferApplyTagDetail struct {
	callback  TextBufferSignalApplyTagCallback
	handlerID C.gulong
}

var signalTextBufferApplyTagId int
var signalTextBufferApplyTagMap = make(map[int]signalTextBufferApplyTagDetail)
var signalTextBufferApplyTagLock sync.RWMutex

// TextBufferSignalApplyTagCallback is a callback function for a 'apply-tag' signal emitted from a TextBuffer.
type TextBufferSignalApplyTagCallback func(tag *TextTag, start *TextIter, end *TextIter)

/*
ConnectApplyTag connects the callback to the 'apply-tag' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectApplyTag to remove it.
*/
func (recv *TextBuffer) ConnectApplyTag(callback TextBufferSignalApplyTagCallback) int {
	signalTextBufferApplyTagLock.Lock()
	defer signalTextBufferApplyTagLock.Unlock()

	signalTextBufferApplyTagId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_apply_tag(instance, C.gpointer(uintptr(signalTextBufferApplyTagId)))

	detail := signalTextBufferApplyTagDetail{callback, handlerID}
	signalTextBufferApplyTagMap[signalTextBufferApplyTagId] = detail

	return signalTextBufferApplyTagId
}

/*
DisconnectApplyTag disconnects a callback from the 'apply-tag' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectApplyTag.
*/
func (recv *TextBuffer) DisconnectApplyTag(connectionID int) {
	signalTextBufferApplyTagLock.Lock()
	defer signalTextBufferApplyTagLock.Unlock()

	detail, exists := signalTextBufferApplyTagMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferApplyTagMap, connectionID)
}

//export textbuffer_applyTagHandler
func textbuffer_applyTagHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	signalTextBufferApplyTagLock.RLock()
	defer signalTextBufferApplyTagLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferApplyTagMap[index].callback
	callback(tag, start, end)
}

type signalTextBufferBeginUserActionDetail struct {
	callback  TextBufferSignalBeginUserActionCallback
	handlerID C.gulong
}

var signalTextBufferBeginUserActionId int
var signalTextBufferBeginUserActionMap = make(map[int]signalTextBufferBeginUserActionDetail)
var signalTextBufferBeginUserActionLock sync.RWMutex

// TextBufferSignalBeginUserActionCallback is a callback function for a 'begin-user-action' signal emitted from a TextBuffer.
type TextBufferSignalBeginUserActionCallback func()

/*
ConnectBeginUserAction connects the callback to the 'begin-user-action' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectBeginUserAction to remove it.
*/
func (recv *TextBuffer) ConnectBeginUserAction(callback TextBufferSignalBeginUserActionCallback) int {
	signalTextBufferBeginUserActionLock.Lock()
	defer signalTextBufferBeginUserActionLock.Unlock()

	signalTextBufferBeginUserActionId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_begin_user_action(instance, C.gpointer(uintptr(signalTextBufferBeginUserActionId)))

	detail := signalTextBufferBeginUserActionDetail{callback, handlerID}
	signalTextBufferBeginUserActionMap[signalTextBufferBeginUserActionId] = detail

	return signalTextBufferBeginUserActionId
}

/*
DisconnectBeginUserAction disconnects a callback from the 'begin-user-action' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectBeginUserAction.
*/
func (recv *TextBuffer) DisconnectBeginUserAction(connectionID int) {
	signalTextBufferBeginUserActionLock.Lock()
	defer signalTextBufferBeginUserActionLock.Unlock()

	detail, exists := signalTextBufferBeginUserActionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferBeginUserActionMap, connectionID)
}

//export textbuffer_beginUserActionHandler
func textbuffer_beginUserActionHandler(_ *C.GObject, data C.gpointer) {
	signalTextBufferBeginUserActionLock.RLock()
	defer signalTextBufferBeginUserActionLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextBufferBeginUserActionMap[index].callback
	callback()
}

type signalTextBufferChangedDetail struct {
	callback  TextBufferSignalChangedCallback
	handlerID C.gulong
}

var signalTextBufferChangedId int
var signalTextBufferChangedMap = make(map[int]signalTextBufferChangedDetail)
var signalTextBufferChangedLock sync.RWMutex

// TextBufferSignalChangedCallback is a callback function for a 'changed' signal emitted from a TextBuffer.
type TextBufferSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *TextBuffer) ConnectChanged(callback TextBufferSignalChangedCallback) int {
	signalTextBufferChangedLock.Lock()
	defer signalTextBufferChangedLock.Unlock()

	signalTextBufferChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_changed(instance, C.gpointer(uintptr(signalTextBufferChangedId)))

	detail := signalTextBufferChangedDetail{callback, handlerID}
	signalTextBufferChangedMap[signalTextBufferChangedId] = detail

	return signalTextBufferChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *TextBuffer) DisconnectChanged(connectionID int) {
	signalTextBufferChangedLock.Lock()
	defer signalTextBufferChangedLock.Unlock()

	detail, exists := signalTextBufferChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferChangedMap, connectionID)
}

//export textbuffer_changedHandler
func textbuffer_changedHandler(_ *C.GObject, data C.gpointer) {
	signalTextBufferChangedLock.RLock()
	defer signalTextBufferChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextBufferChangedMap[index].callback
	callback()
}

type signalTextBufferDeleteRangeDetail struct {
	callback  TextBufferSignalDeleteRangeCallback
	handlerID C.gulong
}

var signalTextBufferDeleteRangeId int
var signalTextBufferDeleteRangeMap = make(map[int]signalTextBufferDeleteRangeDetail)
var signalTextBufferDeleteRangeLock sync.RWMutex

// TextBufferSignalDeleteRangeCallback is a callback function for a 'delete-range' signal emitted from a TextBuffer.
type TextBufferSignalDeleteRangeCallback func(start *TextIter, end *TextIter)

/*
ConnectDeleteRange connects the callback to the 'delete-range' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectDeleteRange to remove it.
*/
func (recv *TextBuffer) ConnectDeleteRange(callback TextBufferSignalDeleteRangeCallback) int {
	signalTextBufferDeleteRangeLock.Lock()
	defer signalTextBufferDeleteRangeLock.Unlock()

	signalTextBufferDeleteRangeId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_delete_range(instance, C.gpointer(uintptr(signalTextBufferDeleteRangeId)))

	detail := signalTextBufferDeleteRangeDetail{callback, handlerID}
	signalTextBufferDeleteRangeMap[signalTextBufferDeleteRangeId] = detail

	return signalTextBufferDeleteRangeId
}

/*
DisconnectDeleteRange disconnects a callback from the 'delete-range' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectDeleteRange.
*/
func (recv *TextBuffer) DisconnectDeleteRange(connectionID int) {
	signalTextBufferDeleteRangeLock.Lock()
	defer signalTextBufferDeleteRangeLock.Unlock()

	detail, exists := signalTextBufferDeleteRangeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferDeleteRangeMap, connectionID)
}

//export textbuffer_deleteRangeHandler
func textbuffer_deleteRangeHandler(_ *C.GObject, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	signalTextBufferDeleteRangeLock.RLock()
	defer signalTextBufferDeleteRangeLock.RUnlock()

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferDeleteRangeMap[index].callback
	callback(start, end)
}

type signalTextBufferEndUserActionDetail struct {
	callback  TextBufferSignalEndUserActionCallback
	handlerID C.gulong
}

var signalTextBufferEndUserActionId int
var signalTextBufferEndUserActionMap = make(map[int]signalTextBufferEndUserActionDetail)
var signalTextBufferEndUserActionLock sync.RWMutex

// TextBufferSignalEndUserActionCallback is a callback function for a 'end-user-action' signal emitted from a TextBuffer.
type TextBufferSignalEndUserActionCallback func()

/*
ConnectEndUserAction connects the callback to the 'end-user-action' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectEndUserAction to remove it.
*/
func (recv *TextBuffer) ConnectEndUserAction(callback TextBufferSignalEndUserActionCallback) int {
	signalTextBufferEndUserActionLock.Lock()
	defer signalTextBufferEndUserActionLock.Unlock()

	signalTextBufferEndUserActionId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_end_user_action(instance, C.gpointer(uintptr(signalTextBufferEndUserActionId)))

	detail := signalTextBufferEndUserActionDetail{callback, handlerID}
	signalTextBufferEndUserActionMap[signalTextBufferEndUserActionId] = detail

	return signalTextBufferEndUserActionId
}

/*
DisconnectEndUserAction disconnects a callback from the 'end-user-action' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectEndUserAction.
*/
func (recv *TextBuffer) DisconnectEndUserAction(connectionID int) {
	signalTextBufferEndUserActionLock.Lock()
	defer signalTextBufferEndUserActionLock.Unlock()

	detail, exists := signalTextBufferEndUserActionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferEndUserActionMap, connectionID)
}

//export textbuffer_endUserActionHandler
func textbuffer_endUserActionHandler(_ *C.GObject, data C.gpointer) {
	signalTextBufferEndUserActionLock.RLock()
	defer signalTextBufferEndUserActionLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextBufferEndUserActionMap[index].callback
	callback()
}

type signalTextBufferInsertChildAnchorDetail struct {
	callback  TextBufferSignalInsertChildAnchorCallback
	handlerID C.gulong
}

var signalTextBufferInsertChildAnchorId int
var signalTextBufferInsertChildAnchorMap = make(map[int]signalTextBufferInsertChildAnchorDetail)
var signalTextBufferInsertChildAnchorLock sync.RWMutex

// TextBufferSignalInsertChildAnchorCallback is a callback function for a 'insert-child-anchor' signal emitted from a TextBuffer.
type TextBufferSignalInsertChildAnchorCallback func(location *TextIter, anchor *TextChildAnchor)

/*
ConnectInsertChildAnchor connects the callback to the 'insert-child-anchor' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertChildAnchor to remove it.
*/
func (recv *TextBuffer) ConnectInsertChildAnchor(callback TextBufferSignalInsertChildAnchorCallback) int {
	signalTextBufferInsertChildAnchorLock.Lock()
	defer signalTextBufferInsertChildAnchorLock.Unlock()

	signalTextBufferInsertChildAnchorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_child_anchor(instance, C.gpointer(uintptr(signalTextBufferInsertChildAnchorId)))

	detail := signalTextBufferInsertChildAnchorDetail{callback, handlerID}
	signalTextBufferInsertChildAnchorMap[signalTextBufferInsertChildAnchorId] = detail

	return signalTextBufferInsertChildAnchorId
}

/*
DisconnectInsertChildAnchor disconnects a callback from the 'insert-child-anchor' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertChildAnchor.
*/
func (recv *TextBuffer) DisconnectInsertChildAnchor(connectionID int) {
	signalTextBufferInsertChildAnchorLock.Lock()
	defer signalTextBufferInsertChildAnchorLock.Unlock()

	detail, exists := signalTextBufferInsertChildAnchorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertChildAnchorMap, connectionID)
}

//export textbuffer_insertChildAnchorHandler
func textbuffer_insertChildAnchorHandler(_ *C.GObject, c_location *C.GtkTextIter, c_anchor *C.GtkTextChildAnchor, data C.gpointer) {
	signalTextBufferInsertChildAnchorLock.RLock()
	defer signalTextBufferInsertChildAnchorLock.RUnlock()

	location := TextIterNewFromC(unsafe.Pointer(c_location))

	anchor := TextChildAnchorNewFromC(unsafe.Pointer(c_anchor))

	index := int(uintptr(data))
	callback := signalTextBufferInsertChildAnchorMap[index].callback
	callback(location, anchor)
}

type signalTextBufferInsertPixbufDetail struct {
	callback  TextBufferSignalInsertPixbufCallback
	handlerID C.gulong
}

var signalTextBufferInsertPixbufId int
var signalTextBufferInsertPixbufMap = make(map[int]signalTextBufferInsertPixbufDetail)
var signalTextBufferInsertPixbufLock sync.RWMutex

// TextBufferSignalInsertPixbufCallback is a callback function for a 'insert-pixbuf' signal emitted from a TextBuffer.
type TextBufferSignalInsertPixbufCallback func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf)

/*
ConnectInsertPixbuf connects the callback to the 'insert-pixbuf' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertPixbuf to remove it.
*/
func (recv *TextBuffer) ConnectInsertPixbuf(callback TextBufferSignalInsertPixbufCallback) int {
	signalTextBufferInsertPixbufLock.Lock()
	defer signalTextBufferInsertPixbufLock.Unlock()

	signalTextBufferInsertPixbufId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_pixbuf(instance, C.gpointer(uintptr(signalTextBufferInsertPixbufId)))

	detail := signalTextBufferInsertPixbufDetail{callback, handlerID}
	signalTextBufferInsertPixbufMap[signalTextBufferInsertPixbufId] = detail

	return signalTextBufferInsertPixbufId
}

/*
DisconnectInsertPixbuf disconnects a callback from the 'insert-pixbuf' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertPixbuf.
*/
func (recv *TextBuffer) DisconnectInsertPixbuf(connectionID int) {
	signalTextBufferInsertPixbufLock.Lock()
	defer signalTextBufferInsertPixbufLock.Unlock()

	detail, exists := signalTextBufferInsertPixbufMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertPixbufMap, connectionID)
}

//export textbuffer_insertPixbufHandler
func textbuffer_insertPixbufHandler(_ *C.GObject, c_location *C.GtkTextIter, c_pixbuf *C.GdkPixbuf, data C.gpointer) {
	signalTextBufferInsertPixbufLock.RLock()
	defer signalTextBufferInsertPixbufLock.RUnlock()

	location := TextIterNewFromC(unsafe.Pointer(c_location))

	pixbuf := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(c_pixbuf))

	index := int(uintptr(data))
	callback := signalTextBufferInsertPixbufMap[index].callback
	callback(location, pixbuf)
}

type signalTextBufferInsertTextDetail struct {
	callback  TextBufferSignalInsertTextCallback
	handlerID C.gulong
}

var signalTextBufferInsertTextId int
var signalTextBufferInsertTextMap = make(map[int]signalTextBufferInsertTextDetail)
var signalTextBufferInsertTextLock sync.RWMutex

// TextBufferSignalInsertTextCallback is a callback function for a 'insert-text' signal emitted from a TextBuffer.
type TextBufferSignalInsertTextCallback func(location *TextIter, text string, len int32)

/*
ConnectInsertText connects the callback to the 'insert-text' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertText to remove it.
*/
func (recv *TextBuffer) ConnectInsertText(callback TextBufferSignalInsertTextCallback) int {
	signalTextBufferInsertTextLock.Lock()
	defer signalTextBufferInsertTextLock.Unlock()

	signalTextBufferInsertTextId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_text(instance, C.gpointer(uintptr(signalTextBufferInsertTextId)))

	detail := signalTextBufferInsertTextDetail{callback, handlerID}
	signalTextBufferInsertTextMap[signalTextBufferInsertTextId] = detail

	return signalTextBufferInsertTextId
}

/*
DisconnectInsertText disconnects a callback from the 'insert-text' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertText.
*/
func (recv *TextBuffer) DisconnectInsertText(connectionID int) {
	signalTextBufferInsertTextLock.Lock()
	defer signalTextBufferInsertTextLock.Unlock()

	detail, exists := signalTextBufferInsertTextMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertTextMap, connectionID)
}

//export textbuffer_insertTextHandler
func textbuffer_insertTextHandler(_ *C.GObject, c_location *C.GtkTextIter, c_text *C.gchar, c_len C.gint, data C.gpointer) {
	signalTextBufferInsertTextLock.RLock()
	defer signalTextBufferInsertTextLock.RUnlock()

	location := TextIterNewFromC(unsafe.Pointer(c_location))

	text := C.GoString(c_text)

	len := int32(c_len)

	index := int(uintptr(data))
	callback := signalTextBufferInsertTextMap[index].callback
	callback(location, text, len)
}

type signalTextBufferMarkDeletedDetail struct {
	callback  TextBufferSignalMarkDeletedCallback
	handlerID C.gulong
}

var signalTextBufferMarkDeletedId int
var signalTextBufferMarkDeletedMap = make(map[int]signalTextBufferMarkDeletedDetail)
var signalTextBufferMarkDeletedLock sync.RWMutex

// TextBufferSignalMarkDeletedCallback is a callback function for a 'mark-deleted' signal emitted from a TextBuffer.
type TextBufferSignalMarkDeletedCallback func(mark *TextMark)

/*
ConnectMarkDeleted connects the callback to the 'mark-deleted' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectMarkDeleted to remove it.
*/
func (recv *TextBuffer) ConnectMarkDeleted(callback TextBufferSignalMarkDeletedCallback) int {
	signalTextBufferMarkDeletedLock.Lock()
	defer signalTextBufferMarkDeletedLock.Unlock()

	signalTextBufferMarkDeletedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_mark_deleted(instance, C.gpointer(uintptr(signalTextBufferMarkDeletedId)))

	detail := signalTextBufferMarkDeletedDetail{callback, handlerID}
	signalTextBufferMarkDeletedMap[signalTextBufferMarkDeletedId] = detail

	return signalTextBufferMarkDeletedId
}

/*
DisconnectMarkDeleted disconnects a callback from the 'mark-deleted' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectMarkDeleted.
*/
func (recv *TextBuffer) DisconnectMarkDeleted(connectionID int) {
	signalTextBufferMarkDeletedLock.Lock()
	defer signalTextBufferMarkDeletedLock.Unlock()

	detail, exists := signalTextBufferMarkDeletedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferMarkDeletedMap, connectionID)
}

//export textbuffer_markDeletedHandler
func textbuffer_markDeletedHandler(_ *C.GObject, c_mark *C.GtkTextMark, data C.gpointer) {
	signalTextBufferMarkDeletedLock.RLock()
	defer signalTextBufferMarkDeletedLock.RUnlock()

	mark := TextMarkNewFromC(unsafe.Pointer(c_mark))

	index := int(uintptr(data))
	callback := signalTextBufferMarkDeletedMap[index].callback
	callback(mark)
}

type signalTextBufferMarkSetDetail struct {
	callback  TextBufferSignalMarkSetCallback
	handlerID C.gulong
}

var signalTextBufferMarkSetId int
var signalTextBufferMarkSetMap = make(map[int]signalTextBufferMarkSetDetail)
var signalTextBufferMarkSetLock sync.RWMutex

// TextBufferSignalMarkSetCallback is a callback function for a 'mark-set' signal emitted from a TextBuffer.
type TextBufferSignalMarkSetCallback func(location *TextIter, mark *TextMark)

/*
ConnectMarkSet connects the callback to the 'mark-set' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectMarkSet to remove it.
*/
func (recv *TextBuffer) ConnectMarkSet(callback TextBufferSignalMarkSetCallback) int {
	signalTextBufferMarkSetLock.Lock()
	defer signalTextBufferMarkSetLock.Unlock()

	signalTextBufferMarkSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_mark_set(instance, C.gpointer(uintptr(signalTextBufferMarkSetId)))

	detail := signalTextBufferMarkSetDetail{callback, handlerID}
	signalTextBufferMarkSetMap[signalTextBufferMarkSetId] = detail

	return signalTextBufferMarkSetId
}

/*
DisconnectMarkSet disconnects a callback from the 'mark-set' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectMarkSet.
*/
func (recv *TextBuffer) DisconnectMarkSet(connectionID int) {
	signalTextBufferMarkSetLock.Lock()
	defer signalTextBufferMarkSetLock.Unlock()

	detail, exists := signalTextBufferMarkSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferMarkSetMap, connectionID)
}

//export textbuffer_markSetHandler
func textbuffer_markSetHandler(_ *C.GObject, c_location *C.GtkTextIter, c_mark *C.GtkTextMark, data C.gpointer) {
	signalTextBufferMarkSetLock.RLock()
	defer signalTextBufferMarkSetLock.RUnlock()

	location := TextIterNewFromC(unsafe.Pointer(c_location))

	mark := TextMarkNewFromC(unsafe.Pointer(c_mark))

	index := int(uintptr(data))
	callback := signalTextBufferMarkSetMap[index].callback
	callback(location, mark)
}

type signalTextBufferModifiedChangedDetail struct {
	callback  TextBufferSignalModifiedChangedCallback
	handlerID C.gulong
}

var signalTextBufferModifiedChangedId int
var signalTextBufferModifiedChangedMap = make(map[int]signalTextBufferModifiedChangedDetail)
var signalTextBufferModifiedChangedLock sync.RWMutex

// TextBufferSignalModifiedChangedCallback is a callback function for a 'modified-changed' signal emitted from a TextBuffer.
type TextBufferSignalModifiedChangedCallback func()

/*
ConnectModifiedChanged connects the callback to the 'modified-changed' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectModifiedChanged to remove it.
*/
func (recv *TextBuffer) ConnectModifiedChanged(callback TextBufferSignalModifiedChangedCallback) int {
	signalTextBufferModifiedChangedLock.Lock()
	defer signalTextBufferModifiedChangedLock.Unlock()

	signalTextBufferModifiedChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_modified_changed(instance, C.gpointer(uintptr(signalTextBufferModifiedChangedId)))

	detail := signalTextBufferModifiedChangedDetail{callback, handlerID}
	signalTextBufferModifiedChangedMap[signalTextBufferModifiedChangedId] = detail

	return signalTextBufferModifiedChangedId
}

/*
DisconnectModifiedChanged disconnects a callback from the 'modified-changed' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectModifiedChanged.
*/
func (recv *TextBuffer) DisconnectModifiedChanged(connectionID int) {
	signalTextBufferModifiedChangedLock.Lock()
	defer signalTextBufferModifiedChangedLock.Unlock()

	detail, exists := signalTextBufferModifiedChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferModifiedChangedMap, connectionID)
}

//export textbuffer_modifiedChangedHandler
func textbuffer_modifiedChangedHandler(_ *C.GObject, data C.gpointer) {
	signalTextBufferModifiedChangedLock.RLock()
	defer signalTextBufferModifiedChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextBufferModifiedChangedMap[index].callback
	callback()
}

type signalTextBufferRemoveTagDetail struct {
	callback  TextBufferSignalRemoveTagCallback
	handlerID C.gulong
}

var signalTextBufferRemoveTagId int
var signalTextBufferRemoveTagMap = make(map[int]signalTextBufferRemoveTagDetail)
var signalTextBufferRemoveTagLock sync.RWMutex

// TextBufferSignalRemoveTagCallback is a callback function for a 'remove-tag' signal emitted from a TextBuffer.
type TextBufferSignalRemoveTagCallback func(tag *TextTag, start *TextIter, end *TextIter)

/*
ConnectRemoveTag connects the callback to the 'remove-tag' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectRemoveTag to remove it.
*/
func (recv *TextBuffer) ConnectRemoveTag(callback TextBufferSignalRemoveTagCallback) int {
	signalTextBufferRemoveTagLock.Lock()
	defer signalTextBufferRemoveTagLock.Unlock()

	signalTextBufferRemoveTagId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_remove_tag(instance, C.gpointer(uintptr(signalTextBufferRemoveTagId)))

	detail := signalTextBufferRemoveTagDetail{callback, handlerID}
	signalTextBufferRemoveTagMap[signalTextBufferRemoveTagId] = detail

	return signalTextBufferRemoveTagId
}

/*
DisconnectRemoveTag disconnects a callback from the 'remove-tag' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectRemoveTag.
*/
func (recv *TextBuffer) DisconnectRemoveTag(connectionID int) {
	signalTextBufferRemoveTagLock.Lock()
	defer signalTextBufferRemoveTagLock.Unlock()

	detail, exists := signalTextBufferRemoveTagMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferRemoveTagMap, connectionID)
}

//export textbuffer_removeTagHandler
func textbuffer_removeTagHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	signalTextBufferRemoveTagLock.RLock()
	defer signalTextBufferRemoveTagLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferRemoveTagMap[index].callback
	callback(tag, start, end)
}

// Blacklisted : gtk_text_buffer_new

// Blacklisted : gtk_text_buffer_add_selection_clipboard

// Blacklisted : gtk_text_buffer_apply_tag

// Blacklisted : gtk_text_buffer_apply_tag_by_name

// Blacklisted : gtk_text_buffer_begin_user_action

// Blacklisted : gtk_text_buffer_copy_clipboard

// Blacklisted : gtk_text_buffer_create_child_anchor

// Blacklisted : gtk_text_buffer_create_mark

// Unsupported : gtk_text_buffer_create_tag : unsupported parameter ... : varargs

// Blacklisted : gtk_text_buffer_cut_clipboard

// Blacklisted : gtk_text_buffer_delete

// Blacklisted : gtk_text_buffer_delete_interactive

// Blacklisted : gtk_text_buffer_delete_mark

// Blacklisted : gtk_text_buffer_delete_mark_by_name

// Blacklisted : gtk_text_buffer_delete_selection

// Blacklisted : gtk_text_buffer_end_user_action

// Blacklisted : gtk_text_buffer_get_bounds

// Blacklisted : gtk_text_buffer_get_char_count

// Blacklisted : gtk_text_buffer_get_end_iter

// Blacklisted : gtk_text_buffer_get_insert

// Blacklisted : gtk_text_buffer_get_iter_at_child_anchor

// Blacklisted : gtk_text_buffer_get_iter_at_line

// Blacklisted : gtk_text_buffer_get_iter_at_line_index

// Blacklisted : gtk_text_buffer_get_iter_at_line_offset

// Blacklisted : gtk_text_buffer_get_iter_at_mark

// Blacklisted : gtk_text_buffer_get_iter_at_offset

// Blacklisted : gtk_text_buffer_get_line_count

// Blacklisted : gtk_text_buffer_get_mark

// Blacklisted : gtk_text_buffer_get_modified

// Blacklisted : gtk_text_buffer_get_selection_bound

// Blacklisted : gtk_text_buffer_get_selection_bounds

// Blacklisted : gtk_text_buffer_get_slice

// Blacklisted : gtk_text_buffer_get_start_iter

// Blacklisted : gtk_text_buffer_get_tag_table

// GetText is a wrapper around the C function gtk_text_buffer_get_text.
func (recv *TextBuffer) GetText(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_include_hidden_chars :=
		boolToGboolean(includeHiddenChars)

	retC := C.gtk_text_buffer_get_text((*C.GtkTextBuffer)(recv.native), c_start, c_end, c_include_hidden_chars)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Blacklisted : gtk_text_buffer_insert

// Blacklisted : gtk_text_buffer_insert_at_cursor

// Blacklisted : gtk_text_buffer_insert_child_anchor

// Blacklisted : gtk_text_buffer_insert_interactive

// Blacklisted : gtk_text_buffer_insert_interactive_at_cursor

// Blacklisted : gtk_text_buffer_insert_pixbuf

// Blacklisted : gtk_text_buffer_insert_range

// Blacklisted : gtk_text_buffer_insert_range_interactive

// Unsupported : gtk_text_buffer_insert_with_tags : unsupported parameter ... : varargs

// Unsupported : gtk_text_buffer_insert_with_tags_by_name : unsupported parameter ... : varargs

// Blacklisted : gtk_text_buffer_move_mark

// Blacklisted : gtk_text_buffer_move_mark_by_name

// Blacklisted : gtk_text_buffer_paste_clipboard

// Blacklisted : gtk_text_buffer_place_cursor

// Blacklisted : gtk_text_buffer_remove_all_tags

// Blacklisted : gtk_text_buffer_remove_selection_clipboard

// Blacklisted : gtk_text_buffer_remove_tag

// Blacklisted : gtk_text_buffer_remove_tag_by_name

// Blacklisted : gtk_text_buffer_set_modified

// SetText is a wrapper around the C function gtk_text_buffer_set_text.
func (recv *TextBuffer) SetText(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_set_text((*C.GtkTextBuffer)(recv.native), c_text, c_len)

	return
}

// TextCellAccessible is a wrapper around the C record GtkTextCellAccessible.
type TextCellAccessible struct {
	native *C.GtkTextCellAccessible
	// parent : record
	// priv : record
}

func TextCellAccessibleNewFromC(u unsafe.Pointer) *TextCellAccessible {
	c := (*C.GtkTextCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TextCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextCellAccessible with another TextCellAccessible, and returns true if they represent the same GObject.
func (recv *TextCellAccessible) Equals(other *TextCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *TextCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *TextCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TextCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TextCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to TextCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextCellAccessible.
func CastToTextCellAccessible(object *gobject.Object) *TextCellAccessible {
	return TextCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// TextChildAnchor is a wrapper around the C record GtkTextChildAnchor.
type TextChildAnchor struct {
	native *C.GtkTextChildAnchor
	// parent_instance : record
	// Private : segment
}

func TextChildAnchorNewFromC(u unsafe.Pointer) *TextChildAnchor {
	c := (*C.GtkTextChildAnchor)(u)
	if c == nil {
		return nil
	}

	g := &TextChildAnchor{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextChildAnchor) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextChildAnchor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextChildAnchor with another TextChildAnchor, and returns true if they represent the same GObject.
func (recv *TextChildAnchor) Equals(other *TextChildAnchor) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextChildAnchor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextChildAnchor.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextChildAnchor.
func CastToTextChildAnchor(object *gobject.Object) *TextChildAnchor {
	return TextChildAnchorNewFromC(object.ToC())
}

// Blacklisted : gtk_text_child_anchor_new

// Blacklisted : gtk_text_child_anchor_get_deleted

// Blacklisted : gtk_text_child_anchor_get_widgets

// TextMark is a wrapper around the C record GtkTextMark.
type TextMark struct {
	native *C.GtkTextMark
	// parent_instance : record
	// Private : segment
}

func TextMarkNewFromC(u unsafe.Pointer) *TextMark {
	c := (*C.GtkTextMark)(u)
	if c == nil {
		return nil
	}

	g := &TextMark{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextMark) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextMark) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextMark with another TextMark, and returns true if they represent the same GObject.
func (recv *TextMark) Equals(other *TextMark) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextMark) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextMark.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextMark.
func CastToTextMark(object *gobject.Object) *TextMark {
	return TextMarkNewFromC(object.ToC())
}

// Blacklisted : gtk_text_mark_get_buffer

// Blacklisted : gtk_text_mark_get_deleted

// Blacklisted : gtk_text_mark_get_left_gravity

// Blacklisted : gtk_text_mark_get_name

// Blacklisted : gtk_text_mark_get_visible

// Blacklisted : gtk_text_mark_set_visible

// TextTag is a wrapper around the C record GtkTextTag.
type TextTag struct {
	native *C.GtkTextTag
	// parent_instance : record
	// priv : record
}

func TextTagNewFromC(u unsafe.Pointer) *TextTag {
	c := (*C.GtkTextTag)(u)
	if c == nil {
		return nil
	}

	g := &TextTag{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextTag) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextTag) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextTag with another TextTag, and returns true if they represent the same GObject.
func (recv *TextTag) Equals(other *TextTag) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextTag) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextTag.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextTag.
func CastToTextTag(object *gobject.Object) *TextTag {
	return TextTagNewFromC(object.ToC())
}

// Unsupported signal 'event' for TextTag : unsupported parameter event : no type generator for Gdk.Event,

// Blacklisted : gtk_text_tag_new

// Unsupported : gtk_text_tag_event : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Blacklisted : gtk_text_tag_get_priority

// Blacklisted : gtk_text_tag_set_priority

// TextTagTable is a wrapper around the C record GtkTextTagTable.
type TextTagTable struct {
	native *C.GtkTextTagTable
	// parent_instance : record
	// priv : record
}

func TextTagTableNewFromC(u unsafe.Pointer) *TextTagTable {
	c := (*C.GtkTextTagTable)(u)
	if c == nil {
		return nil
	}

	g := &TextTagTable{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextTagTable) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextTagTable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextTagTable with another TextTagTable, and returns true if they represent the same GObject.
func (recv *TextTagTable) Equals(other *TextTagTable) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextTagTable) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextTagTable.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextTagTable.
func CastToTextTagTable(object *gobject.Object) *TextTagTable {
	return TextTagTableNewFromC(object.ToC())
}

type signalTextTagTableTagAddedDetail struct {
	callback  TextTagTableSignalTagAddedCallback
	handlerID C.gulong
}

var signalTextTagTableTagAddedId int
var signalTextTagTableTagAddedMap = make(map[int]signalTextTagTableTagAddedDetail)
var signalTextTagTableTagAddedLock sync.RWMutex

// TextTagTableSignalTagAddedCallback is a callback function for a 'tag-added' signal emitted from a TextTagTable.
type TextTagTableSignalTagAddedCallback func(tag *TextTag)

/*
ConnectTagAdded connects the callback to the 'tag-added' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagAdded to remove it.
*/
func (recv *TextTagTable) ConnectTagAdded(callback TextTagTableSignalTagAddedCallback) int {
	signalTextTagTableTagAddedLock.Lock()
	defer signalTextTagTableTagAddedLock.Unlock()

	signalTextTagTableTagAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_added(instance, C.gpointer(uintptr(signalTextTagTableTagAddedId)))

	detail := signalTextTagTableTagAddedDetail{callback, handlerID}
	signalTextTagTableTagAddedMap[signalTextTagTableTagAddedId] = detail

	return signalTextTagTableTagAddedId
}

/*
DisconnectTagAdded disconnects a callback from the 'tag-added' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagAdded.
*/
func (recv *TextTagTable) DisconnectTagAdded(connectionID int) {
	signalTextTagTableTagAddedLock.Lock()
	defer signalTextTagTableTagAddedLock.Unlock()

	detail, exists := signalTextTagTableTagAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagAddedMap, connectionID)
}

//export texttagtable_tagAddedHandler
func texttagtable_tagAddedHandler(_ *C.GObject, c_tag *C.GtkTextTag, data C.gpointer) {
	signalTextTagTableTagAddedLock.RLock()
	defer signalTextTagTableTagAddedLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	index := int(uintptr(data))
	callback := signalTextTagTableTagAddedMap[index].callback
	callback(tag)
}

type signalTextTagTableTagChangedDetail struct {
	callback  TextTagTableSignalTagChangedCallback
	handlerID C.gulong
}

var signalTextTagTableTagChangedId int
var signalTextTagTableTagChangedMap = make(map[int]signalTextTagTableTagChangedDetail)
var signalTextTagTableTagChangedLock sync.RWMutex

// TextTagTableSignalTagChangedCallback is a callback function for a 'tag-changed' signal emitted from a TextTagTable.
type TextTagTableSignalTagChangedCallback func(tag *TextTag, sizeChanged bool)

/*
ConnectTagChanged connects the callback to the 'tag-changed' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagChanged to remove it.
*/
func (recv *TextTagTable) ConnectTagChanged(callback TextTagTableSignalTagChangedCallback) int {
	signalTextTagTableTagChangedLock.Lock()
	defer signalTextTagTableTagChangedLock.Unlock()

	signalTextTagTableTagChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_changed(instance, C.gpointer(uintptr(signalTextTagTableTagChangedId)))

	detail := signalTextTagTableTagChangedDetail{callback, handlerID}
	signalTextTagTableTagChangedMap[signalTextTagTableTagChangedId] = detail

	return signalTextTagTableTagChangedId
}

/*
DisconnectTagChanged disconnects a callback from the 'tag-changed' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagChanged.
*/
func (recv *TextTagTable) DisconnectTagChanged(connectionID int) {
	signalTextTagTableTagChangedLock.Lock()
	defer signalTextTagTableTagChangedLock.Unlock()

	detail, exists := signalTextTagTableTagChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagChangedMap, connectionID)
}

//export texttagtable_tagChangedHandler
func texttagtable_tagChangedHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_size_changed C.gboolean, data C.gpointer) {
	signalTextTagTableTagChangedLock.RLock()
	defer signalTextTagTableTagChangedLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	sizeChanged := c_size_changed == C.TRUE

	index := int(uintptr(data))
	callback := signalTextTagTableTagChangedMap[index].callback
	callback(tag, sizeChanged)
}

type signalTextTagTableTagRemovedDetail struct {
	callback  TextTagTableSignalTagRemovedCallback
	handlerID C.gulong
}

var signalTextTagTableTagRemovedId int
var signalTextTagTableTagRemovedMap = make(map[int]signalTextTagTableTagRemovedDetail)
var signalTextTagTableTagRemovedLock sync.RWMutex

// TextTagTableSignalTagRemovedCallback is a callback function for a 'tag-removed' signal emitted from a TextTagTable.
type TextTagTableSignalTagRemovedCallback func(tag *TextTag)

/*
ConnectTagRemoved connects the callback to the 'tag-removed' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagRemoved to remove it.
*/
func (recv *TextTagTable) ConnectTagRemoved(callback TextTagTableSignalTagRemovedCallback) int {
	signalTextTagTableTagRemovedLock.Lock()
	defer signalTextTagTableTagRemovedLock.Unlock()

	signalTextTagTableTagRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_removed(instance, C.gpointer(uintptr(signalTextTagTableTagRemovedId)))

	detail := signalTextTagTableTagRemovedDetail{callback, handlerID}
	signalTextTagTableTagRemovedMap[signalTextTagTableTagRemovedId] = detail

	return signalTextTagTableTagRemovedId
}

/*
DisconnectTagRemoved disconnects a callback from the 'tag-removed' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagRemoved.
*/
func (recv *TextTagTable) DisconnectTagRemoved(connectionID int) {
	signalTextTagTableTagRemovedLock.Lock()
	defer signalTextTagTableTagRemovedLock.Unlock()

	detail, exists := signalTextTagTableTagRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagRemovedMap, connectionID)
}

//export texttagtable_tagRemovedHandler
func texttagtable_tagRemovedHandler(_ *C.GObject, c_tag *C.GtkTextTag, data C.gpointer) {
	signalTextTagTableTagRemovedLock.RLock()
	defer signalTextTagTableTagRemovedLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	index := int(uintptr(data))
	callback := signalTextTagTableTagRemovedMap[index].callback
	callback(tag)
}

// Blacklisted : gtk_text_tag_table_new

// Blacklisted : gtk_text_tag_table_add

// Unsupported : gtk_text_tag_table_foreach : unsupported parameter func : no type generator for TextTagTableForeach (GtkTextTagTableForeach) for param func

// Blacklisted : gtk_text_tag_table_get_size

// Blacklisted : gtk_text_tag_table_lookup

// Blacklisted : gtk_text_tag_table_remove

// Buildable returns the Buildable interface implemented by TextTagTable
func (recv *TextTagTable) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TextView is a wrapper around the C record GtkTextView.
type TextView struct {
	native *C.GtkTextView
	// parent_instance : record
	// Private : priv
}

func TextViewNewFromC(u unsafe.Pointer) *TextView {
	c := (*C.GtkTextView)(u)
	if c == nil {
		return nil
	}

	g := &TextView{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextView) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextView with another TextView, and returns true if they represent the same GObject.
func (recv *TextView) Equals(other *TextView) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *TextView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *TextView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TextView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TextView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to TextView.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextView.
func CastToTextView(object *gobject.Object) *TextView {
	return TextViewNewFromC(object.ToC())
}

type signalTextViewBackspaceDetail struct {
	callback  TextViewSignalBackspaceCallback
	handlerID C.gulong
}

var signalTextViewBackspaceId int
var signalTextViewBackspaceMap = make(map[int]signalTextViewBackspaceDetail)
var signalTextViewBackspaceLock sync.RWMutex

// TextViewSignalBackspaceCallback is a callback function for a 'backspace' signal emitted from a TextView.
type TextViewSignalBackspaceCallback func()

/*
ConnectBackspace connects the callback to the 'backspace' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectBackspace to remove it.
*/
func (recv *TextView) ConnectBackspace(callback TextViewSignalBackspaceCallback) int {
	signalTextViewBackspaceLock.Lock()
	defer signalTextViewBackspaceLock.Unlock()

	signalTextViewBackspaceId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_backspace(instance, C.gpointer(uintptr(signalTextViewBackspaceId)))

	detail := signalTextViewBackspaceDetail{callback, handlerID}
	signalTextViewBackspaceMap[signalTextViewBackspaceId] = detail

	return signalTextViewBackspaceId
}

/*
DisconnectBackspace disconnects a callback from the 'backspace' signal for the TextView.

The connectionID should be a value returned from a call to ConnectBackspace.
*/
func (recv *TextView) DisconnectBackspace(connectionID int) {
	signalTextViewBackspaceLock.Lock()
	defer signalTextViewBackspaceLock.Unlock()

	detail, exists := signalTextViewBackspaceMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewBackspaceMap, connectionID)
}

//export textview_backspaceHandler
func textview_backspaceHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewBackspaceLock.RLock()
	defer signalTextViewBackspaceLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewBackspaceMap[index].callback
	callback()
}

type signalTextViewCopyClipboardDetail struct {
	callback  TextViewSignalCopyClipboardCallback
	handlerID C.gulong
}

var signalTextViewCopyClipboardId int
var signalTextViewCopyClipboardMap = make(map[int]signalTextViewCopyClipboardDetail)
var signalTextViewCopyClipboardLock sync.RWMutex

// TextViewSignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a TextView.
type TextViewSignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *TextView) ConnectCopyClipboard(callback TextViewSignalCopyClipboardCallback) int {
	signalTextViewCopyClipboardLock.Lock()
	defer signalTextViewCopyClipboardLock.Unlock()

	signalTextViewCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalTextViewCopyClipboardId)))

	detail := signalTextViewCopyClipboardDetail{callback, handlerID}
	signalTextViewCopyClipboardMap[signalTextViewCopyClipboardId] = detail

	return signalTextViewCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *TextView) DisconnectCopyClipboard(connectionID int) {
	signalTextViewCopyClipboardLock.Lock()
	defer signalTextViewCopyClipboardLock.Unlock()

	detail, exists := signalTextViewCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewCopyClipboardMap, connectionID)
}

//export textview_copyClipboardHandler
func textview_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewCopyClipboardLock.RLock()
	defer signalTextViewCopyClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewCopyClipboardMap[index].callback
	callback()
}

type signalTextViewCutClipboardDetail struct {
	callback  TextViewSignalCutClipboardCallback
	handlerID C.gulong
}

var signalTextViewCutClipboardId int
var signalTextViewCutClipboardMap = make(map[int]signalTextViewCutClipboardDetail)
var signalTextViewCutClipboardLock sync.RWMutex

// TextViewSignalCutClipboardCallback is a callback function for a 'cut-clipboard' signal emitted from a TextView.
type TextViewSignalCutClipboardCallback func()

/*
ConnectCutClipboard connects the callback to the 'cut-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectCutClipboard to remove it.
*/
func (recv *TextView) ConnectCutClipboard(callback TextViewSignalCutClipboardCallback) int {
	signalTextViewCutClipboardLock.Lock()
	defer signalTextViewCutClipboardLock.Unlock()

	signalTextViewCutClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_cut_clipboard(instance, C.gpointer(uintptr(signalTextViewCutClipboardId)))

	detail := signalTextViewCutClipboardDetail{callback, handlerID}
	signalTextViewCutClipboardMap[signalTextViewCutClipboardId] = detail

	return signalTextViewCutClipboardId
}

/*
DisconnectCutClipboard disconnects a callback from the 'cut-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectCutClipboard.
*/
func (recv *TextView) DisconnectCutClipboard(connectionID int) {
	signalTextViewCutClipboardLock.Lock()
	defer signalTextViewCutClipboardLock.Unlock()

	detail, exists := signalTextViewCutClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewCutClipboardMap, connectionID)
}

//export textview_cutClipboardHandler
func textview_cutClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewCutClipboardLock.RLock()
	defer signalTextViewCutClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewCutClipboardMap[index].callback
	callback()
}

type signalTextViewDeleteFromCursorDetail struct {
	callback  TextViewSignalDeleteFromCursorCallback
	handlerID C.gulong
}

var signalTextViewDeleteFromCursorId int
var signalTextViewDeleteFromCursorMap = make(map[int]signalTextViewDeleteFromCursorDetail)
var signalTextViewDeleteFromCursorLock sync.RWMutex

// TextViewSignalDeleteFromCursorCallback is a callback function for a 'delete-from-cursor' signal emitted from a TextView.
type TextViewSignalDeleteFromCursorCallback func(type_ DeleteType, count int32)

/*
ConnectDeleteFromCursor connects the callback to the 'delete-from-cursor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectDeleteFromCursor to remove it.
*/
func (recv *TextView) ConnectDeleteFromCursor(callback TextViewSignalDeleteFromCursorCallback) int {
	signalTextViewDeleteFromCursorLock.Lock()
	defer signalTextViewDeleteFromCursorLock.Unlock()

	signalTextViewDeleteFromCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_delete_from_cursor(instance, C.gpointer(uintptr(signalTextViewDeleteFromCursorId)))

	detail := signalTextViewDeleteFromCursorDetail{callback, handlerID}
	signalTextViewDeleteFromCursorMap[signalTextViewDeleteFromCursorId] = detail

	return signalTextViewDeleteFromCursorId
}

/*
DisconnectDeleteFromCursor disconnects a callback from the 'delete-from-cursor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectDeleteFromCursor.
*/
func (recv *TextView) DisconnectDeleteFromCursor(connectionID int) {
	signalTextViewDeleteFromCursorLock.Lock()
	defer signalTextViewDeleteFromCursorLock.Unlock()

	detail, exists := signalTextViewDeleteFromCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewDeleteFromCursorMap, connectionID)
}

//export textview_deleteFromCursorHandler
func textview_deleteFromCursorHandler(_ *C.GObject, c_type C.GtkDeleteType, c_count C.gint, data C.gpointer) {
	signalTextViewDeleteFromCursorLock.RLock()
	defer signalTextViewDeleteFromCursorLock.RUnlock()

	type_ := DeleteType(c_type)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalTextViewDeleteFromCursorMap[index].callback
	callback(type_, count)
}

type signalTextViewInsertAtCursorDetail struct {
	callback  TextViewSignalInsertAtCursorCallback
	handlerID C.gulong
}

var signalTextViewInsertAtCursorId int
var signalTextViewInsertAtCursorMap = make(map[int]signalTextViewInsertAtCursorDetail)
var signalTextViewInsertAtCursorLock sync.RWMutex

// TextViewSignalInsertAtCursorCallback is a callback function for a 'insert-at-cursor' signal emitted from a TextView.
type TextViewSignalInsertAtCursorCallback func(string_ string)

/*
ConnectInsertAtCursor connects the callback to the 'insert-at-cursor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectInsertAtCursor to remove it.
*/
func (recv *TextView) ConnectInsertAtCursor(callback TextViewSignalInsertAtCursorCallback) int {
	signalTextViewInsertAtCursorLock.Lock()
	defer signalTextViewInsertAtCursorLock.Unlock()

	signalTextViewInsertAtCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_insert_at_cursor(instance, C.gpointer(uintptr(signalTextViewInsertAtCursorId)))

	detail := signalTextViewInsertAtCursorDetail{callback, handlerID}
	signalTextViewInsertAtCursorMap[signalTextViewInsertAtCursorId] = detail

	return signalTextViewInsertAtCursorId
}

/*
DisconnectInsertAtCursor disconnects a callback from the 'insert-at-cursor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectInsertAtCursor.
*/
func (recv *TextView) DisconnectInsertAtCursor(connectionID int) {
	signalTextViewInsertAtCursorLock.Lock()
	defer signalTextViewInsertAtCursorLock.Unlock()

	detail, exists := signalTextViewInsertAtCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewInsertAtCursorMap, connectionID)
}

//export textview_insertAtCursorHandler
func textview_insertAtCursorHandler(_ *C.GObject, c_string *C.gchar, data C.gpointer) {
	signalTextViewInsertAtCursorLock.RLock()
	defer signalTextViewInsertAtCursorLock.RUnlock()

	string_ := C.GoString(c_string)

	index := int(uintptr(data))
	callback := signalTextViewInsertAtCursorMap[index].callback
	callback(string_)
}

type signalTextViewMoveCursorDetail struct {
	callback  TextViewSignalMoveCursorCallback
	handlerID C.gulong
}

var signalTextViewMoveCursorId int
var signalTextViewMoveCursorMap = make(map[int]signalTextViewMoveCursorDetail)
var signalTextViewMoveCursorLock sync.RWMutex

// TextViewSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a TextView.
type TextViewSignalMoveCursorCallback func(step MovementStep, count int32, extendSelection bool)

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *TextView) ConnectMoveCursor(callback TextViewSignalMoveCursorCallback) int {
	signalTextViewMoveCursorLock.Lock()
	defer signalTextViewMoveCursorLock.Unlock()

	signalTextViewMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalTextViewMoveCursorId)))

	detail := signalTextViewMoveCursorDetail{callback, handlerID}
	signalTextViewMoveCursorMap[signalTextViewMoveCursorId] = detail

	return signalTextViewMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *TextView) DisconnectMoveCursor(connectionID int) {
	signalTextViewMoveCursorLock.Lock()
	defer signalTextViewMoveCursorLock.Unlock()

	detail, exists := signalTextViewMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewMoveCursorMap, connectionID)
}

//export textview_moveCursorHandler
func textview_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, c_extend_selection C.gboolean, data C.gpointer) {
	signalTextViewMoveCursorLock.RLock()
	defer signalTextViewMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	extendSelection := c_extend_selection == C.TRUE

	index := int(uintptr(data))
	callback := signalTextViewMoveCursorMap[index].callback
	callback(step, count, extendSelection)
}

type signalTextViewMoveViewportDetail struct {
	callback  TextViewSignalMoveViewportCallback
	handlerID C.gulong
}

var signalTextViewMoveViewportId int
var signalTextViewMoveViewportMap = make(map[int]signalTextViewMoveViewportDetail)
var signalTextViewMoveViewportLock sync.RWMutex

// TextViewSignalMoveViewportCallback is a callback function for a 'move-viewport' signal emitted from a TextView.
type TextViewSignalMoveViewportCallback func(step ScrollStep, count int32)

/*
ConnectMoveViewport connects the callback to the 'move-viewport' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectMoveViewport to remove it.
*/
func (recv *TextView) ConnectMoveViewport(callback TextViewSignalMoveViewportCallback) int {
	signalTextViewMoveViewportLock.Lock()
	defer signalTextViewMoveViewportLock.Unlock()

	signalTextViewMoveViewportId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_move_viewport(instance, C.gpointer(uintptr(signalTextViewMoveViewportId)))

	detail := signalTextViewMoveViewportDetail{callback, handlerID}
	signalTextViewMoveViewportMap[signalTextViewMoveViewportId] = detail

	return signalTextViewMoveViewportId
}

/*
DisconnectMoveViewport disconnects a callback from the 'move-viewport' signal for the TextView.

The connectionID should be a value returned from a call to ConnectMoveViewport.
*/
func (recv *TextView) DisconnectMoveViewport(connectionID int) {
	signalTextViewMoveViewportLock.Lock()
	defer signalTextViewMoveViewportLock.Unlock()

	detail, exists := signalTextViewMoveViewportMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewMoveViewportMap, connectionID)
}

//export textview_moveViewportHandler
func textview_moveViewportHandler(_ *C.GObject, c_step C.GtkScrollStep, c_count C.gint, data C.gpointer) {
	signalTextViewMoveViewportLock.RLock()
	defer signalTextViewMoveViewportLock.RUnlock()

	step := ScrollStep(c_step)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalTextViewMoveViewportMap[index].callback
	callback(step, count)
}

type signalTextViewPasteClipboardDetail struct {
	callback  TextViewSignalPasteClipboardCallback
	handlerID C.gulong
}

var signalTextViewPasteClipboardId int
var signalTextViewPasteClipboardMap = make(map[int]signalTextViewPasteClipboardDetail)
var signalTextViewPasteClipboardLock sync.RWMutex

// TextViewSignalPasteClipboardCallback is a callback function for a 'paste-clipboard' signal emitted from a TextView.
type TextViewSignalPasteClipboardCallback func()

/*
ConnectPasteClipboard connects the callback to the 'paste-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectPasteClipboard to remove it.
*/
func (recv *TextView) ConnectPasteClipboard(callback TextViewSignalPasteClipboardCallback) int {
	signalTextViewPasteClipboardLock.Lock()
	defer signalTextViewPasteClipboardLock.Unlock()

	signalTextViewPasteClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_paste_clipboard(instance, C.gpointer(uintptr(signalTextViewPasteClipboardId)))

	detail := signalTextViewPasteClipboardDetail{callback, handlerID}
	signalTextViewPasteClipboardMap[signalTextViewPasteClipboardId] = detail

	return signalTextViewPasteClipboardId
}

/*
DisconnectPasteClipboard disconnects a callback from the 'paste-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectPasteClipboard.
*/
func (recv *TextView) DisconnectPasteClipboard(connectionID int) {
	signalTextViewPasteClipboardLock.Lock()
	defer signalTextViewPasteClipboardLock.Unlock()

	detail, exists := signalTextViewPasteClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewPasteClipboardMap, connectionID)
}

//export textview_pasteClipboardHandler
func textview_pasteClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewPasteClipboardLock.RLock()
	defer signalTextViewPasteClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewPasteClipboardMap[index].callback
	callback()
}

type signalTextViewPopulatePopupDetail struct {
	callback  TextViewSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalTextViewPopulatePopupId int
var signalTextViewPopulatePopupMap = make(map[int]signalTextViewPopulatePopupDetail)
var signalTextViewPopulatePopupLock sync.RWMutex

// TextViewSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a TextView.
type TextViewSignalPopulatePopupCallback func(popup *Widget)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *TextView) ConnectPopulatePopup(callback TextViewSignalPopulatePopupCallback) int {
	signalTextViewPopulatePopupLock.Lock()
	defer signalTextViewPopulatePopupLock.Unlock()

	signalTextViewPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalTextViewPopulatePopupId)))

	detail := signalTextViewPopulatePopupDetail{callback, handlerID}
	signalTextViewPopulatePopupMap[signalTextViewPopulatePopupId] = detail

	return signalTextViewPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the TextView.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *TextView) DisconnectPopulatePopup(connectionID int) {
	signalTextViewPopulatePopupLock.Lock()
	defer signalTextViewPopulatePopupLock.Unlock()

	detail, exists := signalTextViewPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewPopulatePopupMap, connectionID)
}

//export textview_populatePopupHandler
func textview_populatePopupHandler(_ *C.GObject, c_popup *C.GtkWidget, data C.gpointer) {
	signalTextViewPopulatePopupLock.RLock()
	defer signalTextViewPopulatePopupLock.RUnlock()

	popup := WidgetNewFromC(unsafe.Pointer(c_popup))

	index := int(uintptr(data))
	callback := signalTextViewPopulatePopupMap[index].callback
	callback(popup)
}

type signalTextViewSelectAllDetail struct {
	callback  TextViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalTextViewSelectAllId int
var signalTextViewSelectAllMap = make(map[int]signalTextViewSelectAllDetail)
var signalTextViewSelectAllLock sync.RWMutex

// TextViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a TextView.
type TextViewSignalSelectAllCallback func(select_ bool)

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *TextView) ConnectSelectAll(callback TextViewSignalSelectAllCallback) int {
	signalTextViewSelectAllLock.Lock()
	defer signalTextViewSelectAllLock.Unlock()

	signalTextViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_select_all(instance, C.gpointer(uintptr(signalTextViewSelectAllId)))

	detail := signalTextViewSelectAllDetail{callback, handlerID}
	signalTextViewSelectAllMap[signalTextViewSelectAllId] = detail

	return signalTextViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the TextView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *TextView) DisconnectSelectAll(connectionID int) {
	signalTextViewSelectAllLock.Lock()
	defer signalTextViewSelectAllLock.Unlock()

	detail, exists := signalTextViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewSelectAllMap, connectionID)
}

//export textview_selectAllHandler
func textview_selectAllHandler(_ *C.GObject, c_select C.gboolean, data C.gpointer) {
	signalTextViewSelectAllLock.RLock()
	defer signalTextViewSelectAllLock.RUnlock()

	select_ := c_select == C.TRUE

	index := int(uintptr(data))
	callback := signalTextViewSelectAllMap[index].callback
	callback(select_)
}

type signalTextViewSetAnchorDetail struct {
	callback  TextViewSignalSetAnchorCallback
	handlerID C.gulong
}

var signalTextViewSetAnchorId int
var signalTextViewSetAnchorMap = make(map[int]signalTextViewSetAnchorDetail)
var signalTextViewSetAnchorLock sync.RWMutex

// TextViewSignalSetAnchorCallback is a callback function for a 'set-anchor' signal emitted from a TextView.
type TextViewSignalSetAnchorCallback func()

/*
ConnectSetAnchor connects the callback to the 'set-anchor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectSetAnchor to remove it.
*/
func (recv *TextView) ConnectSetAnchor(callback TextViewSignalSetAnchorCallback) int {
	signalTextViewSetAnchorLock.Lock()
	defer signalTextViewSetAnchorLock.Unlock()

	signalTextViewSetAnchorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_set_anchor(instance, C.gpointer(uintptr(signalTextViewSetAnchorId)))

	detail := signalTextViewSetAnchorDetail{callback, handlerID}
	signalTextViewSetAnchorMap[signalTextViewSetAnchorId] = detail

	return signalTextViewSetAnchorId
}

/*
DisconnectSetAnchor disconnects a callback from the 'set-anchor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectSetAnchor.
*/
func (recv *TextView) DisconnectSetAnchor(connectionID int) {
	signalTextViewSetAnchorLock.Lock()
	defer signalTextViewSetAnchorLock.Unlock()

	detail, exists := signalTextViewSetAnchorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewSetAnchorMap, connectionID)
}

//export textview_setAnchorHandler
func textview_setAnchorHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewSetAnchorLock.RLock()
	defer signalTextViewSetAnchorLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewSetAnchorMap[index].callback
	callback()
}

type signalTextViewToggleCursorVisibleDetail struct {
	callback  TextViewSignalToggleCursorVisibleCallback
	handlerID C.gulong
}

var signalTextViewToggleCursorVisibleId int
var signalTextViewToggleCursorVisibleMap = make(map[int]signalTextViewToggleCursorVisibleDetail)
var signalTextViewToggleCursorVisibleLock sync.RWMutex

// TextViewSignalToggleCursorVisibleCallback is a callback function for a 'toggle-cursor-visible' signal emitted from a TextView.
type TextViewSignalToggleCursorVisibleCallback func()

/*
ConnectToggleCursorVisible connects the callback to the 'toggle-cursor-visible' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorVisible to remove it.
*/
func (recv *TextView) ConnectToggleCursorVisible(callback TextViewSignalToggleCursorVisibleCallback) int {
	signalTextViewToggleCursorVisibleLock.Lock()
	defer signalTextViewToggleCursorVisibleLock.Unlock()

	signalTextViewToggleCursorVisibleId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_toggle_cursor_visible(instance, C.gpointer(uintptr(signalTextViewToggleCursorVisibleId)))

	detail := signalTextViewToggleCursorVisibleDetail{callback, handlerID}
	signalTextViewToggleCursorVisibleMap[signalTextViewToggleCursorVisibleId] = detail

	return signalTextViewToggleCursorVisibleId
}

/*
DisconnectToggleCursorVisible disconnects a callback from the 'toggle-cursor-visible' signal for the TextView.

The connectionID should be a value returned from a call to ConnectToggleCursorVisible.
*/
func (recv *TextView) DisconnectToggleCursorVisible(connectionID int) {
	signalTextViewToggleCursorVisibleLock.Lock()
	defer signalTextViewToggleCursorVisibleLock.Unlock()

	detail, exists := signalTextViewToggleCursorVisibleMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewToggleCursorVisibleMap, connectionID)
}

//export textview_toggleCursorVisibleHandler
func textview_toggleCursorVisibleHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewToggleCursorVisibleLock.RLock()
	defer signalTextViewToggleCursorVisibleLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewToggleCursorVisibleMap[index].callback
	callback()
}

type signalTextViewToggleOverwriteDetail struct {
	callback  TextViewSignalToggleOverwriteCallback
	handlerID C.gulong
}

var signalTextViewToggleOverwriteId int
var signalTextViewToggleOverwriteMap = make(map[int]signalTextViewToggleOverwriteDetail)
var signalTextViewToggleOverwriteLock sync.RWMutex

// TextViewSignalToggleOverwriteCallback is a callback function for a 'toggle-overwrite' signal emitted from a TextView.
type TextViewSignalToggleOverwriteCallback func()

/*
ConnectToggleOverwrite connects the callback to the 'toggle-overwrite' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectToggleOverwrite to remove it.
*/
func (recv *TextView) ConnectToggleOverwrite(callback TextViewSignalToggleOverwriteCallback) int {
	signalTextViewToggleOverwriteLock.Lock()
	defer signalTextViewToggleOverwriteLock.Unlock()

	signalTextViewToggleOverwriteId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_toggle_overwrite(instance, C.gpointer(uintptr(signalTextViewToggleOverwriteId)))

	detail := signalTextViewToggleOverwriteDetail{callback, handlerID}
	signalTextViewToggleOverwriteMap[signalTextViewToggleOverwriteId] = detail

	return signalTextViewToggleOverwriteId
}

/*
DisconnectToggleOverwrite disconnects a callback from the 'toggle-overwrite' signal for the TextView.

The connectionID should be a value returned from a call to ConnectToggleOverwrite.
*/
func (recv *TextView) DisconnectToggleOverwrite(connectionID int) {
	signalTextViewToggleOverwriteLock.Lock()
	defer signalTextViewToggleOverwriteLock.Unlock()

	detail, exists := signalTextViewToggleOverwriteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewToggleOverwriteMap, connectionID)
}

//export textview_toggleOverwriteHandler
func textview_toggleOverwriteHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewToggleOverwriteLock.RLock()
	defer signalTextViewToggleOverwriteLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewToggleOverwriteMap[index].callback
	callback()
}

// Blacklisted : gtk_text_view_new

// Blacklisted : gtk_text_view_new_with_buffer

// Blacklisted : gtk_text_view_add_child_at_anchor

// Blacklisted : gtk_text_view_add_child_in_window

// Blacklisted : gtk_text_view_backward_display_line

// Blacklisted : gtk_text_view_backward_display_line_start

// Blacklisted : gtk_text_view_buffer_to_window_coords

// Blacklisted : gtk_text_view_forward_display_line

// Blacklisted : gtk_text_view_forward_display_line_end

// Blacklisted : gtk_text_view_get_border_window_size

// Blacklisted : gtk_text_view_get_buffer

// Blacklisted : gtk_text_view_get_cursor_visible

// Blacklisted : gtk_text_view_get_default_attributes

// Blacklisted : gtk_text_view_get_editable

// Blacklisted : gtk_text_view_get_indent

// Blacklisted : gtk_text_view_get_iter_at_location

// Blacklisted : gtk_text_view_get_iter_location

// Blacklisted : gtk_text_view_get_justification

// Blacklisted : gtk_text_view_get_left_margin

// Blacklisted : gtk_text_view_get_line_at_y

// Blacklisted : gtk_text_view_get_line_yrange

// Blacklisted : gtk_text_view_get_pixels_above_lines

// Blacklisted : gtk_text_view_get_pixels_below_lines

// Blacklisted : gtk_text_view_get_pixels_inside_wrap

// Blacklisted : gtk_text_view_get_right_margin

// Blacklisted : gtk_text_view_get_tabs

// Blacklisted : gtk_text_view_get_visible_rect

// Blacklisted : gtk_text_view_get_window

// Blacklisted : gtk_text_view_get_window_type

// Blacklisted : gtk_text_view_get_wrap_mode

// Blacklisted : gtk_text_view_move_child

// Blacklisted : gtk_text_view_move_mark_onscreen

// Blacklisted : gtk_text_view_move_visually

// Blacklisted : gtk_text_view_place_cursor_onscreen

// Blacklisted : gtk_text_view_scroll_mark_onscreen

// Blacklisted : gtk_text_view_scroll_to_iter

// Blacklisted : gtk_text_view_scroll_to_mark

// Blacklisted : gtk_text_view_set_border_window_size

// Blacklisted : gtk_text_view_set_buffer

// Blacklisted : gtk_text_view_set_cursor_visible

// Blacklisted : gtk_text_view_set_editable

// Blacklisted : gtk_text_view_set_indent

// Blacklisted : gtk_text_view_set_justification

// Blacklisted : gtk_text_view_set_left_margin

// Blacklisted : gtk_text_view_set_pixels_above_lines

// Blacklisted : gtk_text_view_set_pixels_below_lines

// Blacklisted : gtk_text_view_set_pixels_inside_wrap

// Blacklisted : gtk_text_view_set_right_margin

// Blacklisted : gtk_text_view_set_tabs

// Blacklisted : gtk_text_view_set_wrap_mode

// Blacklisted : gtk_text_view_starts_display_line

// Blacklisted : gtk_text_view_window_to_buffer_coords

// ImplementorIface returns the ImplementorIface interface implemented by TextView
func (recv *TextView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TextView
func (recv *TextView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by TextView
func (recv *TextView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// TextViewAccessible is a wrapper around the C record GtkTextViewAccessible.
type TextViewAccessible struct {
	native *C.GtkTextViewAccessible
	// parent : record
	// priv : record
}

func TextViewAccessibleNewFromC(u unsafe.Pointer) *TextViewAccessible {
	c := (*C.GtkTextViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TextViewAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextViewAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextViewAccessible with another TextViewAccessible, and returns true if they represent the same GObject.
func (recv *TextViewAccessible) Equals(other *TextViewAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *TextViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *TextViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TextViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TextViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to TextViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextViewAccessible.
func CastToTextViewAccessible(object *gobject.Object) *TextViewAccessible {
	return TextViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by TextViewAccessible
func (recv *TextViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by TextViewAccessible
func (recv *TextViewAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// StreamableContent returns the StreamableContent interface implemented by TextViewAccessible
func (recv *TextViewAccessible) StreamableContent() *atk.StreamableContent {
	return atk.StreamableContentNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by TextViewAccessible
func (recv *TextViewAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// ThemingEngine is a wrapper around the C record GtkThemingEngine.
type ThemingEngine struct {
	native *C.GtkThemingEngine
	// parent_object : record
	// priv : record
}

func ThemingEngineNewFromC(u unsafe.Pointer) *ThemingEngine {
	c := (*C.GtkThemingEngine)(u)
	if c == nil {
		return nil
	}

	g := &ThemingEngine{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ThemingEngine) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ThemingEngine) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThemingEngine with another ThemingEngine, and returns true if they represent the same GObject.
func (recv *ThemingEngine) Equals(other *ThemingEngine) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ThemingEngine) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ThemingEngine.
// Exercise care, as this is a potentially dangerous function if the Object is not a ThemingEngine.
func CastToThemingEngine(object *gobject.Object) *ThemingEngine {
	return ThemingEngineNewFromC(object.ToC())
}

// Blacklisted : gtk_theming_engine_load

// Blacklisted : gtk_theming_engine_get_screen

// ToggleAction is a wrapper around the C record GtkToggleAction.
type ToggleAction struct {
	native *C.GtkToggleAction
	// parent : record
	// Private : private_data
}

func ToggleActionNewFromC(u unsafe.Pointer) *ToggleAction {
	c := (*C.GtkToggleAction)(u)
	if c == nil {
		return nil
	}

	g := &ToggleAction{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToggleAction) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToggleAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleAction with another ToggleAction, and returns true if they represent the same GObject.
func (recv *ToggleAction) Equals(other *ToggleAction) bool {
	return other.ToC() == recv.ToC()
}

// Action upcasts to *Action
func (recv *ToggleAction) Action() *Action {
	return ActionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *ToggleAction) Object() *gobject.Object {
	return recv.Action().Object()
}

// CastToWidget down casts any arbitrary Object to ToggleAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleAction.
func CastToToggleAction(object *gobject.Object) *ToggleAction {
	return ToggleActionNewFromC(object.ToC())
}

type signalToggleActionToggledDetail struct {
	callback  ToggleActionSignalToggledCallback
	handlerID C.gulong
}

var signalToggleActionToggledId int
var signalToggleActionToggledMap = make(map[int]signalToggleActionToggledDetail)
var signalToggleActionToggledLock sync.RWMutex

// ToggleActionSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleAction.
type ToggleActionSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleAction.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleAction) ConnectToggled(callback ToggleActionSignalToggledCallback) int {
	signalToggleActionToggledLock.Lock()
	defer signalToggleActionToggledLock.Unlock()

	signalToggleActionToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleAction_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleActionToggledId)))

	detail := signalToggleActionToggledDetail{callback, handlerID}
	signalToggleActionToggledMap[signalToggleActionToggledId] = detail

	return signalToggleActionToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleAction.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleAction) DisconnectToggled(connectionID int) {
	signalToggleActionToggledLock.Lock()
	defer signalToggleActionToggledLock.Unlock()

	detail, exists := signalToggleActionToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleActionToggledMap, connectionID)
}

//export toggleaction_toggledHandler
func toggleaction_toggledHandler(_ *C.GObject, data C.gpointer) {
	signalToggleActionToggledLock.RLock()
	defer signalToggleActionToggledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToggleActionToggledMap[index].callback
	callback()
}

// Buildable returns the Buildable interface implemented by ToggleAction
func (recv *ToggleAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToggleButton is a wrapper around the C record GtkToggleButton.
type ToggleButton struct {
	native *C.GtkToggleButton
	// Private : button
	// Private : priv
}

func ToggleButtonNewFromC(u unsafe.Pointer) *ToggleButton {
	c := (*C.GtkToggleButton)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToggleButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToggleButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleButton with another ToggleButton, and returns true if they represent the same GObject.
func (recv *ToggleButton) Equals(other *ToggleButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *ToggleButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ToggleButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ToggleButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ToggleButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToggleButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToggleButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to ToggleButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleButton.
func CastToToggleButton(object *gobject.Object) *ToggleButton {
	return ToggleButtonNewFromC(object.ToC())
}

type signalToggleButtonToggledDetail struct {
	callback  ToggleButtonSignalToggledCallback
	handlerID C.gulong
}

var signalToggleButtonToggledId int
var signalToggleButtonToggledMap = make(map[int]signalToggleButtonToggledDetail)
var signalToggleButtonToggledLock sync.RWMutex

// ToggleButtonSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleButton.
type ToggleButtonSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleButton.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleButton) ConnectToggled(callback ToggleButtonSignalToggledCallback) int {
	signalToggleButtonToggledLock.Lock()
	defer signalToggleButtonToggledLock.Unlock()

	signalToggleButtonToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleButton_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleButtonToggledId)))

	detail := signalToggleButtonToggledDetail{callback, handlerID}
	signalToggleButtonToggledMap[signalToggleButtonToggledId] = detail

	return signalToggleButtonToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleButton.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleButton) DisconnectToggled(connectionID int) {
	signalToggleButtonToggledLock.Lock()
	defer signalToggleButtonToggledLock.Unlock()

	detail, exists := signalToggleButtonToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleButtonToggledMap, connectionID)
}

//export togglebutton_toggledHandler
func togglebutton_toggledHandler(_ *C.GObject, data C.gpointer) {
	signalToggleButtonToggledLock.RLock()
	defer signalToggleButtonToggledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToggleButtonToggledMap[index].callback
	callback()
}

// Blacklisted : gtk_toggle_button_new

// Blacklisted : gtk_toggle_button_new_with_label

// Blacklisted : gtk_toggle_button_new_with_mnemonic

// Blacklisted : gtk_toggle_button_get_active

// Blacklisted : gtk_toggle_button_get_inconsistent

// Blacklisted : gtk_toggle_button_get_mode

// Blacklisted : gtk_toggle_button_set_active

// Blacklisted : gtk_toggle_button_set_inconsistent

// Blacklisted : gtk_toggle_button_set_mode

// Blacklisted : gtk_toggle_button_toggled

// ImplementorIface returns the ImplementorIface interface implemented by ToggleButton
func (recv *ToggleButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToggleButton
func (recv *ToggleButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToggleButton
func (recv *ToggleButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToggleButton
func (recv *ToggleButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToggleButtonAccessible is a wrapper around the C record GtkToggleButtonAccessible.
type ToggleButtonAccessible struct {
	native *C.GtkToggleButtonAccessible
	// parent : record
	// priv : record
}

func ToggleButtonAccessibleNewFromC(u unsafe.Pointer) *ToggleButtonAccessible {
	c := (*C.GtkToggleButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToggleButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToggleButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleButtonAccessible with another ToggleButtonAccessible, and returns true if they represent the same GObject.
func (recv *ToggleButtonAccessible) Equals(other *ToggleButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *ToggleButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ToggleButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ToggleButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ToggleButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ToggleButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ToggleButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleButtonAccessible.
func CastToToggleButtonAccessible(object *gobject.Object) *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ToggleToolButton is a wrapper around the C record GtkToggleToolButton.
type ToggleToolButton struct {
	native *C.GtkToggleToolButton
	// parent : record
	// Private : priv
}

func ToggleToolButtonNewFromC(u unsafe.Pointer) *ToggleToolButton {
	c := (*C.GtkToggleToolButton)(u)
	if c == nil {
		return nil
	}

	g := &ToggleToolButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToggleToolButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToggleToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleToolButton with another ToggleToolButton, and returns true if they represent the same GObject.
func (recv *ToggleToolButton) Equals(other *ToggleToolButton) bool {
	return other.ToC() == recv.ToC()
}

// ToolButton upcasts to *ToolButton
func (recv *ToggleToolButton) ToolButton() *ToolButton {
	return ToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolItem upcasts to *ToolItem
func (recv *ToggleToolButton) ToolItem() *ToolItem {
	return recv.ToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *ToggleToolButton) Bin() *Bin {
	return recv.ToolButton().Bin()
}

// Container upcasts to *Container
func (recv *ToggleToolButton) Container() *Container {
	return recv.ToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *ToggleToolButton) Widget() *Widget {
	return recv.ToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToggleToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToggleToolButton) Object() *gobject.Object {
	return recv.ToolButton().Object()
}

// CastToWidget down casts any arbitrary Object to ToggleToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleToolButton.
func CastToToggleToolButton(object *gobject.Object) *ToggleToolButton {
	return ToggleToolButtonNewFromC(object.ToC())
}

type signalToggleToolButtonToggledDetail struct {
	callback  ToggleToolButtonSignalToggledCallback
	handlerID C.gulong
}

var signalToggleToolButtonToggledId int
var signalToggleToolButtonToggledMap = make(map[int]signalToggleToolButtonToggledDetail)
var signalToggleToolButtonToggledLock sync.RWMutex

// ToggleToolButtonSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleToolButton.
type ToggleToolButtonSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleToolButton.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleToolButton) ConnectToggled(callback ToggleToolButtonSignalToggledCallback) int {
	signalToggleToolButtonToggledLock.Lock()
	defer signalToggleToolButtonToggledLock.Unlock()

	signalToggleToolButtonToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleToolButton_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleToolButtonToggledId)))

	detail := signalToggleToolButtonToggledDetail{callback, handlerID}
	signalToggleToolButtonToggledMap[signalToggleToolButtonToggledId] = detail

	return signalToggleToolButtonToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleToolButton.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleToolButton) DisconnectToggled(connectionID int) {
	signalToggleToolButtonToggledLock.Lock()
	defer signalToggleToolButtonToggledLock.Unlock()

	detail, exists := signalToggleToolButtonToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleToolButtonToggledMap, connectionID)
}

//export toggletoolbutton_toggledHandler
func toggletoolbutton_toggledHandler(_ *C.GObject, data C.gpointer) {
	signalToggleToolButtonToggledLock.RLock()
	defer signalToggleToolButtonToggledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToggleToolButtonToggledMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToggleToolButton
func (recv *ToggleToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolButton is a wrapper around the C record GtkToolButton.
type ToolButton struct {
	native *C.GtkToolButton
	// parent : record
	// Private : priv
}

func ToolButtonNewFromC(u unsafe.Pointer) *ToolButton {
	c := (*C.GtkToolButton)(u)
	if c == nil {
		return nil
	}

	g := &ToolButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToolButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolButton with another ToolButton, and returns true if they represent the same GObject.
func (recv *ToolButton) Equals(other *ToolButton) bool {
	return other.ToC() == recv.ToC()
}

// ToolItem upcasts to *ToolItem
func (recv *ToolButton) ToolItem() *ToolItem {
	return ToolItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ToolButton) Bin() *Bin {
	return recv.ToolItem().Bin()
}

// Container upcasts to *Container
func (recv *ToolButton) Container() *Container {
	return recv.ToolItem().Container()
}

// Widget upcasts to *Widget
func (recv *ToolButton) Widget() *Widget {
	return recv.ToolItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolButton) Object() *gobject.Object {
	return recv.ToolItem().Object()
}

// CastToWidget down casts any arbitrary Object to ToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolButton.
func CastToToolButton(object *gobject.Object) *ToolButton {
	return ToolButtonNewFromC(object.ToC())
}

type signalToolButtonClickedDetail struct {
	callback  ToolButtonSignalClickedCallback
	handlerID C.gulong
}

var signalToolButtonClickedId int
var signalToolButtonClickedMap = make(map[int]signalToolButtonClickedDetail)
var signalToolButtonClickedLock sync.RWMutex

// ToolButtonSignalClickedCallback is a callback function for a 'clicked' signal emitted from a ToolButton.
type ToolButtonSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the ToolButton.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *ToolButton) ConnectClicked(callback ToolButtonSignalClickedCallback) int {
	signalToolButtonClickedLock.Lock()
	defer signalToolButtonClickedLock.Unlock()

	signalToolButtonClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolButton_signal_connect_clicked(instance, C.gpointer(uintptr(signalToolButtonClickedId)))

	detail := signalToolButtonClickedDetail{callback, handlerID}
	signalToolButtonClickedMap[signalToolButtonClickedId] = detail

	return signalToolButtonClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the ToolButton.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *ToolButton) DisconnectClicked(connectionID int) {
	signalToolButtonClickedLock.Lock()
	defer signalToolButtonClickedLock.Unlock()

	detail, exists := signalToolButtonClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolButtonClickedMap, connectionID)
}

//export toolbutton_clickedHandler
func toolbutton_clickedHandler(_ *C.GObject, data C.gpointer) {
	signalToolButtonClickedLock.RLock()
	defer signalToolButtonClickedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToolButtonClickedMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolButton
func (recv *ToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToolButton
func (recv *ToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToolButton
func (recv *ToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolButton
func (recv *ToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolItem is a wrapper around the C record GtkToolItem.
type ToolItem struct {
	native *C.GtkToolItem
	// parent : record
	// Private : priv
}

func ToolItemNewFromC(u unsafe.Pointer) *ToolItem {
	c := (*C.GtkToolItem)(u)
	if c == nil {
		return nil
	}

	g := &ToolItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToolItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToolItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolItem with another ToolItem, and returns true if they represent the same GObject.
func (recv *ToolItem) Equals(other *ToolItem) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ToolItem) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ToolItem) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ToolItem) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolItem) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ToolItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolItem.
func CastToToolItem(object *gobject.Object) *ToolItem {
	return ToolItemNewFromC(object.ToC())
}

type signalToolItemCreateMenuProxyDetail struct {
	callback  ToolItemSignalCreateMenuProxyCallback
	handlerID C.gulong
}

var signalToolItemCreateMenuProxyId int
var signalToolItemCreateMenuProxyMap = make(map[int]signalToolItemCreateMenuProxyDetail)
var signalToolItemCreateMenuProxyLock sync.RWMutex

// ToolItemSignalCreateMenuProxyCallback is a callback function for a 'create-menu-proxy' signal emitted from a ToolItem.
type ToolItemSignalCreateMenuProxyCallback func() bool

/*
ConnectCreateMenuProxy connects the callback to the 'create-menu-proxy' signal for the ToolItem.

The returned value represents the connection, and may be passed to DisconnectCreateMenuProxy to remove it.
*/
func (recv *ToolItem) ConnectCreateMenuProxy(callback ToolItemSignalCreateMenuProxyCallback) int {
	signalToolItemCreateMenuProxyLock.Lock()
	defer signalToolItemCreateMenuProxyLock.Unlock()

	signalToolItemCreateMenuProxyId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolItem_signal_connect_create_menu_proxy(instance, C.gpointer(uintptr(signalToolItemCreateMenuProxyId)))

	detail := signalToolItemCreateMenuProxyDetail{callback, handlerID}
	signalToolItemCreateMenuProxyMap[signalToolItemCreateMenuProxyId] = detail

	return signalToolItemCreateMenuProxyId
}

/*
DisconnectCreateMenuProxy disconnects a callback from the 'create-menu-proxy' signal for the ToolItem.

The connectionID should be a value returned from a call to ConnectCreateMenuProxy.
*/
func (recv *ToolItem) DisconnectCreateMenuProxy(connectionID int) {
	signalToolItemCreateMenuProxyLock.Lock()
	defer signalToolItemCreateMenuProxyLock.Unlock()

	detail, exists := signalToolItemCreateMenuProxyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolItemCreateMenuProxyMap, connectionID)
}

//export toolitem_createMenuProxyHandler
func toolitem_createMenuProxyHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalToolItemCreateMenuProxyLock.RLock()
	defer signalToolItemCreateMenuProxyLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToolItemCreateMenuProxyMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalToolItemToolbarReconfiguredDetail struct {
	callback  ToolItemSignalToolbarReconfiguredCallback
	handlerID C.gulong
}

var signalToolItemToolbarReconfiguredId int
var signalToolItemToolbarReconfiguredMap = make(map[int]signalToolItemToolbarReconfiguredDetail)
var signalToolItemToolbarReconfiguredLock sync.RWMutex

// ToolItemSignalToolbarReconfiguredCallback is a callback function for a 'toolbar-reconfigured' signal emitted from a ToolItem.
type ToolItemSignalToolbarReconfiguredCallback func()

/*
ConnectToolbarReconfigured connects the callback to the 'toolbar-reconfigured' signal for the ToolItem.

The returned value represents the connection, and may be passed to DisconnectToolbarReconfigured to remove it.
*/
func (recv *ToolItem) ConnectToolbarReconfigured(callback ToolItemSignalToolbarReconfiguredCallback) int {
	signalToolItemToolbarReconfiguredLock.Lock()
	defer signalToolItemToolbarReconfiguredLock.Unlock()

	signalToolItemToolbarReconfiguredId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolItem_signal_connect_toolbar_reconfigured(instance, C.gpointer(uintptr(signalToolItemToolbarReconfiguredId)))

	detail := signalToolItemToolbarReconfiguredDetail{callback, handlerID}
	signalToolItemToolbarReconfiguredMap[signalToolItemToolbarReconfiguredId] = detail

	return signalToolItemToolbarReconfiguredId
}

/*
DisconnectToolbarReconfigured disconnects a callback from the 'toolbar-reconfigured' signal for the ToolItem.

The connectionID should be a value returned from a call to ConnectToolbarReconfigured.
*/
func (recv *ToolItem) DisconnectToolbarReconfigured(connectionID int) {
	signalToolItemToolbarReconfiguredLock.Lock()
	defer signalToolItemToolbarReconfiguredLock.Unlock()

	detail, exists := signalToolItemToolbarReconfiguredMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolItemToolbarReconfiguredMap, connectionID)
}

//export toolitem_toolbarReconfiguredHandler
func toolitem_toolbarReconfiguredHandler(_ *C.GObject, data C.gpointer) {
	signalToolItemToolbarReconfiguredLock.RLock()
	defer signalToolItemToolbarReconfiguredLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToolItemToolbarReconfiguredMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolItem
func (recv *ToolItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToolItem
func (recv *ToolItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolItem
func (recv *ToolItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolItemGroup is a wrapper around the C record GtkToolItemGroup.
type ToolItemGroup struct {
	native *C.GtkToolItemGroup
	// parent_instance : record
	// priv : record
}

func ToolItemGroupNewFromC(u unsafe.Pointer) *ToolItemGroup {
	c := (*C.GtkToolItemGroup)(u)
	if c == nil {
		return nil
	}

	g := &ToolItemGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToolItemGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToolItemGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolItemGroup with another ToolItemGroup, and returns true if they represent the same GObject.
func (recv *ToolItemGroup) Equals(other *ToolItemGroup) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *ToolItemGroup) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ToolItemGroup) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolItemGroup) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolItemGroup) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to ToolItemGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolItemGroup.
func CastToToolItemGroup(object *gobject.Object) *ToolItemGroup {
	return ToolItemGroupNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolItemGroup
func (recv *ToolItemGroup) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolItemGroup
func (recv *ToolItemGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolShell returns the ToolShell interface implemented by ToolItemGroup
func (recv *ToolItemGroup) ToolShell() *ToolShell {
	return ToolShellNewFromC(recv.ToC())
}

// ToolPalette is a wrapper around the C record GtkToolPalette.
type ToolPalette struct {
	native *C.GtkToolPalette
	// parent_instance : record
	// priv : record
}

func ToolPaletteNewFromC(u unsafe.Pointer) *ToolPalette {
	c := (*C.GtkToolPalette)(u)
	if c == nil {
		return nil
	}

	g := &ToolPalette{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToolPalette) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToolPalette) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolPalette with another ToolPalette, and returns true if they represent the same GObject.
func (recv *ToolPalette) Equals(other *ToolPalette) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *ToolPalette) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ToolPalette) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolPalette) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolPalette) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to ToolPalette.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolPalette.
func CastToToolPalette(object *gobject.Object) *ToolPalette {
	return ToolPaletteNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolPalette
func (recv *ToolPalette) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolPalette
func (recv *ToolPalette) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ToolPalette
func (recv *ToolPalette) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by ToolPalette
func (recv *ToolPalette) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// Toolbar is a wrapper around the C record GtkToolbar.
type Toolbar struct {
	native *C.GtkToolbar
	// container : record
	// priv : record
}

func ToolbarNewFromC(u unsafe.Pointer) *Toolbar {
	c := (*C.GtkToolbar)(u)
	if c == nil {
		return nil
	}

	g := &Toolbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Toolbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Toolbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Toolbar with another Toolbar, and returns true if they represent the same GObject.
func (recv *Toolbar) Equals(other *Toolbar) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Toolbar) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Toolbar) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Toolbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Toolbar) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Toolbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Toolbar.
func CastToToolbar(object *gobject.Object) *Toolbar {
	return ToolbarNewFromC(object.ToC())
}

type signalToolbarFocusHomeOrEndDetail struct {
	callback  ToolbarSignalFocusHomeOrEndCallback
	handlerID C.gulong
}

var signalToolbarFocusHomeOrEndId int
var signalToolbarFocusHomeOrEndMap = make(map[int]signalToolbarFocusHomeOrEndDetail)
var signalToolbarFocusHomeOrEndLock sync.RWMutex

// ToolbarSignalFocusHomeOrEndCallback is a callback function for a 'focus-home-or-end' signal emitted from a Toolbar.
type ToolbarSignalFocusHomeOrEndCallback func(focusHome bool) bool

/*
ConnectFocusHomeOrEnd connects the callback to the 'focus-home-or-end' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectFocusHomeOrEnd to remove it.
*/
func (recv *Toolbar) ConnectFocusHomeOrEnd(callback ToolbarSignalFocusHomeOrEndCallback) int {
	signalToolbarFocusHomeOrEndLock.Lock()
	defer signalToolbarFocusHomeOrEndLock.Unlock()

	signalToolbarFocusHomeOrEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_focus_home_or_end(instance, C.gpointer(uintptr(signalToolbarFocusHomeOrEndId)))

	detail := signalToolbarFocusHomeOrEndDetail{callback, handlerID}
	signalToolbarFocusHomeOrEndMap[signalToolbarFocusHomeOrEndId] = detail

	return signalToolbarFocusHomeOrEndId
}

/*
DisconnectFocusHomeOrEnd disconnects a callback from the 'focus-home-or-end' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectFocusHomeOrEnd.
*/
func (recv *Toolbar) DisconnectFocusHomeOrEnd(connectionID int) {
	signalToolbarFocusHomeOrEndLock.Lock()
	defer signalToolbarFocusHomeOrEndLock.Unlock()

	detail, exists := signalToolbarFocusHomeOrEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarFocusHomeOrEndMap, connectionID)
}

//export toolbar_focusHomeOrEndHandler
func toolbar_focusHomeOrEndHandler(_ *C.GObject, c_focus_home C.gboolean, data C.gpointer) C.gboolean {
	signalToolbarFocusHomeOrEndLock.RLock()
	defer signalToolbarFocusHomeOrEndLock.RUnlock()

	focusHome := c_focus_home == C.TRUE

	index := int(uintptr(data))
	callback := signalToolbarFocusHomeOrEndMap[index].callback
	retGo := callback(focusHome)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalToolbarOrientationChangedDetail struct {
	callback  ToolbarSignalOrientationChangedCallback
	handlerID C.gulong
}

var signalToolbarOrientationChangedId int
var signalToolbarOrientationChangedMap = make(map[int]signalToolbarOrientationChangedDetail)
var signalToolbarOrientationChangedLock sync.RWMutex

// ToolbarSignalOrientationChangedCallback is a callback function for a 'orientation-changed' signal emitted from a Toolbar.
type ToolbarSignalOrientationChangedCallback func(orientation Orientation)

/*
ConnectOrientationChanged connects the callback to the 'orientation-changed' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectOrientationChanged to remove it.
*/
func (recv *Toolbar) ConnectOrientationChanged(callback ToolbarSignalOrientationChangedCallback) int {
	signalToolbarOrientationChangedLock.Lock()
	defer signalToolbarOrientationChangedLock.Unlock()

	signalToolbarOrientationChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_orientation_changed(instance, C.gpointer(uintptr(signalToolbarOrientationChangedId)))

	detail := signalToolbarOrientationChangedDetail{callback, handlerID}
	signalToolbarOrientationChangedMap[signalToolbarOrientationChangedId] = detail

	return signalToolbarOrientationChangedId
}

/*
DisconnectOrientationChanged disconnects a callback from the 'orientation-changed' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectOrientationChanged.
*/
func (recv *Toolbar) DisconnectOrientationChanged(connectionID int) {
	signalToolbarOrientationChangedLock.Lock()
	defer signalToolbarOrientationChangedLock.Unlock()

	detail, exists := signalToolbarOrientationChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarOrientationChangedMap, connectionID)
}

//export toolbar_orientationChangedHandler
func toolbar_orientationChangedHandler(_ *C.GObject, c_orientation C.GtkOrientation, data C.gpointer) {
	signalToolbarOrientationChangedLock.RLock()
	defer signalToolbarOrientationChangedLock.RUnlock()

	orientation := Orientation(c_orientation)

	index := int(uintptr(data))
	callback := signalToolbarOrientationChangedMap[index].callback
	callback(orientation)
}

type signalToolbarPopupContextMenuDetail struct {
	callback  ToolbarSignalPopupContextMenuCallback
	handlerID C.gulong
}

var signalToolbarPopupContextMenuId int
var signalToolbarPopupContextMenuMap = make(map[int]signalToolbarPopupContextMenuDetail)
var signalToolbarPopupContextMenuLock sync.RWMutex

// ToolbarSignalPopupContextMenuCallback is a callback function for a 'popup-context-menu' signal emitted from a Toolbar.
type ToolbarSignalPopupContextMenuCallback func(x int32, y int32, button int32) bool

/*
ConnectPopupContextMenu connects the callback to the 'popup-context-menu' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectPopupContextMenu to remove it.
*/
func (recv *Toolbar) ConnectPopupContextMenu(callback ToolbarSignalPopupContextMenuCallback) int {
	signalToolbarPopupContextMenuLock.Lock()
	defer signalToolbarPopupContextMenuLock.Unlock()

	signalToolbarPopupContextMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_popup_context_menu(instance, C.gpointer(uintptr(signalToolbarPopupContextMenuId)))

	detail := signalToolbarPopupContextMenuDetail{callback, handlerID}
	signalToolbarPopupContextMenuMap[signalToolbarPopupContextMenuId] = detail

	return signalToolbarPopupContextMenuId
}

/*
DisconnectPopupContextMenu disconnects a callback from the 'popup-context-menu' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectPopupContextMenu.
*/
func (recv *Toolbar) DisconnectPopupContextMenu(connectionID int) {
	signalToolbarPopupContextMenuLock.Lock()
	defer signalToolbarPopupContextMenuLock.Unlock()

	detail, exists := signalToolbarPopupContextMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarPopupContextMenuMap, connectionID)
}

//export toolbar_popupContextMenuHandler
func toolbar_popupContextMenuHandler(_ *C.GObject, c_x C.gint, c_y C.gint, c_button C.gint, data C.gpointer) C.gboolean {
	signalToolbarPopupContextMenuLock.RLock()
	defer signalToolbarPopupContextMenuLock.RUnlock()

	x := int32(c_x)

	y := int32(c_y)

	button := int32(c_button)

	index := int(uintptr(data))
	callback := signalToolbarPopupContextMenuMap[index].callback
	retGo := callback(x, y, button)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalToolbarStyleChangedDetail struct {
	callback  ToolbarSignalStyleChangedCallback
	handlerID C.gulong
}

var signalToolbarStyleChangedId int
var signalToolbarStyleChangedMap = make(map[int]signalToolbarStyleChangedDetail)
var signalToolbarStyleChangedLock sync.RWMutex

// ToolbarSignalStyleChangedCallback is a callback function for a 'style-changed' signal emitted from a Toolbar.
type ToolbarSignalStyleChangedCallback func(style ToolbarStyle)

/*
ConnectStyleChanged connects the callback to the 'style-changed' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectStyleChanged to remove it.
*/
func (recv *Toolbar) ConnectStyleChanged(callback ToolbarSignalStyleChangedCallback) int {
	signalToolbarStyleChangedLock.Lock()
	defer signalToolbarStyleChangedLock.Unlock()

	signalToolbarStyleChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_style_changed(instance, C.gpointer(uintptr(signalToolbarStyleChangedId)))

	detail := signalToolbarStyleChangedDetail{callback, handlerID}
	signalToolbarStyleChangedMap[signalToolbarStyleChangedId] = detail

	return signalToolbarStyleChangedId
}

/*
DisconnectStyleChanged disconnects a callback from the 'style-changed' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectStyleChanged.
*/
func (recv *Toolbar) DisconnectStyleChanged(connectionID int) {
	signalToolbarStyleChangedLock.Lock()
	defer signalToolbarStyleChangedLock.Unlock()

	detail, exists := signalToolbarStyleChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarStyleChangedMap, connectionID)
}

//export toolbar_styleChangedHandler
func toolbar_styleChangedHandler(_ *C.GObject, c_style C.GtkToolbarStyle, data C.gpointer) {
	signalToolbarStyleChangedLock.RLock()
	defer signalToolbarStyleChangedLock.RUnlock()

	style := ToolbarStyle(c_style)

	index := int(uintptr(data))
	callback := signalToolbarStyleChangedMap[index].callback
	callback(style)
}

// Blacklisted : gtk_toolbar_new

// Blacklisted : gtk_toolbar_get_icon_size

// Blacklisted : gtk_toolbar_get_style

// Blacklisted : gtk_toolbar_set_icon_size

// Blacklisted : gtk_toolbar_set_style

// Blacklisted : gtk_toolbar_unset_icon_size

// Blacklisted : gtk_toolbar_unset_style

// ImplementorIface returns the ImplementorIface interface implemented by Toolbar
func (recv *Toolbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Toolbar
func (recv *Toolbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Toolbar
func (recv *Toolbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ToolShell returns the ToolShell interface implemented by Toolbar
func (recv *Toolbar) ToolShell() *ToolShell {
	return ToolShellNewFromC(recv.ToC())
}

// Tooltip is a wrapper around the C record GtkTooltip.
type Tooltip struct {
	native *C.GtkTooltip
}

func TooltipNewFromC(u unsafe.Pointer) *Tooltip {
	c := (*C.GtkTooltip)(u)
	if c == nil {
		return nil
	}

	g := &Tooltip{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Tooltip) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Tooltip) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Tooltip with another Tooltip, and returns true if they represent the same GObject.
func (recv *Tooltip) Equals(other *Tooltip) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Tooltip) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Tooltip.
// Exercise care, as this is a potentially dangerous function if the Object is not a Tooltip.
func CastToTooltip(object *gobject.Object) *Tooltip {
	return TooltipNewFromC(object.ToC())
}

// ToplevelAccessible is a wrapper around the C record GtkToplevelAccessible.
type ToplevelAccessible struct {
	native *C.GtkToplevelAccessible
	// parent : record
	// priv : record
}

func ToplevelAccessibleNewFromC(u unsafe.Pointer) *ToplevelAccessible {
	c := (*C.GtkToplevelAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ToplevelAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToplevelAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToplevelAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToplevelAccessible with another ToplevelAccessible, and returns true if they represent the same GObject.
func (recv *ToplevelAccessible) Equals(other *ToplevelAccessible) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ToplevelAccessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ToplevelAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToplevelAccessible.
func CastToToplevelAccessible(object *gobject.Object) *ToplevelAccessible {
	return ToplevelAccessibleNewFromC(object.ToC())
}

// Blacklisted : gtk_toplevel_accessible_get_children

// TreeModelFilter is a wrapper around the C record GtkTreeModelFilter.
type TreeModelFilter struct {
	native *C.GtkTreeModelFilter
	// parent : record
	// Private : priv
}

func TreeModelFilterNewFromC(u unsafe.Pointer) *TreeModelFilter {
	c := (*C.GtkTreeModelFilter)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelFilter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeModelFilter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeModelFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelFilter with another TreeModelFilter, and returns true if they represent the same GObject.
func (recv *TreeModelFilter) Equals(other *TreeModelFilter) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TreeModelFilter) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TreeModelFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeModelFilter.
func CastToTreeModelFilter(object *gobject.Object) *TreeModelFilter {
	return TreeModelFilterNewFromC(object.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeModelFilter
func (recv *TreeModelFilter) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeModelFilter
func (recv *TreeModelFilter) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeModelSort is a wrapper around the C record GtkTreeModelSort.
type TreeModelSort struct {
	native *C.GtkTreeModelSort
	// parent : record
	// Private : priv
}

func TreeModelSortNewFromC(u unsafe.Pointer) *TreeModelSort {
	c := (*C.GtkTreeModelSort)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelSort{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeModelSort) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeModelSort) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelSort with another TreeModelSort, and returns true if they represent the same GObject.
func (recv *TreeModelSort) Equals(other *TreeModelSort) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TreeModelSort) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TreeModelSort.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeModelSort.
func CastToTreeModelSort(object *gobject.Object) *TreeModelSort {
	return TreeModelSortNewFromC(object.ToC())
}

// Blacklisted : gtk_tree_model_sort_clear_cache

// Blacklisted : gtk_tree_model_sort_convert_child_iter_to_iter

// Blacklisted : gtk_tree_model_sort_convert_child_path_to_path

// Blacklisted : gtk_tree_model_sort_convert_iter_to_child_iter

// Blacklisted : gtk_tree_model_sort_convert_path_to_child_path

// Blacklisted : gtk_tree_model_sort_get_model

// Blacklisted : gtk_tree_model_sort_reset_default_sort_func

// TreeDragSource returns the TreeDragSource interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// TreeSelection is a wrapper around the C record GtkTreeSelection.
type TreeSelection struct {
	native *C.GtkTreeSelection
	// Private : parent
	// Private : priv
}

func TreeSelectionNewFromC(u unsafe.Pointer) *TreeSelection {
	c := (*C.GtkTreeSelection)(u)
	if c == nil {
		return nil
	}

	g := &TreeSelection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeSelection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeSelection with another TreeSelection, and returns true if they represent the same GObject.
func (recv *TreeSelection) Equals(other *TreeSelection) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TreeSelection) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TreeSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeSelection.
func CastToTreeSelection(object *gobject.Object) *TreeSelection {
	return TreeSelectionNewFromC(object.ToC())
}

type signalTreeSelectionChangedDetail struct {
	callback  TreeSelectionSignalChangedCallback
	handlerID C.gulong
}

var signalTreeSelectionChangedId int
var signalTreeSelectionChangedMap = make(map[int]signalTreeSelectionChangedDetail)
var signalTreeSelectionChangedLock sync.RWMutex

// TreeSelectionSignalChangedCallback is a callback function for a 'changed' signal emitted from a TreeSelection.
type TreeSelectionSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the TreeSelection.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *TreeSelection) ConnectChanged(callback TreeSelectionSignalChangedCallback) int {
	signalTreeSelectionChangedLock.Lock()
	defer signalTreeSelectionChangedLock.Unlock()

	signalTreeSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeSelection_signal_connect_changed(instance, C.gpointer(uintptr(signalTreeSelectionChangedId)))

	detail := signalTreeSelectionChangedDetail{callback, handlerID}
	signalTreeSelectionChangedMap[signalTreeSelectionChangedId] = detail

	return signalTreeSelectionChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the TreeSelection.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *TreeSelection) DisconnectChanged(connectionID int) {
	signalTreeSelectionChangedLock.Lock()
	defer signalTreeSelectionChangedLock.Unlock()

	detail, exists := signalTreeSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeSelectionChangedMap, connectionID)
}

//export treeselection_changedHandler
func treeselection_changedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeSelectionChangedLock.RLock()
	defer signalTreeSelectionChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeSelectionChangedMap[index].callback
	callback()
}

// Blacklisted : gtk_tree_selection_get_mode

// Blacklisted : gtk_tree_selection_get_selected

// Blacklisted : gtk_tree_selection_get_tree_view

// Unsupported : gtk_tree_selection_get_user_data : no return generator

// Blacklisted : gtk_tree_selection_iter_is_selected

// Blacklisted : gtk_tree_selection_path_is_selected

// Blacklisted : gtk_tree_selection_select_all

// Blacklisted : gtk_tree_selection_select_iter

// Blacklisted : gtk_tree_selection_select_path

// Blacklisted : gtk_tree_selection_select_range

// Unsupported : gtk_tree_selection_selected_foreach : unsupported parameter func : no type generator for TreeSelectionForeachFunc (GtkTreeSelectionForeachFunc) for param func

// Blacklisted : gtk_tree_selection_set_mode

// Unsupported : gtk_tree_selection_set_select_function : unsupported parameter func : no type generator for TreeSelectionFunc (GtkTreeSelectionFunc) for param func

// Blacklisted : gtk_tree_selection_unselect_all

// Blacklisted : gtk_tree_selection_unselect_iter

// Blacklisted : gtk_tree_selection_unselect_path

// TreeStore is a wrapper around the C record GtkTreeStore.
type TreeStore struct {
	native *C.GtkTreeStore
	// parent : record
	// priv : record
}

func TreeStoreNewFromC(u unsafe.Pointer) *TreeStore {
	c := (*C.GtkTreeStore)(u)
	if c == nil {
		return nil
	}

	g := &TreeStore{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeStore) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeStore with another TreeStore, and returns true if they represent the same GObject.
func (recv *TreeStore) Equals(other *TreeStore) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TreeStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TreeStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeStore.
func CastToTreeStore(object *gobject.Object) *TreeStore {
	return TreeStoreNewFromC(object.ToC())
}

// Unsupported : gtk_tree_store_new : unsupported parameter ... : varargs

// Blacklisted : gtk_tree_store_newv

// Blacklisted : gtk_tree_store_append

// Blacklisted : gtk_tree_store_clear

// Blacklisted : gtk_tree_store_insert

// Blacklisted : gtk_tree_store_insert_after

// Blacklisted : gtk_tree_store_insert_before

// Blacklisted : gtk_tree_store_is_ancestor

// Blacklisted : gtk_tree_store_iter_depth

// Blacklisted : gtk_tree_store_prepend

// Blacklisted : gtk_tree_store_remove

// Unsupported : gtk_tree_store_set : unsupported parameter ... : varargs

// Blacklisted : gtk_tree_store_set_column_types

// Unsupported : gtk_tree_store_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Blacklisted : gtk_tree_store_set_value

// Buildable returns the Buildable interface implemented by TreeStore
func (recv *TreeStore) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TreeDragDest returns the TreeDragDest interface implemented by TreeStore
func (recv *TreeStore) TreeDragDest() *TreeDragDest {
	return TreeDragDestNewFromC(recv.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeStore
func (recv *TreeStore) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeStore
func (recv *TreeStore) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by TreeStore
func (recv *TreeStore) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// TreeView is a wrapper around the C record GtkTreeView.
type TreeView struct {
	native *C.GtkTreeView
	// parent : record
	// Private : priv
}

func TreeViewNewFromC(u unsafe.Pointer) *TreeView {
	c := (*C.GtkTreeView)(u)
	if c == nil {
		return nil
	}

	g := &TreeView{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeView) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeView with another TreeView, and returns true if they represent the same GObject.
func (recv *TreeView) Equals(other *TreeView) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *TreeView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *TreeView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TreeView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TreeView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to TreeView.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeView.
func CastToTreeView(object *gobject.Object) *TreeView {
	return TreeViewNewFromC(object.ToC())
}

type signalTreeViewColumnsChangedDetail struct {
	callback  TreeViewSignalColumnsChangedCallback
	handlerID C.gulong
}

var signalTreeViewColumnsChangedId int
var signalTreeViewColumnsChangedMap = make(map[int]signalTreeViewColumnsChangedDetail)
var signalTreeViewColumnsChangedLock sync.RWMutex

// TreeViewSignalColumnsChangedCallback is a callback function for a 'columns-changed' signal emitted from a TreeView.
type TreeViewSignalColumnsChangedCallback func()

/*
ConnectColumnsChanged connects the callback to the 'columns-changed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectColumnsChanged to remove it.
*/
func (recv *TreeView) ConnectColumnsChanged(callback TreeViewSignalColumnsChangedCallback) int {
	signalTreeViewColumnsChangedLock.Lock()
	defer signalTreeViewColumnsChangedLock.Unlock()

	signalTreeViewColumnsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_columns_changed(instance, C.gpointer(uintptr(signalTreeViewColumnsChangedId)))

	detail := signalTreeViewColumnsChangedDetail{callback, handlerID}
	signalTreeViewColumnsChangedMap[signalTreeViewColumnsChangedId] = detail

	return signalTreeViewColumnsChangedId
}

/*
DisconnectColumnsChanged disconnects a callback from the 'columns-changed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectColumnsChanged.
*/
func (recv *TreeView) DisconnectColumnsChanged(connectionID int) {
	signalTreeViewColumnsChangedLock.Lock()
	defer signalTreeViewColumnsChangedLock.Unlock()

	detail, exists := signalTreeViewColumnsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewColumnsChangedMap, connectionID)
}

//export treeview_columnsChangedHandler
func treeview_columnsChangedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeViewColumnsChangedLock.RLock()
	defer signalTreeViewColumnsChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewColumnsChangedMap[index].callback
	callback()
}

type signalTreeViewCursorChangedDetail struct {
	callback  TreeViewSignalCursorChangedCallback
	handlerID C.gulong
}

var signalTreeViewCursorChangedId int
var signalTreeViewCursorChangedMap = make(map[int]signalTreeViewCursorChangedDetail)
var signalTreeViewCursorChangedLock sync.RWMutex

// TreeViewSignalCursorChangedCallback is a callback function for a 'cursor-changed' signal emitted from a TreeView.
type TreeViewSignalCursorChangedCallback func()

/*
ConnectCursorChanged connects the callback to the 'cursor-changed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectCursorChanged to remove it.
*/
func (recv *TreeView) ConnectCursorChanged(callback TreeViewSignalCursorChangedCallback) int {
	signalTreeViewCursorChangedLock.Lock()
	defer signalTreeViewCursorChangedLock.Unlock()

	signalTreeViewCursorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_cursor_changed(instance, C.gpointer(uintptr(signalTreeViewCursorChangedId)))

	detail := signalTreeViewCursorChangedDetail{callback, handlerID}
	signalTreeViewCursorChangedMap[signalTreeViewCursorChangedId] = detail

	return signalTreeViewCursorChangedId
}

/*
DisconnectCursorChanged disconnects a callback from the 'cursor-changed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectCursorChanged.
*/
func (recv *TreeView) DisconnectCursorChanged(connectionID int) {
	signalTreeViewCursorChangedLock.Lock()
	defer signalTreeViewCursorChangedLock.Unlock()

	detail, exists := signalTreeViewCursorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewCursorChangedMap, connectionID)
}

//export treeview_cursorChangedHandler
func treeview_cursorChangedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeViewCursorChangedLock.RLock()
	defer signalTreeViewCursorChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewCursorChangedMap[index].callback
	callback()
}

type signalTreeViewExpandCollapseCursorRowDetail struct {
	callback  TreeViewSignalExpandCollapseCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewExpandCollapseCursorRowId int
var signalTreeViewExpandCollapseCursorRowMap = make(map[int]signalTreeViewExpandCollapseCursorRowDetail)
var signalTreeViewExpandCollapseCursorRowLock sync.RWMutex

// TreeViewSignalExpandCollapseCursorRowCallback is a callback function for a 'expand-collapse-cursor-row' signal emitted from a TreeView.
type TreeViewSignalExpandCollapseCursorRowCallback func(object bool, p0 bool, p1 bool) bool

/*
ConnectExpandCollapseCursorRow connects the callback to the 'expand-collapse-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectExpandCollapseCursorRow to remove it.
*/
func (recv *TreeView) ConnectExpandCollapseCursorRow(callback TreeViewSignalExpandCollapseCursorRowCallback) int {
	signalTreeViewExpandCollapseCursorRowLock.Lock()
	defer signalTreeViewExpandCollapseCursorRowLock.Unlock()

	signalTreeViewExpandCollapseCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_expand_collapse_cursor_row(instance, C.gpointer(uintptr(signalTreeViewExpandCollapseCursorRowId)))

	detail := signalTreeViewExpandCollapseCursorRowDetail{callback, handlerID}
	signalTreeViewExpandCollapseCursorRowMap[signalTreeViewExpandCollapseCursorRowId] = detail

	return signalTreeViewExpandCollapseCursorRowId
}

/*
DisconnectExpandCollapseCursorRow disconnects a callback from the 'expand-collapse-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectExpandCollapseCursorRow.
*/
func (recv *TreeView) DisconnectExpandCollapseCursorRow(connectionID int) {
	signalTreeViewExpandCollapseCursorRowLock.Lock()
	defer signalTreeViewExpandCollapseCursorRowLock.Unlock()

	detail, exists := signalTreeViewExpandCollapseCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewExpandCollapseCursorRowMap, connectionID)
}

//export treeview_expandCollapseCursorRowHandler
func treeview_expandCollapseCursorRowHandler(_ *C.GObject, c_object C.gboolean, c_p0 C.gboolean, c_p1 C.gboolean, data C.gpointer) C.gboolean {
	signalTreeViewExpandCollapseCursorRowLock.RLock()
	defer signalTreeViewExpandCollapseCursorRowLock.RUnlock()

	object := c_object == C.TRUE

	p0 := c_p0 == C.TRUE

	p1 := c_p1 == C.TRUE

	index := int(uintptr(data))
	callback := signalTreeViewExpandCollapseCursorRowMap[index].callback
	retGo := callback(object, p0, p1)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewMoveCursorDetail struct {
	callback  TreeViewSignalMoveCursorCallback
	handlerID C.gulong
}

var signalTreeViewMoveCursorId int
var signalTreeViewMoveCursorMap = make(map[int]signalTreeViewMoveCursorDetail)
var signalTreeViewMoveCursorLock sync.RWMutex

// TreeViewSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a TreeView.
type TreeViewSignalMoveCursorCallback func(step MovementStep, direction int32) bool

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *TreeView) ConnectMoveCursor(callback TreeViewSignalMoveCursorCallback) int {
	signalTreeViewMoveCursorLock.Lock()
	defer signalTreeViewMoveCursorLock.Unlock()

	signalTreeViewMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalTreeViewMoveCursorId)))

	detail := signalTreeViewMoveCursorDetail{callback, handlerID}
	signalTreeViewMoveCursorMap[signalTreeViewMoveCursorId] = detail

	return signalTreeViewMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *TreeView) DisconnectMoveCursor(connectionID int) {
	signalTreeViewMoveCursorLock.Lock()
	defer signalTreeViewMoveCursorLock.Unlock()

	detail, exists := signalTreeViewMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewMoveCursorMap, connectionID)
}

//export treeview_moveCursorHandler
func treeview_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_direction C.gint, data C.gpointer) C.gboolean {
	signalTreeViewMoveCursorLock.RLock()
	defer signalTreeViewMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	direction := int32(c_direction)

	index := int(uintptr(data))
	callback := signalTreeViewMoveCursorMap[index].callback
	retGo := callback(step, direction)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewRowActivatedDetail struct {
	callback  TreeViewSignalRowActivatedCallback
	handlerID C.gulong
}

var signalTreeViewRowActivatedId int
var signalTreeViewRowActivatedMap = make(map[int]signalTreeViewRowActivatedDetail)
var signalTreeViewRowActivatedLock sync.RWMutex

// TreeViewSignalRowActivatedCallback is a callback function for a 'row-activated' signal emitted from a TreeView.
type TreeViewSignalRowActivatedCallback func(path *TreePath, column *TreeViewColumn)

/*
ConnectRowActivated connects the callback to the 'row-activated' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowActivated to remove it.
*/
func (recv *TreeView) ConnectRowActivated(callback TreeViewSignalRowActivatedCallback) int {
	signalTreeViewRowActivatedLock.Lock()
	defer signalTreeViewRowActivatedLock.Unlock()

	signalTreeViewRowActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_activated(instance, C.gpointer(uintptr(signalTreeViewRowActivatedId)))

	detail := signalTreeViewRowActivatedDetail{callback, handlerID}
	signalTreeViewRowActivatedMap[signalTreeViewRowActivatedId] = detail

	return signalTreeViewRowActivatedId
}

/*
DisconnectRowActivated disconnects a callback from the 'row-activated' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowActivated.
*/
func (recv *TreeView) DisconnectRowActivated(connectionID int) {
	signalTreeViewRowActivatedLock.Lock()
	defer signalTreeViewRowActivatedLock.Unlock()

	detail, exists := signalTreeViewRowActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowActivatedMap, connectionID)
}

//export treeview_rowActivatedHandler
func treeview_rowActivatedHandler(_ *C.GObject, c_path *C.GtkTreePath, c_column *C.GtkTreeViewColumn, data C.gpointer) {
	signalTreeViewRowActivatedLock.RLock()
	defer signalTreeViewRowActivatedLock.RUnlock()

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	column := TreeViewColumnNewFromC(unsafe.Pointer(c_column))

	index := int(uintptr(data))
	callback := signalTreeViewRowActivatedMap[index].callback
	callback(path, column)
}

type signalTreeViewRowCollapsedDetail struct {
	callback  TreeViewSignalRowCollapsedCallback
	handlerID C.gulong
}

var signalTreeViewRowCollapsedId int
var signalTreeViewRowCollapsedMap = make(map[int]signalTreeViewRowCollapsedDetail)
var signalTreeViewRowCollapsedLock sync.RWMutex

// TreeViewSignalRowCollapsedCallback is a callback function for a 'row-collapsed' signal emitted from a TreeView.
type TreeViewSignalRowCollapsedCallback func(iter *TreeIter, path *TreePath)

/*
ConnectRowCollapsed connects the callback to the 'row-collapsed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowCollapsed to remove it.
*/
func (recv *TreeView) ConnectRowCollapsed(callback TreeViewSignalRowCollapsedCallback) int {
	signalTreeViewRowCollapsedLock.Lock()
	defer signalTreeViewRowCollapsedLock.Unlock()

	signalTreeViewRowCollapsedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_collapsed(instance, C.gpointer(uintptr(signalTreeViewRowCollapsedId)))

	detail := signalTreeViewRowCollapsedDetail{callback, handlerID}
	signalTreeViewRowCollapsedMap[signalTreeViewRowCollapsedId] = detail

	return signalTreeViewRowCollapsedId
}

/*
DisconnectRowCollapsed disconnects a callback from the 'row-collapsed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowCollapsed.
*/
func (recv *TreeView) DisconnectRowCollapsed(connectionID int) {
	signalTreeViewRowCollapsedLock.Lock()
	defer signalTreeViewRowCollapsedLock.Unlock()

	detail, exists := signalTreeViewRowCollapsedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowCollapsedMap, connectionID)
}

//export treeview_rowCollapsedHandler
func treeview_rowCollapsedHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) {
	signalTreeViewRowCollapsedLock.RLock()
	defer signalTreeViewRowCollapsedLock.RUnlock()

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewRowCollapsedMap[index].callback
	callback(iter, path)
}

type signalTreeViewRowExpandedDetail struct {
	callback  TreeViewSignalRowExpandedCallback
	handlerID C.gulong
}

var signalTreeViewRowExpandedId int
var signalTreeViewRowExpandedMap = make(map[int]signalTreeViewRowExpandedDetail)
var signalTreeViewRowExpandedLock sync.RWMutex

// TreeViewSignalRowExpandedCallback is a callback function for a 'row-expanded' signal emitted from a TreeView.
type TreeViewSignalRowExpandedCallback func(iter *TreeIter, path *TreePath)

/*
ConnectRowExpanded connects the callback to the 'row-expanded' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowExpanded to remove it.
*/
func (recv *TreeView) ConnectRowExpanded(callback TreeViewSignalRowExpandedCallback) int {
	signalTreeViewRowExpandedLock.Lock()
	defer signalTreeViewRowExpandedLock.Unlock()

	signalTreeViewRowExpandedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_expanded(instance, C.gpointer(uintptr(signalTreeViewRowExpandedId)))

	detail := signalTreeViewRowExpandedDetail{callback, handlerID}
	signalTreeViewRowExpandedMap[signalTreeViewRowExpandedId] = detail

	return signalTreeViewRowExpandedId
}

/*
DisconnectRowExpanded disconnects a callback from the 'row-expanded' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowExpanded.
*/
func (recv *TreeView) DisconnectRowExpanded(connectionID int) {
	signalTreeViewRowExpandedLock.Lock()
	defer signalTreeViewRowExpandedLock.Unlock()

	detail, exists := signalTreeViewRowExpandedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowExpandedMap, connectionID)
}

//export treeview_rowExpandedHandler
func treeview_rowExpandedHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) {
	signalTreeViewRowExpandedLock.RLock()
	defer signalTreeViewRowExpandedLock.RUnlock()

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewRowExpandedMap[index].callback
	callback(iter, path)
}

type signalTreeViewSelectAllDetail struct {
	callback  TreeViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalTreeViewSelectAllId int
var signalTreeViewSelectAllMap = make(map[int]signalTreeViewSelectAllDetail)
var signalTreeViewSelectAllLock sync.RWMutex

// TreeViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a TreeView.
type TreeViewSignalSelectAllCallback func() bool

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *TreeView) ConnectSelectAll(callback TreeViewSignalSelectAllCallback) int {
	signalTreeViewSelectAllLock.Lock()
	defer signalTreeViewSelectAllLock.Unlock()

	signalTreeViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_all(instance, C.gpointer(uintptr(signalTreeViewSelectAllId)))

	detail := signalTreeViewSelectAllDetail{callback, handlerID}
	signalTreeViewSelectAllMap[signalTreeViewSelectAllId] = detail

	return signalTreeViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *TreeView) DisconnectSelectAll(connectionID int) {
	signalTreeViewSelectAllLock.Lock()
	defer signalTreeViewSelectAllLock.Unlock()

	detail, exists := signalTreeViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectAllMap, connectionID)
}

//export treeview_selectAllHandler
func treeview_selectAllHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewSelectAllLock.RLock()
	defer signalTreeViewSelectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewSelectAllMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewSelectCursorParentDetail struct {
	callback  TreeViewSignalSelectCursorParentCallback
	handlerID C.gulong
}

var signalTreeViewSelectCursorParentId int
var signalTreeViewSelectCursorParentMap = make(map[int]signalTreeViewSelectCursorParentDetail)
var signalTreeViewSelectCursorParentLock sync.RWMutex

// TreeViewSignalSelectCursorParentCallback is a callback function for a 'select-cursor-parent' signal emitted from a TreeView.
type TreeViewSignalSelectCursorParentCallback func() bool

/*
ConnectSelectCursorParent connects the callback to the 'select-cursor-parent' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorParent to remove it.
*/
func (recv *TreeView) ConnectSelectCursorParent(callback TreeViewSignalSelectCursorParentCallback) int {
	signalTreeViewSelectCursorParentLock.Lock()
	defer signalTreeViewSelectCursorParentLock.Unlock()

	signalTreeViewSelectCursorParentId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_cursor_parent(instance, C.gpointer(uintptr(signalTreeViewSelectCursorParentId)))

	detail := signalTreeViewSelectCursorParentDetail{callback, handlerID}
	signalTreeViewSelectCursorParentMap[signalTreeViewSelectCursorParentId] = detail

	return signalTreeViewSelectCursorParentId
}

/*
DisconnectSelectCursorParent disconnects a callback from the 'select-cursor-parent' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectCursorParent.
*/
func (recv *TreeView) DisconnectSelectCursorParent(connectionID int) {
	signalTreeViewSelectCursorParentLock.Lock()
	defer signalTreeViewSelectCursorParentLock.Unlock()

	detail, exists := signalTreeViewSelectCursorParentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectCursorParentMap, connectionID)
}

//export treeview_selectCursorParentHandler
func treeview_selectCursorParentHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewSelectCursorParentLock.RLock()
	defer signalTreeViewSelectCursorParentLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewSelectCursorParentMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewSelectCursorRowDetail struct {
	callback  TreeViewSignalSelectCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewSelectCursorRowId int
var signalTreeViewSelectCursorRowMap = make(map[int]signalTreeViewSelectCursorRowDetail)
var signalTreeViewSelectCursorRowLock sync.RWMutex

// TreeViewSignalSelectCursorRowCallback is a callback function for a 'select-cursor-row' signal emitted from a TreeView.
type TreeViewSignalSelectCursorRowCallback func(object bool) bool

/*
ConnectSelectCursorRow connects the callback to the 'select-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorRow to remove it.
*/
func (recv *TreeView) ConnectSelectCursorRow(callback TreeViewSignalSelectCursorRowCallback) int {
	signalTreeViewSelectCursorRowLock.Lock()
	defer signalTreeViewSelectCursorRowLock.Unlock()

	signalTreeViewSelectCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_cursor_row(instance, C.gpointer(uintptr(signalTreeViewSelectCursorRowId)))

	detail := signalTreeViewSelectCursorRowDetail{callback, handlerID}
	signalTreeViewSelectCursorRowMap[signalTreeViewSelectCursorRowId] = detail

	return signalTreeViewSelectCursorRowId
}

/*
DisconnectSelectCursorRow disconnects a callback from the 'select-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectCursorRow.
*/
func (recv *TreeView) DisconnectSelectCursorRow(connectionID int) {
	signalTreeViewSelectCursorRowLock.Lock()
	defer signalTreeViewSelectCursorRowLock.Unlock()

	detail, exists := signalTreeViewSelectCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectCursorRowMap, connectionID)
}

//export treeview_selectCursorRowHandler
func treeview_selectCursorRowHandler(_ *C.GObject, c_object C.gboolean, data C.gpointer) C.gboolean {
	signalTreeViewSelectCursorRowLock.RLock()
	defer signalTreeViewSelectCursorRowLock.RUnlock()

	object := c_object == C.TRUE

	index := int(uintptr(data))
	callback := signalTreeViewSelectCursorRowMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewStartInteractiveSearchDetail struct {
	callback  TreeViewSignalStartInteractiveSearchCallback
	handlerID C.gulong
}

var signalTreeViewStartInteractiveSearchId int
var signalTreeViewStartInteractiveSearchMap = make(map[int]signalTreeViewStartInteractiveSearchDetail)
var signalTreeViewStartInteractiveSearchLock sync.RWMutex

// TreeViewSignalStartInteractiveSearchCallback is a callback function for a 'start-interactive-search' signal emitted from a TreeView.
type TreeViewSignalStartInteractiveSearchCallback func() bool

/*
ConnectStartInteractiveSearch connects the callback to the 'start-interactive-search' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectStartInteractiveSearch to remove it.
*/
func (recv *TreeView) ConnectStartInteractiveSearch(callback TreeViewSignalStartInteractiveSearchCallback) int {
	signalTreeViewStartInteractiveSearchLock.Lock()
	defer signalTreeViewStartInteractiveSearchLock.Unlock()

	signalTreeViewStartInteractiveSearchId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_start_interactive_search(instance, C.gpointer(uintptr(signalTreeViewStartInteractiveSearchId)))

	detail := signalTreeViewStartInteractiveSearchDetail{callback, handlerID}
	signalTreeViewStartInteractiveSearchMap[signalTreeViewStartInteractiveSearchId] = detail

	return signalTreeViewStartInteractiveSearchId
}

/*
DisconnectStartInteractiveSearch disconnects a callback from the 'start-interactive-search' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectStartInteractiveSearch.
*/
func (recv *TreeView) DisconnectStartInteractiveSearch(connectionID int) {
	signalTreeViewStartInteractiveSearchLock.Lock()
	defer signalTreeViewStartInteractiveSearchLock.Unlock()

	detail, exists := signalTreeViewStartInteractiveSearchMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewStartInteractiveSearchMap, connectionID)
}

//export treeview_startInteractiveSearchHandler
func treeview_startInteractiveSearchHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewStartInteractiveSearchLock.RLock()
	defer signalTreeViewStartInteractiveSearchLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewStartInteractiveSearchMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewTestCollapseRowDetail struct {
	callback  TreeViewSignalTestCollapseRowCallback
	handlerID C.gulong
}

var signalTreeViewTestCollapseRowId int
var signalTreeViewTestCollapseRowMap = make(map[int]signalTreeViewTestCollapseRowDetail)
var signalTreeViewTestCollapseRowLock sync.RWMutex

// TreeViewSignalTestCollapseRowCallback is a callback function for a 'test-collapse-row' signal emitted from a TreeView.
type TreeViewSignalTestCollapseRowCallback func(iter *TreeIter, path *TreePath) bool

/*
ConnectTestCollapseRow connects the callback to the 'test-collapse-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectTestCollapseRow to remove it.
*/
func (recv *TreeView) ConnectTestCollapseRow(callback TreeViewSignalTestCollapseRowCallback) int {
	signalTreeViewTestCollapseRowLock.Lock()
	defer signalTreeViewTestCollapseRowLock.Unlock()

	signalTreeViewTestCollapseRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_test_collapse_row(instance, C.gpointer(uintptr(signalTreeViewTestCollapseRowId)))

	detail := signalTreeViewTestCollapseRowDetail{callback, handlerID}
	signalTreeViewTestCollapseRowMap[signalTreeViewTestCollapseRowId] = detail

	return signalTreeViewTestCollapseRowId
}

/*
DisconnectTestCollapseRow disconnects a callback from the 'test-collapse-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectTestCollapseRow.
*/
func (recv *TreeView) DisconnectTestCollapseRow(connectionID int) {
	signalTreeViewTestCollapseRowLock.Lock()
	defer signalTreeViewTestCollapseRowLock.Unlock()

	detail, exists := signalTreeViewTestCollapseRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewTestCollapseRowMap, connectionID)
}

//export treeview_testCollapseRowHandler
func treeview_testCollapseRowHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) C.gboolean {
	signalTreeViewTestCollapseRowLock.RLock()
	defer signalTreeViewTestCollapseRowLock.RUnlock()

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewTestCollapseRowMap[index].callback
	retGo := callback(iter, path)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewTestExpandRowDetail struct {
	callback  TreeViewSignalTestExpandRowCallback
	handlerID C.gulong
}

var signalTreeViewTestExpandRowId int
var signalTreeViewTestExpandRowMap = make(map[int]signalTreeViewTestExpandRowDetail)
var signalTreeViewTestExpandRowLock sync.RWMutex

// TreeViewSignalTestExpandRowCallback is a callback function for a 'test-expand-row' signal emitted from a TreeView.
type TreeViewSignalTestExpandRowCallback func(iter *TreeIter, path *TreePath) bool

/*
ConnectTestExpandRow connects the callback to the 'test-expand-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectTestExpandRow to remove it.
*/
func (recv *TreeView) ConnectTestExpandRow(callback TreeViewSignalTestExpandRowCallback) int {
	signalTreeViewTestExpandRowLock.Lock()
	defer signalTreeViewTestExpandRowLock.Unlock()

	signalTreeViewTestExpandRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_test_expand_row(instance, C.gpointer(uintptr(signalTreeViewTestExpandRowId)))

	detail := signalTreeViewTestExpandRowDetail{callback, handlerID}
	signalTreeViewTestExpandRowMap[signalTreeViewTestExpandRowId] = detail

	return signalTreeViewTestExpandRowId
}

/*
DisconnectTestExpandRow disconnects a callback from the 'test-expand-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectTestExpandRow.
*/
func (recv *TreeView) DisconnectTestExpandRow(connectionID int) {
	signalTreeViewTestExpandRowLock.Lock()
	defer signalTreeViewTestExpandRowLock.Unlock()

	detail, exists := signalTreeViewTestExpandRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewTestExpandRowMap, connectionID)
}

//export treeview_testExpandRowHandler
func treeview_testExpandRowHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) C.gboolean {
	signalTreeViewTestExpandRowLock.RLock()
	defer signalTreeViewTestExpandRowLock.RUnlock()

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewTestExpandRowMap[index].callback
	retGo := callback(iter, path)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewToggleCursorRowDetail struct {
	callback  TreeViewSignalToggleCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewToggleCursorRowId int
var signalTreeViewToggleCursorRowMap = make(map[int]signalTreeViewToggleCursorRowDetail)
var signalTreeViewToggleCursorRowLock sync.RWMutex

// TreeViewSignalToggleCursorRowCallback is a callback function for a 'toggle-cursor-row' signal emitted from a TreeView.
type TreeViewSignalToggleCursorRowCallback func() bool

/*
ConnectToggleCursorRow connects the callback to the 'toggle-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorRow to remove it.
*/
func (recv *TreeView) ConnectToggleCursorRow(callback TreeViewSignalToggleCursorRowCallback) int {
	signalTreeViewToggleCursorRowLock.Lock()
	defer signalTreeViewToggleCursorRowLock.Unlock()

	signalTreeViewToggleCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_toggle_cursor_row(instance, C.gpointer(uintptr(signalTreeViewToggleCursorRowId)))

	detail := signalTreeViewToggleCursorRowDetail{callback, handlerID}
	signalTreeViewToggleCursorRowMap[signalTreeViewToggleCursorRowId] = detail

	return signalTreeViewToggleCursorRowId
}

/*
DisconnectToggleCursorRow disconnects a callback from the 'toggle-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectToggleCursorRow.
*/
func (recv *TreeView) DisconnectToggleCursorRow(connectionID int) {
	signalTreeViewToggleCursorRowLock.Lock()
	defer signalTreeViewToggleCursorRowLock.Unlock()

	detail, exists := signalTreeViewToggleCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewToggleCursorRowMap, connectionID)
}

//export treeview_toggleCursorRowHandler
func treeview_toggleCursorRowHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewToggleCursorRowLock.RLock()
	defer signalTreeViewToggleCursorRowLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewToggleCursorRowMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewUnselectAllDetail struct {
	callback  TreeViewSignalUnselectAllCallback
	handlerID C.gulong
}

var signalTreeViewUnselectAllId int
var signalTreeViewUnselectAllMap = make(map[int]signalTreeViewUnselectAllDetail)
var signalTreeViewUnselectAllLock sync.RWMutex

// TreeViewSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a TreeView.
type TreeViewSignalUnselectAllCallback func() bool

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *TreeView) ConnectUnselectAll(callback TreeViewSignalUnselectAllCallback) int {
	signalTreeViewUnselectAllLock.Lock()
	defer signalTreeViewUnselectAllLock.Unlock()

	signalTreeViewUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalTreeViewUnselectAllId)))

	detail := signalTreeViewUnselectAllDetail{callback, handlerID}
	signalTreeViewUnselectAllMap[signalTreeViewUnselectAllId] = detail

	return signalTreeViewUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *TreeView) DisconnectUnselectAll(connectionID int) {
	signalTreeViewUnselectAllLock.Lock()
	defer signalTreeViewUnselectAllLock.Unlock()

	detail, exists := signalTreeViewUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewUnselectAllMap, connectionID)
}

//export treeview_unselectAllHandler
func treeview_unselectAllHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewUnselectAllLock.RLock()
	defer signalTreeViewUnselectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewUnselectAllMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Blacklisted : gtk_tree_view_new

// Blacklisted : gtk_tree_view_new_with_model

// Blacklisted : gtk_tree_view_append_column

// Blacklisted : gtk_tree_view_collapse_all

// Blacklisted : gtk_tree_view_collapse_row

// Blacklisted : gtk_tree_view_columns_autosize

// Blacklisted : gtk_tree_view_create_row_drag_icon

// Unsupported : gtk_tree_view_enable_model_drag_dest : unsupported parameter targets :

// Unsupported : gtk_tree_view_enable_model_drag_source : unsupported parameter targets :

// Blacklisted : gtk_tree_view_expand_all

// Blacklisted : gtk_tree_view_expand_row

// Blacklisted : gtk_tree_view_get_background_area

// Blacklisted : gtk_tree_view_get_bin_window

// Blacklisted : gtk_tree_view_get_cell_area

// Blacklisted : gtk_tree_view_get_column

// Blacklisted : gtk_tree_view_get_columns

// Blacklisted : gtk_tree_view_get_cursor

// Unsupported : gtk_tree_view_get_dest_row_at_pos : unsupported parameter pos : GtkTreeViewDropPosition* with indirection level of 1

// Unsupported : gtk_tree_view_get_drag_dest_row : unsupported parameter pos : GtkTreeViewDropPosition* with indirection level of 1

// Blacklisted : gtk_tree_view_get_enable_search

// Blacklisted : gtk_tree_view_get_expander_column

// Blacklisted : gtk_tree_view_get_hadjustment

// Blacklisted : gtk_tree_view_get_headers_visible

// Blacklisted : gtk_tree_view_get_model

// Blacklisted : gtk_tree_view_get_path_at_pos

// Blacklisted : gtk_tree_view_get_reorderable

// Blacklisted : gtk_tree_view_get_rules_hint

// Blacklisted : gtk_tree_view_get_search_column

// Unsupported : gtk_tree_view_get_search_equal_func : no return generator

// Blacklisted : gtk_tree_view_get_selection

// Blacklisted : gtk_tree_view_get_vadjustment

// Blacklisted : gtk_tree_view_get_visible_rect

// Blacklisted : gtk_tree_view_insert_column

// Unsupported : gtk_tree_view_insert_column_with_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_tree_view_insert_column_with_data_func : unsupported parameter func : no type generator for TreeCellDataFunc (GtkTreeCellDataFunc) for param func

// Unsupported : gtk_tree_view_map_expanded_rows : unsupported parameter func : no type generator for TreeViewMappingFunc (GtkTreeViewMappingFunc) for param func

// Blacklisted : gtk_tree_view_move_column_after

// Blacklisted : gtk_tree_view_remove_column

// Blacklisted : gtk_tree_view_row_activated

// Blacklisted : gtk_tree_view_row_expanded

// Blacklisted : gtk_tree_view_scroll_to_cell

// Blacklisted : gtk_tree_view_scroll_to_point

// Unsupported : gtk_tree_view_set_column_drag_function : unsupported parameter func : no type generator for TreeViewColumnDropFunc (GtkTreeViewColumnDropFunc) for param func

// Blacklisted : gtk_tree_view_set_cursor

// Unsupported : gtk_tree_view_set_destroy_count_func : unsupported parameter func : no type generator for TreeDestroyCountFunc (GtkTreeDestroyCountFunc) for param func

// Blacklisted : gtk_tree_view_set_drag_dest_row

// Blacklisted : gtk_tree_view_set_enable_search

// Blacklisted : gtk_tree_view_set_expander_column

// Blacklisted : gtk_tree_view_set_hadjustment

// Blacklisted : gtk_tree_view_set_headers_clickable

// Blacklisted : gtk_tree_view_set_headers_visible

// Blacklisted : gtk_tree_view_set_model

// Blacklisted : gtk_tree_view_set_reorderable

// Blacklisted : gtk_tree_view_set_rules_hint

// Blacklisted : gtk_tree_view_set_search_column

// Unsupported : gtk_tree_view_set_search_equal_func : unsupported parameter search_equal_func : no type generator for TreeViewSearchEqualFunc (GtkTreeViewSearchEqualFunc) for param search_equal_func

// Blacklisted : gtk_tree_view_set_vadjustment

// Blacklisted : gtk_tree_view_unset_rows_drag_dest

// Blacklisted : gtk_tree_view_unset_rows_drag_source

// ImplementorIface returns the ImplementorIface interface implemented by TreeView
func (recv *TreeView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TreeView
func (recv *TreeView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by TreeView
func (recv *TreeView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// TreeViewAccessible is a wrapper around the C record GtkTreeViewAccessible.
type TreeViewAccessible struct {
	native *C.GtkTreeViewAccessible
	// parent : record
	// priv : record
}

func TreeViewAccessibleNewFromC(u unsafe.Pointer) *TreeViewAccessible {
	c := (*C.GtkTreeViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeViewAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewAccessible with another TreeViewAccessible, and returns true if they represent the same GObject.
func (recv *TreeViewAccessible) Equals(other *TreeViewAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *TreeViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *TreeViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TreeViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TreeViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to TreeViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeViewAccessible.
func CastToTreeViewAccessible(object *gobject.Object) *TreeViewAccessible {
	return TreeViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Table returns the Table interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Table() *atk.Table {
	return atk.TableNewFromC(recv.ToC())
}

// CellAccessibleParent returns the CellAccessibleParent interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) CellAccessibleParent() *CellAccessibleParent {
	return CellAccessibleParentNewFromC(recv.ToC())
}

// TreeViewColumn is a wrapper around the C record GtkTreeViewColumn.
type TreeViewColumn struct {
	native *C.GtkTreeViewColumn
	// parent_instance : record
	// priv : record
}

func TreeViewColumnNewFromC(u unsafe.Pointer) *TreeViewColumn {
	c := (*C.GtkTreeViewColumn)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewColumn{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeViewColumn) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeViewColumn) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewColumn with another TreeViewColumn, and returns true if they represent the same GObject.
func (recv *TreeViewColumn) Equals(other *TreeViewColumn) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TreeViewColumn) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *TreeViewColumn) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to TreeViewColumn.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeViewColumn.
func CastToTreeViewColumn(object *gobject.Object) *TreeViewColumn {
	return TreeViewColumnNewFromC(object.ToC())
}

type signalTreeViewColumnClickedDetail struct {
	callback  TreeViewColumnSignalClickedCallback
	handlerID C.gulong
}

var signalTreeViewColumnClickedId int
var signalTreeViewColumnClickedMap = make(map[int]signalTreeViewColumnClickedDetail)
var signalTreeViewColumnClickedLock sync.RWMutex

// TreeViewColumnSignalClickedCallback is a callback function for a 'clicked' signal emitted from a TreeViewColumn.
type TreeViewColumnSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the TreeViewColumn.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *TreeViewColumn) ConnectClicked(callback TreeViewColumnSignalClickedCallback) int {
	signalTreeViewColumnClickedLock.Lock()
	defer signalTreeViewColumnClickedLock.Unlock()

	signalTreeViewColumnClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeViewColumn_signal_connect_clicked(instance, C.gpointer(uintptr(signalTreeViewColumnClickedId)))

	detail := signalTreeViewColumnClickedDetail{callback, handlerID}
	signalTreeViewColumnClickedMap[signalTreeViewColumnClickedId] = detail

	return signalTreeViewColumnClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the TreeViewColumn.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *TreeViewColumn) DisconnectClicked(connectionID int) {
	signalTreeViewColumnClickedLock.Lock()
	defer signalTreeViewColumnClickedLock.Unlock()

	detail, exists := signalTreeViewColumnClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewColumnClickedMap, connectionID)
}

//export treeviewcolumn_clickedHandler
func treeviewcolumn_clickedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeViewColumnClickedLock.RLock()
	defer signalTreeViewColumnClickedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewColumnClickedMap[index].callback
	callback()
}

// Blacklisted : gtk_tree_view_column_new

// Unsupported : gtk_tree_view_column_new_with_attributes : unsupported parameter ... : varargs

// Blacklisted : gtk_tree_view_column_add_attribute

// Blacklisted : gtk_tree_view_column_cell_get_position

// Blacklisted : gtk_tree_view_column_cell_get_size

// Blacklisted : gtk_tree_view_column_cell_is_visible

// Blacklisted : gtk_tree_view_column_cell_set_cell_data

// Blacklisted : gtk_tree_view_column_clear

// Blacklisted : gtk_tree_view_column_clear_attributes

// Blacklisted : gtk_tree_view_column_clicked

// Blacklisted : gtk_tree_view_column_get_alignment

// Blacklisted : gtk_tree_view_column_get_clickable

// Blacklisted : gtk_tree_view_column_get_fixed_width

// Blacklisted : gtk_tree_view_column_get_max_width

// Blacklisted : gtk_tree_view_column_get_min_width

// Blacklisted : gtk_tree_view_column_get_reorderable

// Blacklisted : gtk_tree_view_column_get_resizable

// Blacklisted : gtk_tree_view_column_get_sizing

// Blacklisted : gtk_tree_view_column_get_sort_column_id

// Blacklisted : gtk_tree_view_column_get_sort_indicator

// Blacklisted : gtk_tree_view_column_get_sort_order

// Blacklisted : gtk_tree_view_column_get_spacing

// GetTitle is a wrapper around the C function gtk_tree_view_column_get_title.
func (recv *TreeViewColumn) GetTitle() string {
	retC := C.gtk_tree_view_column_get_title((*C.GtkTreeViewColumn)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Blacklisted : gtk_tree_view_column_get_visible

// Blacklisted : gtk_tree_view_column_get_widget

// Blacklisted : gtk_tree_view_column_get_width

// Blacklisted : gtk_tree_view_column_pack_end

// Blacklisted : gtk_tree_view_column_pack_start

// Blacklisted : gtk_tree_view_column_set_alignment

// Unsupported : gtk_tree_view_column_set_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_tree_view_column_set_cell_data_func : unsupported parameter func : no type generator for TreeCellDataFunc (GtkTreeCellDataFunc) for param func

// Blacklisted : gtk_tree_view_column_set_clickable

// Blacklisted : gtk_tree_view_column_set_fixed_width

// Blacklisted : gtk_tree_view_column_set_max_width

// Blacklisted : gtk_tree_view_column_set_min_width

// Blacklisted : gtk_tree_view_column_set_reorderable

// Blacklisted : gtk_tree_view_column_set_resizable

// Blacklisted : gtk_tree_view_column_set_sizing

// Blacklisted : gtk_tree_view_column_set_sort_column_id

// Blacklisted : gtk_tree_view_column_set_sort_indicator

// Blacklisted : gtk_tree_view_column_set_sort_order

// Blacklisted : gtk_tree_view_column_set_spacing

// SetTitle is a wrapper around the C function gtk_tree_view_column_set_title.
func (recv *TreeViewColumn) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_tree_view_column_set_title((*C.GtkTreeViewColumn)(recv.native), c_title)

	return
}

// Blacklisted : gtk_tree_view_column_set_visible

// Blacklisted : gtk_tree_view_column_set_widget

// Buildable returns the Buildable interface implemented by TreeViewColumn
func (recv *TreeViewColumn) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by TreeViewColumn
func (recv *TreeViewColumn) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// UIManager is a wrapper around the C record GtkUIManager.
type UIManager struct {
	native *C.GtkUIManager
	// parent : record
	// Private : private_data
}

func UIManagerNewFromC(u unsafe.Pointer) *UIManager {
	c := (*C.GtkUIManager)(u)
	if c == nil {
		return nil
	}

	g := &UIManager{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UIManager) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UIManager) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UIManager with another UIManager, and returns true if they represent the same GObject.
func (recv *UIManager) Equals(other *UIManager) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *UIManager) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to UIManager.
// Exercise care, as this is a potentially dangerous function if the Object is not a UIManager.
func CastToUIManager(object *gobject.Object) *UIManager {
	return UIManagerNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by UIManager
func (recv *UIManager) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// VBox is a wrapper around the C record GtkVBox.
type VBox struct {
	native *C.GtkVBox
	// box : record
}

func VBoxNewFromC(u unsafe.Pointer) *VBox {
	c := (*C.GtkVBox)(u)
	if c == nil {
		return nil
	}

	g := &VBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VBox with another VBox, and returns true if they represent the same GObject.
func (recv *VBox) Equals(other *VBox) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *VBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *VBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *VBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to VBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a VBox.
func CastToVBox(object *gobject.Object) *VBox {
	return VBoxNewFromC(object.ToC())
}

// Blacklisted : gtk_vbox_new

// ImplementorIface returns the ImplementorIface interface implemented by VBox
func (recv *VBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VBox
func (recv *VBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VBox
func (recv *VBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VButtonBox is a wrapper around the C record GtkVButtonBox.
type VButtonBox struct {
	native *C.GtkVButtonBox
	// button_box : record
}

func VButtonBoxNewFromC(u unsafe.Pointer) *VButtonBox {
	c := (*C.GtkVButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &VButtonBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VButtonBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VButtonBox with another VButtonBox, and returns true if they represent the same GObject.
func (recv *VButtonBox) Equals(other *VButtonBox) bool {
	return other.ToC() == recv.ToC()
}

// ButtonBox upcasts to *ButtonBox
func (recv *VButtonBox) ButtonBox() *ButtonBox {
	return ButtonBoxNewFromC(unsafe.Pointer(recv.native))
}

// Box upcasts to *Box
func (recv *VButtonBox) Box() *Box {
	return recv.ButtonBox().Box()
}

// Container upcasts to *Container
func (recv *VButtonBox) Container() *Container {
	return recv.ButtonBox().Container()
}

// Widget upcasts to *Widget
func (recv *VButtonBox) Widget() *Widget {
	return recv.ButtonBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ButtonBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VButtonBox) Object() *gobject.Object {
	return recv.ButtonBox().Object()
}

// CastToWidget down casts any arbitrary Object to VButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a VButtonBox.
func CastToVButtonBox(object *gobject.Object) *VButtonBox {
	return VButtonBoxNewFromC(object.ToC())
}

// Blacklisted : gtk_vbutton_box_new

// ImplementorIface returns the ImplementorIface interface implemented by VButtonBox
func (recv *VButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VButtonBox
func (recv *VButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VButtonBox
func (recv *VButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VPaned is a wrapper around the C record GtkVPaned.
type VPaned struct {
	native *C.GtkVPaned
	// paned : record
}

func VPanedNewFromC(u unsafe.Pointer) *VPaned {
	c := (*C.GtkVPaned)(u)
	if c == nil {
		return nil
	}

	g := &VPaned{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VPaned) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VPaned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VPaned with another VPaned, and returns true if they represent the same GObject.
func (recv *VPaned) Equals(other *VPaned) bool {
	return other.ToC() == recv.ToC()
}

// Paned upcasts to *Paned
func (recv *VPaned) Paned() *Paned {
	return PanedNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *VPaned) Container() *Container {
	return recv.Paned().Container()
}

// Widget upcasts to *Widget
func (recv *VPaned) Widget() *Widget {
	return recv.Paned().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VPaned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Paned().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VPaned) Object() *gobject.Object {
	return recv.Paned().Object()
}

// CastToWidget down casts any arbitrary Object to VPaned.
// Exercise care, as this is a potentially dangerous function if the Object is not a VPaned.
func CastToVPaned(object *gobject.Object) *VPaned {
	return VPanedNewFromC(object.ToC())
}

// Blacklisted : gtk_vpaned_new

// ImplementorIface returns the ImplementorIface interface implemented by VPaned
func (recv *VPaned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VPaned
func (recv *VPaned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VPaned
func (recv *VPaned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VScale is a wrapper around the C record GtkVScale.
type VScale struct {
	native *C.GtkVScale
	// scale : record
}

func VScaleNewFromC(u unsafe.Pointer) *VScale {
	c := (*C.GtkVScale)(u)
	if c == nil {
		return nil
	}

	g := &VScale{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VScale) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VScale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VScale with another VScale, and returns true if they represent the same GObject.
func (recv *VScale) Equals(other *VScale) bool {
	return other.ToC() == recv.ToC()
}

// Scale upcasts to *Scale
func (recv *VScale) Scale() *Scale {
	return ScaleNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *VScale) Range() *Range {
	return recv.Scale().Range()
}

// Widget upcasts to *Widget
func (recv *VScale) Widget() *Widget {
	return recv.Scale().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VScale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scale().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VScale) Object() *gobject.Object {
	return recv.Scale().Object()
}

// CastToWidget down casts any arbitrary Object to VScale.
// Exercise care, as this is a potentially dangerous function if the Object is not a VScale.
func CastToVScale(object *gobject.Object) *VScale {
	return VScaleNewFromC(object.ToC())
}

// Blacklisted : gtk_vscale_new

// Blacklisted : gtk_vscale_new_with_range

// ImplementorIface returns the ImplementorIface interface implemented by VScale
func (recv *VScale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VScale
func (recv *VScale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VScale
func (recv *VScale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VScrollbar is a wrapper around the C record GtkVScrollbar.
type VScrollbar struct {
	native *C.GtkVScrollbar
	// scrollbar : record
}

func VScrollbarNewFromC(u unsafe.Pointer) *VScrollbar {
	c := (*C.GtkVScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &VScrollbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VScrollbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VScrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VScrollbar with another VScrollbar, and returns true if they represent the same GObject.
func (recv *VScrollbar) Equals(other *VScrollbar) bool {
	return other.ToC() == recv.ToC()
}

// Scrollbar upcasts to *Scrollbar
func (recv *VScrollbar) Scrollbar() *Scrollbar {
	return ScrollbarNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *VScrollbar) Range() *Range {
	return recv.Scrollbar().Range()
}

// Widget upcasts to *Widget
func (recv *VScrollbar) Widget() *Widget {
	return recv.Scrollbar().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VScrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scrollbar().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VScrollbar) Object() *gobject.Object {
	return recv.Scrollbar().Object()
}

// CastToWidget down casts any arbitrary Object to VScrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a VScrollbar.
func CastToVScrollbar(object *gobject.Object) *VScrollbar {
	return VScrollbarNewFromC(object.ToC())
}

// Blacklisted : gtk_vscrollbar_new

// ImplementorIface returns the ImplementorIface interface implemented by VScrollbar
func (recv *VScrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VScrollbar
func (recv *VScrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VScrollbar
func (recv *VScrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VSeparator is a wrapper around the C record GtkVSeparator.
type VSeparator struct {
	native *C.GtkVSeparator
	// separator : record
}

func VSeparatorNewFromC(u unsafe.Pointer) *VSeparator {
	c := (*C.GtkVSeparator)(u)
	if c == nil {
		return nil
	}

	g := &VSeparator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VSeparator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VSeparator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VSeparator with another VSeparator, and returns true if they represent the same GObject.
func (recv *VSeparator) Equals(other *VSeparator) bool {
	return other.ToC() == recv.ToC()
}

// Separator upcasts to *Separator
func (recv *VSeparator) Separator() *Separator {
	return SeparatorNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *VSeparator) Widget() *Widget {
	return recv.Separator().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VSeparator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Separator().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VSeparator) Object() *gobject.Object {
	return recv.Separator().Object()
}

// CastToWidget down casts any arbitrary Object to VSeparator.
// Exercise care, as this is a potentially dangerous function if the Object is not a VSeparator.
func CastToVSeparator(object *gobject.Object) *VSeparator {
	return VSeparatorNewFromC(object.ToC())
}

// Blacklisted : gtk_vseparator_new

// ImplementorIface returns the ImplementorIface interface implemented by VSeparator
func (recv *VSeparator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VSeparator
func (recv *VSeparator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VSeparator
func (recv *VSeparator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Viewport is a wrapper around the C record GtkViewport.
type Viewport struct {
	native *C.GtkViewport
	// bin : record
	// Private : priv
}

func ViewportNewFromC(u unsafe.Pointer) *Viewport {
	c := (*C.GtkViewport)(u)
	if c == nil {
		return nil
	}

	g := &Viewport{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Viewport) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Viewport) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Viewport with another Viewport, and returns true if they represent the same GObject.
func (recv *Viewport) Equals(other *Viewport) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Viewport) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Viewport) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Viewport) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Viewport) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Viewport) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Viewport.
// Exercise care, as this is a potentially dangerous function if the Object is not a Viewport.
func CastToViewport(object *gobject.Object) *Viewport {
	return ViewportNewFromC(object.ToC())
}

// Blacklisted : gtk_viewport_new

// Blacklisted : gtk_viewport_get_hadjustment

// Blacklisted : gtk_viewport_get_shadow_type

// Blacklisted : gtk_viewport_get_vadjustment

// Blacklisted : gtk_viewport_set_hadjustment

// Blacklisted : gtk_viewport_set_shadow_type

// Blacklisted : gtk_viewport_set_vadjustment

// ImplementorIface returns the ImplementorIface interface implemented by Viewport
func (recv *Viewport) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Viewport
func (recv *Viewport) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by Viewport
func (recv *Viewport) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// VolumeButton is a wrapper around the C record GtkVolumeButton.
type VolumeButton struct {
	native *C.GtkVolumeButton
	// parent : record
}

func VolumeButtonNewFromC(u unsafe.Pointer) *VolumeButton {
	c := (*C.GtkVolumeButton)(u)
	if c == nil {
		return nil
	}

	g := &VolumeButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VolumeButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VolumeButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VolumeButton with another VolumeButton, and returns true if they represent the same GObject.
func (recv *VolumeButton) Equals(other *VolumeButton) bool {
	return other.ToC() == recv.ToC()
}

// ScaleButton upcasts to *ScaleButton
func (recv *VolumeButton) ScaleButton() *ScaleButton {
	return ScaleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *VolumeButton) Button() *Button {
	return recv.ScaleButton().Button()
}

// Bin upcasts to *Bin
func (recv *VolumeButton) Bin() *Bin {
	return recv.ScaleButton().Bin()
}

// Container upcasts to *Container
func (recv *VolumeButton) Container() *Container {
	return recv.ScaleButton().Container()
}

// Widget upcasts to *Widget
func (recv *VolumeButton) Widget() *Widget {
	return recv.ScaleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VolumeButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ScaleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VolumeButton) Object() *gobject.Object {
	return recv.ScaleButton().Object()
}

// CastToWidget down casts any arbitrary Object to VolumeButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a VolumeButton.
func CastToVolumeButton(object *gobject.Object) *VolumeButton {
	return VolumeButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by VolumeButton
func (recv *VolumeButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by VolumeButton
func (recv *VolumeButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by VolumeButton
func (recv *VolumeButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VolumeButton
func (recv *VolumeButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VolumeButton
func (recv *VolumeButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Widget is a wrapper around the C record GtkWidget.
type Widget struct {
	native *C.GtkWidget
	// parent_instance : record
	// Private : priv
}

func WidgetNewFromC(u unsafe.Pointer) *Widget {
	c := (*C.GtkWidget)(u)
	if c == nil {
		return nil
	}

	g := &Widget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Widget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Widget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Widget with another Widget, and returns true if they represent the same GObject.
func (recv *Widget) Equals(other *Widget) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Widget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Widget) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to Widget.
// Exercise care, as this is a potentially dangerous function if the Object is not a Widget.
func CastToWidget(object *gobject.Object) *Widget {
	return WidgetNewFromC(object.ToC())
}

type signalWidgetAccelClosuresChangedDetail struct {
	callback  WidgetSignalAccelClosuresChangedCallback
	handlerID C.gulong
}

var signalWidgetAccelClosuresChangedId int
var signalWidgetAccelClosuresChangedMap = make(map[int]signalWidgetAccelClosuresChangedDetail)
var signalWidgetAccelClosuresChangedLock sync.RWMutex

// WidgetSignalAccelClosuresChangedCallback is a callback function for a 'accel-closures-changed' signal emitted from a Widget.
type WidgetSignalAccelClosuresChangedCallback func()

/*
ConnectAccelClosuresChanged connects the callback to the 'accel-closures-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectAccelClosuresChanged to remove it.
*/
func (recv *Widget) ConnectAccelClosuresChanged(callback WidgetSignalAccelClosuresChangedCallback) int {
	signalWidgetAccelClosuresChangedLock.Lock()
	defer signalWidgetAccelClosuresChangedLock.Unlock()

	signalWidgetAccelClosuresChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_accel_closures_changed(instance, C.gpointer(uintptr(signalWidgetAccelClosuresChangedId)))

	detail := signalWidgetAccelClosuresChangedDetail{callback, handlerID}
	signalWidgetAccelClosuresChangedMap[signalWidgetAccelClosuresChangedId] = detail

	return signalWidgetAccelClosuresChangedId
}

/*
DisconnectAccelClosuresChanged disconnects a callback from the 'accel-closures-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectAccelClosuresChanged.
*/
func (recv *Widget) DisconnectAccelClosuresChanged(connectionID int) {
	signalWidgetAccelClosuresChangedLock.Lock()
	defer signalWidgetAccelClosuresChangedLock.Unlock()

	detail, exists := signalWidgetAccelClosuresChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetAccelClosuresChangedMap, connectionID)
}

//export widget_accelClosuresChangedHandler
func widget_accelClosuresChangedHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetAccelClosuresChangedLock.RLock()
	defer signalWidgetAccelClosuresChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetAccelClosuresChangedMap[index].callback
	callback()
}

type signalWidgetButtonPressEventDetail struct {
	callback  WidgetSignalButtonPressEventCallback
	handlerID C.gulong
}

var signalWidgetButtonPressEventId int
var signalWidgetButtonPressEventMap = make(map[int]signalWidgetButtonPressEventDetail)
var signalWidgetButtonPressEventLock sync.RWMutex

// WidgetSignalButtonPressEventCallback is a callback function for a 'button-press-event' signal emitted from a Widget.
type WidgetSignalButtonPressEventCallback func(event *gdk.EventButton) bool

/*
ConnectButtonPressEvent connects the callback to the 'button-press-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectButtonPressEvent to remove it.
*/
func (recv *Widget) ConnectButtonPressEvent(callback WidgetSignalButtonPressEventCallback) int {
	signalWidgetButtonPressEventLock.Lock()
	defer signalWidgetButtonPressEventLock.Unlock()

	signalWidgetButtonPressEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_button_press_event(instance, C.gpointer(uintptr(signalWidgetButtonPressEventId)))

	detail := signalWidgetButtonPressEventDetail{callback, handlerID}
	signalWidgetButtonPressEventMap[signalWidgetButtonPressEventId] = detail

	return signalWidgetButtonPressEventId
}

/*
DisconnectButtonPressEvent disconnects a callback from the 'button-press-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectButtonPressEvent.
*/
func (recv *Widget) DisconnectButtonPressEvent(connectionID int) {
	signalWidgetButtonPressEventLock.Lock()
	defer signalWidgetButtonPressEventLock.Unlock()

	detail, exists := signalWidgetButtonPressEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetButtonPressEventMap, connectionID)
}

//export widget_buttonPressEventHandler
func widget_buttonPressEventHandler(_ *C.GObject, c_event *C.GdkEventButton, data C.gpointer) C.gboolean {
	signalWidgetButtonPressEventLock.RLock()
	defer signalWidgetButtonPressEventLock.RUnlock()

	event := gdk.EventButtonNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetButtonPressEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetButtonReleaseEventDetail struct {
	callback  WidgetSignalButtonReleaseEventCallback
	handlerID C.gulong
}

var signalWidgetButtonReleaseEventId int
var signalWidgetButtonReleaseEventMap = make(map[int]signalWidgetButtonReleaseEventDetail)
var signalWidgetButtonReleaseEventLock sync.RWMutex

// WidgetSignalButtonReleaseEventCallback is a callback function for a 'button-release-event' signal emitted from a Widget.
type WidgetSignalButtonReleaseEventCallback func(event *gdk.EventButton) bool

/*
ConnectButtonReleaseEvent connects the callback to the 'button-release-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectButtonReleaseEvent to remove it.
*/
func (recv *Widget) ConnectButtonReleaseEvent(callback WidgetSignalButtonReleaseEventCallback) int {
	signalWidgetButtonReleaseEventLock.Lock()
	defer signalWidgetButtonReleaseEventLock.Unlock()

	signalWidgetButtonReleaseEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_button_release_event(instance, C.gpointer(uintptr(signalWidgetButtonReleaseEventId)))

	detail := signalWidgetButtonReleaseEventDetail{callback, handlerID}
	signalWidgetButtonReleaseEventMap[signalWidgetButtonReleaseEventId] = detail

	return signalWidgetButtonReleaseEventId
}

/*
DisconnectButtonReleaseEvent disconnects a callback from the 'button-release-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectButtonReleaseEvent.
*/
func (recv *Widget) DisconnectButtonReleaseEvent(connectionID int) {
	signalWidgetButtonReleaseEventLock.Lock()
	defer signalWidgetButtonReleaseEventLock.Unlock()

	detail, exists := signalWidgetButtonReleaseEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetButtonReleaseEventMap, connectionID)
}

//export widget_buttonReleaseEventHandler
func widget_buttonReleaseEventHandler(_ *C.GObject, c_event *C.GdkEventButton, data C.gpointer) C.gboolean {
	signalWidgetButtonReleaseEventLock.RLock()
	defer signalWidgetButtonReleaseEventLock.RUnlock()

	event := gdk.EventButtonNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetButtonReleaseEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetCanActivateAccelDetail struct {
	callback  WidgetSignalCanActivateAccelCallback
	handlerID C.gulong
}

var signalWidgetCanActivateAccelId int
var signalWidgetCanActivateAccelMap = make(map[int]signalWidgetCanActivateAccelDetail)
var signalWidgetCanActivateAccelLock sync.RWMutex

// WidgetSignalCanActivateAccelCallback is a callback function for a 'can-activate-accel' signal emitted from a Widget.
type WidgetSignalCanActivateAccelCallback func(signalId uint32) bool

/*
ConnectCanActivateAccel connects the callback to the 'can-activate-accel' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectCanActivateAccel to remove it.
*/
func (recv *Widget) ConnectCanActivateAccel(callback WidgetSignalCanActivateAccelCallback) int {
	signalWidgetCanActivateAccelLock.Lock()
	defer signalWidgetCanActivateAccelLock.Unlock()

	signalWidgetCanActivateAccelId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_can_activate_accel(instance, C.gpointer(uintptr(signalWidgetCanActivateAccelId)))

	detail := signalWidgetCanActivateAccelDetail{callback, handlerID}
	signalWidgetCanActivateAccelMap[signalWidgetCanActivateAccelId] = detail

	return signalWidgetCanActivateAccelId
}

/*
DisconnectCanActivateAccel disconnects a callback from the 'can-activate-accel' signal for the Widget.

The connectionID should be a value returned from a call to ConnectCanActivateAccel.
*/
func (recv *Widget) DisconnectCanActivateAccel(connectionID int) {
	signalWidgetCanActivateAccelLock.Lock()
	defer signalWidgetCanActivateAccelLock.Unlock()

	detail, exists := signalWidgetCanActivateAccelMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetCanActivateAccelMap, connectionID)
}

//export widget_canActivateAccelHandler
func widget_canActivateAccelHandler(_ *C.GObject, c_signal_id C.guint, data C.gpointer) C.gboolean {
	signalWidgetCanActivateAccelLock.RLock()
	defer signalWidgetCanActivateAccelLock.RUnlock()

	signalId := uint32(c_signal_id)

	index := int(uintptr(data))
	callback := signalWidgetCanActivateAccelMap[index].callback
	retGo := callback(signalId)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetChildNotifyDetail struct {
	callback  WidgetSignalChildNotifyCallback
	handlerID C.gulong
}

var signalWidgetChildNotifyId int
var signalWidgetChildNotifyMap = make(map[int]signalWidgetChildNotifyDetail)
var signalWidgetChildNotifyLock sync.RWMutex

// WidgetSignalChildNotifyCallback is a callback function for a 'child-notify' signal emitted from a Widget.
type WidgetSignalChildNotifyCallback func(childProperty *gobject.ParamSpec)

/*
ConnectChildNotify connects the callback to the 'child-notify' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectChildNotify to remove it.
*/
func (recv *Widget) ConnectChildNotify(callback WidgetSignalChildNotifyCallback) int {
	signalWidgetChildNotifyLock.Lock()
	defer signalWidgetChildNotifyLock.Unlock()

	signalWidgetChildNotifyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_child_notify(instance, C.gpointer(uintptr(signalWidgetChildNotifyId)))

	detail := signalWidgetChildNotifyDetail{callback, handlerID}
	signalWidgetChildNotifyMap[signalWidgetChildNotifyId] = detail

	return signalWidgetChildNotifyId
}

/*
DisconnectChildNotify disconnects a callback from the 'child-notify' signal for the Widget.

The connectionID should be a value returned from a call to ConnectChildNotify.
*/
func (recv *Widget) DisconnectChildNotify(connectionID int) {
	signalWidgetChildNotifyLock.Lock()
	defer signalWidgetChildNotifyLock.Unlock()

	detail, exists := signalWidgetChildNotifyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetChildNotifyMap, connectionID)
}

//export widget_childNotifyHandler
func widget_childNotifyHandler(_ *C.GObject, c_child_property *C.GParamSpec, data C.gpointer) {
	signalWidgetChildNotifyLock.RLock()
	defer signalWidgetChildNotifyLock.RUnlock()

	childProperty := gobject.ParamSpecNewFromC(unsafe.Pointer(c_child_property))

	index := int(uintptr(data))
	callback := signalWidgetChildNotifyMap[index].callback
	callback(childProperty)
}

type signalWidgetCompositedChangedDetail struct {
	callback  WidgetSignalCompositedChangedCallback
	handlerID C.gulong
}

var signalWidgetCompositedChangedId int
var signalWidgetCompositedChangedMap = make(map[int]signalWidgetCompositedChangedDetail)
var signalWidgetCompositedChangedLock sync.RWMutex

// WidgetSignalCompositedChangedCallback is a callback function for a 'composited-changed' signal emitted from a Widget.
type WidgetSignalCompositedChangedCallback func()

/*
ConnectCompositedChanged connects the callback to the 'composited-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectCompositedChanged to remove it.
*/
func (recv *Widget) ConnectCompositedChanged(callback WidgetSignalCompositedChangedCallback) int {
	signalWidgetCompositedChangedLock.Lock()
	defer signalWidgetCompositedChangedLock.Unlock()

	signalWidgetCompositedChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_composited_changed(instance, C.gpointer(uintptr(signalWidgetCompositedChangedId)))

	detail := signalWidgetCompositedChangedDetail{callback, handlerID}
	signalWidgetCompositedChangedMap[signalWidgetCompositedChangedId] = detail

	return signalWidgetCompositedChangedId
}

/*
DisconnectCompositedChanged disconnects a callback from the 'composited-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectCompositedChanged.
*/
func (recv *Widget) DisconnectCompositedChanged(connectionID int) {
	signalWidgetCompositedChangedLock.Lock()
	defer signalWidgetCompositedChangedLock.Unlock()

	detail, exists := signalWidgetCompositedChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetCompositedChangedMap, connectionID)
}

//export widget_compositedChangedHandler
func widget_compositedChangedHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetCompositedChangedLock.RLock()
	defer signalWidgetCompositedChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetCompositedChangedMap[index].callback
	callback()
}

type signalWidgetConfigureEventDetail struct {
	callback  WidgetSignalConfigureEventCallback
	handlerID C.gulong
}

var signalWidgetConfigureEventId int
var signalWidgetConfigureEventMap = make(map[int]signalWidgetConfigureEventDetail)
var signalWidgetConfigureEventLock sync.RWMutex

// WidgetSignalConfigureEventCallback is a callback function for a 'configure-event' signal emitted from a Widget.
type WidgetSignalConfigureEventCallback func(event *gdk.EventConfigure) bool

/*
ConnectConfigureEvent connects the callback to the 'configure-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectConfigureEvent to remove it.
*/
func (recv *Widget) ConnectConfigureEvent(callback WidgetSignalConfigureEventCallback) int {
	signalWidgetConfigureEventLock.Lock()
	defer signalWidgetConfigureEventLock.Unlock()

	signalWidgetConfigureEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_configure_event(instance, C.gpointer(uintptr(signalWidgetConfigureEventId)))

	detail := signalWidgetConfigureEventDetail{callback, handlerID}
	signalWidgetConfigureEventMap[signalWidgetConfigureEventId] = detail

	return signalWidgetConfigureEventId
}

/*
DisconnectConfigureEvent disconnects a callback from the 'configure-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectConfigureEvent.
*/
func (recv *Widget) DisconnectConfigureEvent(connectionID int) {
	signalWidgetConfigureEventLock.Lock()
	defer signalWidgetConfigureEventLock.Unlock()

	detail, exists := signalWidgetConfigureEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetConfigureEventMap, connectionID)
}

//export widget_configureEventHandler
func widget_configureEventHandler(_ *C.GObject, c_event *C.GdkEventConfigure, data C.gpointer) C.gboolean {
	signalWidgetConfigureEventLock.RLock()
	defer signalWidgetConfigureEventLock.RUnlock()

	event := gdk.EventConfigureNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetConfigureEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'delete-event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

type signalWidgetDestroyDetail struct {
	callback  WidgetSignalDestroyCallback
	handlerID C.gulong
}

var signalWidgetDestroyId int
var signalWidgetDestroyMap = make(map[int]signalWidgetDestroyDetail)
var signalWidgetDestroyLock sync.RWMutex

// WidgetSignalDestroyCallback is a callback function for a 'destroy' signal emitted from a Widget.
type WidgetSignalDestroyCallback func()

/*
ConnectDestroy connects the callback to the 'destroy' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDestroy to remove it.
*/
func (recv *Widget) ConnectDestroy(callback WidgetSignalDestroyCallback) int {
	signalWidgetDestroyLock.Lock()
	defer signalWidgetDestroyLock.Unlock()

	signalWidgetDestroyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_destroy(instance, C.gpointer(uintptr(signalWidgetDestroyId)))

	detail := signalWidgetDestroyDetail{callback, handlerID}
	signalWidgetDestroyMap[signalWidgetDestroyId] = detail

	return signalWidgetDestroyId
}

/*
DisconnectDestroy disconnects a callback from the 'destroy' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDestroy.
*/
func (recv *Widget) DisconnectDestroy(connectionID int) {
	signalWidgetDestroyLock.Lock()
	defer signalWidgetDestroyLock.Unlock()

	detail, exists := signalWidgetDestroyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDestroyMap, connectionID)
}

//export widget_destroyHandler
func widget_destroyHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetDestroyLock.RLock()
	defer signalWidgetDestroyLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetDestroyMap[index].callback
	callback()
}

// Unsupported signal 'destroy-event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

type signalWidgetDirectionChangedDetail struct {
	callback  WidgetSignalDirectionChangedCallback
	handlerID C.gulong
}

var signalWidgetDirectionChangedId int
var signalWidgetDirectionChangedMap = make(map[int]signalWidgetDirectionChangedDetail)
var signalWidgetDirectionChangedLock sync.RWMutex

// WidgetSignalDirectionChangedCallback is a callback function for a 'direction-changed' signal emitted from a Widget.
type WidgetSignalDirectionChangedCallback func(previousDirection TextDirection)

/*
ConnectDirectionChanged connects the callback to the 'direction-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDirectionChanged to remove it.
*/
func (recv *Widget) ConnectDirectionChanged(callback WidgetSignalDirectionChangedCallback) int {
	signalWidgetDirectionChangedLock.Lock()
	defer signalWidgetDirectionChangedLock.Unlock()

	signalWidgetDirectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_direction_changed(instance, C.gpointer(uintptr(signalWidgetDirectionChangedId)))

	detail := signalWidgetDirectionChangedDetail{callback, handlerID}
	signalWidgetDirectionChangedMap[signalWidgetDirectionChangedId] = detail

	return signalWidgetDirectionChangedId
}

/*
DisconnectDirectionChanged disconnects a callback from the 'direction-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDirectionChanged.
*/
func (recv *Widget) DisconnectDirectionChanged(connectionID int) {
	signalWidgetDirectionChangedLock.Lock()
	defer signalWidgetDirectionChangedLock.Unlock()

	detail, exists := signalWidgetDirectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDirectionChangedMap, connectionID)
}

//export widget_directionChangedHandler
func widget_directionChangedHandler(_ *C.GObject, c_previous_direction C.GtkTextDirection, data C.gpointer) {
	signalWidgetDirectionChangedLock.RLock()
	defer signalWidgetDirectionChangedLock.RUnlock()

	previousDirection := TextDirection(c_previous_direction)

	index := int(uintptr(data))
	callback := signalWidgetDirectionChangedMap[index].callback
	callback(previousDirection)
}

type signalWidgetDragBeginDetail struct {
	callback  WidgetSignalDragBeginCallback
	handlerID C.gulong
}

var signalWidgetDragBeginId int
var signalWidgetDragBeginMap = make(map[int]signalWidgetDragBeginDetail)
var signalWidgetDragBeginLock sync.RWMutex

// WidgetSignalDragBeginCallback is a callback function for a 'drag-begin' signal emitted from a Widget.
type WidgetSignalDragBeginCallback func(context *gdk.DragContext)

/*
ConnectDragBegin connects the callback to the 'drag-begin' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragBegin to remove it.
*/
func (recv *Widget) ConnectDragBegin(callback WidgetSignalDragBeginCallback) int {
	signalWidgetDragBeginLock.Lock()
	defer signalWidgetDragBeginLock.Unlock()

	signalWidgetDragBeginId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_begin(instance, C.gpointer(uintptr(signalWidgetDragBeginId)))

	detail := signalWidgetDragBeginDetail{callback, handlerID}
	signalWidgetDragBeginMap[signalWidgetDragBeginId] = detail

	return signalWidgetDragBeginId
}

/*
DisconnectDragBegin disconnects a callback from the 'drag-begin' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragBegin.
*/
func (recv *Widget) DisconnectDragBegin(connectionID int) {
	signalWidgetDragBeginLock.Lock()
	defer signalWidgetDragBeginLock.Unlock()

	detail, exists := signalWidgetDragBeginMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragBeginMap, connectionID)
}

//export widget_dragBeginHandler
func widget_dragBeginHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	signalWidgetDragBeginLock.RLock()
	defer signalWidgetDragBeginLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragBeginMap[index].callback
	callback(context)
}

type signalWidgetDragDataDeleteDetail struct {
	callback  WidgetSignalDragDataDeleteCallback
	handlerID C.gulong
}

var signalWidgetDragDataDeleteId int
var signalWidgetDragDataDeleteMap = make(map[int]signalWidgetDragDataDeleteDetail)
var signalWidgetDragDataDeleteLock sync.RWMutex

// WidgetSignalDragDataDeleteCallback is a callback function for a 'drag-data-delete' signal emitted from a Widget.
type WidgetSignalDragDataDeleteCallback func(context *gdk.DragContext)

/*
ConnectDragDataDelete connects the callback to the 'drag-data-delete' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDataDelete to remove it.
*/
func (recv *Widget) ConnectDragDataDelete(callback WidgetSignalDragDataDeleteCallback) int {
	signalWidgetDragDataDeleteLock.Lock()
	defer signalWidgetDragDataDeleteLock.Unlock()

	signalWidgetDragDataDeleteId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_data_delete(instance, C.gpointer(uintptr(signalWidgetDragDataDeleteId)))

	detail := signalWidgetDragDataDeleteDetail{callback, handlerID}
	signalWidgetDragDataDeleteMap[signalWidgetDragDataDeleteId] = detail

	return signalWidgetDragDataDeleteId
}

/*
DisconnectDragDataDelete disconnects a callback from the 'drag-data-delete' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDataDelete.
*/
func (recv *Widget) DisconnectDragDataDelete(connectionID int) {
	signalWidgetDragDataDeleteLock.Lock()
	defer signalWidgetDragDataDeleteLock.Unlock()

	detail, exists := signalWidgetDragDataDeleteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDataDeleteMap, connectionID)
}

//export widget_dragDataDeleteHandler
func widget_dragDataDeleteHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	signalWidgetDragDataDeleteLock.RLock()
	defer signalWidgetDragDataDeleteLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragDataDeleteMap[index].callback
	callback(context)
}

type signalWidgetDragDataGetDetail struct {
	callback  WidgetSignalDragDataGetCallback
	handlerID C.gulong
}

var signalWidgetDragDataGetId int
var signalWidgetDragDataGetMap = make(map[int]signalWidgetDragDataGetDetail)
var signalWidgetDragDataGetLock sync.RWMutex

// WidgetSignalDragDataGetCallback is a callback function for a 'drag-data-get' signal emitted from a Widget.
type WidgetSignalDragDataGetCallback func(context *gdk.DragContext, Data *SelectionData, info uint32, time uint32)

/*
ConnectDragDataGet connects the callback to the 'drag-data-get' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDataGet to remove it.
*/
func (recv *Widget) ConnectDragDataGet(callback WidgetSignalDragDataGetCallback) int {
	signalWidgetDragDataGetLock.Lock()
	defer signalWidgetDragDataGetLock.Unlock()

	signalWidgetDragDataGetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_data_get(instance, C.gpointer(uintptr(signalWidgetDragDataGetId)))

	detail := signalWidgetDragDataGetDetail{callback, handlerID}
	signalWidgetDragDataGetMap[signalWidgetDragDataGetId] = detail

	return signalWidgetDragDataGetId
}

/*
DisconnectDragDataGet disconnects a callback from the 'drag-data-get' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDataGet.
*/
func (recv *Widget) DisconnectDragDataGet(connectionID int) {
	signalWidgetDragDataGetLock.Lock()
	defer signalWidgetDragDataGetLock.Unlock()

	detail, exists := signalWidgetDragDataGetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDataGetMap, connectionID)
}

//export widget_dragDataGetHandler
func widget_dragDataGetHandler(_ *C.GObject, c_context *C.GdkDragContext, c__data *C.GtkSelectionData, c_info C.guint, c_time C.guint, data C.gpointer) {
	signalWidgetDragDataGetLock.RLock()
	defer signalWidgetDragDataGetLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	Data := SelectionDataNewFromC(unsafe.Pointer(c__data))

	info := uint32(c_info)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragDataGetMap[index].callback
	callback(context, Data, info, time)
}

type signalWidgetDragDataReceivedDetail struct {
	callback  WidgetSignalDragDataReceivedCallback
	handlerID C.gulong
}

var signalWidgetDragDataReceivedId int
var signalWidgetDragDataReceivedMap = make(map[int]signalWidgetDragDataReceivedDetail)
var signalWidgetDragDataReceivedLock sync.RWMutex

// WidgetSignalDragDataReceivedCallback is a callback function for a 'drag-data-received' signal emitted from a Widget.
type WidgetSignalDragDataReceivedCallback func(context *gdk.DragContext, x int32, y int32, Data *SelectionData, info uint32, time uint32)

/*
ConnectDragDataReceived connects the callback to the 'drag-data-received' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDataReceived to remove it.
*/
func (recv *Widget) ConnectDragDataReceived(callback WidgetSignalDragDataReceivedCallback) int {
	signalWidgetDragDataReceivedLock.Lock()
	defer signalWidgetDragDataReceivedLock.Unlock()

	signalWidgetDragDataReceivedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_data_received(instance, C.gpointer(uintptr(signalWidgetDragDataReceivedId)))

	detail := signalWidgetDragDataReceivedDetail{callback, handlerID}
	signalWidgetDragDataReceivedMap[signalWidgetDragDataReceivedId] = detail

	return signalWidgetDragDataReceivedId
}

/*
DisconnectDragDataReceived disconnects a callback from the 'drag-data-received' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDataReceived.
*/
func (recv *Widget) DisconnectDragDataReceived(connectionID int) {
	signalWidgetDragDataReceivedLock.Lock()
	defer signalWidgetDragDataReceivedLock.Unlock()

	detail, exists := signalWidgetDragDataReceivedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDataReceivedMap, connectionID)
}

//export widget_dragDataReceivedHandler
func widget_dragDataReceivedHandler(_ *C.GObject, c_context *C.GdkDragContext, c_x C.gint, c_y C.gint, c__data *C.GtkSelectionData, c_info C.guint, c_time C.guint, data C.gpointer) {
	signalWidgetDragDataReceivedLock.RLock()
	defer signalWidgetDragDataReceivedLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	x := int32(c_x)

	y := int32(c_y)

	Data := SelectionDataNewFromC(unsafe.Pointer(c__data))

	info := uint32(c_info)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragDataReceivedMap[index].callback
	callback(context, x, y, Data, info, time)
}

type signalWidgetDragDropDetail struct {
	callback  WidgetSignalDragDropCallback
	handlerID C.gulong
}

var signalWidgetDragDropId int
var signalWidgetDragDropMap = make(map[int]signalWidgetDragDropDetail)
var signalWidgetDragDropLock sync.RWMutex

// WidgetSignalDragDropCallback is a callback function for a 'drag-drop' signal emitted from a Widget.
type WidgetSignalDragDropCallback func(context *gdk.DragContext, x int32, y int32, time uint32) bool

/*
ConnectDragDrop connects the callback to the 'drag-drop' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDrop to remove it.
*/
func (recv *Widget) ConnectDragDrop(callback WidgetSignalDragDropCallback) int {
	signalWidgetDragDropLock.Lock()
	defer signalWidgetDragDropLock.Unlock()

	signalWidgetDragDropId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_drop(instance, C.gpointer(uintptr(signalWidgetDragDropId)))

	detail := signalWidgetDragDropDetail{callback, handlerID}
	signalWidgetDragDropMap[signalWidgetDragDropId] = detail

	return signalWidgetDragDropId
}

/*
DisconnectDragDrop disconnects a callback from the 'drag-drop' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDrop.
*/
func (recv *Widget) DisconnectDragDrop(connectionID int) {
	signalWidgetDragDropLock.Lock()
	defer signalWidgetDragDropLock.Unlock()

	detail, exists := signalWidgetDragDropMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDropMap, connectionID)
}

//export widget_dragDropHandler
func widget_dragDropHandler(_ *C.GObject, c_context *C.GdkDragContext, c_x C.gint, c_y C.gint, c_time C.guint, data C.gpointer) C.gboolean {
	signalWidgetDragDropLock.RLock()
	defer signalWidgetDragDropLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	x := int32(c_x)

	y := int32(c_y)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragDropMap[index].callback
	retGo := callback(context, x, y, time)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetDragEndDetail struct {
	callback  WidgetSignalDragEndCallback
	handlerID C.gulong
}

var signalWidgetDragEndId int
var signalWidgetDragEndMap = make(map[int]signalWidgetDragEndDetail)
var signalWidgetDragEndLock sync.RWMutex

// WidgetSignalDragEndCallback is a callback function for a 'drag-end' signal emitted from a Widget.
type WidgetSignalDragEndCallback func(context *gdk.DragContext)

/*
ConnectDragEnd connects the callback to the 'drag-end' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragEnd to remove it.
*/
func (recv *Widget) ConnectDragEnd(callback WidgetSignalDragEndCallback) int {
	signalWidgetDragEndLock.Lock()
	defer signalWidgetDragEndLock.Unlock()

	signalWidgetDragEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_end(instance, C.gpointer(uintptr(signalWidgetDragEndId)))

	detail := signalWidgetDragEndDetail{callback, handlerID}
	signalWidgetDragEndMap[signalWidgetDragEndId] = detail

	return signalWidgetDragEndId
}

/*
DisconnectDragEnd disconnects a callback from the 'drag-end' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragEnd.
*/
func (recv *Widget) DisconnectDragEnd(connectionID int) {
	signalWidgetDragEndLock.Lock()
	defer signalWidgetDragEndLock.Unlock()

	detail, exists := signalWidgetDragEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragEndMap, connectionID)
}

//export widget_dragEndHandler
func widget_dragEndHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	signalWidgetDragEndLock.RLock()
	defer signalWidgetDragEndLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragEndMap[index].callback
	callback(context)
}

type signalWidgetDragLeaveDetail struct {
	callback  WidgetSignalDragLeaveCallback
	handlerID C.gulong
}

var signalWidgetDragLeaveId int
var signalWidgetDragLeaveMap = make(map[int]signalWidgetDragLeaveDetail)
var signalWidgetDragLeaveLock sync.RWMutex

// WidgetSignalDragLeaveCallback is a callback function for a 'drag-leave' signal emitted from a Widget.
type WidgetSignalDragLeaveCallback func(context *gdk.DragContext, time uint32)

/*
ConnectDragLeave connects the callback to the 'drag-leave' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragLeave to remove it.
*/
func (recv *Widget) ConnectDragLeave(callback WidgetSignalDragLeaveCallback) int {
	signalWidgetDragLeaveLock.Lock()
	defer signalWidgetDragLeaveLock.Unlock()

	signalWidgetDragLeaveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_leave(instance, C.gpointer(uintptr(signalWidgetDragLeaveId)))

	detail := signalWidgetDragLeaveDetail{callback, handlerID}
	signalWidgetDragLeaveMap[signalWidgetDragLeaveId] = detail

	return signalWidgetDragLeaveId
}

/*
DisconnectDragLeave disconnects a callback from the 'drag-leave' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragLeave.
*/
func (recv *Widget) DisconnectDragLeave(connectionID int) {
	signalWidgetDragLeaveLock.Lock()
	defer signalWidgetDragLeaveLock.Unlock()

	detail, exists := signalWidgetDragLeaveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragLeaveMap, connectionID)
}

//export widget_dragLeaveHandler
func widget_dragLeaveHandler(_ *C.GObject, c_context *C.GdkDragContext, c_time C.guint, data C.gpointer) {
	signalWidgetDragLeaveLock.RLock()
	defer signalWidgetDragLeaveLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragLeaveMap[index].callback
	callback(context, time)
}

type signalWidgetDragMotionDetail struct {
	callback  WidgetSignalDragMotionCallback
	handlerID C.gulong
}

var signalWidgetDragMotionId int
var signalWidgetDragMotionMap = make(map[int]signalWidgetDragMotionDetail)
var signalWidgetDragMotionLock sync.RWMutex

// WidgetSignalDragMotionCallback is a callback function for a 'drag-motion' signal emitted from a Widget.
type WidgetSignalDragMotionCallback func(context *gdk.DragContext, x int32, y int32, time uint32) bool

/*
ConnectDragMotion connects the callback to the 'drag-motion' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragMotion to remove it.
*/
func (recv *Widget) ConnectDragMotion(callback WidgetSignalDragMotionCallback) int {
	signalWidgetDragMotionLock.Lock()
	defer signalWidgetDragMotionLock.Unlock()

	signalWidgetDragMotionId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_motion(instance, C.gpointer(uintptr(signalWidgetDragMotionId)))

	detail := signalWidgetDragMotionDetail{callback, handlerID}
	signalWidgetDragMotionMap[signalWidgetDragMotionId] = detail

	return signalWidgetDragMotionId
}

/*
DisconnectDragMotion disconnects a callback from the 'drag-motion' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragMotion.
*/
func (recv *Widget) DisconnectDragMotion(connectionID int) {
	signalWidgetDragMotionLock.Lock()
	defer signalWidgetDragMotionLock.Unlock()

	detail, exists := signalWidgetDragMotionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragMotionMap, connectionID)
}

//export widget_dragMotionHandler
func widget_dragMotionHandler(_ *C.GObject, c_context *C.GdkDragContext, c_x C.gint, c_y C.gint, c_time C.guint, data C.gpointer) C.gboolean {
	signalWidgetDragMotionLock.RLock()
	defer signalWidgetDragMotionLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	x := int32(c_x)

	y := int32(c_y)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragMotionMap[index].callback
	retGo := callback(context, x, y, time)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetEnterNotifyEventDetail struct {
	callback  WidgetSignalEnterNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetEnterNotifyEventId int
var signalWidgetEnterNotifyEventMap = make(map[int]signalWidgetEnterNotifyEventDetail)
var signalWidgetEnterNotifyEventLock sync.RWMutex

// WidgetSignalEnterNotifyEventCallback is a callback function for a 'enter-notify-event' signal emitted from a Widget.
type WidgetSignalEnterNotifyEventCallback func(event *gdk.EventCrossing) bool

/*
ConnectEnterNotifyEvent connects the callback to the 'enter-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectEnterNotifyEvent to remove it.
*/
func (recv *Widget) ConnectEnterNotifyEvent(callback WidgetSignalEnterNotifyEventCallback) int {
	signalWidgetEnterNotifyEventLock.Lock()
	defer signalWidgetEnterNotifyEventLock.Unlock()

	signalWidgetEnterNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_enter_notify_event(instance, C.gpointer(uintptr(signalWidgetEnterNotifyEventId)))

	detail := signalWidgetEnterNotifyEventDetail{callback, handlerID}
	signalWidgetEnterNotifyEventMap[signalWidgetEnterNotifyEventId] = detail

	return signalWidgetEnterNotifyEventId
}

/*
DisconnectEnterNotifyEvent disconnects a callback from the 'enter-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectEnterNotifyEvent.
*/
func (recv *Widget) DisconnectEnterNotifyEvent(connectionID int) {
	signalWidgetEnterNotifyEventLock.Lock()
	defer signalWidgetEnterNotifyEventLock.Unlock()

	detail, exists := signalWidgetEnterNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetEnterNotifyEventMap, connectionID)
}

//export widget_enterNotifyEventHandler
func widget_enterNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventCrossing, data C.gpointer) C.gboolean {
	signalWidgetEnterNotifyEventLock.RLock()
	defer signalWidgetEnterNotifyEventLock.RUnlock()

	event := gdk.EventCrossingNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetEnterNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

// Unsupported signal 'event-after' for Widget : unsupported parameter event : no type generator for Gdk.Event,

type signalWidgetFocusDetail struct {
	callback  WidgetSignalFocusCallback
	handlerID C.gulong
}

var signalWidgetFocusId int
var signalWidgetFocusMap = make(map[int]signalWidgetFocusDetail)
var signalWidgetFocusLock sync.RWMutex

// WidgetSignalFocusCallback is a callback function for a 'focus' signal emitted from a Widget.
type WidgetSignalFocusCallback func(direction DirectionType) bool

/*
ConnectFocus connects the callback to the 'focus' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocus to remove it.
*/
func (recv *Widget) ConnectFocus(callback WidgetSignalFocusCallback) int {
	signalWidgetFocusLock.Lock()
	defer signalWidgetFocusLock.Unlock()

	signalWidgetFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus(instance, C.gpointer(uintptr(signalWidgetFocusId)))

	detail := signalWidgetFocusDetail{callback, handlerID}
	signalWidgetFocusMap[signalWidgetFocusId] = detail

	return signalWidgetFocusId
}

/*
DisconnectFocus disconnects a callback from the 'focus' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocus.
*/
func (recv *Widget) DisconnectFocus(connectionID int) {
	signalWidgetFocusLock.Lock()
	defer signalWidgetFocusLock.Unlock()

	detail, exists := signalWidgetFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusMap, connectionID)
}

//export widget_focusHandler
func widget_focusHandler(_ *C.GObject, c_direction C.GtkDirectionType, data C.gpointer) C.gboolean {
	signalWidgetFocusLock.RLock()
	defer signalWidgetFocusLock.RUnlock()

	direction := DirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalWidgetFocusMap[index].callback
	retGo := callback(direction)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetFocusInEventDetail struct {
	callback  WidgetSignalFocusInEventCallback
	handlerID C.gulong
}

var signalWidgetFocusInEventId int
var signalWidgetFocusInEventMap = make(map[int]signalWidgetFocusInEventDetail)
var signalWidgetFocusInEventLock sync.RWMutex

// WidgetSignalFocusInEventCallback is a callback function for a 'focus-in-event' signal emitted from a Widget.
type WidgetSignalFocusInEventCallback func(event *gdk.EventFocus) bool

/*
ConnectFocusInEvent connects the callback to the 'focus-in-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocusInEvent to remove it.
*/
func (recv *Widget) ConnectFocusInEvent(callback WidgetSignalFocusInEventCallback) int {
	signalWidgetFocusInEventLock.Lock()
	defer signalWidgetFocusInEventLock.Unlock()

	signalWidgetFocusInEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus_in_event(instance, C.gpointer(uintptr(signalWidgetFocusInEventId)))

	detail := signalWidgetFocusInEventDetail{callback, handlerID}
	signalWidgetFocusInEventMap[signalWidgetFocusInEventId] = detail

	return signalWidgetFocusInEventId
}

/*
DisconnectFocusInEvent disconnects a callback from the 'focus-in-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocusInEvent.
*/
func (recv *Widget) DisconnectFocusInEvent(connectionID int) {
	signalWidgetFocusInEventLock.Lock()
	defer signalWidgetFocusInEventLock.Unlock()

	detail, exists := signalWidgetFocusInEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusInEventMap, connectionID)
}

//export widget_focusInEventHandler
func widget_focusInEventHandler(_ *C.GObject, c_event *C.GdkEventFocus, data C.gpointer) C.gboolean {
	signalWidgetFocusInEventLock.RLock()
	defer signalWidgetFocusInEventLock.RUnlock()

	event := gdk.EventFocusNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetFocusInEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetFocusOutEventDetail struct {
	callback  WidgetSignalFocusOutEventCallback
	handlerID C.gulong
}

var signalWidgetFocusOutEventId int
var signalWidgetFocusOutEventMap = make(map[int]signalWidgetFocusOutEventDetail)
var signalWidgetFocusOutEventLock sync.RWMutex

// WidgetSignalFocusOutEventCallback is a callback function for a 'focus-out-event' signal emitted from a Widget.
type WidgetSignalFocusOutEventCallback func(event *gdk.EventFocus) bool

/*
ConnectFocusOutEvent connects the callback to the 'focus-out-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocusOutEvent to remove it.
*/
func (recv *Widget) ConnectFocusOutEvent(callback WidgetSignalFocusOutEventCallback) int {
	signalWidgetFocusOutEventLock.Lock()
	defer signalWidgetFocusOutEventLock.Unlock()

	signalWidgetFocusOutEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus_out_event(instance, C.gpointer(uintptr(signalWidgetFocusOutEventId)))

	detail := signalWidgetFocusOutEventDetail{callback, handlerID}
	signalWidgetFocusOutEventMap[signalWidgetFocusOutEventId] = detail

	return signalWidgetFocusOutEventId
}

/*
DisconnectFocusOutEvent disconnects a callback from the 'focus-out-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocusOutEvent.
*/
func (recv *Widget) DisconnectFocusOutEvent(connectionID int) {
	signalWidgetFocusOutEventLock.Lock()
	defer signalWidgetFocusOutEventLock.Unlock()

	detail, exists := signalWidgetFocusOutEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusOutEventMap, connectionID)
}

//export widget_focusOutEventHandler
func widget_focusOutEventHandler(_ *C.GObject, c_event *C.GdkEventFocus, data C.gpointer) C.gboolean {
	signalWidgetFocusOutEventLock.RLock()
	defer signalWidgetFocusOutEventLock.RUnlock()

	event := gdk.EventFocusNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetFocusOutEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetGrabFocusDetail struct {
	callback  WidgetSignalGrabFocusCallback
	handlerID C.gulong
}

var signalWidgetGrabFocusId int
var signalWidgetGrabFocusMap = make(map[int]signalWidgetGrabFocusDetail)
var signalWidgetGrabFocusLock sync.RWMutex

// WidgetSignalGrabFocusCallback is a callback function for a 'grab-focus' signal emitted from a Widget.
type WidgetSignalGrabFocusCallback func()

/*
ConnectGrabFocus connects the callback to the 'grab-focus' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabFocus to remove it.
*/
func (recv *Widget) ConnectGrabFocus(callback WidgetSignalGrabFocusCallback) int {
	signalWidgetGrabFocusLock.Lock()
	defer signalWidgetGrabFocusLock.Unlock()

	signalWidgetGrabFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_focus(instance, C.gpointer(uintptr(signalWidgetGrabFocusId)))

	detail := signalWidgetGrabFocusDetail{callback, handlerID}
	signalWidgetGrabFocusMap[signalWidgetGrabFocusId] = detail

	return signalWidgetGrabFocusId
}

/*
DisconnectGrabFocus disconnects a callback from the 'grab-focus' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabFocus.
*/
func (recv *Widget) DisconnectGrabFocus(connectionID int) {
	signalWidgetGrabFocusLock.Lock()
	defer signalWidgetGrabFocusLock.Unlock()

	detail, exists := signalWidgetGrabFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabFocusMap, connectionID)
}

//export widget_grabFocusHandler
func widget_grabFocusHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetGrabFocusLock.RLock()
	defer signalWidgetGrabFocusLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetGrabFocusMap[index].callback
	callback()
}

type signalWidgetGrabNotifyDetail struct {
	callback  WidgetSignalGrabNotifyCallback
	handlerID C.gulong
}

var signalWidgetGrabNotifyId int
var signalWidgetGrabNotifyMap = make(map[int]signalWidgetGrabNotifyDetail)
var signalWidgetGrabNotifyLock sync.RWMutex

// WidgetSignalGrabNotifyCallback is a callback function for a 'grab-notify' signal emitted from a Widget.
type WidgetSignalGrabNotifyCallback func(wasGrabbed bool)

/*
ConnectGrabNotify connects the callback to the 'grab-notify' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabNotify to remove it.
*/
func (recv *Widget) ConnectGrabNotify(callback WidgetSignalGrabNotifyCallback) int {
	signalWidgetGrabNotifyLock.Lock()
	defer signalWidgetGrabNotifyLock.Unlock()

	signalWidgetGrabNotifyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_notify(instance, C.gpointer(uintptr(signalWidgetGrabNotifyId)))

	detail := signalWidgetGrabNotifyDetail{callback, handlerID}
	signalWidgetGrabNotifyMap[signalWidgetGrabNotifyId] = detail

	return signalWidgetGrabNotifyId
}

/*
DisconnectGrabNotify disconnects a callback from the 'grab-notify' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabNotify.
*/
func (recv *Widget) DisconnectGrabNotify(connectionID int) {
	signalWidgetGrabNotifyLock.Lock()
	defer signalWidgetGrabNotifyLock.Unlock()

	detail, exists := signalWidgetGrabNotifyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabNotifyMap, connectionID)
}

//export widget_grabNotifyHandler
func widget_grabNotifyHandler(_ *C.GObject, c_was_grabbed C.gboolean, data C.gpointer) {
	signalWidgetGrabNotifyLock.RLock()
	defer signalWidgetGrabNotifyLock.RUnlock()

	wasGrabbed := c_was_grabbed == C.TRUE

	index := int(uintptr(data))
	callback := signalWidgetGrabNotifyMap[index].callback
	callback(wasGrabbed)
}

type signalWidgetHideDetail struct {
	callback  WidgetSignalHideCallback
	handlerID C.gulong
}

var signalWidgetHideId int
var signalWidgetHideMap = make(map[int]signalWidgetHideDetail)
var signalWidgetHideLock sync.RWMutex

// WidgetSignalHideCallback is a callback function for a 'hide' signal emitted from a Widget.
type WidgetSignalHideCallback func()

/*
ConnectHide connects the callback to the 'hide' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectHide to remove it.
*/
func (recv *Widget) ConnectHide(callback WidgetSignalHideCallback) int {
	signalWidgetHideLock.Lock()
	defer signalWidgetHideLock.Unlock()

	signalWidgetHideId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_hide(instance, C.gpointer(uintptr(signalWidgetHideId)))

	detail := signalWidgetHideDetail{callback, handlerID}
	signalWidgetHideMap[signalWidgetHideId] = detail

	return signalWidgetHideId
}

/*
DisconnectHide disconnects a callback from the 'hide' signal for the Widget.

The connectionID should be a value returned from a call to ConnectHide.
*/
func (recv *Widget) DisconnectHide(connectionID int) {
	signalWidgetHideLock.Lock()
	defer signalWidgetHideLock.Unlock()

	detail, exists := signalWidgetHideMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetHideMap, connectionID)
}

//export widget_hideHandler
func widget_hideHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetHideLock.RLock()
	defer signalWidgetHideLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetHideMap[index].callback
	callback()
}

type signalWidgetHierarchyChangedDetail struct {
	callback  WidgetSignalHierarchyChangedCallback
	handlerID C.gulong
}

var signalWidgetHierarchyChangedId int
var signalWidgetHierarchyChangedMap = make(map[int]signalWidgetHierarchyChangedDetail)
var signalWidgetHierarchyChangedLock sync.RWMutex

// WidgetSignalHierarchyChangedCallback is a callback function for a 'hierarchy-changed' signal emitted from a Widget.
type WidgetSignalHierarchyChangedCallback func(previousToplevel *Widget)

/*
ConnectHierarchyChanged connects the callback to the 'hierarchy-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectHierarchyChanged to remove it.
*/
func (recv *Widget) ConnectHierarchyChanged(callback WidgetSignalHierarchyChangedCallback) int {
	signalWidgetHierarchyChangedLock.Lock()
	defer signalWidgetHierarchyChangedLock.Unlock()

	signalWidgetHierarchyChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_hierarchy_changed(instance, C.gpointer(uintptr(signalWidgetHierarchyChangedId)))

	detail := signalWidgetHierarchyChangedDetail{callback, handlerID}
	signalWidgetHierarchyChangedMap[signalWidgetHierarchyChangedId] = detail

	return signalWidgetHierarchyChangedId
}

/*
DisconnectHierarchyChanged disconnects a callback from the 'hierarchy-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectHierarchyChanged.
*/
func (recv *Widget) DisconnectHierarchyChanged(connectionID int) {
	signalWidgetHierarchyChangedLock.Lock()
	defer signalWidgetHierarchyChangedLock.Unlock()

	detail, exists := signalWidgetHierarchyChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetHierarchyChangedMap, connectionID)
}

//export widget_hierarchyChangedHandler
func widget_hierarchyChangedHandler(_ *C.GObject, c_previous_toplevel *C.GtkWidget, data C.gpointer) {
	signalWidgetHierarchyChangedLock.RLock()
	defer signalWidgetHierarchyChangedLock.RUnlock()

	previousToplevel := WidgetNewFromC(unsafe.Pointer(c_previous_toplevel))

	index := int(uintptr(data))
	callback := signalWidgetHierarchyChangedMap[index].callback
	callback(previousToplevel)
}

type signalWidgetKeyPressEventDetail struct {
	callback  WidgetSignalKeyPressEventCallback
	handlerID C.gulong
}

var signalWidgetKeyPressEventId int
var signalWidgetKeyPressEventMap = make(map[int]signalWidgetKeyPressEventDetail)
var signalWidgetKeyPressEventLock sync.RWMutex

// WidgetSignalKeyPressEventCallback is a callback function for a 'key-press-event' signal emitted from a Widget.
type WidgetSignalKeyPressEventCallback func(event *gdk.EventKey) bool

/*
ConnectKeyPressEvent connects the callback to the 'key-press-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeyPressEvent to remove it.
*/
func (recv *Widget) ConnectKeyPressEvent(callback WidgetSignalKeyPressEventCallback) int {
	signalWidgetKeyPressEventLock.Lock()
	defer signalWidgetKeyPressEventLock.Unlock()

	signalWidgetKeyPressEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_key_press_event(instance, C.gpointer(uintptr(signalWidgetKeyPressEventId)))

	detail := signalWidgetKeyPressEventDetail{callback, handlerID}
	signalWidgetKeyPressEventMap[signalWidgetKeyPressEventId] = detail

	return signalWidgetKeyPressEventId
}

/*
DisconnectKeyPressEvent disconnects a callback from the 'key-press-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeyPressEvent.
*/
func (recv *Widget) DisconnectKeyPressEvent(connectionID int) {
	signalWidgetKeyPressEventLock.Lock()
	defer signalWidgetKeyPressEventLock.Unlock()

	detail, exists := signalWidgetKeyPressEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeyPressEventMap, connectionID)
}

//export widget_keyPressEventHandler
func widget_keyPressEventHandler(_ *C.GObject, c_event *C.GdkEventKey, data C.gpointer) C.gboolean {
	signalWidgetKeyPressEventLock.RLock()
	defer signalWidgetKeyPressEventLock.RUnlock()

	event := gdk.EventKeyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetKeyPressEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetKeyReleaseEventDetail struct {
	callback  WidgetSignalKeyReleaseEventCallback
	handlerID C.gulong
}

var signalWidgetKeyReleaseEventId int
var signalWidgetKeyReleaseEventMap = make(map[int]signalWidgetKeyReleaseEventDetail)
var signalWidgetKeyReleaseEventLock sync.RWMutex

// WidgetSignalKeyReleaseEventCallback is a callback function for a 'key-release-event' signal emitted from a Widget.
type WidgetSignalKeyReleaseEventCallback func(event *gdk.EventKey) bool

/*
ConnectKeyReleaseEvent connects the callback to the 'key-release-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeyReleaseEvent to remove it.
*/
func (recv *Widget) ConnectKeyReleaseEvent(callback WidgetSignalKeyReleaseEventCallback) int {
	signalWidgetKeyReleaseEventLock.Lock()
	defer signalWidgetKeyReleaseEventLock.Unlock()

	signalWidgetKeyReleaseEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_key_release_event(instance, C.gpointer(uintptr(signalWidgetKeyReleaseEventId)))

	detail := signalWidgetKeyReleaseEventDetail{callback, handlerID}
	signalWidgetKeyReleaseEventMap[signalWidgetKeyReleaseEventId] = detail

	return signalWidgetKeyReleaseEventId
}

/*
DisconnectKeyReleaseEvent disconnects a callback from the 'key-release-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeyReleaseEvent.
*/
func (recv *Widget) DisconnectKeyReleaseEvent(connectionID int) {
	signalWidgetKeyReleaseEventLock.Lock()
	defer signalWidgetKeyReleaseEventLock.Unlock()

	detail, exists := signalWidgetKeyReleaseEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeyReleaseEventMap, connectionID)
}

//export widget_keyReleaseEventHandler
func widget_keyReleaseEventHandler(_ *C.GObject, c_event *C.GdkEventKey, data C.gpointer) C.gboolean {
	signalWidgetKeyReleaseEventLock.RLock()
	defer signalWidgetKeyReleaseEventLock.RUnlock()

	event := gdk.EventKeyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetKeyReleaseEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetLeaveNotifyEventDetail struct {
	callback  WidgetSignalLeaveNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetLeaveNotifyEventId int
var signalWidgetLeaveNotifyEventMap = make(map[int]signalWidgetLeaveNotifyEventDetail)
var signalWidgetLeaveNotifyEventLock sync.RWMutex

// WidgetSignalLeaveNotifyEventCallback is a callback function for a 'leave-notify-event' signal emitted from a Widget.
type WidgetSignalLeaveNotifyEventCallback func(event *gdk.EventCrossing) bool

/*
ConnectLeaveNotifyEvent connects the callback to the 'leave-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectLeaveNotifyEvent to remove it.
*/
func (recv *Widget) ConnectLeaveNotifyEvent(callback WidgetSignalLeaveNotifyEventCallback) int {
	signalWidgetLeaveNotifyEventLock.Lock()
	defer signalWidgetLeaveNotifyEventLock.Unlock()

	signalWidgetLeaveNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_leave_notify_event(instance, C.gpointer(uintptr(signalWidgetLeaveNotifyEventId)))

	detail := signalWidgetLeaveNotifyEventDetail{callback, handlerID}
	signalWidgetLeaveNotifyEventMap[signalWidgetLeaveNotifyEventId] = detail

	return signalWidgetLeaveNotifyEventId
}

/*
DisconnectLeaveNotifyEvent disconnects a callback from the 'leave-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectLeaveNotifyEvent.
*/
func (recv *Widget) DisconnectLeaveNotifyEvent(connectionID int) {
	signalWidgetLeaveNotifyEventLock.Lock()
	defer signalWidgetLeaveNotifyEventLock.Unlock()

	detail, exists := signalWidgetLeaveNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetLeaveNotifyEventMap, connectionID)
}

//export widget_leaveNotifyEventHandler
func widget_leaveNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventCrossing, data C.gpointer) C.gboolean {
	signalWidgetLeaveNotifyEventLock.RLock()
	defer signalWidgetLeaveNotifyEventLock.RUnlock()

	event := gdk.EventCrossingNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetLeaveNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMapDetail struct {
	callback  WidgetSignalMapCallback
	handlerID C.gulong
}

var signalWidgetMapId int
var signalWidgetMapMap = make(map[int]signalWidgetMapDetail)
var signalWidgetMapLock sync.RWMutex

// WidgetSignalMapCallback is a callback function for a 'map' signal emitted from a Widget.
type WidgetSignalMapCallback func()

/*
ConnectMap connects the callback to the 'map' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMap to remove it.
*/
func (recv *Widget) ConnectMap(callback WidgetSignalMapCallback) int {
	signalWidgetMapLock.Lock()
	defer signalWidgetMapLock.Unlock()

	signalWidgetMapId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_map(instance, C.gpointer(uintptr(signalWidgetMapId)))

	detail := signalWidgetMapDetail{callback, handlerID}
	signalWidgetMapMap[signalWidgetMapId] = detail

	return signalWidgetMapId
}

/*
DisconnectMap disconnects a callback from the 'map' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMap.
*/
func (recv *Widget) DisconnectMap(connectionID int) {
	signalWidgetMapLock.Lock()
	defer signalWidgetMapLock.Unlock()

	detail, exists := signalWidgetMapMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMapMap, connectionID)
}

//export widget_mapHandler
func widget_mapHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetMapLock.RLock()
	defer signalWidgetMapLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetMapMap[index].callback
	callback()
}

type signalWidgetMapEventDetail struct {
	callback  WidgetSignalMapEventCallback
	handlerID C.gulong
}

var signalWidgetMapEventId int
var signalWidgetMapEventMap = make(map[int]signalWidgetMapEventDetail)
var signalWidgetMapEventLock sync.RWMutex

// WidgetSignalMapEventCallback is a callback function for a 'map-event' signal emitted from a Widget.
type WidgetSignalMapEventCallback func(event *gdk.EventAny) bool

/*
ConnectMapEvent connects the callback to the 'map-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMapEvent to remove it.
*/
func (recv *Widget) ConnectMapEvent(callback WidgetSignalMapEventCallback) int {
	signalWidgetMapEventLock.Lock()
	defer signalWidgetMapEventLock.Unlock()

	signalWidgetMapEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_map_event(instance, C.gpointer(uintptr(signalWidgetMapEventId)))

	detail := signalWidgetMapEventDetail{callback, handlerID}
	signalWidgetMapEventMap[signalWidgetMapEventId] = detail

	return signalWidgetMapEventId
}

/*
DisconnectMapEvent disconnects a callback from the 'map-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMapEvent.
*/
func (recv *Widget) DisconnectMapEvent(connectionID int) {
	signalWidgetMapEventLock.Lock()
	defer signalWidgetMapEventLock.Unlock()

	detail, exists := signalWidgetMapEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMapEventMap, connectionID)
}

//export widget_mapEventHandler
func widget_mapEventHandler(_ *C.GObject, c_event *C.GdkEventAny, data C.gpointer) C.gboolean {
	signalWidgetMapEventLock.RLock()
	defer signalWidgetMapEventLock.RUnlock()

	event := gdk.EventAnyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetMapEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMnemonicActivateDetail struct {
	callback  WidgetSignalMnemonicActivateCallback
	handlerID C.gulong
}

var signalWidgetMnemonicActivateId int
var signalWidgetMnemonicActivateMap = make(map[int]signalWidgetMnemonicActivateDetail)
var signalWidgetMnemonicActivateLock sync.RWMutex

// WidgetSignalMnemonicActivateCallback is a callback function for a 'mnemonic-activate' signal emitted from a Widget.
type WidgetSignalMnemonicActivateCallback func(groupCycling bool) bool

/*
ConnectMnemonicActivate connects the callback to the 'mnemonic-activate' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMnemonicActivate to remove it.
*/
func (recv *Widget) ConnectMnemonicActivate(callback WidgetSignalMnemonicActivateCallback) int {
	signalWidgetMnemonicActivateLock.Lock()
	defer signalWidgetMnemonicActivateLock.Unlock()

	signalWidgetMnemonicActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_mnemonic_activate(instance, C.gpointer(uintptr(signalWidgetMnemonicActivateId)))

	detail := signalWidgetMnemonicActivateDetail{callback, handlerID}
	signalWidgetMnemonicActivateMap[signalWidgetMnemonicActivateId] = detail

	return signalWidgetMnemonicActivateId
}

/*
DisconnectMnemonicActivate disconnects a callback from the 'mnemonic-activate' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMnemonicActivate.
*/
func (recv *Widget) DisconnectMnemonicActivate(connectionID int) {
	signalWidgetMnemonicActivateLock.Lock()
	defer signalWidgetMnemonicActivateLock.Unlock()

	detail, exists := signalWidgetMnemonicActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMnemonicActivateMap, connectionID)
}

//export widget_mnemonicActivateHandler
func widget_mnemonicActivateHandler(_ *C.GObject, c_group_cycling C.gboolean, data C.gpointer) C.gboolean {
	signalWidgetMnemonicActivateLock.RLock()
	defer signalWidgetMnemonicActivateLock.RUnlock()

	groupCycling := c_group_cycling == C.TRUE

	index := int(uintptr(data))
	callback := signalWidgetMnemonicActivateMap[index].callback
	retGo := callback(groupCycling)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMotionNotifyEventDetail struct {
	callback  WidgetSignalMotionNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetMotionNotifyEventId int
var signalWidgetMotionNotifyEventMap = make(map[int]signalWidgetMotionNotifyEventDetail)
var signalWidgetMotionNotifyEventLock sync.RWMutex

// WidgetSignalMotionNotifyEventCallback is a callback function for a 'motion-notify-event' signal emitted from a Widget.
type WidgetSignalMotionNotifyEventCallback func(event *gdk.EventMotion) bool

/*
ConnectMotionNotifyEvent connects the callback to the 'motion-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMotionNotifyEvent to remove it.
*/
func (recv *Widget) ConnectMotionNotifyEvent(callback WidgetSignalMotionNotifyEventCallback) int {
	signalWidgetMotionNotifyEventLock.Lock()
	defer signalWidgetMotionNotifyEventLock.Unlock()

	signalWidgetMotionNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_motion_notify_event(instance, C.gpointer(uintptr(signalWidgetMotionNotifyEventId)))

	detail := signalWidgetMotionNotifyEventDetail{callback, handlerID}
	signalWidgetMotionNotifyEventMap[signalWidgetMotionNotifyEventId] = detail

	return signalWidgetMotionNotifyEventId
}

/*
DisconnectMotionNotifyEvent disconnects a callback from the 'motion-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMotionNotifyEvent.
*/
func (recv *Widget) DisconnectMotionNotifyEvent(connectionID int) {
	signalWidgetMotionNotifyEventLock.Lock()
	defer signalWidgetMotionNotifyEventLock.Unlock()

	detail, exists := signalWidgetMotionNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMotionNotifyEventMap, connectionID)
}

//export widget_motionNotifyEventHandler
func widget_motionNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventMotion, data C.gpointer) C.gboolean {
	signalWidgetMotionNotifyEventLock.RLock()
	defer signalWidgetMotionNotifyEventLock.RUnlock()

	event := gdk.EventMotionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetMotionNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMoveFocusDetail struct {
	callback  WidgetSignalMoveFocusCallback
	handlerID C.gulong
}

var signalWidgetMoveFocusId int
var signalWidgetMoveFocusMap = make(map[int]signalWidgetMoveFocusDetail)
var signalWidgetMoveFocusLock sync.RWMutex

// WidgetSignalMoveFocusCallback is a callback function for a 'move-focus' signal emitted from a Widget.
type WidgetSignalMoveFocusCallback func(direction DirectionType)

/*
ConnectMoveFocus connects the callback to the 'move-focus' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMoveFocus to remove it.
*/
func (recv *Widget) ConnectMoveFocus(callback WidgetSignalMoveFocusCallback) int {
	signalWidgetMoveFocusLock.Lock()
	defer signalWidgetMoveFocusLock.Unlock()

	signalWidgetMoveFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_move_focus(instance, C.gpointer(uintptr(signalWidgetMoveFocusId)))

	detail := signalWidgetMoveFocusDetail{callback, handlerID}
	signalWidgetMoveFocusMap[signalWidgetMoveFocusId] = detail

	return signalWidgetMoveFocusId
}

/*
DisconnectMoveFocus disconnects a callback from the 'move-focus' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMoveFocus.
*/
func (recv *Widget) DisconnectMoveFocus(connectionID int) {
	signalWidgetMoveFocusLock.Lock()
	defer signalWidgetMoveFocusLock.Unlock()

	detail, exists := signalWidgetMoveFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMoveFocusMap, connectionID)
}

//export widget_moveFocusHandler
func widget_moveFocusHandler(_ *C.GObject, c_direction C.GtkDirectionType, data C.gpointer) {
	signalWidgetMoveFocusLock.RLock()
	defer signalWidgetMoveFocusLock.RUnlock()

	direction := DirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalWidgetMoveFocusMap[index].callback
	callback(direction)
}

type signalWidgetParentSetDetail struct {
	callback  WidgetSignalParentSetCallback
	handlerID C.gulong
}

var signalWidgetParentSetId int
var signalWidgetParentSetMap = make(map[int]signalWidgetParentSetDetail)
var signalWidgetParentSetLock sync.RWMutex

// WidgetSignalParentSetCallback is a callback function for a 'parent-set' signal emitted from a Widget.
type WidgetSignalParentSetCallback func(oldParent *Widget)

/*
ConnectParentSet connects the callback to the 'parent-set' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectParentSet to remove it.
*/
func (recv *Widget) ConnectParentSet(callback WidgetSignalParentSetCallback) int {
	signalWidgetParentSetLock.Lock()
	defer signalWidgetParentSetLock.Unlock()

	signalWidgetParentSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_parent_set(instance, C.gpointer(uintptr(signalWidgetParentSetId)))

	detail := signalWidgetParentSetDetail{callback, handlerID}
	signalWidgetParentSetMap[signalWidgetParentSetId] = detail

	return signalWidgetParentSetId
}

/*
DisconnectParentSet disconnects a callback from the 'parent-set' signal for the Widget.

The connectionID should be a value returned from a call to ConnectParentSet.
*/
func (recv *Widget) DisconnectParentSet(connectionID int) {
	signalWidgetParentSetLock.Lock()
	defer signalWidgetParentSetLock.Unlock()

	detail, exists := signalWidgetParentSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetParentSetMap, connectionID)
}

//export widget_parentSetHandler
func widget_parentSetHandler(_ *C.GObject, c_old_parent *C.GtkWidget, data C.gpointer) {
	signalWidgetParentSetLock.RLock()
	defer signalWidgetParentSetLock.RUnlock()

	oldParent := WidgetNewFromC(unsafe.Pointer(c_old_parent))

	index := int(uintptr(data))
	callback := signalWidgetParentSetMap[index].callback
	callback(oldParent)
}

type signalWidgetPopupMenuDetail struct {
	callback  WidgetSignalPopupMenuCallback
	handlerID C.gulong
}

var signalWidgetPopupMenuId int
var signalWidgetPopupMenuMap = make(map[int]signalWidgetPopupMenuDetail)
var signalWidgetPopupMenuLock sync.RWMutex

// WidgetSignalPopupMenuCallback is a callback function for a 'popup-menu' signal emitted from a Widget.
type WidgetSignalPopupMenuCallback func() bool

/*
ConnectPopupMenu connects the callback to the 'popup-menu' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectPopupMenu to remove it.
*/
func (recv *Widget) ConnectPopupMenu(callback WidgetSignalPopupMenuCallback) int {
	signalWidgetPopupMenuLock.Lock()
	defer signalWidgetPopupMenuLock.Unlock()

	signalWidgetPopupMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_popup_menu(instance, C.gpointer(uintptr(signalWidgetPopupMenuId)))

	detail := signalWidgetPopupMenuDetail{callback, handlerID}
	signalWidgetPopupMenuMap[signalWidgetPopupMenuId] = detail

	return signalWidgetPopupMenuId
}

/*
DisconnectPopupMenu disconnects a callback from the 'popup-menu' signal for the Widget.

The connectionID should be a value returned from a call to ConnectPopupMenu.
*/
func (recv *Widget) DisconnectPopupMenu(connectionID int) {
	signalWidgetPopupMenuLock.Lock()
	defer signalWidgetPopupMenuLock.Unlock()

	detail, exists := signalWidgetPopupMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetPopupMenuMap, connectionID)
}

//export widget_popupMenuHandler
func widget_popupMenuHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalWidgetPopupMenuLock.RLock()
	defer signalWidgetPopupMenuLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetPopupMenuMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetPropertyNotifyEventDetail struct {
	callback  WidgetSignalPropertyNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetPropertyNotifyEventId int
var signalWidgetPropertyNotifyEventMap = make(map[int]signalWidgetPropertyNotifyEventDetail)
var signalWidgetPropertyNotifyEventLock sync.RWMutex

// WidgetSignalPropertyNotifyEventCallback is a callback function for a 'property-notify-event' signal emitted from a Widget.
type WidgetSignalPropertyNotifyEventCallback func(event *gdk.EventProperty) bool

/*
ConnectPropertyNotifyEvent connects the callback to the 'property-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectPropertyNotifyEvent to remove it.
*/
func (recv *Widget) ConnectPropertyNotifyEvent(callback WidgetSignalPropertyNotifyEventCallback) int {
	signalWidgetPropertyNotifyEventLock.Lock()
	defer signalWidgetPropertyNotifyEventLock.Unlock()

	signalWidgetPropertyNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_property_notify_event(instance, C.gpointer(uintptr(signalWidgetPropertyNotifyEventId)))

	detail := signalWidgetPropertyNotifyEventDetail{callback, handlerID}
	signalWidgetPropertyNotifyEventMap[signalWidgetPropertyNotifyEventId] = detail

	return signalWidgetPropertyNotifyEventId
}

/*
DisconnectPropertyNotifyEvent disconnects a callback from the 'property-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectPropertyNotifyEvent.
*/
func (recv *Widget) DisconnectPropertyNotifyEvent(connectionID int) {
	signalWidgetPropertyNotifyEventLock.Lock()
	defer signalWidgetPropertyNotifyEventLock.Unlock()

	detail, exists := signalWidgetPropertyNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetPropertyNotifyEventMap, connectionID)
}

//export widget_propertyNotifyEventHandler
func widget_propertyNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventProperty, data C.gpointer) C.gboolean {
	signalWidgetPropertyNotifyEventLock.RLock()
	defer signalWidgetPropertyNotifyEventLock.RUnlock()

	event := gdk.EventPropertyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetPropertyNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetProximityInEventDetail struct {
	callback  WidgetSignalProximityInEventCallback
	handlerID C.gulong
}

var signalWidgetProximityInEventId int
var signalWidgetProximityInEventMap = make(map[int]signalWidgetProximityInEventDetail)
var signalWidgetProximityInEventLock sync.RWMutex

// WidgetSignalProximityInEventCallback is a callback function for a 'proximity-in-event' signal emitted from a Widget.
type WidgetSignalProximityInEventCallback func(event *gdk.EventProximity) bool

/*
ConnectProximityInEvent connects the callback to the 'proximity-in-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectProximityInEvent to remove it.
*/
func (recv *Widget) ConnectProximityInEvent(callback WidgetSignalProximityInEventCallback) int {
	signalWidgetProximityInEventLock.Lock()
	defer signalWidgetProximityInEventLock.Unlock()

	signalWidgetProximityInEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_proximity_in_event(instance, C.gpointer(uintptr(signalWidgetProximityInEventId)))

	detail := signalWidgetProximityInEventDetail{callback, handlerID}
	signalWidgetProximityInEventMap[signalWidgetProximityInEventId] = detail

	return signalWidgetProximityInEventId
}

/*
DisconnectProximityInEvent disconnects a callback from the 'proximity-in-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectProximityInEvent.
*/
func (recv *Widget) DisconnectProximityInEvent(connectionID int) {
	signalWidgetProximityInEventLock.Lock()
	defer signalWidgetProximityInEventLock.Unlock()

	detail, exists := signalWidgetProximityInEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetProximityInEventMap, connectionID)
}

//export widget_proximityInEventHandler
func widget_proximityInEventHandler(_ *C.GObject, c_event *C.GdkEventProximity, data C.gpointer) C.gboolean {
	signalWidgetProximityInEventLock.RLock()
	defer signalWidgetProximityInEventLock.RUnlock()

	event := gdk.EventProximityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetProximityInEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetProximityOutEventDetail struct {
	callback  WidgetSignalProximityOutEventCallback
	handlerID C.gulong
}

var signalWidgetProximityOutEventId int
var signalWidgetProximityOutEventMap = make(map[int]signalWidgetProximityOutEventDetail)
var signalWidgetProximityOutEventLock sync.RWMutex

// WidgetSignalProximityOutEventCallback is a callback function for a 'proximity-out-event' signal emitted from a Widget.
type WidgetSignalProximityOutEventCallback func(event *gdk.EventProximity) bool

/*
ConnectProximityOutEvent connects the callback to the 'proximity-out-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectProximityOutEvent to remove it.
*/
func (recv *Widget) ConnectProximityOutEvent(callback WidgetSignalProximityOutEventCallback) int {
	signalWidgetProximityOutEventLock.Lock()
	defer signalWidgetProximityOutEventLock.Unlock()

	signalWidgetProximityOutEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_proximity_out_event(instance, C.gpointer(uintptr(signalWidgetProximityOutEventId)))

	detail := signalWidgetProximityOutEventDetail{callback, handlerID}
	signalWidgetProximityOutEventMap[signalWidgetProximityOutEventId] = detail

	return signalWidgetProximityOutEventId
}

/*
DisconnectProximityOutEvent disconnects a callback from the 'proximity-out-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectProximityOutEvent.
*/
func (recv *Widget) DisconnectProximityOutEvent(connectionID int) {
	signalWidgetProximityOutEventLock.Lock()
	defer signalWidgetProximityOutEventLock.Unlock()

	detail, exists := signalWidgetProximityOutEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetProximityOutEventMap, connectionID)
}

//export widget_proximityOutEventHandler
func widget_proximityOutEventHandler(_ *C.GObject, c_event *C.GdkEventProximity, data C.gpointer) C.gboolean {
	signalWidgetProximityOutEventLock.RLock()
	defer signalWidgetProximityOutEventLock.RUnlock()

	event := gdk.EventProximityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetProximityOutEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetRealizeDetail struct {
	callback  WidgetSignalRealizeCallback
	handlerID C.gulong
}

var signalWidgetRealizeId int
var signalWidgetRealizeMap = make(map[int]signalWidgetRealizeDetail)
var signalWidgetRealizeLock sync.RWMutex

// WidgetSignalRealizeCallback is a callback function for a 'realize' signal emitted from a Widget.
type WidgetSignalRealizeCallback func()

/*
ConnectRealize connects the callback to the 'realize' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectRealize to remove it.
*/
func (recv *Widget) ConnectRealize(callback WidgetSignalRealizeCallback) int {
	signalWidgetRealizeLock.Lock()
	defer signalWidgetRealizeLock.Unlock()

	signalWidgetRealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_realize(instance, C.gpointer(uintptr(signalWidgetRealizeId)))

	detail := signalWidgetRealizeDetail{callback, handlerID}
	signalWidgetRealizeMap[signalWidgetRealizeId] = detail

	return signalWidgetRealizeId
}

/*
DisconnectRealize disconnects a callback from the 'realize' signal for the Widget.

The connectionID should be a value returned from a call to ConnectRealize.
*/
func (recv *Widget) DisconnectRealize(connectionID int) {
	signalWidgetRealizeLock.Lock()
	defer signalWidgetRealizeLock.Unlock()

	detail, exists := signalWidgetRealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetRealizeMap, connectionID)
}

//export widget_realizeHandler
func widget_realizeHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetRealizeLock.RLock()
	defer signalWidgetRealizeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetRealizeMap[index].callback
	callback()
}

type signalWidgetScreenChangedDetail struct {
	callback  WidgetSignalScreenChangedCallback
	handlerID C.gulong
}

var signalWidgetScreenChangedId int
var signalWidgetScreenChangedMap = make(map[int]signalWidgetScreenChangedDetail)
var signalWidgetScreenChangedLock sync.RWMutex

// WidgetSignalScreenChangedCallback is a callback function for a 'screen-changed' signal emitted from a Widget.
type WidgetSignalScreenChangedCallback func(previousScreen *gdk.Screen)

/*
ConnectScreenChanged connects the callback to the 'screen-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectScreenChanged to remove it.
*/
func (recv *Widget) ConnectScreenChanged(callback WidgetSignalScreenChangedCallback) int {
	signalWidgetScreenChangedLock.Lock()
	defer signalWidgetScreenChangedLock.Unlock()

	signalWidgetScreenChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_screen_changed(instance, C.gpointer(uintptr(signalWidgetScreenChangedId)))

	detail := signalWidgetScreenChangedDetail{callback, handlerID}
	signalWidgetScreenChangedMap[signalWidgetScreenChangedId] = detail

	return signalWidgetScreenChangedId
}

/*
DisconnectScreenChanged disconnects a callback from the 'screen-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectScreenChanged.
*/
func (recv *Widget) DisconnectScreenChanged(connectionID int) {
	signalWidgetScreenChangedLock.Lock()
	defer signalWidgetScreenChangedLock.Unlock()

	detail, exists := signalWidgetScreenChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetScreenChangedMap, connectionID)
}

//export widget_screenChangedHandler
func widget_screenChangedHandler(_ *C.GObject, c_previous_screen *C.GdkScreen, data C.gpointer) {
	signalWidgetScreenChangedLock.RLock()
	defer signalWidgetScreenChangedLock.RUnlock()

	previousScreen := gdk.ScreenNewFromC(unsafe.Pointer(c_previous_screen))

	index := int(uintptr(data))
	callback := signalWidgetScreenChangedMap[index].callback
	callback(previousScreen)
}

type signalWidgetScrollEventDetail struct {
	callback  WidgetSignalScrollEventCallback
	handlerID C.gulong
}

var signalWidgetScrollEventId int
var signalWidgetScrollEventMap = make(map[int]signalWidgetScrollEventDetail)
var signalWidgetScrollEventLock sync.RWMutex

// WidgetSignalScrollEventCallback is a callback function for a 'scroll-event' signal emitted from a Widget.
type WidgetSignalScrollEventCallback func(event *gdk.EventScroll) bool

/*
ConnectScrollEvent connects the callback to the 'scroll-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectScrollEvent to remove it.
*/
func (recv *Widget) ConnectScrollEvent(callback WidgetSignalScrollEventCallback) int {
	signalWidgetScrollEventLock.Lock()
	defer signalWidgetScrollEventLock.Unlock()

	signalWidgetScrollEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_scroll_event(instance, C.gpointer(uintptr(signalWidgetScrollEventId)))

	detail := signalWidgetScrollEventDetail{callback, handlerID}
	signalWidgetScrollEventMap[signalWidgetScrollEventId] = detail

	return signalWidgetScrollEventId
}

/*
DisconnectScrollEvent disconnects a callback from the 'scroll-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectScrollEvent.
*/
func (recv *Widget) DisconnectScrollEvent(connectionID int) {
	signalWidgetScrollEventLock.Lock()
	defer signalWidgetScrollEventLock.Unlock()

	detail, exists := signalWidgetScrollEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetScrollEventMap, connectionID)
}

//export widget_scrollEventHandler
func widget_scrollEventHandler(_ *C.GObject, c_event *C.GdkEventScroll, data C.gpointer) C.gboolean {
	signalWidgetScrollEventLock.RLock()
	defer signalWidgetScrollEventLock.RUnlock()

	event := gdk.EventScrollNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetScrollEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSelectionClearEventDetail struct {
	callback  WidgetSignalSelectionClearEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionClearEventId int
var signalWidgetSelectionClearEventMap = make(map[int]signalWidgetSelectionClearEventDetail)
var signalWidgetSelectionClearEventLock sync.RWMutex

// WidgetSignalSelectionClearEventCallback is a callback function for a 'selection-clear-event' signal emitted from a Widget.
type WidgetSignalSelectionClearEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionClearEvent connects the callback to the 'selection-clear-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionClearEvent to remove it.
*/
func (recv *Widget) ConnectSelectionClearEvent(callback WidgetSignalSelectionClearEventCallback) int {
	signalWidgetSelectionClearEventLock.Lock()
	defer signalWidgetSelectionClearEventLock.Unlock()

	signalWidgetSelectionClearEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_clear_event(instance, C.gpointer(uintptr(signalWidgetSelectionClearEventId)))

	detail := signalWidgetSelectionClearEventDetail{callback, handlerID}
	signalWidgetSelectionClearEventMap[signalWidgetSelectionClearEventId] = detail

	return signalWidgetSelectionClearEventId
}

/*
DisconnectSelectionClearEvent disconnects a callback from the 'selection-clear-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionClearEvent.
*/
func (recv *Widget) DisconnectSelectionClearEvent(connectionID int) {
	signalWidgetSelectionClearEventLock.Lock()
	defer signalWidgetSelectionClearEventLock.Unlock()

	detail, exists := signalWidgetSelectionClearEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionClearEventMap, connectionID)
}

//export widget_selectionClearEventHandler
func widget_selectionClearEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	signalWidgetSelectionClearEventLock.RLock()
	defer signalWidgetSelectionClearEventLock.RUnlock()

	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionClearEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSelectionGetDetail struct {
	callback  WidgetSignalSelectionGetCallback
	handlerID C.gulong
}

var signalWidgetSelectionGetId int
var signalWidgetSelectionGetMap = make(map[int]signalWidgetSelectionGetDetail)
var signalWidgetSelectionGetLock sync.RWMutex

// WidgetSignalSelectionGetCallback is a callback function for a 'selection-get' signal emitted from a Widget.
type WidgetSignalSelectionGetCallback func(Data *SelectionData, info uint32, time uint32)

/*
ConnectSelectionGet connects the callback to the 'selection-get' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionGet to remove it.
*/
func (recv *Widget) ConnectSelectionGet(callback WidgetSignalSelectionGetCallback) int {
	signalWidgetSelectionGetLock.Lock()
	defer signalWidgetSelectionGetLock.Unlock()

	signalWidgetSelectionGetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_get(instance, C.gpointer(uintptr(signalWidgetSelectionGetId)))

	detail := signalWidgetSelectionGetDetail{callback, handlerID}
	signalWidgetSelectionGetMap[signalWidgetSelectionGetId] = detail

	return signalWidgetSelectionGetId
}

/*
DisconnectSelectionGet disconnects a callback from the 'selection-get' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionGet.
*/
func (recv *Widget) DisconnectSelectionGet(connectionID int) {
	signalWidgetSelectionGetLock.Lock()
	defer signalWidgetSelectionGetLock.Unlock()

	detail, exists := signalWidgetSelectionGetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionGetMap, connectionID)
}

//export widget_selectionGetHandler
func widget_selectionGetHandler(_ *C.GObject, c__data *C.GtkSelectionData, c_info C.guint, c_time C.guint, data C.gpointer) {
	signalWidgetSelectionGetLock.RLock()
	defer signalWidgetSelectionGetLock.RUnlock()

	Data := SelectionDataNewFromC(unsafe.Pointer(c__data))

	info := uint32(c_info)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetSelectionGetMap[index].callback
	callback(Data, info, time)
}

type signalWidgetSelectionNotifyEventDetail struct {
	callback  WidgetSignalSelectionNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionNotifyEventId int
var signalWidgetSelectionNotifyEventMap = make(map[int]signalWidgetSelectionNotifyEventDetail)
var signalWidgetSelectionNotifyEventLock sync.RWMutex

// WidgetSignalSelectionNotifyEventCallback is a callback function for a 'selection-notify-event' signal emitted from a Widget.
type WidgetSignalSelectionNotifyEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionNotifyEvent connects the callback to the 'selection-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionNotifyEvent to remove it.
*/
func (recv *Widget) ConnectSelectionNotifyEvent(callback WidgetSignalSelectionNotifyEventCallback) int {
	signalWidgetSelectionNotifyEventLock.Lock()
	defer signalWidgetSelectionNotifyEventLock.Unlock()

	signalWidgetSelectionNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_notify_event(instance, C.gpointer(uintptr(signalWidgetSelectionNotifyEventId)))

	detail := signalWidgetSelectionNotifyEventDetail{callback, handlerID}
	signalWidgetSelectionNotifyEventMap[signalWidgetSelectionNotifyEventId] = detail

	return signalWidgetSelectionNotifyEventId
}

/*
DisconnectSelectionNotifyEvent disconnects a callback from the 'selection-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionNotifyEvent.
*/
func (recv *Widget) DisconnectSelectionNotifyEvent(connectionID int) {
	signalWidgetSelectionNotifyEventLock.Lock()
	defer signalWidgetSelectionNotifyEventLock.Unlock()

	detail, exists := signalWidgetSelectionNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionNotifyEventMap, connectionID)
}

//export widget_selectionNotifyEventHandler
func widget_selectionNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	signalWidgetSelectionNotifyEventLock.RLock()
	defer signalWidgetSelectionNotifyEventLock.RUnlock()

	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSelectionReceivedDetail struct {
	callback  WidgetSignalSelectionReceivedCallback
	handlerID C.gulong
}

var signalWidgetSelectionReceivedId int
var signalWidgetSelectionReceivedMap = make(map[int]signalWidgetSelectionReceivedDetail)
var signalWidgetSelectionReceivedLock sync.RWMutex

// WidgetSignalSelectionReceivedCallback is a callback function for a 'selection-received' signal emitted from a Widget.
type WidgetSignalSelectionReceivedCallback func(Data *SelectionData, time uint32)

/*
ConnectSelectionReceived connects the callback to the 'selection-received' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionReceived to remove it.
*/
func (recv *Widget) ConnectSelectionReceived(callback WidgetSignalSelectionReceivedCallback) int {
	signalWidgetSelectionReceivedLock.Lock()
	defer signalWidgetSelectionReceivedLock.Unlock()

	signalWidgetSelectionReceivedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_received(instance, C.gpointer(uintptr(signalWidgetSelectionReceivedId)))

	detail := signalWidgetSelectionReceivedDetail{callback, handlerID}
	signalWidgetSelectionReceivedMap[signalWidgetSelectionReceivedId] = detail

	return signalWidgetSelectionReceivedId
}

/*
DisconnectSelectionReceived disconnects a callback from the 'selection-received' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionReceived.
*/
func (recv *Widget) DisconnectSelectionReceived(connectionID int) {
	signalWidgetSelectionReceivedLock.Lock()
	defer signalWidgetSelectionReceivedLock.Unlock()

	detail, exists := signalWidgetSelectionReceivedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionReceivedMap, connectionID)
}

//export widget_selectionReceivedHandler
func widget_selectionReceivedHandler(_ *C.GObject, c__data *C.GtkSelectionData, c_time C.guint, data C.gpointer) {
	signalWidgetSelectionReceivedLock.RLock()
	defer signalWidgetSelectionReceivedLock.RUnlock()

	Data := SelectionDataNewFromC(unsafe.Pointer(c__data))

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetSelectionReceivedMap[index].callback
	callback(Data, time)
}

type signalWidgetSelectionRequestEventDetail struct {
	callback  WidgetSignalSelectionRequestEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionRequestEventId int
var signalWidgetSelectionRequestEventMap = make(map[int]signalWidgetSelectionRequestEventDetail)
var signalWidgetSelectionRequestEventLock sync.RWMutex

// WidgetSignalSelectionRequestEventCallback is a callback function for a 'selection-request-event' signal emitted from a Widget.
type WidgetSignalSelectionRequestEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionRequestEvent connects the callback to the 'selection-request-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionRequestEvent to remove it.
*/
func (recv *Widget) ConnectSelectionRequestEvent(callback WidgetSignalSelectionRequestEventCallback) int {
	signalWidgetSelectionRequestEventLock.Lock()
	defer signalWidgetSelectionRequestEventLock.Unlock()

	signalWidgetSelectionRequestEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_request_event(instance, C.gpointer(uintptr(signalWidgetSelectionRequestEventId)))

	detail := signalWidgetSelectionRequestEventDetail{callback, handlerID}
	signalWidgetSelectionRequestEventMap[signalWidgetSelectionRequestEventId] = detail

	return signalWidgetSelectionRequestEventId
}

/*
DisconnectSelectionRequestEvent disconnects a callback from the 'selection-request-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionRequestEvent.
*/
func (recv *Widget) DisconnectSelectionRequestEvent(connectionID int) {
	signalWidgetSelectionRequestEventLock.Lock()
	defer signalWidgetSelectionRequestEventLock.Unlock()

	detail, exists := signalWidgetSelectionRequestEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionRequestEventMap, connectionID)
}

//export widget_selectionRequestEventHandler
func widget_selectionRequestEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	signalWidgetSelectionRequestEventLock.RLock()
	defer signalWidgetSelectionRequestEventLock.RUnlock()

	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionRequestEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetShowDetail struct {
	callback  WidgetSignalShowCallback
	handlerID C.gulong
}

var signalWidgetShowId int
var signalWidgetShowMap = make(map[int]signalWidgetShowDetail)
var signalWidgetShowLock sync.RWMutex

// WidgetSignalShowCallback is a callback function for a 'show' signal emitted from a Widget.
type WidgetSignalShowCallback func()

/*
ConnectShow connects the callback to the 'show' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectShow to remove it.
*/
func (recv *Widget) ConnectShow(callback WidgetSignalShowCallback) int {
	signalWidgetShowLock.Lock()
	defer signalWidgetShowLock.Unlock()

	signalWidgetShowId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_show(instance, C.gpointer(uintptr(signalWidgetShowId)))

	detail := signalWidgetShowDetail{callback, handlerID}
	signalWidgetShowMap[signalWidgetShowId] = detail

	return signalWidgetShowId
}

/*
DisconnectShow disconnects a callback from the 'show' signal for the Widget.

The connectionID should be a value returned from a call to ConnectShow.
*/
func (recv *Widget) DisconnectShow(connectionID int) {
	signalWidgetShowLock.Lock()
	defer signalWidgetShowLock.Unlock()

	detail, exists := signalWidgetShowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetShowMap, connectionID)
}

//export widget_showHandler
func widget_showHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetShowLock.RLock()
	defer signalWidgetShowLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetShowMap[index].callback
	callback()
}

type signalWidgetShowHelpDetail struct {
	callback  WidgetSignalShowHelpCallback
	handlerID C.gulong
}

var signalWidgetShowHelpId int
var signalWidgetShowHelpMap = make(map[int]signalWidgetShowHelpDetail)
var signalWidgetShowHelpLock sync.RWMutex

// WidgetSignalShowHelpCallback is a callback function for a 'show-help' signal emitted from a Widget.
type WidgetSignalShowHelpCallback func(helpType WidgetHelpType) bool

/*
ConnectShowHelp connects the callback to the 'show-help' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectShowHelp to remove it.
*/
func (recv *Widget) ConnectShowHelp(callback WidgetSignalShowHelpCallback) int {
	signalWidgetShowHelpLock.Lock()
	defer signalWidgetShowHelpLock.Unlock()

	signalWidgetShowHelpId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_show_help(instance, C.gpointer(uintptr(signalWidgetShowHelpId)))

	detail := signalWidgetShowHelpDetail{callback, handlerID}
	signalWidgetShowHelpMap[signalWidgetShowHelpId] = detail

	return signalWidgetShowHelpId
}

/*
DisconnectShowHelp disconnects a callback from the 'show-help' signal for the Widget.

The connectionID should be a value returned from a call to ConnectShowHelp.
*/
func (recv *Widget) DisconnectShowHelp(connectionID int) {
	signalWidgetShowHelpLock.Lock()
	defer signalWidgetShowHelpLock.Unlock()

	detail, exists := signalWidgetShowHelpMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetShowHelpMap, connectionID)
}

//export widget_showHelpHandler
func widget_showHelpHandler(_ *C.GObject, c_help_type C.GtkWidgetHelpType, data C.gpointer) C.gboolean {
	signalWidgetShowHelpLock.RLock()
	defer signalWidgetShowHelpLock.RUnlock()

	helpType := WidgetHelpType(c_help_type)

	index := int(uintptr(data))
	callback := signalWidgetShowHelpMap[index].callback
	retGo := callback(helpType)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSizeAllocateDetail struct {
	callback  WidgetSignalSizeAllocateCallback
	handlerID C.gulong
}

var signalWidgetSizeAllocateId int
var signalWidgetSizeAllocateMap = make(map[int]signalWidgetSizeAllocateDetail)
var signalWidgetSizeAllocateLock sync.RWMutex

// WidgetSignalSizeAllocateCallback is a callback function for a 'size-allocate' signal emitted from a Widget.
type WidgetSignalSizeAllocateCallback func(allocation *gdk.Rectangle)

/*
ConnectSizeAllocate connects the callback to the 'size-allocate' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSizeAllocate to remove it.
*/
func (recv *Widget) ConnectSizeAllocate(callback WidgetSignalSizeAllocateCallback) int {
	signalWidgetSizeAllocateLock.Lock()
	defer signalWidgetSizeAllocateLock.Unlock()

	signalWidgetSizeAllocateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_size_allocate(instance, C.gpointer(uintptr(signalWidgetSizeAllocateId)))

	detail := signalWidgetSizeAllocateDetail{callback, handlerID}
	signalWidgetSizeAllocateMap[signalWidgetSizeAllocateId] = detail

	return signalWidgetSizeAllocateId
}

/*
DisconnectSizeAllocate disconnects a callback from the 'size-allocate' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSizeAllocate.
*/
func (recv *Widget) DisconnectSizeAllocate(connectionID int) {
	signalWidgetSizeAllocateLock.Lock()
	defer signalWidgetSizeAllocateLock.Unlock()

	detail, exists := signalWidgetSizeAllocateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSizeAllocateMap, connectionID)
}

//export widget_sizeAllocateHandler
func widget_sizeAllocateHandler(_ *C.GObject, c_allocation *C.GdkRectangle, data C.gpointer) {
	signalWidgetSizeAllocateLock.RLock()
	defer signalWidgetSizeAllocateLock.RUnlock()

	allocation := gdk.RectangleNewFromC(unsafe.Pointer(c_allocation))

	index := int(uintptr(data))
	callback := signalWidgetSizeAllocateMap[index].callback
	callback(allocation)
}

type signalWidgetStateChangedDetail struct {
	callback  WidgetSignalStateChangedCallback
	handlerID C.gulong
}

var signalWidgetStateChangedId int
var signalWidgetStateChangedMap = make(map[int]signalWidgetStateChangedDetail)
var signalWidgetStateChangedLock sync.RWMutex

// WidgetSignalStateChangedCallback is a callback function for a 'state-changed' signal emitted from a Widget.
type WidgetSignalStateChangedCallback func(state StateType)

/*
ConnectStateChanged connects the callback to the 'state-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectStateChanged to remove it.
*/
func (recv *Widget) ConnectStateChanged(callback WidgetSignalStateChangedCallback) int {
	signalWidgetStateChangedLock.Lock()
	defer signalWidgetStateChangedLock.Unlock()

	signalWidgetStateChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_state_changed(instance, C.gpointer(uintptr(signalWidgetStateChangedId)))

	detail := signalWidgetStateChangedDetail{callback, handlerID}
	signalWidgetStateChangedMap[signalWidgetStateChangedId] = detail

	return signalWidgetStateChangedId
}

/*
DisconnectStateChanged disconnects a callback from the 'state-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectStateChanged.
*/
func (recv *Widget) DisconnectStateChanged(connectionID int) {
	signalWidgetStateChangedLock.Lock()
	defer signalWidgetStateChangedLock.Unlock()

	detail, exists := signalWidgetStateChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetStateChangedMap, connectionID)
}

//export widget_stateChangedHandler
func widget_stateChangedHandler(_ *C.GObject, c_state C.GtkStateType, data C.gpointer) {
	signalWidgetStateChangedLock.RLock()
	defer signalWidgetStateChangedLock.RUnlock()

	state := StateType(c_state)

	index := int(uintptr(data))
	callback := signalWidgetStateChangedMap[index].callback
	callback(state)
}

type signalWidgetStyleSetDetail struct {
	callback  WidgetSignalStyleSetCallback
	handlerID C.gulong
}

var signalWidgetStyleSetId int
var signalWidgetStyleSetMap = make(map[int]signalWidgetStyleSetDetail)
var signalWidgetStyleSetLock sync.RWMutex

// WidgetSignalStyleSetCallback is a callback function for a 'style-set' signal emitted from a Widget.
type WidgetSignalStyleSetCallback func(previousStyle *Style)

/*
ConnectStyleSet connects the callback to the 'style-set' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectStyleSet to remove it.
*/
func (recv *Widget) ConnectStyleSet(callback WidgetSignalStyleSetCallback) int {
	signalWidgetStyleSetLock.Lock()
	defer signalWidgetStyleSetLock.Unlock()

	signalWidgetStyleSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_style_set(instance, C.gpointer(uintptr(signalWidgetStyleSetId)))

	detail := signalWidgetStyleSetDetail{callback, handlerID}
	signalWidgetStyleSetMap[signalWidgetStyleSetId] = detail

	return signalWidgetStyleSetId
}

/*
DisconnectStyleSet disconnects a callback from the 'style-set' signal for the Widget.

The connectionID should be a value returned from a call to ConnectStyleSet.
*/
func (recv *Widget) DisconnectStyleSet(connectionID int) {
	signalWidgetStyleSetLock.Lock()
	defer signalWidgetStyleSetLock.Unlock()

	detail, exists := signalWidgetStyleSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetStyleSetMap, connectionID)
}

//export widget_styleSetHandler
func widget_styleSetHandler(_ *C.GObject, c_previous_style *C.GtkStyle, data C.gpointer) {
	signalWidgetStyleSetLock.RLock()
	defer signalWidgetStyleSetLock.RUnlock()

	previousStyle := StyleNewFromC(unsafe.Pointer(c_previous_style))

	index := int(uintptr(data))
	callback := signalWidgetStyleSetMap[index].callback
	callback(previousStyle)
}

// Unsupported signal 'touch-event' for Widget : unsupported parameter object : no type generator for Gdk.Event,

type signalWidgetUnmapDetail struct {
	callback  WidgetSignalUnmapCallback
	handlerID C.gulong
}

var signalWidgetUnmapId int
var signalWidgetUnmapMap = make(map[int]signalWidgetUnmapDetail)
var signalWidgetUnmapLock sync.RWMutex

// WidgetSignalUnmapCallback is a callback function for a 'unmap' signal emitted from a Widget.
type WidgetSignalUnmapCallback func()

/*
ConnectUnmap connects the callback to the 'unmap' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnmap to remove it.
*/
func (recv *Widget) ConnectUnmap(callback WidgetSignalUnmapCallback) int {
	signalWidgetUnmapLock.Lock()
	defer signalWidgetUnmapLock.Unlock()

	signalWidgetUnmapId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unmap(instance, C.gpointer(uintptr(signalWidgetUnmapId)))

	detail := signalWidgetUnmapDetail{callback, handlerID}
	signalWidgetUnmapMap[signalWidgetUnmapId] = detail

	return signalWidgetUnmapId
}

/*
DisconnectUnmap disconnects a callback from the 'unmap' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnmap.
*/
func (recv *Widget) DisconnectUnmap(connectionID int) {
	signalWidgetUnmapLock.Lock()
	defer signalWidgetUnmapLock.Unlock()

	detail, exists := signalWidgetUnmapMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnmapMap, connectionID)
}

//export widget_unmapHandler
func widget_unmapHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetUnmapLock.RLock()
	defer signalWidgetUnmapLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetUnmapMap[index].callback
	callback()
}

type signalWidgetUnmapEventDetail struct {
	callback  WidgetSignalUnmapEventCallback
	handlerID C.gulong
}

var signalWidgetUnmapEventId int
var signalWidgetUnmapEventMap = make(map[int]signalWidgetUnmapEventDetail)
var signalWidgetUnmapEventLock sync.RWMutex

// WidgetSignalUnmapEventCallback is a callback function for a 'unmap-event' signal emitted from a Widget.
type WidgetSignalUnmapEventCallback func(event *gdk.EventAny) bool

/*
ConnectUnmapEvent connects the callback to the 'unmap-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnmapEvent to remove it.
*/
func (recv *Widget) ConnectUnmapEvent(callback WidgetSignalUnmapEventCallback) int {
	signalWidgetUnmapEventLock.Lock()
	defer signalWidgetUnmapEventLock.Unlock()

	signalWidgetUnmapEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unmap_event(instance, C.gpointer(uintptr(signalWidgetUnmapEventId)))

	detail := signalWidgetUnmapEventDetail{callback, handlerID}
	signalWidgetUnmapEventMap[signalWidgetUnmapEventId] = detail

	return signalWidgetUnmapEventId
}

/*
DisconnectUnmapEvent disconnects a callback from the 'unmap-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnmapEvent.
*/
func (recv *Widget) DisconnectUnmapEvent(connectionID int) {
	signalWidgetUnmapEventLock.Lock()
	defer signalWidgetUnmapEventLock.Unlock()

	detail, exists := signalWidgetUnmapEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnmapEventMap, connectionID)
}

//export widget_unmapEventHandler
func widget_unmapEventHandler(_ *C.GObject, c_event *C.GdkEventAny, data C.gpointer) C.gboolean {
	signalWidgetUnmapEventLock.RLock()
	defer signalWidgetUnmapEventLock.RUnlock()

	event := gdk.EventAnyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetUnmapEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetUnrealizeDetail struct {
	callback  WidgetSignalUnrealizeCallback
	handlerID C.gulong
}

var signalWidgetUnrealizeId int
var signalWidgetUnrealizeMap = make(map[int]signalWidgetUnrealizeDetail)
var signalWidgetUnrealizeLock sync.RWMutex

// WidgetSignalUnrealizeCallback is a callback function for a 'unrealize' signal emitted from a Widget.
type WidgetSignalUnrealizeCallback func()

/*
ConnectUnrealize connects the callback to the 'unrealize' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnrealize to remove it.
*/
func (recv *Widget) ConnectUnrealize(callback WidgetSignalUnrealizeCallback) int {
	signalWidgetUnrealizeLock.Lock()
	defer signalWidgetUnrealizeLock.Unlock()

	signalWidgetUnrealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unrealize(instance, C.gpointer(uintptr(signalWidgetUnrealizeId)))

	detail := signalWidgetUnrealizeDetail{callback, handlerID}
	signalWidgetUnrealizeMap[signalWidgetUnrealizeId] = detail

	return signalWidgetUnrealizeId
}

/*
DisconnectUnrealize disconnects a callback from the 'unrealize' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnrealize.
*/
func (recv *Widget) DisconnectUnrealize(connectionID int) {
	signalWidgetUnrealizeLock.Lock()
	defer signalWidgetUnrealizeLock.Unlock()

	detail, exists := signalWidgetUnrealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnrealizeMap, connectionID)
}

//export widget_unrealizeHandler
func widget_unrealizeHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetUnrealizeLock.RLock()
	defer signalWidgetUnrealizeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetUnrealizeMap[index].callback
	callback()
}

type signalWidgetVisibilityNotifyEventDetail struct {
	callback  WidgetSignalVisibilityNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetVisibilityNotifyEventId int
var signalWidgetVisibilityNotifyEventMap = make(map[int]signalWidgetVisibilityNotifyEventDetail)
var signalWidgetVisibilityNotifyEventLock sync.RWMutex

// WidgetSignalVisibilityNotifyEventCallback is a callback function for a 'visibility-notify-event' signal emitted from a Widget.
type WidgetSignalVisibilityNotifyEventCallback func(event *gdk.EventVisibility) bool

/*
ConnectVisibilityNotifyEvent connects the callback to the 'visibility-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectVisibilityNotifyEvent to remove it.
*/
func (recv *Widget) ConnectVisibilityNotifyEvent(callback WidgetSignalVisibilityNotifyEventCallback) int {
	signalWidgetVisibilityNotifyEventLock.Lock()
	defer signalWidgetVisibilityNotifyEventLock.Unlock()

	signalWidgetVisibilityNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_visibility_notify_event(instance, C.gpointer(uintptr(signalWidgetVisibilityNotifyEventId)))

	detail := signalWidgetVisibilityNotifyEventDetail{callback, handlerID}
	signalWidgetVisibilityNotifyEventMap[signalWidgetVisibilityNotifyEventId] = detail

	return signalWidgetVisibilityNotifyEventId
}

/*
DisconnectVisibilityNotifyEvent disconnects a callback from the 'visibility-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectVisibilityNotifyEvent.
*/
func (recv *Widget) DisconnectVisibilityNotifyEvent(connectionID int) {
	signalWidgetVisibilityNotifyEventLock.Lock()
	defer signalWidgetVisibilityNotifyEventLock.Unlock()

	detail, exists := signalWidgetVisibilityNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetVisibilityNotifyEventMap, connectionID)
}

//export widget_visibilityNotifyEventHandler
func widget_visibilityNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventVisibility, data C.gpointer) C.gboolean {
	signalWidgetVisibilityNotifyEventLock.RLock()
	defer signalWidgetVisibilityNotifyEventLock.RUnlock()

	event := gdk.EventVisibilityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetVisibilityNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetWindowStateEventDetail struct {
	callback  WidgetSignalWindowStateEventCallback
	handlerID C.gulong
}

var signalWidgetWindowStateEventId int
var signalWidgetWindowStateEventMap = make(map[int]signalWidgetWindowStateEventDetail)
var signalWidgetWindowStateEventLock sync.RWMutex

// WidgetSignalWindowStateEventCallback is a callback function for a 'window-state-event' signal emitted from a Widget.
type WidgetSignalWindowStateEventCallback func(event *gdk.EventWindowState) bool

/*
ConnectWindowStateEvent connects the callback to the 'window-state-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectWindowStateEvent to remove it.
*/
func (recv *Widget) ConnectWindowStateEvent(callback WidgetSignalWindowStateEventCallback) int {
	signalWidgetWindowStateEventLock.Lock()
	defer signalWidgetWindowStateEventLock.Unlock()

	signalWidgetWindowStateEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_window_state_event(instance, C.gpointer(uintptr(signalWidgetWindowStateEventId)))

	detail := signalWidgetWindowStateEventDetail{callback, handlerID}
	signalWidgetWindowStateEventMap[signalWidgetWindowStateEventId] = detail

	return signalWidgetWindowStateEventId
}

/*
DisconnectWindowStateEvent disconnects a callback from the 'window-state-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectWindowStateEvent.
*/
func (recv *Widget) DisconnectWindowStateEvent(connectionID int) {
	signalWidgetWindowStateEventLock.Lock()
	defer signalWidgetWindowStateEventLock.Unlock()

	detail, exists := signalWidgetWindowStateEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetWindowStateEventMap, connectionID)
}

//export widget_windowStateEventHandler
func widget_windowStateEventHandler(_ *C.GObject, c_event *C.GdkEventWindowState, data C.gpointer) C.gboolean {
	signalWidgetWindowStateEventLock.RLock()
	defer signalWidgetWindowStateEventLock.RUnlock()

	event := gdk.EventWindowStateNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetWindowStateEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported : gtk_widget_new : unsupported parameter ... : varargs

// Blacklisted : gtk_widget_get_default_direction

// Blacklisted : gtk_widget_get_default_style

// Blacklisted : gtk_widget_pop_composite_child

// Blacklisted : gtk_widget_push_composite_child

// Blacklisted : gtk_widget_set_default_direction

// Blacklisted : gtk_widget_activate

// Blacklisted : gtk_widget_add_accelerator

// Blacklisted : gtk_widget_add_events

// Blacklisted : gtk_widget_child_focus

// Blacklisted : gtk_widget_child_notify

// Blacklisted : gtk_widget_class_path

// Blacklisted : gtk_widget_compute_expand

// Blacklisted : gtk_widget_create_pango_context

// Blacklisted : gtk_widget_create_pango_layout

// Destroy is a wrapper around the C function gtk_widget_destroy.
func (recv *Widget) Destroy() {
	C.gtk_widget_destroy((*C.GtkWidget)(recv.native))

	return
}

// Blacklisted : gtk_widget_destroyed

// Unsupported : gtk_drag_begin : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Blacklisted : gtk_drag_check_threshold

// Blacklisted : gtk_drag_dest_find_target

// Blacklisted : gtk_drag_dest_get_target_list

// Unsupported : gtk_drag_dest_set : unsupported parameter targets :

// Blacklisted : gtk_drag_dest_set_proxy

// Blacklisted : gtk_drag_dest_set_target_list

// Blacklisted : gtk_drag_dest_unset

// Blacklisted : gtk_drag_get_data

// Blacklisted : gtk_drag_highlight

// Unsupported : gtk_drag_source_set : unsupported parameter targets :

// Blacklisted : gtk_drag_source_set_icon_pixbuf

// Blacklisted : gtk_drag_source_set_icon_stock

// Blacklisted : gtk_drag_source_unset

// Blacklisted : gtk_drag_unhighlight

// Blacklisted : gtk_widget_ensure_style

// Unsupported : gtk_widget_event : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Blacklisted : gtk_widget_freeze_child_notify

// Blacklisted : gtk_widget_get_accessible

// Blacklisted : gtk_widget_get_allocated_height

// Blacklisted : gtk_widget_get_allocated_width

// Blacklisted : gtk_widget_get_ancestor

// Blacklisted : gtk_widget_get_child_requisition

// Blacklisted : gtk_widget_get_child_visible

// Blacklisted : gtk_widget_get_composite_name

// Blacklisted : gtk_widget_get_direction

// Blacklisted : gtk_widget_get_events

// Blacklisted : gtk_widget_get_halign

// Blacklisted : gtk_widget_get_hexpand

// Blacklisted : gtk_widget_get_hexpand_set

// Blacklisted : gtk_widget_get_modifier_style

// Blacklisted : gtk_widget_get_name

// Blacklisted : gtk_widget_get_pango_context

// Blacklisted : gtk_widget_get_parent

// Blacklisted : gtk_widget_get_parent_window

// Blacklisted : gtk_widget_get_path

// Blacklisted : gtk_widget_get_pointer

// Blacklisted : gtk_widget_get_settings

// Blacklisted : gtk_widget_get_size_request

// Blacklisted : gtk_widget_get_style

// Blacklisted : gtk_widget_get_style_context

// Blacklisted : gtk_widget_get_support_multidevice

// Blacklisted : gtk_widget_get_template_child

// Blacklisted : gtk_widget_get_toplevel

// Blacklisted : gtk_widget_get_valign

// Blacklisted : gtk_widget_get_vexpand

// Blacklisted : gtk_widget_get_vexpand_set

// Blacklisted : gtk_widget_get_visual

// Blacklisted : gtk_grab_add

// Blacklisted : gtk_widget_grab_default

// Blacklisted : gtk_widget_grab_focus

// Blacklisted : gtk_grab_remove

// Blacklisted : gtk_widget_hide

// Blacklisted : gtk_widget_hide_on_delete

// Blacklisted : gtk_widget_in_destruction

// Blacklisted : gtk_widget_intersect

// Blacklisted : gtk_widget_is_ancestor

// Blacklisted : gtk_widget_is_focus

// Blacklisted : gtk_widget_list_accel_closures

// Blacklisted : gtk_widget_map

// Blacklisted : gtk_widget_mnemonic_activate

// Blacklisted : gtk_widget_modify_base

// Blacklisted : gtk_widget_modify_bg

// Blacklisted : gtk_widget_modify_fg

// Blacklisted : gtk_widget_modify_font

// Blacklisted : gtk_widget_modify_style

// Blacklisted : gtk_widget_modify_text

// Blacklisted : gtk_widget_path

// Blacklisted : gtk_widget_queue_compute_expand

// Blacklisted : gtk_widget_queue_draw

// Blacklisted : gtk_widget_queue_draw_area

// Blacklisted : gtk_widget_queue_resize

// Blacklisted : gtk_widget_realize

// Blacklisted : gtk_widget_region_intersect

// Blacklisted : gtk_widget_remove_accelerator

// Blacklisted : gtk_widget_render_icon

// Blacklisted : gtk_widget_reparent

// Blacklisted : gtk_widget_reset_rc_styles

// Unsupported : gtk_widget_send_expose : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Blacklisted : gtk_widget_set_accel_path

// Blacklisted : gtk_widget_set_app_paintable

// Blacklisted : gtk_widget_set_child_visible

// Blacklisted : gtk_widget_set_composite_name

// Blacklisted : gtk_widget_set_direction

// Blacklisted : gtk_widget_set_double_buffered

// Blacklisted : gtk_widget_set_events

// Blacklisted : gtk_widget_set_halign

// Blacklisted : gtk_widget_set_hexpand

// Blacklisted : gtk_widget_set_hexpand_set

// Blacklisted : gtk_widget_set_name

// Blacklisted : gtk_widget_set_parent

// Blacklisted : gtk_widget_set_parent_window

// Blacklisted : gtk_widget_set_redraw_on_allocate

// Blacklisted : gtk_widget_set_sensitive

// Blacklisted : gtk_widget_set_size_request

// Blacklisted : gtk_widget_set_state

// Blacklisted : gtk_widget_set_style

// Blacklisted : gtk_widget_set_valign

// Blacklisted : gtk_widget_set_vexpand

// Blacklisted : gtk_widget_set_vexpand_set

// Blacklisted : gtk_widget_set_visual

// Blacklisted : gtk_widget_show

// ShowAll is a wrapper around the C function gtk_widget_show_all.
func (recv *Widget) ShowAll() {
	C.gtk_widget_show_all((*C.GtkWidget)(recv.native))

	return
}

// Blacklisted : gtk_widget_show_now

// Blacklisted : gtk_widget_size_allocate

// Blacklisted : gtk_widget_size_request

// Unsupported : gtk_widget_style_get : unsupported parameter ... : varargs

// Blacklisted : gtk_widget_style_get_property

// Unsupported : gtk_widget_style_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Blacklisted : gtk_widget_thaw_child_notify

// Blacklisted : gtk_widget_translate_coordinates

// Blacklisted : gtk_widget_unmap

// Blacklisted : gtk_widget_unparent

// Blacklisted : gtk_widget_unrealize

// ImplementorIface returns the ImplementorIface interface implemented by Widget
func (recv *Widget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Widget
func (recv *Widget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// WidgetAccessible is a wrapper around the C record GtkWidgetAccessible.
type WidgetAccessible struct {
	native *C.GtkWidgetAccessible
	// parent : record
	// priv : record
}

func WidgetAccessibleNewFromC(u unsafe.Pointer) *WidgetAccessible {
	c := (*C.GtkWidgetAccessible)(u)
	if c == nil {
		return nil
	}

	g := &WidgetAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *WidgetAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *WidgetAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WidgetAccessible with another WidgetAccessible, and returns true if they represent the same GObject.
func (recv *WidgetAccessible) Equals(other *WidgetAccessible) bool {
	return other.ToC() == recv.ToC()
}

// Accessible upcasts to *Accessible
func (recv *WidgetAccessible) Accessible() *Accessible {
	return AccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *WidgetAccessible) Object() *atk.Object {
	return recv.Accessible().Object()
}

// CastToWidget down casts any arbitrary Object to WidgetAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a WidgetAccessible.
func CastToWidgetAccessible(object *gobject.Object) *WidgetAccessible {
	return WidgetAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by WidgetAccessible
func (recv *WidgetAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Window is a wrapper around the C record GtkWindow.
type Window struct {
	native *C.GtkWindow
	// bin : record
	// priv : record
}

func WindowNewFromC(u unsafe.Pointer) *Window {
	c := (*C.GtkWindow)(u)
	if c == nil {
		return nil
	}

	g := &Window{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Window) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Window) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Window with another Window, and returns true if they represent the same GObject.
func (recv *Window) Equals(other *Window) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Window) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Window) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Window) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Window) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Window) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Window.
// Exercise care, as this is a potentially dangerous function if the Object is not a Window.
func CastToWindow(object *gobject.Object) *Window {
	return WindowNewFromC(object.ToC())
}

type signalWindowActivateDefaultDetail struct {
	callback  WindowSignalActivateDefaultCallback
	handlerID C.gulong
}

var signalWindowActivateDefaultId int
var signalWindowActivateDefaultMap = make(map[int]signalWindowActivateDefaultDetail)
var signalWindowActivateDefaultLock sync.RWMutex

// WindowSignalActivateDefaultCallback is a callback function for a 'activate-default' signal emitted from a Window.
type WindowSignalActivateDefaultCallback func()

/*
ConnectActivateDefault connects the callback to the 'activate-default' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectActivateDefault to remove it.
*/
func (recv *Window) ConnectActivateDefault(callback WindowSignalActivateDefaultCallback) int {
	signalWindowActivateDefaultLock.Lock()
	defer signalWindowActivateDefaultLock.Unlock()

	signalWindowActivateDefaultId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_activate_default(instance, C.gpointer(uintptr(signalWindowActivateDefaultId)))

	detail := signalWindowActivateDefaultDetail{callback, handlerID}
	signalWindowActivateDefaultMap[signalWindowActivateDefaultId] = detail

	return signalWindowActivateDefaultId
}

/*
DisconnectActivateDefault disconnects a callback from the 'activate-default' signal for the Window.

The connectionID should be a value returned from a call to ConnectActivateDefault.
*/
func (recv *Window) DisconnectActivateDefault(connectionID int) {
	signalWindowActivateDefaultLock.Lock()
	defer signalWindowActivateDefaultLock.Unlock()

	detail, exists := signalWindowActivateDefaultMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowActivateDefaultMap, connectionID)
}

//export window_activateDefaultHandler
func window_activateDefaultHandler(_ *C.GObject, data C.gpointer) {
	signalWindowActivateDefaultLock.RLock()
	defer signalWindowActivateDefaultLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWindowActivateDefaultMap[index].callback
	callback()
}

type signalWindowActivateFocusDetail struct {
	callback  WindowSignalActivateFocusCallback
	handlerID C.gulong
}

var signalWindowActivateFocusId int
var signalWindowActivateFocusMap = make(map[int]signalWindowActivateFocusDetail)
var signalWindowActivateFocusLock sync.RWMutex

// WindowSignalActivateFocusCallback is a callback function for a 'activate-focus' signal emitted from a Window.
type WindowSignalActivateFocusCallback func()

/*
ConnectActivateFocus connects the callback to the 'activate-focus' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectActivateFocus to remove it.
*/
func (recv *Window) ConnectActivateFocus(callback WindowSignalActivateFocusCallback) int {
	signalWindowActivateFocusLock.Lock()
	defer signalWindowActivateFocusLock.Unlock()

	signalWindowActivateFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_activate_focus(instance, C.gpointer(uintptr(signalWindowActivateFocusId)))

	detail := signalWindowActivateFocusDetail{callback, handlerID}
	signalWindowActivateFocusMap[signalWindowActivateFocusId] = detail

	return signalWindowActivateFocusId
}

/*
DisconnectActivateFocus disconnects a callback from the 'activate-focus' signal for the Window.

The connectionID should be a value returned from a call to ConnectActivateFocus.
*/
func (recv *Window) DisconnectActivateFocus(connectionID int) {
	signalWindowActivateFocusLock.Lock()
	defer signalWindowActivateFocusLock.Unlock()

	detail, exists := signalWindowActivateFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowActivateFocusMap, connectionID)
}

//export window_activateFocusHandler
func window_activateFocusHandler(_ *C.GObject, data C.gpointer) {
	signalWindowActivateFocusLock.RLock()
	defer signalWindowActivateFocusLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWindowActivateFocusMap[index].callback
	callback()
}

type signalWindowEnableDebuggingDetail struct {
	callback  WindowSignalEnableDebuggingCallback
	handlerID C.gulong
}

var signalWindowEnableDebuggingId int
var signalWindowEnableDebuggingMap = make(map[int]signalWindowEnableDebuggingDetail)
var signalWindowEnableDebuggingLock sync.RWMutex

// WindowSignalEnableDebuggingCallback is a callback function for a 'enable-debugging' signal emitted from a Window.
type WindowSignalEnableDebuggingCallback func(toggle bool) bool

/*
ConnectEnableDebugging connects the callback to the 'enable-debugging' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectEnableDebugging to remove it.
*/
func (recv *Window) ConnectEnableDebugging(callback WindowSignalEnableDebuggingCallback) int {
	signalWindowEnableDebuggingLock.Lock()
	defer signalWindowEnableDebuggingLock.Unlock()

	signalWindowEnableDebuggingId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_enable_debugging(instance, C.gpointer(uintptr(signalWindowEnableDebuggingId)))

	detail := signalWindowEnableDebuggingDetail{callback, handlerID}
	signalWindowEnableDebuggingMap[signalWindowEnableDebuggingId] = detail

	return signalWindowEnableDebuggingId
}

/*
DisconnectEnableDebugging disconnects a callback from the 'enable-debugging' signal for the Window.

The connectionID should be a value returned from a call to ConnectEnableDebugging.
*/
func (recv *Window) DisconnectEnableDebugging(connectionID int) {
	signalWindowEnableDebuggingLock.Lock()
	defer signalWindowEnableDebuggingLock.Unlock()

	detail, exists := signalWindowEnableDebuggingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowEnableDebuggingMap, connectionID)
}

//export window_enableDebuggingHandler
func window_enableDebuggingHandler(_ *C.GObject, c_toggle C.gboolean, data C.gpointer) C.gboolean {
	signalWindowEnableDebuggingLock.RLock()
	defer signalWindowEnableDebuggingLock.RUnlock()

	toggle := c_toggle == C.TRUE

	index := int(uintptr(data))
	callback := signalWindowEnableDebuggingMap[index].callback
	retGo := callback(toggle)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWindowKeysChangedDetail struct {
	callback  WindowSignalKeysChangedCallback
	handlerID C.gulong
}

var signalWindowKeysChangedId int
var signalWindowKeysChangedMap = make(map[int]signalWindowKeysChangedDetail)
var signalWindowKeysChangedLock sync.RWMutex

// WindowSignalKeysChangedCallback is a callback function for a 'keys-changed' signal emitted from a Window.
type WindowSignalKeysChangedCallback func()

/*
ConnectKeysChanged connects the callback to the 'keys-changed' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectKeysChanged to remove it.
*/
func (recv *Window) ConnectKeysChanged(callback WindowSignalKeysChangedCallback) int {
	signalWindowKeysChangedLock.Lock()
	defer signalWindowKeysChangedLock.Unlock()

	signalWindowKeysChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_keys_changed(instance, C.gpointer(uintptr(signalWindowKeysChangedId)))

	detail := signalWindowKeysChangedDetail{callback, handlerID}
	signalWindowKeysChangedMap[signalWindowKeysChangedId] = detail

	return signalWindowKeysChangedId
}

/*
DisconnectKeysChanged disconnects a callback from the 'keys-changed' signal for the Window.

The connectionID should be a value returned from a call to ConnectKeysChanged.
*/
func (recv *Window) DisconnectKeysChanged(connectionID int) {
	signalWindowKeysChangedLock.Lock()
	defer signalWindowKeysChangedLock.Unlock()

	detail, exists := signalWindowKeysChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowKeysChangedMap, connectionID)
}

//export window_keysChangedHandler
func window_keysChangedHandler(_ *C.GObject, data C.gpointer) {
	signalWindowKeysChangedLock.RLock()
	defer signalWindowKeysChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWindowKeysChangedMap[index].callback
	callback()
}

type signalWindowSetFocusDetail struct {
	callback  WindowSignalSetFocusCallback
	handlerID C.gulong
}

var signalWindowSetFocusId int
var signalWindowSetFocusMap = make(map[int]signalWindowSetFocusDetail)
var signalWindowSetFocusLock sync.RWMutex

// WindowSignalSetFocusCallback is a callback function for a 'set-focus' signal emitted from a Window.
type WindowSignalSetFocusCallback func(object *Widget)

/*
ConnectSetFocus connects the callback to the 'set-focus' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectSetFocus to remove it.
*/
func (recv *Window) ConnectSetFocus(callback WindowSignalSetFocusCallback) int {
	signalWindowSetFocusLock.Lock()
	defer signalWindowSetFocusLock.Unlock()

	signalWindowSetFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_set_focus(instance, C.gpointer(uintptr(signalWindowSetFocusId)))

	detail := signalWindowSetFocusDetail{callback, handlerID}
	signalWindowSetFocusMap[signalWindowSetFocusId] = detail

	return signalWindowSetFocusId
}

/*
DisconnectSetFocus disconnects a callback from the 'set-focus' signal for the Window.

The connectionID should be a value returned from a call to ConnectSetFocus.
*/
func (recv *Window) DisconnectSetFocus(connectionID int) {
	signalWindowSetFocusLock.Lock()
	defer signalWindowSetFocusLock.Unlock()

	detail, exists := signalWindowSetFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowSetFocusMap, connectionID)
}

//export window_setFocusHandler
func window_setFocusHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	signalWindowSetFocusLock.RLock()
	defer signalWindowSetFocusLock.RUnlock()

	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalWindowSetFocusMap[index].callback
	callback(object)
}

// WindowNew is a wrapper around the C function gtk_window_new.
func WindowNew(type_ WindowType) *Window {
	c_type := (C.GtkWindowType)(type_)

	retC := C.gtk_window_new(c_type)
	retGo := WindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Blacklisted : gtk_window_get_default_icon_list

// Blacklisted : gtk_window_list_toplevels

// Blacklisted : gtk_window_set_default_icon_list

// Blacklisted : gtk_window_activate_default

// Blacklisted : gtk_window_activate_focus

// Blacklisted : gtk_window_add_accel_group

// Blacklisted : gtk_window_add_mnemonic

// Blacklisted : gtk_window_begin_move_drag

// Blacklisted : gtk_window_begin_resize_drag

// Blacklisted : gtk_window_deiconify

// Blacklisted : gtk_window_get_decorated

// Blacklisted : gtk_window_get_default_size

// Blacklisted : gtk_window_get_destroy_with_parent

// Blacklisted : gtk_window_get_focus

// Blacklisted : gtk_window_get_gravity

// Blacklisted : gtk_window_get_icon

// Blacklisted : gtk_window_get_icon_list

// Blacklisted : gtk_window_get_mnemonic_modifier

// Blacklisted : gtk_window_get_modal

// Blacklisted : gtk_window_get_position

// Blacklisted : gtk_window_get_resizable

// Blacklisted : gtk_window_get_role

// Blacklisted : gtk_window_get_size

// GetTitle is a wrapper around the C function gtk_window_get_title.
func (recv *Window) GetTitle() string {
	retC := C.gtk_window_get_title((*C.GtkWindow)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Blacklisted : gtk_window_get_transient_for

// Blacklisted : gtk_window_get_type_hint

// Blacklisted : gtk_window_has_group

// Blacklisted : gtk_window_iconify

// Blacklisted : gtk_window_maximize

// Blacklisted : gtk_window_mnemonic_activate

// Blacklisted : gtk_window_move

// Blacklisted : gtk_window_parse_geometry

// Blacklisted : gtk_window_present

// Blacklisted : gtk_window_remove_accel_group

// Blacklisted : gtk_window_remove_mnemonic

// Blacklisted : gtk_window_reshow_with_initial_size

// Blacklisted : gtk_window_resize

// Blacklisted : gtk_window_set_decorated

// Blacklisted : gtk_window_set_default

// Blacklisted : gtk_window_set_default_size

// Blacklisted : gtk_window_set_destroy_with_parent

// Blacklisted : gtk_window_set_focus

// Blacklisted : gtk_window_set_geometry_hints

// Blacklisted : gtk_window_set_gravity

// Blacklisted : gtk_window_set_icon

// Blacklisted : gtk_window_set_icon_list

// Blacklisted : gtk_window_set_mnemonic_modifier

// Blacklisted : gtk_window_set_modal

// Blacklisted : gtk_window_set_position

// Blacklisted : gtk_window_set_resizable

// Blacklisted : gtk_window_set_role

// SetTitle is a wrapper around the C function gtk_window_set_title.
func (recv *Window) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_window_set_title((*C.GtkWindow)(recv.native), c_title)

	return
}

// Blacklisted : gtk_window_set_transient_for

// Blacklisted : gtk_window_set_type_hint

// Blacklisted : gtk_window_set_wmclass

// Blacklisted : gtk_window_stick

// Blacklisted : gtk_window_unmaximize

// Blacklisted : gtk_window_unstick

// ImplementorIface returns the ImplementorIface interface implemented by Window
func (recv *Window) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Window
func (recv *Window) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// WindowAccessible is a wrapper around the C record GtkWindowAccessible.
type WindowAccessible struct {
	native *C.GtkWindowAccessible
	// parent : record
	// priv : record
}

func WindowAccessibleNewFromC(u unsafe.Pointer) *WindowAccessible {
	c := (*C.GtkWindowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &WindowAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *WindowAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *WindowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowAccessible with another WindowAccessible, and returns true if they represent the same GObject.
func (recv *WindowAccessible) Equals(other *WindowAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *WindowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *WindowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *WindowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *WindowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to WindowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a WindowAccessible.
func CastToWindowAccessible(object *gobject.Object) *WindowAccessible {
	return WindowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by WindowAccessible
func (recv *WindowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Window returns the Window interface implemented by WindowAccessible
func (recv *WindowAccessible) Window() *atk.Window {
	return atk.WindowNewFromC(recv.ToC())
}

// WindowGroup is a wrapper around the C record GtkWindowGroup.
type WindowGroup struct {
	native *C.GtkWindowGroup
	// parent_instance : record
	// priv : record
}

func WindowGroupNewFromC(u unsafe.Pointer) *WindowGroup {
	c := (*C.GtkWindowGroup)(u)
	if c == nil {
		return nil
	}

	g := &WindowGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *WindowGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *WindowGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowGroup with another WindowGroup, and returns true if they represent the same GObject.
func (recv *WindowGroup) Equals(other *WindowGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *WindowGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to WindowGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a WindowGroup.
func CastToWindowGroup(object *gobject.Object) *WindowGroup {
	return WindowGroupNewFromC(object.ToC())
}

// Blacklisted : gtk_window_group_new

// Blacklisted : gtk_window_group_add_window

// Blacklisted : gtk_window_group_remove_window
