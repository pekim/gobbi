// This is a generated file - DO NOT EDIT

package gtk

import (
	atk "github.com/pekim/gobbi/lib/atk"
	cairo "github.com/pekim/gobbi/lib/cairo"
	gdk "github.com/pekim/gobbi/lib/gdk"
	gdkpixbuf "github.com/pekim/gobbi/lib/gdkpixbuf"
	gio "github.com/pekim/gobbi/lib/gio"
	glib "github.com/pekim/gobbi/lib/glib"
	gobject "github.com/pekim/gobbi/lib/gobject"
	pango "github.com/pekim/gobbi/lib/pango"
	"sync"
	"unsafe"
)

// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// #include <stdlib.h>
/*

	void adjustment_changedHandler(GObject *, gpointer);

	static gulong Adjustment_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(adjustment_changedHandler), data);
	}

*/
/*

	void adjustment_valueChangedHandler(GObject *, gpointer);

	static gulong Adjustment_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(adjustment_valueChangedHandler), data);
	}

*/
/*

	void appchooserwidget_applicationActivatedHandler(GObject *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_application_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "application-activated", G_CALLBACK(appchooserwidget_applicationActivatedHandler), data);
	}

*/
/*

	void appchooserwidget_applicationSelectedHandler(GObject *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_application_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "application-selected", G_CALLBACK(appchooserwidget_applicationSelectedHandler), data);
	}

*/
/*

	void appchooserwidget_populatePopupHandler(GObject *, GtkMenu *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(appchooserwidget_populatePopupHandler), data);
	}

*/
/*

	void assistant_escapeHandler(GObject *, gpointer);

	static gulong Assistant_signal_connect_escape(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "escape", G_CALLBACK(assistant_escapeHandler), data);
	}

*/
/*

	void button_activateHandler(GObject *, gpointer);

	static gulong Button_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(button_activateHandler), data);
	}

*/
/*

	void button_clickedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(button_clickedHandler), data);
	}

*/
/*

	void button_enterHandler(GObject *, gpointer);

	static gulong Button_signal_connect_enter(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enter", G_CALLBACK(button_enterHandler), data);
	}

*/
/*

	void button_leaveHandler(GObject *, gpointer);

	static gulong Button_signal_connect_leave(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "leave", G_CALLBACK(button_leaveHandler), data);
	}

*/
/*

	void button_pressedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_pressed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "pressed", G_CALLBACK(button_pressedHandler), data);
	}

*/
/*

	void button_releasedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_released(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "released", G_CALLBACK(button_releasedHandler), data);
	}

*/
/*

	void calendar_daySelectedHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_day_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "day-selected", G_CALLBACK(calendar_daySelectedHandler), data);
	}

*/
/*

	void calendar_daySelectedDoubleClickHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_day_selected_double_click(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "day-selected-double-click", G_CALLBACK(calendar_daySelectedDoubleClickHandler), data);
	}

*/
/*

	void calendar_monthChangedHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_month_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "month-changed", G_CALLBACK(calendar_monthChangedHandler), data);
	}

*/
/*

	void calendar_nextMonthHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_next_month(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "next-month", G_CALLBACK(calendar_nextMonthHandler), data);
	}

*/
/*

	void calendar_nextYearHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_next_year(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "next-year", G_CALLBACK(calendar_nextYearHandler), data);
	}

*/
/*

	void calendar_prevMonthHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_prev_month(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prev-month", G_CALLBACK(calendar_prevMonthHandler), data);
	}

*/
/*

	void calendar_prevYearHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_prev_year(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prev-year", G_CALLBACK(calendar_prevYearHandler), data);
	}

*/
/*

	void checkmenuitem_toggledHandler(GObject *, gpointer);

	static gulong CheckMenuItem_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(checkmenuitem_toggledHandler), data);
	}

*/
/*

	void colorselection_colorChangedHandler(GObject *, gpointer);

	static gulong ColorSelection_signal_connect_color_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "color-changed", G_CALLBACK(colorselection_colorChangedHandler), data);
	}

*/
/*

	void container_addHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_add(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "add", G_CALLBACK(container_addHandler), data);
	}

*/
/*

	void container_checkResizeHandler(GObject *, gpointer);

	static gulong Container_signal_connect_check_resize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "check-resize", G_CALLBACK(container_checkResizeHandler), data);
	}

*/
/*

	void container_removeHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_remove(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove", G_CALLBACK(container_removeHandler), data);
	}

*/
/*

	void container_setFocusChildHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_set_focus_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-focus-child", G_CALLBACK(container_setFocusChildHandler), data);
	}

*/
/*

	void cssprovider_parsingErrorHandler(GObject *, GtkCssSection *, GError *, gpointer);

	static gulong CssProvider_signal_connect_parsing_error(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "parsing-error", G_CALLBACK(cssprovider_parsingErrorHandler), data);
	}

*/
/*

	void dialog_closeHandler(GObject *, gpointer);

	static gulong Dialog_signal_connect_close(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "close", G_CALLBACK(dialog_closeHandler), data);
	}

*/
/*

	void entry_activateHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(entry_activateHandler), data);
	}

*/
/*

	void entry_backspaceHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_backspace(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "backspace", G_CALLBACK(entry_backspaceHandler), data);
	}

*/
/*

	void entry_copyClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(entry_copyClipboardHandler), data);
	}

*/
/*

	void entry_cutClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_cut_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cut-clipboard", G_CALLBACK(entry_cutClipboardHandler), data);
	}

*/
/*

	void entry_pasteClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_paste_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paste-clipboard", G_CALLBACK(entry_pasteClipboardHandler), data);
	}

*/
/*

	void entry_populatePopupHandler(GObject *, GtkWidget *, gpointer);

	static gulong Entry_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(entry_populatePopupHandler), data);
	}

*/
/*

	void entry_toggleOverwriteHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_toggle_overwrite(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-overwrite", G_CALLBACK(entry_toggleOverwriteHandler), data);
	}

*/
/*

	void expander_activateHandler(GObject *, gpointer);

	static gulong Expander_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(expander_activateHandler), data);
	}

*/
/*

	void filechooserwidget_desktopFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_desktop_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "desktop-folder", G_CALLBACK(filechooserwidget_desktopFolderHandler), data);
	}

*/
/*

	void filechooserwidget_downFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_down_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "down-folder", G_CALLBACK(filechooserwidget_downFolderHandler), data);
	}

*/
/*

	void filechooserwidget_homeFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_home_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "home-folder", G_CALLBACK(filechooserwidget_homeFolderHandler), data);
	}

*/
/*

	void filechooserwidget_locationPopupOnPasteHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_location_popup_on_paste(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-popup-on-paste", G_CALLBACK(filechooserwidget_locationPopupOnPasteHandler), data);
	}

*/
/*

	void filechooserwidget_locationTogglePopupHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_location_toggle_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-toggle-popup", G_CALLBACK(filechooserwidget_locationTogglePopupHandler), data);
	}

*/
/*

	void filechooserwidget_placesShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_places_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "places-shortcut", G_CALLBACK(filechooserwidget_placesShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_recentShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_recent_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "recent-shortcut", G_CALLBACK(filechooserwidget_recentShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_searchShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_search_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "search-shortcut", G_CALLBACK(filechooserwidget_searchShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_showHiddenHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_show_hidden(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-hidden", G_CALLBACK(filechooserwidget_showHiddenHandler), data);
	}

*/
/*

	void filechooserwidget_upFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_up_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "up-folder", G_CALLBACK(filechooserwidget_upFolderHandler), data);
	}

*/
/*

	void flowbox_activateCursorChildHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_activate_cursor_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-child", G_CALLBACK(flowbox_activateCursorChildHandler), data);
	}

*/
/*

	void flowbox_childActivatedHandler(GObject *, GtkFlowBoxChild *, gpointer);

	static gulong FlowBox_signal_connect_child_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-activated", G_CALLBACK(flowbox_childActivatedHandler), data);
	}

*/
/*

	void flowbox_selectAllHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(flowbox_selectAllHandler), data);
	}

*/
/*

	void flowbox_selectedChildrenChangedHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_selected_children_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selected-children-changed", G_CALLBACK(flowbox_selectedChildrenChangedHandler), data);
	}

*/
/*

	void flowbox_toggleCursorChildHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_toggle_cursor_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-child", G_CALLBACK(flowbox_toggleCursorChildHandler), data);
	}

*/
/*

	void flowbox_unselectAllHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(flowbox_unselectAllHandler), data);
	}

*/
/*

	void flowboxchild_activateHandler(GObject *, gpointer);

	static gulong FlowBoxChild_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(flowboxchild_activateHandler), data);
	}

*/
/*

	void hsv_changedHandler(GObject *, gpointer);

	static gulong HSV_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(hsv_changedHandler), data);
	}

*/
/*

	void handlebox_childAttachedHandler(GObject *, GtkWidget *, gpointer);

	static gulong HandleBox_signal_connect_child_attached(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-attached", G_CALLBACK(handlebox_childAttachedHandler), data);
	}

*/
/*

	void handlebox_childDetachedHandler(GObject *, GtkWidget *, gpointer);

	static gulong HandleBox_signal_connect_child_detached(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-detached", G_CALLBACK(handlebox_childDetachedHandler), data);
	}

*/
/*

	void imcontext_preeditChangedHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-changed", G_CALLBACK(imcontext_preeditChangedHandler), data);
	}

*/
/*

	void imcontext_preeditEndHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-end", G_CALLBACK(imcontext_preeditEndHandler), data);
	}

*/
/*

	void imcontext_preeditStartHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_start(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-start", G_CALLBACK(imcontext_preeditStartHandler), data);
	}

*/
/*

	gboolean imcontext_retrieveSurroundingHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_retrieve_surrounding(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "retrieve-surrounding", G_CALLBACK(imcontext_retrieveSurroundingHandler), data);
	}

*/
/*

	void icontheme_changedHandler(GObject *, gpointer);

	static gulong IconTheme_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(icontheme_changedHandler), data);
	}

*/
/*

	gboolean iconview_activateCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_activate_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-item", G_CALLBACK(iconview_activateCursorItemHandler), data);
	}

*/
/*

	void iconview_itemActivatedHandler(GObject *, GtkTreePath *, gpointer);

	static gulong IconView_signal_connect_item_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "item-activated", G_CALLBACK(iconview_itemActivatedHandler), data);
	}

*/
/*

	void iconview_selectAllHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(iconview_selectAllHandler), data);
	}

*/
/*

	void iconview_selectCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_select_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-item", G_CALLBACK(iconview_selectCursorItemHandler), data);
	}

*/
/*

	void iconview_selectionChangedHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_selection_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-changed", G_CALLBACK(iconview_selectionChangedHandler), data);
	}

*/
/*

	void iconview_toggleCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_toggle_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-item", G_CALLBACK(iconview_toggleCursorItemHandler), data);
	}

*/
/*

	void iconview_unselectAllHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(iconview_unselectAllHandler), data);
	}

*/
/*

	void label_copyClipboardHandler(GObject *, gpointer);

	static gulong Label_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(label_copyClipboardHandler), data);
	}

*/
/*

	void label_populatePopupHandler(GObject *, GtkMenu *, gpointer);

	static gulong Label_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(label_populatePopupHandler), data);
	}

*/
/*

	gboolean linkbutton_activateLinkHandler(GObject *, gpointer);

	static gulong LinkButton_signal_connect_activate_link(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-link", G_CALLBACK(linkbutton_activateLinkHandler), data);
	}

*/
/*

	void listbox_activateCursorRowHandler(GObject *, gpointer);

	static gulong ListBox_signal_connect_activate_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-row", G_CALLBACK(listbox_activateCursorRowHandler), data);
	}

*/
/*

	void listbox_toggleCursorRowHandler(GObject *, gpointer);

	static gulong ListBox_signal_connect_toggle_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-row", G_CALLBACK(listbox_toggleCursorRowHandler), data);
	}

*/
/*

	void menuitem_activateHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(menuitem_activateHandler), data);
	}

*/
/*

	void menuitem_activateItemHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_activate_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-item", G_CALLBACK(menuitem_activateItemHandler), data);
	}

*/
/*

	void menuitem_deselectHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_deselect(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "deselect", G_CALLBACK(menuitem_deselectHandler), data);
	}

*/
/*

	void menuitem_selectHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_select(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select", G_CALLBACK(menuitem_selectHandler), data);
	}

*/
/*

	void menushell_activateCurrentHandler(GObject *, gboolean, gpointer);

	static gulong MenuShell_signal_connect_activate_current(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-current", G_CALLBACK(menushell_activateCurrentHandler), data);
	}

*/
/*

	void menushell_cancelHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_cancel(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cancel", G_CALLBACK(menushell_cancelHandler), data);
	}

*/
/*

	void menushell_deactivateHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_deactivate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "deactivate", G_CALLBACK(menushell_deactivateHandler), data);
	}

*/
/*

	void menushell_selectionDoneHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_selection_done(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-done", G_CALLBACK(menushell_selectionDoneHandler), data);
	}

*/
/*

	void menutoolbutton_showMenuHandler(GObject *, gpointer);

	static gulong MenuToolButton_signal_connect_show_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-menu", G_CALLBACK(menutoolbutton_showMenuHandler), data);
	}

*/
/*

	gboolean notebook_selectPageHandler(GObject *, gboolean, gpointer);

	static gulong Notebook_signal_connect_select_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-page", G_CALLBACK(notebook_selectPageHandler), data);
	}

*/
/*

	void placessidebar_showConnectToServerHandler(GObject *, gpointer);

	static gulong PlacesSidebar_signal_connect_show_connect_to_server(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-connect-to-server", G_CALLBACK(placessidebar_showConnectToServerHandler), data);
	}

*/
/*

	void popover_closedHandler(GObject *, gpointer);

	static gulong Popover_signal_connect_closed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "closed", G_CALLBACK(popover_closedHandler), data);
	}

*/
/*

	void radiomenuitem_groupChangedHandler(GObject *, gpointer);

	static gulong RadioMenuItem_signal_connect_group_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "group-changed", G_CALLBACK(radiomenuitem_groupChangedHandler), data);
	}

*/
/*

	void range_valueChangedHandler(GObject *, gpointer);

	static gulong Range_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(range_valueChangedHandler), data);
	}

*/
/*

	gboolean spinbutton_outputHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_output(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "output", G_CALLBACK(spinbutton_outputHandler), data);
	}

*/
/*

	void spinbutton_valueChangedHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(spinbutton_valueChangedHandler), data);
	}

*/
/*

	void switch_activateHandler(GObject *, gpointer);

	static gulong Switch_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(switch_activateHandler), data);
	}

*/
/*

	void textbuffer_applyTagHandler(GObject *, GtkTextTag *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_apply_tag(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "apply-tag", G_CALLBACK(textbuffer_applyTagHandler), data);
	}

*/
/*

	void textbuffer_beginUserActionHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_begin_user_action(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "begin-user-action", G_CALLBACK(textbuffer_beginUserActionHandler), data);
	}

*/
/*

	void textbuffer_changedHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(textbuffer_changedHandler), data);
	}

*/
/*

	void textbuffer_deleteRangeHandler(GObject *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_delete_range(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-range", G_CALLBACK(textbuffer_deleteRangeHandler), data);
	}

*/
/*

	void textbuffer_endUserActionHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_end_user_action(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "end-user-action", G_CALLBACK(textbuffer_endUserActionHandler), data);
	}

*/
/*

	void textbuffer_insertChildAnchorHandler(GObject *, GtkTextIter *, GtkTextChildAnchor *, gpointer);

	static gulong TextBuffer_signal_connect_insert_child_anchor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-child-anchor", G_CALLBACK(textbuffer_insertChildAnchorHandler), data);
	}

*/
/*

	void textbuffer_insertPixbufHandler(GObject *, GtkTextIter *, GdkPixbuf *, gpointer);

	static gulong TextBuffer_signal_connect_insert_pixbuf(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-pixbuf", G_CALLBACK(textbuffer_insertPixbufHandler), data);
	}

*/
/*

	void textbuffer_markDeletedHandler(GObject *, GtkTextMark *, gpointer);

	static gulong TextBuffer_signal_connect_mark_deleted(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mark-deleted", G_CALLBACK(textbuffer_markDeletedHandler), data);
	}

*/
/*

	void textbuffer_markSetHandler(GObject *, GtkTextIter *, GtkTextMark *, gpointer);

	static gulong TextBuffer_signal_connect_mark_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mark-set", G_CALLBACK(textbuffer_markSetHandler), data);
	}

*/
/*

	void textbuffer_modifiedChangedHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_modified_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "modified-changed", G_CALLBACK(textbuffer_modifiedChangedHandler), data);
	}

*/
/*

	void textbuffer_removeTagHandler(GObject *, GtkTextTag *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_remove_tag(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove-tag", G_CALLBACK(textbuffer_removeTagHandler), data);
	}

*/
/*

	void texttagtable_tagAddedHandler(GObject *, GtkTextTag *, gpointer);

	static gulong TextTagTable_signal_connect_tag_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-added", G_CALLBACK(texttagtable_tagAddedHandler), data);
	}

*/
/*

	void texttagtable_tagChangedHandler(GObject *, GtkTextTag *, gboolean, gpointer);

	static gulong TextTagTable_signal_connect_tag_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-changed", G_CALLBACK(texttagtable_tagChangedHandler), data);
	}

*/
/*

	void texttagtable_tagRemovedHandler(GObject *, GtkTextTag *, gpointer);

	static gulong TextTagTable_signal_connect_tag_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-removed", G_CALLBACK(texttagtable_tagRemovedHandler), data);
	}

*/
/*

	void textview_backspaceHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_backspace(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "backspace", G_CALLBACK(textview_backspaceHandler), data);
	}

*/
/*

	void textview_copyClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(textview_copyClipboardHandler), data);
	}

*/
/*

	void textview_cutClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_cut_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cut-clipboard", G_CALLBACK(textview_cutClipboardHandler), data);
	}

*/
/*

	void textview_pasteClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_paste_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paste-clipboard", G_CALLBACK(textview_pasteClipboardHandler), data);
	}

*/
/*

	void textview_populatePopupHandler(GObject *, GtkWidget *, gpointer);

	static gulong TextView_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(textview_populatePopupHandler), data);
	}

*/
/*

	void textview_selectAllHandler(GObject *, gboolean, gpointer);

	static gulong TextView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(textview_selectAllHandler), data);
	}

*/
/*

	void textview_setAnchorHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_set_anchor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-anchor", G_CALLBACK(textview_setAnchorHandler), data);
	}

*/
/*

	void textview_toggleCursorVisibleHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_toggle_cursor_visible(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-visible", G_CALLBACK(textview_toggleCursorVisibleHandler), data);
	}

*/
/*

	void textview_toggleOverwriteHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_toggle_overwrite(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-overwrite", G_CALLBACK(textview_toggleOverwriteHandler), data);
	}

*/
/*

	void toggleaction_toggledHandler(GObject *, gpointer);

	static gulong ToggleAction_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(toggleaction_toggledHandler), data);
	}

*/
/*

	void togglebutton_toggledHandler(GObject *, gpointer);

	static gulong ToggleButton_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(togglebutton_toggledHandler), data);
	}

*/
/*

	void toggletoolbutton_toggledHandler(GObject *, gpointer);

	static gulong ToggleToolButton_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(toggletoolbutton_toggledHandler), data);
	}

*/
/*

	void toolbutton_clickedHandler(GObject *, gpointer);

	static gulong ToolButton_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(toolbutton_clickedHandler), data);
	}

*/
/*

	gboolean toolitem_createMenuProxyHandler(GObject *, gpointer);

	static gulong ToolItem_signal_connect_create_menu_proxy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "create-menu-proxy", G_CALLBACK(toolitem_createMenuProxyHandler), data);
	}

*/
/*

	void toolitem_toolbarReconfiguredHandler(GObject *, gpointer);

	static gulong ToolItem_signal_connect_toolbar_reconfigured(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toolbar-reconfigured", G_CALLBACK(toolitem_toolbarReconfiguredHandler), data);
	}

*/
/*

	gboolean toolbar_focusHomeOrEndHandler(GObject *, gboolean, gpointer);

	static gulong Toolbar_signal_connect_focus_home_or_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-home-or-end", G_CALLBACK(toolbar_focusHomeOrEndHandler), data);
	}

*/
/*

	void treeselection_changedHandler(GObject *, gpointer);

	static gulong TreeSelection_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(treeselection_changedHandler), data);
	}

*/
/*

	void treeview_columnsChangedHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_columns_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "columns-changed", G_CALLBACK(treeview_columnsChangedHandler), data);
	}

*/
/*

	void treeview_cursorChangedHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_cursor_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cursor-changed", G_CALLBACK(treeview_cursorChangedHandler), data);
	}

*/
/*

	gboolean treeview_expandCollapseCursorRowHandler(GObject *, gboolean, gboolean, gboolean, gpointer);

	static gulong TreeView_signal_connect_expand_collapse_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "expand-collapse-cursor-row", G_CALLBACK(treeview_expandCollapseCursorRowHandler), data);
	}

*/
/*

	void treeview_rowActivatedHandler(GObject *, GtkTreePath *, GtkTreeViewColumn *, gpointer);

	static gulong TreeView_signal_connect_row_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-activated", G_CALLBACK(treeview_rowActivatedHandler), data);
	}

*/
/*

	void treeview_rowCollapsedHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_row_collapsed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-collapsed", G_CALLBACK(treeview_rowCollapsedHandler), data);
	}

*/
/*

	void treeview_rowExpandedHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_row_expanded(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-expanded", G_CALLBACK(treeview_rowExpandedHandler), data);
	}

*/
/*

	gboolean treeview_selectAllHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(treeview_selectAllHandler), data);
	}

*/
/*

	gboolean treeview_selectCursorParentHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_select_cursor_parent(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-parent", G_CALLBACK(treeview_selectCursorParentHandler), data);
	}

*/
/*

	gboolean treeview_selectCursorRowHandler(GObject *, gboolean, gpointer);

	static gulong TreeView_signal_connect_select_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-row", G_CALLBACK(treeview_selectCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_startInteractiveSearchHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_start_interactive_search(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "start-interactive-search", G_CALLBACK(treeview_startInteractiveSearchHandler), data);
	}

*/
/*

	gboolean treeview_testCollapseRowHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_test_collapse_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "test-collapse-row", G_CALLBACK(treeview_testCollapseRowHandler), data);
	}

*/
/*

	gboolean treeview_testExpandRowHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_test_expand_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "test-expand-row", G_CALLBACK(treeview_testExpandRowHandler), data);
	}

*/
/*

	gboolean treeview_toggleCursorRowHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_toggle_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-row", G_CALLBACK(treeview_toggleCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_unselectAllHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(treeview_unselectAllHandler), data);
	}

*/
/*

	void treeviewcolumn_clickedHandler(GObject *, gpointer);

	static gulong TreeViewColumn_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(treeviewcolumn_clickedHandler), data);
	}

*/
/*

	void widget_accelClosuresChangedHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_accel_closures_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-closures-changed", G_CALLBACK(widget_accelClosuresChangedHandler), data);
	}

*/
/*

	gboolean widget_buttonPressEventHandler(GObject *, GdkEventButton *, gpointer);

	static gulong Widget_signal_connect_button_press_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "button-press-event", G_CALLBACK(widget_buttonPressEventHandler), data);
	}

*/
/*

	gboolean widget_buttonReleaseEventHandler(GObject *, GdkEventButton *, gpointer);

	static gulong Widget_signal_connect_button_release_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "button-release-event", G_CALLBACK(widget_buttonReleaseEventHandler), data);
	}

*/
/*

	void widget_compositedChangedHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_composited_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "composited-changed", G_CALLBACK(widget_compositedChangedHandler), data);
	}

*/
/*

	gboolean widget_configureEventHandler(GObject *, GdkEventConfigure *, gpointer);

	static gulong Widget_signal_connect_configure_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "configure-event", G_CALLBACK(widget_configureEventHandler), data);
	}

*/
/*

	void widget_destroyHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_destroy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "destroy", G_CALLBACK(widget_destroyHandler), data);
	}

*/
/*

	void widget_dragBeginHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_begin(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-begin", G_CALLBACK(widget_dragBeginHandler), data);
	}

*/
/*

	void widget_dragDataDeleteHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_data_delete(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-data-delete", G_CALLBACK(widget_dragDataDeleteHandler), data);
	}

*/
/*

	void widget_dragEndHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-end", G_CALLBACK(widget_dragEndHandler), data);
	}

*/
/*

	gboolean widget_enterNotifyEventHandler(GObject *, GdkEventCrossing *, gpointer);

	static gulong Widget_signal_connect_enter_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enter-notify-event", G_CALLBACK(widget_enterNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_focusInEventHandler(GObject *, GdkEventFocus *, gpointer);

	static gulong Widget_signal_connect_focus_in_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-in-event", G_CALLBACK(widget_focusInEventHandler), data);
	}

*/
/*

	gboolean widget_focusOutEventHandler(GObject *, GdkEventFocus *, gpointer);

	static gulong Widget_signal_connect_focus_out_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-out-event", G_CALLBACK(widget_focusOutEventHandler), data);
	}

*/
/*

	void widget_grabFocusHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_grab_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-focus", G_CALLBACK(widget_grabFocusHandler), data);
	}

*/
/*

	void widget_grabNotifyHandler(GObject *, gboolean, gpointer);

	static gulong Widget_signal_connect_grab_notify(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-notify", G_CALLBACK(widget_grabNotifyHandler), data);
	}

*/
/*

	void widget_hideHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_hide(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "hide", G_CALLBACK(widget_hideHandler), data);
	}

*/
/*

	void widget_hierarchyChangedHandler(GObject *, GtkWidget *, gpointer);

	static gulong Widget_signal_connect_hierarchy_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "hierarchy-changed", G_CALLBACK(widget_hierarchyChangedHandler), data);
	}

*/
/*

	gboolean widget_keyPressEventHandler(GObject *, GdkEventKey *, gpointer);

	static gulong Widget_signal_connect_key_press_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "key-press-event", G_CALLBACK(widget_keyPressEventHandler), data);
	}

*/
/*

	gboolean widget_keyReleaseEventHandler(GObject *, GdkEventKey *, gpointer);

	static gulong Widget_signal_connect_key_release_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "key-release-event", G_CALLBACK(widget_keyReleaseEventHandler), data);
	}

*/
/*

	gboolean widget_leaveNotifyEventHandler(GObject *, GdkEventCrossing *, gpointer);

	static gulong Widget_signal_connect_leave_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "leave-notify-event", G_CALLBACK(widget_leaveNotifyEventHandler), data);
	}

*/
/*

	void widget_mapHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_map(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "map", G_CALLBACK(widget_mapHandler), data);
	}

*/
/*

	gboolean widget_mapEventHandler(GObject *, GdkEventAny *, gpointer);

	static gulong Widget_signal_connect_map_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "map-event", G_CALLBACK(widget_mapEventHandler), data);
	}

*/
/*

	gboolean widget_mnemonicActivateHandler(GObject *, gboolean, gpointer);

	static gulong Widget_signal_connect_mnemonic_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mnemonic-activate", G_CALLBACK(widget_mnemonicActivateHandler), data);
	}

*/
/*

	gboolean widget_motionNotifyEventHandler(GObject *, GdkEventMotion *, gpointer);

	static gulong Widget_signal_connect_motion_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "motion-notify-event", G_CALLBACK(widget_motionNotifyEventHandler), data);
	}

*/
/*

	void widget_parentSetHandler(GObject *, GtkWidget *, gpointer);

	static gulong Widget_signal_connect_parent_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "parent-set", G_CALLBACK(widget_parentSetHandler), data);
	}

*/
/*

	gboolean widget_popupMenuHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_popup_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup-menu", G_CALLBACK(widget_popupMenuHandler), data);
	}

*/
/*

	gboolean widget_propertyNotifyEventHandler(GObject *, GdkEventProperty *, gpointer);

	static gulong Widget_signal_connect_property_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "property-notify-event", G_CALLBACK(widget_propertyNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_proximityInEventHandler(GObject *, GdkEventProximity *, gpointer);

	static gulong Widget_signal_connect_proximity_in_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "proximity-in-event", G_CALLBACK(widget_proximityInEventHandler), data);
	}

*/
/*

	gboolean widget_proximityOutEventHandler(GObject *, GdkEventProximity *, gpointer);

	static gulong Widget_signal_connect_proximity_out_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "proximity-out-event", G_CALLBACK(widget_proximityOutEventHandler), data);
	}

*/
/*

	void widget_realizeHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_realize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "realize", G_CALLBACK(widget_realizeHandler), data);
	}

*/
/*

	void widget_screenChangedHandler(GObject *, GdkScreen *, gpointer);

	static gulong Widget_signal_connect_screen_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "screen-changed", G_CALLBACK(widget_screenChangedHandler), data);
	}

*/
/*

	gboolean widget_scrollEventHandler(GObject *, GdkEventScroll *, gpointer);

	static gulong Widget_signal_connect_scroll_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "scroll-event", G_CALLBACK(widget_scrollEventHandler), data);
	}

*/
/*

	gboolean widget_selectionClearEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_clear_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-clear-event", G_CALLBACK(widget_selectionClearEventHandler), data);
	}

*/
/*

	gboolean widget_selectionNotifyEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-notify-event", G_CALLBACK(widget_selectionNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_selectionRequestEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_request_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-request-event", G_CALLBACK(widget_selectionRequestEventHandler), data);
	}

*/
/*

	void widget_showHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_show(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show", G_CALLBACK(widget_showHandler), data);
	}

*/
/*

	void widget_styleSetHandler(GObject *, GtkStyle *, gpointer);

	static gulong Widget_signal_connect_style_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "style-set", G_CALLBACK(widget_styleSetHandler), data);
	}

*/
/*

	void widget_unmapHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_unmap(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmap", G_CALLBACK(widget_unmapHandler), data);
	}

*/
/*

	gboolean widget_unmapEventHandler(GObject *, GdkEventAny *, gpointer);

	static gulong Widget_signal_connect_unmap_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmap-event", G_CALLBACK(widget_unmapEventHandler), data);
	}

*/
/*

	void widget_unrealizeHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_unrealize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unrealize", G_CALLBACK(widget_unrealizeHandler), data);
	}

*/
/*

	gboolean widget_visibilityNotifyEventHandler(GObject *, GdkEventVisibility *, gpointer);

	static gulong Widget_signal_connect_visibility_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "visibility-notify-event", G_CALLBACK(widget_visibilityNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_windowStateEventHandler(GObject *, GdkEventWindowState *, gpointer);

	static gulong Widget_signal_connect_window_state_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "window-state-event", G_CALLBACK(widget_windowStateEventHandler), data);
	}

*/
/*

	void window_activateDefaultHandler(GObject *, gpointer);

	static gulong Window_signal_connect_activate_default(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-default", G_CALLBACK(window_activateDefaultHandler), data);
	}

*/
/*

	void window_activateFocusHandler(GObject *, gpointer);

	static gulong Window_signal_connect_activate_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-focus", G_CALLBACK(window_activateFocusHandler), data);
	}

*/
/*

	gboolean window_enableDebuggingHandler(GObject *, gboolean, gpointer);

	static gulong Window_signal_connect_enable_debugging(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enable-debugging", G_CALLBACK(window_enableDebuggingHandler), data);
	}

*/
/*

	void window_keysChangedHandler(GObject *, gpointer);

	static gulong Window_signal_connect_keys_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "keys-changed", G_CALLBACK(window_keysChangedHandler), data);
	}

*/
/*

	void window_setFocusHandler(GObject *, GtkWidget *, gpointer);

	static gulong Window_signal_connect_set_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-focus", G_CALLBACK(window_setFocusHandler), data);
	}

*/
import "C"

// AboutDialog is a wrapper around the C record GtkAboutDialog.
type AboutDialog struct {
	native *C.GtkAboutDialog
	// parent_instance : record
	// Private : priv
}

func AboutDialogNewFromC(u unsafe.Pointer) *AboutDialog {
	c := (*C.GtkAboutDialog)(u)
	if c == nil {
		return nil
	}

	g := &AboutDialog{native: c}

	return g
}

func (recv *AboutDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *AboutDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *AboutDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *AboutDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *AboutDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *AboutDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AboutDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AboutDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to AboutDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a AboutDialog.
func CastToAboutDialog(object *gobject.Object) *AboutDialog {
	return AboutDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by AboutDialog
func (recv *AboutDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AboutDialog
func (recv *AboutDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AccelGroup is a wrapper around the C record GtkAccelGroup.
type AccelGroup struct {
	native *C.GtkAccelGroup
	// parent : record
	// priv : record
}

func AccelGroupNewFromC(u unsafe.Pointer) *AccelGroup {
	c := (*C.GtkAccelGroup)(u)
	if c == nil {
		return nil
	}

	g := &AccelGroup{native: c}

	return g
}

func (recv *AccelGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *AccelGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to AccelGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelGroup.
func CastToAccelGroup(object *gobject.Object) *AccelGroup {
	return AccelGroupNewFromC(object.ToC())
}

// Unsupported signal 'accel-activate' for AccelGroup : unsupported parameter keyval : type guint :

// Unsupported signal 'accel-changed' for AccelGroup : unsupported parameter keyval : type guint :

// Creates a new #GtkAccelGroup.
/*

C function : gtk_accel_group_new
*/
func AccelGroupNew() *AccelGroup {
	retC := C.gtk_accel_group_new()
	retGo := AccelGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Finds the first accelerator in @accel_group that matches
// @accel_key and @accel_mods, and activates it.
/*

C function : gtk_accel_group_activate
*/
func (recv *AccelGroup) Activate(accelQuark glib.Quark, acceleratable *gobject.Object, accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_quark := (C.GQuark)(accelQuark)

	c_acceleratable := (*C.GObject)(C.NULL)
	if acceleratable != nil {
		c_acceleratable = (*C.GObject)(acceleratable.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_accel_group_activate((*C.GtkAccelGroup)(recv.native), c_accel_quark, c_acceleratable, c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// Installs an accelerator in this group. When @accel_group is being
// activated in response to a call to gtk_accel_groups_activate(),
// @closure will be invoked if the @accel_key and @accel_mods from
// gtk_accel_groups_activate() match those of this connection.
//
// The signature used for the @closure is that of #GtkAccelGroupActivate.
//
// Note that, due to implementation details, a single closure can
// only be connected to one accelerator group.
/*

C function : gtk_accel_group_connect
*/
func (recv *AccelGroup) Connect(accelKey uint32, accelMods gdk.ModifierType, accelFlags AccelFlags, closure *gobject.Closure) {
	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	c_accel_flags := (C.GtkAccelFlags)(accelFlags)

	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	C.gtk_accel_group_connect((*C.GtkAccelGroup)(recv.native), c_accel_key, c_accel_mods, c_accel_flags, c_closure)

	return
}

// Installs an accelerator in this group, using an accelerator path
// to look up the appropriate key and modifiers (see
// gtk_accel_map_add_entry()). When @accel_group is being activated
// in response to a call to gtk_accel_groups_activate(), @closure will
// be invoked if the @accel_key and @accel_mods from
// gtk_accel_groups_activate() match the key and modifiers for the path.
//
// The signature used for the @closure is that of #GtkAccelGroupActivate.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore,
// if you pass a static string, you can save some memory by interning it
// first with g_intern_static_string().
/*

C function : gtk_accel_group_connect_by_path
*/
func (recv *AccelGroup) ConnectByPath(accelPath string, closure *gobject.Closure) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	C.gtk_accel_group_connect_by_path((*C.GtkAccelGroup)(recv.native), c_accel_path, c_closure)

	return
}

// Removes an accelerator previously installed through
// gtk_accel_group_connect().
//
// Since 2.20 @closure can be %NULL.
/*

C function : gtk_accel_group_disconnect
*/
func (recv *AccelGroup) Disconnect(closure *gobject.Closure) bool {
	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	retC := C.gtk_accel_group_disconnect((*C.GtkAccelGroup)(recv.native), c_closure)
	retGo := retC == C.TRUE

	return retGo
}

// Removes an accelerator previously installed through
// gtk_accel_group_connect().
/*

C function : gtk_accel_group_disconnect_key
*/
func (recv *AccelGroup) DisconnectKey(accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_accel_group_disconnect_key((*C.GtkAccelGroup)(recv.native), c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_accel_group_find : unsupported parameter find_func : no type generator for AccelGroupFindFunc (GtkAccelGroupFindFunc) for param find_func

// Locks the given accelerator group.
//
// Locking an acelerator group prevents the accelerators contained
// within it to be changed during runtime. Refer to
// gtk_accel_map_change_entry() about runtime accelerator changes.
//
// If called more than once, @accel_group remains locked until
// gtk_accel_group_unlock() has been called an equivalent number
// of times.
/*

C function : gtk_accel_group_lock
*/
func (recv *AccelGroup) Lock() {
	C.gtk_accel_group_lock((*C.GtkAccelGroup)(recv.native))

	return
}

// Unsupported : gtk_accel_group_query : no return type

// Undoes the last call to gtk_accel_group_lock() on this @accel_group.
/*

C function : gtk_accel_group_unlock
*/
func (recv *AccelGroup) Unlock() {
	C.gtk_accel_group_unlock((*C.GtkAccelGroup)(recv.native))

	return
}

// AccelLabel is a wrapper around the C record GtkAccelLabel.
type AccelLabel struct {
	native *C.GtkAccelLabel
	// label : record
	// priv : record
}

func AccelLabelNewFromC(u unsafe.Pointer) *AccelLabel {
	c := (*C.GtkAccelLabel)(u)
	if c == nil {
		return nil
	}

	g := &AccelLabel{native: c}

	return g
}

func (recv *AccelLabel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Label upcasts to *Label
func (recv *AccelLabel) Label() *Label {
	return LabelNewFromC(unsafe.Pointer(recv.native))
}

// Misc upcasts to *Misc
func (recv *AccelLabel) Misc() *Misc {
	return recv.Label().Misc()
}

// Widget upcasts to *Widget
func (recv *AccelLabel) Widget() *Widget {
	return recv.Label().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AccelLabel) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Label().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AccelLabel) Object() *gobject.Object {
	return recv.Label().Object()
}

// CastToWidget down casts any arbitary Object to AccelLabel.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelLabel.
func CastToAccelLabel(object *gobject.Object) *AccelLabel {
	return AccelLabelNewFromC(object.ToC())
}

// Creates a new #GtkAccelLabel.
/*

C function : gtk_accel_label_new
*/
func AccelLabelNew(string string) *AccelLabel {
	c_string := C.CString(string)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.gtk_accel_label_new(c_string)
	retGo := AccelLabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Fetches the widget monitored by this accelerator label. See
// gtk_accel_label_set_accel_widget().
/*

C function : gtk_accel_label_get_accel_widget
*/
func (recv *AccelLabel) GetAccelWidget() *Widget {
	retC := C.gtk_accel_label_get_accel_widget((*C.GtkAccelLabel)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the width needed to display the accelerator key(s).
// This is used by menus to align all of the #GtkMenuItem widgets, and shouldn't
// be needed by applications.
/*

C function : gtk_accel_label_get_accel_width
*/
func (recv *AccelLabel) GetAccelWidth() uint32 {
	retC := C.gtk_accel_label_get_accel_width((*C.GtkAccelLabel)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Recreates the string representing the accelerator keys.
// This should not be needed since the string is automatically updated whenever
// accelerators are added or removed from the associated widget.
/*

C function : gtk_accel_label_refetch
*/
func (recv *AccelLabel) Refetch() bool {
	retC := C.gtk_accel_label_refetch((*C.GtkAccelLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the closure to be monitored by this accelerator label. The closure
// must be connected to an accelerator group; see gtk_accel_group_connect().
// Passing %NULL for @accel_closure will dissociate @accel_label from its
// current closure, if any.
/*

C function : gtk_accel_label_set_accel_closure
*/
func (recv *AccelLabel) SetAccelClosure(accelClosure *gobject.Closure) {
	c_accel_closure := (*C.GClosure)(C.NULL)
	if accelClosure != nil {
		c_accel_closure = (*C.GClosure)(accelClosure.ToC())
	}

	C.gtk_accel_label_set_accel_closure((*C.GtkAccelLabel)(recv.native), c_accel_closure)

	return
}

// Sets the widget to be monitored by this accelerator label. Passing %NULL for
// @accel_widget will dissociate @accel_label from its current widget, if any.
/*

C function : gtk_accel_label_set_accel_widget
*/
func (recv *AccelLabel) SetAccelWidget(accelWidget *Widget) {
	c_accel_widget := (*C.GtkWidget)(C.NULL)
	if accelWidget != nil {
		c_accel_widget = (*C.GtkWidget)(accelWidget.ToC())
	}

	C.gtk_accel_label_set_accel_widget((*C.GtkAccelLabel)(recv.native), c_accel_widget)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AccelLabel
func (recv *AccelLabel) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AccelLabel
func (recv *AccelLabel) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AccelMap is a wrapper around the C record GtkAccelMap.
type AccelMap struct {
	native *C.GtkAccelMap
}

func AccelMapNewFromC(u unsafe.Pointer) *AccelMap {
	c := (*C.GtkAccelMap)(u)
	if c == nil {
		return nil
	}

	g := &AccelMap{native: c}

	return g
}

func (recv *AccelMap) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *AccelMap) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to AccelMap.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelMap.
func CastToAccelMap(object *gobject.Object) *AccelMap {
	return AccelMapNewFromC(object.ToC())
}

// Accessible is a wrapper around the C record GtkAccessible.
type Accessible struct {
	native *C.GtkAccessible
	// parent : record
	// Private : priv
}

func AccessibleNewFromC(u unsafe.Pointer) *Accessible {
	c := (*C.GtkAccessible)(u)
	if c == nil {
		return nil
	}

	g := &Accessible{native: c}

	return g
}

func (recv *Accessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Accessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Accessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a Accessible.
func CastToAccessible(object *gobject.Object) *Accessible {
	return AccessibleNewFromC(object.ToC())
}

// This function specifies the callback function to be called
// when the widget corresponding to a GtkAccessible is destroyed.
/*

C function : gtk_accessible_connect_widget_destroyed
*/
func (recv *Accessible) ConnectWidgetDestroyed() {
	C.gtk_accessible_connect_widget_destroyed((*C.GtkAccessible)(recv.native))

	return
}

// Action is a wrapper around the C record GtkAction.
type Action struct {
	native *C.GtkAction
	// object : record
	// Private : private_data
}

func ActionNewFromC(u unsafe.Pointer) *Action {
	c := (*C.GtkAction)(u)
	if c == nil {
		return nil
	}

	g := &Action{native: c}

	return g
}

func (recv *Action) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Action) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Action.
// Exercise care, as this is a potentially dangerous function if the Object is not a Action.
func CastToAction(object *gobject.Object) *Action {
	return ActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by Action
func (recv *Action) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ActionBar is a wrapper around the C record GtkActionBar.
type ActionBar struct {
	native *C.GtkActionBar
	// Private : bin
}

func ActionBarNewFromC(u unsafe.Pointer) *ActionBar {
	c := (*C.GtkActionBar)(u)
	if c == nil {
		return nil
	}

	g := &ActionBar{native: c}

	return g
}

func (recv *ActionBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ActionBar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ActionBar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ActionBar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ActionBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ActionBar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ActionBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a ActionBar.
func CastToActionBar(object *gobject.Object) *ActionBar {
	return ActionBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ActionBar
func (recv *ActionBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ActionBar
func (recv *ActionBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ActionGroup is a wrapper around the C record GtkActionGroup.
type ActionGroup struct {
	native *C.GtkActionGroup
	// parent : record
	// Private : priv
}

func ActionGroupNewFromC(u unsafe.Pointer) *ActionGroup {
	c := (*C.GtkActionGroup)(u)
	if c == nil {
		return nil
	}

	g := &ActionGroup{native: c}

	return g
}

func (recv *ActionGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *ActionGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to ActionGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a ActionGroup.
func CastToActionGroup(object *gobject.Object) *ActionGroup {
	return ActionGroupNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by ActionGroup
func (recv *ActionGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Adjustment is a wrapper around the C record GtkAdjustment.
type Adjustment struct {
	native *C.GtkAdjustment
	// parent_instance : record
	// priv : record
}

func AdjustmentNewFromC(u unsafe.Pointer) *Adjustment {
	c := (*C.GtkAdjustment)(u)
	if c == nil {
		return nil
	}

	g := &Adjustment{native: c}

	return g
}

func (recv *Adjustment) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Adjustment) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Adjustment) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to Adjustment.
// Exercise care, as this is a potentially dangerous function if the Object is not a Adjustment.
func CastToAdjustment(object *gobject.Object) *Adjustment {
	return AdjustmentNewFromC(object.ToC())
}

type signalAdjustmentChangedDetail struct {
	callback  AdjustmentSignalChangedCallback
	handlerID C.gulong
}

var signalAdjustmentChangedId int
var signalAdjustmentChangedMap = make(map[int]signalAdjustmentChangedDetail)
var signalAdjustmentChangedLock sync.Mutex

// AdjustmentSignalChangedCallback is a callback function for a 'changed' signal emitted from a Adjustment.
type AdjustmentSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the Adjustment.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Adjustment) ConnectChanged(callback AdjustmentSignalChangedCallback) int {
	signalAdjustmentChangedLock.Lock()
	defer signalAdjustmentChangedLock.Unlock()

	signalAdjustmentChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Adjustment_signal_connect_changed(instance, C.gpointer(uintptr(signalAdjustmentChangedId)))

	detail := signalAdjustmentChangedDetail{callback, handlerID}
	signalAdjustmentChangedMap[signalAdjustmentChangedId] = detail

	return signalAdjustmentChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Adjustment.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Adjustment) DisconnectChanged(connectionID int) {
	signalAdjustmentChangedLock.Lock()
	defer signalAdjustmentChangedLock.Unlock()

	detail, exists := signalAdjustmentChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAdjustmentChangedMap, connectionID)
}

//export adjustment_changedHandler
func adjustment_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalAdjustmentChangedMap[index].callback
	callback()
}

type signalAdjustmentValueChangedDetail struct {
	callback  AdjustmentSignalValueChangedCallback
	handlerID C.gulong
}

var signalAdjustmentValueChangedId int
var signalAdjustmentValueChangedMap = make(map[int]signalAdjustmentValueChangedDetail)
var signalAdjustmentValueChangedLock sync.Mutex

// AdjustmentSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a Adjustment.
type AdjustmentSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the Adjustment.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *Adjustment) ConnectValueChanged(callback AdjustmentSignalValueChangedCallback) int {
	signalAdjustmentValueChangedLock.Lock()
	defer signalAdjustmentValueChangedLock.Unlock()

	signalAdjustmentValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Adjustment_signal_connect_value_changed(instance, C.gpointer(uintptr(signalAdjustmentValueChangedId)))

	detail := signalAdjustmentValueChangedDetail{callback, handlerID}
	signalAdjustmentValueChangedMap[signalAdjustmentValueChangedId] = detail

	return signalAdjustmentValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the Adjustment.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *Adjustment) DisconnectValueChanged(connectionID int) {
	signalAdjustmentValueChangedLock.Lock()
	defer signalAdjustmentValueChangedLock.Unlock()

	detail, exists := signalAdjustmentValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAdjustmentValueChangedMap, connectionID)
}

//export adjustment_valueChangedHandler
func adjustment_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalAdjustmentValueChangedMap[index].callback
	callback()
}

// Creates a new #GtkAdjustment.
/*

C function : gtk_adjustment_new
*/
func AdjustmentNew(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) *Adjustment {
	c_value := (C.gdouble)(value)

	c_lower := (C.gdouble)(lower)

	c_upper := (C.gdouble)(upper)

	c_step_increment := (C.gdouble)(stepIncrement)

	c_page_increment := (C.gdouble)(pageIncrement)

	c_page_size := (C.gdouble)(pageSize)

	retC := C.gtk_adjustment_new(c_value, c_lower, c_upper, c_step_increment, c_page_increment, c_page_size)
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Emits a #GtkAdjustment::changed signal from the #GtkAdjustment.
// This is typically called by the owner of the #GtkAdjustment after it has
// changed any of the #GtkAdjustment properties other than the value.
/*

C function : gtk_adjustment_changed
*/
func (recv *Adjustment) Changed() {
	C.gtk_adjustment_changed((*C.GtkAdjustment)(recv.native))

	return
}

// Updates the #GtkAdjustment:value property to ensure that the range
// between @lower and @upper is in the current page (i.e. between
// #GtkAdjustment:value and #GtkAdjustment:value + #GtkAdjustment:page-size).
// If the range is larger than the page size, then only the start of it will
// be in the current page.
//
// A #GtkAdjustment::value-changed signal will be emitted if the value is changed.
/*

C function : gtk_adjustment_clamp_page
*/
func (recv *Adjustment) ClampPage(lower float64, upper float64) {
	c_lower := (C.gdouble)(lower)

	c_upper := (C.gdouble)(upper)

	C.gtk_adjustment_clamp_page((*C.GtkAdjustment)(recv.native), c_lower, c_upper)

	return
}

// Gets the current value of the adjustment.
// See gtk_adjustment_set_value().
/*

C function : gtk_adjustment_get_value
*/
func (recv *Adjustment) GetValue() float64 {
	retC := C.gtk_adjustment_get_value((*C.GtkAdjustment)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Sets the #GtkAdjustment value. The value is clamped to lie between
// #GtkAdjustment:lower and #GtkAdjustment:upper.
//
// Note that for adjustments which are used in a #GtkScrollbar, the
// effective range of allowed values goes from #GtkAdjustment:lower to
// #GtkAdjustment:upper - #GtkAdjustment:page-size.
/*

C function : gtk_adjustment_set_value
*/
func (recv *Adjustment) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_adjustment_set_value((*C.GtkAdjustment)(recv.native), c_value)

	return
}

// Emits a #GtkAdjustment::value-changed signal from the #GtkAdjustment.
// This is typically called by the owner of the #GtkAdjustment after it has
// changed the #GtkAdjustment:value property.
/*

C function : gtk_adjustment_value_changed
*/
func (recv *Adjustment) ValueChanged() {
	C.gtk_adjustment_value_changed((*C.GtkAdjustment)(recv.native))

	return
}

// Alignment is a wrapper around the C record GtkAlignment.
type Alignment struct {
	native *C.GtkAlignment
	// bin : record
	// Private : priv
}

func AlignmentNewFromC(u unsafe.Pointer) *Alignment {
	c := (*C.GtkAlignment)(u)
	if c == nil {
		return nil
	}

	g := &Alignment{native: c}

	return g
}

func (recv *Alignment) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Alignment) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Alignment) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Alignment) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Alignment) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Alignment) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Alignment.
// Exercise care, as this is a potentially dangerous function if the Object is not a Alignment.
func CastToAlignment(object *gobject.Object) *Alignment {
	return AlignmentNewFromC(object.ToC())
}

// Creates a new #GtkAlignment.
/*

C function : gtk_alignment_new
*/
func AlignmentNew(xalign float32, yalign float32, xscale float32, yscale float32) *Alignment {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_xscale := (C.gfloat)(xscale)

	c_yscale := (C.gfloat)(yscale)

	retC := C.gtk_alignment_new(c_xalign, c_yalign, c_xscale, c_yscale)
	retGo := AlignmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the #GtkAlignment values.
/*

C function : gtk_alignment_set
*/
func (recv *Alignment) Set(xalign float32, yalign float32, xscale float32, yscale float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_xscale := (C.gfloat)(xscale)

	c_yscale := (C.gfloat)(yscale)

	C.gtk_alignment_set((*C.GtkAlignment)(recv.native), c_xalign, c_yalign, c_xscale, c_yscale)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Alignment
func (recv *Alignment) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Alignment
func (recv *Alignment) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AppChooserButton is a wrapper around the C record GtkAppChooserButton.
type AppChooserButton struct {
	native *C.GtkAppChooserButton
	// parent : record
	// Private : priv
}

func AppChooserButtonNewFromC(u unsafe.Pointer) *AppChooserButton {
	c := (*C.GtkAppChooserButton)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserButton{native: c}

	return g
}

func (recv *AppChooserButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ComboBox upcasts to *ComboBox
func (recv *AppChooserButton) ComboBox() *ComboBox {
	return ComboBoxNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *AppChooserButton) Bin() *Bin {
	return recv.ComboBox().Bin()
}

// Container upcasts to *Container
func (recv *AppChooserButton) Container() *Container {
	return recv.ComboBox().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserButton) Widget() *Widget {
	return recv.ComboBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ComboBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserButton) Object() *gobject.Object {
	return recv.ComboBox().Object()
}

// CastToWidget down casts any arbitary Object to AppChooserButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserButton.
func CastToAppChooserButton(object *gobject.Object) *AppChooserButton {
	return AppChooserButtonNewFromC(object.ToC())
}

// Unsupported signal 'custom-item-activated' for AppChooserButton : unsupported parameter item_name : type utf8 :

// Returns the text to display at the top of the dialog.
/*

C function : gtk_app_chooser_button_get_heading
*/
func (recv *AppChooserButton) GetHeading() string {
	retC := C.gtk_app_chooser_button_get_heading((*C.GtkAppChooserButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Sets the text to display at the top of the dialog.
// If the heading is not set, the dialog displays a default text.
/*

C function : gtk_app_chooser_button_set_heading
*/
func (recv *AppChooserButton) SetHeading(heading string) {
	c_heading := C.CString(heading)
	defer C.free(unsafe.Pointer(c_heading))

	C.gtk_app_chooser_button_set_heading((*C.GtkAppChooserButton)(recv.native), c_heading)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserButton
func (recv *AppChooserButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserButton
func (recv *AppChooserButton) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserButton
func (recv *AppChooserButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by AppChooserButton
func (recv *AppChooserButton) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by AppChooserButton
func (recv *AppChooserButton) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// AppChooserDialog is a wrapper around the C record GtkAppChooserDialog.
type AppChooserDialog struct {
	native *C.GtkAppChooserDialog
	// parent : record
	// Private : priv
}

func AppChooserDialogNewFromC(u unsafe.Pointer) *AppChooserDialog {
	c := (*C.GtkAppChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserDialog{native: c}

	return g
}

func (recv *AppChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *AppChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *AppChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *AppChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *AppChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to AppChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserDialog.
func CastToAppChooserDialog(object *gobject.Object) *AppChooserDialog {
	return AppChooserDialogNewFromC(object.ToC())
}

// Returns the text to display at the top of the dialog.
/*

C function : gtk_app_chooser_dialog_get_heading
*/
func (recv *AppChooserDialog) GetHeading() string {
	retC := C.gtk_app_chooser_dialog_get_heading((*C.GtkAppChooserDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Sets the text to display at the top of the dialog.
// If the heading is not set, the dialog displays a default text.
/*

C function : gtk_app_chooser_dialog_set_heading
*/
func (recv *AppChooserDialog) SetHeading(heading string) {
	c_heading := C.CString(heading)
	defer C.free(unsafe.Pointer(c_heading))

	C.gtk_app_chooser_dialog_set_heading((*C.GtkAppChooserDialog)(recv.native), c_heading)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserDialog
func (recv *AppChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserDialog
func (recv *AppChooserDialog) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserDialog
func (recv *AppChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AppChooserWidget is a wrapper around the C record GtkAppChooserWidget.
type AppChooserWidget struct {
	native *C.GtkAppChooserWidget
	// parent : record
	// Private : priv
}

func AppChooserWidgetNewFromC(u unsafe.Pointer) *AppChooserWidget {
	c := (*C.GtkAppChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserWidget{native: c}

	return g
}

func (recv *AppChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *AppChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *AppChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to AppChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserWidget.
func CastToAppChooserWidget(object *gobject.Object) *AppChooserWidget {
	return AppChooserWidgetNewFromC(object.ToC())
}

type signalAppChooserWidgetApplicationActivatedDetail struct {
	callback  AppChooserWidgetSignalApplicationActivatedCallback
	handlerID C.gulong
}

var signalAppChooserWidgetApplicationActivatedId int
var signalAppChooserWidgetApplicationActivatedMap = make(map[int]signalAppChooserWidgetApplicationActivatedDetail)
var signalAppChooserWidgetApplicationActivatedLock sync.Mutex

// AppChooserWidgetSignalApplicationActivatedCallback is a callback function for a 'application-activated' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalApplicationActivatedCallback func(application *gio.AppInfo)

/*
ConnectApplicationActivated connects the callback to the 'application-activated' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectApplicationActivated to remove it.
*/
func (recv *AppChooserWidget) ConnectApplicationActivated(callback AppChooserWidgetSignalApplicationActivatedCallback) int {
	signalAppChooserWidgetApplicationActivatedLock.Lock()
	defer signalAppChooserWidgetApplicationActivatedLock.Unlock()

	signalAppChooserWidgetApplicationActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_application_activated(instance, C.gpointer(uintptr(signalAppChooserWidgetApplicationActivatedId)))

	detail := signalAppChooserWidgetApplicationActivatedDetail{callback, handlerID}
	signalAppChooserWidgetApplicationActivatedMap[signalAppChooserWidgetApplicationActivatedId] = detail

	return signalAppChooserWidgetApplicationActivatedId
}

/*
DisconnectApplicationActivated disconnects a callback from the 'application-activated' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectApplicationActivated.
*/
func (recv *AppChooserWidget) DisconnectApplicationActivated(connectionID int) {
	signalAppChooserWidgetApplicationActivatedLock.Lock()
	defer signalAppChooserWidgetApplicationActivatedLock.Unlock()

	detail, exists := signalAppChooserWidgetApplicationActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetApplicationActivatedMap, connectionID)
}

//export appchooserwidget_applicationActivatedHandler
func appchooserwidget_applicationActivatedHandler(_ *C.GObject, c_application *C.GAppInfo, data C.gpointer) {
	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetApplicationActivatedMap[index].callback
	callback(application)
}

type signalAppChooserWidgetApplicationSelectedDetail struct {
	callback  AppChooserWidgetSignalApplicationSelectedCallback
	handlerID C.gulong
}

var signalAppChooserWidgetApplicationSelectedId int
var signalAppChooserWidgetApplicationSelectedMap = make(map[int]signalAppChooserWidgetApplicationSelectedDetail)
var signalAppChooserWidgetApplicationSelectedLock sync.Mutex

// AppChooserWidgetSignalApplicationSelectedCallback is a callback function for a 'application-selected' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalApplicationSelectedCallback func(application *gio.AppInfo)

/*
ConnectApplicationSelected connects the callback to the 'application-selected' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectApplicationSelected to remove it.
*/
func (recv *AppChooserWidget) ConnectApplicationSelected(callback AppChooserWidgetSignalApplicationSelectedCallback) int {
	signalAppChooserWidgetApplicationSelectedLock.Lock()
	defer signalAppChooserWidgetApplicationSelectedLock.Unlock()

	signalAppChooserWidgetApplicationSelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_application_selected(instance, C.gpointer(uintptr(signalAppChooserWidgetApplicationSelectedId)))

	detail := signalAppChooserWidgetApplicationSelectedDetail{callback, handlerID}
	signalAppChooserWidgetApplicationSelectedMap[signalAppChooserWidgetApplicationSelectedId] = detail

	return signalAppChooserWidgetApplicationSelectedId
}

/*
DisconnectApplicationSelected disconnects a callback from the 'application-selected' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectApplicationSelected.
*/
func (recv *AppChooserWidget) DisconnectApplicationSelected(connectionID int) {
	signalAppChooserWidgetApplicationSelectedLock.Lock()
	defer signalAppChooserWidgetApplicationSelectedLock.Unlock()

	detail, exists := signalAppChooserWidgetApplicationSelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetApplicationSelectedMap, connectionID)
}

//export appchooserwidget_applicationSelectedHandler
func appchooserwidget_applicationSelectedHandler(_ *C.GObject, c_application *C.GAppInfo, data C.gpointer) {
	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetApplicationSelectedMap[index].callback
	callback(application)
}

type signalAppChooserWidgetPopulatePopupDetail struct {
	callback  AppChooserWidgetSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalAppChooserWidgetPopulatePopupId int
var signalAppChooserWidgetPopulatePopupMap = make(map[int]signalAppChooserWidgetPopulatePopupDetail)
var signalAppChooserWidgetPopulatePopupLock sync.Mutex

// AppChooserWidgetSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalPopulatePopupCallback func(menu *Menu, application *gio.AppInfo)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *AppChooserWidget) ConnectPopulatePopup(callback AppChooserWidgetSignalPopulatePopupCallback) int {
	signalAppChooserWidgetPopulatePopupLock.Lock()
	defer signalAppChooserWidgetPopulatePopupLock.Unlock()

	signalAppChooserWidgetPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalAppChooserWidgetPopulatePopupId)))

	detail := signalAppChooserWidgetPopulatePopupDetail{callback, handlerID}
	signalAppChooserWidgetPopulatePopupMap[signalAppChooserWidgetPopulatePopupId] = detail

	return signalAppChooserWidgetPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *AppChooserWidget) DisconnectPopulatePopup(connectionID int) {
	signalAppChooserWidgetPopulatePopupLock.Lock()
	defer signalAppChooserWidgetPopulatePopupLock.Unlock()

	detail, exists := signalAppChooserWidgetPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetPopulatePopupMap, connectionID)
}

//export appchooserwidget_populatePopupHandler
func appchooserwidget_populatePopupHandler(_ *C.GObject, c_menu *C.GtkMenu, c_application *C.GAppInfo, data C.gpointer) {
	menu := MenuNewFromC(unsafe.Pointer(c_menu))

	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetPopulatePopupMap[index].callback
	callback(menu, application)
}

// Sets the text that is shown if there are not applications
// that can handle the content type.
/*

C function : gtk_app_chooser_widget_set_default_text
*/
func (recv *AppChooserWidget) SetDefaultText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_app_chooser_widget_set_default_text((*C.GtkAppChooserWidget)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserWidget
func (recv *AppChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserWidget
func (recv *AppChooserWidget) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserWidget
func (recv *AppChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by AppChooserWidget
func (recv *AppChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Application is a wrapper around the C record GtkApplication.
type Application struct {
	native *C.GtkApplication
	// parent : record
	// Private : priv
}

func ApplicationNewFromC(u unsafe.Pointer) *Application {
	c := (*C.GtkApplication)(u)
	if c == nil {
		return nil
	}

	g := &Application{native: c}

	return g
}

func (recv *Application) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Application upcasts to *Application
func (recv *Application) Application() *gio.Application {
	return gio.ApplicationNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Application) Object() *gobject.Object {
	return recv.Application().Object()
}

// CastToWidget down casts any arbitary Object to Application.
// Exercise care, as this is a potentially dangerous function if the Object is not a Application.
func CastToApplication(object *gobject.Object) *Application {
	return ApplicationNewFromC(object.ToC())
}

// ActionGroup returns the ActionGroup interface implemented by Application
func (recv *Application) ActionGroup() *gio.ActionGroup {
	return gio.ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by Application
func (recv *Application) ActionMap() *gio.ActionMap {
	return gio.ActionMapNewFromC(recv.ToC())
}

// ApplicationWindow is a wrapper around the C record GtkApplicationWindow.
type ApplicationWindow struct {
	native *C.GtkApplicationWindow
	// parent_instance : record
	// Private : priv
}

func ApplicationWindowNewFromC(u unsafe.Pointer) *ApplicationWindow {
	c := (*C.GtkApplicationWindow)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationWindow{native: c}

	return g
}

func (recv *ApplicationWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Window upcasts to *Window
func (recv *ApplicationWindow) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ApplicationWindow) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *ApplicationWindow) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *ApplicationWindow) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ApplicationWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ApplicationWindow) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitary Object to ApplicationWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ApplicationWindow.
func CastToApplicationWindow(object *gobject.Object) *ApplicationWindow {
	return ApplicationWindowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// ActionGroup returns the ActionGroup interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ActionGroup() *gio.ActionGroup {
	return gio.ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ActionMap() *gio.ActionMap {
	return gio.ActionMapNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ApplicationWindow
func (recv *ApplicationWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Arrow is a wrapper around the C record GtkArrow.
type Arrow struct {
	native *C.GtkArrow
	// misc : record
	// Private : priv
}

func ArrowNewFromC(u unsafe.Pointer) *Arrow {
	c := (*C.GtkArrow)(u)
	if c == nil {
		return nil
	}

	g := &Arrow{native: c}

	return g
}

func (recv *Arrow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Misc upcasts to *Misc
func (recv *Arrow) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Arrow) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Arrow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Arrow) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitary Object to Arrow.
// Exercise care, as this is a potentially dangerous function if the Object is not a Arrow.
func CastToArrow(object *gobject.Object) *Arrow {
	return ArrowNewFromC(object.ToC())
}

// Creates a new #GtkArrow widget.
/*

C function : gtk_arrow_new
*/
func ArrowNew(arrowType ArrowType, shadowType ShadowType) *Arrow {
	c_arrow_type := (C.GtkArrowType)(arrowType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	retC := C.gtk_arrow_new(c_arrow_type, c_shadow_type)
	retGo := ArrowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the direction and style of the #GtkArrow, @arrow.
/*

C function : gtk_arrow_set
*/
func (recv *Arrow) Set(arrowType ArrowType, shadowType ShadowType) {
	c_arrow_type := (C.GtkArrowType)(arrowType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	C.gtk_arrow_set((*C.GtkArrow)(recv.native), c_arrow_type, c_shadow_type)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Arrow
func (recv *Arrow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Arrow
func (recv *Arrow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ArrowAccessible is a wrapper around the C record GtkArrowAccessible.
type ArrowAccessible struct {
	native *C.GtkArrowAccessible
	// parent : record
	// priv : record
}

func ArrowAccessibleNewFromC(u unsafe.Pointer) *ArrowAccessible {
	c := (*C.GtkArrowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ArrowAccessible{native: c}

	return g
}

func (recv *ArrowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ArrowAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ArrowAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ArrowAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ArrowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ArrowAccessible.
func CastToArrowAccessible(object *gobject.Object) *ArrowAccessible {
	return ArrowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ArrowAccessible
func (recv *ArrowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ArrowAccessible
func (recv *ArrowAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// AspectFrame is a wrapper around the C record GtkAspectFrame.
type AspectFrame struct {
	native *C.GtkAspectFrame
	// frame : record
	// Private : priv
}

func AspectFrameNewFromC(u unsafe.Pointer) *AspectFrame {
	c := (*C.GtkAspectFrame)(u)
	if c == nil {
		return nil
	}

	g := &AspectFrame{native: c}

	return g
}

func (recv *AspectFrame) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Frame upcasts to *Frame
func (recv *AspectFrame) Frame() *Frame {
	return FrameNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *AspectFrame) Bin() *Bin {
	return recv.Frame().Bin()
}

// Container upcasts to *Container
func (recv *AspectFrame) Container() *Container {
	return recv.Frame().Container()
}

// Widget upcasts to *Widget
func (recv *AspectFrame) Widget() *Widget {
	return recv.Frame().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AspectFrame) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Frame().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AspectFrame) Object() *gobject.Object {
	return recv.Frame().Object()
}

// CastToWidget down casts any arbitary Object to AspectFrame.
// Exercise care, as this is a potentially dangerous function if the Object is not a AspectFrame.
func CastToAspectFrame(object *gobject.Object) *AspectFrame {
	return AspectFrameNewFromC(object.ToC())
}

// Create a new #GtkAspectFrame.
/*

C function : gtk_aspect_frame_new
*/
func AspectFrameNew(label string, xalign float32, yalign float32, ratio float32, obeyChild bool) *AspectFrame {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_ratio := (C.gfloat)(ratio)

	c_obey_child :=
		boolToGboolean(obeyChild)

	retC := C.gtk_aspect_frame_new(c_label, c_xalign, c_yalign, c_ratio, c_obey_child)
	retGo := AspectFrameNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Set parameters for an existing #GtkAspectFrame.
/*

C function : gtk_aspect_frame_set
*/
func (recv *AspectFrame) Set(xalign float32, yalign float32, ratio float32, obeyChild bool) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_ratio := (C.gfloat)(ratio)

	c_obey_child :=
		boolToGboolean(obeyChild)

	C.gtk_aspect_frame_set((*C.GtkAspectFrame)(recv.native), c_xalign, c_yalign, c_ratio, c_obey_child)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AspectFrame
func (recv *AspectFrame) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AspectFrame
func (recv *AspectFrame) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Assistant is a wrapper around the C record GtkAssistant.
type Assistant struct {
	native *C.GtkAssistant
	// parent : record
	// Private : priv
}

func AssistantNewFromC(u unsafe.Pointer) *Assistant {
	c := (*C.GtkAssistant)(u)
	if c == nil {
		return nil
	}

	g := &Assistant{native: c}

	return g
}

func (recv *Assistant) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Window upcasts to *Window
func (recv *Assistant) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *Assistant) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *Assistant) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *Assistant) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Assistant) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Assistant) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitary Object to Assistant.
// Exercise care, as this is a potentially dangerous function if the Object is not a Assistant.
func CastToAssistant(object *gobject.Object) *Assistant {
	return AssistantNewFromC(object.ToC())
}

type signalAssistantEscapeDetail struct {
	callback  AssistantSignalEscapeCallback
	handlerID C.gulong
}

var signalAssistantEscapeId int
var signalAssistantEscapeMap = make(map[int]signalAssistantEscapeDetail)
var signalAssistantEscapeLock sync.Mutex

// AssistantSignalEscapeCallback is a callback function for a 'escape' signal emitted from a Assistant.
type AssistantSignalEscapeCallback func()

/*
ConnectEscape connects the callback to the 'escape' signal for the Assistant.

The returned value represents the connection, and may be passed to DisconnectEscape to remove it.
*/
func (recv *Assistant) ConnectEscape(callback AssistantSignalEscapeCallback) int {
	signalAssistantEscapeLock.Lock()
	defer signalAssistantEscapeLock.Unlock()

	signalAssistantEscapeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Assistant_signal_connect_escape(instance, C.gpointer(uintptr(signalAssistantEscapeId)))

	detail := signalAssistantEscapeDetail{callback, handlerID}
	signalAssistantEscapeMap[signalAssistantEscapeId] = detail

	return signalAssistantEscapeId
}

/*
DisconnectEscape disconnects a callback from the 'escape' signal for the Assistant.

The connectionID should be a value returned from a call to ConnectEscape.
*/
func (recv *Assistant) DisconnectEscape(connectionID int) {
	signalAssistantEscapeLock.Lock()
	defer signalAssistantEscapeLock.Unlock()

	detail, exists := signalAssistantEscapeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAssistantEscapeMap, connectionID)
}

//export assistant_escapeHandler
func assistant_escapeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalAssistantEscapeMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Assistant
func (recv *Assistant) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Assistant
func (recv *Assistant) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Bin is a wrapper around the C record GtkBin.
type Bin struct {
	native *C.GtkBin
	// container : record
	// Private : priv
}

func BinNewFromC(u unsafe.Pointer) *Bin {
	c := (*C.GtkBin)(u)
	if c == nil {
		return nil
	}

	g := &Bin{native: c}

	return g
}

func (recv *Bin) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Bin) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Bin) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Bin) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Bin) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Bin.
// Exercise care, as this is a potentially dangerous function if the Object is not a Bin.
func CastToBin(object *gobject.Object) *Bin {
	return BinNewFromC(object.ToC())
}

// Gets the child of the #GtkBin, or %NULL if the bin contains
// no child widget. The returned widget does not have a reference
// added, so you do not need to unref it.
/*

C function : gtk_bin_get_child
*/
func (recv *Bin) GetChild() *Widget {
	retC := C.gtk_bin_get_child((*C.GtkBin)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Bin
func (recv *Bin) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Bin
func (recv *Bin) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// BooleanCellAccessible is a wrapper around the C record GtkBooleanCellAccessible.
type BooleanCellAccessible struct {
	native *C.GtkBooleanCellAccessible
	// parent : record
	// priv : record
}

func BooleanCellAccessibleNewFromC(u unsafe.Pointer) *BooleanCellAccessible {
	c := (*C.GtkBooleanCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &BooleanCellAccessible{native: c}

	return g
}

func (recv *BooleanCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *BooleanCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *BooleanCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *BooleanCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *BooleanCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to BooleanCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a BooleanCellAccessible.
func CastToBooleanCellAccessible(object *gobject.Object) *BooleanCellAccessible {
	return BooleanCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by BooleanCellAccessible
func (recv *BooleanCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by BooleanCellAccessible
func (recv *BooleanCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Box is a wrapper around the C record GtkBox.
type Box struct {
	native *C.GtkBox
	// container : record
	// Private : priv
}

func BoxNewFromC(u unsafe.Pointer) *Box {
	c := (*C.GtkBox)(u)
	if c == nil {
		return nil
	}

	g := &Box{native: c}

	return g
}

func (recv *Box) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Box) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Box) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Box) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Box) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Box.
// Exercise care, as this is a potentially dangerous function if the Object is not a Box.
func CastToBox(object *gobject.Object) *Box {
	return BoxNewFromC(object.ToC())
}

// Returns whether the box is homogeneous (all children are the
// same size). See gtk_box_set_homogeneous().
/*

C function : gtk_box_get_homogeneous
*/
func (recv *Box) GetHomogeneous() bool {
	retC := C.gtk_box_get_homogeneous((*C.GtkBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_box_set_spacing().
/*

C function : gtk_box_get_spacing
*/
func (recv *Box) GetSpacing() int32 {
	retC := C.gtk_box_get_spacing((*C.GtkBox)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Adds @child to @box, packed with reference to the end of @box.
// The @child is packed after (away from end of) any other child
// packed with reference to the end of @box.
/*

C function : gtk_box_pack_end
*/
func (recv *Box) PackEnd(child *Widget, expand bool, fill bool, padding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	C.gtk_box_pack_end((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding)

	return
}

// Adds @child to @box, packed with reference to the start of @box.
// The @child is packed after any other child packed with reference
// to the start of @box.
/*

C function : gtk_box_pack_start
*/
func (recv *Box) PackStart(child *Widget, expand bool, fill bool, padding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	C.gtk_box_pack_start((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding)

	return
}

// Unsupported : gtk_box_query_child_packing : unsupported parameter pack_type : GtkPackType* with indirection level of 1

// Moves @child to a new @position in the list of @box children.
// The list contains widgets packed #GTK_PACK_START
// as well as widgets packed #GTK_PACK_END, in the order that these
// widgets were added to @box.
//
// A widget’s position in the @box children list determines where
// the widget is packed into @box.  A child widget at some position
// in the list will be packed just after all other widgets of the
// same packing type that appear earlier in the list.
/*

C function : gtk_box_reorder_child
*/
func (recv *Box) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_box_reorder_child((*C.GtkBox)(recv.native), c_child, c_position)

	return
}

// Sets the way @child is packed into @box.
/*

C function : gtk_box_set_child_packing
*/
func (recv *Box) SetChildPacking(child *Widget, expand bool, fill bool, padding uint32, packType PackType) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	c_pack_type := (C.GtkPackType)(packType)

	C.gtk_box_set_child_packing((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding, c_pack_type)

	return
}

// Sets the #GtkBox:homogeneous property of @box, controlling
// whether or not all children of @box are given equal space
// in the box.
/*

C function : gtk_box_set_homogeneous
*/
func (recv *Box) SetHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_box_set_homogeneous((*C.GtkBox)(recv.native), c_homogeneous)

	return
}

// Sets the #GtkBox:spacing property of @box, which is the
// number of pixels to place between children of @box.
/*

C function : gtk_box_set_spacing
*/
func (recv *Box) SetSpacing(spacing int32) {
	c_spacing := (C.gint)(spacing)

	C.gtk_box_set_spacing((*C.GtkBox)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Box
func (recv *Box) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Box
func (recv *Box) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Box
func (recv *Box) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Builder is a wrapper around the C record GtkBuilder.
type Builder struct {
	native *C.GtkBuilder
	// parent_instance : record
	// priv : record
}

func BuilderNewFromC(u unsafe.Pointer) *Builder {
	c := (*C.GtkBuilder)(u)
	if c == nil {
		return nil
	}

	g := &Builder{native: c}

	return g
}

func (recv *Builder) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Builder) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Builder.
// Exercise care, as this is a potentially dangerous function if the Object is not a Builder.
func CastToBuilder(object *gobject.Object) *Builder {
	return BuilderNewFromC(object.ToC())
}

// Blacklisted : gtk_builder_extend_with_template

// Button is a wrapper around the C record GtkButton.
type Button struct {
	native *C.GtkButton
	// Private : bin
	// Private : priv
}

func ButtonNewFromC(u unsafe.Pointer) *Button {
	c := (*C.GtkButton)(u)
	if c == nil {
		return nil
	}

	g := &Button{native: c}

	return g
}

func (recv *Button) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Button) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Button) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Button) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Button) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Button) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Button.
// Exercise care, as this is a potentially dangerous function if the Object is not a Button.
func CastToButton(object *gobject.Object) *Button {
	return ButtonNewFromC(object.ToC())
}

type signalButtonActivateDetail struct {
	callback  ButtonSignalActivateCallback
	handlerID C.gulong
}

var signalButtonActivateId int
var signalButtonActivateMap = make(map[int]signalButtonActivateDetail)
var signalButtonActivateLock sync.Mutex

// ButtonSignalActivateCallback is a callback function for a 'activate' signal emitted from a Button.
type ButtonSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Button) ConnectActivate(callback ButtonSignalActivateCallback) int {
	signalButtonActivateLock.Lock()
	defer signalButtonActivateLock.Unlock()

	signalButtonActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_activate(instance, C.gpointer(uintptr(signalButtonActivateId)))

	detail := signalButtonActivateDetail{callback, handlerID}
	signalButtonActivateMap[signalButtonActivateId] = detail

	return signalButtonActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Button.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Button) DisconnectActivate(connectionID int) {
	signalButtonActivateLock.Lock()
	defer signalButtonActivateLock.Unlock()

	detail, exists := signalButtonActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonActivateMap, connectionID)
}

//export button_activateHandler
func button_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonActivateMap[index].callback
	callback()
}

type signalButtonClickedDetail struct {
	callback  ButtonSignalClickedCallback
	handlerID C.gulong
}

var signalButtonClickedId int
var signalButtonClickedMap = make(map[int]signalButtonClickedDetail)
var signalButtonClickedLock sync.Mutex

// ButtonSignalClickedCallback is a callback function for a 'clicked' signal emitted from a Button.
type ButtonSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *Button) ConnectClicked(callback ButtonSignalClickedCallback) int {
	signalButtonClickedLock.Lock()
	defer signalButtonClickedLock.Unlock()

	signalButtonClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_clicked(instance, C.gpointer(uintptr(signalButtonClickedId)))

	detail := signalButtonClickedDetail{callback, handlerID}
	signalButtonClickedMap[signalButtonClickedId] = detail

	return signalButtonClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the Button.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *Button) DisconnectClicked(connectionID int) {
	signalButtonClickedLock.Lock()
	defer signalButtonClickedLock.Unlock()

	detail, exists := signalButtonClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonClickedMap, connectionID)
}

//export button_clickedHandler
func button_clickedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonClickedMap[index].callback
	callback()
}

type signalButtonEnterDetail struct {
	callback  ButtonSignalEnterCallback
	handlerID C.gulong
}

var signalButtonEnterId int
var signalButtonEnterMap = make(map[int]signalButtonEnterDetail)
var signalButtonEnterLock sync.Mutex

// ButtonSignalEnterCallback is a callback function for a 'enter' signal emitted from a Button.
type ButtonSignalEnterCallback func()

/*
ConnectEnter connects the callback to the 'enter' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectEnter to remove it.
*/
func (recv *Button) ConnectEnter(callback ButtonSignalEnterCallback) int {
	signalButtonEnterLock.Lock()
	defer signalButtonEnterLock.Unlock()

	signalButtonEnterId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_enter(instance, C.gpointer(uintptr(signalButtonEnterId)))

	detail := signalButtonEnterDetail{callback, handlerID}
	signalButtonEnterMap[signalButtonEnterId] = detail

	return signalButtonEnterId
}

/*
DisconnectEnter disconnects a callback from the 'enter' signal for the Button.

The connectionID should be a value returned from a call to ConnectEnter.
*/
func (recv *Button) DisconnectEnter(connectionID int) {
	signalButtonEnterLock.Lock()
	defer signalButtonEnterLock.Unlock()

	detail, exists := signalButtonEnterMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonEnterMap, connectionID)
}

//export button_enterHandler
func button_enterHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonEnterMap[index].callback
	callback()
}

type signalButtonLeaveDetail struct {
	callback  ButtonSignalLeaveCallback
	handlerID C.gulong
}

var signalButtonLeaveId int
var signalButtonLeaveMap = make(map[int]signalButtonLeaveDetail)
var signalButtonLeaveLock sync.Mutex

// ButtonSignalLeaveCallback is a callback function for a 'leave' signal emitted from a Button.
type ButtonSignalLeaveCallback func()

/*
ConnectLeave connects the callback to the 'leave' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectLeave to remove it.
*/
func (recv *Button) ConnectLeave(callback ButtonSignalLeaveCallback) int {
	signalButtonLeaveLock.Lock()
	defer signalButtonLeaveLock.Unlock()

	signalButtonLeaveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_leave(instance, C.gpointer(uintptr(signalButtonLeaveId)))

	detail := signalButtonLeaveDetail{callback, handlerID}
	signalButtonLeaveMap[signalButtonLeaveId] = detail

	return signalButtonLeaveId
}

/*
DisconnectLeave disconnects a callback from the 'leave' signal for the Button.

The connectionID should be a value returned from a call to ConnectLeave.
*/
func (recv *Button) DisconnectLeave(connectionID int) {
	signalButtonLeaveLock.Lock()
	defer signalButtonLeaveLock.Unlock()

	detail, exists := signalButtonLeaveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonLeaveMap, connectionID)
}

//export button_leaveHandler
func button_leaveHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonLeaveMap[index].callback
	callback()
}

type signalButtonPressedDetail struct {
	callback  ButtonSignalPressedCallback
	handlerID C.gulong
}

var signalButtonPressedId int
var signalButtonPressedMap = make(map[int]signalButtonPressedDetail)
var signalButtonPressedLock sync.Mutex

// ButtonSignalPressedCallback is a callback function for a 'pressed' signal emitted from a Button.
type ButtonSignalPressedCallback func()

/*
ConnectPressed connects the callback to the 'pressed' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectPressed to remove it.
*/
func (recv *Button) ConnectPressed(callback ButtonSignalPressedCallback) int {
	signalButtonPressedLock.Lock()
	defer signalButtonPressedLock.Unlock()

	signalButtonPressedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_pressed(instance, C.gpointer(uintptr(signalButtonPressedId)))

	detail := signalButtonPressedDetail{callback, handlerID}
	signalButtonPressedMap[signalButtonPressedId] = detail

	return signalButtonPressedId
}

/*
DisconnectPressed disconnects a callback from the 'pressed' signal for the Button.

The connectionID should be a value returned from a call to ConnectPressed.
*/
func (recv *Button) DisconnectPressed(connectionID int) {
	signalButtonPressedLock.Lock()
	defer signalButtonPressedLock.Unlock()

	detail, exists := signalButtonPressedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonPressedMap, connectionID)
}

//export button_pressedHandler
func button_pressedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonPressedMap[index].callback
	callback()
}

type signalButtonReleasedDetail struct {
	callback  ButtonSignalReleasedCallback
	handlerID C.gulong
}

var signalButtonReleasedId int
var signalButtonReleasedMap = make(map[int]signalButtonReleasedDetail)
var signalButtonReleasedLock sync.Mutex

// ButtonSignalReleasedCallback is a callback function for a 'released' signal emitted from a Button.
type ButtonSignalReleasedCallback func()

/*
ConnectReleased connects the callback to the 'released' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectReleased to remove it.
*/
func (recv *Button) ConnectReleased(callback ButtonSignalReleasedCallback) int {
	signalButtonReleasedLock.Lock()
	defer signalButtonReleasedLock.Unlock()

	signalButtonReleasedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_released(instance, C.gpointer(uintptr(signalButtonReleasedId)))

	detail := signalButtonReleasedDetail{callback, handlerID}
	signalButtonReleasedMap[signalButtonReleasedId] = detail

	return signalButtonReleasedId
}

/*
DisconnectReleased disconnects a callback from the 'released' signal for the Button.

The connectionID should be a value returned from a call to ConnectReleased.
*/
func (recv *Button) DisconnectReleased(connectionID int) {
	signalButtonReleasedLock.Lock()
	defer signalButtonReleasedLock.Unlock()

	detail, exists := signalButtonReleasedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonReleasedMap, connectionID)
}

//export button_releasedHandler
func button_releasedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalButtonReleasedMap[index].callback
	callback()
}

// Creates a new #GtkButton widget. To add a child widget to the button,
// use gtk_container_add().
/*

C function : gtk_button_new
*/
func ButtonNew() *Button {
	retC := C.gtk_button_new()
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkButton containing the image and text from a stock item.
// Some stock ids have preprocessor macros like #GTK_STOCK_OK and
// #GTK_STOCK_APPLY.
//
// If @stock_id is unknown, then it will be treated as a mnemonic
// label (as for gtk_button_new_with_mnemonic()).
/*

C function : gtk_button_new_from_stock
*/
func ButtonNewFromStock(stockId string) *Button {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_button_new_from_stock(c_stock_id)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a #GtkButton widget with a #GtkLabel child containing the given
// text.
/*

C function : gtk_button_new_with_label
*/
func ButtonNewWithLabel(label string) *Button {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_button_new_with_label(c_label)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkButton containing a label.
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
// Pressing Alt and that key activates the button.
/*

C function : gtk_button_new_with_mnemonic
*/
func ButtonNewWithMnemonic(label string) *Button {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_button_new_with_mnemonic(c_label)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Emits a #GtkButton::clicked signal to the given #GtkButton.
/*

C function : gtk_button_clicked
*/
func (recv *Button) Clicked() {
	C.gtk_button_clicked((*C.GtkButton)(recv.native))

	return
}

// Emits a #GtkButton::enter signal to the given #GtkButton.
/*

C function : gtk_button_enter
*/
func (recv *Button) Enter() {
	C.gtk_button_enter((*C.GtkButton)(recv.native))

	return
}

// Fetches the text from the label of the button, as set by
// gtk_button_set_label(). If the label text has not
// been set the return value will be %NULL. This will be the
// case if you create an empty button with gtk_button_new() to
// use as a container.
/*

C function : gtk_button_get_label
*/
func (recv *Button) GetLabel() string {
	retC := C.gtk_button_get_label((*C.GtkButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Returns the current relief style of the given #GtkButton.
/*

C function : gtk_button_get_relief
*/
func (recv *Button) GetRelief() ReliefStyle {
	retC := C.gtk_button_get_relief((*C.GtkButton)(recv.native))
	retGo := (ReliefStyle)(retC)

	return retGo
}

// Returns whether the button label is a stock item.
/*

C function : gtk_button_get_use_stock
*/
func (recv *Button) GetUseStock() bool {
	retC := C.gtk_button_get_use_stock((*C.GtkButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether an embedded underline in the button label indicates a
// mnemonic. See gtk_button_set_use_underline ().
/*

C function : gtk_button_get_use_underline
*/
func (recv *Button) GetUseUnderline() bool {
	retC := C.gtk_button_get_use_underline((*C.GtkButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Emits a #GtkButton::leave signal to the given #GtkButton.
/*

C function : gtk_button_leave
*/
func (recv *Button) Leave() {
	C.gtk_button_leave((*C.GtkButton)(recv.native))

	return
}

// Emits a #GtkButton::pressed signal to the given #GtkButton.
/*

C function : gtk_button_pressed
*/
func (recv *Button) Pressed() {
	C.gtk_button_pressed((*C.GtkButton)(recv.native))

	return
}

// Emits a #GtkButton::released signal to the given #GtkButton.
/*

C function : gtk_button_released
*/
func (recv *Button) Released() {
	C.gtk_button_released((*C.GtkButton)(recv.native))

	return
}

// Sets the text of the label of the button to @str. This text is
// also used to select the stock item if gtk_button_set_use_stock()
// is used.
//
// This will also clear any previously set labels.
/*

C function : gtk_button_set_label
*/
func (recv *Button) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_button_set_label((*C.GtkButton)(recv.native), c_label)

	return
}

// Sets the relief style of the edges of the given #GtkButton widget.
// Two styles exist, %GTK_RELIEF_NORMAL and %GTK_RELIEF_NONE.
// The default style is, as one can guess, %GTK_RELIEF_NORMAL.
// The deprecated value %GTK_RELIEF_HALF behaves the same as
// %GTK_RELIEF_NORMAL.
/*

C function : gtk_button_set_relief
*/
func (recv *Button) SetRelief(relief ReliefStyle) {
	c_relief := (C.GtkReliefStyle)(relief)

	C.gtk_button_set_relief((*C.GtkButton)(recv.native), c_relief)

	return
}

// If %TRUE, the label set on the button is used as a
// stock id to select the stock item for the button.
/*

C function : gtk_button_set_use_stock
*/
func (recv *Button) SetUseStock(useStock bool) {
	c_use_stock :=
		boolToGboolean(useStock)

	C.gtk_button_set_use_stock((*C.GtkButton)(recv.native), c_use_stock)

	return
}

// If true, an underline in the text of the button label indicates
// the next character should be used for the mnemonic accelerator key.
/*

C function : gtk_button_set_use_underline
*/
func (recv *Button) SetUseUnderline(useUnderline bool) {
	c_use_underline :=
		boolToGboolean(useUnderline)

	C.gtk_button_set_use_underline((*C.GtkButton)(recv.native), c_use_underline)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Button
func (recv *Button) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by Button
func (recv *Button) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by Button
func (recv *Button) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Button
func (recv *Button) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ButtonAccessible is a wrapper around the C record GtkButtonAccessible.
type ButtonAccessible struct {
	native *C.GtkButtonAccessible
	// parent : record
	// priv : record
}

func ButtonAccessibleNewFromC(u unsafe.Pointer) *ButtonAccessible {
	c := (*C.GtkButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ButtonAccessible{native: c}

	return g
}

func (recv *ButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ButtonAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ButtonAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ButtonAccessible.
func CastToButtonAccessible(object *gobject.Object) *ButtonAccessible {
	return ButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ButtonBox is a wrapper around the C record GtkButtonBox.
type ButtonBox struct {
	native *C.GtkButtonBox
	// box : record
	// Private : priv
}

func ButtonBoxNewFromC(u unsafe.Pointer) *ButtonBox {
	c := (*C.GtkButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &ButtonBox{native: c}

	return g
}

func (recv *ButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *ButtonBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ButtonBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ButtonBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ButtonBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to ButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ButtonBox.
func CastToButtonBox(object *gobject.Object) *ButtonBox {
	return ButtonBoxNewFromC(object.ToC())
}

// Retrieves the method being used to arrange the buttons in a button box.
/*

C function : gtk_button_box_get_layout
*/
func (recv *ButtonBox) GetLayout() ButtonBoxStyle {
	retC := C.gtk_button_box_get_layout((*C.GtkButtonBox)(recv.native))
	retGo := (ButtonBoxStyle)(retC)

	return retGo
}

// Sets whether @child should appear in a secondary group of children.
// A typical use of a secondary child is the help button in a dialog.
//
// This group appears after the other children if the style
// is %GTK_BUTTONBOX_START, %GTK_BUTTONBOX_SPREAD or
// %GTK_BUTTONBOX_EDGE, and before the other children if the style
// is %GTK_BUTTONBOX_END. For horizontal button boxes, the definition
// of before/after depends on direction of the widget (see
// gtk_widget_set_direction()). If the style is %GTK_BUTTONBOX_START
// or %GTK_BUTTONBOX_END, then the secondary children are aligned at
// the other end of the button box from the main children. For the
// other styles, they appear immediately next to the main children.
/*

C function : gtk_button_box_set_child_secondary
*/
func (recv *ButtonBox) SetChildSecondary(child *Widget, isSecondary bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_is_secondary :=
		boolToGboolean(isSecondary)

	C.gtk_button_box_set_child_secondary((*C.GtkButtonBox)(recv.native), c_child, c_is_secondary)

	return
}

// Changes the way buttons are arranged in their container.
/*

C function : gtk_button_box_set_layout
*/
func (recv *ButtonBox) SetLayout(layoutStyle ButtonBoxStyle) {
	c_layout_style := (C.GtkButtonBoxStyle)(layoutStyle)

	C.gtk_button_box_set_layout((*C.GtkButtonBox)(recv.native), c_layout_style)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ButtonBox
func (recv *ButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ButtonBox
func (recv *ButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ButtonBox
func (recv *ButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Calendar is a wrapper around the C record GtkCalendar.
type Calendar struct {
	native *C.GtkCalendar
	// widget : record
	// priv : record
}

func CalendarNewFromC(u unsafe.Pointer) *Calendar {
	c := (*C.GtkCalendar)(u)
	if c == nil {
		return nil
	}

	g := &Calendar{native: c}

	return g
}

func (recv *Calendar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Calendar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Calendar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Calendar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Calendar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Calendar.
func CastToCalendar(object *gobject.Object) *Calendar {
	return CalendarNewFromC(object.ToC())
}

type signalCalendarDaySelectedDetail struct {
	callback  CalendarSignalDaySelectedCallback
	handlerID C.gulong
}

var signalCalendarDaySelectedId int
var signalCalendarDaySelectedMap = make(map[int]signalCalendarDaySelectedDetail)
var signalCalendarDaySelectedLock sync.Mutex

// CalendarSignalDaySelectedCallback is a callback function for a 'day-selected' signal emitted from a Calendar.
type CalendarSignalDaySelectedCallback func()

/*
ConnectDaySelected connects the callback to the 'day-selected' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectDaySelected to remove it.
*/
func (recv *Calendar) ConnectDaySelected(callback CalendarSignalDaySelectedCallback) int {
	signalCalendarDaySelectedLock.Lock()
	defer signalCalendarDaySelectedLock.Unlock()

	signalCalendarDaySelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_day_selected(instance, C.gpointer(uintptr(signalCalendarDaySelectedId)))

	detail := signalCalendarDaySelectedDetail{callback, handlerID}
	signalCalendarDaySelectedMap[signalCalendarDaySelectedId] = detail

	return signalCalendarDaySelectedId
}

/*
DisconnectDaySelected disconnects a callback from the 'day-selected' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectDaySelected.
*/
func (recv *Calendar) DisconnectDaySelected(connectionID int) {
	signalCalendarDaySelectedLock.Lock()
	defer signalCalendarDaySelectedLock.Unlock()

	detail, exists := signalCalendarDaySelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarDaySelectedMap, connectionID)
}

//export calendar_daySelectedHandler
func calendar_daySelectedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarDaySelectedMap[index].callback
	callback()
}

type signalCalendarDaySelectedDoubleClickDetail struct {
	callback  CalendarSignalDaySelectedDoubleClickCallback
	handlerID C.gulong
}

var signalCalendarDaySelectedDoubleClickId int
var signalCalendarDaySelectedDoubleClickMap = make(map[int]signalCalendarDaySelectedDoubleClickDetail)
var signalCalendarDaySelectedDoubleClickLock sync.Mutex

// CalendarSignalDaySelectedDoubleClickCallback is a callback function for a 'day-selected-double-click' signal emitted from a Calendar.
type CalendarSignalDaySelectedDoubleClickCallback func()

/*
ConnectDaySelectedDoubleClick connects the callback to the 'day-selected-double-click' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectDaySelectedDoubleClick to remove it.
*/
func (recv *Calendar) ConnectDaySelectedDoubleClick(callback CalendarSignalDaySelectedDoubleClickCallback) int {
	signalCalendarDaySelectedDoubleClickLock.Lock()
	defer signalCalendarDaySelectedDoubleClickLock.Unlock()

	signalCalendarDaySelectedDoubleClickId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_day_selected_double_click(instance, C.gpointer(uintptr(signalCalendarDaySelectedDoubleClickId)))

	detail := signalCalendarDaySelectedDoubleClickDetail{callback, handlerID}
	signalCalendarDaySelectedDoubleClickMap[signalCalendarDaySelectedDoubleClickId] = detail

	return signalCalendarDaySelectedDoubleClickId
}

/*
DisconnectDaySelectedDoubleClick disconnects a callback from the 'day-selected-double-click' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectDaySelectedDoubleClick.
*/
func (recv *Calendar) DisconnectDaySelectedDoubleClick(connectionID int) {
	signalCalendarDaySelectedDoubleClickLock.Lock()
	defer signalCalendarDaySelectedDoubleClickLock.Unlock()

	detail, exists := signalCalendarDaySelectedDoubleClickMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarDaySelectedDoubleClickMap, connectionID)
}

//export calendar_daySelectedDoubleClickHandler
func calendar_daySelectedDoubleClickHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarDaySelectedDoubleClickMap[index].callback
	callback()
}

type signalCalendarMonthChangedDetail struct {
	callback  CalendarSignalMonthChangedCallback
	handlerID C.gulong
}

var signalCalendarMonthChangedId int
var signalCalendarMonthChangedMap = make(map[int]signalCalendarMonthChangedDetail)
var signalCalendarMonthChangedLock sync.Mutex

// CalendarSignalMonthChangedCallback is a callback function for a 'month-changed' signal emitted from a Calendar.
type CalendarSignalMonthChangedCallback func()

/*
ConnectMonthChanged connects the callback to the 'month-changed' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectMonthChanged to remove it.
*/
func (recv *Calendar) ConnectMonthChanged(callback CalendarSignalMonthChangedCallback) int {
	signalCalendarMonthChangedLock.Lock()
	defer signalCalendarMonthChangedLock.Unlock()

	signalCalendarMonthChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_month_changed(instance, C.gpointer(uintptr(signalCalendarMonthChangedId)))

	detail := signalCalendarMonthChangedDetail{callback, handlerID}
	signalCalendarMonthChangedMap[signalCalendarMonthChangedId] = detail

	return signalCalendarMonthChangedId
}

/*
DisconnectMonthChanged disconnects a callback from the 'month-changed' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectMonthChanged.
*/
func (recv *Calendar) DisconnectMonthChanged(connectionID int) {
	signalCalendarMonthChangedLock.Lock()
	defer signalCalendarMonthChangedLock.Unlock()

	detail, exists := signalCalendarMonthChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarMonthChangedMap, connectionID)
}

//export calendar_monthChangedHandler
func calendar_monthChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarMonthChangedMap[index].callback
	callback()
}

type signalCalendarNextMonthDetail struct {
	callback  CalendarSignalNextMonthCallback
	handlerID C.gulong
}

var signalCalendarNextMonthId int
var signalCalendarNextMonthMap = make(map[int]signalCalendarNextMonthDetail)
var signalCalendarNextMonthLock sync.Mutex

// CalendarSignalNextMonthCallback is a callback function for a 'next-month' signal emitted from a Calendar.
type CalendarSignalNextMonthCallback func()

/*
ConnectNextMonth connects the callback to the 'next-month' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectNextMonth to remove it.
*/
func (recv *Calendar) ConnectNextMonth(callback CalendarSignalNextMonthCallback) int {
	signalCalendarNextMonthLock.Lock()
	defer signalCalendarNextMonthLock.Unlock()

	signalCalendarNextMonthId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_next_month(instance, C.gpointer(uintptr(signalCalendarNextMonthId)))

	detail := signalCalendarNextMonthDetail{callback, handlerID}
	signalCalendarNextMonthMap[signalCalendarNextMonthId] = detail

	return signalCalendarNextMonthId
}

/*
DisconnectNextMonth disconnects a callback from the 'next-month' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectNextMonth.
*/
func (recv *Calendar) DisconnectNextMonth(connectionID int) {
	signalCalendarNextMonthLock.Lock()
	defer signalCalendarNextMonthLock.Unlock()

	detail, exists := signalCalendarNextMonthMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarNextMonthMap, connectionID)
}

//export calendar_nextMonthHandler
func calendar_nextMonthHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarNextMonthMap[index].callback
	callback()
}

type signalCalendarNextYearDetail struct {
	callback  CalendarSignalNextYearCallback
	handlerID C.gulong
}

var signalCalendarNextYearId int
var signalCalendarNextYearMap = make(map[int]signalCalendarNextYearDetail)
var signalCalendarNextYearLock sync.Mutex

// CalendarSignalNextYearCallback is a callback function for a 'next-year' signal emitted from a Calendar.
type CalendarSignalNextYearCallback func()

/*
ConnectNextYear connects the callback to the 'next-year' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectNextYear to remove it.
*/
func (recv *Calendar) ConnectNextYear(callback CalendarSignalNextYearCallback) int {
	signalCalendarNextYearLock.Lock()
	defer signalCalendarNextYearLock.Unlock()

	signalCalendarNextYearId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_next_year(instance, C.gpointer(uintptr(signalCalendarNextYearId)))

	detail := signalCalendarNextYearDetail{callback, handlerID}
	signalCalendarNextYearMap[signalCalendarNextYearId] = detail

	return signalCalendarNextYearId
}

/*
DisconnectNextYear disconnects a callback from the 'next-year' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectNextYear.
*/
func (recv *Calendar) DisconnectNextYear(connectionID int) {
	signalCalendarNextYearLock.Lock()
	defer signalCalendarNextYearLock.Unlock()

	detail, exists := signalCalendarNextYearMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarNextYearMap, connectionID)
}

//export calendar_nextYearHandler
func calendar_nextYearHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarNextYearMap[index].callback
	callback()
}

type signalCalendarPrevMonthDetail struct {
	callback  CalendarSignalPrevMonthCallback
	handlerID C.gulong
}

var signalCalendarPrevMonthId int
var signalCalendarPrevMonthMap = make(map[int]signalCalendarPrevMonthDetail)
var signalCalendarPrevMonthLock sync.Mutex

// CalendarSignalPrevMonthCallback is a callback function for a 'prev-month' signal emitted from a Calendar.
type CalendarSignalPrevMonthCallback func()

/*
ConnectPrevMonth connects the callback to the 'prev-month' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectPrevMonth to remove it.
*/
func (recv *Calendar) ConnectPrevMonth(callback CalendarSignalPrevMonthCallback) int {
	signalCalendarPrevMonthLock.Lock()
	defer signalCalendarPrevMonthLock.Unlock()

	signalCalendarPrevMonthId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_prev_month(instance, C.gpointer(uintptr(signalCalendarPrevMonthId)))

	detail := signalCalendarPrevMonthDetail{callback, handlerID}
	signalCalendarPrevMonthMap[signalCalendarPrevMonthId] = detail

	return signalCalendarPrevMonthId
}

/*
DisconnectPrevMonth disconnects a callback from the 'prev-month' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectPrevMonth.
*/
func (recv *Calendar) DisconnectPrevMonth(connectionID int) {
	signalCalendarPrevMonthLock.Lock()
	defer signalCalendarPrevMonthLock.Unlock()

	detail, exists := signalCalendarPrevMonthMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarPrevMonthMap, connectionID)
}

//export calendar_prevMonthHandler
func calendar_prevMonthHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarPrevMonthMap[index].callback
	callback()
}

type signalCalendarPrevYearDetail struct {
	callback  CalendarSignalPrevYearCallback
	handlerID C.gulong
}

var signalCalendarPrevYearId int
var signalCalendarPrevYearMap = make(map[int]signalCalendarPrevYearDetail)
var signalCalendarPrevYearLock sync.Mutex

// CalendarSignalPrevYearCallback is a callback function for a 'prev-year' signal emitted from a Calendar.
type CalendarSignalPrevYearCallback func()

/*
ConnectPrevYear connects the callback to the 'prev-year' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectPrevYear to remove it.
*/
func (recv *Calendar) ConnectPrevYear(callback CalendarSignalPrevYearCallback) int {
	signalCalendarPrevYearLock.Lock()
	defer signalCalendarPrevYearLock.Unlock()

	signalCalendarPrevYearId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_prev_year(instance, C.gpointer(uintptr(signalCalendarPrevYearId)))

	detail := signalCalendarPrevYearDetail{callback, handlerID}
	signalCalendarPrevYearMap[signalCalendarPrevYearId] = detail

	return signalCalendarPrevYearId
}

/*
DisconnectPrevYear disconnects a callback from the 'prev-year' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectPrevYear.
*/
func (recv *Calendar) DisconnectPrevYear(connectionID int) {
	signalCalendarPrevYearLock.Lock()
	defer signalCalendarPrevYearLock.Unlock()

	detail, exists := signalCalendarPrevYearMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarPrevYearMap, connectionID)
}

//export calendar_prevYearHandler
func calendar_prevYearHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCalendarPrevYearMap[index].callback
	callback()
}

// Creates a new calendar, with the current date being selected.
/*

C function : gtk_calendar_new
*/
func CalendarNew() *Calendar {
	retC := C.gtk_calendar_new()
	retGo := CalendarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Remove all visual markers.
/*

C function : gtk_calendar_clear_marks
*/
func (recv *Calendar) ClearMarks() {
	C.gtk_calendar_clear_marks((*C.GtkCalendar)(recv.native))

	return
}

// Obtains the selected date from a #GtkCalendar.
/*

C function : gtk_calendar_get_date
*/
func (recv *Calendar) GetDate() (uint32, uint32, uint32) {
	var c_year C.guint

	var c_month C.guint

	var c_day C.guint

	C.gtk_calendar_get_date((*C.GtkCalendar)(recv.native), &c_year, &c_month, &c_day)

	year := (uint32)(c_year)

	month := (uint32)(c_month)

	day := (uint32)(c_day)

	return year, month, day
}

// Places a visual marker on a particular day.
/*

C function : gtk_calendar_mark_day
*/
func (recv *Calendar) MarkDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_mark_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// Selects a day from the current month.
/*

C function : gtk_calendar_select_day
*/
func (recv *Calendar) SelectDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_select_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// Shifts the calendar to a different month.
/*

C function : gtk_calendar_select_month
*/
func (recv *Calendar) SelectMonth(month uint32, year uint32) {
	c_month := (C.guint)(month)

	c_year := (C.guint)(year)

	C.gtk_calendar_select_month((*C.GtkCalendar)(recv.native), c_month, c_year)

	return
}

// Removes the visual marker from a particular day.
/*

C function : gtk_calendar_unmark_day
*/
func (recv *Calendar) UnmarkDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_unmark_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Calendar
func (recv *Calendar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Calendar
func (recv *Calendar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellAccessible is a wrapper around the C record GtkCellAccessible.
type CellAccessible struct {
	native *C.GtkCellAccessible
	// parent : record
	// priv : record
}

func CellAccessibleNewFromC(u unsafe.Pointer) *CellAccessible {
	c := (*C.GtkCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &CellAccessible{native: c}

	return g
}

func (recv *CellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Accessible upcasts to *Accessible
func (recv *CellAccessible) Accessible() *Accessible {
	return AccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellAccessible) Object() *atk.Object {
	return recv.Accessible().Object()
}

// CastToWidget down casts any arbitary Object to CellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAccessible.
func CastToCellAccessible(object *gobject.Object) *CellAccessible {
	return CellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by CellAccessible
func (recv *CellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by CellAccessible
func (recv *CellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// CellArea is a wrapper around the C record GtkCellArea.
type CellArea struct {
	native *C.GtkCellArea
	// Private : parent_instance
	// Private : priv
}

func CellAreaNewFromC(u unsafe.Pointer) *CellArea {
	c := (*C.GtkCellArea)(u)
	if c == nil {
		return nil
	}

	g := &CellArea{native: c}

	return g
}

func (recv *CellArea) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellArea) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellArea) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to CellArea.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellArea.
func CastToCellArea(object *gobject.Object) *CellArea {
	return CellAreaNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by CellArea
func (recv *CellArea) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellArea
func (recv *CellArea) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// CellAreaBox is a wrapper around the C record GtkCellAreaBox.
type CellAreaBox struct {
	native *C.GtkCellAreaBox
	// Private : parent_instance
	// Private : priv
}

func CellAreaBoxNewFromC(u unsafe.Pointer) *CellAreaBox {
	c := (*C.GtkCellAreaBox)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaBox{native: c}

	return g
}

func (recv *CellAreaBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellArea upcasts to *CellArea
func (recv *CellAreaBox) CellArea() *CellArea {
	return CellAreaNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellAreaBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellArea().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellAreaBox) Object() *gobject.Object {
	return recv.CellArea().Object()
}

// CastToWidget down casts any arbitary Object to CellAreaBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAreaBox.
func CastToCellAreaBox(object *gobject.Object) *CellAreaBox {
	return CellAreaBoxNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by CellAreaBox
func (recv *CellAreaBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellAreaBox
func (recv *CellAreaBox) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by CellAreaBox
func (recv *CellAreaBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CellAreaContext is a wrapper around the C record GtkCellAreaContext.
type CellAreaContext struct {
	native *C.GtkCellAreaContext
	// Private : parent_instance
	// Private : priv
}

func CellAreaContextNewFromC(u unsafe.Pointer) *CellAreaContext {
	c := (*C.GtkCellAreaContext)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaContext{native: c}

	return g
}

func (recv *CellAreaContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *CellAreaContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to CellAreaContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAreaContext.
func CastToCellAreaContext(object *gobject.Object) *CellAreaContext {
	return CellAreaContextNewFromC(object.ToC())
}

// Allocates a width and/or a height for all rows which are to be
// rendered with @context.
//
// Usually allocation is performed only horizontally or sometimes
// vertically since a group of rows are usually rendered side by
// side vertically or horizontally and share either the same width
// or the same height. Sometimes they are allocated in both horizontal
// and vertical orientations producing a homogeneous effect of the
// rows. This is generally the case for #GtkTreeView when
// #GtkTreeView:fixed-height-mode is enabled.
//
// Since 3.0
/*

C function : gtk_cell_area_context_allocate
*/
func (recv *CellAreaContext) Allocate(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_cell_area_context_allocate((*C.GtkCellAreaContext)(recv.native), c_width, c_height)

	return
}

// Resets any previously cached request and allocation
// data.
//
// When underlying #GtkTreeModel data changes its
// important to reset the context if the content
// size is allowed to shrink. If the content size
// is only allowed to grow (this is usually an option
// for views rendering large data stores as a measure
// of optimization), then only the row that changed
// or was inserted needs to be (re)requested with
// gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires
// that the allocated size changes (or whenever this
// allocation changes at all), the variable row
// sizes need to be re-requested for every row.
//
// For instance, if the rows are displayed all with
// the same width from top to bottom then a change
// in the allocated width necessitates a recalculation
// of all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
//
// Since 3.0
/*

C function : gtk_cell_area_context_reset
*/
func (recv *CellAreaContext) Reset() {
	C.gtk_cell_area_context_reset((*C.GtkCellAreaContext)(recv.native))

	return
}

// CellRenderer is a wrapper around the C record GtkCellRenderer.
type CellRenderer struct {
	native *C.GtkCellRenderer
	// parent_instance : record
	// Private : priv
}

func CellRendererNewFromC(u unsafe.Pointer) *CellRenderer {
	c := (*C.GtkCellRenderer)(u)
	if c == nil {
		return nil
	}

	g := &CellRenderer{native: c}

	return g
}

func (recv *CellRenderer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRenderer) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellRenderer) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to CellRenderer.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRenderer.
func CastToCellRenderer(object *gobject.Object) *CellRenderer {
	return CellRendererNewFromC(object.ToC())
}

// Unsupported : gtk_cell_renderer_activate : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Fills in @width and @height with the appropriate size of @cell.
/*

C function : gtk_cell_renderer_get_fixed_size
*/
func (recv *CellRenderer) GetFixedSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_cell_renderer_get_fixed_size((*C.GtkCellRenderer)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// Unsupported : gtk_cell_renderer_get_size : unsupported parameter cell_area : Blacklisted record : GdkRectangle

// Unsupported : gtk_cell_renderer_render : unsupported parameter background_area : Blacklisted record : GdkRectangle

// Sets the renderer size to be explicit, independent of the properties set.
/*

C function : gtk_cell_renderer_set_fixed_size
*/
func (recv *CellRenderer) SetFixedSize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_cell_renderer_set_fixed_size((*C.GtkCellRenderer)(recv.native), c_width, c_height)

	return
}

// Unsupported : gtk_cell_renderer_start_editing : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// CellRendererAccel is a wrapper around the C record GtkCellRendererAccel.
type CellRendererAccel struct {
	native *C.GtkCellRendererAccel
	// parent : record
	// Private : priv
}

func CellRendererAccelNewFromC(u unsafe.Pointer) *CellRendererAccel {
	c := (*C.GtkCellRendererAccel)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererAccel{native: c}

	return g
}

func (recv *CellRendererAccel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererAccel) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererAccel) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererAccel) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererAccel) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererAccel.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererAccel.
func CastToCellRendererAccel(object *gobject.Object) *CellRendererAccel {
	return CellRendererAccelNewFromC(object.ToC())
}

// CellRendererCombo is a wrapper around the C record GtkCellRendererCombo.
type CellRendererCombo struct {
	native *C.GtkCellRendererCombo
	// parent : record
	// Private : priv
}

func CellRendererComboNewFromC(u unsafe.Pointer) *CellRendererCombo {
	c := (*C.GtkCellRendererCombo)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererCombo{native: c}

	return g
}

func (recv *CellRendererCombo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererCombo) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererCombo) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererCombo) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererCombo) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererCombo.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererCombo.
func CastToCellRendererCombo(object *gobject.Object) *CellRendererCombo {
	return CellRendererComboNewFromC(object.ToC())
}

// CellRendererPixbuf is a wrapper around the C record GtkCellRendererPixbuf.
type CellRendererPixbuf struct {
	native *C.GtkCellRendererPixbuf
	// parent : record
	// Private : priv
}

func CellRendererPixbufNewFromC(u unsafe.Pointer) *CellRendererPixbuf {
	c := (*C.GtkCellRendererPixbuf)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererPixbuf{native: c}

	return g
}

func (recv *CellRendererPixbuf) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererPixbuf) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererPixbuf) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererPixbuf) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererPixbuf.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererPixbuf.
func CastToCellRendererPixbuf(object *gobject.Object) *CellRendererPixbuf {
	return CellRendererPixbufNewFromC(object.ToC())
}

// Creates a new #GtkCellRendererPixbuf. Adjust rendering
// parameters using object properties. Object properties can be set
// globally (with g_object_set()). Also, with #GtkTreeViewColumn, you
// can bind a property to a value in a #GtkTreeModel. For example, you
// can bind the “pixbuf” property on the cell renderer to a pixbuf value
// in the model, thus rendering a different image in each row of the
// #GtkTreeView.
/*

C function : gtk_cell_renderer_pixbuf_new
*/
func CellRendererPixbufNew() *CellRendererPixbuf {
	retC := C.gtk_cell_renderer_pixbuf_new()
	retGo := CellRendererPixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellRendererProgress is a wrapper around the C record GtkCellRendererProgress.
type CellRendererProgress struct {
	native *C.GtkCellRendererProgress
	// parent_instance : record
	// Private : priv
}

func CellRendererProgressNewFromC(u unsafe.Pointer) *CellRendererProgress {
	c := (*C.GtkCellRendererProgress)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererProgress{native: c}

	return g
}

func (recv *CellRendererProgress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererProgress) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererProgress) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererProgress) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererProgress.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererProgress.
func CastToCellRendererProgress(object *gobject.Object) *CellRendererProgress {
	return CellRendererProgressNewFromC(object.ToC())
}

// Orientable returns the Orientable interface implemented by CellRendererProgress
func (recv *CellRendererProgress) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CellRendererSpin is a wrapper around the C record GtkCellRendererSpin.
type CellRendererSpin struct {
	native *C.GtkCellRendererSpin
	// parent : record
	// Private : priv
}

func CellRendererSpinNewFromC(u unsafe.Pointer) *CellRendererSpin {
	c := (*C.GtkCellRendererSpin)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpin{native: c}

	return g
}

func (recv *CellRendererSpin) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererSpin) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererSpin) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererSpin) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererSpin) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererSpin.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererSpin.
func CastToCellRendererSpin(object *gobject.Object) *CellRendererSpin {
	return CellRendererSpinNewFromC(object.ToC())
}

// CellRendererSpinner is a wrapper around the C record GtkCellRendererSpinner.
type CellRendererSpinner struct {
	native *C.GtkCellRendererSpinner
	// parent : record
	// Private : priv
}

func CellRendererSpinnerNewFromC(u unsafe.Pointer) *CellRendererSpinner {
	c := (*C.GtkCellRendererSpinner)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpinner{native: c}

	return g
}

func (recv *CellRendererSpinner) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererSpinner) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererSpinner) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererSpinner) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererSpinner.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererSpinner.
func CastToCellRendererSpinner(object *gobject.Object) *CellRendererSpinner {
	return CellRendererSpinnerNewFromC(object.ToC())
}

// CellRendererText is a wrapper around the C record GtkCellRendererText.
type CellRendererText struct {
	native *C.GtkCellRendererText
	// parent : record
	// Private : priv
}

func CellRendererTextNewFromC(u unsafe.Pointer) *CellRendererText {
	c := (*C.GtkCellRendererText)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererText{native: c}

	return g
}

func (recv *CellRendererText) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererText) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererText) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererText) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererText.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererText.
func CastToCellRendererText(object *gobject.Object) *CellRendererText {
	return CellRendererTextNewFromC(object.ToC())
}

// Unsupported signal 'edited' for CellRendererText : unsupported parameter path : type utf8 :

// Creates a new #GtkCellRendererText. Adjust how text is drawn using
// object properties. Object properties can be
// set globally (with g_object_set()). Also, with #GtkTreeViewColumn,
// you can bind a property to a value in a #GtkTreeModel. For example,
// you can bind the “text” property on the cell renderer to a string
// value in the model, thus rendering a different string in each row
// of the #GtkTreeView
/*

C function : gtk_cell_renderer_text_new
*/
func CellRendererTextNew() *CellRendererText {
	retC := C.gtk_cell_renderer_text_new()
	retGo := CellRendererTextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the height of a renderer to explicitly be determined by the “font” and
// “y_pad” property set on it.  Further changes in these properties do not
// affect the height, so they must be accompanied by a subsequent call to this
// function.  Using this function is unflexible, and should really only be used
// if calculating the size of a cell is too slow (ie, a massive number of cells
// displayed).  If @number_of_rows is -1, then the fixed height is unset, and
// the height is determined by the properties again.
/*

C function : gtk_cell_renderer_text_set_fixed_height_from_font
*/
func (recv *CellRendererText) SetFixedHeightFromFont(numberOfRows int32) {
	c_number_of_rows := (C.gint)(numberOfRows)

	C.gtk_cell_renderer_text_set_fixed_height_from_font((*C.GtkCellRendererText)(recv.native), c_number_of_rows)

	return
}

// CellRendererToggle is a wrapper around the C record GtkCellRendererToggle.
type CellRendererToggle struct {
	native *C.GtkCellRendererToggle
	// parent : record
	// Private : priv
}

func CellRendererToggleNewFromC(u unsafe.Pointer) *CellRendererToggle {
	c := (*C.GtkCellRendererToggle)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererToggle{native: c}

	return g
}

func (recv *CellRendererToggle) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererToggle) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererToggle) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererToggle) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitary Object to CellRendererToggle.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererToggle.
func CastToCellRendererToggle(object *gobject.Object) *CellRendererToggle {
	return CellRendererToggleNewFromC(object.ToC())
}

// Unsupported signal 'toggled' for CellRendererToggle : unsupported parameter path : type utf8 :

// Creates a new #GtkCellRendererToggle. Adjust rendering
// parameters using object properties. Object properties can be set
// globally (with g_object_set()). Also, with #GtkTreeViewColumn, you
// can bind a property to a value in a #GtkTreeModel. For example, you
// can bind the “active” property on the cell renderer to a boolean value
// in the model, thus causing the check button to reflect the state of
// the model.
/*

C function : gtk_cell_renderer_toggle_new
*/
func CellRendererToggleNew() *CellRendererToggle {
	retC := C.gtk_cell_renderer_toggle_new()
	retGo := CellRendererToggleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
/*

C function : gtk_cell_renderer_toggle_get_active
*/
func (recv *CellRendererToggle) GetActive() bool {
	retC := C.gtk_cell_renderer_toggle_get_active((*C.GtkCellRendererToggle)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether we’re rendering radio toggles rather than checkboxes.
/*

C function : gtk_cell_renderer_toggle_get_radio
*/
func (recv *CellRendererToggle) GetRadio() bool {
	retC := C.gtk_cell_renderer_toggle_get_radio((*C.GtkCellRendererToggle)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Activates or deactivates a cell renderer.
/*

C function : gtk_cell_renderer_toggle_set_active
*/
func (recv *CellRendererToggle) SetActive(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_cell_renderer_toggle_set_active((*C.GtkCellRendererToggle)(recv.native), c_setting)

	return
}

// If @radio is %TRUE, the cell renderer renders a radio toggle
// (i.e. a toggle in a group of mutually-exclusive toggles).
// If %FALSE, it renders a check toggle (a standalone boolean option).
// This can be set globally for the cell renderer, or changed just
// before rendering each cell in the model (for #GtkTreeView, you set
// up a per-row setting using #GtkTreeViewColumn to associate model
// columns with cell renderer properties).
/*

C function : gtk_cell_renderer_toggle_set_radio
*/
func (recv *CellRendererToggle) SetRadio(radio bool) {
	c_radio :=
		boolToGboolean(radio)

	C.gtk_cell_renderer_toggle_set_radio((*C.GtkCellRendererToggle)(recv.native), c_radio)

	return
}

// CellView is a wrapper around the C record GtkCellView.
type CellView struct {
	native *C.GtkCellView
	// parent_instance : record
	// Private : priv
}

func CellViewNewFromC(u unsafe.Pointer) *CellView {
	c := (*C.GtkCellView)(u)
	if c == nil {
		return nil
	}

	g := &CellView{native: c}

	return g
}

func (recv *CellView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *CellView) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellView) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to CellView.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellView.
func CastToCellView(object *gobject.Object) *CellView {
	return CellViewNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by CellView
func (recv *CellView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CellView
func (recv *CellView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellView
func (recv *CellView) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by CellView
func (recv *CellView) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CheckButton is a wrapper around the C record GtkCheckButton.
type CheckButton struct {
	native *C.GtkCheckButton
	// toggle_button : record
}

func CheckButtonNewFromC(u unsafe.Pointer) *CheckButton {
	c := (*C.GtkCheckButton)(u)
	if c == nil {
		return nil
	}

	g := &CheckButton{native: c}

	return g
}

func (recv *CheckButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleButton upcasts to *ToggleButton
func (recv *CheckButton) ToggleButton() *ToggleButton {
	return ToggleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *CheckButton) Button() *Button {
	return recv.ToggleButton().Button()
}

// Bin upcasts to *Bin
func (recv *CheckButton) Bin() *Bin {
	return recv.ToggleButton().Bin()
}

// Container upcasts to *Container
func (recv *CheckButton) Container() *Container {
	return recv.ToggleButton().Container()
}

// Widget upcasts to *Widget
func (recv *CheckButton) Widget() *Widget {
	return recv.ToggleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CheckButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CheckButton) Object() *gobject.Object {
	return recv.ToggleButton().Object()
}

// CastToWidget down casts any arbitary Object to CheckButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckButton.
func CastToCheckButton(object *gobject.Object) *CheckButton {
	return CheckButtonNewFromC(object.ToC())
}

// Creates a new #GtkCheckButton.
/*

C function : gtk_check_button_new
*/
func CheckButtonNew() *CheckButton {
	retC := C.gtk_check_button_new()
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkCheckButton with a #GtkLabel to the right of it.
/*

C function : gtk_check_button_new_with_label
*/
func CheckButtonNewWithLabel(label string) *CheckButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_button_new_with_label(c_label)
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkCheckButton containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the check button.
/*

C function : gtk_check_button_new_with_mnemonic
*/
func CheckButtonNewWithMnemonic(label string) *CheckButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_button_new_with_mnemonic(c_label)
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by CheckButton
func (recv *CheckButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by CheckButton
func (recv *CheckButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by CheckButton
func (recv *CheckButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CheckButton
func (recv *CheckButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CheckMenuItem is a wrapper around the C record GtkCheckMenuItem.
type CheckMenuItem struct {
	native *C.GtkCheckMenuItem
	// menu_item : record
	// Private : priv
}

func CheckMenuItemNewFromC(u unsafe.Pointer) *CheckMenuItem {
	c := (*C.GtkCheckMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItem{native: c}

	return g
}

func (recv *CheckMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItem upcasts to *MenuItem
func (recv *CheckMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *CheckMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *CheckMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *CheckMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CheckMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CheckMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitary Object to CheckMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckMenuItem.
func CastToCheckMenuItem(object *gobject.Object) *CheckMenuItem {
	return CheckMenuItemNewFromC(object.ToC())
}

type signalCheckMenuItemToggledDetail struct {
	callback  CheckMenuItemSignalToggledCallback
	handlerID C.gulong
}

var signalCheckMenuItemToggledId int
var signalCheckMenuItemToggledMap = make(map[int]signalCheckMenuItemToggledDetail)
var signalCheckMenuItemToggledLock sync.Mutex

// CheckMenuItemSignalToggledCallback is a callback function for a 'toggled' signal emitted from a CheckMenuItem.
type CheckMenuItemSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the CheckMenuItem.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *CheckMenuItem) ConnectToggled(callback CheckMenuItemSignalToggledCallback) int {
	signalCheckMenuItemToggledLock.Lock()
	defer signalCheckMenuItemToggledLock.Unlock()

	signalCheckMenuItemToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.CheckMenuItem_signal_connect_toggled(instance, C.gpointer(uintptr(signalCheckMenuItemToggledId)))

	detail := signalCheckMenuItemToggledDetail{callback, handlerID}
	signalCheckMenuItemToggledMap[signalCheckMenuItemToggledId] = detail

	return signalCheckMenuItemToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the CheckMenuItem.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *CheckMenuItem) DisconnectToggled(connectionID int) {
	signalCheckMenuItemToggledLock.Lock()
	defer signalCheckMenuItemToggledLock.Unlock()

	detail, exists := signalCheckMenuItemToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCheckMenuItemToggledMap, connectionID)
}

//export checkmenuitem_toggledHandler
func checkmenuitem_toggledHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalCheckMenuItemToggledMap[index].callback
	callback()
}

// Creates a new #GtkCheckMenuItem.
/*

C function : gtk_check_menu_item_new
*/
func CheckMenuItemNew() *CheckMenuItem {
	retC := C.gtk_check_menu_item_new()
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkCheckMenuItem with a label.
/*

C function : gtk_check_menu_item_new_with_label
*/
func CheckMenuItemNewWithLabel(label string) *CheckMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_menu_item_new_with_label(c_label)
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkCheckMenuItem containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
/*

C function : gtk_check_menu_item_new_with_mnemonic
*/
func CheckMenuItemNewWithMnemonic(label string) *CheckMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_menu_item_new_with_mnemonic(c_label)
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns whether the check menu item is active. See
// gtk_check_menu_item_set_active ().
/*

C function : gtk_check_menu_item_get_active
*/
func (recv *CheckMenuItem) GetActive() bool {
	retC := C.gtk_check_menu_item_get_active((*C.GtkCheckMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves the value set by gtk_check_menu_item_set_inconsistent().
/*

C function : gtk_check_menu_item_get_inconsistent
*/
func (recv *CheckMenuItem) GetInconsistent() bool {
	retC := C.gtk_check_menu_item_get_inconsistent((*C.GtkCheckMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the active state of the menu item’s check box.
/*

C function : gtk_check_menu_item_set_active
*/
func (recv *CheckMenuItem) SetActive(isActive bool) {
	c_is_active :=
		boolToGboolean(isActive)

	C.gtk_check_menu_item_set_active((*C.GtkCheckMenuItem)(recv.native), c_is_active)

	return
}

// If the user has selected a range of elements (such as some text or
// spreadsheet cells) that are affected by a boolean setting, and the
// current values in that range are inconsistent, you may want to
// display the check in an “in between” state. This function turns on
// “in between” display.  Normally you would turn off the inconsistent
// state again if the user explicitly selects a setting. This has to be
// done manually, gtk_check_menu_item_set_inconsistent() only affects
// visual appearance, it doesn’t affect the semantics of the widget.
/*

C function : gtk_check_menu_item_set_inconsistent
*/
func (recv *CheckMenuItem) SetInconsistent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_check_menu_item_set_inconsistent((*C.GtkCheckMenuItem)(recv.native), c_setting)

	return
}

// Emits the #GtkCheckMenuItem::toggled signal.
/*

C function : gtk_check_menu_item_toggled
*/
func (recv *CheckMenuItem) Toggled() {
	C.gtk_check_menu_item_toggled((*C.GtkCheckMenuItem)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by CheckMenuItem
func (recv *CheckMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CheckMenuItemAccessible is a wrapper around the C record GtkCheckMenuItemAccessible.
type CheckMenuItemAccessible struct {
	native *C.GtkCheckMenuItemAccessible
	// parent : record
	// priv : record
}

func CheckMenuItemAccessibleNewFromC(u unsafe.Pointer) *CheckMenuItemAccessible {
	c := (*C.GtkCheckMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItemAccessible{native: c}

	return g
}

func (recv *CheckMenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItemAccessible upcasts to *MenuItemAccessible
func (recv *CheckMenuItemAccessible) MenuItemAccessible() *MenuItemAccessible {
	return MenuItemAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *CheckMenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.MenuItemAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *CheckMenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.MenuItemAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *CheckMenuItemAccessible) Accessible() *Accessible {
	return recv.MenuItemAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *CheckMenuItemAccessible) Object() *atk.Object {
	return recv.MenuItemAccessible().Object()
}

// CastToWidget down casts any arbitary Object to CheckMenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckMenuItemAccessible.
func CastToCheckMenuItemAccessible(object *gobject.Object) *CheckMenuItemAccessible {
	return CheckMenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Clipboard is a wrapper around the C record GtkClipboard.
type Clipboard struct {
	native *C.GtkClipboard
}

func ClipboardNewFromC(u unsafe.Pointer) *Clipboard {
	c := (*C.GtkClipboard)(u)
	if c == nil {
		return nil
	}

	g := &Clipboard{native: c}

	return g
}

func (recv *Clipboard) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Clipboard) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Clipboard.
// Exercise care, as this is a potentially dangerous function if the Object is not a Clipboard.
func CastToClipboard(object *gobject.Object) *Clipboard {
	return ClipboardNewFromC(object.ToC())
}

// Clears the contents of the clipboard. Generally this should only
// be called between the time you call gtk_clipboard_set_with_owner()
// or gtk_clipboard_set_with_data(),
// and when the @clear_func you supplied is called. Otherwise, the
// clipboard may be owned by someone else.
/*

C function : gtk_clipboard_clear
*/
func (recv *Clipboard) Clear() {
	C.gtk_clipboard_clear((*C.GtkClipboard)(recv.native))

	return
}

// If the clipboard contents callbacks were set with
// gtk_clipboard_set_with_owner(), and the gtk_clipboard_set_with_data() or
// gtk_clipboard_clear() has not subsequently called, returns the owner set
// by gtk_clipboard_set_with_owner().
/*

C function : gtk_clipboard_get_owner
*/
func (recv *Clipboard) GetOwner() *gobject.Object {
	retC := C.gtk_clipboard_get_owner((*C.GtkClipboard)(recv.native))
	var retGo (*gobject.Object)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gobject.ObjectNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_clipboard_request_contents : unsupported parameter target : Blacklisted record : GdkAtom

// Unsupported : gtk_clipboard_request_text : unsupported parameter callback : no type generator for ClipboardTextReceivedFunc (GtkClipboardTextReceivedFunc) for param callback

// Sets the contents of the clipboard to the given UTF-8 string. GTK+ will
// make a copy of the text and take responsibility for responding
// for requests for the text, and for converting the text into
// the requested format.
/*

C function : gtk_clipboard_set_text
*/
func (recv *Clipboard) SetText(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_clipboard_set_text((*C.GtkClipboard)(recv.native), c_text, c_len)

	return
}

// Unsupported : gtk_clipboard_set_with_data : unsupported parameter targets :

// Unsupported : gtk_clipboard_set_with_owner : unsupported parameter targets :

// Unsupported : gtk_clipboard_wait_for_contents : unsupported parameter target : Blacklisted record : GdkAtom

// Requests the contents of the clipboard as text and converts
// the result to UTF-8 if necessary. This function waits for
// the data to be received using the main loop, so events,
// timeouts, etc, may be dispatched during the wait.
/*

C function : gtk_clipboard_wait_for_text
*/
func (recv *Clipboard) WaitForText() string {
	retC := C.gtk_clipboard_wait_for_text((*C.GtkClipboard)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Test to see if there is text available to be pasted
// This is done by requesting the TARGETS atom and checking
// if it contains any of the supported text targets. This function
// waits for the data to be received using the main loop, so events,
// timeouts, etc, may be dispatched during the wait.
//
// This function is a little faster than calling
// gtk_clipboard_wait_for_text() since it doesn’t need to retrieve
// the actual text.
/*

C function : gtk_clipboard_wait_is_text_available
*/
func (recv *Clipboard) WaitIsTextAvailable() bool {
	retC := C.gtk_clipboard_wait_is_text_available((*C.GtkClipboard)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ColorButton is a wrapper around the C record GtkColorButton.
type ColorButton struct {
	native *C.GtkColorButton
	// button : record
	// Private : priv
}

func ColorButtonNewFromC(u unsafe.Pointer) *ColorButton {
	c := (*C.GtkColorButton)(u)
	if c == nil {
		return nil
	}

	g := &ColorButton{native: c}

	return g
}

func (recv *ColorButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *ColorButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ColorButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ColorButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ColorButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to ColorButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorButton.
func CastToColorButton(object *gobject.Object) *ColorButton {
	return ColorButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorButton
func (recv *ColorButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ColorButton
func (recv *ColorButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ColorButton
func (recv *ColorButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorButton
func (recv *ColorButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorButton
func (recv *ColorButton) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// ColorChooserDialog is a wrapper around the C record GtkColorChooserDialog.
type ColorChooserDialog struct {
	native *C.GtkColorChooserDialog
	// parent_instance : record
	// Private : priv
}

func ColorChooserDialogNewFromC(u unsafe.Pointer) *ColorChooserDialog {
	c := (*C.GtkColorChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserDialog{native: c}

	return g
}

func (recv *ColorChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *ColorChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *ColorChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *ColorChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *ColorChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *ColorChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to ColorChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorChooserDialog.
func CastToColorChooserDialog(object *gobject.Object) *ColorChooserDialog {
	return ColorChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// ColorChooserWidget is a wrapper around the C record GtkColorChooserWidget.
type ColorChooserWidget struct {
	native *C.GtkColorChooserWidget
	// parent_instance : record
	// Private : priv
}

func ColorChooserWidgetNewFromC(u unsafe.Pointer) *ColorChooserWidget {
	c := (*C.GtkColorChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserWidget{native: c}

	return g
}

func (recv *ColorChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *ColorChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ColorChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ColorChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to ColorChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorChooserWidget.
func CastToColorChooserWidget(object *gobject.Object) *ColorChooserWidget {
	return ColorChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ColorSelection is a wrapper around the C record GtkColorSelection.
type ColorSelection struct {
	native *C.GtkColorSelection
	// parent_instance : record
	// Private : private_data
}

func ColorSelectionNewFromC(u unsafe.Pointer) *ColorSelection {
	c := (*C.GtkColorSelection)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelection{native: c}

	return g
}

func (recv *ColorSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *ColorSelection) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ColorSelection) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ColorSelection) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorSelection) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorSelection) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to ColorSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorSelection.
func CastToColorSelection(object *gobject.Object) *ColorSelection {
	return ColorSelectionNewFromC(object.ToC())
}

type signalColorSelectionColorChangedDetail struct {
	callback  ColorSelectionSignalColorChangedCallback
	handlerID C.gulong
}

var signalColorSelectionColorChangedId int
var signalColorSelectionColorChangedMap = make(map[int]signalColorSelectionColorChangedDetail)
var signalColorSelectionColorChangedLock sync.Mutex

// ColorSelectionSignalColorChangedCallback is a callback function for a 'color-changed' signal emitted from a ColorSelection.
type ColorSelectionSignalColorChangedCallback func()

/*
ConnectColorChanged connects the callback to the 'color-changed' signal for the ColorSelection.

The returned value represents the connection, and may be passed to DisconnectColorChanged to remove it.
*/
func (recv *ColorSelection) ConnectColorChanged(callback ColorSelectionSignalColorChangedCallback) int {
	signalColorSelectionColorChangedLock.Lock()
	defer signalColorSelectionColorChangedLock.Unlock()

	signalColorSelectionColorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ColorSelection_signal_connect_color_changed(instance, C.gpointer(uintptr(signalColorSelectionColorChangedId)))

	detail := signalColorSelectionColorChangedDetail{callback, handlerID}
	signalColorSelectionColorChangedMap[signalColorSelectionColorChangedId] = detail

	return signalColorSelectionColorChangedId
}

/*
DisconnectColorChanged disconnects a callback from the 'color-changed' signal for the ColorSelection.

The connectionID should be a value returned from a call to ConnectColorChanged.
*/
func (recv *ColorSelection) DisconnectColorChanged(connectionID int) {
	signalColorSelectionColorChangedLock.Lock()
	defer signalColorSelectionColorChangedLock.Unlock()

	detail, exists := signalColorSelectionColorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalColorSelectionColorChangedMap, connectionID)
}

//export colorselection_colorChangedHandler
func colorselection_colorChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalColorSelectionColorChangedMap[index].callback
	callback()
}

// Creates a new GtkColorSelection.
/*

C function : gtk_color_selection_new
*/
func ColorSelectionNew() *ColorSelection {
	retC := C.gtk_color_selection_new()
	retGo := ColorSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the current alpha value.
/*

C function : gtk_color_selection_get_current_alpha
*/
func (recv *ColorSelection) GetCurrentAlpha() uint16 {
	retC := C.gtk_color_selection_get_current_alpha((*C.GtkColorSelection)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// Sets @color to be the current color in the GtkColorSelection widget.
/*

C function : gtk_color_selection_get_current_color
*/
func (recv *ColorSelection) GetCurrentColor() *gdk.Color {
	var c_color C.GdkColor

	C.gtk_color_selection_get_current_color((*C.GtkColorSelection)(recv.native), &c_color)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return color
}

// Determines whether the colorsel has an opacity control.
/*

C function : gtk_color_selection_get_has_opacity_control
*/
func (recv *ColorSelection) GetHasOpacityControl() bool {
	retC := C.gtk_color_selection_get_has_opacity_control((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Determines whether the color selector has a color palette.
/*

C function : gtk_color_selection_get_has_palette
*/
func (recv *ColorSelection) GetHasPalette() bool {
	retC := C.gtk_color_selection_get_has_palette((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the previous alpha value.
/*

C function : gtk_color_selection_get_previous_alpha
*/
func (recv *ColorSelection) GetPreviousAlpha() uint16 {
	retC := C.gtk_color_selection_get_previous_alpha((*C.GtkColorSelection)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// Fills @color in with the original color value.
/*

C function : gtk_color_selection_get_previous_color
*/
func (recv *ColorSelection) GetPreviousColor() *gdk.Color {
	var c_color C.GdkColor

	C.gtk_color_selection_get_previous_color((*C.GtkColorSelection)(recv.native), &c_color)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return color
}

// Gets the current state of the @colorsel.
/*

C function : gtk_color_selection_is_adjusting
*/
func (recv *ColorSelection) IsAdjusting() bool {
	retC := C.gtk_color_selection_is_adjusting((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the current opacity to be @alpha.
//
// The first time this is called, it will also set
// the original opacity to be @alpha too.
/*

C function : gtk_color_selection_set_current_alpha
*/
func (recv *ColorSelection) SetCurrentAlpha(alpha uint16) {
	c_alpha := (C.guint16)(alpha)

	C.gtk_color_selection_set_current_alpha((*C.GtkColorSelection)(recv.native), c_alpha)

	return
}

// Sets the current color to be @color.
//
// The first time this is called, it will also set
// the original color to be @color too.
/*

C function : gtk_color_selection_set_current_color
*/
func (recv *ColorSelection) SetCurrentColor(color *gdk.Color) {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_color_selection_set_current_color((*C.GtkColorSelection)(recv.native), c_color)

	return
}

// Sets the @colorsel to use or not use opacity.
/*

C function : gtk_color_selection_set_has_opacity_control
*/
func (recv *ColorSelection) SetHasOpacityControl(hasOpacity bool) {
	c_has_opacity :=
		boolToGboolean(hasOpacity)

	C.gtk_color_selection_set_has_opacity_control((*C.GtkColorSelection)(recv.native), c_has_opacity)

	return
}

// Shows and hides the palette based upon the value of @has_palette.
/*

C function : gtk_color_selection_set_has_palette
*/
func (recv *ColorSelection) SetHasPalette(hasPalette bool) {
	c_has_palette :=
		boolToGboolean(hasPalette)

	C.gtk_color_selection_set_has_palette((*C.GtkColorSelection)(recv.native), c_has_palette)

	return
}

// Sets the “previous” alpha to be @alpha.
//
// This function should be called with some hesitations,
// as it might seem confusing to have that alpha change.
/*

C function : gtk_color_selection_set_previous_alpha
*/
func (recv *ColorSelection) SetPreviousAlpha(alpha uint16) {
	c_alpha := (C.guint16)(alpha)

	C.gtk_color_selection_set_previous_alpha((*C.GtkColorSelection)(recv.native), c_alpha)

	return
}

// Sets the “previous” color to be @color.
//
// This function should be called with some hesitations,
// as it might seem confusing to have that color change.
// Calling gtk_color_selection_set_current_color() will also
// set this color the first time it is called.
/*

C function : gtk_color_selection_set_previous_color
*/
func (recv *ColorSelection) SetPreviousColor(color *gdk.Color) {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_color_selection_set_previous_color((*C.GtkColorSelection)(recv.native), c_color)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorSelection
func (recv *ColorSelection) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorSelection
func (recv *ColorSelection) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ColorSelection
func (recv *ColorSelection) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ColorSelectionDialog is a wrapper around the C record GtkColorSelectionDialog.
type ColorSelectionDialog struct {
	native *C.GtkColorSelectionDialog
	// parent_instance : record
	// Private : priv
}

func ColorSelectionDialogNewFromC(u unsafe.Pointer) *ColorSelectionDialog {
	c := (*C.GtkColorSelectionDialog)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelectionDialog{native: c}

	return g
}

func (recv *ColorSelectionDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *ColorSelectionDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *ColorSelectionDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *ColorSelectionDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *ColorSelectionDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *ColorSelectionDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorSelectionDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorSelectionDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to ColorSelectionDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorSelectionDialog.
func CastToColorSelectionDialog(object *gobject.Object) *ColorSelectionDialog {
	return ColorSelectionDialogNewFromC(object.ToC())
}

// Creates a new #GtkColorSelectionDialog.
/*

C function : gtk_color_selection_dialog_new
*/
func ColorSelectionDialogNew(title string) *ColorSelectionDialog {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	retC := C.gtk_color_selection_dialog_new(c_title)
	retGo := ColorSelectionDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorSelectionDialog
func (recv *ColorSelectionDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorSelectionDialog
func (recv *ColorSelectionDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ComboBox is a wrapper around the C record GtkComboBox.
type ComboBox struct {
	native *C.GtkComboBox
	// parent_instance : record
	// Private : priv
}

func ComboBoxNewFromC(u unsafe.Pointer) *ComboBox {
	c := (*C.GtkComboBox)(u)
	if c == nil {
		return nil
	}

	g := &ComboBox{native: c}

	return g
}

func (recv *ComboBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ComboBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ComboBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ComboBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ComboBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ComboBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ComboBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBox.
func CastToComboBox(object *gobject.Object) *ComboBox {
	return ComboBoxNewFromC(object.ToC())
}

// Creates a new empty #GtkComboBox using @area to layout cells.
/*

C function : gtk_combo_box_new_with_area
*/
func ComboBoxNewWithArea(area *CellArea) *ComboBox {
	c_area := (*C.GtkCellArea)(C.NULL)
	if area != nil {
		c_area = (*C.GtkCellArea)(area.ToC())
	}

	retC := C.gtk_combo_box_new_with_area(c_area)
	retGo := ComboBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new empty #GtkComboBox with an entry.
//
// The new combo box will use @area to layout cells.
/*

C function : gtk_combo_box_new_with_area_and_entry
*/
func ComboBoxNewWithAreaAndEntry(area *CellArea) *ComboBox {
	c_area := (*C.GtkCellArea)(C.NULL)
	if area != nil {
		c_area = (*C.GtkCellArea)(area.ToC())
	}

	retC := C.gtk_combo_box_new_with_area_and_entry(c_area)
	retGo := ComboBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the current value of the :add-tearoffs property.
/*

C function : gtk_combo_box_get_add_tearoffs
*/
func (recv *ComboBox) GetAddTearoffs() bool {
	retC := C.gtk_combo_box_get_add_tearoffs((*C.GtkComboBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by ComboBox
func (recv *ComboBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ComboBox
func (recv *ComboBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by ComboBox
func (recv *ComboBox) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by ComboBox
func (recv *ComboBox) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// ComboBoxAccessible is a wrapper around the C record GtkComboBoxAccessible.
type ComboBoxAccessible struct {
	native *C.GtkComboBoxAccessible
	// parent : record
	// priv : record
}

func ComboBoxAccessibleNewFromC(u unsafe.Pointer) *ComboBoxAccessible {
	c := (*C.GtkComboBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxAccessible{native: c}

	return g
}

func (recv *ComboBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ComboBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ComboBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ComboBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ComboBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ComboBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBoxAccessible.
func CastToComboBoxAccessible(object *gobject.Object) *ComboBoxAccessible {
	return ComboBoxAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// ComboBoxText is a wrapper around the C record GtkComboBoxText.
type ComboBoxText struct {
	native *C.GtkComboBoxText
	// Private : parent_instance
	// Private : priv
}

func ComboBoxTextNewFromC(u unsafe.Pointer) *ComboBoxText {
	c := (*C.GtkComboBoxText)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxText{native: c}

	return g
}

func (recv *ComboBoxText) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ComboBox upcasts to *ComboBox
func (recv *ComboBoxText) ComboBox() *ComboBox {
	return ComboBoxNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ComboBoxText) Bin() *Bin {
	return recv.ComboBox().Bin()
}

// Container upcasts to *Container
func (recv *ComboBoxText) Container() *Container {
	return recv.ComboBox().Container()
}

// Widget upcasts to *Widget
func (recv *ComboBoxText) Widget() *Widget {
	return recv.ComboBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ComboBoxText) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ComboBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ComboBoxText) Object() *gobject.Object {
	return recv.ComboBox().Object()
}

// CastToWidget down casts any arbitary Object to ComboBoxText.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBoxText.
func CastToComboBoxText(object *gobject.Object) *ComboBoxText {
	return ComboBoxTextNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ComboBoxText
func (recv *ComboBoxText) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ComboBoxText
func (recv *ComboBoxText) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by ComboBoxText
func (recv *ComboBoxText) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by ComboBoxText
func (recv *ComboBoxText) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Container is a wrapper around the C record GtkContainer.
type Container struct {
	native *C.GtkContainer
	// widget : record
	// Private : priv
}

func ContainerNewFromC(u unsafe.Pointer) *Container {
	c := (*C.GtkContainer)(u)
	if c == nil {
		return nil
	}

	g := &Container{native: c}

	return g
}

func (recv *Container) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Container) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Container) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Container) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Container.
// Exercise care, as this is a potentially dangerous function if the Object is not a Container.
func CastToContainer(object *gobject.Object) *Container {
	return ContainerNewFromC(object.ToC())
}

type signalContainerAddDetail struct {
	callback  ContainerSignalAddCallback
	handlerID C.gulong
}

var signalContainerAddId int
var signalContainerAddMap = make(map[int]signalContainerAddDetail)
var signalContainerAddLock sync.Mutex

// ContainerSignalAddCallback is a callback function for a 'add' signal emitted from a Container.
type ContainerSignalAddCallback func(object *Widget)

/*
ConnectAdd connects the callback to the 'add' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectAdd to remove it.
*/
func (recv *Container) ConnectAdd(callback ContainerSignalAddCallback) int {
	signalContainerAddLock.Lock()
	defer signalContainerAddLock.Unlock()

	signalContainerAddId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_add(instance, C.gpointer(uintptr(signalContainerAddId)))

	detail := signalContainerAddDetail{callback, handlerID}
	signalContainerAddMap[signalContainerAddId] = detail

	return signalContainerAddId
}

/*
DisconnectAdd disconnects a callback from the 'add' signal for the Container.

The connectionID should be a value returned from a call to ConnectAdd.
*/
func (recv *Container) DisconnectAdd(connectionID int) {
	signalContainerAddLock.Lock()
	defer signalContainerAddLock.Unlock()

	detail, exists := signalContainerAddMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerAddMap, connectionID)
}

//export container_addHandler
func container_addHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerAddMap[index].callback
	callback(object)
}

type signalContainerCheckResizeDetail struct {
	callback  ContainerSignalCheckResizeCallback
	handlerID C.gulong
}

var signalContainerCheckResizeId int
var signalContainerCheckResizeMap = make(map[int]signalContainerCheckResizeDetail)
var signalContainerCheckResizeLock sync.Mutex

// ContainerSignalCheckResizeCallback is a callback function for a 'check-resize' signal emitted from a Container.
type ContainerSignalCheckResizeCallback func()

/*
ConnectCheckResize connects the callback to the 'check-resize' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectCheckResize to remove it.
*/
func (recv *Container) ConnectCheckResize(callback ContainerSignalCheckResizeCallback) int {
	signalContainerCheckResizeLock.Lock()
	defer signalContainerCheckResizeLock.Unlock()

	signalContainerCheckResizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_check_resize(instance, C.gpointer(uintptr(signalContainerCheckResizeId)))

	detail := signalContainerCheckResizeDetail{callback, handlerID}
	signalContainerCheckResizeMap[signalContainerCheckResizeId] = detail

	return signalContainerCheckResizeId
}

/*
DisconnectCheckResize disconnects a callback from the 'check-resize' signal for the Container.

The connectionID should be a value returned from a call to ConnectCheckResize.
*/
func (recv *Container) DisconnectCheckResize(connectionID int) {
	signalContainerCheckResizeLock.Lock()
	defer signalContainerCheckResizeLock.Unlock()

	detail, exists := signalContainerCheckResizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerCheckResizeMap, connectionID)
}

//export container_checkResizeHandler
func container_checkResizeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalContainerCheckResizeMap[index].callback
	callback()
}

type signalContainerRemoveDetail struct {
	callback  ContainerSignalRemoveCallback
	handlerID C.gulong
}

var signalContainerRemoveId int
var signalContainerRemoveMap = make(map[int]signalContainerRemoveDetail)
var signalContainerRemoveLock sync.Mutex

// ContainerSignalRemoveCallback is a callback function for a 'remove' signal emitted from a Container.
type ContainerSignalRemoveCallback func(object *Widget)

/*
ConnectRemove connects the callback to the 'remove' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectRemove to remove it.
*/
func (recv *Container) ConnectRemove(callback ContainerSignalRemoveCallback) int {
	signalContainerRemoveLock.Lock()
	defer signalContainerRemoveLock.Unlock()

	signalContainerRemoveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_remove(instance, C.gpointer(uintptr(signalContainerRemoveId)))

	detail := signalContainerRemoveDetail{callback, handlerID}
	signalContainerRemoveMap[signalContainerRemoveId] = detail

	return signalContainerRemoveId
}

/*
DisconnectRemove disconnects a callback from the 'remove' signal for the Container.

The connectionID should be a value returned from a call to ConnectRemove.
*/
func (recv *Container) DisconnectRemove(connectionID int) {
	signalContainerRemoveLock.Lock()
	defer signalContainerRemoveLock.Unlock()

	detail, exists := signalContainerRemoveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerRemoveMap, connectionID)
}

//export container_removeHandler
func container_removeHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerRemoveMap[index].callback
	callback(object)
}

type signalContainerSetFocusChildDetail struct {
	callback  ContainerSignalSetFocusChildCallback
	handlerID C.gulong
}

var signalContainerSetFocusChildId int
var signalContainerSetFocusChildMap = make(map[int]signalContainerSetFocusChildDetail)
var signalContainerSetFocusChildLock sync.Mutex

// ContainerSignalSetFocusChildCallback is a callback function for a 'set-focus-child' signal emitted from a Container.
type ContainerSignalSetFocusChildCallback func(object *Widget)

/*
ConnectSetFocusChild connects the callback to the 'set-focus-child' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectSetFocusChild to remove it.
*/
func (recv *Container) ConnectSetFocusChild(callback ContainerSignalSetFocusChildCallback) int {
	signalContainerSetFocusChildLock.Lock()
	defer signalContainerSetFocusChildLock.Unlock()

	signalContainerSetFocusChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_set_focus_child(instance, C.gpointer(uintptr(signalContainerSetFocusChildId)))

	detail := signalContainerSetFocusChildDetail{callback, handlerID}
	signalContainerSetFocusChildMap[signalContainerSetFocusChildId] = detail

	return signalContainerSetFocusChildId
}

/*
DisconnectSetFocusChild disconnects a callback from the 'set-focus-child' signal for the Container.

The connectionID should be a value returned from a call to ConnectSetFocusChild.
*/
func (recv *Container) DisconnectSetFocusChild(connectionID int) {
	signalContainerSetFocusChildLock.Lock()
	defer signalContainerSetFocusChildLock.Unlock()

	detail, exists := signalContainerSetFocusChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerSetFocusChildMap, connectionID)
}

//export container_setFocusChildHandler
func container_setFocusChildHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerSetFocusChildMap[index].callback
	callback(object)
}

// Adds @widget to @container. Typically used for simple containers
// such as #GtkWindow, #GtkFrame, or #GtkButton; for more complicated
// layout containers such as #GtkBox or #GtkGrid, this function will
// pick default packing parameters that may not be correct.  So
// consider functions such as gtk_box_pack_start() and
// gtk_grid_attach() as an alternative to gtk_container_add() in
// those cases. A widget may be added to only one container at a time;
// you can’t place the same widget inside two different containers.
//
// Note that some containers, such as #GtkScrolledWindow or #GtkListBox,
// may add intermediate children between the added widget and the
// container.
/*

C function : gtk_container_add
*/
func (recv *Container) Add(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_container_add((*C.GtkContainer)(recv.native), c_widget)

	return
}

// Unsupported : gtk_container_add_with_properties : unsupported parameter ... : varargs

/*

C function : gtk_container_check_resize
*/
func (recv *Container) CheckResize() {
	C.gtk_container_check_resize((*C.GtkContainer)(recv.native))

	return
}

// Unsupported : gtk_container_child_get : unsupported parameter ... : varargs

// Gets the value of a child property for @child and @container.
/*

C function : gtk_container_child_get_property
*/
func (recv *Container) ChildGetProperty(child *Widget, propertyName string, value *gobject.Value) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_container_child_get_property((*C.GtkContainer)(recv.native), c_child, c_property_name, c_value)

	return
}

// Unsupported : gtk_container_child_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Unsupported : gtk_container_child_set : unsupported parameter ... : varargs

// Sets a child property for @child and @container.
/*

C function : gtk_container_child_set_property
*/
func (recv *Container) ChildSetProperty(child *Widget, propertyName string, value *gobject.Value) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_container_child_set_property((*C.GtkContainer)(recv.native), c_child, c_property_name, c_value)

	return
}

// Unsupported : gtk_container_child_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Returns the type of the children supported by the container.
//
// Note that this may return %G_TYPE_NONE to indicate that no more
// children can be added, e.g. for a #GtkPaned which already has two
// children.
/*

C function : gtk_container_child_type
*/
func (recv *Container) ChildType() gobject.Type {
	retC := C.gtk_container_child_type((*C.GtkContainer)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// Unsupported : gtk_container_forall : unsupported parameter callback : no type generator for Callback (GtkCallback) for param callback

// Unsupported : gtk_container_foreach : unsupported parameter callback : no type generator for Callback (GtkCallback) for param callback

// Retrieves the border width of the container. See
// gtk_container_set_border_width().
/*

C function : gtk_container_get_border_width
*/
func (recv *Container) GetBorderWidth() uint32 {
	retC := C.gtk_container_get_border_width((*C.GtkContainer)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Returns the container’s non-internal children. See
// gtk_container_forall() for details on what constitutes an "internal" child.
/*

C function : gtk_container_get_children
*/
func (recv *Container) GetChildren() *glib.List {
	retC := C.gtk_container_get_children((*C.GtkContainer)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the focus chain of the container, if one has been
// set explicitly. If no focus chain has been explicitly
// set, GTK+ computes the focus chain based on the positions
// of the children. In that case, GTK+ stores %NULL in
// @focusable_widgets and returns %FALSE.
/*

C function : gtk_container_get_focus_chain
*/
func (recv *Container) GetFocusChain() (bool, *glib.List) {
	var c_focusable_widgets *C.GList

	retC := C.gtk_container_get_focus_chain((*C.GtkContainer)(recv.native), &c_focusable_widgets)
	retGo := retC == C.TRUE

	focusableWidgets := glib.ListNewFromC(unsafe.Pointer(c_focusable_widgets))

	return retGo, focusableWidgets
}

// Retrieves the horizontal focus adjustment for the container. See
// gtk_container_set_focus_hadjustment ().
/*

C function : gtk_container_get_focus_hadjustment
*/
func (recv *Container) GetFocusHadjustment() *Adjustment {
	retC := C.gtk_container_get_focus_hadjustment((*C.GtkContainer)(recv.native))
	var retGo (*Adjustment)
	if retC == nil {
		retGo = nil
	} else {
		retGo = AdjustmentNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the vertical focus adjustment for the container. See
// gtk_container_set_focus_vadjustment().
/*

C function : gtk_container_get_focus_vadjustment
*/
func (recv *Container) GetFocusVadjustment() *Adjustment {
	retC := C.gtk_container_get_focus_vadjustment((*C.GtkContainer)(recv.native))
	var retGo (*Adjustment)
	if retC == nil {
		retGo = nil
	} else {
		retGo = AdjustmentNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns a newly created widget path representing all the widget hierarchy
// from the toplevel down to and including @child.
/*

C function : gtk_container_get_path_for_child
*/
func (recv *Container) GetPathForChild(child *Widget) *WidgetPath {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_container_get_path_for_child((*C.GtkContainer)(recv.native), c_child)
	retGo := WidgetPathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the resize mode for the container. See
// gtk_container_set_resize_mode ().
/*

C function : gtk_container_get_resize_mode
*/
func (recv *Container) GetResizeMode() ResizeMode {
	retC := C.gtk_container_get_resize_mode((*C.GtkContainer)(recv.native))
	retGo := (ResizeMode)(retC)

	return retGo
}

// When a container receives a call to the draw function, it must send
// synthetic #GtkWidget::draw calls to all children that don’t have their
// own #GdkWindows. This function provides a convenient way of doing this.
// A container, when it receives a call to its #GtkWidget::draw function,
// calls gtk_container_propagate_draw() once for each child, passing in
// the @cr the container received.
//
// gtk_container_propagate_draw() takes care of translating the origin of @cr,
// and deciding whether the draw needs to be sent to the child. It is a
// convenient and optimized way of getting the same effect as calling
// gtk_widget_draw() on the child directly.
//
// In most cases, a container can simply either inherit the
// #GtkWidget::draw implementation from #GtkContainer, or do some drawing
// and then chain to the ::draw implementation from #GtkContainer.
/*

C function : gtk_container_propagate_draw
*/
func (recv *Container) PropagateDraw(child *Widget, cr *cairo.Context) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	C.gtk_container_propagate_draw((*C.GtkContainer)(recv.native), c_child, c_cr)

	return
}

// Removes @widget from @container. @widget must be inside @container.
// Note that @container will own a reference to @widget, and that this
// may be the last reference held; so removing a widget from its
// container can destroy that widget. If you want to use @widget
// again, you need to add a reference to it before removing it from
// a container, using g_object_ref(). If you don’t want to use @widget
// again it’s usually more efficient to simply destroy it directly
// using gtk_widget_destroy() since this will remove it from the
// container and help break any circular reference count cycles.
/*

C function : gtk_container_remove
*/
func (recv *Container) Remove(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_container_remove((*C.GtkContainer)(recv.native), c_widget)

	return
}

/*

C function : gtk_container_resize_children
*/
func (recv *Container) ResizeChildren() {
	C.gtk_container_resize_children((*C.GtkContainer)(recv.native))

	return
}

// Sets the border width of the container.
//
// The border width of a container is the amount of space to leave
// around the outside of the container. The only exception to this is
// #GtkWindow; because toplevel windows can’t leave space outside,
// they leave the space inside. The border is added on all sides of
// the container. To add space to only one side, use a specific
// #GtkWidget:margin property on the child widget, for example
// #GtkWidget:margin-top.
/*

C function : gtk_container_set_border_width
*/
func (recv *Container) SetBorderWidth(borderWidth uint32) {
	c_border_width := (C.guint)(borderWidth)

	C.gtk_container_set_border_width((*C.GtkContainer)(recv.native), c_border_width)

	return
}

// Sets a focus chain, overriding the one computed automatically by GTK+.
//
// In principle each widget in the chain should be a descendant of the
// container, but this is not enforced by this method, since it’s allowed
// to set the focus chain before you pack the widgets, or have a widget
// in the chain that isn’t always packed. The necessary checks are done
// when the focus chain is actually traversed.
/*

C function : gtk_container_set_focus_chain
*/
func (recv *Container) SetFocusChain(focusableWidgets *glib.List) {
	c_focusable_widgets := (*C.GList)(C.NULL)
	if focusableWidgets != nil {
		c_focusable_widgets = (*C.GList)(focusableWidgets.ToC())
	}

	C.gtk_container_set_focus_chain((*C.GtkContainer)(recv.native), c_focusable_widgets)

	return
}

// Sets, or unsets if @child is %NULL, the focused child of @container.
//
// This function emits the GtkContainer::set_focus_child signal of
// @container. Implementations of #GtkContainer can override the
// default behaviour by overriding the class closure of this signal.
//
// This is function is mostly meant to be used by widgets. Applications can use
// gtk_widget_grab_focus() to manually set the focus to a specific widget.
/*

C function : gtk_container_set_focus_child
*/
func (recv *Container) SetFocusChild(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_container_set_focus_child((*C.GtkContainer)(recv.native), c_child)

	return
}

// Hooks up an adjustment to focus handling in a container, so when a child
// of the container is focused, the adjustment is scrolled to show that
// widget. This function sets the horizontal alignment.
// See gtk_scrolled_window_get_hadjustment() for a typical way of obtaining
// the adjustment and gtk_container_set_focus_vadjustment() for setting
// the vertical adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the container.
/*

C function : gtk_container_set_focus_hadjustment
*/
func (recv *Container) SetFocusHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_container_set_focus_hadjustment((*C.GtkContainer)(recv.native), c_adjustment)

	return
}

// Hooks up an adjustment to focus handling in a container, so when a
// child of the container is focused, the adjustment is scrolled to
// show that widget. This function sets the vertical alignment. See
// gtk_scrolled_window_get_vadjustment() for a typical way of obtaining
// the adjustment and gtk_container_set_focus_hadjustment() for setting
// the horizontal adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate
// system as the allocation for immediate children of the container.
/*

C function : gtk_container_set_focus_vadjustment
*/
func (recv *Container) SetFocusVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_container_set_focus_vadjustment((*C.GtkContainer)(recv.native), c_adjustment)

	return
}

// Sets the @reallocate_redraws flag of the container to the given value.
//
// Containers requesting reallocation redraws get automatically
// redrawn if any of their children changed allocation.
/*

C function : gtk_container_set_reallocate_redraws
*/
func (recv *Container) SetReallocateRedraws(needsRedraws bool) {
	c_needs_redraws :=
		boolToGboolean(needsRedraws)

	C.gtk_container_set_reallocate_redraws((*C.GtkContainer)(recv.native), c_needs_redraws)

	return
}

// Sets the resize mode for the container.
//
// The resize mode of a container determines whether a resize request
// will be passed to the container’s parent, queued for later execution
// or executed immediately.
/*

C function : gtk_container_set_resize_mode
*/
func (recv *Container) SetResizeMode(resizeMode ResizeMode) {
	c_resize_mode := (C.GtkResizeMode)(resizeMode)

	C.gtk_container_set_resize_mode((*C.GtkContainer)(recv.native), c_resize_mode)

	return
}

// Removes a focus chain explicitly set with gtk_container_set_focus_chain().
/*

C function : gtk_container_unset_focus_chain
*/
func (recv *Container) UnsetFocusChain() {
	C.gtk_container_unset_focus_chain((*C.GtkContainer)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Container
func (recv *Container) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Container
func (recv *Container) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ContainerAccessible is a wrapper around the C record GtkContainerAccessible.
type ContainerAccessible struct {
	native *C.GtkContainerAccessible
	// parent : record
	// priv : record
}

func ContainerAccessibleNewFromC(u unsafe.Pointer) *ContainerAccessible {
	c := (*C.GtkContainerAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ContainerAccessible{native: c}

	return g
}

func (recv *ContainerAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ContainerAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ContainerAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ContainerAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ContainerAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ContainerAccessible.
func CastToContainerAccessible(object *gobject.Object) *ContainerAccessible {
	return ContainerAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ContainerAccessible
func (recv *ContainerAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// ContainerCellAccessible is a wrapper around the C record GtkContainerCellAccessible.
type ContainerCellAccessible struct {
	native *C.GtkContainerCellAccessible
	// parent : record
	// priv : record
}

func ContainerCellAccessibleNewFromC(u unsafe.Pointer) *ContainerCellAccessible {
	c := (*C.GtkContainerCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ContainerCellAccessible{native: c}

	return g
}

func (recv *ContainerCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellAccessible upcasts to *CellAccessible
func (recv *ContainerCellAccessible) CellAccessible() *CellAccessible {
	return CellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ContainerCellAccessible) Accessible() *Accessible {
	return recv.CellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ContainerCellAccessible) Object() *atk.Object {
	return recv.CellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ContainerCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ContainerCellAccessible.
func CastToContainerCellAccessible(object *gobject.Object) *ContainerCellAccessible {
	return ContainerCellAccessibleNewFromC(object.ToC())
}

/*

C function : gtk_container_cell_accessible_new
*/
func ContainerCellAccessibleNew() *ContainerCellAccessible {
	retC := C.gtk_container_cell_accessible_new()
	retGo := ContainerCellAccessibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

/*

C function : gtk_container_cell_accessible_add_child
*/
func (recv *ContainerCellAccessible) AddChild(child *CellAccessible) {
	c_child := (*C.GtkCellAccessible)(C.NULL)
	if child != nil {
		c_child = (*C.GtkCellAccessible)(child.ToC())
	}

	C.gtk_container_cell_accessible_add_child((*C.GtkContainerCellAccessible)(recv.native), c_child)

	return
}

// Get a list of children.
/*

C function : gtk_container_cell_accessible_get_children
*/
func (recv *ContainerCellAccessible) GetChildren() *glib.List {
	retC := C.gtk_container_cell_accessible_get_children((*C.GtkContainerCellAccessible)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

/*

C function : gtk_container_cell_accessible_remove_child
*/
func (recv *ContainerCellAccessible) RemoveChild(child *CellAccessible) {
	c_child := (*C.GtkCellAccessible)(C.NULL)
	if child != nil {
		c_child = (*C.GtkCellAccessible)(child.ToC())
	}

	C.gtk_container_cell_accessible_remove_child((*C.GtkContainerCellAccessible)(recv.native), c_child)

	return
}

// Action returns the Action interface implemented by ContainerCellAccessible
func (recv *ContainerCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ContainerCellAccessible
func (recv *ContainerCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// CssProvider is a wrapper around the C record GtkCssProvider.
type CssProvider struct {
	native *C.GtkCssProvider
	// parent_instance : record
	// priv : record
}

func CssProviderNewFromC(u unsafe.Pointer) *CssProvider {
	c := (*C.GtkCssProvider)(u)
	if c == nil {
		return nil
	}

	g := &CssProvider{native: c}

	return g
}

func (recv *CssProvider) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *CssProvider) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to CssProvider.
// Exercise care, as this is a potentially dangerous function if the Object is not a CssProvider.
func CastToCssProvider(object *gobject.Object) *CssProvider {
	return CssProviderNewFromC(object.ToC())
}

type signalCssProviderParsingErrorDetail struct {
	callback  CssProviderSignalParsingErrorCallback
	handlerID C.gulong
}

var signalCssProviderParsingErrorId int
var signalCssProviderParsingErrorMap = make(map[int]signalCssProviderParsingErrorDetail)
var signalCssProviderParsingErrorLock sync.Mutex

// CssProviderSignalParsingErrorCallback is a callback function for a 'parsing-error' signal emitted from a CssProvider.
type CssProviderSignalParsingErrorCallback func(section *CssSection, error *glib.Error)

/*
ConnectParsingError connects the callback to the 'parsing-error' signal for the CssProvider.

The returned value represents the connection, and may be passed to DisconnectParsingError to remove it.
*/
func (recv *CssProvider) ConnectParsingError(callback CssProviderSignalParsingErrorCallback) int {
	signalCssProviderParsingErrorLock.Lock()
	defer signalCssProviderParsingErrorLock.Unlock()

	signalCssProviderParsingErrorId++
	instance := C.gpointer(recv.native)
	handlerID := C.CssProvider_signal_connect_parsing_error(instance, C.gpointer(uintptr(signalCssProviderParsingErrorId)))

	detail := signalCssProviderParsingErrorDetail{callback, handlerID}
	signalCssProviderParsingErrorMap[signalCssProviderParsingErrorId] = detail

	return signalCssProviderParsingErrorId
}

/*
DisconnectParsingError disconnects a callback from the 'parsing-error' signal for the CssProvider.

The connectionID should be a value returned from a call to ConnectParsingError.
*/
func (recv *CssProvider) DisconnectParsingError(connectionID int) {
	signalCssProviderParsingErrorLock.Lock()
	defer signalCssProviderParsingErrorLock.Unlock()

	detail, exists := signalCssProviderParsingErrorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCssProviderParsingErrorMap, connectionID)
}

//export cssprovider_parsingErrorHandler
func cssprovider_parsingErrorHandler(_ *C.GObject, c_section *C.GtkCssSection, c_error *C.GError, data C.gpointer) {
	section := CssSectionNewFromC(unsafe.Pointer(c_section))

	error := glib.ErrorNewFromC(unsafe.Pointer(c_error))

	index := int(uintptr(data))
	callback := signalCssProviderParsingErrorMap[index].callback
	callback(section, error)
}

// Returns a newly created #GtkCssProvider.
/*

C function : gtk_css_provider_new
*/
func CssProviderNew() *CssProvider {
	retC := C.gtk_css_provider_new()
	retGo := CssProviderNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Loads @data into @css_provider, and by doing so clears any previously loaded
// information.
/*

C function : gtk_css_provider_load_from_data
*/
func (recv *CssProvider) LoadFromData(data []uint8) (bool, error) {
	c_data := &data[0]

	c_length := (C.gssize)(len(data))

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_data((*C.GtkCssProvider)(recv.native), (*C.gchar)(unsafe.Pointer(c_data)), c_length, &cThrowableError)
	retGo := retC == C.TRUE

	goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
	if cThrowableError != nil {
		C.g_error_free(cThrowableError)
	}

	return retGo, goThrowableError
}

// Loads the data contained in @file into @css_provider, making it
// clear any previously loaded information.
/*

C function : gtk_css_provider_load_from_file
*/
func (recv *CssProvider) LoadFromFile(file *gio.File) (bool, error) {
	c_file := (*C.GFile)(file.ToC())

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_file((*C.GtkCssProvider)(recv.native), c_file, &cThrowableError)
	retGo := retC == C.TRUE

	goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
	if cThrowableError != nil {
		C.g_error_free(cThrowableError)
	}

	return retGo, goThrowableError
}

// Loads the data contained in @path into @css_provider, making it clear
// any previously loaded information.
/*

C function : gtk_css_provider_load_from_path
*/
func (recv *CssProvider) LoadFromPath(path string) (bool, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_path((*C.GtkCssProvider)(recv.native), c_path, &cThrowableError)
	retGo := retC == C.TRUE

	goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
	if cThrowableError != nil {
		C.g_error_free(cThrowableError)
	}

	return retGo, goThrowableError
}

// StyleProvider returns the StyleProvider interface implemented by CssProvider
func (recv *CssProvider) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// Dialog is a wrapper around the C record GtkDialog.
type Dialog struct {
	native *C.GtkDialog
	// window : record
	// Private : priv
}

func DialogNewFromC(u unsafe.Pointer) *Dialog {
	c := (*C.GtkDialog)(u)
	if c == nil {
		return nil
	}

	g := &Dialog{native: c}

	return g
}

func (recv *Dialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Window upcasts to *Window
func (recv *Dialog) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *Dialog) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *Dialog) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *Dialog) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Dialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Dialog) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitary Object to Dialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a Dialog.
func CastToDialog(object *gobject.Object) *Dialog {
	return DialogNewFromC(object.ToC())
}

type signalDialogCloseDetail struct {
	callback  DialogSignalCloseCallback
	handlerID C.gulong
}

var signalDialogCloseId int
var signalDialogCloseMap = make(map[int]signalDialogCloseDetail)
var signalDialogCloseLock sync.Mutex

// DialogSignalCloseCallback is a callback function for a 'close' signal emitted from a Dialog.
type DialogSignalCloseCallback func()

/*
ConnectClose connects the callback to the 'close' signal for the Dialog.

The returned value represents the connection, and may be passed to DisconnectClose to remove it.
*/
func (recv *Dialog) ConnectClose(callback DialogSignalCloseCallback) int {
	signalDialogCloseLock.Lock()
	defer signalDialogCloseLock.Unlock()

	signalDialogCloseId++
	instance := C.gpointer(recv.native)
	handlerID := C.Dialog_signal_connect_close(instance, C.gpointer(uintptr(signalDialogCloseId)))

	detail := signalDialogCloseDetail{callback, handlerID}
	signalDialogCloseMap[signalDialogCloseId] = detail

	return signalDialogCloseId
}

/*
DisconnectClose disconnects a callback from the 'close' signal for the Dialog.

The connectionID should be a value returned from a call to ConnectClose.
*/
func (recv *Dialog) DisconnectClose(connectionID int) {
	signalDialogCloseLock.Lock()
	defer signalDialogCloseLock.Unlock()

	detail, exists := signalDialogCloseMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDialogCloseMap, connectionID)
}

//export dialog_closeHandler
func dialog_closeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalDialogCloseMap[index].callback
	callback()
}

// Unsupported signal 'response' for Dialog : unsupported parameter response_id : type gint :

// Creates a new dialog box.
//
// Widgets should not be packed into this #GtkWindow
// directly, but into the @vbox and @action_area, as described above.
/*

C function : gtk_dialog_new
*/
func DialogNew() *Dialog {
	retC := C.gtk_dialog_new()
	retGo := DialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_dialog_new_with_buttons : unsupported parameter ... : varargs

// Adds an activatable widget to the action area of a #GtkDialog,
// connecting a signal handler that will emit the #GtkDialog::response
// signal on the dialog when the widget is activated. The widget is
// appended to the end of the dialog’s action area. If you want to add a
// non-activatable widget, simply pack it into the @action_area field
// of the #GtkDialog struct.
/*

C function : gtk_dialog_add_action_widget
*/
func (recv *Dialog) AddActionWidget(child *Widget, responseId int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_add_action_widget((*C.GtkDialog)(recv.native), c_child, c_response_id)

	return
}

// Adds a button with the given text and sets things up so that
// clicking the button will emit the #GtkDialog::response signal with
// the given @response_id. The button is appended to the end of the
// dialog’s action area. The button widget is returned, but usually
// you don’t need it.
/*

C function : gtk_dialog_add_button
*/
func (recv *Dialog) AddButton(buttonText string, responseId int32) *Widget {
	c_button_text := C.CString(buttonText)
	defer C.free(unsafe.Pointer(c_button_text))

	c_response_id := (C.gint)(responseId)

	retC := C.gtk_dialog_add_button((*C.GtkDialog)(recv.native), c_button_text, c_response_id)
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_dialog_add_buttons : unsupported parameter ... : varargs

// Emits the #GtkDialog::response signal with the given response ID.
// Used to indicate that the user has responded to the dialog in some way;
// typically either you or gtk_dialog_run() will be monitoring the
// ::response signal and take appropriate action.
/*

C function : gtk_dialog_response
*/
func (recv *Dialog) Response(responseId int32) {
	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_response((*C.GtkDialog)(recv.native), c_response_id)

	return
}

// Blocks in a recursive main loop until the @dialog either emits the
// #GtkDialog::response signal, or is destroyed. If the dialog is
// destroyed during the call to gtk_dialog_run(), gtk_dialog_run() returns
// #GTK_RESPONSE_NONE. Otherwise, it returns the response ID from the
// ::response signal emission.
//
// Before entering the recursive main loop, gtk_dialog_run() calls
// gtk_widget_show() on the dialog for you. Note that you still
// need to show any children of the dialog yourself.
//
// During gtk_dialog_run(), the default behavior of #GtkWidget::delete-event
// is disabled; if the dialog receives ::delete_event, it will not be
// destroyed as windows usually are, and gtk_dialog_run() will return
// #GTK_RESPONSE_DELETE_EVENT. Also, during gtk_dialog_run() the dialog
// will be modal. You can force gtk_dialog_run() to return at any time by
// calling gtk_dialog_response() to emit the ::response signal. Destroying
// the dialog during gtk_dialog_run() is a very bad idea, because your
// post-run code won’t know whether the dialog was destroyed or not.
//
// After gtk_dialog_run() returns, you are responsible for hiding or
// destroying the dialog if you wish to do so.
//
// Typical usage of this function might be:
// |[<!-- language="C" -->
// GtkWidget *dialog = gtk_dialog_new ();
// Set up dialog...
//
// int result = gtk_dialog_run (GTK_DIALOG (dialog));
// switch (result)
// {
// case GTK_RESPONSE_ACCEPT:
// do_application_specific_something ();
// break;
// default:
// do_nothing_since_dialog_was_cancelled ();
// break;
// }
// gtk_widget_destroy (dialog);
// ]|
//
// Note that even though the recursive main loop gives the effect of a
// modal dialog (it prevents the user from interacting with other
// windows in the same window group while the dialog is run), callbacks
// such as timeouts, IO channel watches, DND drops, etc, will
// be triggered during a gtk_dialog_run() call.
/*

C function : gtk_dialog_run
*/
func (recv *Dialog) Run() int32 {
	retC := C.gtk_dialog_run((*C.GtkDialog)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Sets the last widget in the dialog’s action area with the given @response_id
// as the default widget for the dialog. Pressing “Enter” normally activates
// the default widget.
/*

C function : gtk_dialog_set_default_response
*/
func (recv *Dialog) SetDefaultResponse(responseId int32) {
	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_set_default_response((*C.GtkDialog)(recv.native), c_response_id)

	return
}

// Calls `gtk_widget_set_sensitive (widget, @setting)`
// for each widget in the dialog’s action area with the given @response_id.
// A convenient way to sensitize/desensitize dialog buttons.
/*

C function : gtk_dialog_set_response_sensitive
*/
func (recv *Dialog) SetResponseSensitive(responseId int32, setting bool) {
	c_response_id := (C.gint)(responseId)

	c_setting :=
		boolToGboolean(setting)

	C.gtk_dialog_set_response_sensitive((*C.GtkDialog)(recv.native), c_response_id, c_setting)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Dialog
func (recv *Dialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Dialog
func (recv *Dialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// DrawingArea is a wrapper around the C record GtkDrawingArea.
type DrawingArea struct {
	native *C.GtkDrawingArea
	// widget : record
	// Private : dummy
}

func DrawingAreaNewFromC(u unsafe.Pointer) *DrawingArea {
	c := (*C.GtkDrawingArea)(u)
	if c == nil {
		return nil
	}

	g := &DrawingArea{native: c}

	return g
}

func (recv *DrawingArea) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *DrawingArea) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *DrawingArea) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *DrawingArea) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to DrawingArea.
// Exercise care, as this is a potentially dangerous function if the Object is not a DrawingArea.
func CastToDrawingArea(object *gobject.Object) *DrawingArea {
	return DrawingAreaNewFromC(object.ToC())
}

// Creates a new drawing area.
/*

C function : gtk_drawing_area_new
*/
func DrawingAreaNew() *DrawingArea {
	retC := C.gtk_drawing_area_new()
	retGo := DrawingAreaNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by DrawingArea
func (recv *DrawingArea) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by DrawingArea
func (recv *DrawingArea) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Entry is a wrapper around the C record GtkEntry.
type Entry struct {
	native *C.GtkEntry
	// Private : parent_instance
	// Private : priv
}

func EntryNewFromC(u unsafe.Pointer) *Entry {
	c := (*C.GtkEntry)(u)
	if c == nil {
		return nil
	}

	g := &Entry{native: c}

	return g
}

func (recv *Entry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Entry) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Entry) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Entry) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Entry.
// Exercise care, as this is a potentially dangerous function if the Object is not a Entry.
func CastToEntry(object *gobject.Object) *Entry {
	return EntryNewFromC(object.ToC())
}

type signalEntryActivateDetail struct {
	callback  EntrySignalActivateCallback
	handlerID C.gulong
}

var signalEntryActivateId int
var signalEntryActivateMap = make(map[int]signalEntryActivateDetail)
var signalEntryActivateLock sync.Mutex

// EntrySignalActivateCallback is a callback function for a 'activate' signal emitted from a Entry.
type EntrySignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Entry) ConnectActivate(callback EntrySignalActivateCallback) int {
	signalEntryActivateLock.Lock()
	defer signalEntryActivateLock.Unlock()

	signalEntryActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_activate(instance, C.gpointer(uintptr(signalEntryActivateId)))

	detail := signalEntryActivateDetail{callback, handlerID}
	signalEntryActivateMap[signalEntryActivateId] = detail

	return signalEntryActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Entry.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Entry) DisconnectActivate(connectionID int) {
	signalEntryActivateLock.Lock()
	defer signalEntryActivateLock.Unlock()

	detail, exists := signalEntryActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryActivateMap, connectionID)
}

//export entry_activateHandler
func entry_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryActivateMap[index].callback
	callback()
}

type signalEntryBackspaceDetail struct {
	callback  EntrySignalBackspaceCallback
	handlerID C.gulong
}

var signalEntryBackspaceId int
var signalEntryBackspaceMap = make(map[int]signalEntryBackspaceDetail)
var signalEntryBackspaceLock sync.Mutex

// EntrySignalBackspaceCallback is a callback function for a 'backspace' signal emitted from a Entry.
type EntrySignalBackspaceCallback func()

/*
ConnectBackspace connects the callback to the 'backspace' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectBackspace to remove it.
*/
func (recv *Entry) ConnectBackspace(callback EntrySignalBackspaceCallback) int {
	signalEntryBackspaceLock.Lock()
	defer signalEntryBackspaceLock.Unlock()

	signalEntryBackspaceId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_backspace(instance, C.gpointer(uintptr(signalEntryBackspaceId)))

	detail := signalEntryBackspaceDetail{callback, handlerID}
	signalEntryBackspaceMap[signalEntryBackspaceId] = detail

	return signalEntryBackspaceId
}

/*
DisconnectBackspace disconnects a callback from the 'backspace' signal for the Entry.

The connectionID should be a value returned from a call to ConnectBackspace.
*/
func (recv *Entry) DisconnectBackspace(connectionID int) {
	signalEntryBackspaceLock.Lock()
	defer signalEntryBackspaceLock.Unlock()

	detail, exists := signalEntryBackspaceMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryBackspaceMap, connectionID)
}

//export entry_backspaceHandler
func entry_backspaceHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryBackspaceMap[index].callback
	callback()
}

type signalEntryCopyClipboardDetail struct {
	callback  EntrySignalCopyClipboardCallback
	handlerID C.gulong
}

var signalEntryCopyClipboardId int
var signalEntryCopyClipboardMap = make(map[int]signalEntryCopyClipboardDetail)
var signalEntryCopyClipboardLock sync.Mutex

// EntrySignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a Entry.
type EntrySignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *Entry) ConnectCopyClipboard(callback EntrySignalCopyClipboardCallback) int {
	signalEntryCopyClipboardLock.Lock()
	defer signalEntryCopyClipboardLock.Unlock()

	signalEntryCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalEntryCopyClipboardId)))

	detail := signalEntryCopyClipboardDetail{callback, handlerID}
	signalEntryCopyClipboardMap[signalEntryCopyClipboardId] = detail

	return signalEntryCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *Entry) DisconnectCopyClipboard(connectionID int) {
	signalEntryCopyClipboardLock.Lock()
	defer signalEntryCopyClipboardLock.Unlock()

	detail, exists := signalEntryCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCopyClipboardMap, connectionID)
}

//export entry_copyClipboardHandler
func entry_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryCopyClipboardMap[index].callback
	callback()
}

type signalEntryCutClipboardDetail struct {
	callback  EntrySignalCutClipboardCallback
	handlerID C.gulong
}

var signalEntryCutClipboardId int
var signalEntryCutClipboardMap = make(map[int]signalEntryCutClipboardDetail)
var signalEntryCutClipboardLock sync.Mutex

// EntrySignalCutClipboardCallback is a callback function for a 'cut-clipboard' signal emitted from a Entry.
type EntrySignalCutClipboardCallback func()

/*
ConnectCutClipboard connects the callback to the 'cut-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectCutClipboard to remove it.
*/
func (recv *Entry) ConnectCutClipboard(callback EntrySignalCutClipboardCallback) int {
	signalEntryCutClipboardLock.Lock()
	defer signalEntryCutClipboardLock.Unlock()

	signalEntryCutClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_cut_clipboard(instance, C.gpointer(uintptr(signalEntryCutClipboardId)))

	detail := signalEntryCutClipboardDetail{callback, handlerID}
	signalEntryCutClipboardMap[signalEntryCutClipboardId] = detail

	return signalEntryCutClipboardId
}

/*
DisconnectCutClipboard disconnects a callback from the 'cut-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectCutClipboard.
*/
func (recv *Entry) DisconnectCutClipboard(connectionID int) {
	signalEntryCutClipboardLock.Lock()
	defer signalEntryCutClipboardLock.Unlock()

	detail, exists := signalEntryCutClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCutClipboardMap, connectionID)
}

//export entry_cutClipboardHandler
func entry_cutClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryCutClipboardMap[index].callback
	callback()
}

// Unsupported signal 'delete-from-cursor' for Entry : unsupported parameter type : type DeleteType :

// Unsupported signal 'insert-at-cursor' for Entry : unsupported parameter string : type utf8 :

// Unsupported signal 'move-cursor' for Entry : unsupported parameter step : type MovementStep :

type signalEntryPasteClipboardDetail struct {
	callback  EntrySignalPasteClipboardCallback
	handlerID C.gulong
}

var signalEntryPasteClipboardId int
var signalEntryPasteClipboardMap = make(map[int]signalEntryPasteClipboardDetail)
var signalEntryPasteClipboardLock sync.Mutex

// EntrySignalPasteClipboardCallback is a callback function for a 'paste-clipboard' signal emitted from a Entry.
type EntrySignalPasteClipboardCallback func()

/*
ConnectPasteClipboard connects the callback to the 'paste-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectPasteClipboard to remove it.
*/
func (recv *Entry) ConnectPasteClipboard(callback EntrySignalPasteClipboardCallback) int {
	signalEntryPasteClipboardLock.Lock()
	defer signalEntryPasteClipboardLock.Unlock()

	signalEntryPasteClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_paste_clipboard(instance, C.gpointer(uintptr(signalEntryPasteClipboardId)))

	detail := signalEntryPasteClipboardDetail{callback, handlerID}
	signalEntryPasteClipboardMap[signalEntryPasteClipboardId] = detail

	return signalEntryPasteClipboardId
}

/*
DisconnectPasteClipboard disconnects a callback from the 'paste-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectPasteClipboard.
*/
func (recv *Entry) DisconnectPasteClipboard(connectionID int) {
	signalEntryPasteClipboardLock.Lock()
	defer signalEntryPasteClipboardLock.Unlock()

	detail, exists := signalEntryPasteClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryPasteClipboardMap, connectionID)
}

//export entry_pasteClipboardHandler
func entry_pasteClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryPasteClipboardMap[index].callback
	callback()
}

type signalEntryPopulatePopupDetail struct {
	callback  EntrySignalPopulatePopupCallback
	handlerID C.gulong
}

var signalEntryPopulatePopupId int
var signalEntryPopulatePopupMap = make(map[int]signalEntryPopulatePopupDetail)
var signalEntryPopulatePopupLock sync.Mutex

// EntrySignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a Entry.
type EntrySignalPopulatePopupCallback func(widget *Widget)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *Entry) ConnectPopulatePopup(callback EntrySignalPopulatePopupCallback) int {
	signalEntryPopulatePopupLock.Lock()
	defer signalEntryPopulatePopupLock.Unlock()

	signalEntryPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalEntryPopulatePopupId)))

	detail := signalEntryPopulatePopupDetail{callback, handlerID}
	signalEntryPopulatePopupMap[signalEntryPopulatePopupId] = detail

	return signalEntryPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the Entry.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *Entry) DisconnectPopulatePopup(connectionID int) {
	signalEntryPopulatePopupLock.Lock()
	defer signalEntryPopulatePopupLock.Unlock()

	detail, exists := signalEntryPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryPopulatePopupMap, connectionID)
}

//export entry_populatePopupHandler
func entry_populatePopupHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalEntryPopulatePopupMap[index].callback
	callback(widget)
}

type signalEntryToggleOverwriteDetail struct {
	callback  EntrySignalToggleOverwriteCallback
	handlerID C.gulong
}

var signalEntryToggleOverwriteId int
var signalEntryToggleOverwriteMap = make(map[int]signalEntryToggleOverwriteDetail)
var signalEntryToggleOverwriteLock sync.Mutex

// EntrySignalToggleOverwriteCallback is a callback function for a 'toggle-overwrite' signal emitted from a Entry.
type EntrySignalToggleOverwriteCallback func()

/*
ConnectToggleOverwrite connects the callback to the 'toggle-overwrite' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectToggleOverwrite to remove it.
*/
func (recv *Entry) ConnectToggleOverwrite(callback EntrySignalToggleOverwriteCallback) int {
	signalEntryToggleOverwriteLock.Lock()
	defer signalEntryToggleOverwriteLock.Unlock()

	signalEntryToggleOverwriteId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_toggle_overwrite(instance, C.gpointer(uintptr(signalEntryToggleOverwriteId)))

	detail := signalEntryToggleOverwriteDetail{callback, handlerID}
	signalEntryToggleOverwriteMap[signalEntryToggleOverwriteId] = detail

	return signalEntryToggleOverwriteId
}

/*
DisconnectToggleOverwrite disconnects a callback from the 'toggle-overwrite' signal for the Entry.

The connectionID should be a value returned from a call to ConnectToggleOverwrite.
*/
func (recv *Entry) DisconnectToggleOverwrite(connectionID int) {
	signalEntryToggleOverwriteLock.Lock()
	defer signalEntryToggleOverwriteLock.Unlock()

	detail, exists := signalEntryToggleOverwriteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryToggleOverwriteMap, connectionID)
}

//export entry_toggleOverwriteHandler
func entry_toggleOverwriteHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalEntryToggleOverwriteMap[index].callback
	callback()
}

// Creates a new entry.
/*

C function : gtk_entry_new
*/
func EntryNew() *Entry {
	retC := C.gtk_entry_new()
	retGo := EntryNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the value set by gtk_entry_set_activates_default().
/*

C function : gtk_entry_get_activates_default
*/
func (recv *Entry) GetActivatesDefault() bool {
	retC := C.gtk_entry_get_activates_default((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_entry_set_has_frame().
/*

C function : gtk_entry_get_has_frame
*/
func (recv *Entry) GetHasFrame() bool {
	retC := C.gtk_entry_get_has_frame((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves the character displayed in place of the real characters
// for entries with visibility set to false. See gtk_entry_set_invisible_char().
/*

C function : gtk_entry_get_invisible_char
*/
func (recv *Entry) GetInvisibleChar() rune {
	retC := C.gtk_entry_get_invisible_char((*C.GtkEntry)(recv.native))
	retGo := (rune)(retC)

	return retGo
}

// Gets the #PangoLayout used to display the entry.
// The layout is useful to e.g. convert text positions to
// pixel positions, in combination with gtk_entry_get_layout_offsets().
// The returned layout is owned by the entry and must not be
// modified or freed by the caller.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte
// indices in the layout to byte indices in the entry contents.
/*

C function : gtk_entry_get_layout
*/
func (recv *Entry) GetLayout() *pango.Layout {
	retC := C.gtk_entry_get_layout((*C.GtkEntry)(recv.native))
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Obtains the position of the #PangoLayout used to render text
// in the entry, in widget coordinates. Useful if you want to line
// up the text in an entry with some other text, e.g. when using the
// entry to implement editable cells in a sheet widget.
//
// Also useful to convert mouse events into coordinates inside the
// #PangoLayout, e.g. to take some action if some part of the entry text
// is clicked.
//
// Note that as the user scrolls around in the entry the offsets will
// change; you’ll need to connect to the “notify::scroll-offset”
// signal to track this. Remember when using the #PangoLayout
// functions you need to convert to and from pixels using
// PANGO_PIXELS() or #PANGO_SCALE.
//
// Keep in mind that the layout text may contain a preedit string, so
// gtk_entry_layout_index_to_text_index() and
// gtk_entry_text_index_to_layout_index() are needed to convert byte
// indices in the layout to byte indices in the entry contents.
/*

C function : gtk_entry_get_layout_offsets
*/
func (recv *Entry) GetLayoutOffsets() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_entry_get_layout_offsets((*C.GtkEntry)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// Retrieves the maximum allowed length of the text in
// @entry. See gtk_entry_set_max_length().
//
// This is equivalent to getting @entry's #GtkEntryBuffer and
// calling gtk_entry_buffer_get_max_length() on it.
/*

C function : gtk_entry_get_max_length
*/
func (recv *Entry) GetMaxLength() int32 {
	retC := C.gtk_entry_get_max_length((*C.GtkEntry)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Retrieves the contents of the entry widget.
// See also gtk_editable_get_chars().
//
// This is equivalent to getting @entry's #GtkEntryBuffer and calling
// gtk_entry_buffer_get_text() on it.
/*

C function : gtk_entry_get_text
*/
func (recv *Entry) GetText() string {
	retC := C.gtk_entry_get_text((*C.GtkEntry)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Retrieves whether the text in @entry is visible. See
// gtk_entry_set_visibility().
/*

C function : gtk_entry_get_visibility
*/
func (recv *Entry) GetVisibility() bool {
	retC := C.gtk_entry_get_visibility((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_entry_set_width_chars().
/*

C function : gtk_entry_get_width_chars
*/
func (recv *Entry) GetWidthChars() int32 {
	retC := C.gtk_entry_get_width_chars((*C.GtkEntry)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Converts from a position in the entry’s #PangoLayout (returned by
// gtk_entry_get_layout()) to a position in the entry contents
// (returned by gtk_entry_get_text()).
/*

C function : gtk_entry_layout_index_to_text_index
*/
func (recv *Entry) LayoutIndexToTextIndex(layoutIndex int32) int32 {
	c_layout_index := (C.gint)(layoutIndex)

	retC := C.gtk_entry_layout_index_to_text_index((*C.GtkEntry)(recv.native), c_layout_index)
	retGo := (int32)(retC)

	return retGo
}

// If @setting is %TRUE, pressing Enter in the @entry will activate the default
// widget for the window containing the entry. This usually means that
// the dialog box containing the entry will be closed, since the default
// widget is usually one of the dialog buttons.
//
// (For experts: if @setting is %TRUE, the entry calls
// gtk_window_activate_default() on the window containing the entry, in
// the default handler for the #GtkEntry::activate signal.)
/*

C function : gtk_entry_set_activates_default
*/
func (recv *Entry) SetActivatesDefault(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_entry_set_activates_default((*C.GtkEntry)(recv.native), c_setting)

	return
}

// Sets whether the entry has a beveled frame around it.
/*

C function : gtk_entry_set_has_frame
*/
func (recv *Entry) SetHasFrame(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_entry_set_has_frame((*C.GtkEntry)(recv.native), c_setting)

	return
}

// Sets the character to use in place of the actual text when
// gtk_entry_set_visibility() has been called to set text visibility
// to %FALSE. i.e. this is the character used in “password mode” to
// show the user how many characters have been typed. By default, GTK+
// picks the best invisible char available in the current font. If you
// set the invisible char to 0, then the user will get no feedback
// at all; there will be no text on the screen as they type.
/*

C function : gtk_entry_set_invisible_char
*/
func (recv *Entry) SetInvisibleChar(ch rune) {
	c_ch := (C.gunichar)(ch)

	C.gtk_entry_set_invisible_char((*C.GtkEntry)(recv.native), c_ch)

	return
}

// Sets the maximum allowed length of the contents of the widget. If
// the current contents are longer than the given length, then they
// will be truncated to fit.
//
// This is equivalent to getting @entry's #GtkEntryBuffer and
// calling gtk_entry_buffer_set_max_length() on it.
// ]|
/*

C function : gtk_entry_set_max_length
*/
func (recv *Entry) SetMaxLength(max int32) {
	c_max := (C.gint)(max)

	C.gtk_entry_set_max_length((*C.GtkEntry)(recv.native), c_max)

	return
}

// Sets the text in the widget to the given
// value, replacing the current contents.
//
// See gtk_entry_buffer_set_text().
/*

C function : gtk_entry_set_text
*/
func (recv *Entry) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_entry_set_text((*C.GtkEntry)(recv.native), c_text)

	return
}

// Sets whether the contents of the entry are visible or not.
// When visibility is set to %FALSE, characters are displayed
// as the invisible char, and will also appear that way when
// the text in the entry widget is copied elsewhere.
//
// By default, GTK+ picks the best invisible character available
// in the current font, but it can be changed with
// gtk_entry_set_invisible_char().
//
// Note that you probably want to set #GtkEntry:input-purpose
// to %GTK_INPUT_PURPOSE_PASSWORD or %GTK_INPUT_PURPOSE_PIN to
// inform input methods about the purpose of this entry,
// in addition to setting visibility to %FALSE.
/*

C function : gtk_entry_set_visibility
*/
func (recv *Entry) SetVisibility(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_entry_set_visibility((*C.GtkEntry)(recv.native), c_visible)

	return
}

// Changes the size request of the entry to be about the right size
// for @n_chars characters. Note that it changes the size
// request, the size can still be affected by
// how you pack the widget into containers. If @n_chars is -1, the
// size reverts to the default entry size.
/*

C function : gtk_entry_set_width_chars
*/
func (recv *Entry) SetWidthChars(nChars int32) {
	c_n_chars := (C.gint)(nChars)

	C.gtk_entry_set_width_chars((*C.GtkEntry)(recv.native), c_n_chars)

	return
}

// Converts from a position in the entry contents (returned
// by gtk_entry_get_text()) to a position in the
// entry’s #PangoLayout (returned by gtk_entry_get_layout(),
// with text retrieved via pango_layout_get_text()).
/*

C function : gtk_entry_text_index_to_layout_index
*/
func (recv *Entry) TextIndexToLayoutIndex(textIndex int32) int32 {
	c_text_index := (C.gint)(textIndex)

	retC := C.gtk_entry_text_index_to_layout_index((*C.GtkEntry)(recv.native), c_text_index)
	retGo := (int32)(retC)

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Entry
func (recv *Entry) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Entry
func (recv *Entry) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by Entry
func (recv *Entry) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by Entry
func (recv *Entry) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// EntryAccessible is a wrapper around the C record GtkEntryAccessible.
type EntryAccessible struct {
	native *C.GtkEntryAccessible
	// parent : record
	// priv : record
}

func EntryAccessibleNewFromC(u unsafe.Pointer) *EntryAccessible {
	c := (*C.GtkEntryAccessible)(u)
	if c == nil {
		return nil
	}

	g := &EntryAccessible{native: c}

	return g
}

func (recv *EntryAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *EntryAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *EntryAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *EntryAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to EntryAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryAccessible.
func CastToEntryAccessible(object *gobject.Object) *EntryAccessible {
	return EntryAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by EntryAccessible
func (recv *EntryAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by EntryAccessible
func (recv *EntryAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by EntryAccessible
func (recv *EntryAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by EntryAccessible
func (recv *EntryAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// EntryBuffer is a wrapper around the C record GtkEntryBuffer.
type EntryBuffer struct {
	native *C.GtkEntryBuffer
	// parent_instance : record
	// Private : priv
}

func EntryBufferNewFromC(u unsafe.Pointer) *EntryBuffer {
	c := (*C.GtkEntryBuffer)(u)
	if c == nil {
		return nil
	}

	g := &EntryBuffer{native: c}

	return g
}

func (recv *EntryBuffer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *EntryBuffer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to EntryBuffer.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryBuffer.
func CastToEntryBuffer(object *gobject.Object) *EntryBuffer {
	return EntryBufferNewFromC(object.ToC())
}

// EntryCompletion is a wrapper around the C record GtkEntryCompletion.
type EntryCompletion struct {
	native *C.GtkEntryCompletion
	// parent_instance : record
	// Private : priv
}

func EntryCompletionNewFromC(u unsafe.Pointer) *EntryCompletion {
	c := (*C.GtkEntryCompletion)(u)
	if c == nil {
		return nil
	}

	g := &EntryCompletion{native: c}

	return g
}

func (recv *EntryCompletion) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *EntryCompletion) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to EntryCompletion.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryCompletion.
func CastToEntryCompletion(object *gobject.Object) *EntryCompletion {
	return EntryCompletionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by EntryCompletion
func (recv *EntryCompletion) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by EntryCompletion
func (recv *EntryCompletion) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Unsupported : EntryIconAccessible : no CType

// EventBox is a wrapper around the C record GtkEventBox.
type EventBox struct {
	native *C.GtkEventBox
	// bin : record
	// Private : priv
}

func EventBoxNewFromC(u unsafe.Pointer) *EventBox {
	c := (*C.GtkEventBox)(u)
	if c == nil {
		return nil
	}

	g := &EventBox{native: c}

	return g
}

func (recv *EventBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *EventBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *EventBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *EventBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *EventBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *EventBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to EventBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a EventBox.
func CastToEventBox(object *gobject.Object) *EventBox {
	return EventBoxNewFromC(object.ToC())
}

// Creates a new #GtkEventBox.
/*

C function : gtk_event_box_new
*/
func EventBoxNew() *EventBox {
	retC := C.gtk_event_box_new()
	retGo := EventBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by EventBox
func (recv *EventBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by EventBox
func (recv *EventBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// EventController is a wrapper around the C record GtkEventController.
type EventController struct {
	native *C.GtkEventController
}

func EventControllerNewFromC(u unsafe.Pointer) *EventController {
	c := (*C.GtkEventController)(u)
	if c == nil {
		return nil
	}

	g := &EventController{native: c}

	return g
}

func (recv *EventController) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *EventController) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to EventController.
// Exercise care, as this is a potentially dangerous function if the Object is not a EventController.
func CastToEventController(object *gobject.Object) *EventController {
	return EventControllerNewFromC(object.ToC())
}

// Expander is a wrapper around the C record GtkExpander.
type Expander struct {
	native *C.GtkExpander
	// bin : record
	// priv : record
}

func ExpanderNewFromC(u unsafe.Pointer) *Expander {
	c := (*C.GtkExpander)(u)
	if c == nil {
		return nil
	}

	g := &Expander{native: c}

	return g
}

func (recv *Expander) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Expander) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Expander) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Expander) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Expander) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Expander) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Expander.
// Exercise care, as this is a potentially dangerous function if the Object is not a Expander.
func CastToExpander(object *gobject.Object) *Expander {
	return ExpanderNewFromC(object.ToC())
}

type signalExpanderActivateDetail struct {
	callback  ExpanderSignalActivateCallback
	handlerID C.gulong
}

var signalExpanderActivateId int
var signalExpanderActivateMap = make(map[int]signalExpanderActivateDetail)
var signalExpanderActivateLock sync.Mutex

// ExpanderSignalActivateCallback is a callback function for a 'activate' signal emitted from a Expander.
type ExpanderSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Expander.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Expander) ConnectActivate(callback ExpanderSignalActivateCallback) int {
	signalExpanderActivateLock.Lock()
	defer signalExpanderActivateLock.Unlock()

	signalExpanderActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Expander_signal_connect_activate(instance, C.gpointer(uintptr(signalExpanderActivateId)))

	detail := signalExpanderActivateDetail{callback, handlerID}
	signalExpanderActivateMap[signalExpanderActivateId] = detail

	return signalExpanderActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Expander.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Expander) DisconnectActivate(connectionID int) {
	signalExpanderActivateLock.Lock()
	defer signalExpanderActivateLock.Unlock()

	detail, exists := signalExpanderActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalExpanderActivateMap, connectionID)
}

//export expander_activateHandler
func expander_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalExpanderActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Expander
func (recv *Expander) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Expander
func (recv *Expander) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ExpanderAccessible is a wrapper around the C record GtkExpanderAccessible.
type ExpanderAccessible struct {
	native *C.GtkExpanderAccessible
	// parent : record
	// priv : record
}

func ExpanderAccessibleNewFromC(u unsafe.Pointer) *ExpanderAccessible {
	c := (*C.GtkExpanderAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ExpanderAccessible{native: c}

	return g
}

func (recv *ExpanderAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ExpanderAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ExpanderAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ExpanderAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ExpanderAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ExpanderAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ExpanderAccessible.
func CastToExpanderAccessible(object *gobject.Object) *ExpanderAccessible {
	return ExpanderAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ExpanderAccessible
func (recv *ExpanderAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ExpanderAccessible
func (recv *ExpanderAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// FileChooserButton is a wrapper around the C record GtkFileChooserButton.
type FileChooserButton struct {
	native *C.GtkFileChooserButton
	// parent : record
	// Private : priv
}

func FileChooserButtonNewFromC(u unsafe.Pointer) *FileChooserButton {
	c := (*C.GtkFileChooserButton)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserButton{native: c}

	return g
}

func (recv *FileChooserButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *FileChooserButton) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FileChooserButton) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserButton) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserButton) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to FileChooserButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserButton.
func CastToFileChooserButton(object *gobject.Object) *FileChooserButton {
	return FileChooserButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserButton
func (recv *FileChooserButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserButton
func (recv *FileChooserButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserButton
func (recv *FileChooserButton) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FileChooserButton
func (recv *FileChooserButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FileChooserDialog is a wrapper around the C record GtkFileChooserDialog.
type FileChooserDialog struct {
	native *C.GtkFileChooserDialog
	// parent_instance : record
	// priv : record
}

func FileChooserDialogNewFromC(u unsafe.Pointer) *FileChooserDialog {
	c := (*C.GtkFileChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserDialog{native: c}

	return g
}

func (recv *FileChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *FileChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FileChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FileChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FileChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to FileChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserDialog.
func CastToFileChooserDialog(object *gobject.Object) *FileChooserDialog {
	return FileChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserDialog
func (recv *FileChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserDialog
func (recv *FileChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserDialog
func (recv *FileChooserDialog) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// FileChooserWidget is a wrapper around the C record GtkFileChooserWidget.
type FileChooserWidget struct {
	native *C.GtkFileChooserWidget
	// parent_instance : record
	// priv : record
}

func FileChooserWidgetNewFromC(u unsafe.Pointer) *FileChooserWidget {
	c := (*C.GtkFileChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserWidget{native: c}

	return g
}

func (recv *FileChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *FileChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FileChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to FileChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserWidget.
func CastToFileChooserWidget(object *gobject.Object) *FileChooserWidget {
	return FileChooserWidgetNewFromC(object.ToC())
}

type signalFileChooserWidgetDesktopFolderDetail struct {
	callback  FileChooserWidgetSignalDesktopFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetDesktopFolderId int
var signalFileChooserWidgetDesktopFolderMap = make(map[int]signalFileChooserWidgetDesktopFolderDetail)
var signalFileChooserWidgetDesktopFolderLock sync.Mutex

// FileChooserWidgetSignalDesktopFolderCallback is a callback function for a 'desktop-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalDesktopFolderCallback func()

/*
ConnectDesktopFolder connects the callback to the 'desktop-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectDesktopFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectDesktopFolder(callback FileChooserWidgetSignalDesktopFolderCallback) int {
	signalFileChooserWidgetDesktopFolderLock.Lock()
	defer signalFileChooserWidgetDesktopFolderLock.Unlock()

	signalFileChooserWidgetDesktopFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_desktop_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetDesktopFolderId)))

	detail := signalFileChooserWidgetDesktopFolderDetail{callback, handlerID}
	signalFileChooserWidgetDesktopFolderMap[signalFileChooserWidgetDesktopFolderId] = detail

	return signalFileChooserWidgetDesktopFolderId
}

/*
DisconnectDesktopFolder disconnects a callback from the 'desktop-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectDesktopFolder.
*/
func (recv *FileChooserWidget) DisconnectDesktopFolder(connectionID int) {
	signalFileChooserWidgetDesktopFolderLock.Lock()
	defer signalFileChooserWidgetDesktopFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetDesktopFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetDesktopFolderMap, connectionID)
}

//export filechooserwidget_desktopFolderHandler
func filechooserwidget_desktopFolderHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetDesktopFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetDownFolderDetail struct {
	callback  FileChooserWidgetSignalDownFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetDownFolderId int
var signalFileChooserWidgetDownFolderMap = make(map[int]signalFileChooserWidgetDownFolderDetail)
var signalFileChooserWidgetDownFolderLock sync.Mutex

// FileChooserWidgetSignalDownFolderCallback is a callback function for a 'down-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalDownFolderCallback func()

/*
ConnectDownFolder connects the callback to the 'down-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectDownFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectDownFolder(callback FileChooserWidgetSignalDownFolderCallback) int {
	signalFileChooserWidgetDownFolderLock.Lock()
	defer signalFileChooserWidgetDownFolderLock.Unlock()

	signalFileChooserWidgetDownFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_down_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetDownFolderId)))

	detail := signalFileChooserWidgetDownFolderDetail{callback, handlerID}
	signalFileChooserWidgetDownFolderMap[signalFileChooserWidgetDownFolderId] = detail

	return signalFileChooserWidgetDownFolderId
}

/*
DisconnectDownFolder disconnects a callback from the 'down-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectDownFolder.
*/
func (recv *FileChooserWidget) DisconnectDownFolder(connectionID int) {
	signalFileChooserWidgetDownFolderLock.Lock()
	defer signalFileChooserWidgetDownFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetDownFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetDownFolderMap, connectionID)
}

//export filechooserwidget_downFolderHandler
func filechooserwidget_downFolderHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetDownFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetHomeFolderDetail struct {
	callback  FileChooserWidgetSignalHomeFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetHomeFolderId int
var signalFileChooserWidgetHomeFolderMap = make(map[int]signalFileChooserWidgetHomeFolderDetail)
var signalFileChooserWidgetHomeFolderLock sync.Mutex

// FileChooserWidgetSignalHomeFolderCallback is a callback function for a 'home-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalHomeFolderCallback func()

/*
ConnectHomeFolder connects the callback to the 'home-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectHomeFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectHomeFolder(callback FileChooserWidgetSignalHomeFolderCallback) int {
	signalFileChooserWidgetHomeFolderLock.Lock()
	defer signalFileChooserWidgetHomeFolderLock.Unlock()

	signalFileChooserWidgetHomeFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_home_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetHomeFolderId)))

	detail := signalFileChooserWidgetHomeFolderDetail{callback, handlerID}
	signalFileChooserWidgetHomeFolderMap[signalFileChooserWidgetHomeFolderId] = detail

	return signalFileChooserWidgetHomeFolderId
}

/*
DisconnectHomeFolder disconnects a callback from the 'home-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectHomeFolder.
*/
func (recv *FileChooserWidget) DisconnectHomeFolder(connectionID int) {
	signalFileChooserWidgetHomeFolderLock.Lock()
	defer signalFileChooserWidgetHomeFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetHomeFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetHomeFolderMap, connectionID)
}

//export filechooserwidget_homeFolderHandler
func filechooserwidget_homeFolderHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetHomeFolderMap[index].callback
	callback()
}

// Unsupported signal 'location-popup' for FileChooserWidget : unsupported parameter path : type utf8 :

type signalFileChooserWidgetLocationPopupOnPasteDetail struct {
	callback  FileChooserWidgetSignalLocationPopupOnPasteCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationPopupOnPasteId int
var signalFileChooserWidgetLocationPopupOnPasteMap = make(map[int]signalFileChooserWidgetLocationPopupOnPasteDetail)
var signalFileChooserWidgetLocationPopupOnPasteLock sync.Mutex

// FileChooserWidgetSignalLocationPopupOnPasteCallback is a callback function for a 'location-popup-on-paste' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationPopupOnPasteCallback func()

/*
ConnectLocationPopupOnPaste connects the callback to the 'location-popup-on-paste' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationPopupOnPaste to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationPopupOnPaste(callback FileChooserWidgetSignalLocationPopupOnPasteCallback) int {
	signalFileChooserWidgetLocationPopupOnPasteLock.Lock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.Unlock()

	signalFileChooserWidgetLocationPopupOnPasteId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_popup_on_paste(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationPopupOnPasteId)))

	detail := signalFileChooserWidgetLocationPopupOnPasteDetail{callback, handlerID}
	signalFileChooserWidgetLocationPopupOnPasteMap[signalFileChooserWidgetLocationPopupOnPasteId] = detail

	return signalFileChooserWidgetLocationPopupOnPasteId
}

/*
DisconnectLocationPopupOnPaste disconnects a callback from the 'location-popup-on-paste' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationPopupOnPaste.
*/
func (recv *FileChooserWidget) DisconnectLocationPopupOnPaste(connectionID int) {
	signalFileChooserWidgetLocationPopupOnPasteLock.Lock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationPopupOnPasteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationPopupOnPasteMap, connectionID)
}

//export filechooserwidget_locationPopupOnPasteHandler
func filechooserwidget_locationPopupOnPasteHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationPopupOnPasteMap[index].callback
	callback()
}

type signalFileChooserWidgetLocationTogglePopupDetail struct {
	callback  FileChooserWidgetSignalLocationTogglePopupCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationTogglePopupId int
var signalFileChooserWidgetLocationTogglePopupMap = make(map[int]signalFileChooserWidgetLocationTogglePopupDetail)
var signalFileChooserWidgetLocationTogglePopupLock sync.Mutex

// FileChooserWidgetSignalLocationTogglePopupCallback is a callback function for a 'location-toggle-popup' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationTogglePopupCallback func()

/*
ConnectLocationTogglePopup connects the callback to the 'location-toggle-popup' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationTogglePopup to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationTogglePopup(callback FileChooserWidgetSignalLocationTogglePopupCallback) int {
	signalFileChooserWidgetLocationTogglePopupLock.Lock()
	defer signalFileChooserWidgetLocationTogglePopupLock.Unlock()

	signalFileChooserWidgetLocationTogglePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_toggle_popup(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationTogglePopupId)))

	detail := signalFileChooserWidgetLocationTogglePopupDetail{callback, handlerID}
	signalFileChooserWidgetLocationTogglePopupMap[signalFileChooserWidgetLocationTogglePopupId] = detail

	return signalFileChooserWidgetLocationTogglePopupId
}

/*
DisconnectLocationTogglePopup disconnects a callback from the 'location-toggle-popup' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationTogglePopup.
*/
func (recv *FileChooserWidget) DisconnectLocationTogglePopup(connectionID int) {
	signalFileChooserWidgetLocationTogglePopupLock.Lock()
	defer signalFileChooserWidgetLocationTogglePopupLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationTogglePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationTogglePopupMap, connectionID)
}

//export filechooserwidget_locationTogglePopupHandler
func filechooserwidget_locationTogglePopupHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationTogglePopupMap[index].callback
	callback()
}

type signalFileChooserWidgetPlacesShortcutDetail struct {
	callback  FileChooserWidgetSignalPlacesShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetPlacesShortcutId int
var signalFileChooserWidgetPlacesShortcutMap = make(map[int]signalFileChooserWidgetPlacesShortcutDetail)
var signalFileChooserWidgetPlacesShortcutLock sync.Mutex

// FileChooserWidgetSignalPlacesShortcutCallback is a callback function for a 'places-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalPlacesShortcutCallback func()

/*
ConnectPlacesShortcut connects the callback to the 'places-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectPlacesShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectPlacesShortcut(callback FileChooserWidgetSignalPlacesShortcutCallback) int {
	signalFileChooserWidgetPlacesShortcutLock.Lock()
	defer signalFileChooserWidgetPlacesShortcutLock.Unlock()

	signalFileChooserWidgetPlacesShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_places_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetPlacesShortcutId)))

	detail := signalFileChooserWidgetPlacesShortcutDetail{callback, handlerID}
	signalFileChooserWidgetPlacesShortcutMap[signalFileChooserWidgetPlacesShortcutId] = detail

	return signalFileChooserWidgetPlacesShortcutId
}

/*
DisconnectPlacesShortcut disconnects a callback from the 'places-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectPlacesShortcut.
*/
func (recv *FileChooserWidget) DisconnectPlacesShortcut(connectionID int) {
	signalFileChooserWidgetPlacesShortcutLock.Lock()
	defer signalFileChooserWidgetPlacesShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetPlacesShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetPlacesShortcutMap, connectionID)
}

//export filechooserwidget_placesShortcutHandler
func filechooserwidget_placesShortcutHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetPlacesShortcutMap[index].callback
	callback()
}

// Unsupported signal 'quick-bookmark' for FileChooserWidget : unsupported parameter bookmark_index : type gint :

type signalFileChooserWidgetRecentShortcutDetail struct {
	callback  FileChooserWidgetSignalRecentShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetRecentShortcutId int
var signalFileChooserWidgetRecentShortcutMap = make(map[int]signalFileChooserWidgetRecentShortcutDetail)
var signalFileChooserWidgetRecentShortcutLock sync.Mutex

// FileChooserWidgetSignalRecentShortcutCallback is a callback function for a 'recent-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalRecentShortcutCallback func()

/*
ConnectRecentShortcut connects the callback to the 'recent-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectRecentShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectRecentShortcut(callback FileChooserWidgetSignalRecentShortcutCallback) int {
	signalFileChooserWidgetRecentShortcutLock.Lock()
	defer signalFileChooserWidgetRecentShortcutLock.Unlock()

	signalFileChooserWidgetRecentShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_recent_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetRecentShortcutId)))

	detail := signalFileChooserWidgetRecentShortcutDetail{callback, handlerID}
	signalFileChooserWidgetRecentShortcutMap[signalFileChooserWidgetRecentShortcutId] = detail

	return signalFileChooserWidgetRecentShortcutId
}

/*
DisconnectRecentShortcut disconnects a callback from the 'recent-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectRecentShortcut.
*/
func (recv *FileChooserWidget) DisconnectRecentShortcut(connectionID int) {
	signalFileChooserWidgetRecentShortcutLock.Lock()
	defer signalFileChooserWidgetRecentShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetRecentShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetRecentShortcutMap, connectionID)
}

//export filechooserwidget_recentShortcutHandler
func filechooserwidget_recentShortcutHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetRecentShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetSearchShortcutDetail struct {
	callback  FileChooserWidgetSignalSearchShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetSearchShortcutId int
var signalFileChooserWidgetSearchShortcutMap = make(map[int]signalFileChooserWidgetSearchShortcutDetail)
var signalFileChooserWidgetSearchShortcutLock sync.Mutex

// FileChooserWidgetSignalSearchShortcutCallback is a callback function for a 'search-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalSearchShortcutCallback func()

/*
ConnectSearchShortcut connects the callback to the 'search-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectSearchShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectSearchShortcut(callback FileChooserWidgetSignalSearchShortcutCallback) int {
	signalFileChooserWidgetSearchShortcutLock.Lock()
	defer signalFileChooserWidgetSearchShortcutLock.Unlock()

	signalFileChooserWidgetSearchShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_search_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetSearchShortcutId)))

	detail := signalFileChooserWidgetSearchShortcutDetail{callback, handlerID}
	signalFileChooserWidgetSearchShortcutMap[signalFileChooserWidgetSearchShortcutId] = detail

	return signalFileChooserWidgetSearchShortcutId
}

/*
DisconnectSearchShortcut disconnects a callback from the 'search-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectSearchShortcut.
*/
func (recv *FileChooserWidget) DisconnectSearchShortcut(connectionID int) {
	signalFileChooserWidgetSearchShortcutLock.Lock()
	defer signalFileChooserWidgetSearchShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetSearchShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetSearchShortcutMap, connectionID)
}

//export filechooserwidget_searchShortcutHandler
func filechooserwidget_searchShortcutHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetSearchShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetShowHiddenDetail struct {
	callback  FileChooserWidgetSignalShowHiddenCallback
	handlerID C.gulong
}

var signalFileChooserWidgetShowHiddenId int
var signalFileChooserWidgetShowHiddenMap = make(map[int]signalFileChooserWidgetShowHiddenDetail)
var signalFileChooserWidgetShowHiddenLock sync.Mutex

// FileChooserWidgetSignalShowHiddenCallback is a callback function for a 'show-hidden' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalShowHiddenCallback func()

/*
ConnectShowHidden connects the callback to the 'show-hidden' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectShowHidden to remove it.
*/
func (recv *FileChooserWidget) ConnectShowHidden(callback FileChooserWidgetSignalShowHiddenCallback) int {
	signalFileChooserWidgetShowHiddenLock.Lock()
	defer signalFileChooserWidgetShowHiddenLock.Unlock()

	signalFileChooserWidgetShowHiddenId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_show_hidden(instance, C.gpointer(uintptr(signalFileChooserWidgetShowHiddenId)))

	detail := signalFileChooserWidgetShowHiddenDetail{callback, handlerID}
	signalFileChooserWidgetShowHiddenMap[signalFileChooserWidgetShowHiddenId] = detail

	return signalFileChooserWidgetShowHiddenId
}

/*
DisconnectShowHidden disconnects a callback from the 'show-hidden' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectShowHidden.
*/
func (recv *FileChooserWidget) DisconnectShowHidden(connectionID int) {
	signalFileChooserWidgetShowHiddenLock.Lock()
	defer signalFileChooserWidgetShowHiddenLock.Unlock()

	detail, exists := signalFileChooserWidgetShowHiddenMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetShowHiddenMap, connectionID)
}

//export filechooserwidget_showHiddenHandler
func filechooserwidget_showHiddenHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetShowHiddenMap[index].callback
	callback()
}

type signalFileChooserWidgetUpFolderDetail struct {
	callback  FileChooserWidgetSignalUpFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetUpFolderId int
var signalFileChooserWidgetUpFolderMap = make(map[int]signalFileChooserWidgetUpFolderDetail)
var signalFileChooserWidgetUpFolderLock sync.Mutex

// FileChooserWidgetSignalUpFolderCallback is a callback function for a 'up-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalUpFolderCallback func()

/*
ConnectUpFolder connects the callback to the 'up-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectUpFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectUpFolder(callback FileChooserWidgetSignalUpFolderCallback) int {
	signalFileChooserWidgetUpFolderLock.Lock()
	defer signalFileChooserWidgetUpFolderLock.Unlock()

	signalFileChooserWidgetUpFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_up_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetUpFolderId)))

	detail := signalFileChooserWidgetUpFolderDetail{callback, handlerID}
	signalFileChooserWidgetUpFolderMap[signalFileChooserWidgetUpFolderId] = detail

	return signalFileChooserWidgetUpFolderId
}

/*
DisconnectUpFolder disconnects a callback from the 'up-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectUpFolder.
*/
func (recv *FileChooserWidget) DisconnectUpFolder(connectionID int) {
	signalFileChooserWidgetUpFolderLock.Lock()
	defer signalFileChooserWidgetUpFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetUpFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetUpFolderMap, connectionID)
}

//export filechooserwidget_upFolderHandler
func filechooserwidget_upFolderHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFileChooserWidgetUpFolderMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserWidget
func (recv *FileChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserWidget
func (recv *FileChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserWidget
func (recv *FileChooserWidget) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FileChooserWidget
func (recv *FileChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FileFilter is a wrapper around the C record GtkFileFilter.
type FileFilter struct {
	native *C.GtkFileFilter
}

func FileFilterNewFromC(u unsafe.Pointer) *FileFilter {
	c := (*C.GtkFileFilter)(u)
	if c == nil {
		return nil
	}

	g := &FileFilter{native: c}

	return g
}

func (recv *FileFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileFilter) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FileFilter) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to FileFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileFilter.
func CastToFileFilter(object *gobject.Object) *FileFilter {
	return FileFilterNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by FileFilter
func (recv *FileFilter) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Fixed is a wrapper around the C record GtkFixed.
type Fixed struct {
	native *C.GtkFixed
	// container : record
	// Private : priv
}

func FixedNewFromC(u unsafe.Pointer) *Fixed {
	c := (*C.GtkFixed)(u)
	if c == nil {
		return nil
	}

	g := &Fixed{native: c}

	return g
}

func (recv *Fixed) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Fixed) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Fixed) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Fixed) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Fixed) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Fixed.
// Exercise care, as this is a potentially dangerous function if the Object is not a Fixed.
func CastToFixed(object *gobject.Object) *Fixed {
	return FixedNewFromC(object.ToC())
}

// Creates a new #GtkFixed.
/*

C function : gtk_fixed_new
*/
func FixedNew() *Fixed {
	retC := C.gtk_fixed_new()
	retGo := FixedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Moves a child of a #GtkFixed container to the given position.
/*

C function : gtk_fixed_move
*/
func (recv *Fixed) Move(widget *Widget, x int32, y int32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_fixed_move((*C.GtkFixed)(recv.native), c_widget, c_x, c_y)

	return
}

// Adds a widget to a #GtkFixed container at the given position.
/*

C function : gtk_fixed_put
*/
func (recv *Fixed) Put(widget *Widget, x int32, y int32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_fixed_put((*C.GtkFixed)(recv.native), c_widget, c_x, c_y)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Fixed
func (recv *Fixed) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Fixed
func (recv *Fixed) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FlowBox is a wrapper around the C record GtkFlowBox.
type FlowBox struct {
	native *C.GtkFlowBox
	// container : record
}

func FlowBoxNewFromC(u unsafe.Pointer) *FlowBox {
	c := (*C.GtkFlowBox)(u)
	if c == nil {
		return nil
	}

	g := &FlowBox{native: c}

	return g
}

func (recv *FlowBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *FlowBox) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *FlowBox) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FlowBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FlowBox) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to FlowBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBox.
func CastToFlowBox(object *gobject.Object) *FlowBox {
	return FlowBoxNewFromC(object.ToC())
}

type signalFlowBoxActivateCursorChildDetail struct {
	callback  FlowBoxSignalActivateCursorChildCallback
	handlerID C.gulong
}

var signalFlowBoxActivateCursorChildId int
var signalFlowBoxActivateCursorChildMap = make(map[int]signalFlowBoxActivateCursorChildDetail)
var signalFlowBoxActivateCursorChildLock sync.Mutex

// FlowBoxSignalActivateCursorChildCallback is a callback function for a 'activate-cursor-child' signal emitted from a FlowBox.
type FlowBoxSignalActivateCursorChildCallback func()

/*
ConnectActivateCursorChild connects the callback to the 'activate-cursor-child' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectActivateCursorChild to remove it.
*/
func (recv *FlowBox) ConnectActivateCursorChild(callback FlowBoxSignalActivateCursorChildCallback) int {
	signalFlowBoxActivateCursorChildLock.Lock()
	defer signalFlowBoxActivateCursorChildLock.Unlock()

	signalFlowBoxActivateCursorChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_activate_cursor_child(instance, C.gpointer(uintptr(signalFlowBoxActivateCursorChildId)))

	detail := signalFlowBoxActivateCursorChildDetail{callback, handlerID}
	signalFlowBoxActivateCursorChildMap[signalFlowBoxActivateCursorChildId] = detail

	return signalFlowBoxActivateCursorChildId
}

/*
DisconnectActivateCursorChild disconnects a callback from the 'activate-cursor-child' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectActivateCursorChild.
*/
func (recv *FlowBox) DisconnectActivateCursorChild(connectionID int) {
	signalFlowBoxActivateCursorChildLock.Lock()
	defer signalFlowBoxActivateCursorChildLock.Unlock()

	detail, exists := signalFlowBoxActivateCursorChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxActivateCursorChildMap, connectionID)
}

//export flowbox_activateCursorChildHandler
func flowbox_activateCursorChildHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxActivateCursorChildMap[index].callback
	callback()
}

type signalFlowBoxChildActivatedDetail struct {
	callback  FlowBoxSignalChildActivatedCallback
	handlerID C.gulong
}

var signalFlowBoxChildActivatedId int
var signalFlowBoxChildActivatedMap = make(map[int]signalFlowBoxChildActivatedDetail)
var signalFlowBoxChildActivatedLock sync.Mutex

// FlowBoxSignalChildActivatedCallback is a callback function for a 'child-activated' signal emitted from a FlowBox.
type FlowBoxSignalChildActivatedCallback func(child *FlowBoxChild)

/*
ConnectChildActivated connects the callback to the 'child-activated' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectChildActivated to remove it.
*/
func (recv *FlowBox) ConnectChildActivated(callback FlowBoxSignalChildActivatedCallback) int {
	signalFlowBoxChildActivatedLock.Lock()
	defer signalFlowBoxChildActivatedLock.Unlock()

	signalFlowBoxChildActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_child_activated(instance, C.gpointer(uintptr(signalFlowBoxChildActivatedId)))

	detail := signalFlowBoxChildActivatedDetail{callback, handlerID}
	signalFlowBoxChildActivatedMap[signalFlowBoxChildActivatedId] = detail

	return signalFlowBoxChildActivatedId
}

/*
DisconnectChildActivated disconnects a callback from the 'child-activated' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectChildActivated.
*/
func (recv *FlowBox) DisconnectChildActivated(connectionID int) {
	signalFlowBoxChildActivatedLock.Lock()
	defer signalFlowBoxChildActivatedLock.Unlock()

	detail, exists := signalFlowBoxChildActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxChildActivatedMap, connectionID)
}

//export flowbox_childActivatedHandler
func flowbox_childActivatedHandler(_ *C.GObject, c_child *C.GtkFlowBoxChild, data C.gpointer) {
	child := FlowBoxChildNewFromC(unsafe.Pointer(c_child))

	index := int(uintptr(data))
	callback := signalFlowBoxChildActivatedMap[index].callback
	callback(child)
}

// Unsupported signal 'move-cursor' for FlowBox : unsupported parameter step : type MovementStep :

type signalFlowBoxSelectAllDetail struct {
	callback  FlowBoxSignalSelectAllCallback
	handlerID C.gulong
}

var signalFlowBoxSelectAllId int
var signalFlowBoxSelectAllMap = make(map[int]signalFlowBoxSelectAllDetail)
var signalFlowBoxSelectAllLock sync.Mutex

// FlowBoxSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a FlowBox.
type FlowBoxSignalSelectAllCallback func()

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *FlowBox) ConnectSelectAll(callback FlowBoxSignalSelectAllCallback) int {
	signalFlowBoxSelectAllLock.Lock()
	defer signalFlowBoxSelectAllLock.Unlock()

	signalFlowBoxSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_select_all(instance, C.gpointer(uintptr(signalFlowBoxSelectAllId)))

	detail := signalFlowBoxSelectAllDetail{callback, handlerID}
	signalFlowBoxSelectAllMap[signalFlowBoxSelectAllId] = detail

	return signalFlowBoxSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *FlowBox) DisconnectSelectAll(connectionID int) {
	signalFlowBoxSelectAllLock.Lock()
	defer signalFlowBoxSelectAllLock.Unlock()

	detail, exists := signalFlowBoxSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxSelectAllMap, connectionID)
}

//export flowbox_selectAllHandler
func flowbox_selectAllHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxSelectAllMap[index].callback
	callback()
}

type signalFlowBoxSelectedChildrenChangedDetail struct {
	callback  FlowBoxSignalSelectedChildrenChangedCallback
	handlerID C.gulong
}

var signalFlowBoxSelectedChildrenChangedId int
var signalFlowBoxSelectedChildrenChangedMap = make(map[int]signalFlowBoxSelectedChildrenChangedDetail)
var signalFlowBoxSelectedChildrenChangedLock sync.Mutex

// FlowBoxSignalSelectedChildrenChangedCallback is a callback function for a 'selected-children-changed' signal emitted from a FlowBox.
type FlowBoxSignalSelectedChildrenChangedCallback func()

/*
ConnectSelectedChildrenChanged connects the callback to the 'selected-children-changed' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectSelectedChildrenChanged to remove it.
*/
func (recv *FlowBox) ConnectSelectedChildrenChanged(callback FlowBoxSignalSelectedChildrenChangedCallback) int {
	signalFlowBoxSelectedChildrenChangedLock.Lock()
	defer signalFlowBoxSelectedChildrenChangedLock.Unlock()

	signalFlowBoxSelectedChildrenChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_selected_children_changed(instance, C.gpointer(uintptr(signalFlowBoxSelectedChildrenChangedId)))

	detail := signalFlowBoxSelectedChildrenChangedDetail{callback, handlerID}
	signalFlowBoxSelectedChildrenChangedMap[signalFlowBoxSelectedChildrenChangedId] = detail

	return signalFlowBoxSelectedChildrenChangedId
}

/*
DisconnectSelectedChildrenChanged disconnects a callback from the 'selected-children-changed' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectSelectedChildrenChanged.
*/
func (recv *FlowBox) DisconnectSelectedChildrenChanged(connectionID int) {
	signalFlowBoxSelectedChildrenChangedLock.Lock()
	defer signalFlowBoxSelectedChildrenChangedLock.Unlock()

	detail, exists := signalFlowBoxSelectedChildrenChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxSelectedChildrenChangedMap, connectionID)
}

//export flowbox_selectedChildrenChangedHandler
func flowbox_selectedChildrenChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxSelectedChildrenChangedMap[index].callback
	callback()
}

type signalFlowBoxToggleCursorChildDetail struct {
	callback  FlowBoxSignalToggleCursorChildCallback
	handlerID C.gulong
}

var signalFlowBoxToggleCursorChildId int
var signalFlowBoxToggleCursorChildMap = make(map[int]signalFlowBoxToggleCursorChildDetail)
var signalFlowBoxToggleCursorChildLock sync.Mutex

// FlowBoxSignalToggleCursorChildCallback is a callback function for a 'toggle-cursor-child' signal emitted from a FlowBox.
type FlowBoxSignalToggleCursorChildCallback func()

/*
ConnectToggleCursorChild connects the callback to the 'toggle-cursor-child' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectToggleCursorChild to remove it.
*/
func (recv *FlowBox) ConnectToggleCursorChild(callback FlowBoxSignalToggleCursorChildCallback) int {
	signalFlowBoxToggleCursorChildLock.Lock()
	defer signalFlowBoxToggleCursorChildLock.Unlock()

	signalFlowBoxToggleCursorChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_toggle_cursor_child(instance, C.gpointer(uintptr(signalFlowBoxToggleCursorChildId)))

	detail := signalFlowBoxToggleCursorChildDetail{callback, handlerID}
	signalFlowBoxToggleCursorChildMap[signalFlowBoxToggleCursorChildId] = detail

	return signalFlowBoxToggleCursorChildId
}

/*
DisconnectToggleCursorChild disconnects a callback from the 'toggle-cursor-child' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectToggleCursorChild.
*/
func (recv *FlowBox) DisconnectToggleCursorChild(connectionID int) {
	signalFlowBoxToggleCursorChildLock.Lock()
	defer signalFlowBoxToggleCursorChildLock.Unlock()

	detail, exists := signalFlowBoxToggleCursorChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxToggleCursorChildMap, connectionID)
}

//export flowbox_toggleCursorChildHandler
func flowbox_toggleCursorChildHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxToggleCursorChildMap[index].callback
	callback()
}

type signalFlowBoxUnselectAllDetail struct {
	callback  FlowBoxSignalUnselectAllCallback
	handlerID C.gulong
}

var signalFlowBoxUnselectAllId int
var signalFlowBoxUnselectAllMap = make(map[int]signalFlowBoxUnselectAllDetail)
var signalFlowBoxUnselectAllLock sync.Mutex

// FlowBoxSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a FlowBox.
type FlowBoxSignalUnselectAllCallback func()

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *FlowBox) ConnectUnselectAll(callback FlowBoxSignalUnselectAllCallback) int {
	signalFlowBoxUnselectAllLock.Lock()
	defer signalFlowBoxUnselectAllLock.Unlock()

	signalFlowBoxUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalFlowBoxUnselectAllId)))

	detail := signalFlowBoxUnselectAllDetail{callback, handlerID}
	signalFlowBoxUnselectAllMap[signalFlowBoxUnselectAllId] = detail

	return signalFlowBoxUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *FlowBox) DisconnectUnselectAll(connectionID int) {
	signalFlowBoxUnselectAllLock.Lock()
	defer signalFlowBoxUnselectAllLock.Unlock()

	detail, exists := signalFlowBoxUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxUnselectAllMap, connectionID)
}

//export flowbox_unselectAllHandler
func flowbox_unselectAllHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxUnselectAllMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FlowBox
func (recv *FlowBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FlowBox
func (recv *FlowBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FlowBox
func (recv *FlowBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FlowBoxAccessible is a wrapper around the C record GtkFlowBoxAccessible.
type FlowBoxAccessible struct {
	native *C.GtkFlowBoxAccessible
	// parent : record
	// priv : record
}

func FlowBoxAccessibleNewFromC(u unsafe.Pointer) *FlowBoxAccessible {
	c := (*C.GtkFlowBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxAccessible{native: c}

	return g
}

func (recv *FlowBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FlowBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FlowBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FlowBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FlowBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to FlowBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxAccessible.
func CastToFlowBoxAccessible(object *gobject.Object) *FlowBoxAccessible {
	return FlowBoxAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FlowBoxAccessible
func (recv *FlowBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by FlowBoxAccessible
func (recv *FlowBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// FlowBoxChild is a wrapper around the C record GtkFlowBoxChild.
type FlowBoxChild struct {
	native *C.GtkFlowBoxChild
	// parent_instance : record
}

func FlowBoxChildNewFromC(u unsafe.Pointer) *FlowBoxChild {
	c := (*C.GtkFlowBoxChild)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChild{native: c}

	return g
}

func (recv *FlowBoxChild) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *FlowBoxChild) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FlowBoxChild) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *FlowBoxChild) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FlowBoxChild) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FlowBoxChild) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to FlowBoxChild.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxChild.
func CastToFlowBoxChild(object *gobject.Object) *FlowBoxChild {
	return FlowBoxChildNewFromC(object.ToC())
}

type signalFlowBoxChildActivateDetail struct {
	callback  FlowBoxChildSignalActivateCallback
	handlerID C.gulong
}

var signalFlowBoxChildActivateId int
var signalFlowBoxChildActivateMap = make(map[int]signalFlowBoxChildActivateDetail)
var signalFlowBoxChildActivateLock sync.Mutex

// FlowBoxChildSignalActivateCallback is a callback function for a 'activate' signal emitted from a FlowBoxChild.
type FlowBoxChildSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the FlowBoxChild.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *FlowBoxChild) ConnectActivate(callback FlowBoxChildSignalActivateCallback) int {
	signalFlowBoxChildActivateLock.Lock()
	defer signalFlowBoxChildActivateLock.Unlock()

	signalFlowBoxChildActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBoxChild_signal_connect_activate(instance, C.gpointer(uintptr(signalFlowBoxChildActivateId)))

	detail := signalFlowBoxChildActivateDetail{callback, handlerID}
	signalFlowBoxChildActivateMap[signalFlowBoxChildActivateId] = detail

	return signalFlowBoxChildActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the FlowBoxChild.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *FlowBoxChild) DisconnectActivate(connectionID int) {
	signalFlowBoxChildActivateLock.Lock()
	defer signalFlowBoxChildActivateLock.Unlock()

	detail, exists := signalFlowBoxChildActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxChildActivateMap, connectionID)
}

//export flowboxchild_activateHandler
func flowboxchild_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalFlowBoxChildActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FlowBoxChild
func (recv *FlowBoxChild) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FlowBoxChild
func (recv *FlowBoxChild) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FlowBoxChildAccessible is a wrapper around the C record GtkFlowBoxChildAccessible.
type FlowBoxChildAccessible struct {
	native *C.GtkFlowBoxChildAccessible
	// parent : record
}

func FlowBoxChildAccessibleNewFromC(u unsafe.Pointer) *FlowBoxChildAccessible {
	c := (*C.GtkFlowBoxChildAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChildAccessible{native: c}

	return g
}

func (recv *FlowBoxChildAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FlowBoxChildAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FlowBoxChildAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FlowBoxChildAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FlowBoxChildAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to FlowBoxChildAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxChildAccessible.
func CastToFlowBoxChildAccessible(object *gobject.Object) *FlowBoxChildAccessible {
	return FlowBoxChildAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FlowBoxChildAccessible
func (recv *FlowBoxChildAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// FontButton is a wrapper around the C record GtkFontButton.
type FontButton struct {
	native *C.GtkFontButton
	// button : record
	// Private : priv
}

func FontButtonNewFromC(u unsafe.Pointer) *FontButton {
	c := (*C.GtkFontButton)(u)
	if c == nil {
		return nil
	}

	g := &FontButton{native: c}

	return g
}

func (recv *FontButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *FontButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *FontButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *FontButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *FontButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to FontButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontButton.
func CastToFontButton(object *gobject.Object) *FontButton {
	return FontButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontButton
func (recv *FontButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by FontButton
func (recv *FontButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by FontButton
func (recv *FontButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontButton
func (recv *FontButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontButton
func (recv *FontButton) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// FontChooserDialog is a wrapper around the C record GtkFontChooserDialog.
type FontChooserDialog struct {
	native *C.GtkFontChooserDialog
	// parent_instance : record
	// Private : priv
}

func FontChooserDialogNewFromC(u unsafe.Pointer) *FontChooserDialog {
	c := (*C.GtkFontChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserDialog{native: c}

	return g
}

func (recv *FontChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *FontChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FontChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FontChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FontChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FontChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to FontChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontChooserDialog.
func CastToFontChooserDialog(object *gobject.Object) *FontChooserDialog {
	return FontChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontChooserDialog
func (recv *FontChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontChooserDialog
func (recv *FontChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontChooserDialog
func (recv *FontChooserDialog) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// FontChooserWidget is a wrapper around the C record GtkFontChooserWidget.
type FontChooserWidget struct {
	native *C.GtkFontChooserWidget
	// parent_instance : record
	// Private : priv
}

func FontChooserWidgetNewFromC(u unsafe.Pointer) *FontChooserWidget {
	c := (*C.GtkFontChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserWidget{native: c}

	return g
}

func (recv *FontChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *FontChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FontChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FontChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to FontChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontChooserWidget.
func CastToFontChooserWidget(object *gobject.Object) *FontChooserWidget {
	return FontChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontChooserWidget
func (recv *FontChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontChooserWidget
func (recv *FontChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontChooserWidget
func (recv *FontChooserWidget) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FontChooserWidget
func (recv *FontChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FontSelection is a wrapper around the C record GtkFontSelection.
type FontSelection struct {
	native *C.GtkFontSelection
	// parent_instance : record
	// Private : priv
}

func FontSelectionNewFromC(u unsafe.Pointer) *FontSelection {
	c := (*C.GtkFontSelection)(u)
	if c == nil {
		return nil
	}

	g := &FontSelection{native: c}

	return g
}

func (recv *FontSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *FontSelection) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FontSelection) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FontSelection) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontSelection) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontSelection) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to FontSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontSelection.
func CastToFontSelection(object *gobject.Object) *FontSelection {
	return FontSelectionNewFromC(object.ToC())
}

// Creates a new #GtkFontSelection.
/*

C function : gtk_font_selection_new
*/
func FontSelectionNew() *FontSelection {
	retC := C.gtk_font_selection_new()
	retGo := FontSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk_font_selection_set_font_name(), as the font selection widget may
// normalize font names and thus return a string with a different structure.
// For example, “Helvetica Italic Bold 12” could be normalized to
// “Helvetica Bold Italic 12”. Use pango_font_description_equal()
// if you want to compare two font descriptions.
/*

C function : gtk_font_selection_get_font_name
*/
func (recv *FontSelection) GetFontName() string {
	retC := C.gtk_font_selection_get_font_name((*C.GtkFontSelection)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Gets the text displayed in the preview area.
/*

C function : gtk_font_selection_get_preview_text
*/
func (recv *FontSelection) GetPreviewText() string {
	retC := C.gtk_font_selection_get_preview_text((*C.GtkFontSelection)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Sets the currently-selected font.
//
// Note that the @fontsel needs to know the screen in which it will appear
// for this to work; this can be guaranteed by simply making sure that the
// @fontsel is inserted in a toplevel window before you call this function.
/*

C function : gtk_font_selection_set_font_name
*/
func (recv *FontSelection) SetFontName(fontname string) bool {
	c_fontname := C.CString(fontname)
	defer C.free(unsafe.Pointer(c_fontname))

	retC := C.gtk_font_selection_set_font_name((*C.GtkFontSelection)(recv.native), c_fontname)
	retGo := retC == C.TRUE

	return retGo
}

// Sets the text displayed in the preview area.
// The @text is used to show how the selected font looks.
/*

C function : gtk_font_selection_set_preview_text
*/
func (recv *FontSelection) SetPreviewText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_font_selection_set_preview_text((*C.GtkFontSelection)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by FontSelection
func (recv *FontSelection) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontSelection
func (recv *FontSelection) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FontSelection
func (recv *FontSelection) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FontSelectionDialog is a wrapper around the C record GtkFontSelectionDialog.
type FontSelectionDialog struct {
	native *C.GtkFontSelectionDialog
	// parent_instance : record
	// Private : priv
}

func FontSelectionDialogNewFromC(u unsafe.Pointer) *FontSelectionDialog {
	c := (*C.GtkFontSelectionDialog)(u)
	if c == nil {
		return nil
	}

	g := &FontSelectionDialog{native: c}

	return g
}

func (recv *FontSelectionDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *FontSelectionDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FontSelectionDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FontSelectionDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FontSelectionDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FontSelectionDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontSelectionDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontSelectionDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to FontSelectionDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontSelectionDialog.
func CastToFontSelectionDialog(object *gobject.Object) *FontSelectionDialog {
	return FontSelectionDialogNewFromC(object.ToC())
}

// Creates a new #GtkFontSelectionDialog.
/*

C function : gtk_font_selection_dialog_new
*/
func FontSelectionDialogNew(title string) *FontSelectionDialog {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	retC := C.gtk_font_selection_dialog_new(c_title)
	retGo := FontSelectionDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk_font_selection_dialog_set_font_name(), as the font selection widget
// may normalize font names and thus return a string with a different
// structure. For example, “Helvetica Italic Bold 12” could be normalized
// to “Helvetica Bold Italic 12”.  Use pango_font_description_equal()
// if you want to compare two font descriptions.
/*

C function : gtk_font_selection_dialog_get_font_name
*/
func (recv *FontSelectionDialog) GetFontName() string {
	retC := C.gtk_font_selection_dialog_get_font_name((*C.GtkFontSelectionDialog)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Gets the text displayed in the preview area.
/*

C function : gtk_font_selection_dialog_get_preview_text
*/
func (recv *FontSelectionDialog) GetPreviewText() string {
	retC := C.gtk_font_selection_dialog_get_preview_text((*C.GtkFontSelectionDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Sets the currently selected font.
/*

C function : gtk_font_selection_dialog_set_font_name
*/
func (recv *FontSelectionDialog) SetFontName(fontname string) bool {
	c_fontname := C.CString(fontname)
	defer C.free(unsafe.Pointer(c_fontname))

	retC := C.gtk_font_selection_dialog_set_font_name((*C.GtkFontSelectionDialog)(recv.native), c_fontname)
	retGo := retC == C.TRUE

	return retGo
}

// Sets the text displayed in the preview area.
/*

C function : gtk_font_selection_dialog_set_preview_text
*/
func (recv *FontSelectionDialog) SetPreviewText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_font_selection_dialog_set_preview_text((*C.GtkFontSelectionDialog)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by FontSelectionDialog
func (recv *FontSelectionDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontSelectionDialog
func (recv *FontSelectionDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Frame is a wrapper around the C record GtkFrame.
type Frame struct {
	native *C.GtkFrame
	// bin : record
	// Private : priv
}

func FrameNewFromC(u unsafe.Pointer) *Frame {
	c := (*C.GtkFrame)(u)
	if c == nil {
		return nil
	}

	g := &Frame{native: c}

	return g
}

func (recv *Frame) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Frame) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Frame) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Frame) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Frame) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Frame) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Frame.
// Exercise care, as this is a potentially dangerous function if the Object is not a Frame.
func CastToFrame(object *gobject.Object) *Frame {
	return FrameNewFromC(object.ToC())
}

// Creates a new #GtkFrame, with optional label @label.
// If @label is %NULL, the label is omitted.
/*

C function : gtk_frame_new
*/
func FrameNew(label string) *Frame {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_frame_new(c_label)
	retGo := FrameNewFromC(unsafe.Pointer(retC))

	return retGo
}

// If the frame’s label widget is a #GtkLabel, returns the
// text in the label widget. (The frame will have a #GtkLabel
// for the label widget if a non-%NULL argument was passed
// to gtk_frame_new().)
/*

C function : gtk_frame_get_label
*/
func (recv *Frame) GetLabel() string {
	retC := C.gtk_frame_get_label((*C.GtkFrame)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Retrieves the X and Y alignment of the frame’s label. See
// gtk_frame_set_label_align().
/*

C function : gtk_frame_get_label_align
*/
func (recv *Frame) GetLabelAlign() (float32, float32) {
	var c_xalign C.gfloat

	var c_yalign C.gfloat

	C.gtk_frame_get_label_align((*C.GtkFrame)(recv.native), &c_xalign, &c_yalign)

	xalign := (float32)(c_xalign)

	yalign := (float32)(c_yalign)

	return xalign, yalign
}

// Retrieves the label widget for the frame. See
// gtk_frame_set_label_widget().
/*

C function : gtk_frame_get_label_widget
*/
func (recv *Frame) GetLabelWidget() *Widget {
	retC := C.gtk_frame_get_label_widget((*C.GtkFrame)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the shadow type of the frame. See
// gtk_frame_set_shadow_type().
/*

C function : gtk_frame_get_shadow_type
*/
func (recv *Frame) GetShadowType() ShadowType {
	retC := C.gtk_frame_get_shadow_type((*C.GtkFrame)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// Removes the current #GtkFrame:label-widget. If @label is not %NULL, creates a
// new #GtkLabel with that text and adds it as the #GtkFrame:label-widget.
/*

C function : gtk_frame_set_label
*/
func (recv *Frame) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_frame_set_label((*C.GtkFrame)(recv.native), c_label)

	return
}

// Sets the alignment of the frame widget’s label. The
// default values for a newly created frame are 0.0 and 0.5.
/*

C function : gtk_frame_set_label_align
*/
func (recv *Frame) SetLabelAlign(xalign float32, yalign float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	C.gtk_frame_set_label_align((*C.GtkFrame)(recv.native), c_xalign, c_yalign)

	return
}

// Sets the #GtkFrame:label-widget for the frame. This is the widget that
// will appear embedded in the top edge of the frame as a title.
/*

C function : gtk_frame_set_label_widget
*/
func (recv *Frame) SetLabelWidget(labelWidget *Widget) {
	c_label_widget := (*C.GtkWidget)(C.NULL)
	if labelWidget != nil {
		c_label_widget = (*C.GtkWidget)(labelWidget.ToC())
	}

	C.gtk_frame_set_label_widget((*C.GtkFrame)(recv.native), c_label_widget)

	return
}

// Sets the #GtkFrame:shadow-type for @frame, i.e. whether it is drawn without
// (%GTK_SHADOW_NONE) or with (other values) a visible border. Values other than
// %GTK_SHADOW_NONE are treated identically by GtkFrame. The chosen type is
// applied by removing or adding the .flat class to the CSS node named border.
/*

C function : gtk_frame_set_shadow_type
*/
func (recv *Frame) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_frame_set_shadow_type((*C.GtkFrame)(recv.native), c_type)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Frame
func (recv *Frame) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Frame
func (recv *Frame) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FrameAccessible is a wrapper around the C record GtkFrameAccessible.
type FrameAccessible struct {
	native *C.GtkFrameAccessible
	// parent : record
	// priv : record
}

func FrameAccessibleNewFromC(u unsafe.Pointer) *FrameAccessible {
	c := (*C.GtkFrameAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FrameAccessible{native: c}

	return g
}

func (recv *FrameAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FrameAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FrameAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FrameAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FrameAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to FrameAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FrameAccessible.
func CastToFrameAccessible(object *gobject.Object) *FrameAccessible {
	return FrameAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FrameAccessible
func (recv *FrameAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Gesture is a wrapper around the C record GtkGesture.
type Gesture struct {
	native *C.GtkGesture
}

func GestureNewFromC(u unsafe.Pointer) *Gesture {
	c := (*C.GtkGesture)(u)
	if c == nil {
		return nil
	}

	g := &Gesture{native: c}

	return g
}

func (recv *Gesture) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// EventController upcasts to *EventController
func (recv *Gesture) EventController() *EventController {
	return EventControllerNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Gesture) Object() *gobject.Object {
	return recv.EventController().Object()
}

// CastToWidget down casts any arbitary Object to Gesture.
// Exercise care, as this is a potentially dangerous function if the Object is not a Gesture.
func CastToGesture(object *gobject.Object) *Gesture {
	return GestureNewFromC(object.ToC())
}

// Unsupported : gtk_gesture_get_last_event : no return generator

// GestureDrag is a wrapper around the C record GtkGestureDrag.
type GestureDrag struct {
	native *C.GtkGestureDrag
}

func GestureDragNewFromC(u unsafe.Pointer) *GestureDrag {
	c := (*C.GtkGestureDrag)(u)
	if c == nil {
		return nil
	}

	g := &GestureDrag{native: c}

	return g
}

func (recv *GestureDrag) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureDrag) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureDrag) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureDrag) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureDrag) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitary Object to GestureDrag.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureDrag.
func CastToGestureDrag(object *gobject.Object) *GestureDrag {
	return GestureDragNewFromC(object.ToC())
}

// GestureLongPress is a wrapper around the C record GtkGestureLongPress.
type GestureLongPress struct {
	native *C.GtkGestureLongPress
}

func GestureLongPressNewFromC(u unsafe.Pointer) *GestureLongPress {
	c := (*C.GtkGestureLongPress)(u)
	if c == nil {
		return nil
	}

	g := &GestureLongPress{native: c}

	return g
}

func (recv *GestureLongPress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureLongPress) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureLongPress) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureLongPress) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureLongPress) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitary Object to GestureLongPress.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureLongPress.
func CastToGestureLongPress(object *gobject.Object) *GestureLongPress {
	return GestureLongPressNewFromC(object.ToC())
}

// GestureMultiPress is a wrapper around the C record GtkGestureMultiPress.
type GestureMultiPress struct {
	native *C.GtkGestureMultiPress
}

func GestureMultiPressNewFromC(u unsafe.Pointer) *GestureMultiPress {
	c := (*C.GtkGestureMultiPress)(u)
	if c == nil {
		return nil
	}

	g := &GestureMultiPress{native: c}

	return g
}

func (recv *GestureMultiPress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureMultiPress) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureMultiPress) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureMultiPress) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureMultiPress) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitary Object to GestureMultiPress.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureMultiPress.
func CastToGestureMultiPress(object *gobject.Object) *GestureMultiPress {
	return GestureMultiPressNewFromC(object.ToC())
}

// GesturePan is a wrapper around the C record GtkGesturePan.
type GesturePan struct {
	native *C.GtkGesturePan
}

func GesturePanNewFromC(u unsafe.Pointer) *GesturePan {
	c := (*C.GtkGesturePan)(u)
	if c == nil {
		return nil
	}

	g := &GesturePan{native: c}

	return g
}

func (recv *GesturePan) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureDrag upcasts to *GestureDrag
func (recv *GesturePan) GestureDrag() *GestureDrag {
	return GestureDragNewFromC(unsafe.Pointer(recv.native))
}

// GestureSingle upcasts to *GestureSingle
func (recv *GesturePan) GestureSingle() *GestureSingle {
	return recv.GestureDrag().GestureSingle()
}

// Gesture upcasts to *Gesture
func (recv *GesturePan) Gesture() *Gesture {
	return recv.GestureDrag().Gesture()
}

// EventController upcasts to *EventController
func (recv *GesturePan) EventController() *EventController {
	return recv.GestureDrag().EventController()
}

// Object upcasts to *Object
func (recv *GesturePan) Object() *gobject.Object {
	return recv.GestureDrag().Object()
}

// CastToWidget down casts any arbitary Object to GesturePan.
// Exercise care, as this is a potentially dangerous function if the Object is not a GesturePan.
func CastToGesturePan(object *gobject.Object) *GesturePan {
	return GesturePanNewFromC(object.ToC())
}

// GestureRotate is a wrapper around the C record GtkGestureRotate.
type GestureRotate struct {
	native *C.GtkGestureRotate
}

func GestureRotateNewFromC(u unsafe.Pointer) *GestureRotate {
	c := (*C.GtkGestureRotate)(u)
	if c == nil {
		return nil
	}

	g := &GestureRotate{native: c}

	return g
}

func (recv *GestureRotate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Gesture upcasts to *Gesture
func (recv *GestureRotate) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureRotate) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureRotate) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitary Object to GestureRotate.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureRotate.
func CastToGestureRotate(object *gobject.Object) *GestureRotate {
	return GestureRotateNewFromC(object.ToC())
}

// GestureSingle is a wrapper around the C record GtkGestureSingle.
type GestureSingle struct {
	native *C.GtkGestureSingle
}

func GestureSingleNewFromC(u unsafe.Pointer) *GestureSingle {
	c := (*C.GtkGestureSingle)(u)
	if c == nil {
		return nil
	}

	g := &GestureSingle{native: c}

	return g
}

func (recv *GestureSingle) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Gesture upcasts to *Gesture
func (recv *GestureSingle) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureSingle) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureSingle) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitary Object to GestureSingle.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureSingle.
func CastToGestureSingle(object *gobject.Object) *GestureSingle {
	return GestureSingleNewFromC(object.ToC())
}

// GestureSwipe is a wrapper around the C record GtkGestureSwipe.
type GestureSwipe struct {
	native *C.GtkGestureSwipe
}

func GestureSwipeNewFromC(u unsafe.Pointer) *GestureSwipe {
	c := (*C.GtkGestureSwipe)(u)
	if c == nil {
		return nil
	}

	g := &GestureSwipe{native: c}

	return g
}

func (recv *GestureSwipe) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureSwipe) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureSwipe) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureSwipe) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureSwipe) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitary Object to GestureSwipe.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureSwipe.
func CastToGestureSwipe(object *gobject.Object) *GestureSwipe {
	return GestureSwipeNewFromC(object.ToC())
}

// GestureZoom is a wrapper around the C record GtkGestureZoom.
type GestureZoom struct {
	native *C.GtkGestureZoom
}

func GestureZoomNewFromC(u unsafe.Pointer) *GestureZoom {
	c := (*C.GtkGestureZoom)(u)
	if c == nil {
		return nil
	}

	g := &GestureZoom{native: c}

	return g
}

func (recv *GestureZoom) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Gesture upcasts to *Gesture
func (recv *GestureZoom) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureZoom) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureZoom) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitary Object to GestureZoom.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureZoom.
func CastToGestureZoom(object *gobject.Object) *GestureZoom {
	return GestureZoomNewFromC(object.ToC())
}

// Grid is a wrapper around the C record GtkGrid.
type Grid struct {
	native *C.GtkGrid
	// Private : container
	// Private : priv
}

func GridNewFromC(u unsafe.Pointer) *Grid {
	c := (*C.GtkGrid)(u)
	if c == nil {
		return nil
	}

	g := &Grid{native: c}

	return g
}

func (recv *Grid) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Grid) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Grid) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Grid) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Grid) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Grid.
// Exercise care, as this is a potentially dangerous function if the Object is not a Grid.
func CastToGrid(object *gobject.Object) *Grid {
	return GridNewFromC(object.ToC())
}

// Creates a new grid widget.
/*

C function : gtk_grid_new
*/
func GridNew() *Grid {
	retC := C.gtk_grid_new()
	retGo := GridNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a widget to the grid.
//
// The position of @child is determined by @left and @top. The
// number of “cells” that @child will occupy is determined by
// @width and @height.
/*

C function : gtk_grid_attach
*/
func (recv *Grid) Attach(child *Widget, left int32, top int32, width int32, height int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_left := (C.gint)(left)

	c_top := (C.gint)(top)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_grid_attach((*C.GtkGrid)(recv.native), c_child, c_left, c_top, c_width, c_height)

	return
}

// Adds a widget to the grid.
//
// The widget is placed next to @sibling, on the side determined by
// @side. When @sibling is %NULL, the widget is placed in row (for
// left or right placement) or column 0 (for top or bottom placement),
// at the end indicated by @side.
//
// Attaching widgets labeled [1], [2], [3] with @sibling == %NULL and
// @side == %GTK_POS_LEFT yields a layout of [3][2][1].
/*

C function : gtk_grid_attach_next_to
*/
func (recv *Grid) AttachNextTo(child *Widget, sibling *Widget, side PositionType, width int32, height int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_sibling := (*C.GtkWidget)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkWidget)(sibling.ToC())
	}

	c_side := (C.GtkPositionType)(side)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_grid_attach_next_to((*C.GtkGrid)(recv.native), c_child, c_sibling, c_side, c_width, c_height)

	return
}

// Returns whether all columns of @grid have the same width.
/*

C function : gtk_grid_get_column_homogeneous
*/
func (recv *Grid) GetColumnHomogeneous() bool {
	retC := C.gtk_grid_get_column_homogeneous((*C.GtkGrid)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the amount of space between the columns of @grid.
/*

C function : gtk_grid_get_column_spacing
*/
func (recv *Grid) GetColumnSpacing() uint32 {
	retC := C.gtk_grid_get_column_spacing((*C.GtkGrid)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Returns whether all rows of @grid have the same height.
/*

C function : gtk_grid_get_row_homogeneous
*/
func (recv *Grid) GetRowHomogeneous() bool {
	retC := C.gtk_grid_get_row_homogeneous((*C.GtkGrid)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the amount of space between the rows of @grid.
/*

C function : gtk_grid_get_row_spacing
*/
func (recv *Grid) GetRowSpacing() uint32 {
	retC := C.gtk_grid_get_row_spacing((*C.GtkGrid)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Sets whether all columns of @grid will have the same width.
/*

C function : gtk_grid_set_column_homogeneous
*/
func (recv *Grid) SetColumnHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_grid_set_column_homogeneous((*C.GtkGrid)(recv.native), c_homogeneous)

	return
}

// Sets the amount of space between columns of @grid.
/*

C function : gtk_grid_set_column_spacing
*/
func (recv *Grid) SetColumnSpacing(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_grid_set_column_spacing((*C.GtkGrid)(recv.native), c_spacing)

	return
}

// Sets whether all rows of @grid will have the same height.
/*

C function : gtk_grid_set_row_homogeneous
*/
func (recv *Grid) SetRowHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_grid_set_row_homogeneous((*C.GtkGrid)(recv.native), c_homogeneous)

	return
}

// Sets the amount of space between rows of @grid.
/*

C function : gtk_grid_set_row_spacing
*/
func (recv *Grid) SetRowSpacing(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_grid_set_row_spacing((*C.GtkGrid)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Grid
func (recv *Grid) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Grid
func (recv *Grid) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Grid
func (recv *Grid) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HBox is a wrapper around the C record GtkHBox.
type HBox struct {
	native *C.GtkHBox
	// box : record
}

func HBoxNewFromC(u unsafe.Pointer) *HBox {
	c := (*C.GtkHBox)(u)
	if c == nil {
		return nil
	}

	g := &HBox{native: c}

	return g
}

func (recv *HBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *HBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *HBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to HBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HBox.
func CastToHBox(object *gobject.Object) *HBox {
	return HBoxNewFromC(object.ToC())
}

// Creates a new #GtkHBox.
/*

C function : gtk_hbox_new
*/
func HBoxNew(homogeneous bool, spacing int32) *HBox {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	c_spacing := (C.gint)(spacing)

	retC := C.gtk_hbox_new(c_homogeneous, c_spacing)
	retGo := HBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HBox
func (recv *HBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HBox
func (recv *HBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HBox
func (recv *HBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HButtonBox is a wrapper around the C record GtkHButtonBox.
type HButtonBox struct {
	native *C.GtkHButtonBox
	// button_box : record
}

func HButtonBoxNewFromC(u unsafe.Pointer) *HButtonBox {
	c := (*C.GtkHButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &HButtonBox{native: c}

	return g
}

func (recv *HButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonBox upcasts to *ButtonBox
func (recv *HButtonBox) ButtonBox() *ButtonBox {
	return ButtonBoxNewFromC(unsafe.Pointer(recv.native))
}

// Box upcasts to *Box
func (recv *HButtonBox) Box() *Box {
	return recv.ButtonBox().Box()
}

// Container upcasts to *Container
func (recv *HButtonBox) Container() *Container {
	return recv.ButtonBox().Container()
}

// Widget upcasts to *Widget
func (recv *HButtonBox) Widget() *Widget {
	return recv.ButtonBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ButtonBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HButtonBox) Object() *gobject.Object {
	return recv.ButtonBox().Object()
}

// CastToWidget down casts any arbitary Object to HButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HButtonBox.
func CastToHButtonBox(object *gobject.Object) *HButtonBox {
	return HButtonBoxNewFromC(object.ToC())
}

// Creates a new horizontal button box.
/*

C function : gtk_hbutton_box_new
*/
func HButtonBoxNew() *HButtonBox {
	retC := C.gtk_hbutton_box_new()
	retGo := HButtonBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HButtonBox
func (recv *HButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HButtonBox
func (recv *HButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HButtonBox
func (recv *HButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HPaned is a wrapper around the C record GtkHPaned.
type HPaned struct {
	native *C.GtkHPaned
	// paned : record
}

func HPanedNewFromC(u unsafe.Pointer) *HPaned {
	c := (*C.GtkHPaned)(u)
	if c == nil {
		return nil
	}

	g := &HPaned{native: c}

	return g
}

func (recv *HPaned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Paned upcasts to *Paned
func (recv *HPaned) Paned() *Paned {
	return PanedNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HPaned) Container() *Container {
	return recv.Paned().Container()
}

// Widget upcasts to *Widget
func (recv *HPaned) Widget() *Widget {
	return recv.Paned().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HPaned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Paned().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HPaned) Object() *gobject.Object {
	return recv.Paned().Object()
}

// CastToWidget down casts any arbitary Object to HPaned.
// Exercise care, as this is a potentially dangerous function if the Object is not a HPaned.
func CastToHPaned(object *gobject.Object) *HPaned {
	return HPanedNewFromC(object.ToC())
}

// Create a new #GtkHPaned
/*

C function : gtk_hpaned_new
*/
func HPanedNew() *HPaned {
	retC := C.gtk_hpaned_new()
	retGo := HPanedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HPaned
func (recv *HPaned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HPaned
func (recv *HPaned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HPaned
func (recv *HPaned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HSV is a wrapper around the C record GtkHSV.
type HSV struct {
	native *C.GtkHSV
	// parent_instance : record
	// Private : priv
}

func HSVNewFromC(u unsafe.Pointer) *HSV {
	c := (*C.GtkHSV)(u)
	if c == nil {
		return nil
	}

	g := &HSV{native: c}

	return g
}

func (recv *HSV) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *HSV) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HSV) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HSV) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to HSV.
// Exercise care, as this is a potentially dangerous function if the Object is not a HSV.
func CastToHSV(object *gobject.Object) *HSV {
	return HSVNewFromC(object.ToC())
}

type signalHSVChangedDetail struct {
	callback  HSVSignalChangedCallback
	handlerID C.gulong
}

var signalHSVChangedId int
var signalHSVChangedMap = make(map[int]signalHSVChangedDetail)
var signalHSVChangedLock sync.Mutex

// HSVSignalChangedCallback is a callback function for a 'changed' signal emitted from a HSV.
type HSVSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the HSV.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *HSV) ConnectChanged(callback HSVSignalChangedCallback) int {
	signalHSVChangedLock.Lock()
	defer signalHSVChangedLock.Unlock()

	signalHSVChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HSV_signal_connect_changed(instance, C.gpointer(uintptr(signalHSVChangedId)))

	detail := signalHSVChangedDetail{callback, handlerID}
	signalHSVChangedMap[signalHSVChangedId] = detail

	return signalHSVChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the HSV.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *HSV) DisconnectChanged(connectionID int) {
	signalHSVChangedLock.Lock()
	defer signalHSVChangedLock.Unlock()

	detail, exists := signalHSVChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHSVChangedMap, connectionID)
}

//export hsv_changedHandler
func hsv_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalHSVChangedMap[index].callback
	callback()
}

// Unsupported signal 'move' for HSV : unsupported parameter object : type DirectionType :

// ImplementorIface returns the ImplementorIface interface implemented by HSV
func (recv *HSV) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HSV
func (recv *HSV) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// HScale is a wrapper around the C record GtkHScale.
type HScale struct {
	native *C.GtkHScale
	// scale : record
}

func HScaleNewFromC(u unsafe.Pointer) *HScale {
	c := (*C.GtkHScale)(u)
	if c == nil {
		return nil
	}

	g := &HScale{native: c}

	return g
}

func (recv *HScale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Scale upcasts to *Scale
func (recv *HScale) Scale() *Scale {
	return ScaleNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *HScale) Range() *Range {
	return recv.Scale().Range()
}

// Widget upcasts to *Widget
func (recv *HScale) Widget() *Widget {
	return recv.Scale().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HScale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scale().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HScale) Object() *gobject.Object {
	return recv.Scale().Object()
}

// CastToWidget down casts any arbitary Object to HScale.
// Exercise care, as this is a potentially dangerous function if the Object is not a HScale.
func CastToHScale(object *gobject.Object) *HScale {
	return HScaleNewFromC(object.ToC())
}

// Creates a new #GtkHScale.
/*

C function : gtk_hscale_new
*/
func HScaleNew(adjustment *Adjustment) *HScale {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_hscale_new(c_adjustment)
	retGo := HScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new horizontal scale widget that lets the user input a
// number between @min and @max (including @min and @max) with the
// increment @step.  @step must be nonzero; it’s the distance the
// slider moves when using the arrow keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if @step
// is a power of ten. If the resulting precision is not suitable for your
// needs, use gtk_scale_set_digits() to correct it.
/*

C function : gtk_hscale_new_with_range
*/
func HScaleNewWithRange(min float64, max float64, step float64) *HScale {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_hscale_new_with_range(c_min, c_max, c_step)
	retGo := HScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HScale
func (recv *HScale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HScale
func (recv *HScale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HScale
func (recv *HScale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HScrollbar is a wrapper around the C record GtkHScrollbar.
type HScrollbar struct {
	native *C.GtkHScrollbar
	// scrollbar : record
}

func HScrollbarNewFromC(u unsafe.Pointer) *HScrollbar {
	c := (*C.GtkHScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &HScrollbar{native: c}

	return g
}

func (recv *HScrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Scrollbar upcasts to *Scrollbar
func (recv *HScrollbar) Scrollbar() *Scrollbar {
	return ScrollbarNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *HScrollbar) Range() *Range {
	return recv.Scrollbar().Range()
}

// Widget upcasts to *Widget
func (recv *HScrollbar) Widget() *Widget {
	return recv.Scrollbar().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HScrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scrollbar().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HScrollbar) Object() *gobject.Object {
	return recv.Scrollbar().Object()
}

// CastToWidget down casts any arbitary Object to HScrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a HScrollbar.
func CastToHScrollbar(object *gobject.Object) *HScrollbar {
	return HScrollbarNewFromC(object.ToC())
}

// Creates a new horizontal scrollbar.
/*

C function : gtk_hscrollbar_new
*/
func HScrollbarNew(adjustment *Adjustment) *HScrollbar {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_hscrollbar_new(c_adjustment)
	retGo := HScrollbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HScrollbar
func (recv *HScrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HScrollbar
func (recv *HScrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HScrollbar
func (recv *HScrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HSeparator is a wrapper around the C record GtkHSeparator.
type HSeparator struct {
	native *C.GtkHSeparator
	// separator : record
}

func HSeparatorNewFromC(u unsafe.Pointer) *HSeparator {
	c := (*C.GtkHSeparator)(u)
	if c == nil {
		return nil
	}

	g := &HSeparator{native: c}

	return g
}

func (recv *HSeparator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Separator upcasts to *Separator
func (recv *HSeparator) Separator() *Separator {
	return SeparatorNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *HSeparator) Widget() *Widget {
	return recv.Separator().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HSeparator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Separator().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HSeparator) Object() *gobject.Object {
	return recv.Separator().Object()
}

// CastToWidget down casts any arbitary Object to HSeparator.
// Exercise care, as this is a potentially dangerous function if the Object is not a HSeparator.
func CastToHSeparator(object *gobject.Object) *HSeparator {
	return HSeparatorNewFromC(object.ToC())
}

// Creates a new #GtkHSeparator.
/*

C function : gtk_hseparator_new
*/
func HSeparatorNew() *HSeparator {
	retC := C.gtk_hseparator_new()
	retGo := HSeparatorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HSeparator
func (recv *HSeparator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HSeparator
func (recv *HSeparator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HSeparator
func (recv *HSeparator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HandleBox is a wrapper around the C record GtkHandleBox.
type HandleBox struct {
	native *C.GtkHandleBox
	// bin : record
	// Private : priv
}

func HandleBoxNewFromC(u unsafe.Pointer) *HandleBox {
	c := (*C.GtkHandleBox)(u)
	if c == nil {
		return nil
	}

	g := &HandleBox{native: c}

	return g
}

func (recv *HandleBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *HandleBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HandleBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *HandleBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HandleBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HandleBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to HandleBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HandleBox.
func CastToHandleBox(object *gobject.Object) *HandleBox {
	return HandleBoxNewFromC(object.ToC())
}

type signalHandleBoxChildAttachedDetail struct {
	callback  HandleBoxSignalChildAttachedCallback
	handlerID C.gulong
}

var signalHandleBoxChildAttachedId int
var signalHandleBoxChildAttachedMap = make(map[int]signalHandleBoxChildAttachedDetail)
var signalHandleBoxChildAttachedLock sync.Mutex

// HandleBoxSignalChildAttachedCallback is a callback function for a 'child-attached' signal emitted from a HandleBox.
type HandleBoxSignalChildAttachedCallback func(widget *Widget)

/*
ConnectChildAttached connects the callback to the 'child-attached' signal for the HandleBox.

The returned value represents the connection, and may be passed to DisconnectChildAttached to remove it.
*/
func (recv *HandleBox) ConnectChildAttached(callback HandleBoxSignalChildAttachedCallback) int {
	signalHandleBoxChildAttachedLock.Lock()
	defer signalHandleBoxChildAttachedLock.Unlock()

	signalHandleBoxChildAttachedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HandleBox_signal_connect_child_attached(instance, C.gpointer(uintptr(signalHandleBoxChildAttachedId)))

	detail := signalHandleBoxChildAttachedDetail{callback, handlerID}
	signalHandleBoxChildAttachedMap[signalHandleBoxChildAttachedId] = detail

	return signalHandleBoxChildAttachedId
}

/*
DisconnectChildAttached disconnects a callback from the 'child-attached' signal for the HandleBox.

The connectionID should be a value returned from a call to ConnectChildAttached.
*/
func (recv *HandleBox) DisconnectChildAttached(connectionID int) {
	signalHandleBoxChildAttachedLock.Lock()
	defer signalHandleBoxChildAttachedLock.Unlock()

	detail, exists := signalHandleBoxChildAttachedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHandleBoxChildAttachedMap, connectionID)
}

//export handlebox_childAttachedHandler
func handlebox_childAttachedHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalHandleBoxChildAttachedMap[index].callback
	callback(widget)
}

type signalHandleBoxChildDetachedDetail struct {
	callback  HandleBoxSignalChildDetachedCallback
	handlerID C.gulong
}

var signalHandleBoxChildDetachedId int
var signalHandleBoxChildDetachedMap = make(map[int]signalHandleBoxChildDetachedDetail)
var signalHandleBoxChildDetachedLock sync.Mutex

// HandleBoxSignalChildDetachedCallback is a callback function for a 'child-detached' signal emitted from a HandleBox.
type HandleBoxSignalChildDetachedCallback func(widget *Widget)

/*
ConnectChildDetached connects the callback to the 'child-detached' signal for the HandleBox.

The returned value represents the connection, and may be passed to DisconnectChildDetached to remove it.
*/
func (recv *HandleBox) ConnectChildDetached(callback HandleBoxSignalChildDetachedCallback) int {
	signalHandleBoxChildDetachedLock.Lock()
	defer signalHandleBoxChildDetachedLock.Unlock()

	signalHandleBoxChildDetachedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HandleBox_signal_connect_child_detached(instance, C.gpointer(uintptr(signalHandleBoxChildDetachedId)))

	detail := signalHandleBoxChildDetachedDetail{callback, handlerID}
	signalHandleBoxChildDetachedMap[signalHandleBoxChildDetachedId] = detail

	return signalHandleBoxChildDetachedId
}

/*
DisconnectChildDetached disconnects a callback from the 'child-detached' signal for the HandleBox.

The connectionID should be a value returned from a call to ConnectChildDetached.
*/
func (recv *HandleBox) DisconnectChildDetached(connectionID int) {
	signalHandleBoxChildDetachedLock.Lock()
	defer signalHandleBoxChildDetachedLock.Unlock()

	detail, exists := signalHandleBoxChildDetachedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHandleBoxChildDetachedMap, connectionID)
}

//export handlebox_childDetachedHandler
func handlebox_childDetachedHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalHandleBoxChildDetachedMap[index].callback
	callback(widget)
}

// Create a new handle box.
/*

C function : gtk_handle_box_new
*/
func HandleBoxNew() *HandleBox {
	retC := C.gtk_handle_box_new()
	retGo := HandleBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the handle position of the handle box. See
// gtk_handle_box_set_handle_position().
/*

C function : gtk_handle_box_get_handle_position
*/
func (recv *HandleBox) GetHandlePosition() PositionType {
	retC := C.gtk_handle_box_get_handle_position((*C.GtkHandleBox)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// Gets the type of shadow drawn around the handle box. See
// gtk_handle_box_set_shadow_type().
/*

C function : gtk_handle_box_get_shadow_type
*/
func (recv *HandleBox) GetShadowType() ShadowType {
	retC := C.gtk_handle_box_get_shadow_type((*C.GtkHandleBox)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// Gets the edge used for determining reattachment of the handle box.
// See gtk_handle_box_set_snap_edge().
/*

C function : gtk_handle_box_get_snap_edge
*/
func (recv *HandleBox) GetSnapEdge() PositionType {
	retC := C.gtk_handle_box_get_snap_edge((*C.GtkHandleBox)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// Sets the side of the handlebox where the handle is drawn.
/*

C function : gtk_handle_box_set_handle_position
*/
func (recv *HandleBox) SetHandlePosition(position PositionType) {
	c_position := (C.GtkPositionType)(position)

	C.gtk_handle_box_set_handle_position((*C.GtkHandleBox)(recv.native), c_position)

	return
}

// Sets the type of shadow to be drawn around the border
// of the handle box.
/*

C function : gtk_handle_box_set_shadow_type
*/
func (recv *HandleBox) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_handle_box_set_shadow_type((*C.GtkHandleBox)(recv.native), c_type)

	return
}

// Sets the snap edge of a handlebox. The snap edge is
// the edge of the detached child that must be aligned
// with the corresponding edge of the “ghost” left
// behind when the child was detached to reattach
// the torn-off window. Usually, the snap edge should
// be chosen so that it stays in the same place on
// the screen when the handlebox is torn off.
//
// If the snap edge is not set, then an appropriate value
// will be guessed from the handle position. If the
// handle position is %GTK_POS_RIGHT or %GTK_POS_LEFT,
// then the snap edge will be %GTK_POS_TOP, otherwise
// it will be %GTK_POS_LEFT.
/*

C function : gtk_handle_box_set_snap_edge
*/
func (recv *HandleBox) SetSnapEdge(edge PositionType) {
	c_edge := (C.GtkPositionType)(edge)

	C.gtk_handle_box_set_snap_edge((*C.GtkHandleBox)(recv.native), c_edge)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by HandleBox
func (recv *HandleBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HandleBox
func (recv *HandleBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// HeaderBar is a wrapper around the C record GtkHeaderBar.
type HeaderBar struct {
	native *C.GtkHeaderBar
	// container : record
}

func HeaderBarNewFromC(u unsafe.Pointer) *HeaderBar {
	c := (*C.GtkHeaderBar)(u)
	if c == nil {
		return nil
	}

	g := &HeaderBar{native: c}

	return g
}

func (recv *HeaderBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *HeaderBar) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *HeaderBar) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HeaderBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HeaderBar) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to HeaderBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a HeaderBar.
func CastToHeaderBar(object *gobject.Object) *HeaderBar {
	return HeaderBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by HeaderBar
func (recv *HeaderBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HeaderBar
func (recv *HeaderBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// IMContext is a wrapper around the C record GtkIMContext.
type IMContext struct {
	native *C.GtkIMContext
	// parent_instance : record
}

func IMContextNewFromC(u unsafe.Pointer) *IMContext {
	c := (*C.GtkIMContext)(u)
	if c == nil {
		return nil
	}

	g := &IMContext{native: c}

	return g
}

func (recv *IMContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *IMContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to IMContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMContext.
func CastToIMContext(object *gobject.Object) *IMContext {
	return IMContextNewFromC(object.ToC())
}

// Unsupported signal 'commit' for IMContext : unsupported parameter str : type utf8 :

// Unsupported signal 'delete-surrounding' for IMContext : unsupported parameter offset : type gint :

type signalIMContextPreeditChangedDetail struct {
	callback  IMContextSignalPreeditChangedCallback
	handlerID C.gulong
}

var signalIMContextPreeditChangedId int
var signalIMContextPreeditChangedMap = make(map[int]signalIMContextPreeditChangedDetail)
var signalIMContextPreeditChangedLock sync.Mutex

// IMContextSignalPreeditChangedCallback is a callback function for a 'preedit-changed' signal emitted from a IMContext.
type IMContextSignalPreeditChangedCallback func()

/*
ConnectPreeditChanged connects the callback to the 'preedit-changed' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditChanged to remove it.
*/
func (recv *IMContext) ConnectPreeditChanged(callback IMContextSignalPreeditChangedCallback) int {
	signalIMContextPreeditChangedLock.Lock()
	defer signalIMContextPreeditChangedLock.Unlock()

	signalIMContextPreeditChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_changed(instance, C.gpointer(uintptr(signalIMContextPreeditChangedId)))

	detail := signalIMContextPreeditChangedDetail{callback, handlerID}
	signalIMContextPreeditChangedMap[signalIMContextPreeditChangedId] = detail

	return signalIMContextPreeditChangedId
}

/*
DisconnectPreeditChanged disconnects a callback from the 'preedit-changed' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditChanged.
*/
func (recv *IMContext) DisconnectPreeditChanged(connectionID int) {
	signalIMContextPreeditChangedLock.Lock()
	defer signalIMContextPreeditChangedLock.Unlock()

	detail, exists := signalIMContextPreeditChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditChangedMap, connectionID)
}

//export imcontext_preeditChangedHandler
func imcontext_preeditChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIMContextPreeditChangedMap[index].callback
	callback()
}

type signalIMContextPreeditEndDetail struct {
	callback  IMContextSignalPreeditEndCallback
	handlerID C.gulong
}

var signalIMContextPreeditEndId int
var signalIMContextPreeditEndMap = make(map[int]signalIMContextPreeditEndDetail)
var signalIMContextPreeditEndLock sync.Mutex

// IMContextSignalPreeditEndCallback is a callback function for a 'preedit-end' signal emitted from a IMContext.
type IMContextSignalPreeditEndCallback func()

/*
ConnectPreeditEnd connects the callback to the 'preedit-end' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditEnd to remove it.
*/
func (recv *IMContext) ConnectPreeditEnd(callback IMContextSignalPreeditEndCallback) int {
	signalIMContextPreeditEndLock.Lock()
	defer signalIMContextPreeditEndLock.Unlock()

	signalIMContextPreeditEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_end(instance, C.gpointer(uintptr(signalIMContextPreeditEndId)))

	detail := signalIMContextPreeditEndDetail{callback, handlerID}
	signalIMContextPreeditEndMap[signalIMContextPreeditEndId] = detail

	return signalIMContextPreeditEndId
}

/*
DisconnectPreeditEnd disconnects a callback from the 'preedit-end' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditEnd.
*/
func (recv *IMContext) DisconnectPreeditEnd(connectionID int) {
	signalIMContextPreeditEndLock.Lock()
	defer signalIMContextPreeditEndLock.Unlock()

	detail, exists := signalIMContextPreeditEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditEndMap, connectionID)
}

//export imcontext_preeditEndHandler
func imcontext_preeditEndHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIMContextPreeditEndMap[index].callback
	callback()
}

type signalIMContextPreeditStartDetail struct {
	callback  IMContextSignalPreeditStartCallback
	handlerID C.gulong
}

var signalIMContextPreeditStartId int
var signalIMContextPreeditStartMap = make(map[int]signalIMContextPreeditStartDetail)
var signalIMContextPreeditStartLock sync.Mutex

// IMContextSignalPreeditStartCallback is a callback function for a 'preedit-start' signal emitted from a IMContext.
type IMContextSignalPreeditStartCallback func()

/*
ConnectPreeditStart connects the callback to the 'preedit-start' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditStart to remove it.
*/
func (recv *IMContext) ConnectPreeditStart(callback IMContextSignalPreeditStartCallback) int {
	signalIMContextPreeditStartLock.Lock()
	defer signalIMContextPreeditStartLock.Unlock()

	signalIMContextPreeditStartId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_start(instance, C.gpointer(uintptr(signalIMContextPreeditStartId)))

	detail := signalIMContextPreeditStartDetail{callback, handlerID}
	signalIMContextPreeditStartMap[signalIMContextPreeditStartId] = detail

	return signalIMContextPreeditStartId
}

/*
DisconnectPreeditStart disconnects a callback from the 'preedit-start' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditStart.
*/
func (recv *IMContext) DisconnectPreeditStart(connectionID int) {
	signalIMContextPreeditStartLock.Lock()
	defer signalIMContextPreeditStartLock.Unlock()

	detail, exists := signalIMContextPreeditStartMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditStartMap, connectionID)
}

//export imcontext_preeditStartHandler
func imcontext_preeditStartHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIMContextPreeditStartMap[index].callback
	callback()
}

type signalIMContextRetrieveSurroundingDetail struct {
	callback  IMContextSignalRetrieveSurroundingCallback
	handlerID C.gulong
}

var signalIMContextRetrieveSurroundingId int
var signalIMContextRetrieveSurroundingMap = make(map[int]signalIMContextRetrieveSurroundingDetail)
var signalIMContextRetrieveSurroundingLock sync.Mutex

// IMContextSignalRetrieveSurroundingCallback is a callback function for a 'retrieve-surrounding' signal emitted from a IMContext.
type IMContextSignalRetrieveSurroundingCallback func() bool

/*
ConnectRetrieveSurrounding connects the callback to the 'retrieve-surrounding' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectRetrieveSurrounding to remove it.
*/
func (recv *IMContext) ConnectRetrieveSurrounding(callback IMContextSignalRetrieveSurroundingCallback) int {
	signalIMContextRetrieveSurroundingLock.Lock()
	defer signalIMContextRetrieveSurroundingLock.Unlock()

	signalIMContextRetrieveSurroundingId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_retrieve_surrounding(instance, C.gpointer(uintptr(signalIMContextRetrieveSurroundingId)))

	detail := signalIMContextRetrieveSurroundingDetail{callback, handlerID}
	signalIMContextRetrieveSurroundingMap[signalIMContextRetrieveSurroundingId] = detail

	return signalIMContextRetrieveSurroundingId
}

/*
DisconnectRetrieveSurrounding disconnects a callback from the 'retrieve-surrounding' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectRetrieveSurrounding.
*/
func (recv *IMContext) DisconnectRetrieveSurrounding(connectionID int) {
	signalIMContextRetrieveSurroundingLock.Lock()
	defer signalIMContextRetrieveSurroundingLock.Unlock()

	detail, exists := signalIMContextRetrieveSurroundingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextRetrieveSurroundingMap, connectionID)
}

//export imcontext_retrieveSurroundingHandler
func imcontext_retrieveSurroundingHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalIMContextRetrieveSurroundingMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Asks the widget that the input context is attached to to delete
// characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal. Note that @offset and @n_chars
// are in characters not in bytes which differs from the usage other
// places in #GtkIMContext.
//
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and
// call this function immediately afterwards to make sure that you
// know what you are deleting. You should also account for the fact
// that even if the signal was handled, the input context might not
// have deleted all the characters that were requested to be deleted.
//
// This function is used by an input method that wants to make
// subsitutions in the existing text in response to new input. It is
// not useful for applications.
/*

C function : gtk_im_context_delete_surrounding
*/
func (recv *IMContext) DeleteSurrounding(offset int32, nChars int32) bool {
	c_offset := (C.gint)(offset)

	c_n_chars := (C.gint)(nChars)

	retC := C.gtk_im_context_delete_surrounding((*C.GtkIMContext)(recv.native), c_offset, c_n_chars)
	retGo := retC == C.TRUE

	return retGo
}

// Allow an input method to internally handle key press and release
// events. If this function returns %TRUE, then no further processing
// should be done for this key event.
/*

C function : gtk_im_context_filter_keypress
*/
func (recv *IMContext) FilterKeypress(event *gdk.EventKey) bool {
	c_event := (*C.GdkEventKey)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEventKey)(event.ToC())
	}

	retC := C.gtk_im_context_filter_keypress((*C.GtkIMContext)(recv.native), c_event)
	retGo := retC == C.TRUE

	return retGo
}

// Notify the input method that the widget to which this
// input context corresponds has gained focus. The input method
// may, for example, change the displayed feedback to reflect
// this change.
/*

C function : gtk_im_context_focus_in
*/
func (recv *IMContext) FocusIn() {
	C.gtk_im_context_focus_in((*C.GtkIMContext)(recv.native))

	return
}

// Notify the input method that the widget to which this
// input context corresponds has lost focus. The input method
// may, for example, change the displayed feedback or reset the contexts
// state to reflect this change.
/*

C function : gtk_im_context_focus_out
*/
func (recv *IMContext) FocusOut() {
	C.gtk_im_context_focus_out((*C.GtkIMContext)(recv.native))

	return
}

// Retrieve the current preedit string for the input context,
// and a list of attributes to apply to the string.
// This string should be displayed inserted at the insertion
// point.
/*

C function : gtk_im_context_get_preedit_string
*/
func (recv *IMContext) GetPreeditString() (string, *pango.AttrList, int32) {
	var c_str *C.gchar

	var c_attrs *C.PangoAttrList

	var c_cursor_pos C.gint

	C.gtk_im_context_get_preedit_string((*C.GtkIMContext)(recv.native), &c_str, &c_attrs, &c_cursor_pos)

	str := C.GoString(c_str)
	defer C.free(unsafe.Pointer(c_str))

	attrs := pango.AttrListNewFromC(unsafe.Pointer(c_attrs))

	cursorPos := (int32)(c_cursor_pos)

	return str, attrs, cursorPos
}

// Retrieves context around the insertion point. Input methods
// typically want context in order to constrain input text based on
// existing text; this is important for languages such as Thai where
// only some sequences of characters are allowed.
//
// This function is implemented by emitting the
// GtkIMContext::retrieve_surrounding signal on the input method; in
// response to this signal, a widget should provide as much context as
// is available, up to an entire paragraph, by calling
// gtk_im_context_set_surrounding(). Note that there is no obligation
// for a widget to respond to the ::retrieve_surrounding signal, so input
// methods must be prepared to function without context.
/*

C function : gtk_im_context_get_surrounding
*/
func (recv *IMContext) GetSurrounding() (bool, string, int32) {
	var c_text *C.gchar

	var c_cursor_index C.gint

	retC := C.gtk_im_context_get_surrounding((*C.GtkIMContext)(recv.native), &c_text, &c_cursor_index)
	retGo := retC == C.TRUE

	text := C.GoString(c_text)
	defer C.free(unsafe.Pointer(c_text))

	cursorIndex := (int32)(c_cursor_index)

	return retGo, text, cursorIndex
}

// Notify the input method that a change such as a change in cursor
// position has been made. This will typically cause the input
// method to clear the preedit state.
/*

C function : gtk_im_context_reset
*/
func (recv *IMContext) Reset() {
	C.gtk_im_context_reset((*C.GtkIMContext)(recv.native))

	return
}

// Set the client window for the input context; this is the
// #GdkWindow in which the input appears. This window is
// used in order to correctly position status windows, and may
// also be used for purposes internal to the input method.
/*

C function : gtk_im_context_set_client_window
*/
func (recv *IMContext) SetClientWindow(window *gdk.Window) {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	C.gtk_im_context_set_client_window((*C.GtkIMContext)(recv.native), c_window)

	return
}

// Unsupported : gtk_im_context_set_cursor_location : unsupported parameter area : Blacklisted record : GdkRectangle

// Sets surrounding context around the insertion point and preedit
// string. This function is expected to be called in response to the
// GtkIMContext::retrieve_surrounding signal, and will likely have no
// effect if called at other times.
/*

C function : gtk_im_context_set_surrounding
*/
func (recv *IMContext) SetSurrounding(text string, len int32, cursorIndex int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_cursor_index := (C.gint)(cursorIndex)

	C.gtk_im_context_set_surrounding((*C.GtkIMContext)(recv.native), c_text, c_len, c_cursor_index)

	return
}

// Sets whether the IM context should use the preedit string
// to display feedback. If @use_preedit is FALSE (default
// is TRUE), then the IM context may use some other method to display
// feedback, such as displaying it in a child of the root window.
/*

C function : gtk_im_context_set_use_preedit
*/
func (recv *IMContext) SetUsePreedit(usePreedit bool) {
	c_use_preedit :=
		boolToGboolean(usePreedit)

	C.gtk_im_context_set_use_preedit((*C.GtkIMContext)(recv.native), c_use_preedit)

	return
}

// IMContextSimple is a wrapper around the C record GtkIMContextSimple.
type IMContextSimple struct {
	native *C.GtkIMContextSimple
	// object : record
	// Private : priv
}

func IMContextSimpleNewFromC(u unsafe.Pointer) *IMContextSimple {
	c := (*C.GtkIMContextSimple)(u)
	if c == nil {
		return nil
	}

	g := &IMContextSimple{native: c}

	return g
}

func (recv *IMContextSimple) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// IMContext upcasts to *IMContext
func (recv *IMContextSimple) IMContext() *IMContext {
	return IMContextNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *IMContextSimple) Object() *gobject.Object {
	return recv.IMContext().Object()
}

// CastToWidget down casts any arbitary Object to IMContextSimple.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMContextSimple.
func CastToIMContextSimple(object *gobject.Object) *IMContextSimple {
	return IMContextSimpleNewFromC(object.ToC())
}

// Creates a new #GtkIMContextSimple.
/*

C function : gtk_im_context_simple_new
*/
func IMContextSimpleNew() *IMContextSimple {
	retC := C.gtk_im_context_simple_new()
	retGo := IMContextSimpleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Blacklisted : gtk_im_context_simple_add_compose_file

// Adds an additional table to search to the input context.
// Each row of the table consists of @max_seq_len key symbols
// followed by two #guint16 interpreted as the high and low
// words of a #gunicode value. Tables are searched starting
// from the last added.
//
// The table must be sorted in dictionary order on the
// numeric value of the key symbol fields. (Values beyond
// the length of the sequence should be zero.)
/*

C function : gtk_im_context_simple_add_table
*/
func (recv *IMContextSimple) AddTable(data []uint16, maxSeqLen int32, nSeqs int32) {
	c_data := &data[0]

	c_max_seq_len := (C.gint)(maxSeqLen)

	c_n_seqs := (C.gint)(nSeqs)

	C.gtk_im_context_simple_add_table((*C.GtkIMContextSimple)(recv.native), (*C.guint16)(unsafe.Pointer(c_data)), c_max_seq_len, c_n_seqs)

	return
}

// IMMulticontext is a wrapper around the C record GtkIMMulticontext.
type IMMulticontext struct {
	native *C.GtkIMMulticontext
	// object : record
	// Private : priv
}

func IMMulticontextNewFromC(u unsafe.Pointer) *IMMulticontext {
	c := (*C.GtkIMMulticontext)(u)
	if c == nil {
		return nil
	}

	g := &IMMulticontext{native: c}

	return g
}

func (recv *IMMulticontext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// IMContext upcasts to *IMContext
func (recv *IMMulticontext) IMContext() *IMContext {
	return IMContextNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *IMMulticontext) Object() *gobject.Object {
	return recv.IMContext().Object()
}

// CastToWidget down casts any arbitary Object to IMMulticontext.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMMulticontext.
func CastToIMMulticontext(object *gobject.Object) *IMMulticontext {
	return IMMulticontextNewFromC(object.ToC())
}

// Creates a new #GtkIMMulticontext.
/*

C function : gtk_im_multicontext_new
*/
func IMMulticontextNew() *IMMulticontext {
	retC := C.gtk_im_multicontext_new()
	retGo := IMMulticontextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Add menuitems for various available input methods to a menu;
// the menuitems, when selected, will switch the input method
// for the context and the global default input method.
/*

C function : gtk_im_multicontext_append_menuitems
*/
func (recv *IMMulticontext) AppendMenuitems(menushell *MenuShell) {
	c_menushell := (*C.GtkMenuShell)(C.NULL)
	if menushell != nil {
		c_menushell = (*C.GtkMenuShell)(menushell.ToC())
	}

	C.gtk_im_multicontext_append_menuitems((*C.GtkIMMulticontext)(recv.native), c_menushell)

	return
}

// IconFactory is a wrapper around the C record GtkIconFactory.
type IconFactory struct {
	native *C.GtkIconFactory
	// parent_instance : record
	// Private : priv
}

func IconFactoryNewFromC(u unsafe.Pointer) *IconFactory {
	c := (*C.GtkIconFactory)(u)
	if c == nil {
		return nil
	}

	g := &IconFactory{native: c}

	return g
}

func (recv *IconFactory) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *IconFactory) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to IconFactory.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconFactory.
func CastToIconFactory(object *gobject.Object) *IconFactory {
	return IconFactoryNewFromC(object.ToC())
}

// Creates a new #GtkIconFactory. An icon factory manages a collection
// of #GtkIconSets; a #GtkIconSet manages a set of variants of a
// particular icon (i.e. a #GtkIconSet contains variants for different
// sizes and widget states). Icons in an icon factory are named by a
// stock ID, which is a simple string identifying the icon. Each
// #GtkStyle has a list of #GtkIconFactorys derived from the current
// theme; those icon factories are consulted first when searching for
// an icon. If the theme doesn’t set a particular icon, GTK+ looks for
// the icon in a list of default icon factories, maintained by
// gtk_icon_factory_add_default() and
// gtk_icon_factory_remove_default(). Applications with icons should
// add a default icon factory with their icons, which will allow
// themes to override the icons for the application.
/*

C function : gtk_icon_factory_new
*/
func IconFactoryNew() *IconFactory {
	retC := C.gtk_icon_factory_new()
	retGo := IconFactoryNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds the given @icon_set to the icon factory, under the name
// @stock_id.  @stock_id should be namespaced for your application,
// e.g. “myapp-whatever-icon”.  Normally applications create a
// #GtkIconFactory, then add it to the list of default factories with
// gtk_icon_factory_add_default(). Then they pass the @stock_id to
// widgets such as #GtkImage to display the icon. Themes can provide
// an icon with the same name (such as "myapp-whatever-icon") to
// override your application’s default icons. If an icon already
// existed in @factory for @stock_id, it is unreferenced and replaced
// with the new @icon_set.
/*

C function : gtk_icon_factory_add
*/
func (recv *IconFactory) Add(stockId string, iconSet *IconSet) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	C.gtk_icon_factory_add((*C.GtkIconFactory)(recv.native), c_stock_id, c_icon_set)

	return
}

// Adds an icon factory to the list of icon factories searched by
// gtk_style_lookup_icon_set(). This means that, for example,
// gtk_image_new_from_stock() will be able to find icons in @factory.
// There will normally be an icon factory added for each library or
// application that comes with icons. The default icon factories
// can be overridden by themes.
/*

C function : gtk_icon_factory_add_default
*/
func (recv *IconFactory) AddDefault() {
	C.gtk_icon_factory_add_default((*C.GtkIconFactory)(recv.native))

	return
}

// Looks up @stock_id in the icon factory, returning an icon set
// if found, otherwise %NULL. For display to the user, you should
// use gtk_style_lookup_icon_set() on the #GtkStyle for the
// widget that will display the icon, instead of using this
// function directly, so that themes are taken into account.
/*

C function : gtk_icon_factory_lookup
*/
func (recv *IconFactory) Lookup(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_icon_factory_lookup((*C.GtkIconFactory)(recv.native), c_stock_id)
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Removes an icon factory from the list of default icon
// factories. Not normally used; you might use it for a library that
// can be unloaded or shut down.
/*

C function : gtk_icon_factory_remove_default
*/
func (recv *IconFactory) RemoveDefault() {
	C.gtk_icon_factory_remove_default((*C.GtkIconFactory)(recv.native))

	return
}

// Buildable returns the Buildable interface implemented by IconFactory
func (recv *IconFactory) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// IconInfo is a wrapper around the C record GtkIconInfo.
type IconInfo struct {
	native *C.GtkIconInfo
}

func IconInfoNewFromC(u unsafe.Pointer) *IconInfo {
	c := (*C.GtkIconInfo)(u)
	if c == nil {
		return nil
	}

	g := &IconInfo{native: c}

	return g
}

func (recv *IconInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *IconInfo) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to IconInfo.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconInfo.
func CastToIconInfo(object *gobject.Object) *IconInfo {
	return IconInfoNewFromC(object.ToC())
}

// IconTheme is a wrapper around the C record GtkIconTheme.
type IconTheme struct {
	native *C.GtkIconTheme
	// Private : parent_instance
	// Private : priv
}

func IconThemeNewFromC(u unsafe.Pointer) *IconTheme {
	c := (*C.GtkIconTheme)(u)
	if c == nil {
		return nil
	}

	g := &IconTheme{native: c}

	return g
}

func (recv *IconTheme) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *IconTheme) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to IconTheme.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconTheme.
func CastToIconTheme(object *gobject.Object) *IconTheme {
	return IconThemeNewFromC(object.ToC())
}

type signalIconThemeChangedDetail struct {
	callback  IconThemeSignalChangedCallback
	handlerID C.gulong
}

var signalIconThemeChangedId int
var signalIconThemeChangedMap = make(map[int]signalIconThemeChangedDetail)
var signalIconThemeChangedLock sync.Mutex

// IconThemeSignalChangedCallback is a callback function for a 'changed' signal emitted from a IconTheme.
type IconThemeSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the IconTheme.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *IconTheme) ConnectChanged(callback IconThemeSignalChangedCallback) int {
	signalIconThemeChangedLock.Lock()
	defer signalIconThemeChangedLock.Unlock()

	signalIconThemeChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconTheme_signal_connect_changed(instance, C.gpointer(uintptr(signalIconThemeChangedId)))

	detail := signalIconThemeChangedDetail{callback, handlerID}
	signalIconThemeChangedMap[signalIconThemeChangedId] = detail

	return signalIconThemeChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the IconTheme.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *IconTheme) DisconnectChanged(connectionID int) {
	signalIconThemeChangedLock.Lock()
	defer signalIconThemeChangedLock.Unlock()

	detail, exists := signalIconThemeChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconThemeChangedMap, connectionID)
}

//export icontheme_changedHandler
func icontheme_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconThemeChangedMap[index].callback
	callback()
}

// IconView is a wrapper around the C record GtkIconView.
type IconView struct {
	native *C.GtkIconView
	// parent : record
	// Private : priv
}

func IconViewNewFromC(u unsafe.Pointer) *IconView {
	c := (*C.GtkIconView)(u)
	if c == nil {
		return nil
	}

	g := &IconView{native: c}

	return g
}

func (recv *IconView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *IconView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *IconView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *IconView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *IconView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to IconView.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconView.
func CastToIconView(object *gobject.Object) *IconView {
	return IconViewNewFromC(object.ToC())
}

type signalIconViewActivateCursorItemDetail struct {
	callback  IconViewSignalActivateCursorItemCallback
	handlerID C.gulong
}

var signalIconViewActivateCursorItemId int
var signalIconViewActivateCursorItemMap = make(map[int]signalIconViewActivateCursorItemDetail)
var signalIconViewActivateCursorItemLock sync.Mutex

// IconViewSignalActivateCursorItemCallback is a callback function for a 'activate-cursor-item' signal emitted from a IconView.
type IconViewSignalActivateCursorItemCallback func() bool

/*
ConnectActivateCursorItem connects the callback to the 'activate-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectActivateCursorItem to remove it.
*/
func (recv *IconView) ConnectActivateCursorItem(callback IconViewSignalActivateCursorItemCallback) int {
	signalIconViewActivateCursorItemLock.Lock()
	defer signalIconViewActivateCursorItemLock.Unlock()

	signalIconViewActivateCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_activate_cursor_item(instance, C.gpointer(uintptr(signalIconViewActivateCursorItemId)))

	detail := signalIconViewActivateCursorItemDetail{callback, handlerID}
	signalIconViewActivateCursorItemMap[signalIconViewActivateCursorItemId] = detail

	return signalIconViewActivateCursorItemId
}

/*
DisconnectActivateCursorItem disconnects a callback from the 'activate-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectActivateCursorItem.
*/
func (recv *IconView) DisconnectActivateCursorItem(connectionID int) {
	signalIconViewActivateCursorItemLock.Lock()
	defer signalIconViewActivateCursorItemLock.Unlock()

	detail, exists := signalIconViewActivateCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewActivateCursorItemMap, connectionID)
}

//export iconview_activateCursorItemHandler
func iconview_activateCursorItemHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalIconViewActivateCursorItemMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalIconViewItemActivatedDetail struct {
	callback  IconViewSignalItemActivatedCallback
	handlerID C.gulong
}

var signalIconViewItemActivatedId int
var signalIconViewItemActivatedMap = make(map[int]signalIconViewItemActivatedDetail)
var signalIconViewItemActivatedLock sync.Mutex

// IconViewSignalItemActivatedCallback is a callback function for a 'item-activated' signal emitted from a IconView.
type IconViewSignalItemActivatedCallback func(path *TreePath)

/*
ConnectItemActivated connects the callback to the 'item-activated' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectItemActivated to remove it.
*/
func (recv *IconView) ConnectItemActivated(callback IconViewSignalItemActivatedCallback) int {
	signalIconViewItemActivatedLock.Lock()
	defer signalIconViewItemActivatedLock.Unlock()

	signalIconViewItemActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_item_activated(instance, C.gpointer(uintptr(signalIconViewItemActivatedId)))

	detail := signalIconViewItemActivatedDetail{callback, handlerID}
	signalIconViewItemActivatedMap[signalIconViewItemActivatedId] = detail

	return signalIconViewItemActivatedId
}

/*
DisconnectItemActivated disconnects a callback from the 'item-activated' signal for the IconView.

The connectionID should be a value returned from a call to ConnectItemActivated.
*/
func (recv *IconView) DisconnectItemActivated(connectionID int) {
	signalIconViewItemActivatedLock.Lock()
	defer signalIconViewItemActivatedLock.Unlock()

	detail, exists := signalIconViewItemActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewItemActivatedMap, connectionID)
}

//export iconview_itemActivatedHandler
func iconview_itemActivatedHandler(_ *C.GObject, c_path *C.GtkTreePath, data C.gpointer) {
	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalIconViewItemActivatedMap[index].callback
	callback(path)
}

// Unsupported signal 'move-cursor' for IconView : unsupported parameter step : type MovementStep :

type signalIconViewSelectAllDetail struct {
	callback  IconViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalIconViewSelectAllId int
var signalIconViewSelectAllMap = make(map[int]signalIconViewSelectAllDetail)
var signalIconViewSelectAllLock sync.Mutex

// IconViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a IconView.
type IconViewSignalSelectAllCallback func()

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *IconView) ConnectSelectAll(callback IconViewSignalSelectAllCallback) int {
	signalIconViewSelectAllLock.Lock()
	defer signalIconViewSelectAllLock.Unlock()

	signalIconViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_select_all(instance, C.gpointer(uintptr(signalIconViewSelectAllId)))

	detail := signalIconViewSelectAllDetail{callback, handlerID}
	signalIconViewSelectAllMap[signalIconViewSelectAllId] = detail

	return signalIconViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *IconView) DisconnectSelectAll(connectionID int) {
	signalIconViewSelectAllLock.Lock()
	defer signalIconViewSelectAllLock.Unlock()

	detail, exists := signalIconViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectAllMap, connectionID)
}

//export iconview_selectAllHandler
func iconview_selectAllHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewSelectAllMap[index].callback
	callback()
}

type signalIconViewSelectCursorItemDetail struct {
	callback  IconViewSignalSelectCursorItemCallback
	handlerID C.gulong
}

var signalIconViewSelectCursorItemId int
var signalIconViewSelectCursorItemMap = make(map[int]signalIconViewSelectCursorItemDetail)
var signalIconViewSelectCursorItemLock sync.Mutex

// IconViewSignalSelectCursorItemCallback is a callback function for a 'select-cursor-item' signal emitted from a IconView.
type IconViewSignalSelectCursorItemCallback func()

/*
ConnectSelectCursorItem connects the callback to the 'select-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorItem to remove it.
*/
func (recv *IconView) ConnectSelectCursorItem(callback IconViewSignalSelectCursorItemCallback) int {
	signalIconViewSelectCursorItemLock.Lock()
	defer signalIconViewSelectCursorItemLock.Unlock()

	signalIconViewSelectCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_select_cursor_item(instance, C.gpointer(uintptr(signalIconViewSelectCursorItemId)))

	detail := signalIconViewSelectCursorItemDetail{callback, handlerID}
	signalIconViewSelectCursorItemMap[signalIconViewSelectCursorItemId] = detail

	return signalIconViewSelectCursorItemId
}

/*
DisconnectSelectCursorItem disconnects a callback from the 'select-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectCursorItem.
*/
func (recv *IconView) DisconnectSelectCursorItem(connectionID int) {
	signalIconViewSelectCursorItemLock.Lock()
	defer signalIconViewSelectCursorItemLock.Unlock()

	detail, exists := signalIconViewSelectCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectCursorItemMap, connectionID)
}

//export iconview_selectCursorItemHandler
func iconview_selectCursorItemHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewSelectCursorItemMap[index].callback
	callback()
}

type signalIconViewSelectionChangedDetail struct {
	callback  IconViewSignalSelectionChangedCallback
	handlerID C.gulong
}

var signalIconViewSelectionChangedId int
var signalIconViewSelectionChangedMap = make(map[int]signalIconViewSelectionChangedDetail)
var signalIconViewSelectionChangedLock sync.Mutex

// IconViewSignalSelectionChangedCallback is a callback function for a 'selection-changed' signal emitted from a IconView.
type IconViewSignalSelectionChangedCallback func()

/*
ConnectSelectionChanged connects the callback to the 'selection-changed' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectionChanged to remove it.
*/
func (recv *IconView) ConnectSelectionChanged(callback IconViewSignalSelectionChangedCallback) int {
	signalIconViewSelectionChangedLock.Lock()
	defer signalIconViewSelectionChangedLock.Unlock()

	signalIconViewSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_selection_changed(instance, C.gpointer(uintptr(signalIconViewSelectionChangedId)))

	detail := signalIconViewSelectionChangedDetail{callback, handlerID}
	signalIconViewSelectionChangedMap[signalIconViewSelectionChangedId] = detail

	return signalIconViewSelectionChangedId
}

/*
DisconnectSelectionChanged disconnects a callback from the 'selection-changed' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectionChanged.
*/
func (recv *IconView) DisconnectSelectionChanged(connectionID int) {
	signalIconViewSelectionChangedLock.Lock()
	defer signalIconViewSelectionChangedLock.Unlock()

	detail, exists := signalIconViewSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectionChangedMap, connectionID)
}

//export iconview_selectionChangedHandler
func iconview_selectionChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewSelectionChangedMap[index].callback
	callback()
}

type signalIconViewToggleCursorItemDetail struct {
	callback  IconViewSignalToggleCursorItemCallback
	handlerID C.gulong
}

var signalIconViewToggleCursorItemId int
var signalIconViewToggleCursorItemMap = make(map[int]signalIconViewToggleCursorItemDetail)
var signalIconViewToggleCursorItemLock sync.Mutex

// IconViewSignalToggleCursorItemCallback is a callback function for a 'toggle-cursor-item' signal emitted from a IconView.
type IconViewSignalToggleCursorItemCallback func()

/*
ConnectToggleCursorItem connects the callback to the 'toggle-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorItem to remove it.
*/
func (recv *IconView) ConnectToggleCursorItem(callback IconViewSignalToggleCursorItemCallback) int {
	signalIconViewToggleCursorItemLock.Lock()
	defer signalIconViewToggleCursorItemLock.Unlock()

	signalIconViewToggleCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_toggle_cursor_item(instance, C.gpointer(uintptr(signalIconViewToggleCursorItemId)))

	detail := signalIconViewToggleCursorItemDetail{callback, handlerID}
	signalIconViewToggleCursorItemMap[signalIconViewToggleCursorItemId] = detail

	return signalIconViewToggleCursorItemId
}

/*
DisconnectToggleCursorItem disconnects a callback from the 'toggle-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectToggleCursorItem.
*/
func (recv *IconView) DisconnectToggleCursorItem(connectionID int) {
	signalIconViewToggleCursorItemLock.Lock()
	defer signalIconViewToggleCursorItemLock.Unlock()

	detail, exists := signalIconViewToggleCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewToggleCursorItemMap, connectionID)
}

//export iconview_toggleCursorItemHandler
func iconview_toggleCursorItemHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewToggleCursorItemMap[index].callback
	callback()
}

type signalIconViewUnselectAllDetail struct {
	callback  IconViewSignalUnselectAllCallback
	handlerID C.gulong
}

var signalIconViewUnselectAllId int
var signalIconViewUnselectAllMap = make(map[int]signalIconViewUnselectAllDetail)
var signalIconViewUnselectAllLock sync.Mutex

// IconViewSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a IconView.
type IconViewSignalUnselectAllCallback func()

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *IconView) ConnectUnselectAll(callback IconViewSignalUnselectAllCallback) int {
	signalIconViewUnselectAllLock.Lock()
	defer signalIconViewUnselectAllLock.Unlock()

	signalIconViewUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalIconViewUnselectAllId)))

	detail := signalIconViewUnselectAllDetail{callback, handlerID}
	signalIconViewUnselectAllMap[signalIconViewUnselectAllId] = detail

	return signalIconViewUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the IconView.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *IconView) DisconnectUnselectAll(connectionID int) {
	signalIconViewUnselectAllLock.Lock()
	defer signalIconViewUnselectAllLock.Unlock()

	detail, exists := signalIconViewUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewUnselectAllMap, connectionID)
}

//export iconview_unselectAllHandler
func iconview_unselectAllHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalIconViewUnselectAllMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by IconView
func (recv *IconView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by IconView
func (recv *IconView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by IconView
func (recv *IconView) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by IconView
func (recv *IconView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// IconViewAccessible is a wrapper around the C record GtkIconViewAccessible.
type IconViewAccessible struct {
	native *C.GtkIconViewAccessible
	// parent : record
	// priv : record
}

func IconViewAccessibleNewFromC(u unsafe.Pointer) *IconViewAccessible {
	c := (*C.GtkIconViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &IconViewAccessible{native: c}

	return g
}

func (recv *IconViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *IconViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *IconViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *IconViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *IconViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to IconViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconViewAccessible.
func CastToIconViewAccessible(object *gobject.Object) *IconViewAccessible {
	return IconViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by IconViewAccessible
func (recv *IconViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by IconViewAccessible
func (recv *IconViewAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Image is a wrapper around the C record GtkImage.
type Image struct {
	native *C.GtkImage
	// misc : record
	// Private : priv
}

func ImageNewFromC(u unsafe.Pointer) *Image {
	c := (*C.GtkImage)(u)
	if c == nil {
		return nil
	}

	g := &Image{native: c}

	return g
}

func (recv *Image) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Misc upcasts to *Misc
func (recv *Image) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Image) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Image) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Image) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitary Object to Image.
// Exercise care, as this is a potentially dangerous function if the Object is not a Image.
func CastToImage(object *gobject.Object) *Image {
	return ImageNewFromC(object.ToC())
}

// Creates a new empty #GtkImage widget.
/*

C function : gtk_image_new
*/
func ImageNew() *Image {
	retC := C.gtk_image_new()
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a #GtkImage displaying the given animation.
// The #GtkImage does not assume a reference to the
// animation; you still need to unref it if you own references.
// #GtkImage will add its own reference rather than adopting yours.
//
// Note that the animation frames are shown using a timeout with
// #G_PRIORITY_DEFAULT. When using animations to indicate busyness,
// keep in mind that the animation will only be shown if the main loop
// is not busy with something that has a higher priority.
/*

C function : gtk_image_new_from_animation
*/
func ImageNewFromAnimation(animation *gdkpixbuf.PixbufAnimation) *Image {
	c_animation := (*C.GdkPixbufAnimation)(C.NULL)
	if animation != nil {
		c_animation = (*C.GdkPixbufAnimation)(animation.ToC())
	}

	retC := C.gtk_image_new_from_animation(c_animation)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImage displaying the file @filename. If the file
// isn’t found or can’t be loaded, the resulting #GtkImage will
// display a “broken image” icon. This function never returns %NULL,
// it always returns a valid #GtkImage widget.
//
// If the file contains an animation, the image will contain an
// animation.
//
// If you need to detect failures to load the file, use
// gdk_pixbuf_new_from_file() to load the file yourself, then create
// the #GtkImage from the pixbuf. (Or for animations, use
// gdk_pixbuf_animation_new_from_file()).
//
// The storage type (gtk_image_get_storage_type()) of the returned
// image is not defined, it will be whatever is appropriate for
// displaying the file.
/*

C function : gtk_image_new_from_file
*/
func ImageNewFromFile(filename string) *Image {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.gtk_image_new_from_file(c_filename)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a #GtkImage displaying an icon set. Sample stock sizes are
// #GTK_ICON_SIZE_MENU, #GTK_ICON_SIZE_SMALL_TOOLBAR. Instead of using
// this function, usually it’s better to create a #GtkIconFactory, put
// your icon sets in the icon factory, add the icon factory to the
// list of default factories with gtk_icon_factory_add_default(), and
// then use gtk_image_new_from_stock(). This will allow themes to
// override the icon you ship with your application.
//
// The #GtkImage does not assume a reference to the
// icon set; you still need to unref it if you own references.
// #GtkImage will add its own reference rather than adopting yours.
/*

C function : gtk_image_new_from_icon_set
*/
func ImageNewFromIconSet(iconSet *IconSet, size IconSize) *Image {
	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	c_size := (C.GtkIconSize)(size)

	retC := C.gtk_image_new_from_icon_set(c_icon_set, c_size)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImage displaying @pixbuf.
// The #GtkImage does not assume a reference to the
// pixbuf; you still need to unref it if you own references.
// #GtkImage will add its own reference rather than adopting yours.
//
// Note that this function just creates an #GtkImage from the pixbuf. The
// #GtkImage created will not react to state changes. Should you want that,
// you should use gtk_image_new_from_icon_name().
/*

C function : gtk_image_new_from_pixbuf
*/
func ImageNewFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *Image {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	retC := C.gtk_image_new_from_pixbuf(c_pixbuf)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a #GtkImage displaying a stock icon. Sample stock icon
// names are #GTK_STOCK_OPEN, #GTK_STOCK_QUIT. Sample stock sizes
// are #GTK_ICON_SIZE_MENU, #GTK_ICON_SIZE_SMALL_TOOLBAR. If the stock
// icon name isn’t known, the image will be empty.
// You can register your own stock icon names, see
// gtk_icon_factory_add_default() and gtk_icon_factory_add().
/*

C function : gtk_image_new_from_stock
*/
func ImageNewFromStock(stockId string, size IconSize) *Image {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	retC := C.gtk_image_new_from_stock(c_stock_id, c_size)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the #GdkPixbufAnimation being displayed by the #GtkImage.
// The storage type of the image must be %GTK_IMAGE_EMPTY or
// %GTK_IMAGE_ANIMATION (see gtk_image_get_storage_type()).
// The caller of this function does not own a reference to the
// returned animation.
/*

C function : gtk_image_get_animation
*/
func (recv *Image) GetAnimation() *gdkpixbuf.PixbufAnimation {
	retC := C.gtk_image_get_animation((*C.GtkImage)(recv.native))
	var retGo (*gdkpixbuf.PixbufAnimation)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufAnimationNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_image_get_icon_set : unsupported parameter size : no type generator for gint (GtkIconSize*) for param size

// Gets the #GdkPixbuf being displayed by the #GtkImage.
// The storage type of the image must be %GTK_IMAGE_EMPTY or
// %GTK_IMAGE_PIXBUF (see gtk_image_get_storage_type()).
// The caller of this function does not own a reference to the
// returned pixbuf.
/*

C function : gtk_image_get_pixbuf
*/
func (recv *Image) GetPixbuf() *gdkpixbuf.Pixbuf {
	retC := C.gtk_image_get_pixbuf((*C.GtkImage)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_image_get_stock : unsupported parameter size : no type generator for gint (GtkIconSize*) for param size

// Gets the type of representation being used by the #GtkImage
// to store image data. If the #GtkImage has no image data,
// the return value will be %GTK_IMAGE_EMPTY.
/*

C function : gtk_image_get_storage_type
*/
func (recv *Image) GetStorageType() ImageType {
	retC := C.gtk_image_get_storage_type((*C.GtkImage)(recv.native))
	retGo := (ImageType)(retC)

	return retGo
}

// Causes the #GtkImage to display the given animation (or display
// nothing, if you set the animation to %NULL).
/*

C function : gtk_image_set_from_animation
*/
func (recv *Image) SetFromAnimation(animation *gdkpixbuf.PixbufAnimation) {
	c_animation := (*C.GdkPixbufAnimation)(C.NULL)
	if animation != nil {
		c_animation = (*C.GdkPixbufAnimation)(animation.ToC())
	}

	C.gtk_image_set_from_animation((*C.GtkImage)(recv.native), c_animation)

	return
}

// See gtk_image_new_from_file() for details.
/*

C function : gtk_image_set_from_file
*/
func (recv *Image) SetFromFile(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_image_set_from_file((*C.GtkImage)(recv.native), c_filename)

	return
}

// See gtk_image_new_from_icon_set() for details.
/*

C function : gtk_image_set_from_icon_set
*/
func (recv *Image) SetFromIconSet(iconSet *IconSet, size IconSize) {
	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	c_size := (C.GtkIconSize)(size)

	C.gtk_image_set_from_icon_set((*C.GtkImage)(recv.native), c_icon_set, c_size)

	return
}

// See gtk_image_new_from_pixbuf() for details.
/*

C function : gtk_image_set_from_pixbuf
*/
func (recv *Image) SetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_image_set_from_pixbuf((*C.GtkImage)(recv.native), c_pixbuf)

	return
}

// See gtk_image_new_from_resource() for details.
/*

C function : gtk_image_set_from_resource
*/
func (recv *Image) SetFromResource(resourcePath string) {
	c_resource_path := C.CString(resourcePath)
	defer C.free(unsafe.Pointer(c_resource_path))

	C.gtk_image_set_from_resource((*C.GtkImage)(recv.native), c_resource_path)

	return
}

// See gtk_image_new_from_stock() for details.
/*

C function : gtk_image_set_from_stock
*/
func (recv *Image) SetFromStock(stockId string, size IconSize) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	C.gtk_image_set_from_stock((*C.GtkImage)(recv.native), c_stock_id, c_size)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Image
func (recv *Image) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Image
func (recv *Image) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ImageAccessible is a wrapper around the C record GtkImageAccessible.
type ImageAccessible struct {
	native *C.GtkImageAccessible
	// parent : record
	// priv : record
}

func ImageAccessibleNewFromC(u unsafe.Pointer) *ImageAccessible {
	c := (*C.GtkImageAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ImageAccessible{native: c}

	return g
}

func (recv *ImageAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ImageAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ImageAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ImageAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ImageAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageAccessible.
func CastToImageAccessible(object *gobject.Object) *ImageAccessible {
	return ImageAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ImageAccessible
func (recv *ImageAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ImageAccessible
func (recv *ImageAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ImageCellAccessible is a wrapper around the C record GtkImageCellAccessible.
type ImageCellAccessible struct {
	native *C.GtkImageCellAccessible
	// parent : record
	// priv : record
}

func ImageCellAccessibleNewFromC(u unsafe.Pointer) *ImageCellAccessible {
	c := (*C.GtkImageCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ImageCellAccessible{native: c}

	return g
}

func (recv *ImageCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *ImageCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *ImageCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ImageCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ImageCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ImageCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageCellAccessible.
func CastToImageCellAccessible(object *gobject.Object) *ImageCellAccessible {
	return ImageCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ImageMenuItem is a wrapper around the C record GtkImageMenuItem.
type ImageMenuItem struct {
	native *C.GtkImageMenuItem
	// menu_item : record
	// Private : priv
}

func ImageMenuItemNewFromC(u unsafe.Pointer) *ImageMenuItem {
	c := (*C.GtkImageMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &ImageMenuItem{native: c}

	return g
}

func (recv *ImageMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItem upcasts to *MenuItem
func (recv *ImageMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ImageMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *ImageMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *ImageMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ImageMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ImageMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitary Object to ImageMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageMenuItem.
func CastToImageMenuItem(object *gobject.Object) *ImageMenuItem {
	return ImageMenuItemNewFromC(object.ToC())
}

// Creates a new #GtkImageMenuItem with an empty label.
/*

C function : gtk_image_menu_item_new
*/
func ImageMenuItemNew() *ImageMenuItem {
	retC := C.gtk_image_menu_item_new()
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImageMenuItem containing the image and text from a
// stock item. Some stock ids have preprocessor macros like #GTK_STOCK_OK
// and #GTK_STOCK_APPLY.
//
// If you want this menu item to have changeable accelerators, then pass in
// %NULL for accel_group. Next call gtk_menu_item_set_accel_path() with an
// appropriate path for the menu item, use gtk_stock_lookup() to look up the
// standard accelerator for the stock item, and if one is found, call
// gtk_accel_map_add_entry() to register it.
/*

C function : gtk_image_menu_item_new_from_stock
*/
func ImageMenuItemNewFromStock(stockId string, accelGroup *AccelGroup) *ImageMenuItem {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	retC := C.gtk_image_menu_item_new_from_stock(c_stock_id, c_accel_group)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImageMenuItem containing a label.
/*

C function : gtk_image_menu_item_new_with_label
*/
func ImageMenuItemNewWithLabel(label string) *ImageMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_image_menu_item_new_with_label(c_label)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkImageMenuItem containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
/*

C function : gtk_image_menu_item_new_with_mnemonic
*/
func ImageMenuItemNewWithMnemonic(label string) *ImageMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_image_menu_item_new_with_mnemonic(c_label)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the widget that is currently set as the image of @image_menu_item.
// See gtk_image_menu_item_set_image().
/*

C function : gtk_image_menu_item_get_image
*/
func (recv *ImageMenuItem) GetImage() *Widget {
	retC := C.gtk_image_menu_item_get_image((*C.GtkImageMenuItem)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the image of @image_menu_item to the given widget.
// Note that it depends on the show-menu-images setting whether
// the image will be displayed or not.
/*

C function : gtk_image_menu_item_set_image
*/
func (recv *ImageMenuItem) SetImage(image *Widget) {
	c_image := (*C.GtkWidget)(C.NULL)
	if image != nil {
		c_image = (*C.GtkWidget)(image.ToC())
	}

	C.gtk_image_menu_item_set_image((*C.GtkImageMenuItem)(recv.native), c_image)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ImageMenuItem
func (recv *ImageMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// InfoBar is a wrapper around the C record GtkInfoBar.
type InfoBar struct {
	native *C.GtkInfoBar
	// parent : record
	// Private : priv
}

func InfoBarNewFromC(u unsafe.Pointer) *InfoBar {
	c := (*C.GtkInfoBar)(u)
	if c == nil {
		return nil
	}

	g := &InfoBar{native: c}

	return g
}

func (recv *InfoBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *InfoBar) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *InfoBar) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *InfoBar) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *InfoBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *InfoBar) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to InfoBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a InfoBar.
func CastToInfoBar(object *gobject.Object) *InfoBar {
	return InfoBarNewFromC(object.ToC())
}

// Unsupported : gtk_info_bar_new_with_buttons : unsupported parameter ... : varargs

// ImplementorIface returns the ImplementorIface interface implemented by InfoBar
func (recv *InfoBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by InfoBar
func (recv *InfoBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by InfoBar
func (recv *InfoBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Invisible is a wrapper around the C record GtkInvisible.
type Invisible struct {
	native *C.GtkInvisible
	// widget : record
	// Private : priv
}

func InvisibleNewFromC(u unsafe.Pointer) *Invisible {
	c := (*C.GtkInvisible)(u)
	if c == nil {
		return nil
	}

	g := &Invisible{native: c}

	return g
}

func (recv *Invisible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Invisible) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Invisible) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Invisible) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Invisible.
// Exercise care, as this is a potentially dangerous function if the Object is not a Invisible.
func CastToInvisible(object *gobject.Object) *Invisible {
	return InvisibleNewFromC(object.ToC())
}

// Creates a new #GtkInvisible.
/*

C function : gtk_invisible_new
*/
func InvisibleNew() *Invisible {
	retC := C.gtk_invisible_new()
	retGo := InvisibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Invisible
func (recv *Invisible) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Invisible
func (recv *Invisible) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Label is a wrapper around the C record GtkLabel.
type Label struct {
	native *C.GtkLabel
	// misc : record
	// Private : priv
}

func LabelNewFromC(u unsafe.Pointer) *Label {
	c := (*C.GtkLabel)(u)
	if c == nil {
		return nil
	}

	g := &Label{native: c}

	return g
}

func (recv *Label) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Misc upcasts to *Misc
func (recv *Label) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Label) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Label) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Label) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitary Object to Label.
// Exercise care, as this is a potentially dangerous function if the Object is not a Label.
func CastToLabel(object *gobject.Object) *Label {
	return LabelNewFromC(object.ToC())
}

type signalLabelCopyClipboardDetail struct {
	callback  LabelSignalCopyClipboardCallback
	handlerID C.gulong
}

var signalLabelCopyClipboardId int
var signalLabelCopyClipboardMap = make(map[int]signalLabelCopyClipboardDetail)
var signalLabelCopyClipboardLock sync.Mutex

// LabelSignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a Label.
type LabelSignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *Label) ConnectCopyClipboard(callback LabelSignalCopyClipboardCallback) int {
	signalLabelCopyClipboardLock.Lock()
	defer signalLabelCopyClipboardLock.Unlock()

	signalLabelCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalLabelCopyClipboardId)))

	detail := signalLabelCopyClipboardDetail{callback, handlerID}
	signalLabelCopyClipboardMap[signalLabelCopyClipboardId] = detail

	return signalLabelCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the Label.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *Label) DisconnectCopyClipboard(connectionID int) {
	signalLabelCopyClipboardLock.Lock()
	defer signalLabelCopyClipboardLock.Unlock()

	detail, exists := signalLabelCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelCopyClipboardMap, connectionID)
}

//export label_copyClipboardHandler
func label_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalLabelCopyClipboardMap[index].callback
	callback()
}

// Unsupported signal 'move-cursor' for Label : unsupported parameter step : type MovementStep :

type signalLabelPopulatePopupDetail struct {
	callback  LabelSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalLabelPopulatePopupId int
var signalLabelPopulatePopupMap = make(map[int]signalLabelPopulatePopupDetail)
var signalLabelPopulatePopupLock sync.Mutex

// LabelSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a Label.
type LabelSignalPopulatePopupCallback func(menu *Menu)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *Label) ConnectPopulatePopup(callback LabelSignalPopulatePopupCallback) int {
	signalLabelPopulatePopupLock.Lock()
	defer signalLabelPopulatePopupLock.Unlock()

	signalLabelPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalLabelPopulatePopupId)))

	detail := signalLabelPopulatePopupDetail{callback, handlerID}
	signalLabelPopulatePopupMap[signalLabelPopulatePopupId] = detail

	return signalLabelPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the Label.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *Label) DisconnectPopulatePopup(connectionID int) {
	signalLabelPopulatePopupLock.Lock()
	defer signalLabelPopulatePopupLock.Unlock()

	detail, exists := signalLabelPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelPopulatePopupMap, connectionID)
}

//export label_populatePopupHandler
func label_populatePopupHandler(_ *C.GObject, c_menu *C.GtkMenu, data C.gpointer) {
	menu := MenuNewFromC(unsafe.Pointer(c_menu))

	index := int(uintptr(data))
	callback := signalLabelPopulatePopupMap[index].callback
	callback(menu)
}

// Creates a new label with the given text inside it. You can
// pass %NULL to get an empty label widget.
/*

C function : gtk_label_new
*/
func LabelNew(str string) *Label {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	retC := C.gtk_label_new(c_str)
	retGo := LabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkLabel, containing the text in @str.
//
// If characters in @str are preceded by an underscore, they are
// underlined. If you need a literal underscore character in a label, use
// '__' (two underscores). The first underlined character represents a
// keyboard accelerator called a mnemonic. The mnemonic key can be used
// to activate another widget, chosen automatically, or explicitly using
// gtk_label_set_mnemonic_widget().
//
// If gtk_label_set_mnemonic_widget() is not called, then the first
// activatable ancestor of the #GtkLabel will be chosen as the mnemonic
// widget. For instance, if the label is inside a button or menu item,
// the button or menu item will automatically become the mnemonic widget
// and be activated by the mnemonic.
/*

C function : gtk_label_new_with_mnemonic
*/
func LabelNewWithMnemonic(str string) *Label {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	retC := C.gtk_label_new_with_mnemonic(c_str)
	retGo := LabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the attribute list that was set on the label using
// gtk_label_set_attributes(), if any. This function does
// not reflect attributes that come from the labels markup
// (see gtk_label_set_markup()). If you want to get the
// effective attributes for the label, use
// pango_layout_get_attribute (gtk_label_get_layout (label)).
/*

C function : gtk_label_get_attributes
*/
func (recv *Label) GetAttributes() *pango.AttrList {
	retC := C.gtk_label_get_attributes((*C.GtkLabel)(recv.native))
	var retGo (*pango.AttrList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = pango.AttrListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the justification of the label. See gtk_label_set_justify().
/*

C function : gtk_label_get_justify
*/
func (recv *Label) GetJustify() Justification {
	retC := C.gtk_label_get_justify((*C.GtkLabel)(recv.native))
	retGo := (Justification)(retC)

	return retGo
}

// Fetches the text from a label widget including any embedded
// underlines indicating mnemonics and Pango markup. (See
// gtk_label_get_text()).
/*

C function : gtk_label_get_label
*/
func (recv *Label) GetLabel() string {
	retC := C.gtk_label_get_label((*C.GtkLabel)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Gets the #PangoLayout used to display the label.
// The layout is useful to e.g. convert text positions to
// pixel positions, in combination with gtk_label_get_layout_offsets().
// The returned layout is owned by the @label so need not be
// freed by the caller. The @label is free to recreate its layout at
// any time, so it should be considered read-only.
/*

C function : gtk_label_get_layout
*/
func (recv *Label) GetLayout() *pango.Layout {
	retC := C.gtk_label_get_layout((*C.GtkLabel)(recv.native))
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Obtains the coordinates where the label will draw the #PangoLayout
// representing the text in the label; useful to convert mouse events
// into coordinates inside the #PangoLayout, e.g. to take some action
// if some part of the label is clicked. Of course you will need to
// create a #GtkEventBox to receive the events, and pack the label
// inside it, since labels are windowless (they return %FALSE from
// gtk_widget_get_has_window()). Remember
// when using the #PangoLayout functions you need to convert to
// and from pixels using PANGO_PIXELS() or #PANGO_SCALE.
/*

C function : gtk_label_get_layout_offsets
*/
func (recv *Label) GetLayoutOffsets() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_label_get_layout_offsets((*C.GtkLabel)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// Returns whether lines in the label are automatically wrapped.
// See gtk_label_set_line_wrap().
/*

C function : gtk_label_get_line_wrap
*/
func (recv *Label) GetLineWrap() bool {
	retC := C.gtk_label_get_line_wrap((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// If the label has been set so that it has an mnemonic key this function
// returns the keyval used for the mnemonic accelerator. If there is no
// mnemonic set up it returns #GDK_KEY_VoidSymbol.
/*

C function : gtk_label_get_mnemonic_keyval
*/
func (recv *Label) GetMnemonicKeyval() uint32 {
	retC := C.gtk_label_get_mnemonic_keyval((*C.GtkLabel)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Retrieves the target of the mnemonic (keyboard shortcut) of this
// label. See gtk_label_set_mnemonic_widget().
/*

C function : gtk_label_get_mnemonic_widget
*/
func (recv *Label) GetMnemonicWidget() *Widget {
	retC := C.gtk_label_get_mnemonic_widget((*C.GtkLabel)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets the value set by gtk_label_set_selectable().
/*

C function : gtk_label_get_selectable
*/
func (recv *Label) GetSelectable() bool {
	retC := C.gtk_label_get_selectable((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the selected range of characters in the label, returning %TRUE
// if there’s a selection.
/*

C function : gtk_label_get_selection_bounds
*/
func (recv *Label) GetSelectionBounds() (bool, int32, int32) {
	var c_start C.gint

	var c_end C.gint

	retC := C.gtk_label_get_selection_bounds((*C.GtkLabel)(recv.native), &c_start, &c_end)
	retGo := retC == C.TRUE

	start := (int32)(c_start)

	end := (int32)(c_end)

	return retGo, start, end
}

// Fetches the text from a label widget, as displayed on the
// screen. This does not include any embedded underlines
// indicating mnemonics or Pango markup. (See gtk_label_get_label())
/*

C function : gtk_label_get_text
*/
func (recv *Label) GetText() string {
	retC := C.gtk_label_get_text((*C.GtkLabel)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Returns whether the label’s text is interpreted as marked up with
// the [Pango text markup language][PangoMarkupFormat].
// See gtk_label_set_use_markup ().
/*

C function : gtk_label_get_use_markup
*/
func (recv *Label) GetUseMarkup() bool {
	retC := C.gtk_label_get_use_markup((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether an embedded underline in the label indicates a
// mnemonic. See gtk_label_set_use_underline().
/*

C function : gtk_label_get_use_underline
*/
func (recv *Label) GetUseUnderline() bool {
	retC := C.gtk_label_get_use_underline((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Selects a range of characters in the label, if the label is selectable.
// See gtk_label_set_selectable(). If the label is not selectable,
// this function has no effect. If @start_offset or
// @end_offset are -1, then the end of the label will be substituted.
/*

C function : gtk_label_select_region
*/
func (recv *Label) SelectRegion(startOffset int32, endOffset int32) {
	c_start_offset := (C.gint)(startOffset)

	c_end_offset := (C.gint)(endOffset)

	C.gtk_label_select_region((*C.GtkLabel)(recv.native), c_start_offset, c_end_offset)

	return
}

// Sets a #PangoAttrList; the attributes in the list are applied to the
// label text.
//
// The attributes set with this function will be applied
// and merged with any other attributes previously effected by way
// of the #GtkLabel:use-underline or #GtkLabel:use-markup properties.
// While it is not recommended to mix markup strings with manually set
// attributes, if you must; know that the attributes will be applied
// to the label after the markup string is parsed.
/*

C function : gtk_label_set_attributes
*/
func (recv *Label) SetAttributes(attrs *pango.AttrList) {
	c_attrs := (*C.PangoAttrList)(C.NULL)
	if attrs != nil {
		c_attrs = (*C.PangoAttrList)(attrs.ToC())
	}

	C.gtk_label_set_attributes((*C.GtkLabel)(recv.native), c_attrs)

	return
}

// Sets the alignment of the lines in the text of the label relative to
// each other. %GTK_JUSTIFY_LEFT is the default value when the widget is
// first created with gtk_label_new(). If you instead want to set the
// alignment of the label as a whole, use gtk_widget_set_halign() instead.
// gtk_label_set_justify() has no effect on labels containing only a
// single line.
/*

C function : gtk_label_set_justify
*/
func (recv *Label) SetJustify(jtype Justification) {
	c_jtype := (C.GtkJustification)(jtype)

	C.gtk_label_set_justify((*C.GtkLabel)(recv.native), c_jtype)

	return
}

// Sets the text of the label. The label is interpreted as
// including embedded underlines and/or Pango markup depending
// on the values of the #GtkLabel:use-underline and
// #GtkLabel:use-markup properties.
/*

C function : gtk_label_set_label
*/
func (recv *Label) SetLabel(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_label((*C.GtkLabel)(recv.native), c_str)

	return
}

// Toggles line wrapping within the #GtkLabel widget. %TRUE makes it break
// lines if text exceeds the widget’s size. %FALSE lets the text get cut off
// by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to %TRUE does not make the label
// wrap at its parent container’s width, because GTK+ widgets
// conceptually can’t make their requisition depend on the parent
// container’s size. For a label that wraps at a specific position,
// set the label’s width using gtk_widget_set_size_request().
/*

C function : gtk_label_set_line_wrap
*/
func (recv *Label) SetLineWrap(wrap bool) {
	c_wrap :=
		boolToGboolean(wrap)

	C.gtk_label_set_line_wrap((*C.GtkLabel)(recv.native), c_wrap)

	return
}

// Parses @str which is marked up with the
// [Pango text markup language][PangoMarkupFormat], setting the
// label’s text and attribute list based on the parse results.
//
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
// |[<!-- language="C" -->
// GtkWidget *label = gtk_label_new (NULL);
// const char *str = "some text";
// const char *format = "<span style=\"italic\">\%s</span>";
// char *markup;
//
// markup = g_markup_printf_escaped (format, str);
// gtk_label_set_markup (GTK_LABEL (label), markup);
// g_free (markup);
// ]|
//
// This function will set the #GtkLabel:use-markup property to %TRUE as
// a side effect.
//
// If you set the label contents using the #GtkLabel:label property you
// should also ensure that you set the #GtkLabel:use-markup property
// accordingly.
//
// See also: gtk_label_set_text()
/*

C function : gtk_label_set_markup
*/
func (recv *Label) SetMarkup(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_markup((*C.GtkLabel)(recv.native), c_str)

	return
}

// Parses @str which is marked up with the
// [Pango text markup language][PangoMarkupFormat],
// setting the label’s text and attribute list based on the parse results.
// If characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
/*

C function : gtk_label_set_markup_with_mnemonic
*/
func (recv *Label) SetMarkupWithMnemonic(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_markup_with_mnemonic((*C.GtkLabel)(recv.native), c_str)

	return
}

// If the label has been set so that it has an mnemonic key (using
// i.e. gtk_label_set_markup_with_mnemonic(),
// gtk_label_set_text_with_mnemonic(), gtk_label_new_with_mnemonic()
// or the “use_underline” property) the label can be associated with a
// widget that is the target of the mnemonic. When the label is inside
// a widget (like a #GtkButton or a #GtkNotebook tab) it is
// automatically associated with the correct widget, but sometimes
// (i.e. when the target is a #GtkEntry next to the label) you need to
// set it explicitly using this function.
//
// The target widget will be accelerated by emitting the
// GtkWidget::mnemonic-activate signal on it. The default handler for
// this signal will activate the widget if there are no mnemonic collisions
// and toggle focus between the colliding widgets otherwise.
/*

C function : gtk_label_set_mnemonic_widget
*/
func (recv *Label) SetMnemonicWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_label_set_mnemonic_widget((*C.GtkLabel)(recv.native), c_widget)

	return
}

// The pattern of underlines you want under the existing text within the
// #GtkLabel widget.  For example if the current text of the label says
// “FooBarBaz” passing a pattern of “___   ___” will underline
// “Foo” and “Baz” but not “Bar”.
/*

C function : gtk_label_set_pattern
*/
func (recv *Label) SetPattern(pattern string) {
	c_pattern := C.CString(pattern)
	defer C.free(unsafe.Pointer(c_pattern))

	C.gtk_label_set_pattern((*C.GtkLabel)(recv.native), c_pattern)

	return
}

// Selectable labels allow the user to select text from the label, for
// copy-and-paste.
/*

C function : gtk_label_set_selectable
*/
func (recv *Label) SetSelectable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_selectable((*C.GtkLabel)(recv.native), c_setting)

	return
}

// Sets the text within the #GtkLabel widget. It overwrites any text that
// was there before.
//
// This function will clear any previously set mnemonic accelerators, and
// set the #GtkLabel:use-underline property to %FALSE as a side effect.
//
// This function will set the #GtkLabel:use-markup property to %FALSE
// as a side effect.
//
// See also: gtk_label_set_markup()
/*

C function : gtk_label_set_text
*/
func (recv *Label) SetText(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_text((*C.GtkLabel)(recv.native), c_str)

	return
}

// Sets the label’s text from the string @str.
// If characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using gtk_label_set_mnemonic_widget().
/*

C function : gtk_label_set_text_with_mnemonic
*/
func (recv *Label) SetTextWithMnemonic(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_text_with_mnemonic((*C.GtkLabel)(recv.native), c_str)

	return
}

// Sets whether the text of the label contains markup in
// [Pango’s text markup language][PangoMarkupFormat].
// See gtk_label_set_markup().
/*

C function : gtk_label_set_use_markup
*/
func (recv *Label) SetUseMarkup(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_use_markup((*C.GtkLabel)(recv.native), c_setting)

	return
}

// If true, an underline in the text indicates the next character should be
// used for the mnemonic accelerator key.
/*

C function : gtk_label_set_use_underline
*/
func (recv *Label) SetUseUnderline(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_use_underline((*C.GtkLabel)(recv.native), c_setting)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Label
func (recv *Label) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Label
func (recv *Label) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LabelAccessible is a wrapper around the C record GtkLabelAccessible.
type LabelAccessible struct {
	native *C.GtkLabelAccessible
	// parent : record
	// priv : record
}

func LabelAccessibleNewFromC(u unsafe.Pointer) *LabelAccessible {
	c := (*C.GtkLabelAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LabelAccessible{native: c}

	return g
}

func (recv *LabelAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LabelAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *LabelAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LabelAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to LabelAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LabelAccessible.
func CastToLabelAccessible(object *gobject.Object) *LabelAccessible {
	return LabelAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by LabelAccessible
func (recv *LabelAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Hypertext returns the Hypertext interface implemented by LabelAccessible
func (recv *LabelAccessible) Hypertext() *atk.Hypertext {
	return atk.HypertextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by LabelAccessible
func (recv *LabelAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// Layout is a wrapper around the C record GtkLayout.
type Layout struct {
	native *C.GtkLayout
	// container : record
	// Private : priv
}

func LayoutNewFromC(u unsafe.Pointer) *Layout {
	c := (*C.GtkLayout)(u)
	if c == nil {
		return nil
	}

	g := &Layout{native: c}

	return g
}

func (recv *Layout) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Layout) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Layout) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Layout) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Layout) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Layout.
// Exercise care, as this is a potentially dangerous function if the Object is not a Layout.
func CastToLayout(object *gobject.Object) *Layout {
	return LayoutNewFromC(object.ToC())
}

// Creates a new #GtkLayout. Unless you have a specific adjustment
// you’d like the layout to use for scrolling, pass %NULL for
// @hadjustment and @vadjustment.
/*

C function : gtk_layout_new
*/
func LayoutNew(hadjustment *Adjustment, vadjustment *Adjustment) *Layout {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_layout_new(c_hadjustment, c_vadjustment)
	retGo := LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This function should only be called after the layout has been
// placed in a #GtkScrolledWindow or otherwise configured for
// scrolling. It returns the #GtkAdjustment used for communication
// between the horizontal scrollbar and @layout.
//
// See #GtkScrolledWindow, #GtkScrollbar, #GtkAdjustment for details.
/*

C function : gtk_layout_get_hadjustment
*/
func (recv *Layout) GetHadjustment() *Adjustment {
	retC := C.gtk_layout_get_hadjustment((*C.GtkLayout)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the size that has been set on the layout, and that determines
// the total extents of the layout’s scrollbar area. See
// gtk_layout_set_size ().
/*

C function : gtk_layout_get_size
*/
func (recv *Layout) GetSize() (uint32, uint32) {
	var c_width C.guint

	var c_height C.guint

	C.gtk_layout_get_size((*C.GtkLayout)(recv.native), &c_width, &c_height)

	width := (uint32)(c_width)

	height := (uint32)(c_height)

	return width, height
}

// This function should only be called after the layout has been
// placed in a #GtkScrolledWindow or otherwise configured for
// scrolling. It returns the #GtkAdjustment used for communication
// between the vertical scrollbar and @layout.
//
// See #GtkScrolledWindow, #GtkScrollbar, #GtkAdjustment for details.
/*

C function : gtk_layout_get_vadjustment
*/
func (recv *Layout) GetVadjustment() *Adjustment {
	retC := C.gtk_layout_get_vadjustment((*C.GtkLayout)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Moves a current child of @layout to a new position.
/*

C function : gtk_layout_move
*/
func (recv *Layout) Move(childWidget *Widget, x int32, y int32) {
	c_child_widget := (*C.GtkWidget)(C.NULL)
	if childWidget != nil {
		c_child_widget = (*C.GtkWidget)(childWidget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_layout_move((*C.GtkLayout)(recv.native), c_child_widget, c_x, c_y)

	return
}

// Adds @child_widget to @layout, at position (@x,@y).
// @layout becomes the new parent container of @child_widget.
/*

C function : gtk_layout_put
*/
func (recv *Layout) Put(childWidget *Widget, x int32, y int32) {
	c_child_widget := (*C.GtkWidget)(C.NULL)
	if childWidget != nil {
		c_child_widget = (*C.GtkWidget)(childWidget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_layout_put((*C.GtkLayout)(recv.native), c_child_widget, c_x, c_y)

	return
}

// Sets the horizontal scroll adjustment for the layout.
//
// See #GtkScrolledWindow, #GtkScrollbar, #GtkAdjustment for details.
/*

C function : gtk_layout_set_hadjustment
*/
func (recv *Layout) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_layout_set_hadjustment((*C.GtkLayout)(recv.native), c_adjustment)

	return
}

// Sets the size of the scrollable area of the layout.
/*

C function : gtk_layout_set_size
*/
func (recv *Layout) SetSize(width uint32, height uint32) {
	c_width := (C.guint)(width)

	c_height := (C.guint)(height)

	C.gtk_layout_set_size((*C.GtkLayout)(recv.native), c_width, c_height)

	return
}

// Sets the vertical scroll adjustment for the layout.
//
// See #GtkScrolledWindow, #GtkScrollbar, #GtkAdjustment for details.
/*

C function : gtk_layout_set_vadjustment
*/
func (recv *Layout) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_layout_set_vadjustment((*C.GtkLayout)(recv.native), c_adjustment)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Layout
func (recv *Layout) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Layout
func (recv *Layout) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by Layout
func (recv *Layout) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// LevelBar is a wrapper around the C record GtkLevelBar.
type LevelBar struct {
	native *C.GtkLevelBar
	// Private : parent
	// Private : priv
}

func LevelBarNewFromC(u unsafe.Pointer) *LevelBar {
	c := (*C.GtkLevelBar)(u)
	if c == nil {
		return nil
	}

	g := &LevelBar{native: c}

	return g
}

func (recv *LevelBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *LevelBar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LevelBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LevelBar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to LevelBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a LevelBar.
func CastToLevelBar(object *gobject.Object) *LevelBar {
	return LevelBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by LevelBar
func (recv *LevelBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LevelBar
func (recv *LevelBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by LevelBar
func (recv *LevelBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// LevelBarAccessible is a wrapper around the C record GtkLevelBarAccessible.
type LevelBarAccessible struct {
	native *C.GtkLevelBarAccessible
	// parent : record
	// priv : record
}

func LevelBarAccessibleNewFromC(u unsafe.Pointer) *LevelBarAccessible {
	c := (*C.GtkLevelBarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LevelBarAccessible{native: c}

	return g
}

func (recv *LevelBarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LevelBarAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *LevelBarAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LevelBarAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to LevelBarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LevelBarAccessible.
func CastToLevelBarAccessible(object *gobject.Object) *LevelBarAccessible {
	return LevelBarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by LevelBarAccessible
func (recv *LevelBarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by LevelBarAccessible
func (recv *LevelBarAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// LinkButton is a wrapper around the C record GtkLinkButton.
type LinkButton struct {
	native *C.GtkLinkButton
	// Private : parent_instance
	// Private : priv
}

func LinkButtonNewFromC(u unsafe.Pointer) *LinkButton {
	c := (*C.GtkLinkButton)(u)
	if c == nil {
		return nil
	}

	g := &LinkButton{native: c}

	return g
}

func (recv *LinkButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *LinkButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *LinkButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *LinkButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *LinkButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LinkButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LinkButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to LinkButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a LinkButton.
func CastToLinkButton(object *gobject.Object) *LinkButton {
	return LinkButtonNewFromC(object.ToC())
}

type signalLinkButtonActivateLinkDetail struct {
	callback  LinkButtonSignalActivateLinkCallback
	handlerID C.gulong
}

var signalLinkButtonActivateLinkId int
var signalLinkButtonActivateLinkMap = make(map[int]signalLinkButtonActivateLinkDetail)
var signalLinkButtonActivateLinkLock sync.Mutex

// LinkButtonSignalActivateLinkCallback is a callback function for a 'activate-link' signal emitted from a LinkButton.
type LinkButtonSignalActivateLinkCallback func() bool

/*
ConnectActivateLink connects the callback to the 'activate-link' signal for the LinkButton.

The returned value represents the connection, and may be passed to DisconnectActivateLink to remove it.
*/
func (recv *LinkButton) ConnectActivateLink(callback LinkButtonSignalActivateLinkCallback) int {
	signalLinkButtonActivateLinkLock.Lock()
	defer signalLinkButtonActivateLinkLock.Unlock()

	signalLinkButtonActivateLinkId++
	instance := C.gpointer(recv.native)
	handlerID := C.LinkButton_signal_connect_activate_link(instance, C.gpointer(uintptr(signalLinkButtonActivateLinkId)))

	detail := signalLinkButtonActivateLinkDetail{callback, handlerID}
	signalLinkButtonActivateLinkMap[signalLinkButtonActivateLinkId] = detail

	return signalLinkButtonActivateLinkId
}

/*
DisconnectActivateLink disconnects a callback from the 'activate-link' signal for the LinkButton.

The connectionID should be a value returned from a call to ConnectActivateLink.
*/
func (recv *LinkButton) DisconnectActivateLink(connectionID int) {
	signalLinkButtonActivateLinkLock.Lock()
	defer signalLinkButtonActivateLinkLock.Unlock()

	detail, exists := signalLinkButtonActivateLinkMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLinkButtonActivateLinkMap, connectionID)
}

//export linkbutton_activateLinkHandler
func linkbutton_activateLinkHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalLinkButtonActivateLinkMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// ImplementorIface returns the ImplementorIface interface implemented by LinkButton
func (recv *LinkButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by LinkButton
func (recv *LinkButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by LinkButton
func (recv *LinkButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LinkButton
func (recv *LinkButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LinkButtonAccessible is a wrapper around the C record GtkLinkButtonAccessible.
type LinkButtonAccessible struct {
	native *C.GtkLinkButtonAccessible
	// parent : record
	// priv : record
}

func LinkButtonAccessibleNewFromC(u unsafe.Pointer) *LinkButtonAccessible {
	c := (*C.GtkLinkButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LinkButtonAccessible{native: c}

	return g
}

func (recv *LinkButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *LinkButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *LinkButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LinkButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *LinkButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LinkButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to LinkButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LinkButtonAccessible.
func CastToLinkButtonAccessible(object *gobject.Object) *LinkButtonAccessible {
	return LinkButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// HyperlinkImpl returns the HyperlinkImpl interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) HyperlinkImpl() *atk.HyperlinkImpl {
	return atk.HyperlinkImplNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ListBox is a wrapper around the C record GtkListBox.
type ListBox struct {
	native *C.GtkListBox
	// parent_instance : record
}

func ListBoxNewFromC(u unsafe.Pointer) *ListBox {
	c := (*C.GtkListBox)(u)
	if c == nil {
		return nil
	}

	g := &ListBox{native: c}

	return g
}

func (recv *ListBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *ListBox) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ListBox) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ListBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ListBox) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to ListBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBox.
func CastToListBox(object *gobject.Object) *ListBox {
	return ListBoxNewFromC(object.ToC())
}

type signalListBoxActivateCursorRowDetail struct {
	callback  ListBoxSignalActivateCursorRowCallback
	handlerID C.gulong
}

var signalListBoxActivateCursorRowId int
var signalListBoxActivateCursorRowMap = make(map[int]signalListBoxActivateCursorRowDetail)
var signalListBoxActivateCursorRowLock sync.Mutex

// ListBoxSignalActivateCursorRowCallback is a callback function for a 'activate-cursor-row' signal emitted from a ListBox.
type ListBoxSignalActivateCursorRowCallback func()

/*
ConnectActivateCursorRow connects the callback to the 'activate-cursor-row' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectActivateCursorRow to remove it.
*/
func (recv *ListBox) ConnectActivateCursorRow(callback ListBoxSignalActivateCursorRowCallback) int {
	signalListBoxActivateCursorRowLock.Lock()
	defer signalListBoxActivateCursorRowLock.Unlock()

	signalListBoxActivateCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_activate_cursor_row(instance, C.gpointer(uintptr(signalListBoxActivateCursorRowId)))

	detail := signalListBoxActivateCursorRowDetail{callback, handlerID}
	signalListBoxActivateCursorRowMap[signalListBoxActivateCursorRowId] = detail

	return signalListBoxActivateCursorRowId
}

/*
DisconnectActivateCursorRow disconnects a callback from the 'activate-cursor-row' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectActivateCursorRow.
*/
func (recv *ListBox) DisconnectActivateCursorRow(connectionID int) {
	signalListBoxActivateCursorRowLock.Lock()
	defer signalListBoxActivateCursorRowLock.Unlock()

	detail, exists := signalListBoxActivateCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxActivateCursorRowMap, connectionID)
}

//export listbox_activateCursorRowHandler
func listbox_activateCursorRowHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalListBoxActivateCursorRowMap[index].callback
	callback()
}

// Unsupported signal 'move-cursor' for ListBox : unsupported parameter object : type MovementStep :

type signalListBoxToggleCursorRowDetail struct {
	callback  ListBoxSignalToggleCursorRowCallback
	handlerID C.gulong
}

var signalListBoxToggleCursorRowId int
var signalListBoxToggleCursorRowMap = make(map[int]signalListBoxToggleCursorRowDetail)
var signalListBoxToggleCursorRowLock sync.Mutex

// ListBoxSignalToggleCursorRowCallback is a callback function for a 'toggle-cursor-row' signal emitted from a ListBox.
type ListBoxSignalToggleCursorRowCallback func()

/*
ConnectToggleCursorRow connects the callback to the 'toggle-cursor-row' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectToggleCursorRow to remove it.
*/
func (recv *ListBox) ConnectToggleCursorRow(callback ListBoxSignalToggleCursorRowCallback) int {
	signalListBoxToggleCursorRowLock.Lock()
	defer signalListBoxToggleCursorRowLock.Unlock()

	signalListBoxToggleCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_toggle_cursor_row(instance, C.gpointer(uintptr(signalListBoxToggleCursorRowId)))

	detail := signalListBoxToggleCursorRowDetail{callback, handlerID}
	signalListBoxToggleCursorRowMap[signalListBoxToggleCursorRowId] = detail

	return signalListBoxToggleCursorRowId
}

/*
DisconnectToggleCursorRow disconnects a callback from the 'toggle-cursor-row' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectToggleCursorRow.
*/
func (recv *ListBox) DisconnectToggleCursorRow(connectionID int) {
	signalListBoxToggleCursorRowLock.Lock()
	defer signalListBoxToggleCursorRowLock.Unlock()

	detail, exists := signalListBoxToggleCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxToggleCursorRowMap, connectionID)
}

//export listbox_toggleCursorRowHandler
func listbox_toggleCursorRowHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalListBoxToggleCursorRowMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ListBox
func (recv *ListBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ListBox
func (recv *ListBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ListBoxAccessible is a wrapper around the C record GtkListBoxAccessible.
type ListBoxAccessible struct {
	native *C.GtkListBoxAccessible
	// parent : record
	// priv : record
}

func ListBoxAccessibleNewFromC(u unsafe.Pointer) *ListBoxAccessible {
	c := (*C.GtkListBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxAccessible{native: c}

	return g
}

func (recv *ListBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ListBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ListBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ListBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ListBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ListBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxAccessible.
func CastToListBoxAccessible(object *gobject.Object) *ListBoxAccessible {
	return ListBoxAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ListBoxAccessible
func (recv *ListBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by ListBoxAccessible
func (recv *ListBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// ListBoxRow is a wrapper around the C record GtkListBoxRow.
type ListBoxRow struct {
	native *C.GtkListBoxRow
	// parent_instance : record
}

func ListBoxRowNewFromC(u unsafe.Pointer) *ListBoxRow {
	c := (*C.GtkListBoxRow)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRow{native: c}

	return g
}

func (recv *ListBoxRow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ListBoxRow) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ListBoxRow) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ListBoxRow) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ListBoxRow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ListBoxRow) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ListBoxRow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxRow.
func CastToListBoxRow(object *gobject.Object) *ListBoxRow {
	return ListBoxRowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ListBoxRow
func (recv *ListBoxRow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ListBoxRow
func (recv *ListBoxRow) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ListBoxRow
func (recv *ListBoxRow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ListBoxRowAccessible is a wrapper around the C record GtkListBoxRowAccessible.
type ListBoxRowAccessible struct {
	native *C.GtkListBoxRowAccessible
	// parent : record
}

func ListBoxRowAccessibleNewFromC(u unsafe.Pointer) *ListBoxRowAccessible {
	c := (*C.GtkListBoxRowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRowAccessible{native: c}

	return g
}

func (recv *ListBoxRowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ListBoxRowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ListBoxRowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ListBoxRowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ListBoxRowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ListBoxRowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxRowAccessible.
func CastToListBoxRowAccessible(object *gobject.Object) *ListBoxRowAccessible {
	return ListBoxRowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ListBoxRowAccessible
func (recv *ListBoxRowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// ListStore is a wrapper around the C record GtkListStore.
type ListStore struct {
	native *C.GtkListStore
	// parent : record
	// Private : priv
}

func ListStoreNewFromC(u unsafe.Pointer) *ListStore {
	c := (*C.GtkListStore)(u)
	if c == nil {
		return nil
	}

	g := &ListStore{native: c}

	return g
}

func (recv *ListStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *ListStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to ListStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListStore.
func CastToListStore(object *gobject.Object) *ListStore {
	return ListStoreNewFromC(object.ToC())
}

// Unsupported : gtk_list_store_new : unsupported parameter ... : varargs

// Non-vararg creation function.  Used primarily by language bindings.
/*

C function : gtk_list_store_newv
*/
func ListStoreNewv(types []gobject.Type) *ListStore {
	c_n_columns := (C.gint)(len(types))

	c_types := &types[0]

	retC := C.gtk_list_store_newv(c_n_columns, (*C.GType)(unsafe.Pointer(c_types)))
	retGo := ListStoreNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Appends a new row to @list_store.  @iter will be changed to point to this new
// row.  The row will be empty after this function is called.  To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_append
*/
func (recv *ListStore) Append() *TreeIter {
	var c_iter C.GtkTreeIter

	C.gtk_list_store_append((*C.GtkListStore)(recv.native), &c_iter)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Removes all rows from the list store.
/*

C function : gtk_list_store_clear
*/
func (recv *ListStore) Clear() {
	C.gtk_list_store_clear((*C.GtkListStore)(recv.native))

	return
}

// Creates a new row at @position.  @iter will be changed to point to this new
// row.  If @position is -1 or is larger than the number of rows on the list,
// then the new row will be appended to the list. The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_insert
*/
func (recv *ListStore) Insert(position int32) *TreeIter {
	var c_iter C.GtkTreeIter

	c_position := (C.gint)(position)

	C.gtk_list_store_insert((*C.GtkListStore)(recv.native), &c_iter, c_position)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Inserts a new row after @sibling. If @sibling is %NULL, then the row will be
// prepended to the beginning of the list. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill
// in values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_insert_after
*/
func (recv *ListStore) InsertAfter(sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_list_store_insert_after((*C.GtkListStore)(recv.native), &c_iter, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Inserts a new row before @sibling. If @sibling is %NULL, then the row will
// be appended to the end of the list. @iter will be changed to point to this
// new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_insert_before
*/
func (recv *ListStore) InsertBefore(sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_list_store_insert_before((*C.GtkListStore)(recv.native), &c_iter, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Prepends a new row to @list_store. @iter will be changed to point to this new
// row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
/*

C function : gtk_list_store_prepend
*/
func (recv *ListStore) Prepend() *TreeIter {
	var c_iter C.GtkTreeIter

	C.gtk_list_store_prepend((*C.GtkListStore)(recv.native), &c_iter)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Removes the given row from the list store.  After being removed,
// @iter is set to be the next valid row, or invalidated if it pointed
// to the last row in @list_store.
/*

C function : gtk_list_store_remove
*/
func (recv *ListStore) Remove(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_list_store_remove((*C.GtkListStore)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_list_store_set : unsupported parameter ... : varargs

// This function is meant primarily for #GObjects that inherit from #GtkListStore,
// and should only be used when constructing a new #GtkListStore.  It will not
// function after a row has been added, or a method on the #GtkTreeModel
// interface is called.
/*

C function : gtk_list_store_set_column_types
*/
func (recv *ListStore) SetColumnTypes(types []gobject.Type) {
	c_n_columns := (C.gint)(len(types))

	c_types := &types[0]

	C.gtk_list_store_set_column_types((*C.GtkListStore)(recv.native), c_n_columns, (*C.GType)(unsafe.Pointer(c_types)))

	return
}

// Unsupported : gtk_list_store_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Sets the data in the cell specified by @iter and @column.
// The type of @value must be convertible to the type of the
// column.
/*

C function : gtk_list_store_set_value
*/
func (recv *ListStore) SetValue(iter *TreeIter, column int32, value *gobject.Value) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_column := (C.gint)(column)

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_list_store_set_value((*C.GtkListStore)(recv.native), c_iter, c_column, c_value)

	return
}

// Buildable returns the Buildable interface implemented by ListStore
func (recv *ListStore) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TreeDragDest returns the TreeDragDest interface implemented by ListStore
func (recv *ListStore) TreeDragDest() *TreeDragDest {
	return TreeDragDestNewFromC(recv.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by ListStore
func (recv *ListStore) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by ListStore
func (recv *ListStore) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by ListStore
func (recv *ListStore) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// LockButton is a wrapper around the C record GtkLockButton.
type LockButton struct {
	native *C.GtkLockButton
	// parent : record
	// priv : record
}

func LockButtonNewFromC(u unsafe.Pointer) *LockButton {
	c := (*C.GtkLockButton)(u)
	if c == nil {
		return nil
	}

	g := &LockButton{native: c}

	return g
}

func (recv *LockButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *LockButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *LockButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *LockButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *LockButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LockButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LockButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to LockButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a LockButton.
func CastToLockButton(object *gobject.Object) *LockButton {
	return LockButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by LockButton
func (recv *LockButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by LockButton
func (recv *LockButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by LockButton
func (recv *LockButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LockButton
func (recv *LockButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LockButtonAccessible is a wrapper around the C record GtkLockButtonAccessible.
type LockButtonAccessible struct {
	native *C.GtkLockButtonAccessible
	// parent : record
	// priv : record
}

func LockButtonAccessibleNewFromC(u unsafe.Pointer) *LockButtonAccessible {
	c := (*C.GtkLockButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LockButtonAccessible{native: c}

	return g
}

func (recv *LockButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *LockButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *LockButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LockButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *LockButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LockButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to LockButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LockButtonAccessible.
func CastToLockButtonAccessible(object *gobject.Object) *LockButtonAccessible {
	return LockButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Menu is a wrapper around the C record GtkMenu.
type Menu struct {
	native *C.GtkMenu
	// menu_shell : record
	// Private : priv
}

func MenuNewFromC(u unsafe.Pointer) *Menu {
	c := (*C.GtkMenu)(u)
	if c == nil {
		return nil
	}

	g := &Menu{native: c}

	return g
}

func (recv *Menu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuShell upcasts to *MenuShell
func (recv *Menu) MenuShell() *MenuShell {
	return MenuShellNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Menu) Container() *Container {
	return recv.MenuShell().Container()
}

// Widget upcasts to *Widget
func (recv *Menu) Widget() *Widget {
	return recv.MenuShell().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Menu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuShell().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Menu) Object() *gobject.Object {
	return recv.MenuShell().Object()
}

// CastToWidget down casts any arbitary Object to Menu.
// Exercise care, as this is a potentially dangerous function if the Object is not a Menu.
func CastToMenu(object *gobject.Object) *Menu {
	return MenuNewFromC(object.ToC())
}

// Unsupported signal 'move-scroll' for Menu : unsupported parameter scroll_type : type ScrollType :

// Creates a new #GtkMenu
/*

C function : gtk_menu_new
*/
func MenuNew() *Menu {
	retC := C.gtk_menu_new()
	retGo := MenuNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_menu_attach_to_widget : unsupported parameter detacher : no type generator for MenuDetachFunc (GtkMenuDetachFunc) for param detacher

// Detaches the menu from the widget to which it had been attached.
// This function will call the callback function, @detacher, provided
// when the gtk_menu_attach_to_widget() function was called.
/*

C function : gtk_menu_detach
*/
func (recv *Menu) Detach() {
	C.gtk_menu_detach((*C.GtkMenu)(recv.native))

	return
}

// Gets the #GtkAccelGroup which holds global accelerators for the
// menu. See gtk_menu_set_accel_group().
/*

C function : gtk_menu_get_accel_group
*/
func (recv *Menu) GetAccelGroup() *AccelGroup {
	retC := C.gtk_menu_get_accel_group((*C.GtkMenu)(recv.native))
	retGo := AccelGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the selected menu item from the menu.  This is used by the
// #GtkComboBox.
/*

C function : gtk_menu_get_active
*/
func (recv *Menu) GetActive() *Widget {
	retC := C.gtk_menu_get_active((*C.GtkMenu)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the #GtkWidget that the menu is attached to.
/*

C function : gtk_menu_get_attach_widget
*/
func (recv *Menu) GetAttachWidget() *Widget {
	retC := C.gtk_menu_get_attach_widget((*C.GtkMenu)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns whether the menu is torn off.
// See gtk_menu_set_tearoff_state().
/*

C function : gtk_menu_get_tearoff_state
*/
func (recv *Menu) GetTearoffState() bool {
	retC := C.gtk_menu_get_tearoff_state((*C.GtkMenu)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the title of the menu. See gtk_menu_set_title().
/*

C function : gtk_menu_get_title
*/
func (recv *Menu) GetTitle() string {
	retC := C.gtk_menu_get_title((*C.GtkMenu)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Removes the menu from the screen.
/*

C function : gtk_menu_popdown
*/
func (recv *Menu) Popdown() {
	C.gtk_menu_popdown((*C.GtkMenu)(recv.native))

	return
}

// Unsupported : gtk_menu_popup : unsupported parameter func : no type generator for MenuPositionFunc (GtkMenuPositionFunc) for param func

// Moves @child to a new @position in the list of @menu
// children.
/*

C function : gtk_menu_reorder_child
*/
func (recv *Menu) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_menu_reorder_child((*C.GtkMenu)(recv.native), c_child, c_position)

	return
}

// Repositions the menu according to its position function.
/*

C function : gtk_menu_reposition
*/
func (recv *Menu) Reposition() {
	C.gtk_menu_reposition((*C.GtkMenu)(recv.native))

	return
}

// Set the #GtkAccelGroup which holds global accelerators for the
// menu.  This accelerator group needs to also be added to all windows
// that this menu is being used in with gtk_window_add_accel_group(),
// in order for those windows to support all the accelerators
// contained in this group.
/*

C function : gtk_menu_set_accel_group
*/
func (recv *Menu) SetAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_menu_set_accel_group((*C.GtkMenu)(recv.native), c_accel_group)

	return
}

// Sets an accelerator path for this menu from which accelerator paths
// for its immediate children, its menu items, can be constructed.
// The main purpose of this function is to spare the programmer the
// inconvenience of having to call gtk_menu_item_set_accel_path() on
// each menu item that should support runtime user changable accelerators.
// Instead, by just calling gtk_menu_set_accel_path() on their parent,
// each menu item of this menu, that contains a label describing its
// purpose, automatically gets an accel path assigned.
//
// For example, a menu containing menu items “New” and “Exit”, will, after
// `gtk_menu_set_accel_path (menu, "<Gnumeric-Sheet>/File");` has been
// called, assign its items the accel paths: `"<Gnumeric-Sheet>/File/New"`
// and `"<Gnumeric-Sheet>/File/Exit"`.
//
// Assigning accel paths to menu items then enables the user to change
// their accelerators at runtime. More details about accelerator paths
// and their default setups can be found at gtk_accel_map_add_entry().
//
// Note that @accel_path string will be stored in a #GQuark. Therefore,
// if you pass a static string, you can save some memory by interning
// it first with g_intern_static_string().
/*

C function : gtk_menu_set_accel_path
*/
func (recv *Menu) SetAccelPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_menu_set_accel_path((*C.GtkMenu)(recv.native), c_accel_path)

	return
}

// Selects the specified menu item within the menu.  This is used by
// the #GtkComboBox and should not be used by anyone else.
/*

C function : gtk_menu_set_active
*/
func (recv *Menu) SetActive(index uint32) {
	c_index := (C.guint)(index)

	C.gtk_menu_set_active((*C.GtkMenu)(recv.native), c_index)

	return
}

// Changes the tearoff state of the menu.  A menu is normally
// displayed as drop down menu which persists as long as the menu is
// active.  It can also be displayed as a tearoff menu which persists
// until it is closed or reattached.
/*

C function : gtk_menu_set_tearoff_state
*/
func (recv *Menu) SetTearoffState(tornOff bool) {
	c_torn_off :=
		boolToGboolean(tornOff)

	C.gtk_menu_set_tearoff_state((*C.GtkMenu)(recv.native), c_torn_off)

	return
}

// Sets the title string for the menu.
//
// The title is displayed when the menu is shown as a tearoff
// menu. If @title is %NULL, the menu will see if it is attached
// to a parent menu item, and if so it will try to use the same
// text as that menu item’s label.
/*

C function : gtk_menu_set_title
*/
func (recv *Menu) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_menu_set_title((*C.GtkMenu)(recv.native), c_title)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Menu
func (recv *Menu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Menu
func (recv *Menu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuAccessible is a wrapper around the C record GtkMenuAccessible.
type MenuAccessible struct {
	native *C.GtkMenuAccessible
	// parent : record
	// priv : record
}

func MenuAccessibleNewFromC(u unsafe.Pointer) *MenuAccessible {
	c := (*C.GtkMenuAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuAccessible{native: c}

	return g
}

func (recv *MenuAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuShellAccessible upcasts to *MenuShellAccessible
func (recv *MenuAccessible) MenuShellAccessible() *MenuShellAccessible {
	return MenuShellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.MenuShellAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.MenuShellAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuAccessible) Accessible() *Accessible {
	return recv.MenuShellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuAccessible) Object() *atk.Object {
	return recv.MenuShellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to MenuAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuAccessible.
func CastToMenuAccessible(object *gobject.Object) *MenuAccessible {
	return MenuAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by MenuAccessible
func (recv *MenuAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuAccessible
func (recv *MenuAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuBar is a wrapper around the C record GtkMenuBar.
type MenuBar struct {
	native *C.GtkMenuBar
	// menu_shell : record
	// Private : priv
}

func MenuBarNewFromC(u unsafe.Pointer) *MenuBar {
	c := (*C.GtkMenuBar)(u)
	if c == nil {
		return nil
	}

	g := &MenuBar{native: c}

	return g
}

func (recv *MenuBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuShell upcasts to *MenuShell
func (recv *MenuBar) MenuShell() *MenuShell {
	return MenuShellNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *MenuBar) Container() *Container {
	return recv.MenuShell().Container()
}

// Widget upcasts to *Widget
func (recv *MenuBar) Widget() *Widget {
	return recv.MenuShell().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuShell().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuBar) Object() *gobject.Object {
	return recv.MenuShell().Object()
}

// CastToWidget down casts any arbitary Object to MenuBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuBar.
func CastToMenuBar(object *gobject.Object) *MenuBar {
	return MenuBarNewFromC(object.ToC())
}

// Creates a new #GtkMenuBar
/*

C function : gtk_menu_bar_new
*/
func MenuBarNew() *MenuBar {
	retC := C.gtk_menu_bar_new()
	retGo := MenuBarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuBar
func (recv *MenuBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuBar
func (recv *MenuBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuButton is a wrapper around the C record GtkMenuButton.
type MenuButton struct {
	native *C.GtkMenuButton
	// parent : record
	// Private : priv
}

func MenuButtonNewFromC(u unsafe.Pointer) *MenuButton {
	c := (*C.GtkMenuButton)(u)
	if c == nil {
		return nil
	}

	g := &MenuButton{native: c}

	return g
}

func (recv *MenuButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleButton upcasts to *ToggleButton
func (recv *MenuButton) ToggleButton() *ToggleButton {
	return ToggleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *MenuButton) Button() *Button {
	return recv.ToggleButton().Button()
}

// Bin upcasts to *Bin
func (recv *MenuButton) Bin() *Bin {
	return recv.ToggleButton().Bin()
}

// Container upcasts to *Container
func (recv *MenuButton) Container() *Container {
	return recv.ToggleButton().Container()
}

// Widget upcasts to *Widget
func (recv *MenuButton) Widget() *Widget {
	return recv.ToggleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuButton) Object() *gobject.Object {
	return recv.ToggleButton().Object()
}

// CastToWidget down casts any arbitary Object to MenuButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuButton.
func CastToMenuButton(object *gobject.Object) *MenuButton {
	return MenuButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuButton
func (recv *MenuButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuButton
func (recv *MenuButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuButton
func (recv *MenuButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuButton
func (recv *MenuButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuButtonAccessible is a wrapper around the C record GtkMenuButtonAccessible.
type MenuButtonAccessible struct {
	native *C.GtkMenuButtonAccessible
	// parent : record
	// priv : record
}

func MenuButtonAccessibleNewFromC(u unsafe.Pointer) *MenuButtonAccessible {
	c := (*C.GtkMenuButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuButtonAccessible{native: c}

	return g
}

func (recv *MenuButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleButtonAccessible upcasts to *ToggleButtonAccessible
func (recv *MenuButtonAccessible) ToggleButtonAccessible() *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *MenuButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return recv.ToggleButtonAccessible().ButtonAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ToggleButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ToggleButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuButtonAccessible) Accessible() *Accessible {
	return recv.ToggleButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuButtonAccessible) Object() *atk.Object {
	return recv.ToggleButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to MenuButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuButtonAccessible.
func CastToMenuButtonAccessible(object *gobject.Object) *MenuButtonAccessible {
	return MenuButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// MenuItem is a wrapper around the C record GtkMenuItem.
type MenuItem struct {
	native *C.GtkMenuItem
	// bin : record
	// Private : priv
}

func MenuItemNewFromC(u unsafe.Pointer) *MenuItem {
	c := (*C.GtkMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &MenuItem{native: c}

	return g
}

func (recv *MenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *MenuItem) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *MenuItem) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *MenuItem) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuItem) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to MenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItem.
func CastToMenuItem(object *gobject.Object) *MenuItem {
	return MenuItemNewFromC(object.ToC())
}

type signalMenuItemActivateDetail struct {
	callback  MenuItemSignalActivateCallback
	handlerID C.gulong
}

var signalMenuItemActivateId int
var signalMenuItemActivateMap = make(map[int]signalMenuItemActivateDetail)
var signalMenuItemActivateLock sync.Mutex

// MenuItemSignalActivateCallback is a callback function for a 'activate' signal emitted from a MenuItem.
type MenuItemSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *MenuItem) ConnectActivate(callback MenuItemSignalActivateCallback) int {
	signalMenuItemActivateLock.Lock()
	defer signalMenuItemActivateLock.Unlock()

	signalMenuItemActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_activate(instance, C.gpointer(uintptr(signalMenuItemActivateId)))

	detail := signalMenuItemActivateDetail{callback, handlerID}
	signalMenuItemActivateMap[signalMenuItemActivateId] = detail

	return signalMenuItemActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *MenuItem) DisconnectActivate(connectionID int) {
	signalMenuItemActivateLock.Lock()
	defer signalMenuItemActivateLock.Unlock()

	detail, exists := signalMenuItemActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemActivateMap, connectionID)
}

//export menuitem_activateHandler
func menuitem_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuItemActivateMap[index].callback
	callback()
}

type signalMenuItemActivateItemDetail struct {
	callback  MenuItemSignalActivateItemCallback
	handlerID C.gulong
}

var signalMenuItemActivateItemId int
var signalMenuItemActivateItemMap = make(map[int]signalMenuItemActivateItemDetail)
var signalMenuItemActivateItemLock sync.Mutex

// MenuItemSignalActivateItemCallback is a callback function for a 'activate-item' signal emitted from a MenuItem.
type MenuItemSignalActivateItemCallback func()

/*
ConnectActivateItem connects the callback to the 'activate-item' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectActivateItem to remove it.
*/
func (recv *MenuItem) ConnectActivateItem(callback MenuItemSignalActivateItemCallback) int {
	signalMenuItemActivateItemLock.Lock()
	defer signalMenuItemActivateItemLock.Unlock()

	signalMenuItemActivateItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_activate_item(instance, C.gpointer(uintptr(signalMenuItemActivateItemId)))

	detail := signalMenuItemActivateItemDetail{callback, handlerID}
	signalMenuItemActivateItemMap[signalMenuItemActivateItemId] = detail

	return signalMenuItemActivateItemId
}

/*
DisconnectActivateItem disconnects a callback from the 'activate-item' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectActivateItem.
*/
func (recv *MenuItem) DisconnectActivateItem(connectionID int) {
	signalMenuItemActivateItemLock.Lock()
	defer signalMenuItemActivateItemLock.Unlock()

	detail, exists := signalMenuItemActivateItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemActivateItemMap, connectionID)
}

//export menuitem_activateItemHandler
func menuitem_activateItemHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuItemActivateItemMap[index].callback
	callback()
}

type signalMenuItemDeselectDetail struct {
	callback  MenuItemSignalDeselectCallback
	handlerID C.gulong
}

var signalMenuItemDeselectId int
var signalMenuItemDeselectMap = make(map[int]signalMenuItemDeselectDetail)
var signalMenuItemDeselectLock sync.Mutex

// MenuItemSignalDeselectCallback is a callback function for a 'deselect' signal emitted from a MenuItem.
type MenuItemSignalDeselectCallback func()

/*
ConnectDeselect connects the callback to the 'deselect' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectDeselect to remove it.
*/
func (recv *MenuItem) ConnectDeselect(callback MenuItemSignalDeselectCallback) int {
	signalMenuItemDeselectLock.Lock()
	defer signalMenuItemDeselectLock.Unlock()

	signalMenuItemDeselectId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_deselect(instance, C.gpointer(uintptr(signalMenuItemDeselectId)))

	detail := signalMenuItemDeselectDetail{callback, handlerID}
	signalMenuItemDeselectMap[signalMenuItemDeselectId] = detail

	return signalMenuItemDeselectId
}

/*
DisconnectDeselect disconnects a callback from the 'deselect' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectDeselect.
*/
func (recv *MenuItem) DisconnectDeselect(connectionID int) {
	signalMenuItemDeselectLock.Lock()
	defer signalMenuItemDeselectLock.Unlock()

	detail, exists := signalMenuItemDeselectMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemDeselectMap, connectionID)
}

//export menuitem_deselectHandler
func menuitem_deselectHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuItemDeselectMap[index].callback
	callback()
}

type signalMenuItemSelectDetail struct {
	callback  MenuItemSignalSelectCallback
	handlerID C.gulong
}

var signalMenuItemSelectId int
var signalMenuItemSelectMap = make(map[int]signalMenuItemSelectDetail)
var signalMenuItemSelectLock sync.Mutex

// MenuItemSignalSelectCallback is a callback function for a 'select' signal emitted from a MenuItem.
type MenuItemSignalSelectCallback func()

/*
ConnectSelect connects the callback to the 'select' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectSelect to remove it.
*/
func (recv *MenuItem) ConnectSelect(callback MenuItemSignalSelectCallback) int {
	signalMenuItemSelectLock.Lock()
	defer signalMenuItemSelectLock.Unlock()

	signalMenuItemSelectId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_select(instance, C.gpointer(uintptr(signalMenuItemSelectId)))

	detail := signalMenuItemSelectDetail{callback, handlerID}
	signalMenuItemSelectMap[signalMenuItemSelectId] = detail

	return signalMenuItemSelectId
}

/*
DisconnectSelect disconnects a callback from the 'select' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectSelect.
*/
func (recv *MenuItem) DisconnectSelect(connectionID int) {
	signalMenuItemSelectLock.Lock()
	defer signalMenuItemSelectLock.Unlock()

	detail, exists := signalMenuItemSelectMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemSelectMap, connectionID)
}

//export menuitem_selectHandler
func menuitem_selectHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuItemSelectMap[index].callback
	callback()
}

// Unsupported signal 'toggle-size-allocate' for MenuItem : unsupported parameter object : type gint :

// Unsupported signal 'toggle-size-request' for MenuItem : unsupported parameter object : type gpointer :

// Creates a new #GtkMenuItem.
/*

C function : gtk_menu_item_new
*/
func MenuItemNew() *MenuItem {
	retC := C.gtk_menu_item_new()
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkMenuItem whose child is a #GtkLabel.
/*

C function : gtk_menu_item_new_with_label
*/
func MenuItemNewWithLabel(label string) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_menu_item_new_with_label(c_label)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkMenuItem containing a label.
//
// The label will be created using gtk_label_new_with_mnemonic(),
// so underscores in @label indicate the mnemonic for the menu item.
/*

C function : gtk_menu_item_new_with_mnemonic
*/
func MenuItemNewWithMnemonic(label string) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_menu_item_new_with_mnemonic(c_label)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Emits the #GtkMenuItem::activate signal on the given item
/*

C function : gtk_menu_item_activate
*/
func (recv *MenuItem) Activate() {
	C.gtk_menu_item_activate((*C.GtkMenuItem)(recv.native))

	return
}

// Emits the #GtkMenuItem::deselect signal on the given item.
/*

C function : gtk_menu_item_deselect
*/
func (recv *MenuItem) Deselect() {
	C.gtk_menu_item_deselect((*C.GtkMenuItem)(recv.native))

	return
}

// Gets whether the menu item appears justified at the right
// side of the menu bar.
/*

C function : gtk_menu_item_get_right_justified
*/
func (recv *MenuItem) GetRightJustified() bool {
	retC := C.gtk_menu_item_get_right_justified((*C.GtkMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the submenu underneath this menu item, if any.
// See gtk_menu_item_set_submenu().
/*

C function : gtk_menu_item_get_submenu
*/
func (recv *MenuItem) GetSubmenu() *Widget {
	retC := C.gtk_menu_item_get_submenu((*C.GtkMenuItem)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Emits the #GtkMenuItem::select signal on the given item.
/*

C function : gtk_menu_item_select
*/
func (recv *MenuItem) Select() {
	C.gtk_menu_item_select((*C.GtkMenuItem)(recv.native))

	return
}

// Set the accelerator path on @menu_item, through which runtime
// changes of the menu item’s accelerator caused by the user can be
// identified and saved to persistent storage (see gtk_accel_map_save()
// on this). To set up a default accelerator for this menu item, call
// gtk_accel_map_add_entry() with the same @accel_path. See also
// gtk_accel_map_add_entry() on the specifics of accelerator paths,
// and gtk_menu_set_accel_path() for a more convenient variant of
// this function.
//
// This function is basically a convenience wrapper that handles
// calling gtk_widget_set_accel_path() with the appropriate accelerator
// group for the menu item.
//
// Note that you do need to set an accelerator on the parent menu with
// gtk_menu_set_accel_group() for this to work.
//
// Note that @accel_path string will be stored in a #GQuark.
// Therefore, if you pass a static string, you can save some memory
// by interning it first with g_intern_static_string().
/*

C function : gtk_menu_item_set_accel_path
*/
func (recv *MenuItem) SetAccelPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_menu_item_set_accel_path((*C.GtkMenuItem)(recv.native), c_accel_path)

	return
}

// Sets whether the menu item appears justified at the right
// side of a menu bar. This was traditionally done for “Help”
// menu items, but is now considered a bad idea. (If the widget
// layout is reversed for a right-to-left language like Hebrew
// or Arabic, right-justified-menu-items appear at the left.)
/*

C function : gtk_menu_item_set_right_justified
*/
func (recv *MenuItem) SetRightJustified(rightJustified bool) {
	c_right_justified :=
		boolToGboolean(rightJustified)

	C.gtk_menu_item_set_right_justified((*C.GtkMenuItem)(recv.native), c_right_justified)

	return
}

// Sets or replaces the menu item’s submenu, or removes it when a %NULL
// submenu is passed.
/*

C function : gtk_menu_item_set_submenu
*/
func (recv *MenuItem) SetSubmenu(submenu *Menu) {
	c_submenu := (*C.GtkWidget)(C.NULL)
	if submenu != nil {
		c_submenu = (*C.GtkWidget)(submenu.ToC())
	}

	C.gtk_menu_item_set_submenu((*C.GtkMenuItem)(recv.native), c_submenu)

	return
}

// Emits the #GtkMenuItem::toggle-size-allocate signal on the given item.
/*

C function : gtk_menu_item_toggle_size_allocate
*/
func (recv *MenuItem) ToggleSizeAllocate(allocation int32) {
	c_allocation := (C.gint)(allocation)

	C.gtk_menu_item_toggle_size_allocate((*C.GtkMenuItem)(recv.native), c_allocation)

	return
}

// Emits the #GtkMenuItem::toggle-size-request signal on the given item.
/*

C function : gtk_menu_item_toggle_size_request
*/
func (recv *MenuItem) ToggleSizeRequest(requisition int32) {
	c_requisition := (C.gint)(requisition)

	C.gtk_menu_item_toggle_size_request((*C.GtkMenuItem)(recv.native), &c_requisition)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuItem
func (recv *MenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuItem
func (recv *MenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuItem
func (recv *MenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuItem
func (recv *MenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuItemAccessible is a wrapper around the C record GtkMenuItemAccessible.
type MenuItemAccessible struct {
	native *C.GtkMenuItemAccessible
	// parent : record
	// priv : record
}

func MenuItemAccessibleNewFromC(u unsafe.Pointer) *MenuItemAccessible {
	c := (*C.GtkMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuItemAccessible{native: c}

	return g
}

func (recv *MenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuItemAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuItemAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to MenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItemAccessible.
func CastToMenuItemAccessible(object *gobject.Object) *MenuItemAccessible {
	return MenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuShell is a wrapper around the C record GtkMenuShell.
type MenuShell struct {
	native *C.GtkMenuShell
	// container : record
	// Private : priv
}

func MenuShellNewFromC(u unsafe.Pointer) *MenuShell {
	c := (*C.GtkMenuShell)(u)
	if c == nil {
		return nil
	}

	g := &MenuShell{native: c}

	return g
}

func (recv *MenuShell) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *MenuShell) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *MenuShell) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuShell) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuShell) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to MenuShell.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuShell.
func CastToMenuShell(object *gobject.Object) *MenuShell {
	return MenuShellNewFromC(object.ToC())
}

type signalMenuShellActivateCurrentDetail struct {
	callback  MenuShellSignalActivateCurrentCallback
	handlerID C.gulong
}

var signalMenuShellActivateCurrentId int
var signalMenuShellActivateCurrentMap = make(map[int]signalMenuShellActivateCurrentDetail)
var signalMenuShellActivateCurrentLock sync.Mutex

// MenuShellSignalActivateCurrentCallback is a callback function for a 'activate-current' signal emitted from a MenuShell.
type MenuShellSignalActivateCurrentCallback func(forceHide bool)

/*
ConnectActivateCurrent connects the callback to the 'activate-current' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectActivateCurrent to remove it.
*/
func (recv *MenuShell) ConnectActivateCurrent(callback MenuShellSignalActivateCurrentCallback) int {
	signalMenuShellActivateCurrentLock.Lock()
	defer signalMenuShellActivateCurrentLock.Unlock()

	signalMenuShellActivateCurrentId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_activate_current(instance, C.gpointer(uintptr(signalMenuShellActivateCurrentId)))

	detail := signalMenuShellActivateCurrentDetail{callback, handlerID}
	signalMenuShellActivateCurrentMap[signalMenuShellActivateCurrentId] = detail

	return signalMenuShellActivateCurrentId
}

/*
DisconnectActivateCurrent disconnects a callback from the 'activate-current' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectActivateCurrent.
*/
func (recv *MenuShell) DisconnectActivateCurrent(connectionID int) {
	signalMenuShellActivateCurrentLock.Lock()
	defer signalMenuShellActivateCurrentLock.Unlock()

	detail, exists := signalMenuShellActivateCurrentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellActivateCurrentMap, connectionID)
}

//export menushell_activateCurrentHandler
func menushell_activateCurrentHandler(_ *C.GObject, c_force_hide C.gboolean, data C.gpointer) {
	forceHide := c_force_hide == C.TRUE

	index := int(uintptr(data))
	callback := signalMenuShellActivateCurrentMap[index].callback
	callback(forceHide)
}

type signalMenuShellCancelDetail struct {
	callback  MenuShellSignalCancelCallback
	handlerID C.gulong
}

var signalMenuShellCancelId int
var signalMenuShellCancelMap = make(map[int]signalMenuShellCancelDetail)
var signalMenuShellCancelLock sync.Mutex

// MenuShellSignalCancelCallback is a callback function for a 'cancel' signal emitted from a MenuShell.
type MenuShellSignalCancelCallback func()

/*
ConnectCancel connects the callback to the 'cancel' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectCancel to remove it.
*/
func (recv *MenuShell) ConnectCancel(callback MenuShellSignalCancelCallback) int {
	signalMenuShellCancelLock.Lock()
	defer signalMenuShellCancelLock.Unlock()

	signalMenuShellCancelId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_cancel(instance, C.gpointer(uintptr(signalMenuShellCancelId)))

	detail := signalMenuShellCancelDetail{callback, handlerID}
	signalMenuShellCancelMap[signalMenuShellCancelId] = detail

	return signalMenuShellCancelId
}

/*
DisconnectCancel disconnects a callback from the 'cancel' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectCancel.
*/
func (recv *MenuShell) DisconnectCancel(connectionID int) {
	signalMenuShellCancelLock.Lock()
	defer signalMenuShellCancelLock.Unlock()

	detail, exists := signalMenuShellCancelMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellCancelMap, connectionID)
}

//export menushell_cancelHandler
func menushell_cancelHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuShellCancelMap[index].callback
	callback()
}

// Unsupported signal 'cycle-focus' for MenuShell : unsupported parameter direction : type DirectionType :

type signalMenuShellDeactivateDetail struct {
	callback  MenuShellSignalDeactivateCallback
	handlerID C.gulong
}

var signalMenuShellDeactivateId int
var signalMenuShellDeactivateMap = make(map[int]signalMenuShellDeactivateDetail)
var signalMenuShellDeactivateLock sync.Mutex

// MenuShellSignalDeactivateCallback is a callback function for a 'deactivate' signal emitted from a MenuShell.
type MenuShellSignalDeactivateCallback func()

/*
ConnectDeactivate connects the callback to the 'deactivate' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectDeactivate to remove it.
*/
func (recv *MenuShell) ConnectDeactivate(callback MenuShellSignalDeactivateCallback) int {
	signalMenuShellDeactivateLock.Lock()
	defer signalMenuShellDeactivateLock.Unlock()

	signalMenuShellDeactivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_deactivate(instance, C.gpointer(uintptr(signalMenuShellDeactivateId)))

	detail := signalMenuShellDeactivateDetail{callback, handlerID}
	signalMenuShellDeactivateMap[signalMenuShellDeactivateId] = detail

	return signalMenuShellDeactivateId
}

/*
DisconnectDeactivate disconnects a callback from the 'deactivate' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectDeactivate.
*/
func (recv *MenuShell) DisconnectDeactivate(connectionID int) {
	signalMenuShellDeactivateLock.Lock()
	defer signalMenuShellDeactivateLock.Unlock()

	detail, exists := signalMenuShellDeactivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellDeactivateMap, connectionID)
}

//export menushell_deactivateHandler
func menushell_deactivateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuShellDeactivateMap[index].callback
	callback()
}

// Unsupported signal 'move-current' for MenuShell : unsupported parameter direction : type MenuDirectionType :

type signalMenuShellSelectionDoneDetail struct {
	callback  MenuShellSignalSelectionDoneCallback
	handlerID C.gulong
}

var signalMenuShellSelectionDoneId int
var signalMenuShellSelectionDoneMap = make(map[int]signalMenuShellSelectionDoneDetail)
var signalMenuShellSelectionDoneLock sync.Mutex

// MenuShellSignalSelectionDoneCallback is a callback function for a 'selection-done' signal emitted from a MenuShell.
type MenuShellSignalSelectionDoneCallback func()

/*
ConnectSelectionDone connects the callback to the 'selection-done' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectSelectionDone to remove it.
*/
func (recv *MenuShell) ConnectSelectionDone(callback MenuShellSignalSelectionDoneCallback) int {
	signalMenuShellSelectionDoneLock.Lock()
	defer signalMenuShellSelectionDoneLock.Unlock()

	signalMenuShellSelectionDoneId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_selection_done(instance, C.gpointer(uintptr(signalMenuShellSelectionDoneId)))

	detail := signalMenuShellSelectionDoneDetail{callback, handlerID}
	signalMenuShellSelectionDoneMap[signalMenuShellSelectionDoneId] = detail

	return signalMenuShellSelectionDoneId
}

/*
DisconnectSelectionDone disconnects a callback from the 'selection-done' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectSelectionDone.
*/
func (recv *MenuShell) DisconnectSelectionDone(connectionID int) {
	signalMenuShellSelectionDoneLock.Lock()
	defer signalMenuShellSelectionDoneLock.Unlock()

	detail, exists := signalMenuShellSelectionDoneMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellSelectionDoneMap, connectionID)
}

//export menushell_selectionDoneHandler
func menushell_selectionDoneHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuShellSelectionDoneMap[index].callback
	callback()
}

// Activates the menu item within the menu shell.
/*

C function : gtk_menu_shell_activate_item
*/
func (recv *MenuShell) ActivateItem(menuItem *Widget, forceDeactivate bool) {
	c_menu_item := (*C.GtkWidget)(C.NULL)
	if menuItem != nil {
		c_menu_item = (*C.GtkWidget)(menuItem.ToC())
	}

	c_force_deactivate :=
		boolToGboolean(forceDeactivate)

	C.gtk_menu_shell_activate_item((*C.GtkMenuShell)(recv.native), c_menu_item, c_force_deactivate)

	return
}

// Adds a new #GtkMenuItem to the end of the menu shell's
// item list.
/*

C function : gtk_menu_shell_append
*/
func (recv *MenuShell) Append(child *MenuItem) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_menu_shell_append((*C.GtkMenuShell)(recv.native), c_child)

	return
}

// Deactivates the menu shell.
//
// Typically this results in the menu shell being erased
// from the screen.
/*

C function : gtk_menu_shell_deactivate
*/
func (recv *MenuShell) Deactivate() {
	C.gtk_menu_shell_deactivate((*C.GtkMenuShell)(recv.native))

	return
}

// Deselects the currently selected item from the menu shell,
// if any.
/*

C function : gtk_menu_shell_deselect
*/
func (recv *MenuShell) Deselect() {
	C.gtk_menu_shell_deselect((*C.GtkMenuShell)(recv.native))

	return
}

// Adds a new #GtkMenuItem to the menu shell’s item list
// at the position indicated by @position.
/*

C function : gtk_menu_shell_insert
*/
func (recv *MenuShell) Insert(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_menu_shell_insert((*C.GtkMenuShell)(recv.native), c_child, c_position)

	return
}

// Adds a new #GtkMenuItem to the beginning of the menu shell's
// item list.
/*

C function : gtk_menu_shell_prepend
*/
func (recv *MenuShell) Prepend(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_menu_shell_prepend((*C.GtkMenuShell)(recv.native), c_child)

	return
}

// Selects the menu item from the menu shell.
/*

C function : gtk_menu_shell_select_item
*/
func (recv *MenuShell) SelectItem(menuItem *Widget) {
	c_menu_item := (*C.GtkWidget)(C.NULL)
	if menuItem != nil {
		c_menu_item = (*C.GtkWidget)(menuItem.ToC())
	}

	C.gtk_menu_shell_select_item((*C.GtkMenuShell)(recv.native), c_menu_item)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuShell
func (recv *MenuShell) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuShell
func (recv *MenuShell) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuShellAccessible is a wrapper around the C record GtkMenuShellAccessible.
type MenuShellAccessible struct {
	native *C.GtkMenuShellAccessible
	// parent : record
	// priv : record
}

func MenuShellAccessibleNewFromC(u unsafe.Pointer) *MenuShellAccessible {
	c := (*C.GtkMenuShellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuShellAccessible{native: c}

	return g
}

func (recv *MenuShellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuShellAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuShellAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuShellAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuShellAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to MenuShellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuShellAccessible.
func CastToMenuShellAccessible(object *gobject.Object) *MenuShellAccessible {
	return MenuShellAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by MenuShellAccessible
func (recv *MenuShellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuShellAccessible
func (recv *MenuShellAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuToolButton is a wrapper around the C record GtkMenuToolButton.
type MenuToolButton struct {
	native *C.GtkMenuToolButton
	// parent : record
	// Private : priv
}

func MenuToolButtonNewFromC(u unsafe.Pointer) *MenuToolButton {
	c := (*C.GtkMenuToolButton)(u)
	if c == nil {
		return nil
	}

	g := &MenuToolButton{native: c}

	return g
}

func (recv *MenuToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToolButton upcasts to *ToolButton
func (recv *MenuToolButton) ToolButton() *ToolButton {
	return ToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolItem upcasts to *ToolItem
func (recv *MenuToolButton) ToolItem() *ToolItem {
	return recv.ToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *MenuToolButton) Bin() *Bin {
	return recv.ToolButton().Bin()
}

// Container upcasts to *Container
func (recv *MenuToolButton) Container() *Container {
	return recv.ToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *MenuToolButton) Widget() *Widget {
	return recv.ToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuToolButton) Object() *gobject.Object {
	return recv.ToolButton().Object()
}

// CastToWidget down casts any arbitary Object to MenuToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuToolButton.
func CastToMenuToolButton(object *gobject.Object) *MenuToolButton {
	return MenuToolButtonNewFromC(object.ToC())
}

type signalMenuToolButtonShowMenuDetail struct {
	callback  MenuToolButtonSignalShowMenuCallback
	handlerID C.gulong
}

var signalMenuToolButtonShowMenuId int
var signalMenuToolButtonShowMenuMap = make(map[int]signalMenuToolButtonShowMenuDetail)
var signalMenuToolButtonShowMenuLock sync.Mutex

// MenuToolButtonSignalShowMenuCallback is a callback function for a 'show-menu' signal emitted from a MenuToolButton.
type MenuToolButtonSignalShowMenuCallback func()

/*
ConnectShowMenu connects the callback to the 'show-menu' signal for the MenuToolButton.

The returned value represents the connection, and may be passed to DisconnectShowMenu to remove it.
*/
func (recv *MenuToolButton) ConnectShowMenu(callback MenuToolButtonSignalShowMenuCallback) int {
	signalMenuToolButtonShowMenuLock.Lock()
	defer signalMenuToolButtonShowMenuLock.Unlock()

	signalMenuToolButtonShowMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuToolButton_signal_connect_show_menu(instance, C.gpointer(uintptr(signalMenuToolButtonShowMenuId)))

	detail := signalMenuToolButtonShowMenuDetail{callback, handlerID}
	signalMenuToolButtonShowMenuMap[signalMenuToolButtonShowMenuId] = detail

	return signalMenuToolButtonShowMenuId
}

/*
DisconnectShowMenu disconnects a callback from the 'show-menu' signal for the MenuToolButton.

The connectionID should be a value returned from a call to ConnectShowMenu.
*/
func (recv *MenuToolButton) DisconnectShowMenu(connectionID int) {
	signalMenuToolButtonShowMenuLock.Lock()
	defer signalMenuToolButtonShowMenuLock.Unlock()

	detail, exists := signalMenuToolButtonShowMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuToolButtonShowMenuMap, connectionID)
}

//export menutoolbutton_showMenuHandler
func menutoolbutton_showMenuHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalMenuToolButtonShowMenuMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuToolButton
func (recv *MenuToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuToolButton
func (recv *MenuToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuToolButton
func (recv *MenuToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuToolButton
func (recv *MenuToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MessageDialog is a wrapper around the C record GtkMessageDialog.
type MessageDialog struct {
	native *C.GtkMessageDialog
	// parent_instance : record
	// Private : priv
}

func MessageDialogNewFromC(u unsafe.Pointer) *MessageDialog {
	c := (*C.GtkMessageDialog)(u)
	if c == nil {
		return nil
	}

	g := &MessageDialog{native: c}

	return g
}

func (recv *MessageDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *MessageDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *MessageDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *MessageDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *MessageDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *MessageDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MessageDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MessageDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to MessageDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a MessageDialog.
func CastToMessageDialog(object *gobject.Object) *MessageDialog {
	return MessageDialogNewFromC(object.ToC())
}

// Unsupported : gtk_message_dialog_new : unsupported parameter ... : varargs

// ImplementorIface returns the ImplementorIface interface implemented by MessageDialog
func (recv *MessageDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MessageDialog
func (recv *MessageDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Misc is a wrapper around the C record GtkMisc.
type Misc struct {
	native *C.GtkMisc
	// widget : record
	// Private : priv
}

func MiscNewFromC(u unsafe.Pointer) *Misc {
	c := (*C.GtkMisc)(u)
	if c == nil {
		return nil
	}

	g := &Misc{native: c}

	return g
}

func (recv *Misc) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Misc) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Misc) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Misc) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Misc.
// Exercise care, as this is a potentially dangerous function if the Object is not a Misc.
func CastToMisc(object *gobject.Object) *Misc {
	return MiscNewFromC(object.ToC())
}

// Gets the X and Y alignment of the widget within its allocation.
// See gtk_misc_set_alignment().
/*

C function : gtk_misc_get_alignment
*/
func (recv *Misc) GetAlignment() (float32, float32) {
	var c_xalign C.gfloat

	var c_yalign C.gfloat

	C.gtk_misc_get_alignment((*C.GtkMisc)(recv.native), &c_xalign, &c_yalign)

	xalign := (float32)(c_xalign)

	yalign := (float32)(c_yalign)

	return xalign, yalign
}

// Gets the padding in the X and Y directions of the widget.
// See gtk_misc_set_padding().
/*

C function : gtk_misc_get_padding
*/
func (recv *Misc) GetPadding() (int32, int32) {
	var c_xpad C.gint

	var c_ypad C.gint

	C.gtk_misc_get_padding((*C.GtkMisc)(recv.native), &c_xpad, &c_ypad)

	xpad := (int32)(c_xpad)

	ypad := (int32)(c_ypad)

	return xpad, ypad
}

// Sets the alignment of the widget.
/*

C function : gtk_misc_set_alignment
*/
func (recv *Misc) SetAlignment(xalign float32, yalign float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	C.gtk_misc_set_alignment((*C.GtkMisc)(recv.native), c_xalign, c_yalign)

	return
}

// Sets the amount of space to add around the widget.
/*

C function : gtk_misc_set_padding
*/
func (recv *Misc) SetPadding(xpad int32, ypad int32) {
	c_xpad := (C.gint)(xpad)

	c_ypad := (C.gint)(ypad)

	C.gtk_misc_set_padding((*C.GtkMisc)(recv.native), c_xpad, c_ypad)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Misc
func (recv *Misc) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Misc
func (recv *Misc) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ModelButton is a wrapper around the C record GtkModelButton.
type ModelButton struct {
	native *C.GtkModelButton
}

func ModelButtonNewFromC(u unsafe.Pointer) *ModelButton {
	c := (*C.GtkModelButton)(u)
	if c == nil {
		return nil
	}

	g := &ModelButton{native: c}

	return g
}

func (recv *ModelButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *ModelButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ModelButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ModelButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ModelButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ModelButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ModelButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to ModelButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ModelButton.
func CastToModelButton(object *gobject.Object) *ModelButton {
	return ModelButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ModelButton
func (recv *ModelButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ModelButton
func (recv *ModelButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ModelButton
func (recv *ModelButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ModelButton
func (recv *ModelButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MountOperation is a wrapper around the C record GtkMountOperation.
type MountOperation struct {
	native *C.GtkMountOperation
	// parent_instance : record
	// priv : record
}

func MountOperationNewFromC(u unsafe.Pointer) *MountOperation {
	c := (*C.GtkMountOperation)(u)
	if c == nil {
		return nil
	}

	g := &MountOperation{native: c}

	return g
}

func (recv *MountOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MountOperation upcasts to *MountOperation
func (recv *MountOperation) MountOperation() *gio.MountOperation {
	return gio.MountOperationNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *MountOperation) Object() *gobject.Object {
	return recv.MountOperation().Object()
}

// CastToWidget down casts any arbitary Object to MountOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a MountOperation.
func CastToMountOperation(object *gobject.Object) *MountOperation {
	return MountOperationNewFromC(object.ToC())
}

// Notebook is a wrapper around the C record GtkNotebook.
type Notebook struct {
	native *C.GtkNotebook
	// Private : container
	// Private : priv
}

func NotebookNewFromC(u unsafe.Pointer) *Notebook {
	c := (*C.GtkNotebook)(u)
	if c == nil {
		return nil
	}

	g := &Notebook{native: c}

	return g
}

func (recv *Notebook) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Notebook) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Notebook) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Notebook) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Notebook) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Notebook.
// Exercise care, as this is a potentially dangerous function if the Object is not a Notebook.
func CastToNotebook(object *gobject.Object) *Notebook {
	return NotebookNewFromC(object.ToC())
}

// Unsupported signal 'change-current-page' for Notebook : unsupported parameter object : type gint :

// Unsupported signal 'focus-tab' for Notebook : unsupported parameter object : type NotebookTab :

// Unsupported signal 'move-focus-out' for Notebook : unsupported parameter object : type DirectionType :

// Unsupported signal 'reorder-tab' for Notebook : unsupported parameter object : type DirectionType :

type signalNotebookSelectPageDetail struct {
	callback  NotebookSignalSelectPageCallback
	handlerID C.gulong
}

var signalNotebookSelectPageId int
var signalNotebookSelectPageMap = make(map[int]signalNotebookSelectPageDetail)
var signalNotebookSelectPageLock sync.Mutex

// NotebookSignalSelectPageCallback is a callback function for a 'select-page' signal emitted from a Notebook.
type NotebookSignalSelectPageCallback func(object bool) bool

/*
ConnectSelectPage connects the callback to the 'select-page' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectSelectPage to remove it.
*/
func (recv *Notebook) ConnectSelectPage(callback NotebookSignalSelectPageCallback) int {
	signalNotebookSelectPageLock.Lock()
	defer signalNotebookSelectPageLock.Unlock()

	signalNotebookSelectPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_select_page(instance, C.gpointer(uintptr(signalNotebookSelectPageId)))

	detail := signalNotebookSelectPageDetail{callback, handlerID}
	signalNotebookSelectPageMap[signalNotebookSelectPageId] = detail

	return signalNotebookSelectPageId
}

/*
DisconnectSelectPage disconnects a callback from the 'select-page' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectSelectPage.
*/
func (recv *Notebook) DisconnectSelectPage(connectionID int) {
	signalNotebookSelectPageLock.Lock()
	defer signalNotebookSelectPageLock.Unlock()

	detail, exists := signalNotebookSelectPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookSelectPageMap, connectionID)
}

//export notebook_selectPageHandler
func notebook_selectPageHandler(_ *C.GObject, c_object C.gboolean, data C.gpointer) C.gboolean {
	object := c_object == C.TRUE

	index := int(uintptr(data))
	callback := signalNotebookSelectPageMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'switch-page' for Notebook : unsupported parameter page_num : type guint :

// Creates a new #GtkNotebook widget with no pages.
/*

C function : gtk_notebook_new
*/
func NotebookNew() *Notebook {
	retC := C.gtk_notebook_new()
	retGo := NotebookNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Appends a page to @notebook.
/*

C function : gtk_notebook_append_page
*/
func (recv *Notebook) AppendPage(child *Widget, tabLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	retC := C.gtk_notebook_append_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label)
	retGo := (int32)(retC)

	return retGo
}

// Appends a page to @notebook, specifying the widget to use as the
// label in the popup menu.
/*

C function : gtk_notebook_append_page_menu
*/
func (recv *Notebook) AppendPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	retC := C.gtk_notebook_append_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label)
	retGo := (int32)(retC)

	return retGo
}

// Returns the page number of the current page.
/*

C function : gtk_notebook_get_current_page
*/
func (recv *Notebook) GetCurrentPage() int32 {
	retC := C.gtk_notebook_get_current_page((*C.GtkNotebook)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Retrieves the menu label widget of the page containing @child.
/*

C function : gtk_notebook_get_menu_label
*/
func (recv *Notebook) GetMenuLabel(child *Widget) *Widget {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_menu_label((*C.GtkNotebook)(recv.native), c_child)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the text of the menu label for the page containing
// @child.
/*

C function : gtk_notebook_get_menu_label_text
*/
func (recv *Notebook) GetMenuLabelText(child *Widget) string {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_menu_label_text((*C.GtkNotebook)(recv.native), c_child)
	retGo := C.GoString(retC)

	return retGo
}

// Returns the child widget contained in page number @page_num.
/*

C function : gtk_notebook_get_nth_page
*/
func (recv *Notebook) GetNthPage(pageNum int32) *Widget {
	c_page_num := (C.gint)(pageNum)

	retC := C.gtk_notebook_get_nth_page((*C.GtkNotebook)(recv.native), c_page_num)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns whether the tab label area has arrows for scrolling.
// See gtk_notebook_set_scrollable().
/*

C function : gtk_notebook_get_scrollable
*/
func (recv *Notebook) GetScrollable() bool {
	retC := C.gtk_notebook_get_scrollable((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether a bevel will be drawn around the notebook pages.
// See gtk_notebook_set_show_border().
/*

C function : gtk_notebook_get_show_border
*/
func (recv *Notebook) GetShowBorder() bool {
	retC := C.gtk_notebook_get_show_border((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether the tabs of the notebook are shown.
// See gtk_notebook_set_show_tabs().
/*

C function : gtk_notebook_get_show_tabs
*/
func (recv *Notebook) GetShowTabs() bool {
	retC := C.gtk_notebook_get_show_tabs((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the tab label widget for the page @child.
// %NULL is returned if @child is not in @notebook or
// if no tab label has specifically been set for @child.
/*

C function : gtk_notebook_get_tab_label
*/
func (recv *Notebook) GetTabLabel(child *Widget) *Widget {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_tab_label((*C.GtkNotebook)(recv.native), c_child)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the text of the tab label for the page containing
// @child.
/*

C function : gtk_notebook_get_tab_label_text
*/
func (recv *Notebook) GetTabLabelText(child *Widget) string {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_tab_label_text((*C.GtkNotebook)(recv.native), c_child)
	retGo := C.GoString(retC)

	return retGo
}

// Gets the edge at which the tabs for switching pages in the
// notebook are drawn.
/*

C function : gtk_notebook_get_tab_pos
*/
func (recv *Notebook) GetTabPos() PositionType {
	retC := C.gtk_notebook_get_tab_pos((*C.GtkNotebook)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// Insert a page into @notebook at the given position.
/*

C function : gtk_notebook_insert_page
*/
func (recv *Notebook) InsertPage(child *Widget, tabLabel *Widget, position int32) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_notebook_insert_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_position)
	retGo := (int32)(retC)

	return retGo
}

// Insert a page into @notebook at the given position, specifying
// the widget to use as the label in the popup menu.
/*

C function : gtk_notebook_insert_page_menu
*/
func (recv *Notebook) InsertPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget, position int32) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_notebook_insert_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label, c_position)
	retGo := (int32)(retC)

	return retGo
}

// Switches to the next page. Nothing happens if the current page is
// the last page.
/*

C function : gtk_notebook_next_page
*/
func (recv *Notebook) NextPage() {
	C.gtk_notebook_next_page((*C.GtkNotebook)(recv.native))

	return
}

// Finds the index of the page which contains the given child
// widget.
/*

C function : gtk_notebook_page_num
*/
func (recv *Notebook) PageNum(child *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_page_num((*C.GtkNotebook)(recv.native), c_child)
	retGo := (int32)(retC)

	return retGo
}

// Disables the popup menu.
/*

C function : gtk_notebook_popup_disable
*/
func (recv *Notebook) PopupDisable() {
	C.gtk_notebook_popup_disable((*C.GtkNotebook)(recv.native))

	return
}

// Enables the popup menu: if the user clicks with the right
// mouse button on the tab labels, a menu with all the pages
// will be popped up.
/*

C function : gtk_notebook_popup_enable
*/
func (recv *Notebook) PopupEnable() {
	C.gtk_notebook_popup_enable((*C.GtkNotebook)(recv.native))

	return
}

// Prepends a page to @notebook.
/*

C function : gtk_notebook_prepend_page
*/
func (recv *Notebook) PrependPage(child *Widget, tabLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	retC := C.gtk_notebook_prepend_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label)
	retGo := (int32)(retC)

	return retGo
}

// Prepends a page to @notebook, specifying the widget to use as the
// label in the popup menu.
/*

C function : gtk_notebook_prepend_page_menu
*/
func (recv *Notebook) PrependPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	retC := C.gtk_notebook_prepend_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label)
	retGo := (int32)(retC)

	return retGo
}

// Switches to the previous page. Nothing happens if the current page
// is the first page.
/*

C function : gtk_notebook_prev_page
*/
func (recv *Notebook) PrevPage() {
	C.gtk_notebook_prev_page((*C.GtkNotebook)(recv.native))

	return
}

// Removes a page from the notebook given its index
// in the notebook.
/*

C function : gtk_notebook_remove_page
*/
func (recv *Notebook) RemovePage(pageNum int32) {
	c_page_num := (C.gint)(pageNum)

	C.gtk_notebook_remove_page((*C.GtkNotebook)(recv.native), c_page_num)

	return
}

// Reorders the page containing @child, so that it appears in position
// @position. If @position is greater than or equal to the number of
// children in the list or negative, @child will be moved to the end
// of the list.
/*

C function : gtk_notebook_reorder_child
*/
func (recv *Notebook) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_notebook_reorder_child((*C.GtkNotebook)(recv.native), c_child, c_position)

	return
}

// Switches to the page number @page_num.
//
// Note that due to historical reasons, GtkNotebook refuses
// to switch to a page unless the child widget is visible.
// Therefore, it is recommended to show child widgets before
// adding them to a notebook.
/*

C function : gtk_notebook_set_current_page
*/
func (recv *Notebook) SetCurrentPage(pageNum int32) {
	c_page_num := (C.gint)(pageNum)

	C.gtk_notebook_set_current_page((*C.GtkNotebook)(recv.native), c_page_num)

	return
}

// Changes the menu label for the page containing @child.
/*

C function : gtk_notebook_set_menu_label
*/
func (recv *Notebook) SetMenuLabel(child *Widget, menuLabel *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	C.gtk_notebook_set_menu_label((*C.GtkNotebook)(recv.native), c_child, c_menu_label)

	return
}

// Creates a new label and sets it as the menu label of @child.
/*

C function : gtk_notebook_set_menu_label_text
*/
func (recv *Notebook) SetMenuLabelText(child *Widget, menuText string) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_menu_text := C.CString(menuText)
	defer C.free(unsafe.Pointer(c_menu_text))

	C.gtk_notebook_set_menu_label_text((*C.GtkNotebook)(recv.native), c_child, c_menu_text)

	return
}

// Sets whether the tab label area will have arrows for
// scrolling if there are too many tabs to fit in the area.
/*

C function : gtk_notebook_set_scrollable
*/
func (recv *Notebook) SetScrollable(scrollable bool) {
	c_scrollable :=
		boolToGboolean(scrollable)

	C.gtk_notebook_set_scrollable((*C.GtkNotebook)(recv.native), c_scrollable)

	return
}

// Sets whether a bevel will be drawn around the notebook pages.
// This only has a visual effect when the tabs are not shown.
// See gtk_notebook_set_show_tabs().
/*

C function : gtk_notebook_set_show_border
*/
func (recv *Notebook) SetShowBorder(showBorder bool) {
	c_show_border :=
		boolToGboolean(showBorder)

	C.gtk_notebook_set_show_border((*C.GtkNotebook)(recv.native), c_show_border)

	return
}

// Sets whether to show the tabs for the notebook or not.
/*

C function : gtk_notebook_set_show_tabs
*/
func (recv *Notebook) SetShowTabs(showTabs bool) {
	c_show_tabs :=
		boolToGboolean(showTabs)

	C.gtk_notebook_set_show_tabs((*C.GtkNotebook)(recv.native), c_show_tabs)

	return
}

// Changes the tab label for @child.
// If %NULL is specified for @tab_label, then the page will
// have the label “page N”.
/*

C function : gtk_notebook_set_tab_label
*/
func (recv *Notebook) SetTabLabel(child *Widget, tabLabel *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	C.gtk_notebook_set_tab_label((*C.GtkNotebook)(recv.native), c_child, c_tab_label)

	return
}

// Creates a new label and sets it as the tab label for the page
// containing @child.
/*

C function : gtk_notebook_set_tab_label_text
*/
func (recv *Notebook) SetTabLabelText(child *Widget, tabText string) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_text := C.CString(tabText)
	defer C.free(unsafe.Pointer(c_tab_text))

	C.gtk_notebook_set_tab_label_text((*C.GtkNotebook)(recv.native), c_child, c_tab_text)

	return
}

// Sets the edge at which the tabs for switching pages in the
// notebook are drawn.
/*

C function : gtk_notebook_set_tab_pos
*/
func (recv *Notebook) SetTabPos(pos PositionType) {
	c_pos := (C.GtkPositionType)(pos)

	C.gtk_notebook_set_tab_pos((*C.GtkNotebook)(recv.native), c_pos)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Notebook
func (recv *Notebook) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Notebook
func (recv *Notebook) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// NotebookAccessible is a wrapper around the C record GtkNotebookAccessible.
type NotebookAccessible struct {
	native *C.GtkNotebookAccessible
	// parent : record
	// priv : record
}

func NotebookAccessibleNewFromC(u unsafe.Pointer) *NotebookAccessible {
	c := (*C.GtkNotebookAccessible)(u)
	if c == nil {
		return nil
	}

	g := &NotebookAccessible{native: c}

	return g
}

func (recv *NotebookAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *NotebookAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *NotebookAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *NotebookAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *NotebookAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to NotebookAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a NotebookAccessible.
func CastToNotebookAccessible(object *gobject.Object) *NotebookAccessible {
	return NotebookAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by NotebookAccessible
func (recv *NotebookAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by NotebookAccessible
func (recv *NotebookAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// NotebookPageAccessible is a wrapper around the C record GtkNotebookPageAccessible.
type NotebookPageAccessible struct {
	native *C.GtkNotebookPageAccessible
	// parent : record
	// priv : record
}

func NotebookPageAccessibleNewFromC(u unsafe.Pointer) *NotebookPageAccessible {
	c := (*C.GtkNotebookPageAccessible)(u)
	if c == nil {
		return nil
	}

	g := &NotebookPageAccessible{native: c}

	return g
}

func (recv *NotebookPageAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *NotebookPageAccessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to NotebookPageAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a NotebookPageAccessible.
func CastToNotebookPageAccessible(object *gobject.Object) *NotebookPageAccessible {
	return NotebookPageAccessibleNewFromC(object.ToC())
}

/*

C function : gtk_notebook_page_accessible_new
*/
func NotebookPageAccessibleNew(notebook *NotebookAccessible, child *Widget) *NotebookPageAccessible {
	c_notebook := (*C.GtkNotebookAccessible)(C.NULL)
	if notebook != nil {
		c_notebook = (*C.GtkNotebookAccessible)(notebook.ToC())
	}

	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_page_accessible_new(c_notebook, c_child)
	retGo := NotebookPageAccessibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

/*

C function : gtk_notebook_page_accessible_invalidate
*/
func (recv *NotebookPageAccessible) Invalidate() {
	C.gtk_notebook_page_accessible_invalidate((*C.GtkNotebookPageAccessible)(recv.native))

	return
}

// Component returns the Component interface implemented by NotebookPageAccessible
func (recv *NotebookPageAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// NumerableIcon is a wrapper around the C record GtkNumerableIcon.
type NumerableIcon struct {
	native *C.GtkNumerableIcon
	// parent : record
	// Private : priv
}

func NumerableIconNewFromC(u unsafe.Pointer) *NumerableIcon {
	c := (*C.GtkNumerableIcon)(u)
	if c == nil {
		return nil
	}

	g := &NumerableIcon{native: c}

	return g
}

func (recv *NumerableIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// EmblemedIcon upcasts to *EmblemedIcon
func (recv *NumerableIcon) EmblemedIcon() *gio.EmblemedIcon {
	return gio.EmblemedIconNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *NumerableIcon) Object() *gobject.Object {
	return recv.EmblemedIcon().Object()
}

// CastToWidget down casts any arbitary Object to NumerableIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a NumerableIcon.
func CastToNumerableIcon(object *gobject.Object) *NumerableIcon {
	return NumerableIconNewFromC(object.ToC())
}

// Icon returns the Icon interface implemented by NumerableIcon
func (recv *NumerableIcon) Icon() *gio.Icon {
	return gio.IconNewFromC(recv.ToC())
}

// OffscreenWindow is a wrapper around the C record GtkOffscreenWindow.
type OffscreenWindow struct {
	native *C.GtkOffscreenWindow
	// parent_object : record
}

func OffscreenWindowNewFromC(u unsafe.Pointer) *OffscreenWindow {
	c := (*C.GtkOffscreenWindow)(u)
	if c == nil {
		return nil
	}

	g := &OffscreenWindow{native: c}

	return g
}

func (recv *OffscreenWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Window upcasts to *Window
func (recv *OffscreenWindow) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *OffscreenWindow) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *OffscreenWindow) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *OffscreenWindow) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *OffscreenWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *OffscreenWindow) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitary Object to OffscreenWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a OffscreenWindow.
func CastToOffscreenWindow(object *gobject.Object) *OffscreenWindow {
	return OffscreenWindowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by OffscreenWindow
func (recv *OffscreenWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by OffscreenWindow
func (recv *OffscreenWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Overlay is a wrapper around the C record GtkOverlay.
type Overlay struct {
	native *C.GtkOverlay
	// parent : record
	// priv : record
}

func OverlayNewFromC(u unsafe.Pointer) *Overlay {
	c := (*C.GtkOverlay)(u)
	if c == nil {
		return nil
	}

	g := &Overlay{native: c}

	return g
}

func (recv *Overlay) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Overlay) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Overlay) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Overlay) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Overlay) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Overlay) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Overlay.
// Exercise care, as this is a potentially dangerous function if the Object is not a Overlay.
func CastToOverlay(object *gobject.Object) *Overlay {
	return OverlayNewFromC(object.ToC())
}

// Unsupported signal 'get-child-position' for Overlay : unsupported parameter allocation : type Gdk.Rectangle : Blacklisted record : GdkRectangle

// ImplementorIface returns the ImplementorIface interface implemented by Overlay
func (recv *Overlay) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Overlay
func (recv *Overlay) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PageSetup is a wrapper around the C record GtkPageSetup.
type PageSetup struct {
	native *C.GtkPageSetup
}

func PageSetupNewFromC(u unsafe.Pointer) *PageSetup {
	c := (*C.GtkPageSetup)(u)
	if c == nil {
		return nil
	}

	g := &PageSetup{native: c}

	return g
}

func (recv *PageSetup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *PageSetup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to PageSetup.
// Exercise care, as this is a potentially dangerous function if the Object is not a PageSetup.
func CastToPageSetup(object *gobject.Object) *PageSetup {
	return PageSetupNewFromC(object.ToC())
}

// Paned is a wrapper around the C record GtkPaned.
type Paned struct {
	native *C.GtkPaned
	// container : record
	// Private : priv
}

func PanedNewFromC(u unsafe.Pointer) *Paned {
	c := (*C.GtkPaned)(u)
	if c == nil {
		return nil
	}

	g := &Paned{native: c}

	return g
}

func (recv *Paned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Paned) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Paned) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Paned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Paned) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Paned.
// Exercise care, as this is a potentially dangerous function if the Object is not a Paned.
func CastToPaned(object *gobject.Object) *Paned {
	return PanedNewFromC(object.ToC())
}

// Adds a child to the top or left pane with default parameters. This is
// equivalent to
// `gtk_paned_pack1 (paned, child, FALSE, TRUE)`.
/*

C function : gtk_paned_add1
*/
func (recv *Paned) Add1(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_paned_add1((*C.GtkPaned)(recv.native), c_child)

	return
}

// Adds a child to the bottom or right pane with default parameters. This
// is equivalent to
// `gtk_paned_pack2 (paned, child, TRUE, TRUE)`.
/*

C function : gtk_paned_add2
*/
func (recv *Paned) Add2(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_paned_add2((*C.GtkPaned)(recv.native), c_child)

	return
}

// Obtains the position of the divider between the two panes.
/*

C function : gtk_paned_get_position
*/
func (recv *Paned) GetPosition() int32 {
	retC := C.gtk_paned_get_position((*C.GtkPaned)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Adds a child to the top or left pane.
/*

C function : gtk_paned_pack1
*/
func (recv *Paned) Pack1(child *Widget, resize bool, shrink bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_resize :=
		boolToGboolean(resize)

	c_shrink :=
		boolToGboolean(shrink)

	C.gtk_paned_pack1((*C.GtkPaned)(recv.native), c_child, c_resize, c_shrink)

	return
}

// Adds a child to the bottom or right pane.
/*

C function : gtk_paned_pack2
*/
func (recv *Paned) Pack2(child *Widget, resize bool, shrink bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_resize :=
		boolToGboolean(resize)

	c_shrink :=
		boolToGboolean(shrink)

	C.gtk_paned_pack2((*C.GtkPaned)(recv.native), c_child, c_resize, c_shrink)

	return
}

// Sets the position of the divider between the two panes.
/*

C function : gtk_paned_set_position
*/
func (recv *Paned) SetPosition(position int32) {
	c_position := (C.gint)(position)

	C.gtk_paned_set_position((*C.GtkPaned)(recv.native), c_position)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Paned
func (recv *Paned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Paned
func (recv *Paned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Paned
func (recv *Paned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// PanedAccessible is a wrapper around the C record GtkPanedAccessible.
type PanedAccessible struct {
	native *C.GtkPanedAccessible
	// parent : record
	// priv : record
}

func PanedAccessibleNewFromC(u unsafe.Pointer) *PanedAccessible {
	c := (*C.GtkPanedAccessible)(u)
	if c == nil {
		return nil
	}

	g := &PanedAccessible{native: c}

	return g
}

func (recv *PanedAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *PanedAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *PanedAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *PanedAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *PanedAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to PanedAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a PanedAccessible.
func CastToPanedAccessible(object *gobject.Object) *PanedAccessible {
	return PanedAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by PanedAccessible
func (recv *PanedAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by PanedAccessible
func (recv *PanedAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// PlacesSidebar is a wrapper around the C record GtkPlacesSidebar.
type PlacesSidebar struct {
	native *C.GtkPlacesSidebar
}

func PlacesSidebarNewFromC(u unsafe.Pointer) *PlacesSidebar {
	c := (*C.GtkPlacesSidebar)(u)
	if c == nil {
		return nil
	}

	g := &PlacesSidebar{native: c}

	return g
}

func (recv *PlacesSidebar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ScrolledWindow upcasts to *ScrolledWindow
func (recv *PlacesSidebar) ScrolledWindow() *ScrolledWindow {
	return ScrolledWindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *PlacesSidebar) Bin() *Bin {
	return recv.ScrolledWindow().Bin()
}

// Container upcasts to *Container
func (recv *PlacesSidebar) Container() *Container {
	return recv.ScrolledWindow().Container()
}

// Widget upcasts to *Widget
func (recv *PlacesSidebar) Widget() *Widget {
	return recv.ScrolledWindow().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *PlacesSidebar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ScrolledWindow().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *PlacesSidebar) Object() *gobject.Object {
	return recv.ScrolledWindow().Object()
}

// CastToWidget down casts any arbitary Object to PlacesSidebar.
// Exercise care, as this is a potentially dangerous function if the Object is not a PlacesSidebar.
func CastToPlacesSidebar(object *gobject.Object) *PlacesSidebar {
	return PlacesSidebarNewFromC(object.ToC())
}

type signalPlacesSidebarShowConnectToServerDetail struct {
	callback  PlacesSidebarSignalShowConnectToServerCallback
	handlerID C.gulong
}

var signalPlacesSidebarShowConnectToServerId int
var signalPlacesSidebarShowConnectToServerMap = make(map[int]signalPlacesSidebarShowConnectToServerDetail)
var signalPlacesSidebarShowConnectToServerLock sync.Mutex

// PlacesSidebarSignalShowConnectToServerCallback is a callback function for a 'show-connect-to-server' signal emitted from a PlacesSidebar.
type PlacesSidebarSignalShowConnectToServerCallback func()

/*
ConnectShowConnectToServer connects the callback to the 'show-connect-to-server' signal for the PlacesSidebar.

The returned value represents the connection, and may be passed to DisconnectShowConnectToServer to remove it.
*/
func (recv *PlacesSidebar) ConnectShowConnectToServer(callback PlacesSidebarSignalShowConnectToServerCallback) int {
	signalPlacesSidebarShowConnectToServerLock.Lock()
	defer signalPlacesSidebarShowConnectToServerLock.Unlock()

	signalPlacesSidebarShowConnectToServerId++
	instance := C.gpointer(recv.native)
	handlerID := C.PlacesSidebar_signal_connect_show_connect_to_server(instance, C.gpointer(uintptr(signalPlacesSidebarShowConnectToServerId)))

	detail := signalPlacesSidebarShowConnectToServerDetail{callback, handlerID}
	signalPlacesSidebarShowConnectToServerMap[signalPlacesSidebarShowConnectToServerId] = detail

	return signalPlacesSidebarShowConnectToServerId
}

/*
DisconnectShowConnectToServer disconnects a callback from the 'show-connect-to-server' signal for the PlacesSidebar.

The connectionID should be a value returned from a call to ConnectShowConnectToServer.
*/
func (recv *PlacesSidebar) DisconnectShowConnectToServer(connectionID int) {
	signalPlacesSidebarShowConnectToServerLock.Lock()
	defer signalPlacesSidebarShowConnectToServerLock.Unlock()

	detail, exists := signalPlacesSidebarShowConnectToServerMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPlacesSidebarShowConnectToServerMap, connectionID)
}

//export placessidebar_showConnectToServerHandler
func placessidebar_showConnectToServerHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalPlacesSidebarShowConnectToServerMap[index].callback
	callback()
}

// Returns the value previously set with gtk_places_sidebar_set_show_connect_to_server()
/*

C function : gtk_places_sidebar_get_show_connect_to_server
*/
func (recv *PlacesSidebar) GetShowConnectToServer() bool {
	retC := C.gtk_places_sidebar_get_show_connect_to_server((*C.GtkPlacesSidebar)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by PlacesSidebar
func (recv *PlacesSidebar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by PlacesSidebar
func (recv *PlacesSidebar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkPlug

// Popover is a wrapper around the C record GtkPopover.
type Popover struct {
	native *C.GtkPopover
	// parent_instance : record
	// Private : priv
}

func PopoverNewFromC(u unsafe.Pointer) *Popover {
	c := (*C.GtkPopover)(u)
	if c == nil {
		return nil
	}

	g := &Popover{native: c}

	return g
}

func (recv *Popover) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Popover) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Popover) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Popover) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Popover) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Popover) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Popover.
// Exercise care, as this is a potentially dangerous function if the Object is not a Popover.
func CastToPopover(object *gobject.Object) *Popover {
	return PopoverNewFromC(object.ToC())
}

type signalPopoverClosedDetail struct {
	callback  PopoverSignalClosedCallback
	handlerID C.gulong
}

var signalPopoverClosedId int
var signalPopoverClosedMap = make(map[int]signalPopoverClosedDetail)
var signalPopoverClosedLock sync.Mutex

// PopoverSignalClosedCallback is a callback function for a 'closed' signal emitted from a Popover.
type PopoverSignalClosedCallback func()

/*
ConnectClosed connects the callback to the 'closed' signal for the Popover.

The returned value represents the connection, and may be passed to DisconnectClosed to remove it.
*/
func (recv *Popover) ConnectClosed(callback PopoverSignalClosedCallback) int {
	signalPopoverClosedLock.Lock()
	defer signalPopoverClosedLock.Unlock()

	signalPopoverClosedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Popover_signal_connect_closed(instance, C.gpointer(uintptr(signalPopoverClosedId)))

	detail := signalPopoverClosedDetail{callback, handlerID}
	signalPopoverClosedMap[signalPopoverClosedId] = detail

	return signalPopoverClosedId
}

/*
DisconnectClosed disconnects a callback from the 'closed' signal for the Popover.

The connectionID should be a value returned from a call to ConnectClosed.
*/
func (recv *Popover) DisconnectClosed(connectionID int) {
	signalPopoverClosedLock.Lock()
	defer signalPopoverClosedLock.Unlock()

	detail, exists := signalPopoverClosedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPopoverClosedMap, connectionID)
}

//export popover_closedHandler
func popover_closedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalPopoverClosedMap[index].callback
	callback()
}

// Unsupported : gtk_popover_get_pointing_to : unsupported parameter rect : Blacklisted record : GdkRectangle

// Returns the preferred position of @popover.
/*

C function : gtk_popover_get_position
*/
func (recv *Popover) GetPosition() PositionType {
	retC := C.gtk_popover_get_position((*C.GtkPopover)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Popover
func (recv *Popover) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Popover
func (recv *Popover) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PopoverAccessible is a wrapper around the C record GtkPopoverAccessible.
type PopoverAccessible struct {
	native *C.GtkPopoverAccessible
	// parent : record
}

func PopoverAccessibleNewFromC(u unsafe.Pointer) *PopoverAccessible {
	c := (*C.GtkPopoverAccessible)(u)
	if c == nil {
		return nil
	}

	g := &PopoverAccessible{native: c}

	return g
}

func (recv *PopoverAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *PopoverAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *PopoverAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *PopoverAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *PopoverAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to PopoverAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a PopoverAccessible.
func CastToPopoverAccessible(object *gobject.Object) *PopoverAccessible {
	return PopoverAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by PopoverAccessible
func (recv *PopoverAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// PopoverMenu is a wrapper around the C record GtkPopoverMenu.
type PopoverMenu struct {
	native *C.GtkPopoverMenu
}

func PopoverMenuNewFromC(u unsafe.Pointer) *PopoverMenu {
	c := (*C.GtkPopoverMenu)(u)
	if c == nil {
		return nil
	}

	g := &PopoverMenu{native: c}

	return g
}

func (recv *PopoverMenu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Popover upcasts to *Popover
func (recv *PopoverMenu) Popover() *Popover {
	return PopoverNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *PopoverMenu) Bin() *Bin {
	return recv.Popover().Bin()
}

// Container upcasts to *Container
func (recv *PopoverMenu) Container() *Container {
	return recv.Popover().Container()
}

// Widget upcasts to *Widget
func (recv *PopoverMenu) Widget() *Widget {
	return recv.Popover().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *PopoverMenu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Popover().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *PopoverMenu) Object() *gobject.Object {
	return recv.Popover().Object()
}

// CastToWidget down casts any arbitary Object to PopoverMenu.
// Exercise care, as this is a potentially dangerous function if the Object is not a PopoverMenu.
func CastToPopoverMenu(object *gobject.Object) *PopoverMenu {
	return PopoverMenuNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by PopoverMenu
func (recv *PopoverMenu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by PopoverMenu
func (recv *PopoverMenu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PrintContext is a wrapper around the C record GtkPrintContext.
type PrintContext struct {
	native *C.GtkPrintContext
}

func PrintContextNewFromC(u unsafe.Pointer) *PrintContext {
	c := (*C.GtkPrintContext)(u)
	if c == nil {
		return nil
	}

	g := &PrintContext{native: c}

	return g
}

func (recv *PrintContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *PrintContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to PrintContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintContext.
func CastToPrintContext(object *gobject.Object) *PrintContext {
	return PrintContextNewFromC(object.ToC())
}

// PrintOperation is a wrapper around the C record GtkPrintOperation.
type PrintOperation struct {
	native *C.GtkPrintOperation
	// parent_instance : record
	// Private : priv
}

func PrintOperationNewFromC(u unsafe.Pointer) *PrintOperation {
	c := (*C.GtkPrintOperation)(u)
	if c == nil {
		return nil
	}

	g := &PrintOperation{native: c}

	return g
}

func (recv *PrintOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *PrintOperation) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to PrintOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintOperation.
func CastToPrintOperation(object *gobject.Object) *PrintOperation {
	return PrintOperationNewFromC(object.ToC())
}

// PrintOperationPreview returns the PrintOperationPreview interface implemented by PrintOperation
func (recv *PrintOperation) PrintOperationPreview() *PrintOperationPreview {
	return PrintOperationPreviewNewFromC(recv.ToC())
}

// PrintSettings is a wrapper around the C record GtkPrintSettings.
type PrintSettings struct {
	native *C.GtkPrintSettings
}

func PrintSettingsNewFromC(u unsafe.Pointer) *PrintSettings {
	c := (*C.GtkPrintSettings)(u)
	if c == nil {
		return nil
	}

	g := &PrintSettings{native: c}

	return g
}

func (recv *PrintSettings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *PrintSettings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to PrintSettings.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintSettings.
func CastToPrintSettings(object *gobject.Object) *PrintSettings {
	return PrintSettingsNewFromC(object.ToC())
}

// ProgressBar is a wrapper around the C record GtkProgressBar.
type ProgressBar struct {
	native *C.GtkProgressBar
	// parent : record
	// Private : priv
}

func ProgressBarNewFromC(u unsafe.Pointer) *ProgressBar {
	c := (*C.GtkProgressBar)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBar{native: c}

	return g
}

func (recv *ProgressBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *ProgressBar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ProgressBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ProgressBar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to ProgressBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProgressBar.
func CastToProgressBar(object *gobject.Object) *ProgressBar {
	return ProgressBarNewFromC(object.ToC())
}

// Creates a new #GtkProgressBar.
/*

C function : gtk_progress_bar_new
*/
func ProgressBarNew() *ProgressBar {
	retC := C.gtk_progress_bar_new()
	retGo := ProgressBarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the current fraction of the task that’s been completed.
/*

C function : gtk_progress_bar_get_fraction
*/
func (recv *ProgressBar) GetFraction() float64 {
	retC := C.gtk_progress_bar_get_fraction((*C.GtkProgressBar)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Gets the value set by gtk_progress_bar_set_inverted().
/*

C function : gtk_progress_bar_get_inverted
*/
func (recv *ProgressBar) GetInverted() bool {
	retC := C.gtk_progress_bar_get_inverted((*C.GtkProgressBar)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves the pulse step set with gtk_progress_bar_set_pulse_step().
/*

C function : gtk_progress_bar_get_pulse_step
*/
func (recv *ProgressBar) GetPulseStep() float64 {
	retC := C.gtk_progress_bar_get_pulse_step((*C.GtkProgressBar)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Retrieves the text that is displayed with the progress bar,
// if any, otherwise %NULL. The return value is a reference
// to the text, not a copy of it, so will become invalid
// if you change the text in the progress bar.
/*

C function : gtk_progress_bar_get_text
*/
func (recv *ProgressBar) GetText() string {
	retC := C.gtk_progress_bar_get_text((*C.GtkProgressBar)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Indicates that some progress has been made, but you don’t know how much.
// Causes the progress bar to enter “activity mode,” where a block
// bounces back and forth. Each call to gtk_progress_bar_pulse()
// causes the block to move by a little bit (the amount of movement
// per pulse is determined by gtk_progress_bar_set_pulse_step()).
/*

C function : gtk_progress_bar_pulse
*/
func (recv *ProgressBar) Pulse() {
	C.gtk_progress_bar_pulse((*C.GtkProgressBar)(recv.native))

	return
}

// Causes the progress bar to “fill in” the given fraction
// of the bar. The fraction should be between 0.0 and 1.0,
// inclusive.
/*

C function : gtk_progress_bar_set_fraction
*/
func (recv *ProgressBar) SetFraction(fraction float64) {
	c_fraction := (C.gdouble)(fraction)

	C.gtk_progress_bar_set_fraction((*C.GtkProgressBar)(recv.native), c_fraction)

	return
}

// Progress bars normally grow from top to bottom or left to right.
// Inverted progress bars grow in the opposite direction.
/*

C function : gtk_progress_bar_set_inverted
*/
func (recv *ProgressBar) SetInverted(inverted bool) {
	c_inverted :=
		boolToGboolean(inverted)

	C.gtk_progress_bar_set_inverted((*C.GtkProgressBar)(recv.native), c_inverted)

	return
}

// Sets the fraction of total progress bar length to move the
// bouncing block for each call to gtk_progress_bar_pulse().
/*

C function : gtk_progress_bar_set_pulse_step
*/
func (recv *ProgressBar) SetPulseStep(fraction float64) {
	c_fraction := (C.gdouble)(fraction)

	C.gtk_progress_bar_set_pulse_step((*C.GtkProgressBar)(recv.native), c_fraction)

	return
}

// Causes the given @text to appear next to the progress bar.
//
// If @text is %NULL and #GtkProgressBar:show-text is %TRUE, the current
// value of #GtkProgressBar:fraction will be displayed as a percentage.
//
// If @text is non-%NULL and #GtkProgressBar:show-text is %TRUE, the text
// will be displayed. In this case, it will not display the progress
// percentage. If @text is the empty string, the progress bar will still
// be styled and sized suitably for containing text, as long as
// #GtkProgressBar:show-text is %TRUE.
/*

C function : gtk_progress_bar_set_text
*/
func (recv *ProgressBar) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_progress_bar_set_text((*C.GtkProgressBar)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ProgressBar
func (recv *ProgressBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ProgressBar
func (recv *ProgressBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ProgressBar
func (recv *ProgressBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ProgressBarAccessible is a wrapper around the C record GtkProgressBarAccessible.
type ProgressBarAccessible struct {
	native *C.GtkProgressBarAccessible
	// parent : record
	// priv : record
}

func ProgressBarAccessibleNewFromC(u unsafe.Pointer) *ProgressBarAccessible {
	c := (*C.GtkProgressBarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBarAccessible{native: c}

	return g
}

func (recv *ProgressBarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ProgressBarAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ProgressBarAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ProgressBarAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ProgressBarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProgressBarAccessible.
func CastToProgressBarAccessible(object *gobject.Object) *ProgressBarAccessible {
	return ProgressBarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ProgressBarAccessible
func (recv *ProgressBarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ProgressBarAccessible
func (recv *ProgressBarAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// RadioAction is a wrapper around the C record GtkRadioAction.
type RadioAction struct {
	native *C.GtkRadioAction
	// parent : record
	// Private : private_data
}

func RadioActionNewFromC(u unsafe.Pointer) *RadioAction {
	c := (*C.GtkRadioAction)(u)
	if c == nil {
		return nil
	}

	g := &RadioAction{native: c}

	return g
}

func (recv *RadioAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleAction upcasts to *ToggleAction
func (recv *RadioAction) ToggleAction() *ToggleAction {
	return ToggleActionNewFromC(unsafe.Pointer(recv.native))
}

// Action upcasts to *Action
func (recv *RadioAction) Action() *Action {
	return recv.ToggleAction().Action()
}

// Object upcasts to *Object
func (recv *RadioAction) Object() *gobject.Object {
	return recv.ToggleAction().Object()
}

// CastToWidget down casts any arbitary Object to RadioAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioAction.
func CastToRadioAction(object *gobject.Object) *RadioAction {
	return RadioActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RadioAction
func (recv *RadioAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioButton is a wrapper around the C record GtkRadioButton.
type RadioButton struct {
	native *C.GtkRadioButton
	// check_button : record
	// Private : priv
}

func RadioButtonNewFromC(u unsafe.Pointer) *RadioButton {
	c := (*C.GtkRadioButton)(u)
	if c == nil {
		return nil
	}

	g := &RadioButton{native: c}

	return g
}

func (recv *RadioButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CheckButton upcasts to *CheckButton
func (recv *RadioButton) CheckButton() *CheckButton {
	return CheckButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToggleButton upcasts to *ToggleButton
func (recv *RadioButton) ToggleButton() *ToggleButton {
	return recv.CheckButton().ToggleButton()
}

// Button upcasts to *Button
func (recv *RadioButton) Button() *Button {
	return recv.CheckButton().Button()
}

// Bin upcasts to *Bin
func (recv *RadioButton) Bin() *Bin {
	return recv.CheckButton().Bin()
}

// Container upcasts to *Container
func (recv *RadioButton) Container() *Container {
	return recv.CheckButton().Container()
}

// Widget upcasts to *Widget
func (recv *RadioButton) Widget() *Widget {
	return recv.CheckButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CheckButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioButton) Object() *gobject.Object {
	return recv.CheckButton().Object()
}

// CastToWidget down casts any arbitary Object to RadioButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioButton.
func CastToRadioButton(object *gobject.Object) *RadioButton {
	return RadioButtonNewFromC(object.ToC())
}

// Creates a new #GtkRadioButton. To be of any practical value, a widget should
// then be packed into the radio button.
/*

C function : gtk_radio_button_new
*/
func RadioButtonNew(group *glib.SList) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	retC := C.gtk_radio_button_new(c_group)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton, adding it to the same group as
// @radio_group_member. As with gtk_radio_button_new(), a widget
// should be packed into the radio button.
/*

C function : gtk_radio_button_new_from_widget
*/
func RadioButtonNewFromWidget(radioGroupMember *RadioButton) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	retC := C.gtk_radio_button_new_from_widget(c_radio_group_member)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton with a text label.
/*

C function : gtk_radio_button_new_with_label
*/
func RadioButtonNewWithLabel(group *glib.SList, label string) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_label(c_group, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton with a text label, adding it to
// the same group as @radio_group_member.
/*

C function : gtk_radio_button_new_with_label_from_widget
*/
func RadioButtonNewWithLabelFromWidget(radioGroupMember *RadioButton, label string) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_label_from_widget(c_radio_group_member, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton containing a label, adding it to the same
// group as @group. The label will be created using
// gtk_label_new_with_mnemonic(), so underscores in @label indicate the
// mnemonic for the button.
/*

C function : gtk_radio_button_new_with_mnemonic
*/
func RadioButtonNewWithMnemonic(group *glib.SList, label string) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_mnemonic(c_group, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioButton containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the button.
/*

C function : gtk_radio_button_new_with_mnemonic_from_widget
*/
func RadioButtonNewWithMnemonicFromWidget(radioGroupMember *RadioButton, label string) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_mnemonic_from_widget(c_radio_group_member, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the group assigned to a radio button.
/*

C function : gtk_radio_button_get_group
*/
func (recv *RadioButton) GetGroup() *glib.SList {
	retC := C.gtk_radio_button_get_group((*C.GtkRadioButton)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets a #GtkRadioButton’s group. It should be noted that this does not change
// the layout of your interface in any way, so if you are changing the group,
// it is likely you will need to re-arrange the user interface to reflect these
// changes.
/*

C function : gtk_radio_button_set_group
*/
func (recv *RadioButton) SetGroup(group *glib.SList) {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	C.gtk_radio_button_set_group((*C.GtkRadioButton)(recv.native), c_group)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioButton
func (recv *RadioButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioButton
func (recv *RadioButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioButton
func (recv *RadioButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioButton
func (recv *RadioButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioButtonAccessible is a wrapper around the C record GtkRadioButtonAccessible.
type RadioButtonAccessible struct {
	native *C.GtkRadioButtonAccessible
	// parent : record
	// priv : record
}

func RadioButtonAccessibleNewFromC(u unsafe.Pointer) *RadioButtonAccessible {
	c := (*C.GtkRadioButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RadioButtonAccessible{native: c}

	return g
}

func (recv *RadioButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleButtonAccessible upcasts to *ToggleButtonAccessible
func (recv *RadioButtonAccessible) ToggleButtonAccessible() *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *RadioButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return recv.ToggleButtonAccessible().ButtonAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *RadioButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ToggleButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RadioButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ToggleButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *RadioButtonAccessible) Accessible() *Accessible {
	return recv.ToggleButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RadioButtonAccessible) Object() *atk.Object {
	return recv.ToggleButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to RadioButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioButtonAccessible.
func CastToRadioButtonAccessible(object *gobject.Object) *RadioButtonAccessible {
	return RadioButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// RadioMenuItem is a wrapper around the C record GtkRadioMenuItem.
type RadioMenuItem struct {
	native *C.GtkRadioMenuItem
	// check_menu_item : record
	// Private : priv
}

func RadioMenuItemNewFromC(u unsafe.Pointer) *RadioMenuItem {
	c := (*C.GtkRadioMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItem{native: c}

	return g
}

func (recv *RadioMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CheckMenuItem upcasts to *CheckMenuItem
func (recv *RadioMenuItem) CheckMenuItem() *CheckMenuItem {
	return CheckMenuItemNewFromC(unsafe.Pointer(recv.native))
}

// MenuItem upcasts to *MenuItem
func (recv *RadioMenuItem) MenuItem() *MenuItem {
	return recv.CheckMenuItem().MenuItem()
}

// Bin upcasts to *Bin
func (recv *RadioMenuItem) Bin() *Bin {
	return recv.CheckMenuItem().Bin()
}

// Container upcasts to *Container
func (recv *RadioMenuItem) Container() *Container {
	return recv.CheckMenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *RadioMenuItem) Widget() *Widget {
	return recv.CheckMenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CheckMenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioMenuItem) Object() *gobject.Object {
	return recv.CheckMenuItem().Object()
}

// CastToWidget down casts any arbitary Object to RadioMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioMenuItem.
func CastToRadioMenuItem(object *gobject.Object) *RadioMenuItem {
	return RadioMenuItemNewFromC(object.ToC())
}

type signalRadioMenuItemGroupChangedDetail struct {
	callback  RadioMenuItemSignalGroupChangedCallback
	handlerID C.gulong
}

var signalRadioMenuItemGroupChangedId int
var signalRadioMenuItemGroupChangedMap = make(map[int]signalRadioMenuItemGroupChangedDetail)
var signalRadioMenuItemGroupChangedLock sync.Mutex

// RadioMenuItemSignalGroupChangedCallback is a callback function for a 'group-changed' signal emitted from a RadioMenuItem.
type RadioMenuItemSignalGroupChangedCallback func()

/*
ConnectGroupChanged connects the callback to the 'group-changed' signal for the RadioMenuItem.

The returned value represents the connection, and may be passed to DisconnectGroupChanged to remove it.
*/
func (recv *RadioMenuItem) ConnectGroupChanged(callback RadioMenuItemSignalGroupChangedCallback) int {
	signalRadioMenuItemGroupChangedLock.Lock()
	defer signalRadioMenuItemGroupChangedLock.Unlock()

	signalRadioMenuItemGroupChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RadioMenuItem_signal_connect_group_changed(instance, C.gpointer(uintptr(signalRadioMenuItemGroupChangedId)))

	detail := signalRadioMenuItemGroupChangedDetail{callback, handlerID}
	signalRadioMenuItemGroupChangedMap[signalRadioMenuItemGroupChangedId] = detail

	return signalRadioMenuItemGroupChangedId
}

/*
DisconnectGroupChanged disconnects a callback from the 'group-changed' signal for the RadioMenuItem.

The connectionID should be a value returned from a call to ConnectGroupChanged.
*/
func (recv *RadioMenuItem) DisconnectGroupChanged(connectionID int) {
	signalRadioMenuItemGroupChangedLock.Lock()
	defer signalRadioMenuItemGroupChangedLock.Unlock()

	detail, exists := signalRadioMenuItemGroupChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRadioMenuItemGroupChangedMap, connectionID)
}

//export radiomenuitem_groupChangedHandler
func radiomenuitem_groupChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalRadioMenuItemGroupChangedMap[index].callback
	callback()
}

// Creates a new #GtkRadioMenuItem.
/*

C function : gtk_radio_menu_item_new
*/
func RadioMenuItemNew(group *glib.SList) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	retC := C.gtk_radio_menu_item_new(c_group)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioMenuItem whose child is a simple #GtkLabel.
/*

C function : gtk_radio_menu_item_new_with_label
*/
func RadioMenuItemNewWithLabel(group *glib.SList, label string) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_menu_item_new_with_label(c_group, c_label)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkRadioMenuItem containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the menu item.
/*

C function : gtk_radio_menu_item_new_with_mnemonic
*/
func RadioMenuItemNewWithMnemonic(group *glib.SList, label string) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_menu_item_new_with_mnemonic(c_group, c_label)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the group to which the radio menu item belongs, as a #GList of
// #GtkRadioMenuItem. The list belongs to GTK+ and should not be freed.
/*

C function : gtk_radio_menu_item_get_group
*/
func (recv *RadioMenuItem) GetGroup() *glib.SList {
	retC := C.gtk_radio_menu_item_get_group((*C.GtkRadioMenuItem)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the group of a radio menu item, or changes it.
/*

C function : gtk_radio_menu_item_set_group
*/
func (recv *RadioMenuItem) SetGroup(group *glib.SList) {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	C.gtk_radio_menu_item_set_group((*C.GtkRadioMenuItem)(recv.native), c_group)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioMenuItem
func (recv *RadioMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioMenuItemAccessible is a wrapper around the C record GtkRadioMenuItemAccessible.
type RadioMenuItemAccessible struct {
	native *C.GtkRadioMenuItemAccessible
	// parent : record
	// priv : record
}

func RadioMenuItemAccessibleNewFromC(u unsafe.Pointer) *RadioMenuItemAccessible {
	c := (*C.GtkRadioMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItemAccessible{native: c}

	return g
}

func (recv *RadioMenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CheckMenuItemAccessible upcasts to *CheckMenuItemAccessible
func (recv *RadioMenuItemAccessible) CheckMenuItemAccessible() *CheckMenuItemAccessible {
	return CheckMenuItemAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// MenuItemAccessible upcasts to *MenuItemAccessible
func (recv *RadioMenuItemAccessible) MenuItemAccessible() *MenuItemAccessible {
	return recv.CheckMenuItemAccessible().MenuItemAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *RadioMenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.CheckMenuItemAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RadioMenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.CheckMenuItemAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *RadioMenuItemAccessible) Accessible() *Accessible {
	return recv.CheckMenuItemAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RadioMenuItemAccessible) Object() *atk.Object {
	return recv.CheckMenuItemAccessible().Object()
}

// CastToWidget down casts any arbitary Object to RadioMenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioMenuItemAccessible.
func CastToRadioMenuItemAccessible(object *gobject.Object) *RadioMenuItemAccessible {
	return RadioMenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// RadioToolButton is a wrapper around the C record GtkRadioToolButton.
type RadioToolButton struct {
	native *C.GtkRadioToolButton
	// parent : record
}

func RadioToolButtonNewFromC(u unsafe.Pointer) *RadioToolButton {
	c := (*C.GtkRadioToolButton)(u)
	if c == nil {
		return nil
	}

	g := &RadioToolButton{native: c}

	return g
}

func (recv *RadioToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToggleToolButton upcasts to *ToggleToolButton
func (recv *RadioToolButton) ToggleToolButton() *ToggleToolButton {
	return ToggleToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolButton upcasts to *ToolButton
func (recv *RadioToolButton) ToolButton() *ToolButton {
	return recv.ToggleToolButton().ToolButton()
}

// ToolItem upcasts to *ToolItem
func (recv *RadioToolButton) ToolItem() *ToolItem {
	return recv.ToggleToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *RadioToolButton) Bin() *Bin {
	return recv.ToggleToolButton().Bin()
}

// Container upcasts to *Container
func (recv *RadioToolButton) Container() *Container {
	return recv.ToggleToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *RadioToolButton) Widget() *Widget {
	return recv.ToggleToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioToolButton) Object() *gobject.Object {
	return recv.ToggleToolButton().Object()
}

// CastToWidget down casts any arbitary Object to RadioToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioToolButton.
func CastToRadioToolButton(object *gobject.Object) *RadioToolButton {
	return RadioToolButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioToolButton
func (recv *RadioToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioToolButton
func (recv *RadioToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioToolButton
func (recv *RadioToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioToolButton
func (recv *RadioToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Range is a wrapper around the C record GtkRange.
type Range struct {
	native *C.GtkRange
	// widget : record
	// priv : record
}

func RangeNewFromC(u unsafe.Pointer) *Range {
	c := (*C.GtkRange)(u)
	if c == nil {
		return nil
	}

	g := &Range{native: c}

	return g
}

func (recv *Range) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Range) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Range) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Range) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Range.
// Exercise care, as this is a potentially dangerous function if the Object is not a Range.
func CastToRange(object *gobject.Object) *Range {
	return RangeNewFromC(object.ToC())
}

// Unsupported signal 'adjust-bounds' for Range : unsupported parameter value : type gdouble :

// Unsupported signal 'move-slider' for Range : unsupported parameter step : type ScrollType :

type signalRangeValueChangedDetail struct {
	callback  RangeSignalValueChangedCallback
	handlerID C.gulong
}

var signalRangeValueChangedId int
var signalRangeValueChangedMap = make(map[int]signalRangeValueChangedDetail)
var signalRangeValueChangedLock sync.Mutex

// RangeSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a Range.
type RangeSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *Range) ConnectValueChanged(callback RangeSignalValueChangedCallback) int {
	signalRangeValueChangedLock.Lock()
	defer signalRangeValueChangedLock.Unlock()

	signalRangeValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_value_changed(instance, C.gpointer(uintptr(signalRangeValueChangedId)))

	detail := signalRangeValueChangedDetail{callback, handlerID}
	signalRangeValueChangedMap[signalRangeValueChangedId] = detail

	return signalRangeValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the Range.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *Range) DisconnectValueChanged(connectionID int) {
	signalRangeValueChangedLock.Lock()
	defer signalRangeValueChangedLock.Unlock()

	detail, exists := signalRangeValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeValueChangedMap, connectionID)
}

//export range_valueChangedHandler
func range_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalRangeValueChangedMap[index].callback
	callback()
}

// Get the #GtkAdjustment which is the “model” object for #GtkRange.
// See gtk_range_set_adjustment() for details.
// The return value does not have a reference added, so should not
// be unreferenced.
/*

C function : gtk_range_get_adjustment
*/
func (recv *Range) GetAdjustment() *Adjustment {
	retC := C.gtk_range_get_adjustment((*C.GtkRange)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the value set by gtk_range_set_inverted().
/*

C function : gtk_range_get_inverted
*/
func (recv *Range) GetInverted() bool {
	retC := C.gtk_range_get_inverted((*C.GtkRange)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the current value of the range.
/*

C function : gtk_range_get_value
*/
func (recv *Range) GetValue() float64 {
	retC := C.gtk_range_get_value((*C.GtkRange)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Sets the adjustment to be used as the “model” object for this range
// widget. The adjustment indicates the current range value, the
// minimum and maximum range values, the step/page increments used
// for keybindings and scrolling, and the page size. The page size
// is normally 0 for #GtkScale and nonzero for #GtkScrollbar, and
// indicates the size of the visible area of the widget being scrolled.
// The page size affects the size of the scrollbar slider.
/*

C function : gtk_range_set_adjustment
*/
func (recv *Range) SetAdjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_range_set_adjustment((*C.GtkRange)(recv.native), c_adjustment)

	return
}

// Sets the step and page sizes for the range.
// The step size is used when the user clicks the #GtkScrollbar
// arrows or moves #GtkScale via arrow keys. The page size
// is used for example when moving via Page Up or Page Down keys.
/*

C function : gtk_range_set_increments
*/
func (recv *Range) SetIncrements(step float64, page float64) {
	c_step := (C.gdouble)(step)

	c_page := (C.gdouble)(page)

	C.gtk_range_set_increments((*C.GtkRange)(recv.native), c_step, c_page)

	return
}

// Ranges normally move from lower to higher values as the
// slider moves from top to bottom or left to right. Inverted
// ranges have higher values at the top or on the right rather than
// on the bottom or left.
/*

C function : gtk_range_set_inverted
*/
func (recv *Range) SetInverted(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_range_set_inverted((*C.GtkRange)(recv.native), c_setting)

	return
}

// Sets the allowable values in the #GtkRange, and clamps the range
// value to be between @min and @max. (If the range has a non-zero
// page size, it is clamped between @min and @max - page-size.)
/*

C function : gtk_range_set_range
*/
func (recv *Range) SetRange(min float64, max float64) {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	C.gtk_range_set_range((*C.GtkRange)(recv.native), c_min, c_max)

	return
}

// Sets the current value of the range; if the value is outside the
// minimum or maximum range values, it will be clamped to fit inside
// them. The range emits the #GtkRange::value-changed signal if the
// value changes.
/*

C function : gtk_range_set_value
*/
func (recv *Range) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_range_set_value((*C.GtkRange)(recv.native), c_value)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Range
func (recv *Range) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Range
func (recv *Range) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Range
func (recv *Range) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// RangeAccessible is a wrapper around the C record GtkRangeAccessible.
type RangeAccessible struct {
	native *C.GtkRangeAccessible
	// parent : record
	// priv : record
}

func RangeAccessibleNewFromC(u unsafe.Pointer) *RangeAccessible {
	c := (*C.GtkRangeAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RangeAccessible{native: c}

	return g
}

func (recv *RangeAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RangeAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *RangeAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RangeAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to RangeAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RangeAccessible.
func CastToRangeAccessible(object *gobject.Object) *RangeAccessible {
	return RangeAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by RangeAccessible
func (recv *RangeAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by RangeAccessible
func (recv *RangeAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// RcStyle is a wrapper around the C record GtkRcStyle.
type RcStyle struct {
	native *C.GtkRcStyle
	// parent_instance : record
	Name string
	// no type for bg_pixmap_name
	// font_desc : record
	// no type for color_flags
	// no type for fg
	// no type for bg
	// no type for text
	// no type for base
	Xthickness int32
	Ythickness int32
	// Private : rc_properties
	// Private : rc_style_lists
	// Private : icon_factories
	// Private : engine_specified
}

func RcStyleNewFromC(u unsafe.Pointer) *RcStyle {
	c := (*C.GtkRcStyle)(u)
	if c == nil {
		return nil
	}

	g := &RcStyle{
		Name:       C.GoString(c.name),
		Xthickness: (int32)(c.xthickness),
		Ythickness: (int32)(c.ythickness),
		native:     c,
	}

	return g
}

func (recv *RcStyle) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native.xthickness =
		(C.gint)(recv.Xthickness)
	recv.native.ythickness =
		(C.gint)(recv.Ythickness)

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *RcStyle) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to RcStyle.
// Exercise care, as this is a potentially dangerous function if the Object is not a RcStyle.
func CastToRcStyle(object *gobject.Object) *RcStyle {
	return RcStyleNewFromC(object.ToC())
}

// Creates a new #GtkRcStyle with no fields set and
// a reference count of 1.
/*

C function : gtk_rc_style_new
*/
func RcStyleNew() *RcStyle {
	retC := C.gtk_rc_style_new()
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Makes a copy of the specified #GtkRcStyle. This function
// will correctly copy an RC style that is a member of a class
// derived from #GtkRcStyle.
/*

C function : gtk_rc_style_copy
*/
func (recv *RcStyle) Copy() *RcStyle {
	retC := C.gtk_rc_style_copy((*C.GtkRcStyle)(recv.native))
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RecentAction is a wrapper around the C record GtkRecentAction.
type RecentAction struct {
	native *C.GtkRecentAction
	// parent_instance : record
	// Private : priv
}

func RecentActionNewFromC(u unsafe.Pointer) *RecentAction {
	c := (*C.GtkRecentAction)(u)
	if c == nil {
		return nil
	}

	g := &RecentAction{native: c}

	return g
}

func (recv *RecentAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Action upcasts to *Action
func (recv *RecentAction) Action() *Action {
	return ActionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *RecentAction) Object() *gobject.Object {
	return recv.Action().Object()
}

// CastToWidget down casts any arbitary Object to RecentAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentAction.
func CastToRecentAction(object *gobject.Object) *RecentAction {
	return RecentActionNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RecentAction
func (recv *RecentAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentAction
func (recv *RecentAction) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserDialog is a wrapper around the C record GtkRecentChooserDialog.
type RecentChooserDialog struct {
	native *C.GtkRecentChooserDialog
	// parent_instance : record
	// Private : priv
}

func RecentChooserDialogNewFromC(u unsafe.Pointer) *RecentChooserDialog {
	c := (*C.GtkRecentChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserDialog{native: c}

	return g
}

func (recv *RecentChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Dialog upcasts to *Dialog
func (recv *RecentChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *RecentChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *RecentChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *RecentChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitary Object to RecentChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserDialog.
func CastToRecentChooserDialog(object *gobject.Object) *RecentChooserDialog {
	return RecentChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserMenu is a wrapper around the C record GtkRecentChooserMenu.
type RecentChooserMenu struct {
	native *C.GtkRecentChooserMenu
	// parent_instance : record
	// Private : priv
}

func RecentChooserMenuNewFromC(u unsafe.Pointer) *RecentChooserMenu {
	c := (*C.GtkRecentChooserMenu)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserMenu{native: c}

	return g
}

func (recv *RecentChooserMenu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Menu upcasts to *Menu
func (recv *RecentChooserMenu) Menu() *Menu {
	return MenuNewFromC(unsafe.Pointer(recv.native))
}

// MenuShell upcasts to *MenuShell
func (recv *RecentChooserMenu) MenuShell() *MenuShell {
	return recv.Menu().MenuShell()
}

// Container upcasts to *Container
func (recv *RecentChooserMenu) Container() *Container {
	return recv.Menu().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserMenu) Widget() *Widget {
	return recv.Menu().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserMenu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Menu().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserMenu) Object() *gobject.Object {
	return recv.Menu().Object()
}

// CastToWidget down casts any arbitary Object to RecentChooserMenu.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserMenu.
func CastToRecentChooserMenu(object *gobject.Object) *RecentChooserMenu {
	return RecentChooserMenuNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserWidget is a wrapper around the C record GtkRecentChooserWidget.
type RecentChooserWidget struct {
	native *C.GtkRecentChooserWidget
	// parent_instance : record
	// Private : priv
}

func RecentChooserWidgetNewFromC(u unsafe.Pointer) *RecentChooserWidget {
	c := (*C.GtkRecentChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserWidget{native: c}

	return g
}

func (recv *RecentChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *RecentChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *RecentChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to RecentChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserWidget.
func CastToRecentChooserWidget(object *gobject.Object) *RecentChooserWidget {
	return RecentChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentFilter is a wrapper around the C record GtkRecentFilter.
type RecentFilter struct {
	native *C.GtkRecentFilter
}

func RecentFilterNewFromC(u unsafe.Pointer) *RecentFilter {
	c := (*C.GtkRecentFilter)(u)
	if c == nil {
		return nil
	}

	g := &RecentFilter{native: c}

	return g
}

func (recv *RecentFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentFilter) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *RecentFilter) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to RecentFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentFilter.
func CastToRecentFilter(object *gobject.Object) *RecentFilter {
	return RecentFilterNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by RecentFilter
func (recv *RecentFilter) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RendererCellAccessible is a wrapper around the C record GtkRendererCellAccessible.
type RendererCellAccessible struct {
	native *C.GtkRendererCellAccessible
	// parent : record
	// priv : record
}

func RendererCellAccessibleNewFromC(u unsafe.Pointer) *RendererCellAccessible {
	c := (*C.GtkRendererCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RendererCellAccessible{native: c}

	return g
}

func (recv *RendererCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// CellAccessible upcasts to *CellAccessible
func (recv *RendererCellAccessible) CellAccessible() *CellAccessible {
	return CellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *RendererCellAccessible) Accessible() *Accessible {
	return recv.CellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RendererCellAccessible) Object() *atk.Object {
	return recv.CellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to RendererCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RendererCellAccessible.
func CastToRendererCellAccessible(object *gobject.Object) *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(object.ToC())
}

/*

C function : gtk_renderer_cell_accessible_new
*/
func RendererCellAccessibleNew(renderer *CellRenderer) *RendererCellAccessible {
	c_renderer := (*C.GtkCellRenderer)(C.NULL)
	if renderer != nil {
		c_renderer = (*C.GtkCellRenderer)(renderer.ToC())
	}

	retC := C.gtk_renderer_cell_accessible_new(c_renderer)
	retGo := RendererCellAccessibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Action returns the Action interface implemented by RendererCellAccessible
func (recv *RendererCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RendererCellAccessible
func (recv *RendererCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Revealer is a wrapper around the C record GtkRevealer.
type Revealer struct {
	native *C.GtkRevealer
	// parent_instance : record
}

func RevealerNewFromC(u unsafe.Pointer) *Revealer {
	c := (*C.GtkRevealer)(u)
	if c == nil {
		return nil
	}

	g := &Revealer{native: c}

	return g
}

func (recv *Revealer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Revealer) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Revealer) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Revealer) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Revealer) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Revealer) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Revealer.
// Exercise care, as this is a potentially dangerous function if the Object is not a Revealer.
func CastToRevealer(object *gobject.Object) *Revealer {
	return RevealerNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Revealer
func (recv *Revealer) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Revealer
func (recv *Revealer) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scale is a wrapper around the C record GtkScale.
type Scale struct {
	native *C.GtkScale
	// range : record
	// Private : priv
}

func ScaleNewFromC(u unsafe.Pointer) *Scale {
	c := (*C.GtkScale)(u)
	if c == nil {
		return nil
	}

	g := &Scale{native: c}

	return g
}

func (recv *Scale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Range upcasts to *Range
func (recv *Scale) Range() *Range {
	return RangeNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Scale) Widget() *Widget {
	return recv.Range().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Scale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Range().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Scale) Object() *gobject.Object {
	return recv.Range().Object()
}

// CastToWidget down casts any arbitary Object to Scale.
// Exercise care, as this is a potentially dangerous function if the Object is not a Scale.
func CastToScale(object *gobject.Object) *Scale {
	return ScaleNewFromC(object.ToC())
}

// Unsupported signal 'format-value' for Scale : unsupported parameter value : type gdouble :

// Gets the number of decimal places that are displayed in the value.
/*

C function : gtk_scale_get_digits
*/
func (recv *Scale) GetDigits() int32 {
	retC := C.gtk_scale_get_digits((*C.GtkScale)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns whether the current value is displayed as a string
// next to the slider.
/*

C function : gtk_scale_get_draw_value
*/
func (recv *Scale) GetDrawValue() bool {
	retC := C.gtk_scale_get_draw_value((*C.GtkScale)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the position in which the current value is displayed.
/*

C function : gtk_scale_get_value_pos
*/
func (recv *Scale) GetValuePos() PositionType {
	retC := C.gtk_scale_get_value_pos((*C.GtkScale)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// Sets the number of decimal places that are displayed in the value. Also
// causes the value of the adjustment to be rounded to this number of digits,
// so the retrieved value matches the displayed one, if #GtkScale:draw-value is
// %TRUE when the value changes. If you want to enforce rounding the value when
// #GtkScale:draw-value is %FALSE, you can set #GtkRange:round-digits instead.
//
// Note that rounding to a small number of digits can interfere with
// the smooth autoscrolling that is built into #GtkScale. As an alternative,
// you can use the #GtkScale::format-value signal to format the displayed
// value yourself.
/*

C function : gtk_scale_set_digits
*/
func (recv *Scale) SetDigits(digits int32) {
	c_digits := (C.gint)(digits)

	C.gtk_scale_set_digits((*C.GtkScale)(recv.native), c_digits)

	return
}

// Specifies whether the current value is displayed as a string next
// to the slider.
/*

C function : gtk_scale_set_draw_value
*/
func (recv *Scale) SetDrawValue(drawValue bool) {
	c_draw_value :=
		boolToGboolean(drawValue)

	C.gtk_scale_set_draw_value((*C.GtkScale)(recv.native), c_draw_value)

	return
}

// Sets the position in which the current value is displayed.
/*

C function : gtk_scale_set_value_pos
*/
func (recv *Scale) SetValuePos(pos PositionType) {
	c_pos := (C.GtkPositionType)(pos)

	C.gtk_scale_set_value_pos((*C.GtkScale)(recv.native), c_pos)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Scale
func (recv *Scale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Scale
func (recv *Scale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Scale
func (recv *Scale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScaleAccessible is a wrapper around the C record GtkScaleAccessible.
type ScaleAccessible struct {
	native *C.GtkScaleAccessible
	// parent : record
	// priv : record
}

func ScaleAccessibleNewFromC(u unsafe.Pointer) *ScaleAccessible {
	c := (*C.GtkScaleAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScaleAccessible{native: c}

	return g
}

func (recv *ScaleAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// RangeAccessible upcasts to *RangeAccessible
func (recv *ScaleAccessible) RangeAccessible() *RangeAccessible {
	return RangeAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScaleAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.RangeAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScaleAccessible) Accessible() *Accessible {
	return recv.RangeAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScaleAccessible) Object() *atk.Object {
	return recv.RangeAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ScaleAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleAccessible.
func CastToScaleAccessible(object *gobject.Object) *ScaleAccessible {
	return ScaleAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ScaleAccessible
func (recv *ScaleAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ScaleAccessible
func (recv *ScaleAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// ScaleButton is a wrapper around the C record GtkScaleButton.
type ScaleButton struct {
	native *C.GtkScaleButton
	// parent : record
	// Private : priv
}

func ScaleButtonNewFromC(u unsafe.Pointer) *ScaleButton {
	c := (*C.GtkScaleButton)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButton{native: c}

	return g
}

func (recv *ScaleButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *ScaleButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ScaleButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ScaleButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ScaleButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ScaleButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ScaleButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to ScaleButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleButton.
func CastToScaleButton(object *gobject.Object) *ScaleButton {
	return ScaleButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ScaleButton
func (recv *ScaleButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ScaleButton
func (recv *ScaleButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ScaleButton
func (recv *ScaleButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ScaleButton
func (recv *ScaleButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ScaleButton
func (recv *ScaleButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScaleButtonAccessible is a wrapper around the C record GtkScaleButtonAccessible.
type ScaleButtonAccessible struct {
	native *C.GtkScaleButtonAccessible
	// parent : record
	// priv : record
}

func ScaleButtonAccessibleNewFromC(u unsafe.Pointer) *ScaleButtonAccessible {
	c := (*C.GtkScaleButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButtonAccessible{native: c}

	return g
}

func (recv *ScaleButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *ScaleButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ScaleButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScaleButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScaleButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScaleButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ScaleButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleButtonAccessible.
func CastToScaleButtonAccessible(object *gobject.Object) *ScaleButtonAccessible {
	return ScaleButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// Scrollbar is a wrapper around the C record GtkScrollbar.
type Scrollbar struct {
	native *C.GtkScrollbar
	// range : record
}

func ScrollbarNewFromC(u unsafe.Pointer) *Scrollbar {
	c := (*C.GtkScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &Scrollbar{native: c}

	return g
}

func (recv *Scrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Range upcasts to *Range
func (recv *Scrollbar) Range() *Range {
	return RangeNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Scrollbar) Widget() *Widget {
	return recv.Range().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Scrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Range().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Scrollbar) Object() *gobject.Object {
	return recv.Range().Object()
}

// CastToWidget down casts any arbitary Object to Scrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Scrollbar.
func CastToScrollbar(object *gobject.Object) *Scrollbar {
	return ScrollbarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Scrollbar
func (recv *Scrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Scrollbar
func (recv *Scrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Scrollbar
func (recv *Scrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScrolledWindow is a wrapper around the C record GtkScrolledWindow.
type ScrolledWindow struct {
	native *C.GtkScrolledWindow
	// container : record
	// priv : record
}

func ScrolledWindowNewFromC(u unsafe.Pointer) *ScrolledWindow {
	c := (*C.GtkScrolledWindow)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindow{native: c}

	return g
}

func (recv *ScrolledWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ScrolledWindow) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ScrolledWindow) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ScrolledWindow) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ScrolledWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ScrolledWindow) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ScrolledWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScrolledWindow.
func CastToScrolledWindow(object *gobject.Object) *ScrolledWindow {
	return ScrolledWindowNewFromC(object.ToC())
}

// Unsupported signal 'move-focus-out' for ScrolledWindow : unsupported parameter direction_type : type DirectionType :

// Unsupported signal 'scroll-child' for ScrolledWindow : unsupported parameter scroll : type ScrollType :

// Creates a new scrolled window.
//
// The two arguments are the scrolled window’s adjustments; these will be
// shared with the scrollbars and the child widget to keep the bars in sync
// with the child. Usually you want to pass %NULL for the adjustments, which
// will cause the scrolled window to create them for you.
/*

C function : gtk_scrolled_window_new
*/
func ScrolledWindowNew(hadjustment *Adjustment, vadjustment *Adjustment) *ScrolledWindow {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_scrolled_window_new(c_hadjustment, c_vadjustment)
	retGo := ScrolledWindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Used to add children without native scrolling capabilities. This
// is simply a convenience function; it is equivalent to adding the
// unscrollable child to a viewport, then adding the viewport to the
// scrolled window. If a child has native scrolling, use
// gtk_container_add() instead of this function.
//
// The viewport scrolls the child by moving its #GdkWindow, and takes
// the size of the child to be the size of its toplevel #GdkWindow.
// This will be very wrong for most widgets that support native scrolling;
// for example, if you add a widget such as #GtkTreeView with a viewport,
// the whole widget will scroll, including the column headings. Thus,
// widgets with native scrolling support should not be used with the
// #GtkViewport proxy.
//
// A widget supports scrolling natively if it implements the
// #GtkScrollable interface.
/*

C function : gtk_scrolled_window_add_with_viewport
*/
func (recv *ScrolledWindow) AddWithViewport(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_scrolled_window_add_with_viewport((*C.GtkScrolledWindow)(recv.native), c_child)

	return
}

// Returns the horizontal scrollbar’s adjustment, used to connect the
// horizontal scrollbar to the child widget’s horizontal scroll
// functionality.
/*

C function : gtk_scrolled_window_get_hadjustment
*/
func (recv *ScrolledWindow) GetHadjustment() *Adjustment {
	retC := C.gtk_scrolled_window_get_hadjustment((*C.GtkScrolledWindow)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the placement of the contents with respect to the scrollbars
// for the scrolled window. See gtk_scrolled_window_set_placement().
/*

C function : gtk_scrolled_window_get_placement
*/
func (recv *ScrolledWindow) GetPlacement() CornerType {
	retC := C.gtk_scrolled_window_get_placement((*C.GtkScrolledWindow)(recv.native))
	retGo := (CornerType)(retC)

	return retGo
}

// Unsupported : gtk_scrolled_window_get_policy : unsupported parameter hscrollbar_policy : GtkPolicyType* with indirection level of 1

// Gets the shadow type of the scrolled window. See
// gtk_scrolled_window_set_shadow_type().
/*

C function : gtk_scrolled_window_get_shadow_type
*/
func (recv *ScrolledWindow) GetShadowType() ShadowType {
	retC := C.gtk_scrolled_window_get_shadow_type((*C.GtkScrolledWindow)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// Returns the vertical scrollbar’s adjustment, used to connect the
// vertical scrollbar to the child widget’s vertical scroll functionality.
/*

C function : gtk_scrolled_window_get_vadjustment
*/
func (recv *ScrolledWindow) GetVadjustment() *Adjustment {
	retC := C.gtk_scrolled_window_get_vadjustment((*C.GtkScrolledWindow)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the #GtkAdjustment for the horizontal scrollbar.
/*

C function : gtk_scrolled_window_set_hadjustment
*/
func (recv *ScrolledWindow) SetHadjustment(hadjustment *Adjustment) {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	C.gtk_scrolled_window_set_hadjustment((*C.GtkScrolledWindow)(recv.native), c_hadjustment)

	return
}

// Sets the placement of the contents with respect to the scrollbars
// for the scrolled window.
//
// The default is %GTK_CORNER_TOP_LEFT, meaning the child is
// in the top left, with the scrollbars underneath and to the right.
// Other values in #GtkCornerType are %GTK_CORNER_TOP_RIGHT,
// %GTK_CORNER_BOTTOM_LEFT, and %GTK_CORNER_BOTTOM_RIGHT.
//
// See also gtk_scrolled_window_get_placement() and
// gtk_scrolled_window_unset_placement().
/*

C function : gtk_scrolled_window_set_placement
*/
func (recv *ScrolledWindow) SetPlacement(windowPlacement CornerType) {
	c_window_placement := (C.GtkCornerType)(windowPlacement)

	C.gtk_scrolled_window_set_placement((*C.GtkScrolledWindow)(recv.native), c_window_placement)

	return
}

// Sets the scrollbar policy for the horizontal and vertical scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value
// from the #GtkPolicyType enumeration. If %GTK_POLICY_ALWAYS, the
// scrollbar is always present; if %GTK_POLICY_NEVER, the scrollbar is
// never present; if %GTK_POLICY_AUTOMATIC, the scrollbar is present only
// if needed (that is, if the slider part of the bar would be smaller
// than the trough — the display is larger than the page size).
/*

C function : gtk_scrolled_window_set_policy
*/
func (recv *ScrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	c_hscrollbar_policy := (C.GtkPolicyType)(hscrollbarPolicy)

	c_vscrollbar_policy := (C.GtkPolicyType)(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy((*C.GtkScrolledWindow)(recv.native), c_hscrollbar_policy, c_vscrollbar_policy)

	return
}

// Changes the type of shadow drawn around the contents of
// @scrolled_window.
/*

C function : gtk_scrolled_window_set_shadow_type
*/
func (recv *ScrolledWindow) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_scrolled_window_set_shadow_type((*C.GtkScrolledWindow)(recv.native), c_type)

	return
}

// Sets the #GtkAdjustment for the vertical scrollbar.
/*

C function : gtk_scrolled_window_set_vadjustment
*/
func (recv *ScrolledWindow) SetVadjustment(vadjustment *Adjustment) {
	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	C.gtk_scrolled_window_set_vadjustment((*C.GtkScrolledWindow)(recv.native), c_vadjustment)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ScrolledWindow
func (recv *ScrolledWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ScrolledWindow
func (recv *ScrolledWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ScrolledWindowAccessible is a wrapper around the C record GtkScrolledWindowAccessible.
type ScrolledWindowAccessible struct {
	native *C.GtkScrolledWindowAccessible
	// parent : record
	// priv : record
}

func ScrolledWindowAccessibleNewFromC(u unsafe.Pointer) *ScrolledWindowAccessible {
	c := (*C.GtkScrolledWindowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindowAccessible{native: c}

	return g
}

func (recv *ScrolledWindowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ScrolledWindowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScrolledWindowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScrolledWindowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScrolledWindowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ScrolledWindowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScrolledWindowAccessible.
func CastToScrolledWindowAccessible(object *gobject.Object) *ScrolledWindowAccessible {
	return ScrolledWindowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ScrolledWindowAccessible
func (recv *ScrolledWindowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// SearchBar is a wrapper around the C record GtkSearchBar.
type SearchBar struct {
	native *C.GtkSearchBar
	// Private : parent
}

func SearchBarNewFromC(u unsafe.Pointer) *SearchBar {
	c := (*C.GtkSearchBar)(u)
	if c == nil {
		return nil
	}

	g := &SearchBar{native: c}

	return g
}

func (recv *SearchBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *SearchBar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *SearchBar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *SearchBar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SearchBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SearchBar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to SearchBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a SearchBar.
func CastToSearchBar(object *gobject.Object) *SearchBar {
	return SearchBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SearchBar
func (recv *SearchBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SearchBar
func (recv *SearchBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SearchEntry is a wrapper around the C record GtkSearchEntry.
type SearchEntry struct {
	native *C.GtkSearchEntry
	// parent : record
}

func SearchEntryNewFromC(u unsafe.Pointer) *SearchEntry {
	c := (*C.GtkSearchEntry)(u)
	if c == nil {
		return nil
	}

	g := &SearchEntry{native: c}

	return g
}

func (recv *SearchEntry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Entry upcasts to *Entry
func (recv *SearchEntry) Entry() *Entry {
	return EntryNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *SearchEntry) Widget() *Widget {
	return recv.Entry().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SearchEntry) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Entry().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SearchEntry) Object() *gobject.Object {
	return recv.Entry().Object()
}

// CastToWidget down casts any arbitary Object to SearchEntry.
// Exercise care, as this is a potentially dangerous function if the Object is not a SearchEntry.
func CastToSearchEntry(object *gobject.Object) *SearchEntry {
	return SearchEntryNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SearchEntry
func (recv *SearchEntry) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SearchEntry
func (recv *SearchEntry) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by SearchEntry
func (recv *SearchEntry) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by SearchEntry
func (recv *SearchEntry) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// Separator is a wrapper around the C record GtkSeparator.
type Separator struct {
	native *C.GtkSeparator
	// widget : record
	// priv : record
}

func SeparatorNewFromC(u unsafe.Pointer) *Separator {
	c := (*C.GtkSeparator)(u)
	if c == nil {
		return nil
	}

	g := &Separator{native: c}

	return g
}

func (recv *Separator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Separator) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Separator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Separator) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Separator.
// Exercise care, as this is a potentially dangerous function if the Object is not a Separator.
func CastToSeparator(object *gobject.Object) *Separator {
	return SeparatorNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Separator
func (recv *Separator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Separator
func (recv *Separator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Separator
func (recv *Separator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// SeparatorMenuItem is a wrapper around the C record GtkSeparatorMenuItem.
type SeparatorMenuItem struct {
	native *C.GtkSeparatorMenuItem
	// menu_item : record
}

func SeparatorMenuItemNewFromC(u unsafe.Pointer) *SeparatorMenuItem {
	c := (*C.GtkSeparatorMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorMenuItem{native: c}

	return g
}

func (recv *SeparatorMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItem upcasts to *MenuItem
func (recv *SeparatorMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *SeparatorMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *SeparatorMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *SeparatorMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SeparatorMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SeparatorMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitary Object to SeparatorMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a SeparatorMenuItem.
func CastToSeparatorMenuItem(object *gobject.Object) *SeparatorMenuItem {
	return SeparatorMenuItemNewFromC(object.ToC())
}

// Creates a new #GtkSeparatorMenuItem.
/*

C function : gtk_separator_menu_item_new
*/
func SeparatorMenuItemNew() *SeparatorMenuItem {
	retC := C.gtk_separator_menu_item_new()
	retGo := SeparatorMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SeparatorToolItem is a wrapper around the C record GtkSeparatorToolItem.
type SeparatorToolItem struct {
	native *C.GtkSeparatorToolItem
	// parent : record
	// Private : priv
}

func SeparatorToolItemNewFromC(u unsafe.Pointer) *SeparatorToolItem {
	c := (*C.GtkSeparatorToolItem)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorToolItem{native: c}

	return g
}

func (recv *SeparatorToolItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToolItem upcasts to *ToolItem
func (recv *SeparatorToolItem) ToolItem() *ToolItem {
	return ToolItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *SeparatorToolItem) Bin() *Bin {
	return recv.ToolItem().Bin()
}

// Container upcasts to *Container
func (recv *SeparatorToolItem) Container() *Container {
	return recv.ToolItem().Container()
}

// Widget upcasts to *Widget
func (recv *SeparatorToolItem) Widget() *Widget {
	return recv.ToolItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SeparatorToolItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SeparatorToolItem) Object() *gobject.Object {
	return recv.ToolItem().Object()
}

// CastToWidget down casts any arbitary Object to SeparatorToolItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a SeparatorToolItem.
func CastToSeparatorToolItem(object *gobject.Object) *SeparatorToolItem {
	return SeparatorToolItemNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Settings is a wrapper around the C record GtkSettings.
type Settings struct {
	native *C.GtkSettings
	// parent_instance : record
	// Private : priv
}

func SettingsNewFromC(u unsafe.Pointer) *Settings {
	c := (*C.GtkSettings)(u)
	if c == nil {
		return nil
	}

	g := &Settings{native: c}

	return g
}

func (recv *Settings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Settings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Settings.
// Exercise care, as this is a potentially dangerous function if the Object is not a Settings.
func CastToSettings(object *gobject.Object) *Settings {
	return SettingsNewFromC(object.ToC())
}

/*

C function : gtk_settings_set_double_property
*/
func (recv *Settings) SetDoubleProperty(name string, vDouble float64, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_double := (C.gdouble)(vDouble)

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_double_property((*C.GtkSettings)(recv.native), c_name, c_v_double, c_origin)

	return
}

/*

C function : gtk_settings_set_long_property
*/
func (recv *Settings) SetLongProperty(name string, vLong int64, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_long := (C.glong)(vLong)

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_long_property((*C.GtkSettings)(recv.native), c_name, c_v_long, c_origin)

	return
}

/*

C function : gtk_settings_set_property_value
*/
func (recv *Settings) SetPropertyValue(name string, svalue *SettingsValue) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_svalue := (*C.GtkSettingsValue)(C.NULL)
	if svalue != nil {
		c_svalue = (*C.GtkSettingsValue)(svalue.ToC())
	}

	C.gtk_settings_set_property_value((*C.GtkSettings)(recv.native), c_name, c_svalue)

	return
}

/*

C function : gtk_settings_set_string_property
*/
func (recv *Settings) SetStringProperty(name string, vString string, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_string := C.CString(vString)
	defer C.free(unsafe.Pointer(c_v_string))

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_string_property((*C.GtkSettings)(recv.native), c_name, c_v_string, c_origin)

	return
}

// StyleProvider returns the StyleProvider interface implemented by Settings
func (recv *Settings) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// SizeGroup is a wrapper around the C record GtkSizeGroup.
type SizeGroup struct {
	native *C.GtkSizeGroup
	// parent_instance : record
	// Private : priv
}

func SizeGroupNewFromC(u unsafe.Pointer) *SizeGroup {
	c := (*C.GtkSizeGroup)(u)
	if c == nil {
		return nil
	}

	g := &SizeGroup{native: c}

	return g
}

func (recv *SizeGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *SizeGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to SizeGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a SizeGroup.
func CastToSizeGroup(object *gobject.Object) *SizeGroup {
	return SizeGroupNewFromC(object.ToC())
}

// Create a new #GtkSizeGroup.
/*

C function : gtk_size_group_new
*/
func SizeGroupNew(mode SizeGroupMode) *SizeGroup {
	c_mode := (C.GtkSizeGroupMode)(mode)

	retC := C.gtk_size_group_new(c_mode)
	retGo := SizeGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a widget to a #GtkSizeGroup. In the future, the requisition
// of the widget will be determined as the maximum of its requisition
// and the requisition of the other widgets in the size group.
// Whether this applies horizontally, vertically, or in both directions
// depends on the mode of the size group. See gtk_size_group_set_mode().
//
// When the widget is destroyed or no longer referenced elsewhere, it will
// be removed from the size group.
/*

C function : gtk_size_group_add_widget
*/
func (recv *SizeGroup) AddWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_size_group_add_widget((*C.GtkSizeGroup)(recv.native), c_widget)

	return
}

// Gets the current mode of the size group. See gtk_size_group_set_mode().
/*

C function : gtk_size_group_get_mode
*/
func (recv *SizeGroup) GetMode() SizeGroupMode {
	retC := C.gtk_size_group_get_mode((*C.GtkSizeGroup)(recv.native))
	retGo := (SizeGroupMode)(retC)

	return retGo
}

// Removes a widget from a #GtkSizeGroup.
/*

C function : gtk_size_group_remove_widget
*/
func (recv *SizeGroup) RemoveWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_size_group_remove_widget((*C.GtkSizeGroup)(recv.native), c_widget)

	return
}

// Sets the #GtkSizeGroupMode of the size group. The mode of the size
// group determines whether the widgets in the size group should
// all have the same horizontal requisition (%GTK_SIZE_GROUP_HORIZONTAL)
// all have the same vertical requisition (%GTK_SIZE_GROUP_VERTICAL),
// or should all have the same requisition in both directions
// (%GTK_SIZE_GROUP_BOTH).
/*

C function : gtk_size_group_set_mode
*/
func (recv *SizeGroup) SetMode(mode SizeGroupMode) {
	c_mode := (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode((*C.GtkSizeGroup)(recv.native), c_mode)

	return
}

// Buildable returns the Buildable interface implemented by SizeGroup
func (recv *SizeGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkSocket

// SpinButton is a wrapper around the C record GtkSpinButton.
type SpinButton struct {
	native *C.GtkSpinButton
	// entry : record
	// Private : priv
}

func SpinButtonNewFromC(u unsafe.Pointer) *SpinButton {
	c := (*C.GtkSpinButton)(u)
	if c == nil {
		return nil
	}

	g := &SpinButton{native: c}

	return g
}

func (recv *SpinButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Entry upcasts to *Entry
func (recv *SpinButton) Entry() *Entry {
	return EntryNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *SpinButton) Widget() *Widget {
	return recv.Entry().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SpinButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Entry().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SpinButton) Object() *gobject.Object {
	return recv.Entry().Object()
}

// CastToWidget down casts any arbitary Object to SpinButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinButton.
func CastToSpinButton(object *gobject.Object) *SpinButton {
	return SpinButtonNewFromC(object.ToC())
}

// Unsupported signal 'change-value' for SpinButton : unsupported parameter scroll : type ScrollType :

// Unsupported signal 'input' for SpinButton : unsupported parameter new_value : type gdouble :

type signalSpinButtonOutputDetail struct {
	callback  SpinButtonSignalOutputCallback
	handlerID C.gulong
}

var signalSpinButtonOutputId int
var signalSpinButtonOutputMap = make(map[int]signalSpinButtonOutputDetail)
var signalSpinButtonOutputLock sync.Mutex

// SpinButtonSignalOutputCallback is a callback function for a 'output' signal emitted from a SpinButton.
type SpinButtonSignalOutputCallback func() bool

/*
ConnectOutput connects the callback to the 'output' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectOutput to remove it.
*/
func (recv *SpinButton) ConnectOutput(callback SpinButtonSignalOutputCallback) int {
	signalSpinButtonOutputLock.Lock()
	defer signalSpinButtonOutputLock.Unlock()

	signalSpinButtonOutputId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_output(instance, C.gpointer(uintptr(signalSpinButtonOutputId)))

	detail := signalSpinButtonOutputDetail{callback, handlerID}
	signalSpinButtonOutputMap[signalSpinButtonOutputId] = detail

	return signalSpinButtonOutputId
}

/*
DisconnectOutput disconnects a callback from the 'output' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectOutput.
*/
func (recv *SpinButton) DisconnectOutput(connectionID int) {
	signalSpinButtonOutputLock.Lock()
	defer signalSpinButtonOutputLock.Unlock()

	detail, exists := signalSpinButtonOutputMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonOutputMap, connectionID)
}

//export spinbutton_outputHandler
func spinbutton_outputHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalSpinButtonOutputMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalSpinButtonValueChangedDetail struct {
	callback  SpinButtonSignalValueChangedCallback
	handlerID C.gulong
}

var signalSpinButtonValueChangedId int
var signalSpinButtonValueChangedMap = make(map[int]signalSpinButtonValueChangedDetail)
var signalSpinButtonValueChangedLock sync.Mutex

// SpinButtonSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a SpinButton.
type SpinButtonSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *SpinButton) ConnectValueChanged(callback SpinButtonSignalValueChangedCallback) int {
	signalSpinButtonValueChangedLock.Lock()
	defer signalSpinButtonValueChangedLock.Unlock()

	signalSpinButtonValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_value_changed(instance, C.gpointer(uintptr(signalSpinButtonValueChangedId)))

	detail := signalSpinButtonValueChangedDetail{callback, handlerID}
	signalSpinButtonValueChangedMap[signalSpinButtonValueChangedId] = detail

	return signalSpinButtonValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *SpinButton) DisconnectValueChanged(connectionID int) {
	signalSpinButtonValueChangedLock.Lock()
	defer signalSpinButtonValueChangedLock.Unlock()

	detail, exists := signalSpinButtonValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonValueChangedMap, connectionID)
}

//export spinbutton_valueChangedHandler
func spinbutton_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalSpinButtonValueChangedMap[index].callback
	callback()
}

// Creates a new #GtkSpinButton.
/*

C function : gtk_spin_button_new
*/
func SpinButtonNew(adjustment *Adjustment, climbRate float64, digits uint32) *SpinButton {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	c_climb_rate := (C.gdouble)(climbRate)

	c_digits := (C.guint)(digits)

	retC := C.gtk_spin_button_new(c_adjustment, c_climb_rate, c_digits)
	retGo := SpinButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This is a convenience constructor that allows creation of a numeric
// #GtkSpinButton without manually creating an adjustment. The value is
// initially set to the minimum value and a page increment of 10 * @step
// is the default. The precision of the spin button is equivalent to the
// precision of @step.
//
// Note that the way in which the precision is derived works best if @step
// is a power of ten. If the resulting precision is not suitable for your
// needs, use gtk_spin_button_set_digits() to correct it.
/*

C function : gtk_spin_button_new_with_range
*/
func SpinButtonNewWithRange(min float64, max float64, step float64) *SpinButton {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_spin_button_new_with_range(c_min, c_max, c_step)
	retGo := SpinButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Changes the properties of an existing spin button. The adjustment,
// climb rate, and number of decimal places are updated accordingly.
/*

C function : gtk_spin_button_configure
*/
func (recv *SpinButton) Configure(adjustment *Adjustment, climbRate float64, digits uint32) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	c_climb_rate := (C.gdouble)(climbRate)

	c_digits := (C.guint)(digits)

	C.gtk_spin_button_configure((*C.GtkSpinButton)(recv.native), c_adjustment, c_climb_rate, c_digits)

	return
}

// Get the adjustment associated with a #GtkSpinButton
/*

C function : gtk_spin_button_get_adjustment
*/
func (recv *SpinButton) GetAdjustment() *Adjustment {
	retC := C.gtk_spin_button_get_adjustment((*C.GtkSpinButton)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Fetches the precision of @spin_button. See gtk_spin_button_set_digits().
/*

C function : gtk_spin_button_get_digits
*/
func (recv *SpinButton) GetDigits() uint32 {
	retC := C.gtk_spin_button_get_digits((*C.GtkSpinButton)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Gets the current step and page the increments used by @spin_button. See
// gtk_spin_button_set_increments().
/*

C function : gtk_spin_button_get_increments
*/
func (recv *SpinButton) GetIncrements() (float64, float64) {
	var c_step C.gdouble

	var c_page C.gdouble

	C.gtk_spin_button_get_increments((*C.GtkSpinButton)(recv.native), &c_step, &c_page)

	step := (float64)(c_step)

	page := (float64)(c_page)

	return step, page
}

// Returns whether non-numeric text can be typed into the spin button.
// See gtk_spin_button_set_numeric().
/*

C function : gtk_spin_button_get_numeric
*/
func (recv *SpinButton) GetNumeric() bool {
	retC := C.gtk_spin_button_get_numeric((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the range allowed for @spin_button.
// See gtk_spin_button_set_range().
/*

C function : gtk_spin_button_get_range
*/
func (recv *SpinButton) GetRange() (float64, float64) {
	var c_min C.gdouble

	var c_max C.gdouble

	C.gtk_spin_button_get_range((*C.GtkSpinButton)(recv.native), &c_min, &c_max)

	min := (float64)(c_min)

	max := (float64)(c_max)

	return min, max
}

// Returns whether the values are corrected to the nearest step.
// See gtk_spin_button_set_snap_to_ticks().
/*

C function : gtk_spin_button_get_snap_to_ticks
*/
func (recv *SpinButton) GetSnapToTicks() bool {
	retC := C.gtk_spin_button_get_snap_to_ticks((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the update behavior of a spin button.
// See gtk_spin_button_set_update_policy().
/*

C function : gtk_spin_button_get_update_policy
*/
func (recv *SpinButton) GetUpdatePolicy() SpinButtonUpdatePolicy {
	retC := C.gtk_spin_button_get_update_policy((*C.GtkSpinButton)(recv.native))
	retGo := (SpinButtonUpdatePolicy)(retC)

	return retGo
}

// Get the value in the @spin_button.
/*

C function : gtk_spin_button_get_value
*/
func (recv *SpinButton) GetValue() float64 {
	retC := C.gtk_spin_button_get_value((*C.GtkSpinButton)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// Get the value @spin_button represented as an integer.
/*

C function : gtk_spin_button_get_value_as_int
*/
func (recv *SpinButton) GetValueAsInt() int32 {
	retC := C.gtk_spin_button_get_value_as_int((*C.GtkSpinButton)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns whether the spin button’s value wraps around to the
// opposite limit when the upper or lower limit of the range is
// exceeded. See gtk_spin_button_set_wrap().
/*

C function : gtk_spin_button_get_wrap
*/
func (recv *SpinButton) GetWrap() bool {
	retC := C.gtk_spin_button_get_wrap((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Replaces the #GtkAdjustment associated with @spin_button.
/*

C function : gtk_spin_button_set_adjustment
*/
func (recv *SpinButton) SetAdjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_spin_button_set_adjustment((*C.GtkSpinButton)(recv.native), c_adjustment)

	return
}

// Set the precision to be displayed by @spin_button. Up to 20 digit precision
// is allowed.
/*

C function : gtk_spin_button_set_digits
*/
func (recv *SpinButton) SetDigits(digits uint32) {
	c_digits := (C.guint)(digits)

	C.gtk_spin_button_set_digits((*C.GtkSpinButton)(recv.native), c_digits)

	return
}

// Sets the step and page increments for spin_button.  This affects how
// quickly the value changes when the spin button’s arrows are activated.
/*

C function : gtk_spin_button_set_increments
*/
func (recv *SpinButton) SetIncrements(step float64, page float64) {
	c_step := (C.gdouble)(step)

	c_page := (C.gdouble)(page)

	C.gtk_spin_button_set_increments((*C.GtkSpinButton)(recv.native), c_step, c_page)

	return
}

// Sets the flag that determines if non-numeric text can be typed
// into the spin button.
/*

C function : gtk_spin_button_set_numeric
*/
func (recv *SpinButton) SetNumeric(numeric bool) {
	c_numeric :=
		boolToGboolean(numeric)

	C.gtk_spin_button_set_numeric((*C.GtkSpinButton)(recv.native), c_numeric)

	return
}

// Sets the minimum and maximum allowable values for @spin_button.
//
// If the current value is outside this range, it will be adjusted
// to fit within the range, otherwise it will remain unchanged.
/*

C function : gtk_spin_button_set_range
*/
func (recv *SpinButton) SetRange(min float64, max float64) {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	C.gtk_spin_button_set_range((*C.GtkSpinButton)(recv.native), c_min, c_max)

	return
}

// Sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after
// providing an invalid value.
/*

C function : gtk_spin_button_set_snap_to_ticks
*/
func (recv *SpinButton) SetSnapToTicks(snapToTicks bool) {
	c_snap_to_ticks :=
		boolToGboolean(snapToTicks)

	C.gtk_spin_button_set_snap_to_ticks((*C.GtkSpinButton)(recv.native), c_snap_to_ticks)

	return
}

// Sets the update behavior of a spin button.
// This determines whether the spin button is always updated
// or only when a valid value is set.
/*

C function : gtk_spin_button_set_update_policy
*/
func (recv *SpinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy) {
	c_policy := (C.GtkSpinButtonUpdatePolicy)(policy)

	C.gtk_spin_button_set_update_policy((*C.GtkSpinButton)(recv.native), c_policy)

	return
}

// Sets the value of @spin_button.
/*

C function : gtk_spin_button_set_value
*/
func (recv *SpinButton) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_spin_button_set_value((*C.GtkSpinButton)(recv.native), c_value)

	return
}

// Sets the flag that determines if a spin button value wraps
// around to the opposite limit when the upper or lower limit
// of the range is exceeded.
/*

C function : gtk_spin_button_set_wrap
*/
func (recv *SpinButton) SetWrap(wrap bool) {
	c_wrap :=
		boolToGboolean(wrap)

	C.gtk_spin_button_set_wrap((*C.GtkSpinButton)(recv.native), c_wrap)

	return
}

// Increment or decrement a spin button’s value in a specified
// direction by a specified amount.
/*

C function : gtk_spin_button_spin
*/
func (recv *SpinButton) Spin(direction SpinType, increment float64) {
	c_direction := (C.GtkSpinType)(direction)

	c_increment := (C.gdouble)(increment)

	C.gtk_spin_button_spin((*C.GtkSpinButton)(recv.native), c_direction, c_increment)

	return
}

// Manually force an update of the spin button.
/*

C function : gtk_spin_button_update
*/
func (recv *SpinButton) Update() {
	C.gtk_spin_button_update((*C.GtkSpinButton)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by SpinButton
func (recv *SpinButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SpinButton
func (recv *SpinButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by SpinButton
func (recv *SpinButton) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by SpinButton
func (recv *SpinButton) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by SpinButton
func (recv *SpinButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// SpinButtonAccessible is a wrapper around the C record GtkSpinButtonAccessible.
type SpinButtonAccessible struct {
	native *C.GtkSpinButtonAccessible
	// parent : record
	// priv : record
}

func SpinButtonAccessibleNewFromC(u unsafe.Pointer) *SpinButtonAccessible {
	c := (*C.GtkSpinButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SpinButtonAccessible{native: c}

	return g
}

func (recv *SpinButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// EntryAccessible upcasts to *EntryAccessible
func (recv *SpinButtonAccessible) EntryAccessible() *EntryAccessible {
	return EntryAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SpinButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.EntryAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *SpinButtonAccessible) Accessible() *Accessible {
	return recv.EntryAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SpinButtonAccessible) Object() *atk.Object {
	return recv.EntryAccessible().Object()
}

// CastToWidget down casts any arbitary Object to SpinButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinButtonAccessible.
func CastToSpinButtonAccessible(object *gobject.Object) *SpinButtonAccessible {
	return SpinButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// Spinner is a wrapper around the C record GtkSpinner.
type Spinner struct {
	native *C.GtkSpinner
	// parent : record
	// Private : priv
}

func SpinnerNewFromC(u unsafe.Pointer) *Spinner {
	c := (*C.GtkSpinner)(u)
	if c == nil {
		return nil
	}

	g := &Spinner{native: c}

	return g
}

func (recv *Spinner) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Spinner) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Spinner) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Spinner) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Spinner.
// Exercise care, as this is a potentially dangerous function if the Object is not a Spinner.
func CastToSpinner(object *gobject.Object) *Spinner {
	return SpinnerNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Spinner
func (recv *Spinner) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Spinner
func (recv *Spinner) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SpinnerAccessible is a wrapper around the C record GtkSpinnerAccessible.
type SpinnerAccessible struct {
	native *C.GtkSpinnerAccessible
	// parent : record
	// priv : record
}

func SpinnerAccessibleNewFromC(u unsafe.Pointer) *SpinnerAccessible {
	c := (*C.GtkSpinnerAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SpinnerAccessible{native: c}

	return g
}

func (recv *SpinnerAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SpinnerAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *SpinnerAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SpinnerAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to SpinnerAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinnerAccessible.
func CastToSpinnerAccessible(object *gobject.Object) *SpinnerAccessible {
	return SpinnerAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by SpinnerAccessible
func (recv *SpinnerAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by SpinnerAccessible
func (recv *SpinnerAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Stack is a wrapper around the C record GtkStack.
type Stack struct {
	native *C.GtkStack
	// parent_instance : record
}

func StackNewFromC(u unsafe.Pointer) *Stack {
	c := (*C.GtkStack)(u)
	if c == nil {
		return nil
	}

	g := &Stack{native: c}

	return g
}

func (recv *Stack) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Stack) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Stack) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Stack) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Stack) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Stack.
// Exercise care, as this is a potentially dangerous function if the Object is not a Stack.
func CastToStack(object *gobject.Object) *Stack {
	return StackNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Stack
func (recv *Stack) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Stack
func (recv *Stack) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkStackAccessible

// StackSidebar is a wrapper around the C record GtkStackSidebar.
type StackSidebar struct {
	native *C.GtkStackSidebar
	// parent : record
}

func StackSidebarNewFromC(u unsafe.Pointer) *StackSidebar {
	c := (*C.GtkStackSidebar)(u)
	if c == nil {
		return nil
	}

	g := &StackSidebar{native: c}

	return g
}

func (recv *StackSidebar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *StackSidebar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *StackSidebar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *StackSidebar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *StackSidebar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *StackSidebar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to StackSidebar.
// Exercise care, as this is a potentially dangerous function if the Object is not a StackSidebar.
func CastToStackSidebar(object *gobject.Object) *StackSidebar {
	return StackSidebarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by StackSidebar
func (recv *StackSidebar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by StackSidebar
func (recv *StackSidebar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// StackSwitcher is a wrapper around the C record GtkStackSwitcher.
type StackSwitcher struct {
	native *C.GtkStackSwitcher
	// widget : record
}

func StackSwitcherNewFromC(u unsafe.Pointer) *StackSwitcher {
	c := (*C.GtkStackSwitcher)(u)
	if c == nil {
		return nil
	}

	g := &StackSwitcher{native: c}

	return g
}

func (recv *StackSwitcher) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *StackSwitcher) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *StackSwitcher) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *StackSwitcher) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *StackSwitcher) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *StackSwitcher) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to StackSwitcher.
// Exercise care, as this is a potentially dangerous function if the Object is not a StackSwitcher.
func CastToStackSwitcher(object *gobject.Object) *StackSwitcher {
	return StackSwitcherNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by StackSwitcher
func (recv *StackSwitcher) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by StackSwitcher
func (recv *StackSwitcher) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by StackSwitcher
func (recv *StackSwitcher) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// StatusIcon is a wrapper around the C record GtkStatusIcon.
type StatusIcon struct {
	native *C.GtkStatusIcon
	// parent_instance : record
	// priv : record
}

func StatusIconNewFromC(u unsafe.Pointer) *StatusIcon {
	c := (*C.GtkStatusIcon)(u)
	if c == nil {
		return nil
	}

	g := &StatusIcon{native: c}

	return g
}

func (recv *StatusIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *StatusIcon) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to StatusIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a StatusIcon.
func CastToStatusIcon(object *gobject.Object) *StatusIcon {
	return StatusIconNewFromC(object.ToC())
}

// Statusbar is a wrapper around the C record GtkStatusbar.
type Statusbar struct {
	native *C.GtkStatusbar
	// parent_widget : record
	// Private : priv
}

func StatusbarNewFromC(u unsafe.Pointer) *Statusbar {
	c := (*C.GtkStatusbar)(u)
	if c == nil {
		return nil
	}

	g := &Statusbar{native: c}

	return g
}

func (recv *Statusbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *Statusbar) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Statusbar) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *Statusbar) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Statusbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Statusbar) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to Statusbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Statusbar.
func CastToStatusbar(object *gobject.Object) *Statusbar {
	return StatusbarNewFromC(object.ToC())
}

// Unsupported signal 'text-popped' for Statusbar : unsupported parameter context_id : type guint :

// Unsupported signal 'text-pushed' for Statusbar : unsupported parameter context_id : type guint :

// Creates a new #GtkStatusbar ready for messages.
/*

C function : gtk_statusbar_new
*/
func StatusbarNew() *Statusbar {
	retC := C.gtk_statusbar_new()
	retGo := StatusbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns a new context identifier, given a description
// of the actual context. Note that the description is
// not shown in the UI.
/*

C function : gtk_statusbar_get_context_id
*/
func (recv *Statusbar) GetContextId(contextDescription string) uint32 {
	c_context_description := C.CString(contextDescription)
	defer C.free(unsafe.Pointer(c_context_description))

	retC := C.gtk_statusbar_get_context_id((*C.GtkStatusbar)(recv.native), c_context_description)
	retGo := (uint32)(retC)

	return retGo
}

// Removes the first message in the #GtkStatusbar’s stack
// with the given context id.
//
// Note that this may not change the displayed message, if
// the message at the top of the stack has a different
// context id.
/*

C function : gtk_statusbar_pop
*/
func (recv *Statusbar) Pop(contextId uint32) {
	c_context_id := (C.guint)(contextId)

	C.gtk_statusbar_pop((*C.GtkStatusbar)(recv.native), c_context_id)

	return
}

// Pushes a new message onto a statusbar’s stack.
/*

C function : gtk_statusbar_push
*/
func (recv *Statusbar) Push(contextId uint32, text string) uint32 {
	c_context_id := (C.guint)(contextId)

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	retC := C.gtk_statusbar_push((*C.GtkStatusbar)(recv.native), c_context_id, c_text)
	retGo := (uint32)(retC)

	return retGo
}

// Forces the removal of a message from a statusbar’s stack.
// The exact @context_id and @message_id must be specified.
/*

C function : gtk_statusbar_remove
*/
func (recv *Statusbar) Remove(contextId uint32, messageId uint32) {
	c_context_id := (C.guint)(contextId)

	c_message_id := (C.guint)(messageId)

	C.gtk_statusbar_remove((*C.GtkStatusbar)(recv.native), c_context_id, c_message_id)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Statusbar
func (recv *Statusbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Statusbar
func (recv *Statusbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Statusbar
func (recv *Statusbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// StatusbarAccessible is a wrapper around the C record GtkStatusbarAccessible.
type StatusbarAccessible struct {
	native *C.GtkStatusbarAccessible
	// parent : record
	// priv : record
}

func StatusbarAccessibleNewFromC(u unsafe.Pointer) *StatusbarAccessible {
	c := (*C.GtkStatusbarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &StatusbarAccessible{native: c}

	return g
}

func (recv *StatusbarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *StatusbarAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *StatusbarAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *StatusbarAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *StatusbarAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to StatusbarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a StatusbarAccessible.
func CastToStatusbarAccessible(object *gobject.Object) *StatusbarAccessible {
	return StatusbarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by StatusbarAccessible
func (recv *StatusbarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Style is a wrapper around the C record GtkStyle.
type Style struct {
	native *C.GtkStyle
	// Private : parent_instance
	// no type for fg
	// no type for bg
	// no type for light
	// no type for dark
	// no type for mid
	// no type for text
	// no type for base
	// no type for text_aa
	// black : record
	// white : record
	// font_desc : record
	Xthickness int32
	Ythickness int32
	// no type for background
	// Private : attach_count
	// Private : visual
	// Private : private_font_desc
	// Private : rc_style
	// Private : styles
	// Private : property_cache
	// Private : icon_factories
}

func StyleNewFromC(u unsafe.Pointer) *Style {
	c := (*C.GtkStyle)(u)
	if c == nil {
		return nil
	}

	g := &Style{
		Xthickness: (int32)(c.xthickness),
		Ythickness: (int32)(c.ythickness),
		native:     c,
	}

	return g
}

func (recv *Style) ToC() unsafe.Pointer {
	recv.native.xthickness =
		(C.gint)(recv.Xthickness)
	recv.native.ythickness =
		(C.gint)(recv.Ythickness)

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Style) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Style.
// Exercise care, as this is a potentially dangerous function if the Object is not a Style.
func CastToStyle(object *gobject.Object) *Style {
	return StyleNewFromC(object.ToC())
}

// Creates a new #GtkStyle.
/*

C function : gtk_style_new
*/
func StyleNew() *Style {
	retC := C.gtk_style_new()
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

/*

C function : gtk_style_apply_default_background
*/
func (recv *Style) ApplyDefaultBackground(cr *cairo.Context, window *gdk.Window, stateType StateType, x int32, y int32, width int32, height int32) {
	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_style_apply_default_background((*C.GtkStyle)(recv.native), c_cr, c_window, c_state_type, c_x, c_y, c_width, c_height)

	return
}

// Attaches a style to a window; this process allocates the
// colors and creates the GC’s for the style - it specializes
// it to a particular visual. The process may involve the creation
// of a new style if the style has already been attached to a
// window with a different style and visual.
//
// Since this function may return a new object, you have to use it
// in the following way:
// `style = gtk_style_attach (style, window)`
/*

C function : gtk_style_attach
*/
func (recv *Style) Attach(window *gdk.Window) *Style {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	retC := C.gtk_style_attach((*C.GtkStyle)(recv.native), c_window)
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a copy of the passed in #GtkStyle object.
/*

C function : gtk_style_copy
*/
func (recv *Style) Copy() *Style {
	retC := C.gtk_style_copy((*C.GtkStyle)(recv.native))
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Detaches a style from a window. If the style is not attached
// to any windows anymore, it is unrealized. See gtk_style_attach().
/*

C function : gtk_style_detach
*/
func (recv *Style) Detach() {
	C.gtk_style_detach((*C.GtkStyle)(recv.native))

	return
}

// Looks up @stock_id in the icon factories associated with @style
// and the default icon factory, returning an icon set if found,
// otherwise %NULL.
/*

C function : gtk_style_lookup_icon_set
*/
func (recv *Style) LookupIconSet(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_style_lookup_icon_set((*C.GtkStyle)(recv.native), c_stock_id)
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Renders the icon specified by @source at the given @size
// according to the given parameters and returns the result in a
// pixbuf.
/*

C function : gtk_style_render_icon
*/
func (recv *Style) RenderIcon(source *IconSource, direction TextDirection, state StateType, size IconSize, widget *Widget, detail string) *gdkpixbuf.Pixbuf {
	c_source := (*C.GtkIconSource)(C.NULL)
	if source != nil {
		c_source = (*C.GtkIconSource)(source.ToC())
	}

	c_direction := (C.GtkTextDirection)(direction)

	c_state := (C.GtkStateType)(state)

	c_size := (C.GtkIconSize)(size)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	retC := C.gtk_style_render_icon((*C.GtkStyle)(recv.native), c_source, c_direction, c_state, c_size, c_widget, c_detail)
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the background of @window to the background color or pixmap
// specified by @style for the given state.
/*

C function : gtk_style_set_background
*/
func (recv *Style) SetBackground(window *gdk.Window, stateType StateType) {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	C.gtk_style_set_background((*C.GtkStyle)(recv.native), c_window, c_state_type)

	return
}

// StyleContext is a wrapper around the C record GtkStyleContext.
type StyleContext struct {
	native *C.GtkStyleContext
	// parent_object : record
	// priv : record
}

func StyleContextNewFromC(u unsafe.Pointer) *StyleContext {
	c := (*C.GtkStyleContext)(u)
	if c == nil {
		return nil
	}

	g := &StyleContext{native: c}

	return g
}

func (recv *StyleContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *StyleContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to StyleContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a StyleContext.
func CastToStyleContext(object *gobject.Object) *StyleContext {
	return StyleContextNewFromC(object.ToC())
}

// Creates a standalone #GtkStyleContext, this style context
// won’t be attached to any widget, so you may want
// to call gtk_style_context_set_path() yourself.
//
// This function is only useful when using the theming layer
// separated from GTK+, if you are using #GtkStyleContext to
// theme #GtkWidgets, use gtk_widget_get_style_context()
// in order to get a style context ready to theme the widget.
/*

C function : gtk_style_context_new
*/
func StyleContextNew() *StyleContext {
	retC := C.gtk_style_context_new()
	retGo := StyleContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the #GdkScreen to which @context is attached.
/*

C function : gtk_style_context_get_screen
*/
func (recv *StyleContext) GetScreen() *gdk.Screen {
	retC := C.gtk_style_context_get_screen((*C.GtkStyleContext)(recv.native))
	retGo := gdk.ScreenNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Queries the location in the CSS where @property was defined for the
// current @context. Note that the state to be queried is taken from
// gtk_style_context_get_state().
//
// If the location is not available, %NULL will be returned. The
// location might not be available for various reasons, such as the
// property being overridden, @property not naming a supported CSS
// property or tracking of definitions being disabled for performance
// reasons.
//
// Shorthand CSS properties cannot be queried for a location and will
// always return %NULL.
/*

C function : gtk_style_context_get_section
*/
func (recv *StyleContext) GetSection(property string) *CssSection {
	c_property := C.CString(property)
	defer C.free(unsafe.Pointer(c_property))

	retC := C.gtk_style_context_get_section((*C.GtkStyleContext)(recv.native), c_property)
	var retGo (*CssSection)
	if retC == nil {
		retGo = nil
	} else {
		retGo = CssSectionNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets the value for a widget style property.
//
// When @value is no longer needed, g_value_unset() must be called
// to free any allocated memory.
/*

C function : gtk_style_context_get_style_property
*/
func (recv *StyleContext) GetStyleProperty(propertyName string, value *gobject.Value) {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_style_context_get_style_property((*C.GtkStyleContext)(recv.native), c_property_name, c_value)

	return
}

// Looks up and resolves a color name in the @context color map.
/*

C function : gtk_style_context_lookup_color
*/
func (recv *StyleContext) LookupColor(colorName string) (bool, *gdk.RGBA) {
	c_color_name := C.CString(colorName)
	defer C.free(unsafe.Pointer(c_color_name))

	var c_color C.GdkRGBA

	retC := C.gtk_style_context_lookup_color((*C.GtkStyleContext)(recv.native), c_color_name, &c_color)
	retGo := retC == C.TRUE

	color := gdk.RGBANewFromC(unsafe.Pointer(&c_color))

	return retGo, color
}

// Looks up @stock_id in the icon factories associated to @context and
// the default icon factory, returning an icon set if found, otherwise
// %NULL.
/*

C function : gtk_style_context_lookup_icon_set
*/
func (recv *StyleContext) LookupIconSet(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_style_context_lookup_icon_set((*C.GtkStyleContext)(recv.native), c_stock_id)
	var retGo (*IconSet)
	if retC == nil {
		retGo = nil
	} else {
		retGo = IconSetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// StyleProperties is a wrapper around the C record GtkStyleProperties.
type StyleProperties struct {
	native *C.GtkStyleProperties
	// Private : parent_object
	// Private : priv
}

func StylePropertiesNewFromC(u unsafe.Pointer) *StyleProperties {
	c := (*C.GtkStyleProperties)(u)
	if c == nil {
		return nil
	}

	g := &StyleProperties{native: c}

	return g
}

func (recv *StyleProperties) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *StyleProperties) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to StyleProperties.
// Exercise care, as this is a potentially dangerous function if the Object is not a StyleProperties.
func CastToStyleProperties(object *gobject.Object) *StyleProperties {
	return StylePropertiesNewFromC(object.ToC())
}

// Returns a newly created #GtkStyleProperties
/*

C function : gtk_style_properties_new
*/
func StylePropertiesNew() *StyleProperties {
	retC := C.gtk_style_properties_new()
	retGo := StylePropertiesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Clears all style information from @props.
/*

C function : gtk_style_properties_clear
*/
func (recv *StyleProperties) Clear() {
	C.gtk_style_properties_clear((*C.GtkStyleProperties)(recv.native))

	return
}

// StyleProvider returns the StyleProvider interface implemented by StyleProperties
func (recv *StyleProperties) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// Switch is a wrapper around the C record GtkSwitch.
type Switch struct {
	native *C.GtkSwitch
	// Private : parent_instance
	// Private : priv
}

func SwitchNewFromC(u unsafe.Pointer) *Switch {
	c := (*C.GtkSwitch)(u)
	if c == nil {
		return nil
	}

	g := &Switch{native: c}

	return g
}

func (recv *Switch) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Widget upcasts to *Widget
func (recv *Switch) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Switch) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Switch) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitary Object to Switch.
// Exercise care, as this is a potentially dangerous function if the Object is not a Switch.
func CastToSwitch(object *gobject.Object) *Switch {
	return SwitchNewFromC(object.ToC())
}

type signalSwitchActivateDetail struct {
	callback  SwitchSignalActivateCallback
	handlerID C.gulong
}

var signalSwitchActivateId int
var signalSwitchActivateMap = make(map[int]signalSwitchActivateDetail)
var signalSwitchActivateLock sync.Mutex

// SwitchSignalActivateCallback is a callback function for a 'activate' signal emitted from a Switch.
type SwitchSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Switch.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Switch) ConnectActivate(callback SwitchSignalActivateCallback) int {
	signalSwitchActivateLock.Lock()
	defer signalSwitchActivateLock.Unlock()

	signalSwitchActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Switch_signal_connect_activate(instance, C.gpointer(uintptr(signalSwitchActivateId)))

	detail := signalSwitchActivateDetail{callback, handlerID}
	signalSwitchActivateMap[signalSwitchActivateId] = detail

	return signalSwitchActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Switch.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Switch) DisconnectActivate(connectionID int) {
	signalSwitchActivateLock.Lock()
	defer signalSwitchActivateLock.Unlock()

	detail, exists := signalSwitchActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSwitchActivateMap, connectionID)
}

//export switch_activateHandler
func switch_activateHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalSwitchActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Switch
func (recv *Switch) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by Switch
func (recv *Switch) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by Switch
func (recv *Switch) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Switch
func (recv *Switch) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SwitchAccessible is a wrapper around the C record GtkSwitchAccessible.
type SwitchAccessible struct {
	native *C.GtkSwitchAccessible
	// parent : record
	// priv : record
}

func SwitchAccessibleNewFromC(u unsafe.Pointer) *SwitchAccessible {
	c := (*C.GtkSwitchAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SwitchAccessible{native: c}

	return g
}

func (recv *SwitchAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SwitchAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *SwitchAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SwitchAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitary Object to SwitchAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SwitchAccessible.
func CastToSwitchAccessible(object *gobject.Object) *SwitchAccessible {
	return SwitchAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by SwitchAccessible
func (recv *SwitchAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by SwitchAccessible
func (recv *SwitchAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Table is a wrapper around the C record GtkTable.
type Table struct {
	native *C.GtkTable
	// container : record
	// Private : priv
}

func TableNewFromC(u unsafe.Pointer) *Table {
	c := (*C.GtkTable)(u)
	if c == nil {
		return nil
	}

	g := &Table{native: c}

	return g
}

func (recv *Table) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Table) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Table) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Table) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Table) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Table.
// Exercise care, as this is a potentially dangerous function if the Object is not a Table.
func CastToTable(object *gobject.Object) *Table {
	return TableNewFromC(object.ToC())
}

// Used to create a new table widget. An initial size must be given by
// specifying how many rows and columns the table should have, although
// this can be changed later with gtk_table_resize().  @rows and @columns
// must both be in the range 1 .. 65535. For historical reasons, 0 is accepted
// as well and is silently interpreted as 1.
/*

C function : gtk_table_new
*/
func TableNew(rows uint32, columns uint32, homogeneous bool) *Table {
	c_rows := (C.guint)(rows)

	c_columns := (C.guint)(columns)

	c_homogeneous :=
		boolToGboolean(homogeneous)

	retC := C.gtk_table_new(c_rows, c_columns, c_homogeneous)
	retGo := TableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a widget to a table. The number of “cells” that a widget will occupy is
// specified by @left_attach, @right_attach, @top_attach and @bottom_attach.
// These each represent the leftmost, rightmost, uppermost and lowest column
// and row numbers of the table. (Columns and rows are indexed from zero).
//
// To make a button occupy the lower right cell of a 2x2 table, use
// |[
// gtk_table_attach (table, button,
// 1, 2, // left, right attach
// 1, 2, // top, bottom attach
// xoptions, yoptions,
// xpadding, ypadding);
// ]|
// If you want to make the button span the entire bottom row, use @left_attach == 0 and @right_attach = 2 instead.
/*

C function : gtk_table_attach
*/
func (recv *Table) Attach(child *Widget, leftAttach uint32, rightAttach uint32, topAttach uint32, bottomAttach uint32, xoptions AttachOptions, yoptions AttachOptions, xpadding uint32, ypadding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_left_attach := (C.guint)(leftAttach)

	c_right_attach := (C.guint)(rightAttach)

	c_top_attach := (C.guint)(topAttach)

	c_bottom_attach := (C.guint)(bottomAttach)

	c_xoptions := (C.GtkAttachOptions)(xoptions)

	c_yoptions := (C.GtkAttachOptions)(yoptions)

	c_xpadding := (C.guint)(xpadding)

	c_ypadding := (C.guint)(ypadding)

	C.gtk_table_attach((*C.GtkTable)(recv.native), c_child, c_left_attach, c_right_attach, c_top_attach, c_bottom_attach, c_xoptions, c_yoptions, c_xpadding, c_ypadding)

	return
}

// As there are many options associated with gtk_table_attach(), this convenience
// function provides the programmer with a means to add children to a table with
// identical padding and expansion options. The values used for the #GtkAttachOptions
// are `GTK_EXPAND | GTK_FILL`, and the padding is set to 0.
/*

C function : gtk_table_attach_defaults
*/
func (recv *Table) AttachDefaults(widget *Widget, leftAttach uint32, rightAttach uint32, topAttach uint32, bottomAttach uint32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_left_attach := (C.guint)(leftAttach)

	c_right_attach := (C.guint)(rightAttach)

	c_top_attach := (C.guint)(topAttach)

	c_bottom_attach := (C.guint)(bottomAttach)

	C.gtk_table_attach_defaults((*C.GtkTable)(recv.native), c_widget, c_left_attach, c_right_attach, c_top_attach, c_bottom_attach)

	return
}

// Gets the amount of space between column @col, and
// column @col + 1. See gtk_table_set_col_spacing().
/*

C function : gtk_table_get_col_spacing
*/
func (recv *Table) GetColSpacing(column uint32) uint32 {
	c_column := (C.guint)(column)

	retC := C.gtk_table_get_col_spacing((*C.GtkTable)(recv.native), c_column)
	retGo := (uint32)(retC)

	return retGo
}

// Gets the default column spacing for the table. This is
// the spacing that will be used for newly added columns.
// (See gtk_table_set_col_spacings())
/*

C function : gtk_table_get_default_col_spacing
*/
func (recv *Table) GetDefaultColSpacing() uint32 {
	retC := C.gtk_table_get_default_col_spacing((*C.GtkTable)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Gets the default row spacing for the table. This is
// the spacing that will be used for newly added rows.
// (See gtk_table_set_row_spacings())
/*

C function : gtk_table_get_default_row_spacing
*/
func (recv *Table) GetDefaultRowSpacing() uint32 {
	retC := C.gtk_table_get_default_row_spacing((*C.GtkTable)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Returns whether the table cells are all constrained to the same
// width and height. (See gtk_table_set_homogeneous ())
/*

C function : gtk_table_get_homogeneous
*/
func (recv *Table) GetHomogeneous() bool {
	retC := C.gtk_table_get_homogeneous((*C.GtkTable)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the amount of space between row @row, and
// row @row + 1. See gtk_table_set_row_spacing().
/*

C function : gtk_table_get_row_spacing
*/
func (recv *Table) GetRowSpacing(row uint32) uint32 {
	c_row := (C.guint)(row)

	retC := C.gtk_table_get_row_spacing((*C.GtkTable)(recv.native), c_row)
	retGo := (uint32)(retC)

	return retGo
}

// If you need to change a table’s size after
// it has been created, this function allows you to do so.
/*

C function : gtk_table_resize
*/
func (recv *Table) Resize(rows uint32, columns uint32) {
	c_rows := (C.guint)(rows)

	c_columns := (C.guint)(columns)

	C.gtk_table_resize((*C.GtkTable)(recv.native), c_rows, c_columns)

	return
}

// Alters the amount of space between a given table column and the following
// column.
/*

C function : gtk_table_set_col_spacing
*/
func (recv *Table) SetColSpacing(column uint32, spacing uint32) {
	c_column := (C.guint)(column)

	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_col_spacing((*C.GtkTable)(recv.native), c_column, c_spacing)

	return
}

// Sets the space between every column in @table equal to @spacing.
/*

C function : gtk_table_set_col_spacings
*/
func (recv *Table) SetColSpacings(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_col_spacings((*C.GtkTable)(recv.native), c_spacing)

	return
}

// Changes the homogenous property of table cells, ie. whether all cells are
// an equal size or not.
/*

C function : gtk_table_set_homogeneous
*/
func (recv *Table) SetHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_table_set_homogeneous((*C.GtkTable)(recv.native), c_homogeneous)

	return
}

// Changes the space between a given table row and the subsequent row.
/*

C function : gtk_table_set_row_spacing
*/
func (recv *Table) SetRowSpacing(row uint32, spacing uint32) {
	c_row := (C.guint)(row)

	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_row_spacing((*C.GtkTable)(recv.native), c_row, c_spacing)

	return
}

// Sets the space between every row in @table equal to @spacing.
/*

C function : gtk_table_set_row_spacings
*/
func (recv *Table) SetRowSpacings(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_row_spacings((*C.GtkTable)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Table
func (recv *Table) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Table
func (recv *Table) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TearoffMenuItem is a wrapper around the C record GtkTearoffMenuItem.
type TearoffMenuItem struct {
	native *C.GtkTearoffMenuItem
	// menu_item : record
	// Private : priv
}

func TearoffMenuItemNewFromC(u unsafe.Pointer) *TearoffMenuItem {
	c := (*C.GtkTearoffMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &TearoffMenuItem{native: c}

	return g
}

func (recv *TearoffMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// MenuItem upcasts to *MenuItem
func (recv *TearoffMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *TearoffMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *TearoffMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *TearoffMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TearoffMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TearoffMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitary Object to TearoffMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a TearoffMenuItem.
func CastToTearoffMenuItem(object *gobject.Object) *TearoffMenuItem {
	return TearoffMenuItemNewFromC(object.ToC())
}

// Creates a new #GtkTearoffMenuItem.
/*

C function : gtk_tearoff_menu_item_new
*/
func TearoffMenuItemNew() *TearoffMenuItem {
	retC := C.gtk_tearoff_menu_item_new()
	retGo := TearoffMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TextBuffer is a wrapper around the C record GtkTextBuffer.
type TextBuffer struct {
	native *C.GtkTextBuffer
	// parent_instance : record
	// priv : record
}

func TextBufferNewFromC(u unsafe.Pointer) *TextBuffer {
	c := (*C.GtkTextBuffer)(u)
	if c == nil {
		return nil
	}

	g := &TextBuffer{native: c}

	return g
}

func (recv *TextBuffer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextBuffer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextBuffer.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextBuffer.
func CastToTextBuffer(object *gobject.Object) *TextBuffer {
	return TextBufferNewFromC(object.ToC())
}

type signalTextBufferApplyTagDetail struct {
	callback  TextBufferSignalApplyTagCallback
	handlerID C.gulong
}

var signalTextBufferApplyTagId int
var signalTextBufferApplyTagMap = make(map[int]signalTextBufferApplyTagDetail)
var signalTextBufferApplyTagLock sync.Mutex

// TextBufferSignalApplyTagCallback is a callback function for a 'apply-tag' signal emitted from a TextBuffer.
type TextBufferSignalApplyTagCallback func(tag *TextTag, start *TextIter, end *TextIter)

/*
ConnectApplyTag connects the callback to the 'apply-tag' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectApplyTag to remove it.
*/
func (recv *TextBuffer) ConnectApplyTag(callback TextBufferSignalApplyTagCallback) int {
	signalTextBufferApplyTagLock.Lock()
	defer signalTextBufferApplyTagLock.Unlock()

	signalTextBufferApplyTagId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_apply_tag(instance, C.gpointer(uintptr(signalTextBufferApplyTagId)))

	detail := signalTextBufferApplyTagDetail{callback, handlerID}
	signalTextBufferApplyTagMap[signalTextBufferApplyTagId] = detail

	return signalTextBufferApplyTagId
}

/*
DisconnectApplyTag disconnects a callback from the 'apply-tag' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectApplyTag.
*/
func (recv *TextBuffer) DisconnectApplyTag(connectionID int) {
	signalTextBufferApplyTagLock.Lock()
	defer signalTextBufferApplyTagLock.Unlock()

	detail, exists := signalTextBufferApplyTagMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferApplyTagMap, connectionID)
}

//export textbuffer_applyTagHandler
func textbuffer_applyTagHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferApplyTagMap[index].callback
	callback(tag, start, end)
}

type signalTextBufferBeginUserActionDetail struct {
	callback  TextBufferSignalBeginUserActionCallback
	handlerID C.gulong
}

var signalTextBufferBeginUserActionId int
var signalTextBufferBeginUserActionMap = make(map[int]signalTextBufferBeginUserActionDetail)
var signalTextBufferBeginUserActionLock sync.Mutex

// TextBufferSignalBeginUserActionCallback is a callback function for a 'begin-user-action' signal emitted from a TextBuffer.
type TextBufferSignalBeginUserActionCallback func()

/*
ConnectBeginUserAction connects the callback to the 'begin-user-action' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectBeginUserAction to remove it.
*/
func (recv *TextBuffer) ConnectBeginUserAction(callback TextBufferSignalBeginUserActionCallback) int {
	signalTextBufferBeginUserActionLock.Lock()
	defer signalTextBufferBeginUserActionLock.Unlock()

	signalTextBufferBeginUserActionId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_begin_user_action(instance, C.gpointer(uintptr(signalTextBufferBeginUserActionId)))

	detail := signalTextBufferBeginUserActionDetail{callback, handlerID}
	signalTextBufferBeginUserActionMap[signalTextBufferBeginUserActionId] = detail

	return signalTextBufferBeginUserActionId
}

/*
DisconnectBeginUserAction disconnects a callback from the 'begin-user-action' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectBeginUserAction.
*/
func (recv *TextBuffer) DisconnectBeginUserAction(connectionID int) {
	signalTextBufferBeginUserActionLock.Lock()
	defer signalTextBufferBeginUserActionLock.Unlock()

	detail, exists := signalTextBufferBeginUserActionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferBeginUserActionMap, connectionID)
}

//export textbuffer_beginUserActionHandler
func textbuffer_beginUserActionHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextBufferBeginUserActionMap[index].callback
	callback()
}

type signalTextBufferChangedDetail struct {
	callback  TextBufferSignalChangedCallback
	handlerID C.gulong
}

var signalTextBufferChangedId int
var signalTextBufferChangedMap = make(map[int]signalTextBufferChangedDetail)
var signalTextBufferChangedLock sync.Mutex

// TextBufferSignalChangedCallback is a callback function for a 'changed' signal emitted from a TextBuffer.
type TextBufferSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *TextBuffer) ConnectChanged(callback TextBufferSignalChangedCallback) int {
	signalTextBufferChangedLock.Lock()
	defer signalTextBufferChangedLock.Unlock()

	signalTextBufferChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_changed(instance, C.gpointer(uintptr(signalTextBufferChangedId)))

	detail := signalTextBufferChangedDetail{callback, handlerID}
	signalTextBufferChangedMap[signalTextBufferChangedId] = detail

	return signalTextBufferChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *TextBuffer) DisconnectChanged(connectionID int) {
	signalTextBufferChangedLock.Lock()
	defer signalTextBufferChangedLock.Unlock()

	detail, exists := signalTextBufferChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferChangedMap, connectionID)
}

//export textbuffer_changedHandler
func textbuffer_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextBufferChangedMap[index].callback
	callback()
}

type signalTextBufferDeleteRangeDetail struct {
	callback  TextBufferSignalDeleteRangeCallback
	handlerID C.gulong
}

var signalTextBufferDeleteRangeId int
var signalTextBufferDeleteRangeMap = make(map[int]signalTextBufferDeleteRangeDetail)
var signalTextBufferDeleteRangeLock sync.Mutex

// TextBufferSignalDeleteRangeCallback is a callback function for a 'delete-range' signal emitted from a TextBuffer.
type TextBufferSignalDeleteRangeCallback func(start *TextIter, end *TextIter)

/*
ConnectDeleteRange connects the callback to the 'delete-range' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectDeleteRange to remove it.
*/
func (recv *TextBuffer) ConnectDeleteRange(callback TextBufferSignalDeleteRangeCallback) int {
	signalTextBufferDeleteRangeLock.Lock()
	defer signalTextBufferDeleteRangeLock.Unlock()

	signalTextBufferDeleteRangeId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_delete_range(instance, C.gpointer(uintptr(signalTextBufferDeleteRangeId)))

	detail := signalTextBufferDeleteRangeDetail{callback, handlerID}
	signalTextBufferDeleteRangeMap[signalTextBufferDeleteRangeId] = detail

	return signalTextBufferDeleteRangeId
}

/*
DisconnectDeleteRange disconnects a callback from the 'delete-range' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectDeleteRange.
*/
func (recv *TextBuffer) DisconnectDeleteRange(connectionID int) {
	signalTextBufferDeleteRangeLock.Lock()
	defer signalTextBufferDeleteRangeLock.Unlock()

	detail, exists := signalTextBufferDeleteRangeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferDeleteRangeMap, connectionID)
}

//export textbuffer_deleteRangeHandler
func textbuffer_deleteRangeHandler(_ *C.GObject, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferDeleteRangeMap[index].callback
	callback(start, end)
}

type signalTextBufferEndUserActionDetail struct {
	callback  TextBufferSignalEndUserActionCallback
	handlerID C.gulong
}

var signalTextBufferEndUserActionId int
var signalTextBufferEndUserActionMap = make(map[int]signalTextBufferEndUserActionDetail)
var signalTextBufferEndUserActionLock sync.Mutex

// TextBufferSignalEndUserActionCallback is a callback function for a 'end-user-action' signal emitted from a TextBuffer.
type TextBufferSignalEndUserActionCallback func()

/*
ConnectEndUserAction connects the callback to the 'end-user-action' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectEndUserAction to remove it.
*/
func (recv *TextBuffer) ConnectEndUserAction(callback TextBufferSignalEndUserActionCallback) int {
	signalTextBufferEndUserActionLock.Lock()
	defer signalTextBufferEndUserActionLock.Unlock()

	signalTextBufferEndUserActionId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_end_user_action(instance, C.gpointer(uintptr(signalTextBufferEndUserActionId)))

	detail := signalTextBufferEndUserActionDetail{callback, handlerID}
	signalTextBufferEndUserActionMap[signalTextBufferEndUserActionId] = detail

	return signalTextBufferEndUserActionId
}

/*
DisconnectEndUserAction disconnects a callback from the 'end-user-action' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectEndUserAction.
*/
func (recv *TextBuffer) DisconnectEndUserAction(connectionID int) {
	signalTextBufferEndUserActionLock.Lock()
	defer signalTextBufferEndUserActionLock.Unlock()

	detail, exists := signalTextBufferEndUserActionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferEndUserActionMap, connectionID)
}

//export textbuffer_endUserActionHandler
func textbuffer_endUserActionHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextBufferEndUserActionMap[index].callback
	callback()
}

type signalTextBufferInsertChildAnchorDetail struct {
	callback  TextBufferSignalInsertChildAnchorCallback
	handlerID C.gulong
}

var signalTextBufferInsertChildAnchorId int
var signalTextBufferInsertChildAnchorMap = make(map[int]signalTextBufferInsertChildAnchorDetail)
var signalTextBufferInsertChildAnchorLock sync.Mutex

// TextBufferSignalInsertChildAnchorCallback is a callback function for a 'insert-child-anchor' signal emitted from a TextBuffer.
type TextBufferSignalInsertChildAnchorCallback func(location *TextIter, anchor *TextChildAnchor)

/*
ConnectInsertChildAnchor connects the callback to the 'insert-child-anchor' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertChildAnchor to remove it.
*/
func (recv *TextBuffer) ConnectInsertChildAnchor(callback TextBufferSignalInsertChildAnchorCallback) int {
	signalTextBufferInsertChildAnchorLock.Lock()
	defer signalTextBufferInsertChildAnchorLock.Unlock()

	signalTextBufferInsertChildAnchorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_child_anchor(instance, C.gpointer(uintptr(signalTextBufferInsertChildAnchorId)))

	detail := signalTextBufferInsertChildAnchorDetail{callback, handlerID}
	signalTextBufferInsertChildAnchorMap[signalTextBufferInsertChildAnchorId] = detail

	return signalTextBufferInsertChildAnchorId
}

/*
DisconnectInsertChildAnchor disconnects a callback from the 'insert-child-anchor' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertChildAnchor.
*/
func (recv *TextBuffer) DisconnectInsertChildAnchor(connectionID int) {
	signalTextBufferInsertChildAnchorLock.Lock()
	defer signalTextBufferInsertChildAnchorLock.Unlock()

	detail, exists := signalTextBufferInsertChildAnchorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertChildAnchorMap, connectionID)
}

//export textbuffer_insertChildAnchorHandler
func textbuffer_insertChildAnchorHandler(_ *C.GObject, c_location *C.GtkTextIter, c_anchor *C.GtkTextChildAnchor, data C.gpointer) {
	location := TextIterNewFromC(unsafe.Pointer(c_location))

	anchor := TextChildAnchorNewFromC(unsafe.Pointer(c_anchor))

	index := int(uintptr(data))
	callback := signalTextBufferInsertChildAnchorMap[index].callback
	callback(location, anchor)
}

type signalTextBufferInsertPixbufDetail struct {
	callback  TextBufferSignalInsertPixbufCallback
	handlerID C.gulong
}

var signalTextBufferInsertPixbufId int
var signalTextBufferInsertPixbufMap = make(map[int]signalTextBufferInsertPixbufDetail)
var signalTextBufferInsertPixbufLock sync.Mutex

// TextBufferSignalInsertPixbufCallback is a callback function for a 'insert-pixbuf' signal emitted from a TextBuffer.
type TextBufferSignalInsertPixbufCallback func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf)

/*
ConnectInsertPixbuf connects the callback to the 'insert-pixbuf' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertPixbuf to remove it.
*/
func (recv *TextBuffer) ConnectInsertPixbuf(callback TextBufferSignalInsertPixbufCallback) int {
	signalTextBufferInsertPixbufLock.Lock()
	defer signalTextBufferInsertPixbufLock.Unlock()

	signalTextBufferInsertPixbufId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_pixbuf(instance, C.gpointer(uintptr(signalTextBufferInsertPixbufId)))

	detail := signalTextBufferInsertPixbufDetail{callback, handlerID}
	signalTextBufferInsertPixbufMap[signalTextBufferInsertPixbufId] = detail

	return signalTextBufferInsertPixbufId
}

/*
DisconnectInsertPixbuf disconnects a callback from the 'insert-pixbuf' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertPixbuf.
*/
func (recv *TextBuffer) DisconnectInsertPixbuf(connectionID int) {
	signalTextBufferInsertPixbufLock.Lock()
	defer signalTextBufferInsertPixbufLock.Unlock()

	detail, exists := signalTextBufferInsertPixbufMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertPixbufMap, connectionID)
}

//export textbuffer_insertPixbufHandler
func textbuffer_insertPixbufHandler(_ *C.GObject, c_location *C.GtkTextIter, c_pixbuf *C.GdkPixbuf, data C.gpointer) {
	location := TextIterNewFromC(unsafe.Pointer(c_location))

	pixbuf := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(c_pixbuf))

	index := int(uintptr(data))
	callback := signalTextBufferInsertPixbufMap[index].callback
	callback(location, pixbuf)
}

// Unsupported signal 'insert-text' for TextBuffer : unsupported parameter text : type utf8 :

type signalTextBufferMarkDeletedDetail struct {
	callback  TextBufferSignalMarkDeletedCallback
	handlerID C.gulong
}

var signalTextBufferMarkDeletedId int
var signalTextBufferMarkDeletedMap = make(map[int]signalTextBufferMarkDeletedDetail)
var signalTextBufferMarkDeletedLock sync.Mutex

// TextBufferSignalMarkDeletedCallback is a callback function for a 'mark-deleted' signal emitted from a TextBuffer.
type TextBufferSignalMarkDeletedCallback func(mark *TextMark)

/*
ConnectMarkDeleted connects the callback to the 'mark-deleted' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectMarkDeleted to remove it.
*/
func (recv *TextBuffer) ConnectMarkDeleted(callback TextBufferSignalMarkDeletedCallback) int {
	signalTextBufferMarkDeletedLock.Lock()
	defer signalTextBufferMarkDeletedLock.Unlock()

	signalTextBufferMarkDeletedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_mark_deleted(instance, C.gpointer(uintptr(signalTextBufferMarkDeletedId)))

	detail := signalTextBufferMarkDeletedDetail{callback, handlerID}
	signalTextBufferMarkDeletedMap[signalTextBufferMarkDeletedId] = detail

	return signalTextBufferMarkDeletedId
}

/*
DisconnectMarkDeleted disconnects a callback from the 'mark-deleted' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectMarkDeleted.
*/
func (recv *TextBuffer) DisconnectMarkDeleted(connectionID int) {
	signalTextBufferMarkDeletedLock.Lock()
	defer signalTextBufferMarkDeletedLock.Unlock()

	detail, exists := signalTextBufferMarkDeletedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferMarkDeletedMap, connectionID)
}

//export textbuffer_markDeletedHandler
func textbuffer_markDeletedHandler(_ *C.GObject, c_mark *C.GtkTextMark, data C.gpointer) {
	mark := TextMarkNewFromC(unsafe.Pointer(c_mark))

	index := int(uintptr(data))
	callback := signalTextBufferMarkDeletedMap[index].callback
	callback(mark)
}

type signalTextBufferMarkSetDetail struct {
	callback  TextBufferSignalMarkSetCallback
	handlerID C.gulong
}

var signalTextBufferMarkSetId int
var signalTextBufferMarkSetMap = make(map[int]signalTextBufferMarkSetDetail)
var signalTextBufferMarkSetLock sync.Mutex

// TextBufferSignalMarkSetCallback is a callback function for a 'mark-set' signal emitted from a TextBuffer.
type TextBufferSignalMarkSetCallback func(location *TextIter, mark *TextMark)

/*
ConnectMarkSet connects the callback to the 'mark-set' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectMarkSet to remove it.
*/
func (recv *TextBuffer) ConnectMarkSet(callback TextBufferSignalMarkSetCallback) int {
	signalTextBufferMarkSetLock.Lock()
	defer signalTextBufferMarkSetLock.Unlock()

	signalTextBufferMarkSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_mark_set(instance, C.gpointer(uintptr(signalTextBufferMarkSetId)))

	detail := signalTextBufferMarkSetDetail{callback, handlerID}
	signalTextBufferMarkSetMap[signalTextBufferMarkSetId] = detail

	return signalTextBufferMarkSetId
}

/*
DisconnectMarkSet disconnects a callback from the 'mark-set' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectMarkSet.
*/
func (recv *TextBuffer) DisconnectMarkSet(connectionID int) {
	signalTextBufferMarkSetLock.Lock()
	defer signalTextBufferMarkSetLock.Unlock()

	detail, exists := signalTextBufferMarkSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferMarkSetMap, connectionID)
}

//export textbuffer_markSetHandler
func textbuffer_markSetHandler(_ *C.GObject, c_location *C.GtkTextIter, c_mark *C.GtkTextMark, data C.gpointer) {
	location := TextIterNewFromC(unsafe.Pointer(c_location))

	mark := TextMarkNewFromC(unsafe.Pointer(c_mark))

	index := int(uintptr(data))
	callback := signalTextBufferMarkSetMap[index].callback
	callback(location, mark)
}

type signalTextBufferModifiedChangedDetail struct {
	callback  TextBufferSignalModifiedChangedCallback
	handlerID C.gulong
}

var signalTextBufferModifiedChangedId int
var signalTextBufferModifiedChangedMap = make(map[int]signalTextBufferModifiedChangedDetail)
var signalTextBufferModifiedChangedLock sync.Mutex

// TextBufferSignalModifiedChangedCallback is a callback function for a 'modified-changed' signal emitted from a TextBuffer.
type TextBufferSignalModifiedChangedCallback func()

/*
ConnectModifiedChanged connects the callback to the 'modified-changed' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectModifiedChanged to remove it.
*/
func (recv *TextBuffer) ConnectModifiedChanged(callback TextBufferSignalModifiedChangedCallback) int {
	signalTextBufferModifiedChangedLock.Lock()
	defer signalTextBufferModifiedChangedLock.Unlock()

	signalTextBufferModifiedChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_modified_changed(instance, C.gpointer(uintptr(signalTextBufferModifiedChangedId)))

	detail := signalTextBufferModifiedChangedDetail{callback, handlerID}
	signalTextBufferModifiedChangedMap[signalTextBufferModifiedChangedId] = detail

	return signalTextBufferModifiedChangedId
}

/*
DisconnectModifiedChanged disconnects a callback from the 'modified-changed' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectModifiedChanged.
*/
func (recv *TextBuffer) DisconnectModifiedChanged(connectionID int) {
	signalTextBufferModifiedChangedLock.Lock()
	defer signalTextBufferModifiedChangedLock.Unlock()

	detail, exists := signalTextBufferModifiedChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferModifiedChangedMap, connectionID)
}

//export textbuffer_modifiedChangedHandler
func textbuffer_modifiedChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextBufferModifiedChangedMap[index].callback
	callback()
}

type signalTextBufferRemoveTagDetail struct {
	callback  TextBufferSignalRemoveTagCallback
	handlerID C.gulong
}

var signalTextBufferRemoveTagId int
var signalTextBufferRemoveTagMap = make(map[int]signalTextBufferRemoveTagDetail)
var signalTextBufferRemoveTagLock sync.Mutex

// TextBufferSignalRemoveTagCallback is a callback function for a 'remove-tag' signal emitted from a TextBuffer.
type TextBufferSignalRemoveTagCallback func(tag *TextTag, start *TextIter, end *TextIter)

/*
ConnectRemoveTag connects the callback to the 'remove-tag' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectRemoveTag to remove it.
*/
func (recv *TextBuffer) ConnectRemoveTag(callback TextBufferSignalRemoveTagCallback) int {
	signalTextBufferRemoveTagLock.Lock()
	defer signalTextBufferRemoveTagLock.Unlock()

	signalTextBufferRemoveTagId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_remove_tag(instance, C.gpointer(uintptr(signalTextBufferRemoveTagId)))

	detail := signalTextBufferRemoveTagDetail{callback, handlerID}
	signalTextBufferRemoveTagMap[signalTextBufferRemoveTagId] = detail

	return signalTextBufferRemoveTagId
}

/*
DisconnectRemoveTag disconnects a callback from the 'remove-tag' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectRemoveTag.
*/
func (recv *TextBuffer) DisconnectRemoveTag(connectionID int) {
	signalTextBufferRemoveTagLock.Lock()
	defer signalTextBufferRemoveTagLock.Unlock()

	detail, exists := signalTextBufferRemoveTagMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferRemoveTagMap, connectionID)
}

//export textbuffer_removeTagHandler
func textbuffer_removeTagHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferRemoveTagMap[index].callback
	callback(tag, start, end)
}

// Creates a new text buffer.
/*

C function : gtk_text_buffer_new
*/
func TextBufferNew(table *TextTagTable) *TextBuffer {
	c_table := (*C.GtkTextTagTable)(C.NULL)
	if table != nil {
		c_table = (*C.GtkTextTagTable)(table.ToC())
	}

	retC := C.gtk_text_buffer_new(c_table)
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds @clipboard to the list of clipboards in which the selection
// contents of @buffer are available. In most cases, @clipboard will be
// the #GtkClipboard of type %GDK_SELECTION_PRIMARY for a view of @buffer.
/*

C function : gtk_text_buffer_add_selection_clipboard
*/
func (recv *TextBuffer) AddSelectionClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_add_selection_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// Emits the “apply-tag” signal on @buffer. The default
// handler for the signal applies @tag to the given range.
// @start and @end do not have to be in order.
/*

C function : gtk_text_buffer_apply_tag
*/
func (recv *TextBuffer) ApplyTag(tag *TextTag, start *TextIter, end *TextIter) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_apply_tag((*C.GtkTextBuffer)(recv.native), c_tag, c_start, c_end)

	return
}

// Calls gtk_text_tag_table_lookup() on the buffer’s tag table to
// get a #GtkTextTag, then calls gtk_text_buffer_apply_tag().
/*

C function : gtk_text_buffer_apply_tag_by_name
*/
func (recv *TextBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_apply_tag_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_start, c_end)

	return
}

// Called to indicate that the buffer operations between here and a
// call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation. The operations between
// gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when creating
// an undo stack. #GtkTextBuffer maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with
// a call to gtk_text_buffer_end_user_action(), and emits the
// “begin-user-action” and “end-user-action” signals only for the
// outermost pair of calls. This allows you to build user actions
// from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk_text_buffer_insert_interactive(), automatically call begin/end
// user action around the buffer operations they perform, so there's
// no need to add extra calls if you user action consists solely of a
// single call to one of those functions.
/*

C function : gtk_text_buffer_begin_user_action
*/
func (recv *TextBuffer) BeginUserAction() {
	C.gtk_text_buffer_begin_user_action((*C.GtkTextBuffer)(recv.native))

	return
}

// Copies the currently-selected text to a clipboard.
/*

C function : gtk_text_buffer_copy_clipboard
*/
func (recv *TextBuffer) CopyClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_copy_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// This is a convenience function which simply creates a child anchor
// with gtk_text_child_anchor_new() and inserts it into the buffer
// with gtk_text_buffer_insert_child_anchor(). The new anchor is
// owned by the buffer; no reference count is returned to
// the caller of gtk_text_buffer_create_child_anchor().
/*

C function : gtk_text_buffer_create_child_anchor
*/
func (recv *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_buffer_create_child_anchor((*C.GtkTextBuffer)(recv.native), c_iter)
	retGo := TextChildAnchorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a mark at position @where. If @mark_name is %NULL, the mark
// is anonymous; otherwise, the mark can be retrieved by name using
// gtk_text_buffer_get_mark(). If a mark has left gravity, and text is
// inserted at the mark’s current location, the mark will be moved to
// the left of the newly-inserted text. If the mark has right gravity
// (@left_gravity = %FALSE), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark
// with right gravity (when you type, the cursor stays on the right
// side of the text you’re typing).
//
// The caller of this function does not own a
// reference to the returned #GtkTextMark, so you can ignore the
// return value if you like. Marks are owned by the buffer and go
// away when the buffer does.
//
// Emits the #GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
/*

C function : gtk_text_buffer_create_mark
*/
func (recv *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	c_mark_name := C.CString(markName)
	defer C.free(unsafe.Pointer(c_mark_name))

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	c_left_gravity :=
		boolToGboolean(leftGravity)

	retC := C.gtk_text_buffer_create_mark((*C.GtkTextBuffer)(recv.native), c_mark_name, c_where, c_left_gravity)
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_text_buffer_create_tag : unsupported parameter ... : varargs

// Copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
/*

C function : gtk_text_buffer_cut_clipboard
*/
func (recv *TextBuffer) CutClipboard(clipboard *Clipboard, defaultEditable bool) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	C.gtk_text_buffer_cut_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard, c_default_editable)

	return
}

// Deletes text between @start and @end. The order of @start and @end
// is not actually relevant; gtk_text_buffer_delete() will reorder
// them. This function actually emits the “delete-range” signal, and
// the default handler of that signal deletes the text. Because the
// buffer is modified, all outstanding iterators become invalid after
// calling this function; however, the @start and @end will be
// re-initialized to point to the location where text was deleted.
/*

C function : gtk_text_buffer_delete
*/
func (recv *TextBuffer) Delete(start *TextIter, end *TextIter) {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_delete((*C.GtkTextBuffer)(recv.native), c_start, c_end)

	return
}

// Deletes all editable text in the given range.
// Calls gtk_text_buffer_delete() for each editable sub-range of
// [@start,@end). @start and @end are revalidated to point to
// the location of the last deleted range, or left untouched if
// no text was deleted.
/*

C function : gtk_text_buffer_delete_interactive
*/
func (recv *TextBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	c_start_iter := (*C.GtkTextIter)(C.NULL)
	if startIter != nil {
		c_start_iter = (*C.GtkTextIter)(startIter.ToC())
	}

	c_end_iter := (*C.GtkTextIter)(C.NULL)
	if endIter != nil {
		c_end_iter = (*C.GtkTextIter)(endIter.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_delete_interactive((*C.GtkTextBuffer)(recv.native), c_start_iter, c_end_iter, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Deletes @mark, so that it’s no longer located anywhere in the
// buffer. Removes the reference the buffer holds to the mark, so if
// you haven’t called g_object_ref() on the mark, it will be freed. Even
// if the mark isn’t freed, most operations on @mark become
// invalid, until it gets added to a buffer again with
// gtk_text_buffer_add_mark(). Use gtk_text_mark_get_deleted() to
// find out if a mark has been removed from its buffer.
// The #GtkTextBuffer::mark-deleted signal will be emitted as notification after
// the mark is deleted.
/*

C function : gtk_text_buffer_delete_mark
*/
func (recv *TextBuffer) DeleteMark(mark *TextMark) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_buffer_delete_mark((*C.GtkTextBuffer)(recv.native), c_mark)

	return
}

// Deletes the mark named @name; the mark must exist. See
// gtk_text_buffer_delete_mark() for details.
/*

C function : gtk_text_buffer_delete_mark_by_name
*/
func (recv *TextBuffer) DeleteMarkByName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_text_buffer_delete_mark_by_name((*C.GtkTextBuffer)(recv.native), c_name)

	return
}

// Deletes the range between the “insert” and “selection_bound” marks,
// that is, the currently-selected text. If @interactive is %TRUE,
// the editability of the selection will be considered (users can’t delete
// uneditable text).
/*

C function : gtk_text_buffer_delete_selection
*/
func (recv *TextBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	c_interactive :=
		boolToGboolean(interactive)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_delete_selection((*C.GtkTextBuffer)(recv.native), c_interactive, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Should be paired with a call to gtk_text_buffer_begin_user_action().
// See that function for a full explanation.
/*

C function : gtk_text_buffer_end_user_action
*/
func (recv *TextBuffer) EndUserAction() {
	C.gtk_text_buffer_end_user_action((*C.GtkTextBuffer)(recv.native))

	return
}

// Retrieves the first and last iterators in the buffer, i.e. the
// entire buffer lies within the range [@start,@end).
/*

C function : gtk_text_buffer_get_bounds
*/
func (recv *TextBuffer) GetBounds() (*TextIter, *TextIter) {
	var c_start C.GtkTextIter

	var c_end C.GtkTextIter

	C.gtk_text_buffer_get_bounds((*C.GtkTextBuffer)(recv.native), &c_start, &c_end)

	start := TextIterNewFromC(unsafe.Pointer(&c_start))

	end := TextIterNewFromC(unsafe.Pointer(&c_end))

	return start, end
}

// Gets the number of characters in the buffer; note that characters
// and bytes are not the same, you can’t e.g. expect the contents of
// the buffer in string form to be this many bytes long. The character
// count is cached, so this function is very fast.
/*

C function : gtk_text_buffer_get_char_count
*/
func (recv *TextBuffer) GetCharCount() int32 {
	retC := C.gtk_text_buffer_get_char_count((*C.GtkTextBuffer)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Initializes @iter with the “end iterator,” one past the last valid
// character in the text buffer. If dereferenced with
// gtk_text_iter_get_char(), the end iterator has a character value of 0.
// The entire buffer lies in the range from the first position in
// the buffer (call gtk_text_buffer_get_start_iter() to get
// character position 0) to the end iterator.
/*

C function : gtk_text_buffer_get_end_iter
*/
func (recv *TextBuffer) GetEndIter() *TextIter {
	var c_iter C.GtkTextIter

	C.gtk_text_buffer_get_end_iter((*C.GtkTextBuffer)(recv.native), &c_iter)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Returns the mark that represents the cursor (insertion point).
// Equivalent to calling gtk_text_buffer_get_mark() to get the mark
// named “insert”, but very slightly more efficient, and involves less
// typing.
/*

C function : gtk_text_buffer_get_insert
*/
func (recv *TextBuffer) GetInsert() *TextMark {
	retC := C.gtk_text_buffer_get_insert((*C.GtkTextBuffer)(recv.native))
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Obtains the location of @anchor within @buffer.
/*

C function : gtk_text_buffer_get_iter_at_child_anchor
*/
func (recv *TextBuffer) GetIterAtChildAnchor(anchor *TextChildAnchor) *TextIter {
	var c_iter C.GtkTextIter

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_buffer_get_iter_at_child_anchor((*C.GtkTextBuffer)(recv.native), &c_iter, c_anchor)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Initializes @iter to the start of the given line. If @line_number is greater
// than the number of lines in the @buffer, the end iterator is returned.
/*

C function : gtk_text_buffer_get_iter_at_line
*/
func (recv *TextBuffer) GetIterAtLine(lineNumber int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	C.gtk_text_buffer_get_iter_at_line((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Obtains an iterator pointing to @byte_index within the given line.
// @byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of lines
// in the @buffer, the end iterator is returned. And if @byte_index is off the
// end of the line, the iterator at the end of the line is returned.
/*

C function : gtk_text_buffer_get_iter_at_line_index
*/
func (recv *TextBuffer) GetIterAtLineIndex(lineNumber int32, byteIndex int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	c_byte_index := (C.gint)(byteIndex)

	C.gtk_text_buffer_get_iter_at_line_index((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number, c_byte_index)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Obtains an iterator pointing to @char_offset within the given line. Note
// characters, not bytes; UTF-8 may encode one character as multiple bytes.
//
// Before the 3.20 version, it was not allowed to pass an invalid location.
//
// Since the 3.20 version, if @line_number is greater than the number of lines
// in the @buffer, the end iterator is returned. And if @char_offset is off the
// end of the line, the iterator at the end of the line is returned.
/*

C function : gtk_text_buffer_get_iter_at_line_offset
*/
func (recv *TextBuffer) GetIterAtLineOffset(lineNumber int32, charOffset int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	c_char_offset := (C.gint)(charOffset)

	C.gtk_text_buffer_get_iter_at_line_offset((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number, c_char_offset)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Initializes @iter with the current position of @mark.
/*

C function : gtk_text_buffer_get_iter_at_mark
*/
func (recv *TextBuffer) GetIterAtMark(mark *TextMark) *TextIter {
	var c_iter C.GtkTextIter

	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_buffer_get_iter_at_mark((*C.GtkTextBuffer)(recv.native), &c_iter, c_mark)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Initializes @iter to a position @char_offset chars from the start
// of the entire buffer. If @char_offset is -1 or greater than the number
// of characters in the buffer, @iter is initialized to the end iterator,
// the iterator one past the last valid character in the buffer.
/*

C function : gtk_text_buffer_get_iter_at_offset
*/
func (recv *TextBuffer) GetIterAtOffset(charOffset int32) *TextIter {
	var c_iter C.GtkTextIter

	c_char_offset := (C.gint)(charOffset)

	C.gtk_text_buffer_get_iter_at_offset((*C.GtkTextBuffer)(recv.native), &c_iter, c_char_offset)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Obtains the number of lines in the buffer. This value is cached, so
// the function is very fast.
/*

C function : gtk_text_buffer_get_line_count
*/
func (recv *TextBuffer) GetLineCount() int32 {
	retC := C.gtk_text_buffer_get_line_count((*C.GtkTextBuffer)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the mark named @name in buffer @buffer, or %NULL if no such
// mark exists in the buffer.
/*

C function : gtk_text_buffer_get_mark
*/
func (recv *TextBuffer) GetMark(name string) *TextMark {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_buffer_get_mark((*C.GtkTextBuffer)(recv.native), c_name)
	var retGo (*TextMark)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TextMarkNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Indicates whether the buffer has been modified since the last call
// to gtk_text_buffer_set_modified() set the modification flag to
// %FALSE. Used for example to enable a “save” function in a text
// editor.
/*

C function : gtk_text_buffer_get_modified
*/
func (recv *TextBuffer) GetModified() bool {
	retC := C.gtk_text_buffer_get_modified((*C.GtkTextBuffer)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the mark that represents the selection bound.  Equivalent
// to calling gtk_text_buffer_get_mark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves
// less typing.
//
// The currently-selected text in @buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and
// “insert” are in the same place, then there is no current selection.
// gtk_text_buffer_get_selection_bounds() is another convenient function
// for handling the selection, if you just want to know whether there’s a
// selection and what its bounds are.
/*

C function : gtk_text_buffer_get_selection_bound
*/
func (recv *TextBuffer) GetSelectionBound() *TextMark {
	retC := C.gtk_text_buffer_get_selection_bound((*C.GtkTextBuffer)(recv.native))
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if some text is selected; places the bounds
// of the selection in @start and @end (if the selection has length 0,
// then @start and @end are filled in with the same value).
// @start and @end will be in ascending order. If @start and @end are
// NULL, then they are not filled in, but the return value still indicates
// whether text is selected.
/*

C function : gtk_text_buffer_get_selection_bounds
*/
func (recv *TextBuffer) GetSelectionBounds() (bool, *TextIter, *TextIter) {
	var c_start C.GtkTextIter

	var c_end C.GtkTextIter

	retC := C.gtk_text_buffer_get_selection_bounds((*C.GtkTextBuffer)(recv.native), &c_start, &c_end)
	retGo := retC == C.TRUE

	start := TextIterNewFromC(unsafe.Pointer(&c_start))

	end := TextIterNewFromC(unsafe.Pointer(&c_end))

	return retGo, start, end
}

// Returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is %FALSE. The returned string includes a
// 0xFFFC character whenever the buffer contains
// embedded images, so byte and character indexes into
// the returned string do correspond to byte
// and character indexes into the buffer. Contrast with
// gtk_text_buffer_get_text(). Note that 0xFFFC can occur in normal
// text as well, so it is not a reliable indicator that a pixbuf or
// widget is in the buffer.
/*

C function : gtk_text_buffer_get_slice
*/
func (recv *TextBuffer) GetSlice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_include_hidden_chars :=
		boolToGboolean(includeHiddenChars)

	retC := C.gtk_text_buffer_get_slice((*C.GtkTextBuffer)(recv.native), c_start, c_end, c_include_hidden_chars)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Initialized @iter with the first position in the text buffer. This
// is the same as using gtk_text_buffer_get_iter_at_offset() to get
// the iter at character offset 0.
/*

C function : gtk_text_buffer_get_start_iter
*/
func (recv *TextBuffer) GetStartIter() *TextIter {
	var c_iter C.GtkTextIter

	C.gtk_text_buffer_get_start_iter((*C.GtkTextBuffer)(recv.native), &c_iter)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Get the #GtkTextTagTable associated with this buffer.
/*

C function : gtk_text_buffer_get_tag_table
*/
func (recv *TextBuffer) GetTagTable() *TextTagTable {
	retC := C.gtk_text_buffer_get_tag_table((*C.GtkTextBuffer)(recv.native))
	retGo := TextTagTableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the text in the range [@start,@end). Excludes undisplayed
// text (text marked with tags that set the invisibility attribute) if
// @include_hidden_chars is %FALSE. Does not include characters
// representing embedded images, so byte and character indexes into
// the returned string do not correspond to byte
// and character indexes into the buffer. Contrast with
// gtk_text_buffer_get_slice().
/*

C function : gtk_text_buffer_get_text
*/
func (recv *TextBuffer) GetText(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_include_hidden_chars :=
		boolToGboolean(includeHiddenChars)

	retC := C.gtk_text_buffer_get_text((*C.GtkTextBuffer)(recv.native), c_start, c_end, c_include_hidden_chars)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Inserts @len bytes of @text at position @iter.  If @len is -1,
// @text must be nul-terminated and will be inserted in its
// entirety. Emits the “insert-text” signal; insertion actually occurs
// in the default handler for the signal. @iter is invalidated when
// insertion occurs (because the buffer contents change), but the
// default signal handler revalidates it to point to the end of the
// inserted text.
/*

C function : gtk_text_buffer_insert
*/
func (recv *TextBuffer) Insert(iter *TextIter, text string, len int32) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_insert((*C.GtkTextBuffer)(recv.native), c_iter, c_text, c_len)

	return
}

// Simply calls gtk_text_buffer_insert(), using the current
// cursor position as the insertion point.
/*

C function : gtk_text_buffer_insert_at_cursor
*/
func (recv *TextBuffer) InsertAtCursor(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_insert_at_cursor((*C.GtkTextBuffer)(recv.native), c_text, c_len)

	return
}

// Inserts a child widget anchor into the text buffer at @iter. The
// anchor will be counted as one character in character counts, and
// when obtaining the buffer contents as a string, will be represented
// by the Unicode “object replacement character” 0xFFFC. Note that the
// “slice” variants for obtaining portions of the buffer as a string
// include this character for child anchors, but the “text” variants do
// not. E.g. see gtk_text_buffer_get_slice() and
// gtk_text_buffer_get_text(). Consider
// gtk_text_buffer_create_child_anchor() as a more convenient
// alternative to this function. The buffer will add a reference to
// the anchor, so you can unref it after insertion.
/*

C function : gtk_text_buffer_insert_child_anchor
*/
func (recv *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_buffer_insert_child_anchor((*C.GtkTextBuffer)(recv.native), c_iter, c_anchor)

	return
}

// Like gtk_text_buffer_insert(), but the insertion will not occur if
// @iter is at a non-editable location in the buffer. Usually you
// want to prevent insertions at ineditable locations if the insertion
// results from a user action (is interactive).
//
// @default_editable indicates the editability of text that doesn't
// have a tag affecting editability applied to it. Typically the
// result of gtk_text_view_get_editable() is appropriate here.
/*

C function : gtk_text_buffer_insert_interactive
*/
func (recv *TextBuffer) InsertInteractive(iter *TextIter, text string, len int32, defaultEditable bool) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_interactive((*C.GtkTextBuffer)(recv.native), c_iter, c_text, c_len, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Calls gtk_text_buffer_insert_interactive() at the cursor
// position.
//
// @default_editable indicates the editability of text that doesn't
// have a tag affecting editability applied to it. Typically the
// result of gtk_text_view_get_editable() is appropriate here.
/*

C function : gtk_text_buffer_insert_interactive_at_cursor
*/
func (recv *TextBuffer) InsertInteractiveAtCursor(text string, len int32, defaultEditable bool) bool {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_interactive_at_cursor((*C.GtkTextBuffer)(recv.native), c_text, c_len, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Inserts an image into the text buffer at @iter. The image will be
// counted as one character in character counts, and when obtaining
// the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice”
// variants for obtaining portions of the buffer as a string include
// this character for pixbufs, but the “text” variants do
// not. e.g. see gtk_text_buffer_get_slice() and
// gtk_text_buffer_get_text().
/*

C function : gtk_text_buffer_insert_pixbuf
*/
func (recv *TextBuffer) InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_text_buffer_insert_pixbuf((*C.GtkTextBuffer)(recv.native), c_iter, c_pixbuf)

	return
}

// Copies text, tags, and pixbufs between @start and @end (the order
// of @start and @end doesn’t matter) and inserts the copy at @iter.
// Used instead of simply getting/inserting text because it preserves
// images and tags. If @start and @end are in a different buffer from
// @buffer, the two buffers must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals,
// so expect those.
/*

C function : gtk_text_buffer_insert_range
*/
func (recv *TextBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_insert_range((*C.GtkTextBuffer)(recv.native), c_iter, c_start, c_end)

	return
}

// Same as gtk_text_buffer_insert_range(), but does nothing if the
// insertion point isn’t editable. The @default_editable parameter
// indicates whether the text is editable at @iter if no tags
// enclosing @iter affect editability. Typically the result of
// gtk_text_view_get_editable() is appropriate here.
/*

C function : gtk_text_buffer_insert_range_interactive
*/
func (recv *TextBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_range_interactive((*C.GtkTextBuffer)(recv.native), c_iter, c_start, c_end, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_text_buffer_insert_with_tags : unsupported parameter ... : varargs

// Unsupported : gtk_text_buffer_insert_with_tags_by_name : unsupported parameter ... : varargs

// Moves @mark to the new location @where. Emits the #GtkTextBuffer::mark-set
// signal as notification of the move.
/*

C function : gtk_text_buffer_move_mark
*/
func (recv *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_move_mark((*C.GtkTextBuffer)(recv.native), c_mark, c_where)

	return
}

// Moves the mark named @name (which must exist) to location @where.
// See gtk_text_buffer_move_mark() for details.
/*

C function : gtk_text_buffer_move_mark_by_name
*/
func (recv *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_move_mark_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_where)

	return
}

// Pastes the contents of a clipboard. If @override_location is %NULL, the
// pasted text will be inserted at the cursor position, or the buffer selection
// will be replaced if the selection is non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
/*

C function : gtk_text_buffer_paste_clipboard
*/
func (recv *TextBuffer) PasteClipboard(clipboard *Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	c_override_location := (*C.GtkTextIter)(C.NULL)
	if overrideLocation != nil {
		c_override_location = (*C.GtkTextIter)(overrideLocation.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	C.gtk_text_buffer_paste_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard, c_override_location, c_default_editable)

	return
}

// This function moves the “insert” and “selection_bound” marks
// simultaneously.  If you move them to the same place in two steps
// with gtk_text_buffer_move_mark(), you will temporarily select a
// region in between their old and new locations, which can be pretty
// inefficient since the temporarily-selected region will force stuff
// to be recalculated. This function moves them as a unit, which can
// be optimized.
/*

C function : gtk_text_buffer_place_cursor
*/
func (recv *TextBuffer) PlaceCursor(where *TextIter) {
	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_place_cursor((*C.GtkTextBuffer)(recv.native), c_where)

	return
}

// Removes all tags in the range between @start and @end.  Be careful
// with this function; it could remove tags added in code unrelated to
// the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections
// that add tags.
/*

C function : gtk_text_buffer_remove_all_tags
*/
func (recv *TextBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_all_tags((*C.GtkTextBuffer)(recv.native), c_start, c_end)

	return
}

// Removes a #GtkClipboard added with
// gtk_text_buffer_add_selection_clipboard().
/*

C function : gtk_text_buffer_remove_selection_clipboard
*/
func (recv *TextBuffer) RemoveSelectionClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_remove_selection_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// Emits the “remove-tag” signal. The default handler for the signal
// removes all occurrences of @tag from the given range. @start and
// @end don’t have to be in order.
/*

C function : gtk_text_buffer_remove_tag
*/
func (recv *TextBuffer) RemoveTag(tag *TextTag, start *TextIter, end *TextIter) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_tag((*C.GtkTextBuffer)(recv.native), c_tag, c_start, c_end)

	return
}

// Calls gtk_text_tag_table_lookup() on the buffer’s tag table to
// get a #GtkTextTag, then calls gtk_text_buffer_remove_tag().
/*

C function : gtk_text_buffer_remove_tag_by_name
*/
func (recv *TextBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_tag_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_start, c_end)

	return
}

// Used to keep track of whether the buffer has been modified since the
// last time it was saved. Whenever the buffer is saved to disk, call
// gtk_text_buffer_set_modified (@buffer, FALSE). When the buffer is modified,
// it will automatically toggled on the modified bit again. When the modified
// bit flips, the buffer emits the #GtkTextBuffer::modified-changed signal.
/*

C function : gtk_text_buffer_set_modified
*/
func (recv *TextBuffer) SetModified(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_buffer_set_modified((*C.GtkTextBuffer)(recv.native), c_setting)

	return
}

// Deletes current contents of @buffer, and inserts @text instead. If
// @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
/*

C function : gtk_text_buffer_set_text
*/
func (recv *TextBuffer) SetText(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_set_text((*C.GtkTextBuffer)(recv.native), c_text, c_len)

	return
}

// TextCellAccessible is a wrapper around the C record GtkTextCellAccessible.
type TextCellAccessible struct {
	native *C.GtkTextCellAccessible
	// parent : record
	// priv : record
}

func TextCellAccessibleNewFromC(u unsafe.Pointer) *TextCellAccessible {
	c := (*C.GtkTextCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TextCellAccessible{native: c}

	return g
}

func (recv *TextCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *TextCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *TextCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TextCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TextCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitary Object to TextCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextCellAccessible.
func CastToTextCellAccessible(object *gobject.Object) *TextCellAccessible {
	return TextCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// TextChildAnchor is a wrapper around the C record GtkTextChildAnchor.
type TextChildAnchor struct {
	native *C.GtkTextChildAnchor
	// parent_instance : record
	// Private : segment
}

func TextChildAnchorNewFromC(u unsafe.Pointer) *TextChildAnchor {
	c := (*C.GtkTextChildAnchor)(u)
	if c == nil {
		return nil
	}

	g := &TextChildAnchor{native: c}

	return g
}

func (recv *TextChildAnchor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextChildAnchor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextChildAnchor.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextChildAnchor.
func CastToTextChildAnchor(object *gobject.Object) *TextChildAnchor {
	return TextChildAnchorNewFromC(object.ToC())
}

// Creates a new #GtkTextChildAnchor. Usually you would then insert
// it into a #GtkTextBuffer with gtk_text_buffer_insert_child_anchor().
// To perform the creation and insertion in one step, use the
// convenience function gtk_text_buffer_create_child_anchor().
/*

C function : gtk_text_child_anchor_new
*/
func TextChildAnchorNew() *TextChildAnchor {
	retC := C.gtk_text_child_anchor_new()
	retGo := TextChildAnchorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Determines whether a child anchor has been deleted from
// the buffer. Keep in mind that the child anchor will be
// unreferenced when removed from the buffer, so you need to
// hold your own reference (with g_object_ref()) if you plan
// to use this function — otherwise all deleted child anchors
// will also be finalized.
/*

C function : gtk_text_child_anchor_get_deleted
*/
func (recv *TextChildAnchor) GetDeleted() bool {
	retC := C.gtk_text_child_anchor_get_deleted((*C.GtkTextChildAnchor)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets a list of all widgets anchored at this child anchor.
// The returned list should be freed with g_list_free().
/*

C function : gtk_text_child_anchor_get_widgets
*/
func (recv *TextChildAnchor) GetWidgets() *glib.List {
	retC := C.gtk_text_child_anchor_get_widgets((*C.GtkTextChildAnchor)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TextMark is a wrapper around the C record GtkTextMark.
type TextMark struct {
	native *C.GtkTextMark
	// parent_instance : record
	// Private : segment
}

func TextMarkNewFromC(u unsafe.Pointer) *TextMark {
	c := (*C.GtkTextMark)(u)
	if c == nil {
		return nil
	}

	g := &TextMark{native: c}

	return g
}

func (recv *TextMark) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextMark) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextMark.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextMark.
func CastToTextMark(object *gobject.Object) *TextMark {
	return TextMarkNewFromC(object.ToC())
}

// Gets the buffer this mark is located inside,
// or %NULL if the mark is deleted.
/*

C function : gtk_text_mark_get_buffer
*/
func (recv *TextMark) GetBuffer() *TextBuffer {
	retC := C.gtk_text_mark_get_buffer((*C.GtkTextMark)(recv.native))
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if the mark has been removed from its buffer
// with gtk_text_buffer_delete_mark(). See gtk_text_buffer_add_mark()
// for a way to add it to a buffer again.
/*

C function : gtk_text_mark_get_deleted
*/
func (recv *TextMark) GetDeleted() bool {
	retC := C.gtk_text_mark_get_deleted((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Determines whether the mark has left gravity.
/*

C function : gtk_text_mark_get_left_gravity
*/
func (recv *TextMark) GetLeftGravity() bool {
	retC := C.gtk_text_mark_get_left_gravity((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the mark name; returns NULL for anonymous marks.
/*

C function : gtk_text_mark_get_name
*/
func (recv *TextMark) GetName() string {
	retC := C.gtk_text_mark_get_name((*C.GtkTextMark)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Returns %TRUE if the mark is visible (i.e. a cursor is displayed
// for it).
/*

C function : gtk_text_mark_get_visible
*/
func (recv *TextMark) GetVisible() bool {
	retC := C.gtk_text_mark_get_visible((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the visibility of @mark; the insertion point is normally
// visible, i.e. you can see it as a vertical bar. Also, the text
// widget uses a visible mark to indicate where a drop will occur when
// dragging-and-dropping text. Most other marks are not visible.
// Marks are not visible by default.
/*

C function : gtk_text_mark_set_visible
*/
func (recv *TextMark) SetVisible(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_mark_set_visible((*C.GtkTextMark)(recv.native), c_setting)

	return
}

// TextTag is a wrapper around the C record GtkTextTag.
type TextTag struct {
	native *C.GtkTextTag
	// parent_instance : record
	// priv : record
}

func TextTagNewFromC(u unsafe.Pointer) *TextTag {
	c := (*C.GtkTextTag)(u)
	if c == nil {
		return nil
	}

	g := &TextTag{native: c}

	return g
}

func (recv *TextTag) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextTag) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextTag.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextTag.
func CastToTextTag(object *gobject.Object) *TextTag {
	return TextTagNewFromC(object.ToC())
}

// Unsupported signal 'event' for TextTag : unsupported parameter event : no type generator for Gdk.Event,

// Creates a #GtkTextTag. Configure the tag using object arguments,
// i.e. using g_object_set().
/*

C function : gtk_text_tag_new
*/
func TextTagNew(name string) *TextTag {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_tag_new(c_name)
	retGo := TextTagNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_text_tag_event : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Get the tag priority.
/*

C function : gtk_text_tag_get_priority
*/
func (recv *TextTag) GetPriority() int32 {
	retC := C.gtk_text_tag_get_priority((*C.GtkTextTag)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Sets the priority of a #GtkTextTag. Valid priorities
// start at 0 and go to one less than gtk_text_tag_table_get_size().
// Each tag in a table has a unique priority; setting the priority
// of one tag shifts the priorities of all the other tags in the
// table to maintain a unique priority for each tag. Higher priority
// tags “win” if two tags both set the same text attribute. When adding
// a tag to a tag table, it will be assigned the highest priority in
// the table by default; so normally the precedence of a set of tags
// is the order in which they were added to the table, or created with
// gtk_text_buffer_create_tag(), which adds the tag to the buffer’s table
// automatically.
/*

C function : gtk_text_tag_set_priority
*/
func (recv *TextTag) SetPriority(priority int32) {
	c_priority := (C.gint)(priority)

	C.gtk_text_tag_set_priority((*C.GtkTextTag)(recv.native), c_priority)

	return
}

// TextTagTable is a wrapper around the C record GtkTextTagTable.
type TextTagTable struct {
	native *C.GtkTextTagTable
	// parent_instance : record
	// priv : record
}

func TextTagTableNewFromC(u unsafe.Pointer) *TextTagTable {
	c := (*C.GtkTextTagTable)(u)
	if c == nil {
		return nil
	}

	g := &TextTagTable{native: c}

	return g
}

func (recv *TextTagTable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TextTagTable) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TextTagTable.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextTagTable.
func CastToTextTagTable(object *gobject.Object) *TextTagTable {
	return TextTagTableNewFromC(object.ToC())
}

type signalTextTagTableTagAddedDetail struct {
	callback  TextTagTableSignalTagAddedCallback
	handlerID C.gulong
}

var signalTextTagTableTagAddedId int
var signalTextTagTableTagAddedMap = make(map[int]signalTextTagTableTagAddedDetail)
var signalTextTagTableTagAddedLock sync.Mutex

// TextTagTableSignalTagAddedCallback is a callback function for a 'tag-added' signal emitted from a TextTagTable.
type TextTagTableSignalTagAddedCallback func(tag *TextTag)

/*
ConnectTagAdded connects the callback to the 'tag-added' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagAdded to remove it.
*/
func (recv *TextTagTable) ConnectTagAdded(callback TextTagTableSignalTagAddedCallback) int {
	signalTextTagTableTagAddedLock.Lock()
	defer signalTextTagTableTagAddedLock.Unlock()

	signalTextTagTableTagAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_added(instance, C.gpointer(uintptr(signalTextTagTableTagAddedId)))

	detail := signalTextTagTableTagAddedDetail{callback, handlerID}
	signalTextTagTableTagAddedMap[signalTextTagTableTagAddedId] = detail

	return signalTextTagTableTagAddedId
}

/*
DisconnectTagAdded disconnects a callback from the 'tag-added' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagAdded.
*/
func (recv *TextTagTable) DisconnectTagAdded(connectionID int) {
	signalTextTagTableTagAddedLock.Lock()
	defer signalTextTagTableTagAddedLock.Unlock()

	detail, exists := signalTextTagTableTagAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagAddedMap, connectionID)
}

//export texttagtable_tagAddedHandler
func texttagtable_tagAddedHandler(_ *C.GObject, c_tag *C.GtkTextTag, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	index := int(uintptr(data))
	callback := signalTextTagTableTagAddedMap[index].callback
	callback(tag)
}

type signalTextTagTableTagChangedDetail struct {
	callback  TextTagTableSignalTagChangedCallback
	handlerID C.gulong
}

var signalTextTagTableTagChangedId int
var signalTextTagTableTagChangedMap = make(map[int]signalTextTagTableTagChangedDetail)
var signalTextTagTableTagChangedLock sync.Mutex

// TextTagTableSignalTagChangedCallback is a callback function for a 'tag-changed' signal emitted from a TextTagTable.
type TextTagTableSignalTagChangedCallback func(tag *TextTag, sizeChanged bool)

/*
ConnectTagChanged connects the callback to the 'tag-changed' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagChanged to remove it.
*/
func (recv *TextTagTable) ConnectTagChanged(callback TextTagTableSignalTagChangedCallback) int {
	signalTextTagTableTagChangedLock.Lock()
	defer signalTextTagTableTagChangedLock.Unlock()

	signalTextTagTableTagChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_changed(instance, C.gpointer(uintptr(signalTextTagTableTagChangedId)))

	detail := signalTextTagTableTagChangedDetail{callback, handlerID}
	signalTextTagTableTagChangedMap[signalTextTagTableTagChangedId] = detail

	return signalTextTagTableTagChangedId
}

/*
DisconnectTagChanged disconnects a callback from the 'tag-changed' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagChanged.
*/
func (recv *TextTagTable) DisconnectTagChanged(connectionID int) {
	signalTextTagTableTagChangedLock.Lock()
	defer signalTextTagTableTagChangedLock.Unlock()

	detail, exists := signalTextTagTableTagChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagChangedMap, connectionID)
}

//export texttagtable_tagChangedHandler
func texttagtable_tagChangedHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_size_changed C.gboolean, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	sizeChanged := c_size_changed == C.TRUE

	index := int(uintptr(data))
	callback := signalTextTagTableTagChangedMap[index].callback
	callback(tag, sizeChanged)
}

type signalTextTagTableTagRemovedDetail struct {
	callback  TextTagTableSignalTagRemovedCallback
	handlerID C.gulong
}

var signalTextTagTableTagRemovedId int
var signalTextTagTableTagRemovedMap = make(map[int]signalTextTagTableTagRemovedDetail)
var signalTextTagTableTagRemovedLock sync.Mutex

// TextTagTableSignalTagRemovedCallback is a callback function for a 'tag-removed' signal emitted from a TextTagTable.
type TextTagTableSignalTagRemovedCallback func(tag *TextTag)

/*
ConnectTagRemoved connects the callback to the 'tag-removed' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagRemoved to remove it.
*/
func (recv *TextTagTable) ConnectTagRemoved(callback TextTagTableSignalTagRemovedCallback) int {
	signalTextTagTableTagRemovedLock.Lock()
	defer signalTextTagTableTagRemovedLock.Unlock()

	signalTextTagTableTagRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_removed(instance, C.gpointer(uintptr(signalTextTagTableTagRemovedId)))

	detail := signalTextTagTableTagRemovedDetail{callback, handlerID}
	signalTextTagTableTagRemovedMap[signalTextTagTableTagRemovedId] = detail

	return signalTextTagTableTagRemovedId
}

/*
DisconnectTagRemoved disconnects a callback from the 'tag-removed' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagRemoved.
*/
func (recv *TextTagTable) DisconnectTagRemoved(connectionID int) {
	signalTextTagTableTagRemovedLock.Lock()
	defer signalTextTagTableTagRemovedLock.Unlock()

	detail, exists := signalTextTagTableTagRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagRemovedMap, connectionID)
}

//export texttagtable_tagRemovedHandler
func texttagtable_tagRemovedHandler(_ *C.GObject, c_tag *C.GtkTextTag, data C.gpointer) {
	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	index := int(uintptr(data))
	callback := signalTextTagTableTagRemovedMap[index].callback
	callback(tag)
}

// Creates a new #GtkTextTagTable. The table contains no tags by
// default.
/*

C function : gtk_text_tag_table_new
*/
func TextTagTableNew() *TextTagTable {
	retC := C.gtk_text_tag_table_new()
	retGo := TextTagTableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Add a tag to the table. The tag is assigned the highest priority
// in the table.
//
// @tag must not be in a tag table already, and may not have
// the same name as an already-added tag.
/*

C function : gtk_text_tag_table_add
*/
func (recv *TextTagTable) Add(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_tag_table_add((*C.GtkTextTagTable)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_text_tag_table_foreach : unsupported parameter func : no type generator for TextTagTableForeach (GtkTextTagTableForeach) for param func

// Returns the size of the table (number of tags)
/*

C function : gtk_text_tag_table_get_size
*/
func (recv *TextTagTable) GetSize() int32 {
	retC := C.gtk_text_tag_table_get_size((*C.GtkTextTagTable)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Look up a named tag.
/*

C function : gtk_text_tag_table_lookup
*/
func (recv *TextTagTable) Lookup(name string) *TextTag {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_tag_table_lookup((*C.GtkTextTagTable)(recv.native), c_name)
	var retGo (*TextTag)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TextTagNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Remove a tag from the table. If a #GtkTextBuffer has @table as its tag table,
// the tag is removed from the buffer. The table’s reference to the tag is
// removed, so the tag will end up destroyed if you don’t have a reference to
// it.
/*

C function : gtk_text_tag_table_remove
*/
func (recv *TextTagTable) Remove(tag *TextTag) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	C.gtk_text_tag_table_remove((*C.GtkTextTagTable)(recv.native), c_tag)

	return
}

// Buildable returns the Buildable interface implemented by TextTagTable
func (recv *TextTagTable) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TextView is a wrapper around the C record GtkTextView.
type TextView struct {
	native *C.GtkTextView
	// parent_instance : record
	// Private : priv
}

func TextViewNewFromC(u unsafe.Pointer) *TextView {
	c := (*C.GtkTextView)(u)
	if c == nil {
		return nil
	}

	g := &TextView{native: c}

	return g
}

func (recv *TextView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *TextView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *TextView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TextView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TextView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to TextView.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextView.
func CastToTextView(object *gobject.Object) *TextView {
	return TextViewNewFromC(object.ToC())
}

type signalTextViewBackspaceDetail struct {
	callback  TextViewSignalBackspaceCallback
	handlerID C.gulong
}

var signalTextViewBackspaceId int
var signalTextViewBackspaceMap = make(map[int]signalTextViewBackspaceDetail)
var signalTextViewBackspaceLock sync.Mutex

// TextViewSignalBackspaceCallback is a callback function for a 'backspace' signal emitted from a TextView.
type TextViewSignalBackspaceCallback func()

/*
ConnectBackspace connects the callback to the 'backspace' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectBackspace to remove it.
*/
func (recv *TextView) ConnectBackspace(callback TextViewSignalBackspaceCallback) int {
	signalTextViewBackspaceLock.Lock()
	defer signalTextViewBackspaceLock.Unlock()

	signalTextViewBackspaceId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_backspace(instance, C.gpointer(uintptr(signalTextViewBackspaceId)))

	detail := signalTextViewBackspaceDetail{callback, handlerID}
	signalTextViewBackspaceMap[signalTextViewBackspaceId] = detail

	return signalTextViewBackspaceId
}

/*
DisconnectBackspace disconnects a callback from the 'backspace' signal for the TextView.

The connectionID should be a value returned from a call to ConnectBackspace.
*/
func (recv *TextView) DisconnectBackspace(connectionID int) {
	signalTextViewBackspaceLock.Lock()
	defer signalTextViewBackspaceLock.Unlock()

	detail, exists := signalTextViewBackspaceMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewBackspaceMap, connectionID)
}

//export textview_backspaceHandler
func textview_backspaceHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewBackspaceMap[index].callback
	callback()
}

type signalTextViewCopyClipboardDetail struct {
	callback  TextViewSignalCopyClipboardCallback
	handlerID C.gulong
}

var signalTextViewCopyClipboardId int
var signalTextViewCopyClipboardMap = make(map[int]signalTextViewCopyClipboardDetail)
var signalTextViewCopyClipboardLock sync.Mutex

// TextViewSignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a TextView.
type TextViewSignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *TextView) ConnectCopyClipboard(callback TextViewSignalCopyClipboardCallback) int {
	signalTextViewCopyClipboardLock.Lock()
	defer signalTextViewCopyClipboardLock.Unlock()

	signalTextViewCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalTextViewCopyClipboardId)))

	detail := signalTextViewCopyClipboardDetail{callback, handlerID}
	signalTextViewCopyClipboardMap[signalTextViewCopyClipboardId] = detail

	return signalTextViewCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *TextView) DisconnectCopyClipboard(connectionID int) {
	signalTextViewCopyClipboardLock.Lock()
	defer signalTextViewCopyClipboardLock.Unlock()

	detail, exists := signalTextViewCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewCopyClipboardMap, connectionID)
}

//export textview_copyClipboardHandler
func textview_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewCopyClipboardMap[index].callback
	callback()
}

type signalTextViewCutClipboardDetail struct {
	callback  TextViewSignalCutClipboardCallback
	handlerID C.gulong
}

var signalTextViewCutClipboardId int
var signalTextViewCutClipboardMap = make(map[int]signalTextViewCutClipboardDetail)
var signalTextViewCutClipboardLock sync.Mutex

// TextViewSignalCutClipboardCallback is a callback function for a 'cut-clipboard' signal emitted from a TextView.
type TextViewSignalCutClipboardCallback func()

/*
ConnectCutClipboard connects the callback to the 'cut-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectCutClipboard to remove it.
*/
func (recv *TextView) ConnectCutClipboard(callback TextViewSignalCutClipboardCallback) int {
	signalTextViewCutClipboardLock.Lock()
	defer signalTextViewCutClipboardLock.Unlock()

	signalTextViewCutClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_cut_clipboard(instance, C.gpointer(uintptr(signalTextViewCutClipboardId)))

	detail := signalTextViewCutClipboardDetail{callback, handlerID}
	signalTextViewCutClipboardMap[signalTextViewCutClipboardId] = detail

	return signalTextViewCutClipboardId
}

/*
DisconnectCutClipboard disconnects a callback from the 'cut-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectCutClipboard.
*/
func (recv *TextView) DisconnectCutClipboard(connectionID int) {
	signalTextViewCutClipboardLock.Lock()
	defer signalTextViewCutClipboardLock.Unlock()

	detail, exists := signalTextViewCutClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewCutClipboardMap, connectionID)
}

//export textview_cutClipboardHandler
func textview_cutClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewCutClipboardMap[index].callback
	callback()
}

// Unsupported signal 'delete-from-cursor' for TextView : unsupported parameter type : type DeleteType :

// Unsupported signal 'insert-at-cursor' for TextView : unsupported parameter string : type utf8 :

// Unsupported signal 'move-cursor' for TextView : unsupported parameter step : type MovementStep :

// Unsupported signal 'move-viewport' for TextView : unsupported parameter step : type ScrollStep :

type signalTextViewPasteClipboardDetail struct {
	callback  TextViewSignalPasteClipboardCallback
	handlerID C.gulong
}

var signalTextViewPasteClipboardId int
var signalTextViewPasteClipboardMap = make(map[int]signalTextViewPasteClipboardDetail)
var signalTextViewPasteClipboardLock sync.Mutex

// TextViewSignalPasteClipboardCallback is a callback function for a 'paste-clipboard' signal emitted from a TextView.
type TextViewSignalPasteClipboardCallback func()

/*
ConnectPasteClipboard connects the callback to the 'paste-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectPasteClipboard to remove it.
*/
func (recv *TextView) ConnectPasteClipboard(callback TextViewSignalPasteClipboardCallback) int {
	signalTextViewPasteClipboardLock.Lock()
	defer signalTextViewPasteClipboardLock.Unlock()

	signalTextViewPasteClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_paste_clipboard(instance, C.gpointer(uintptr(signalTextViewPasteClipboardId)))

	detail := signalTextViewPasteClipboardDetail{callback, handlerID}
	signalTextViewPasteClipboardMap[signalTextViewPasteClipboardId] = detail

	return signalTextViewPasteClipboardId
}

/*
DisconnectPasteClipboard disconnects a callback from the 'paste-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectPasteClipboard.
*/
func (recv *TextView) DisconnectPasteClipboard(connectionID int) {
	signalTextViewPasteClipboardLock.Lock()
	defer signalTextViewPasteClipboardLock.Unlock()

	detail, exists := signalTextViewPasteClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewPasteClipboardMap, connectionID)
}

//export textview_pasteClipboardHandler
func textview_pasteClipboardHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewPasteClipboardMap[index].callback
	callback()
}

type signalTextViewPopulatePopupDetail struct {
	callback  TextViewSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalTextViewPopulatePopupId int
var signalTextViewPopulatePopupMap = make(map[int]signalTextViewPopulatePopupDetail)
var signalTextViewPopulatePopupLock sync.Mutex

// TextViewSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a TextView.
type TextViewSignalPopulatePopupCallback func(popup *Widget)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *TextView) ConnectPopulatePopup(callback TextViewSignalPopulatePopupCallback) int {
	signalTextViewPopulatePopupLock.Lock()
	defer signalTextViewPopulatePopupLock.Unlock()

	signalTextViewPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalTextViewPopulatePopupId)))

	detail := signalTextViewPopulatePopupDetail{callback, handlerID}
	signalTextViewPopulatePopupMap[signalTextViewPopulatePopupId] = detail

	return signalTextViewPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the TextView.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *TextView) DisconnectPopulatePopup(connectionID int) {
	signalTextViewPopulatePopupLock.Lock()
	defer signalTextViewPopulatePopupLock.Unlock()

	detail, exists := signalTextViewPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewPopulatePopupMap, connectionID)
}

//export textview_populatePopupHandler
func textview_populatePopupHandler(_ *C.GObject, c_popup *C.GtkWidget, data C.gpointer) {
	popup := WidgetNewFromC(unsafe.Pointer(c_popup))

	index := int(uintptr(data))
	callback := signalTextViewPopulatePopupMap[index].callback
	callback(popup)
}

type signalTextViewSelectAllDetail struct {
	callback  TextViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalTextViewSelectAllId int
var signalTextViewSelectAllMap = make(map[int]signalTextViewSelectAllDetail)
var signalTextViewSelectAllLock sync.Mutex

// TextViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a TextView.
type TextViewSignalSelectAllCallback func(select_ bool)

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *TextView) ConnectSelectAll(callback TextViewSignalSelectAllCallback) int {
	signalTextViewSelectAllLock.Lock()
	defer signalTextViewSelectAllLock.Unlock()

	signalTextViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_select_all(instance, C.gpointer(uintptr(signalTextViewSelectAllId)))

	detail := signalTextViewSelectAllDetail{callback, handlerID}
	signalTextViewSelectAllMap[signalTextViewSelectAllId] = detail

	return signalTextViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the TextView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *TextView) DisconnectSelectAll(connectionID int) {
	signalTextViewSelectAllLock.Lock()
	defer signalTextViewSelectAllLock.Unlock()

	detail, exists := signalTextViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewSelectAllMap, connectionID)
}

//export textview_selectAllHandler
func textview_selectAllHandler(_ *C.GObject, c_select C.gboolean, data C.gpointer) {
	select_ := c_select == C.TRUE

	index := int(uintptr(data))
	callback := signalTextViewSelectAllMap[index].callback
	callback(select_)
}

type signalTextViewSetAnchorDetail struct {
	callback  TextViewSignalSetAnchorCallback
	handlerID C.gulong
}

var signalTextViewSetAnchorId int
var signalTextViewSetAnchorMap = make(map[int]signalTextViewSetAnchorDetail)
var signalTextViewSetAnchorLock sync.Mutex

// TextViewSignalSetAnchorCallback is a callback function for a 'set-anchor' signal emitted from a TextView.
type TextViewSignalSetAnchorCallback func()

/*
ConnectSetAnchor connects the callback to the 'set-anchor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectSetAnchor to remove it.
*/
func (recv *TextView) ConnectSetAnchor(callback TextViewSignalSetAnchorCallback) int {
	signalTextViewSetAnchorLock.Lock()
	defer signalTextViewSetAnchorLock.Unlock()

	signalTextViewSetAnchorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_set_anchor(instance, C.gpointer(uintptr(signalTextViewSetAnchorId)))

	detail := signalTextViewSetAnchorDetail{callback, handlerID}
	signalTextViewSetAnchorMap[signalTextViewSetAnchorId] = detail

	return signalTextViewSetAnchorId
}

/*
DisconnectSetAnchor disconnects a callback from the 'set-anchor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectSetAnchor.
*/
func (recv *TextView) DisconnectSetAnchor(connectionID int) {
	signalTextViewSetAnchorLock.Lock()
	defer signalTextViewSetAnchorLock.Unlock()

	detail, exists := signalTextViewSetAnchorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewSetAnchorMap, connectionID)
}

//export textview_setAnchorHandler
func textview_setAnchorHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewSetAnchorMap[index].callback
	callback()
}

type signalTextViewToggleCursorVisibleDetail struct {
	callback  TextViewSignalToggleCursorVisibleCallback
	handlerID C.gulong
}

var signalTextViewToggleCursorVisibleId int
var signalTextViewToggleCursorVisibleMap = make(map[int]signalTextViewToggleCursorVisibleDetail)
var signalTextViewToggleCursorVisibleLock sync.Mutex

// TextViewSignalToggleCursorVisibleCallback is a callback function for a 'toggle-cursor-visible' signal emitted from a TextView.
type TextViewSignalToggleCursorVisibleCallback func()

/*
ConnectToggleCursorVisible connects the callback to the 'toggle-cursor-visible' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorVisible to remove it.
*/
func (recv *TextView) ConnectToggleCursorVisible(callback TextViewSignalToggleCursorVisibleCallback) int {
	signalTextViewToggleCursorVisibleLock.Lock()
	defer signalTextViewToggleCursorVisibleLock.Unlock()

	signalTextViewToggleCursorVisibleId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_toggle_cursor_visible(instance, C.gpointer(uintptr(signalTextViewToggleCursorVisibleId)))

	detail := signalTextViewToggleCursorVisibleDetail{callback, handlerID}
	signalTextViewToggleCursorVisibleMap[signalTextViewToggleCursorVisibleId] = detail

	return signalTextViewToggleCursorVisibleId
}

/*
DisconnectToggleCursorVisible disconnects a callback from the 'toggle-cursor-visible' signal for the TextView.

The connectionID should be a value returned from a call to ConnectToggleCursorVisible.
*/
func (recv *TextView) DisconnectToggleCursorVisible(connectionID int) {
	signalTextViewToggleCursorVisibleLock.Lock()
	defer signalTextViewToggleCursorVisibleLock.Unlock()

	detail, exists := signalTextViewToggleCursorVisibleMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewToggleCursorVisibleMap, connectionID)
}

//export textview_toggleCursorVisibleHandler
func textview_toggleCursorVisibleHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewToggleCursorVisibleMap[index].callback
	callback()
}

type signalTextViewToggleOverwriteDetail struct {
	callback  TextViewSignalToggleOverwriteCallback
	handlerID C.gulong
}

var signalTextViewToggleOverwriteId int
var signalTextViewToggleOverwriteMap = make(map[int]signalTextViewToggleOverwriteDetail)
var signalTextViewToggleOverwriteLock sync.Mutex

// TextViewSignalToggleOverwriteCallback is a callback function for a 'toggle-overwrite' signal emitted from a TextView.
type TextViewSignalToggleOverwriteCallback func()

/*
ConnectToggleOverwrite connects the callback to the 'toggle-overwrite' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectToggleOverwrite to remove it.
*/
func (recv *TextView) ConnectToggleOverwrite(callback TextViewSignalToggleOverwriteCallback) int {
	signalTextViewToggleOverwriteLock.Lock()
	defer signalTextViewToggleOverwriteLock.Unlock()

	signalTextViewToggleOverwriteId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_toggle_overwrite(instance, C.gpointer(uintptr(signalTextViewToggleOverwriteId)))

	detail := signalTextViewToggleOverwriteDetail{callback, handlerID}
	signalTextViewToggleOverwriteMap[signalTextViewToggleOverwriteId] = detail

	return signalTextViewToggleOverwriteId
}

/*
DisconnectToggleOverwrite disconnects a callback from the 'toggle-overwrite' signal for the TextView.

The connectionID should be a value returned from a call to ConnectToggleOverwrite.
*/
func (recv *TextView) DisconnectToggleOverwrite(connectionID int) {
	signalTextViewToggleOverwriteLock.Lock()
	defer signalTextViewToggleOverwriteLock.Unlock()

	detail, exists := signalTextViewToggleOverwriteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewToggleOverwriteMap, connectionID)
}

//export textview_toggleOverwriteHandler
func textview_toggleOverwriteHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTextViewToggleOverwriteMap[index].callback
	callback()
}

// Creates a new #GtkTextView. If you don’t call gtk_text_view_set_buffer()
// before using the text view, an empty default buffer will be created
// for you. Get the buffer with gtk_text_view_get_buffer(). If you want
// to specify your own buffer, consider gtk_text_view_new_with_buffer().
/*

C function : gtk_text_view_new
*/
func TextViewNew() *TextView {
	retC := C.gtk_text_view_new()
	retGo := TextViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkTextView widget displaying the buffer
// @buffer. One buffer can be shared among many widgets.
// @buffer may be %NULL to create a default buffer, in which case
// this function is equivalent to gtk_text_view_new(). The
// text view adds its own reference count to the buffer; it does not
// take over an existing reference.
/*

C function : gtk_text_view_new_with_buffer
*/
func TextViewNewWithBuffer(buffer *TextBuffer) *TextView {
	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	retC := C.gtk_text_view_new_with_buffer(c_buffer)
	retGo := TextViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a child widget in the text buffer, at the given @anchor.
/*

C function : gtk_text_view_add_child_at_anchor
*/
func (recv *TextView) AddChildAtAnchor(child *Widget, anchor *TextChildAnchor) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_view_add_child_at_anchor((*C.GtkTextView)(recv.native), c_child, c_anchor)

	return
}

// Adds a child at fixed coordinates in one of the text widget's
// windows.
//
// The window must have nonzero size (see
// gtk_text_view_set_border_window_size()). Note that the child
// coordinates are given relative to scrolling. When
// placing a child in #GTK_TEXT_WINDOW_WIDGET, scrolling is
// irrelevant, the child floats above all scrollable areas. But when
// placing a child in one of the scrollable windows (border windows or
// text window) it will move with the scrolling as needed.
/*

C function : gtk_text_view_add_child_in_window
*/
func (recv *TextView) AddChildInWindow(child *Widget, whichWindow TextWindowType, xpos int32, ypos int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_which_window := (C.GtkTextWindowType)(whichWindow)

	c_xpos := (C.gint)(xpos)

	c_ypos := (C.gint)(ypos)

	C.gtk_text_view_add_child_in_window((*C.GtkTextView)(recv.native), c_child, c_which_window, c_xpos, c_ypos)

	return
}

// Moves the given @iter backward by one display (wrapped) line.
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the #GtkTextBuffer.
/*

C function : gtk_text_view_backward_display_line
*/
func (recv *TextView) BackwardDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_backward_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Moves the given @iter backward to the next display line start.
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the #GtkTextBuffer.
/*

C function : gtk_text_view_backward_display_line_start
*/
func (recv *TextView) BackwardDisplayLineStart(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_backward_display_line_start((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Converts coordinate (@buffer_x, @buffer_y) to coordinates for the window
// @win, and stores the result in (@window_x, @window_y).
//
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
/*

C function : gtk_text_view_buffer_to_window_coords
*/
func (recv *TextView) BufferToWindowCoords(win TextWindowType, bufferX int32, bufferY int32) (int32, int32) {
	c_win := (C.GtkTextWindowType)(win)

	c_buffer_x := (C.gint)(bufferX)

	c_buffer_y := (C.gint)(bufferY)

	var c_window_x C.gint

	var c_window_y C.gint

	C.gtk_text_view_buffer_to_window_coords((*C.GtkTextView)(recv.native), c_win, c_buffer_x, c_buffer_y, &c_window_x, &c_window_y)

	windowX := (int32)(c_window_x)

	windowY := (int32)(c_window_y)

	return windowX, windowY
}

// Moves the given @iter forward by one display (wrapped) line.
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the #GtkTextBuffer.
/*

C function : gtk_text_view_forward_display_line
*/
func (recv *TextView) ForwardDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_forward_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Moves the given @iter forward to the next display line end.
// A display line is different from a paragraph. Paragraphs are
// separated by newlines or other paragraph separator characters.
// Display lines are created by line-wrapping a paragraph. If
// wrapping is turned off, display lines and paragraphs will be the
// same. Display lines are divided differently for each view, since
// they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the #GtkTextBuffer.
/*

C function : gtk_text_view_forward_display_line_end
*/
func (recv *TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_forward_display_line_end((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Gets the width of the specified border window. See
// gtk_text_view_set_border_window_size().
/*

C function : gtk_text_view_get_border_window_size
*/
func (recv *TextView) GetBorderWindowSize(type_ TextWindowType) int32 {
	c_type := (C.GtkTextWindowType)(type_)

	retC := C.gtk_text_view_get_border_window_size((*C.GtkTextView)(recv.native), c_type)
	retGo := (int32)(retC)

	return retGo
}

// Returns the #GtkTextBuffer being displayed by this text view.
// The reference count on the buffer is not incremented; the caller
// of this function won’t own a new reference.
/*

C function : gtk_text_view_get_buffer
*/
func (recv *TextView) GetBuffer() *TextBuffer {
	retC := C.gtk_text_view_get_buffer((*C.GtkTextView)(recv.native))
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Find out whether the cursor should be displayed.
/*

C function : gtk_text_view_get_cursor_visible
*/
func (recv *TextView) GetCursorVisible() bool {
	retC := C.gtk_text_view_get_cursor_visible((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Obtains a copy of the default text attributes. These are the
// attributes used for text unless a tag overrides them.
// You’d typically pass the default attributes in to
// gtk_text_iter_get_attributes() in order to get the
// attributes in effect at a given text position.
//
// The return value is a copy owned by the caller of this function,
// and should be freed with gtk_text_attributes_unref().
/*

C function : gtk_text_view_get_default_attributes
*/
func (recv *TextView) GetDefaultAttributes() *TextAttributes {
	retC := C.gtk_text_view_get_default_attributes((*C.GtkTextView)(recv.native))
	retGo := TextAttributesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the default editability of the #GtkTextView. Tags in the
// buffer may override this setting for some ranges of text.
/*

C function : gtk_text_view_get_editable
*/
func (recv *TextView) GetEditable() bool {
	retC := C.gtk_text_view_get_editable((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the default indentation of paragraphs in @text_view.
// Tags in the view’s buffer may override the default.
// The indentation may be negative.
/*

C function : gtk_text_view_get_indent
*/
func (recv *TextView) GetIndent() int32 {
	retC := C.gtk_text_view_get_indent((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Retrieves the iterator at buffer coordinates @x and @y. Buffer
// coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion.  If you have coordinates from an
// event, you have to convert those to buffer coordinates with
// gtk_text_view_window_to_buffer_coords().
/*

C function : gtk_text_view_get_iter_at_location
*/
func (recv *TextView) GetIterAtLocation(x int32, y int32) *TextIter {
	var c_iter C.GtkTextIter

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_text_view_get_iter_at_location((*C.GtkTextView)(recv.native), &c_iter, c_x, c_y)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Unsupported : gtk_text_view_get_iter_location : unsupported parameter location : Blacklisted record : GdkRectangle

// Gets the default justification of paragraphs in @text_view.
// Tags in the buffer may override the default.
/*

C function : gtk_text_view_get_justification
*/
func (recv *TextView) GetJustification() Justification {
	retC := C.gtk_text_view_get_justification((*C.GtkTextView)(recv.native))
	retGo := (Justification)(retC)

	return retGo
}

// Gets the default left margin size of paragraphs in the @text_view.
// Tags in the buffer may override the default.
/*

C function : gtk_text_view_get_left_margin
*/
func (recv *TextView) GetLeftMargin() int32 {
	retC := C.gtk_text_view_get_left_margin((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the #GtkTextIter at the start of the line containing
// the coordinate @y. @y is in buffer coordinates, convert from
// window coordinates with gtk_text_view_window_to_buffer_coords().
// If non-%NULL, @line_top will be filled with the coordinate of the top
// edge of the line.
/*

C function : gtk_text_view_get_line_at_y
*/
func (recv *TextView) GetLineAtY(y int32) (*TextIter, int32) {
	var c_target_iter C.GtkTextIter

	c_y := (C.gint)(y)

	var c_line_top C.gint

	C.gtk_text_view_get_line_at_y((*C.GtkTextView)(recv.native), &c_target_iter, c_y, &c_line_top)

	targetIter := TextIterNewFromC(unsafe.Pointer(&c_target_iter))

	lineTop := (int32)(c_line_top)

	return targetIter, lineTop
}

// Gets the y coordinate of the top of the line containing @iter,
// and the height of the line. The coordinate is a buffer coordinate;
// convert to window coordinates with gtk_text_view_buffer_to_window_coords().
/*

C function : gtk_text_view_get_line_yrange
*/
func (recv *TextView) GetLineYrange(iter *TextIter) (int32, int32) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	var c_y C.gint

	var c_height C.gint

	C.gtk_text_view_get_line_yrange((*C.GtkTextView)(recv.native), c_iter, &c_y, &c_height)

	y := (int32)(c_y)

	height := (int32)(c_height)

	return y, height
}

// Gets the default number of pixels to put above paragraphs.
// Adding this function with gtk_text_view_get_pixels_below_lines()
// is equal to the line space between each paragraph.
/*

C function : gtk_text_view_get_pixels_above_lines
*/
func (recv *TextView) GetPixelsAboveLines() int32 {
	retC := C.gtk_text_view_get_pixels_above_lines((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the value set by gtk_text_view_set_pixels_below_lines().
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk_text_view_get_pixels_above_lines().
/*

C function : gtk_text_view_get_pixels_below_lines
*/
func (recv *TextView) GetPixelsBelowLines() int32 {
	retC := C.gtk_text_view_get_pixels_below_lines((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the value set by gtk_text_view_set_pixels_inside_wrap().
/*

C function : gtk_text_view_get_pixels_inside_wrap
*/
func (recv *TextView) GetPixelsInsideWrap() int32 {
	retC := C.gtk_text_view_get_pixels_inside_wrap((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the default right margin for text in @text_view. Tags
// in the buffer may override the default.
/*

C function : gtk_text_view_get_right_margin
*/
func (recv *TextView) GetRightMargin() int32 {
	retC := C.gtk_text_view_get_right_margin((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the default tabs for @text_view. Tags in the buffer may
// override the defaults. The returned array will be %NULL if
// “standard” (8-space) tabs are used. Free the return value
// with pango_tab_array_free().
/*

C function : gtk_text_view_get_tabs
*/
func (recv *TextView) GetTabs() *pango.TabArray {
	retC := C.gtk_text_view_get_tabs((*C.GtkTextView)(recv.native))
	var retGo (*pango.TabArray)
	if retC == nil {
		retGo = nil
	} else {
		retGo = pango.TabArrayNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_text_view_get_visible_rect : unsupported parameter visible_rect : Blacklisted record : GdkRectangle

// Retrieves the #GdkWindow corresponding to an area of the text view;
// possible windows include the overall widget window, child windows
// on the left, right, top, bottom, and the window that displays the
// text buffer. Windows are %NULL and nonexistent if their width or
// height is 0, and are nonexistent before the widget has been
// realized.
/*

C function : gtk_text_view_get_window
*/
func (recv *TextView) GetWindow(win TextWindowType) *gdk.Window {
	c_win := (C.GtkTextWindowType)(win)

	retC := C.gtk_text_view_get_window((*C.GtkTextView)(recv.native), c_win)
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Usually used to find out which window an event corresponds to.
//
// If you connect to an event signal on @text_view, this function
// should be called on `event->window` to see which window it was.
/*

C function : gtk_text_view_get_window_type
*/
func (recv *TextView) GetWindowType(window *gdk.Window) TextWindowType {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	retC := C.gtk_text_view_get_window_type((*C.GtkTextView)(recv.native), c_window)
	retGo := (TextWindowType)(retC)

	return retGo
}

// Gets the line wrapping for the view.
/*

C function : gtk_text_view_get_wrap_mode
*/
func (recv *TextView) GetWrapMode() WrapMode {
	retC := C.gtk_text_view_get_wrap_mode((*C.GtkTextView)(recv.native))
	retGo := (WrapMode)(retC)

	return retGo
}

// Updates the position of a child, as for gtk_text_view_add_child_in_window().
/*

C function : gtk_text_view_move_child
*/
func (recv *TextView) MoveChild(child *Widget, xpos int32, ypos int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_xpos := (C.gint)(xpos)

	c_ypos := (C.gint)(ypos)

	C.gtk_text_view_move_child((*C.GtkTextView)(recv.native), c_child, c_xpos, c_ypos)

	return
}

// Moves a mark within the buffer so that it's
// located within the currently-visible text area.
/*

C function : gtk_text_view_move_mark_onscreen
*/
func (recv *TextView) MoveMarkOnscreen(mark *TextMark) bool {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	retC := C.gtk_text_view_move_mark_onscreen((*C.GtkTextView)(recv.native), c_mark)
	retGo := retC == C.TRUE

	return retGo
}

// Move the iterator a given number of characters visually, treating
// it as the strong cursor position. If @count is positive, then the
// new strong cursor position will be @count positions to the right of
// the old cursor position. If @count is negative then the new strong
// cursor position will be @count positions to the left of the old
// cursor position.
//
// In the presence of bi-directional text, the correspondence
// between logical and visual order will depend on the direction
// of the current run, and there may be jumps when the cursor
// is moved off of the end of a run.
/*

C function : gtk_text_view_move_visually
*/
func (recv *TextView) MoveVisually(iter *TextIter, count int32) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_count := (C.gint)(count)

	retC := C.gtk_text_view_move_visually((*C.GtkTextView)(recv.native), c_iter, c_count)
	retGo := retC == C.TRUE

	return retGo
}

// Moves the cursor to the currently visible region of the
// buffer, it it isn’t there already.
/*

C function : gtk_text_view_place_cursor_onscreen
*/
func (recv *TextView) PlaceCursorOnscreen() bool {
	retC := C.gtk_text_view_place_cursor_onscreen((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Scrolls @text_view the minimum distance such that @mark is contained
// within the visible area of the widget.
/*

C function : gtk_text_view_scroll_mark_onscreen
*/
func (recv *TextView) ScrollMarkOnscreen(mark *TextMark) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_view_scroll_mark_onscreen((*C.GtkTextView)(recv.native), c_mark)

	return
}

// Scrolls @text_view so that @iter is on the screen in the position
// indicated by @xalign and @yalign. An alignment of 0.0 indicates
// left or top, 1.0 indicates right or bottom, 0.5 means center.
// If @use_align is %FALSE, the text scrolls the minimal distance to
// get the mark onscreen, possibly not scrolling at all. The effective
// screen for purposes of this function is reduced by a margin of size
// @within_margin.
//
// Note that this function uses the currently-computed height of the
// lines in the text buffer. Line heights are computed in an idle
// handler; so this function may not have the desired effect if it’s
// called before the height computations. To avoid oddness, consider
// using gtk_text_view_scroll_to_mark() which saves a point to be
// scrolled to after line validation.
/*

C function : gtk_text_view_scroll_to_iter
*/
func (recv *TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_within_margin := (C.gdouble)(withinMargin)

	c_use_align :=
		boolToGboolean(useAlign)

	c_xalign := (C.gdouble)(xalign)

	c_yalign := (C.gdouble)(yalign)

	retC := C.gtk_text_view_scroll_to_iter((*C.GtkTextView)(recv.native), c_iter, c_within_margin, c_use_align, c_xalign, c_yalign)
	retGo := retC == C.TRUE

	return retGo
}

// Scrolls @text_view so that @mark is on the screen in the position
// indicated by @xalign and @yalign. An alignment of 0.0 indicates
// left or top, 1.0 indicates right or bottom, 0.5 means center.
// If @use_align is %FALSE, the text scrolls the minimal distance to
// get the mark onscreen, possibly not scrolling at all. The effective
// screen for purposes of this function is reduced by a margin of size
// @within_margin.
/*

C function : gtk_text_view_scroll_to_mark
*/
func (recv *TextView) ScrollToMark(mark *TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	c_within_margin := (C.gdouble)(withinMargin)

	c_use_align :=
		boolToGboolean(useAlign)

	c_xalign := (C.gdouble)(xalign)

	c_yalign := (C.gdouble)(yalign)

	C.gtk_text_view_scroll_to_mark((*C.GtkTextView)(recv.native), c_mark, c_within_margin, c_use_align, c_xalign, c_yalign)

	return
}

// Sets the width of %GTK_TEXT_WINDOW_LEFT or %GTK_TEXT_WINDOW_RIGHT,
// or the height of %GTK_TEXT_WINDOW_TOP or %GTK_TEXT_WINDOW_BOTTOM.
// Automatically destroys the corresponding window if the size is set
// to 0, and creates the window if the size is set to non-zero.  This
// function can only be used for the “border windows”, and it won’t
// work with %GTK_TEXT_WINDOW_WIDGET, %GTK_TEXT_WINDOW_TEXT, or
// %GTK_TEXT_WINDOW_PRIVATE.
/*

C function : gtk_text_view_set_border_window_size
*/
func (recv *TextView) SetBorderWindowSize(type_ TextWindowType, size int32) {
	c_type := (C.GtkTextWindowType)(type_)

	c_size := (C.gint)(size)

	C.gtk_text_view_set_border_window_size((*C.GtkTextView)(recv.native), c_type, c_size)

	return
}

// Sets @buffer as the buffer being displayed by @text_view. The previous
// buffer displayed by the text view is unreferenced, and a reference is
// added to @buffer. If you owned a reference to @buffer before passing it
// to this function, you must remove that reference yourself; #GtkTextView
// will not “adopt” it.
/*

C function : gtk_text_view_set_buffer
*/
func (recv *TextView) SetBuffer(buffer *TextBuffer) {
	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	C.gtk_text_view_set_buffer((*C.GtkTextView)(recv.native), c_buffer)

	return
}

// Toggles whether the insertion point should be displayed. A buffer with
// no editable text probably shouldn’t have a visible cursor, so you may
// want to turn the cursor off.
//
// Note that this property may be overridden by the
// #GtkSettings:gtk-keynave-use-caret settings.
/*

C function : gtk_text_view_set_cursor_visible
*/
func (recv *TextView) SetCursorVisible(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_view_set_cursor_visible((*C.GtkTextView)(recv.native), c_setting)

	return
}

// Sets the default editability of the #GtkTextView. You can override
// this default setting with tags in the buffer, using the “editable”
// attribute of tags.
/*

C function : gtk_text_view_set_editable
*/
func (recv *TextView) SetEditable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_view_set_editable((*C.GtkTextView)(recv.native), c_setting)

	return
}

// Sets the default indentation for paragraphs in @text_view.
// Tags in the buffer may override the default.
/*

C function : gtk_text_view_set_indent
*/
func (recv *TextView) SetIndent(indent int32) {
	c_indent := (C.gint)(indent)

	C.gtk_text_view_set_indent((*C.GtkTextView)(recv.native), c_indent)

	return
}

// Sets the default justification of text in @text_view.
// Tags in the view’s buffer may override the default.
/*

C function : gtk_text_view_set_justification
*/
func (recv *TextView) SetJustification(justification Justification) {
	c_justification := (C.GtkJustification)(justification)

	C.gtk_text_view_set_justification((*C.GtkTextView)(recv.native), c_justification)

	return
}

// Sets the default left margin for text in @text_view.
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named.
// In CSS terms, the value set here is padding.
/*

C function : gtk_text_view_set_left_margin
*/
func (recv *TextView) SetLeftMargin(leftMargin int32) {
	c_left_margin := (C.gint)(leftMargin)

	C.gtk_text_view_set_left_margin((*C.GtkTextView)(recv.native), c_left_margin)

	return
}

// Sets the default number of blank pixels above paragraphs in @text_view.
// Tags in the buffer for @text_view may override the defaults.
/*

C function : gtk_text_view_set_pixels_above_lines
*/
func (recv *TextView) SetPixelsAboveLines(pixelsAboveLines int32) {
	c_pixels_above_lines := (C.gint)(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines((*C.GtkTextView)(recv.native), c_pixels_above_lines)

	return
}

// Sets the default number of pixels of blank space
// to put below paragraphs in @text_view. May be overridden
// by tags applied to @text_view’s buffer.
/*

C function : gtk_text_view_set_pixels_below_lines
*/
func (recv *TextView) SetPixelsBelowLines(pixelsBelowLines int32) {
	c_pixels_below_lines := (C.gint)(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines((*C.GtkTextView)(recv.native), c_pixels_below_lines)

	return
}

// Sets the default number of pixels of blank space to leave between
// display/wrapped lines within a paragraph. May be overridden by
// tags in @text_view’s buffer.
/*

C function : gtk_text_view_set_pixels_inside_wrap
*/
func (recv *TextView) SetPixelsInsideWrap(pixelsInsideWrap int32) {
	c_pixels_inside_wrap := (C.gint)(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap((*C.GtkTextView)(recv.native), c_pixels_inside_wrap)

	return
}

// Sets the default right margin for text in the text view.
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named.
// In CSS terms, the value set here is padding.
/*

C function : gtk_text_view_set_right_margin
*/
func (recv *TextView) SetRightMargin(rightMargin int32) {
	c_right_margin := (C.gint)(rightMargin)

	C.gtk_text_view_set_right_margin((*C.GtkTextView)(recv.native), c_right_margin)

	return
}

// Sets the default tab stops for paragraphs in @text_view.
// Tags in the buffer may override the default.
/*

C function : gtk_text_view_set_tabs
*/
func (recv *TextView) SetTabs(tabs *pango.TabArray) {
	c_tabs := (*C.PangoTabArray)(C.NULL)
	if tabs != nil {
		c_tabs = (*C.PangoTabArray)(tabs.ToC())
	}

	C.gtk_text_view_set_tabs((*C.GtkTextView)(recv.native), c_tabs)

	return
}

// Sets the line wrapping for the view.
/*

C function : gtk_text_view_set_wrap_mode
*/
func (recv *TextView) SetWrapMode(wrapMode WrapMode) {
	c_wrap_mode := (C.GtkWrapMode)(wrapMode)

	C.gtk_text_view_set_wrap_mode((*C.GtkTextView)(recv.native), c_wrap_mode)

	return
}

// Determines whether @iter is at the start of a display line.
// See gtk_text_view_forward_display_line() for an explanation of
// display lines vs. paragraphs.
/*

C function : gtk_text_view_starts_display_line
*/
func (recv *TextView) StartsDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_starts_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Converts coordinates on the window identified by @win to buffer
// coordinates, storing the result in (@buffer_x,@buffer_y).
//
// Note that you can’t convert coordinates for a nonexisting window (see
// gtk_text_view_set_border_window_size()).
/*

C function : gtk_text_view_window_to_buffer_coords
*/
func (recv *TextView) WindowToBufferCoords(win TextWindowType, windowX int32, windowY int32) (int32, int32) {
	c_win := (C.GtkTextWindowType)(win)

	c_window_x := (C.gint)(windowX)

	c_window_y := (C.gint)(windowY)

	var c_buffer_x C.gint

	var c_buffer_y C.gint

	C.gtk_text_view_window_to_buffer_coords((*C.GtkTextView)(recv.native), c_win, c_window_x, c_window_y, &c_buffer_x, &c_buffer_y)

	bufferX := (int32)(c_buffer_x)

	bufferY := (int32)(c_buffer_y)

	return bufferX, bufferY
}

// ImplementorIface returns the ImplementorIface interface implemented by TextView
func (recv *TextView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TextView
func (recv *TextView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by TextView
func (recv *TextView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// TextViewAccessible is a wrapper around the C record GtkTextViewAccessible.
type TextViewAccessible struct {
	native *C.GtkTextViewAccessible
	// parent : record
	// priv : record
}

func TextViewAccessibleNewFromC(u unsafe.Pointer) *TextViewAccessible {
	c := (*C.GtkTextViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TextViewAccessible{native: c}

	return g
}

func (recv *TextViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *TextViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *TextViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TextViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TextViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to TextViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextViewAccessible.
func CastToTextViewAccessible(object *gobject.Object) *TextViewAccessible {
	return TextViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by TextViewAccessible
func (recv *TextViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by TextViewAccessible
func (recv *TextViewAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// StreamableContent returns the StreamableContent interface implemented by TextViewAccessible
func (recv *TextViewAccessible) StreamableContent() *atk.StreamableContent {
	return atk.StreamableContentNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by TextViewAccessible
func (recv *TextViewAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// ThemingEngine is a wrapper around the C record GtkThemingEngine.
type ThemingEngine struct {
	native *C.GtkThemingEngine
	// parent_object : record
	// priv : record
}

func ThemingEngineNewFromC(u unsafe.Pointer) *ThemingEngine {
	c := (*C.GtkThemingEngine)(u)
	if c == nil {
		return nil
	}

	g := &ThemingEngine{native: c}

	return g
}

func (recv *ThemingEngine) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *ThemingEngine) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to ThemingEngine.
// Exercise care, as this is a potentially dangerous function if the Object is not a ThemingEngine.
func CastToThemingEngine(object *gobject.Object) *ThemingEngine {
	return ThemingEngineNewFromC(object.ToC())
}

// Returns the #GdkScreen to which @engine currently rendering to.
/*

C function : gtk_theming_engine_get_screen
*/
func (recv *ThemingEngine) GetScreen() *gdk.Screen {
	retC := C.gtk_theming_engine_get_screen((*C.GtkThemingEngine)(recv.native))
	var retGo (*gdk.Screen)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.ScreenNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ToggleAction is a wrapper around the C record GtkToggleAction.
type ToggleAction struct {
	native *C.GtkToggleAction
	// parent : record
	// Private : private_data
}

func ToggleActionNewFromC(u unsafe.Pointer) *ToggleAction {
	c := (*C.GtkToggleAction)(u)
	if c == nil {
		return nil
	}

	g := &ToggleAction{native: c}

	return g
}

func (recv *ToggleAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Action upcasts to *Action
func (recv *ToggleAction) Action() *Action {
	return ActionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *ToggleAction) Object() *gobject.Object {
	return recv.Action().Object()
}

// CastToWidget down casts any arbitary Object to ToggleAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleAction.
func CastToToggleAction(object *gobject.Object) *ToggleAction {
	return ToggleActionNewFromC(object.ToC())
}

type signalToggleActionToggledDetail struct {
	callback  ToggleActionSignalToggledCallback
	handlerID C.gulong
}

var signalToggleActionToggledId int
var signalToggleActionToggledMap = make(map[int]signalToggleActionToggledDetail)
var signalToggleActionToggledLock sync.Mutex

// ToggleActionSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleAction.
type ToggleActionSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleAction.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleAction) ConnectToggled(callback ToggleActionSignalToggledCallback) int {
	signalToggleActionToggledLock.Lock()
	defer signalToggleActionToggledLock.Unlock()

	signalToggleActionToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleAction_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleActionToggledId)))

	detail := signalToggleActionToggledDetail{callback, handlerID}
	signalToggleActionToggledMap[signalToggleActionToggledId] = detail

	return signalToggleActionToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleAction.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleAction) DisconnectToggled(connectionID int) {
	signalToggleActionToggledLock.Lock()
	defer signalToggleActionToggledLock.Unlock()

	detail, exists := signalToggleActionToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleActionToggledMap, connectionID)
}

//export toggleaction_toggledHandler
func toggleaction_toggledHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToggleActionToggledMap[index].callback
	callback()
}

// Buildable returns the Buildable interface implemented by ToggleAction
func (recv *ToggleAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToggleButton is a wrapper around the C record GtkToggleButton.
type ToggleButton struct {
	native *C.GtkToggleButton
	// Private : button
	// Private : priv
}

func ToggleButtonNewFromC(u unsafe.Pointer) *ToggleButton {
	c := (*C.GtkToggleButton)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButton{native: c}

	return g
}

func (recv *ToggleButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Button upcasts to *Button
func (recv *ToggleButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ToggleButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ToggleButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ToggleButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToggleButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToggleButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitary Object to ToggleButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleButton.
func CastToToggleButton(object *gobject.Object) *ToggleButton {
	return ToggleButtonNewFromC(object.ToC())
}

type signalToggleButtonToggledDetail struct {
	callback  ToggleButtonSignalToggledCallback
	handlerID C.gulong
}

var signalToggleButtonToggledId int
var signalToggleButtonToggledMap = make(map[int]signalToggleButtonToggledDetail)
var signalToggleButtonToggledLock sync.Mutex

// ToggleButtonSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleButton.
type ToggleButtonSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleButton.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleButton) ConnectToggled(callback ToggleButtonSignalToggledCallback) int {
	signalToggleButtonToggledLock.Lock()
	defer signalToggleButtonToggledLock.Unlock()

	signalToggleButtonToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleButton_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleButtonToggledId)))

	detail := signalToggleButtonToggledDetail{callback, handlerID}
	signalToggleButtonToggledMap[signalToggleButtonToggledId] = detail

	return signalToggleButtonToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleButton.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleButton) DisconnectToggled(connectionID int) {
	signalToggleButtonToggledLock.Lock()
	defer signalToggleButtonToggledLock.Unlock()

	detail, exists := signalToggleButtonToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleButtonToggledMap, connectionID)
}

//export togglebutton_toggledHandler
func togglebutton_toggledHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToggleButtonToggledMap[index].callback
	callback()
}

// Creates a new toggle button. A widget should be packed into the button, as in gtk_button_new().
/*

C function : gtk_toggle_button_new
*/
func ToggleButtonNew() *ToggleButton {
	retC := C.gtk_toggle_button_new()
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new toggle button with a text label.
/*

C function : gtk_toggle_button_new_with_label
*/
func ToggleButtonNewWithLabel(label string) *ToggleButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_toggle_button_new_with_label(c_label)
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkToggleButton containing a label. The label
// will be created using gtk_label_new_with_mnemonic(), so underscores
// in @label indicate the mnemonic for the button.
/*

C function : gtk_toggle_button_new_with_mnemonic
*/
func ToggleButtonNewWithMnemonic(label string) *ToggleButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_toggle_button_new_with_mnemonic(c_label)
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Queries a #GtkToggleButton and returns its current state. Returns %TRUE if
// the toggle button is pressed in and %FALSE if it is raised.
/*

C function : gtk_toggle_button_get_active
*/
func (recv *ToggleButton) GetActive() bool {
	retC := C.gtk_toggle_button_get_active((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_toggle_button_set_inconsistent().
/*

C function : gtk_toggle_button_get_inconsistent
*/
func (recv *ToggleButton) GetInconsistent() bool {
	retC := C.gtk_toggle_button_get_inconsistent((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves whether the button is displayed as a separate indicator
// and label. See gtk_toggle_button_set_mode().
/*

C function : gtk_toggle_button_get_mode
*/
func (recv *ToggleButton) GetMode() bool {
	retC := C.gtk_toggle_button_get_mode((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the status of the toggle button. Set to %TRUE if you want the
// GtkToggleButton to be “pressed in”, and %FALSE to raise it.
// This action causes the #GtkToggleButton::toggled signal and the
// #GtkButton::clicked signal to be emitted.
/*

C function : gtk_toggle_button_set_active
*/
func (recv *ToggleButton) SetActive(isActive bool) {
	c_is_active :=
		boolToGboolean(isActive)

	C.gtk_toggle_button_set_active((*C.GtkToggleButton)(recv.native), c_is_active)

	return
}

// If the user has selected a range of elements (such as some text or
// spreadsheet cells) that are affected by a toggle button, and the
// current values in that range are inconsistent, you may want to
// display the toggle in an “in between” state. This function turns on
// “in between” display.  Normally you would turn off the inconsistent
// state again if the user toggles the toggle button. This has to be
// done manually, gtk_toggle_button_set_inconsistent() only affects
// visual appearance, it doesn’t affect the semantics of the button.
/*

C function : gtk_toggle_button_set_inconsistent
*/
func (recv *ToggleButton) SetInconsistent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_toggle_button_set_inconsistent((*C.GtkToggleButton)(recv.native), c_setting)

	return
}

// Sets whether the button is displayed as a separate indicator and label.
// You can call this function on a checkbutton or a radiobutton with
// @draw_indicator = %FALSE to make the button look like a normal button.
//
// This can be used to create linked strip of buttons that work like
// a #GtkStackSwitcher.
//
// This function only affects instances of classes like #GtkCheckButton
// and #GtkRadioButton that derive from #GtkToggleButton,
// not instances of #GtkToggleButton itself.
/*

C function : gtk_toggle_button_set_mode
*/
func (recv *ToggleButton) SetMode(drawIndicator bool) {
	c_draw_indicator :=
		boolToGboolean(drawIndicator)

	C.gtk_toggle_button_set_mode((*C.GtkToggleButton)(recv.native), c_draw_indicator)

	return
}

// Emits the #GtkToggleButton::toggled signal on the
// #GtkToggleButton. There is no good reason for an
// application ever to call this function.
/*

C function : gtk_toggle_button_toggled
*/
func (recv *ToggleButton) Toggled() {
	C.gtk_toggle_button_toggled((*C.GtkToggleButton)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ToggleButton
func (recv *ToggleButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToggleButton
func (recv *ToggleButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToggleButton
func (recv *ToggleButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToggleButton
func (recv *ToggleButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToggleButtonAccessible is a wrapper around the C record GtkToggleButtonAccessible.
type ToggleButtonAccessible struct {
	native *C.GtkToggleButtonAccessible
	// parent : record
	// priv : record
}

func ToggleButtonAccessibleNewFromC(u unsafe.Pointer) *ToggleButtonAccessible {
	c := (*C.GtkToggleButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButtonAccessible{native: c}

	return g
}

func (recv *ToggleButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *ToggleButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ToggleButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ToggleButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ToggleButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ToggleButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitary Object to ToggleButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleButtonAccessible.
func CastToToggleButtonAccessible(object *gobject.Object) *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ToggleToolButton is a wrapper around the C record GtkToggleToolButton.
type ToggleToolButton struct {
	native *C.GtkToggleToolButton
	// parent : record
	// Private : priv
}

func ToggleToolButtonNewFromC(u unsafe.Pointer) *ToggleToolButton {
	c := (*C.GtkToggleToolButton)(u)
	if c == nil {
		return nil
	}

	g := &ToggleToolButton{native: c}

	return g
}

func (recv *ToggleToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToolButton upcasts to *ToolButton
func (recv *ToggleToolButton) ToolButton() *ToolButton {
	return ToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolItem upcasts to *ToolItem
func (recv *ToggleToolButton) ToolItem() *ToolItem {
	return recv.ToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *ToggleToolButton) Bin() *Bin {
	return recv.ToolButton().Bin()
}

// Container upcasts to *Container
func (recv *ToggleToolButton) Container() *Container {
	return recv.ToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *ToggleToolButton) Widget() *Widget {
	return recv.ToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToggleToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToggleToolButton) Object() *gobject.Object {
	return recv.ToolButton().Object()
}

// CastToWidget down casts any arbitary Object to ToggleToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleToolButton.
func CastToToggleToolButton(object *gobject.Object) *ToggleToolButton {
	return ToggleToolButtonNewFromC(object.ToC())
}

type signalToggleToolButtonToggledDetail struct {
	callback  ToggleToolButtonSignalToggledCallback
	handlerID C.gulong
}

var signalToggleToolButtonToggledId int
var signalToggleToolButtonToggledMap = make(map[int]signalToggleToolButtonToggledDetail)
var signalToggleToolButtonToggledLock sync.Mutex

// ToggleToolButtonSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleToolButton.
type ToggleToolButtonSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleToolButton.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleToolButton) ConnectToggled(callback ToggleToolButtonSignalToggledCallback) int {
	signalToggleToolButtonToggledLock.Lock()
	defer signalToggleToolButtonToggledLock.Unlock()

	signalToggleToolButtonToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleToolButton_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleToolButtonToggledId)))

	detail := signalToggleToolButtonToggledDetail{callback, handlerID}
	signalToggleToolButtonToggledMap[signalToggleToolButtonToggledId] = detail

	return signalToggleToolButtonToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleToolButton.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleToolButton) DisconnectToggled(connectionID int) {
	signalToggleToolButtonToggledLock.Lock()
	defer signalToggleToolButtonToggledLock.Unlock()

	detail, exists := signalToggleToolButtonToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleToolButtonToggledMap, connectionID)
}

//export toggletoolbutton_toggledHandler
func toggletoolbutton_toggledHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToggleToolButtonToggledMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToggleToolButton
func (recv *ToggleToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolButton is a wrapper around the C record GtkToolButton.
type ToolButton struct {
	native *C.GtkToolButton
	// parent : record
	// Private : priv
}

func ToolButtonNewFromC(u unsafe.Pointer) *ToolButton {
	c := (*C.GtkToolButton)(u)
	if c == nil {
		return nil
	}

	g := &ToolButton{native: c}

	return g
}

func (recv *ToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ToolItem upcasts to *ToolItem
func (recv *ToolButton) ToolItem() *ToolItem {
	return ToolItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ToolButton) Bin() *Bin {
	return recv.ToolItem().Bin()
}

// Container upcasts to *Container
func (recv *ToolButton) Container() *Container {
	return recv.ToolItem().Container()
}

// Widget upcasts to *Widget
func (recv *ToolButton) Widget() *Widget {
	return recv.ToolItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolButton) Object() *gobject.Object {
	return recv.ToolItem().Object()
}

// CastToWidget down casts any arbitary Object to ToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolButton.
func CastToToolButton(object *gobject.Object) *ToolButton {
	return ToolButtonNewFromC(object.ToC())
}

type signalToolButtonClickedDetail struct {
	callback  ToolButtonSignalClickedCallback
	handlerID C.gulong
}

var signalToolButtonClickedId int
var signalToolButtonClickedMap = make(map[int]signalToolButtonClickedDetail)
var signalToolButtonClickedLock sync.Mutex

// ToolButtonSignalClickedCallback is a callback function for a 'clicked' signal emitted from a ToolButton.
type ToolButtonSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the ToolButton.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *ToolButton) ConnectClicked(callback ToolButtonSignalClickedCallback) int {
	signalToolButtonClickedLock.Lock()
	defer signalToolButtonClickedLock.Unlock()

	signalToolButtonClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolButton_signal_connect_clicked(instance, C.gpointer(uintptr(signalToolButtonClickedId)))

	detail := signalToolButtonClickedDetail{callback, handlerID}
	signalToolButtonClickedMap[signalToolButtonClickedId] = detail

	return signalToolButtonClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the ToolButton.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *ToolButton) DisconnectClicked(connectionID int) {
	signalToolButtonClickedLock.Lock()
	defer signalToolButtonClickedLock.Unlock()

	detail, exists := signalToolButtonClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolButtonClickedMap, connectionID)
}

//export toolbutton_clickedHandler
func toolbutton_clickedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToolButtonClickedMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolButton
func (recv *ToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToolButton
func (recv *ToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToolButton
func (recv *ToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolButton
func (recv *ToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolItem is a wrapper around the C record GtkToolItem.
type ToolItem struct {
	native *C.GtkToolItem
	// parent : record
	// Private : priv
}

func ToolItemNewFromC(u unsafe.Pointer) *ToolItem {
	c := (*C.GtkToolItem)(u)
	if c == nil {
		return nil
	}

	g := &ToolItem{native: c}

	return g
}

func (recv *ToolItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *ToolItem) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ToolItem) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ToolItem) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolItem) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to ToolItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolItem.
func CastToToolItem(object *gobject.Object) *ToolItem {
	return ToolItemNewFromC(object.ToC())
}

type signalToolItemCreateMenuProxyDetail struct {
	callback  ToolItemSignalCreateMenuProxyCallback
	handlerID C.gulong
}

var signalToolItemCreateMenuProxyId int
var signalToolItemCreateMenuProxyMap = make(map[int]signalToolItemCreateMenuProxyDetail)
var signalToolItemCreateMenuProxyLock sync.Mutex

// ToolItemSignalCreateMenuProxyCallback is a callback function for a 'create-menu-proxy' signal emitted from a ToolItem.
type ToolItemSignalCreateMenuProxyCallback func() bool

/*
ConnectCreateMenuProxy connects the callback to the 'create-menu-proxy' signal for the ToolItem.

The returned value represents the connection, and may be passed to DisconnectCreateMenuProxy to remove it.
*/
func (recv *ToolItem) ConnectCreateMenuProxy(callback ToolItemSignalCreateMenuProxyCallback) int {
	signalToolItemCreateMenuProxyLock.Lock()
	defer signalToolItemCreateMenuProxyLock.Unlock()

	signalToolItemCreateMenuProxyId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolItem_signal_connect_create_menu_proxy(instance, C.gpointer(uintptr(signalToolItemCreateMenuProxyId)))

	detail := signalToolItemCreateMenuProxyDetail{callback, handlerID}
	signalToolItemCreateMenuProxyMap[signalToolItemCreateMenuProxyId] = detail

	return signalToolItemCreateMenuProxyId
}

/*
DisconnectCreateMenuProxy disconnects a callback from the 'create-menu-proxy' signal for the ToolItem.

The connectionID should be a value returned from a call to ConnectCreateMenuProxy.
*/
func (recv *ToolItem) DisconnectCreateMenuProxy(connectionID int) {
	signalToolItemCreateMenuProxyLock.Lock()
	defer signalToolItemCreateMenuProxyLock.Unlock()

	detail, exists := signalToolItemCreateMenuProxyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolItemCreateMenuProxyMap, connectionID)
}

//export toolitem_createMenuProxyHandler
func toolitem_createMenuProxyHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalToolItemCreateMenuProxyMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalToolItemToolbarReconfiguredDetail struct {
	callback  ToolItemSignalToolbarReconfiguredCallback
	handlerID C.gulong
}

var signalToolItemToolbarReconfiguredId int
var signalToolItemToolbarReconfiguredMap = make(map[int]signalToolItemToolbarReconfiguredDetail)
var signalToolItemToolbarReconfiguredLock sync.Mutex

// ToolItemSignalToolbarReconfiguredCallback is a callback function for a 'toolbar-reconfigured' signal emitted from a ToolItem.
type ToolItemSignalToolbarReconfiguredCallback func()

/*
ConnectToolbarReconfigured connects the callback to the 'toolbar-reconfigured' signal for the ToolItem.

The returned value represents the connection, and may be passed to DisconnectToolbarReconfigured to remove it.
*/
func (recv *ToolItem) ConnectToolbarReconfigured(callback ToolItemSignalToolbarReconfiguredCallback) int {
	signalToolItemToolbarReconfiguredLock.Lock()
	defer signalToolItemToolbarReconfiguredLock.Unlock()

	signalToolItemToolbarReconfiguredId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolItem_signal_connect_toolbar_reconfigured(instance, C.gpointer(uintptr(signalToolItemToolbarReconfiguredId)))

	detail := signalToolItemToolbarReconfiguredDetail{callback, handlerID}
	signalToolItemToolbarReconfiguredMap[signalToolItemToolbarReconfiguredId] = detail

	return signalToolItemToolbarReconfiguredId
}

/*
DisconnectToolbarReconfigured disconnects a callback from the 'toolbar-reconfigured' signal for the ToolItem.

The connectionID should be a value returned from a call to ConnectToolbarReconfigured.
*/
func (recv *ToolItem) DisconnectToolbarReconfigured(connectionID int) {
	signalToolItemToolbarReconfiguredLock.Lock()
	defer signalToolItemToolbarReconfiguredLock.Unlock()

	detail, exists := signalToolItemToolbarReconfiguredMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolItemToolbarReconfiguredMap, connectionID)
}

//export toolitem_toolbarReconfiguredHandler
func toolitem_toolbarReconfiguredHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalToolItemToolbarReconfiguredMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolItem
func (recv *ToolItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToolItem
func (recv *ToolItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolItem
func (recv *ToolItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolItemGroup is a wrapper around the C record GtkToolItemGroup.
type ToolItemGroup struct {
	native *C.GtkToolItemGroup
	// parent_instance : record
	// priv : record
}

func ToolItemGroupNewFromC(u unsafe.Pointer) *ToolItemGroup {
	c := (*C.GtkToolItemGroup)(u)
	if c == nil {
		return nil
	}

	g := &ToolItemGroup{native: c}

	return g
}

func (recv *ToolItemGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *ToolItemGroup) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ToolItemGroup) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolItemGroup) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolItemGroup) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to ToolItemGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolItemGroup.
func CastToToolItemGroup(object *gobject.Object) *ToolItemGroup {
	return ToolItemGroupNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolItemGroup
func (recv *ToolItemGroup) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolItemGroup
func (recv *ToolItemGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolShell returns the ToolShell interface implemented by ToolItemGroup
func (recv *ToolItemGroup) ToolShell() *ToolShell {
	return ToolShellNewFromC(recv.ToC())
}

// ToolPalette is a wrapper around the C record GtkToolPalette.
type ToolPalette struct {
	native *C.GtkToolPalette
	// parent_instance : record
	// priv : record
}

func ToolPaletteNewFromC(u unsafe.Pointer) *ToolPalette {
	c := (*C.GtkToolPalette)(u)
	if c == nil {
		return nil
	}

	g := &ToolPalette{native: c}

	return g
}

func (recv *ToolPalette) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *ToolPalette) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ToolPalette) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolPalette) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolPalette) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to ToolPalette.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolPalette.
func CastToToolPalette(object *gobject.Object) *ToolPalette {
	return ToolPaletteNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolPalette
func (recv *ToolPalette) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolPalette
func (recv *ToolPalette) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ToolPalette
func (recv *ToolPalette) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by ToolPalette
func (recv *ToolPalette) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// Toolbar is a wrapper around the C record GtkToolbar.
type Toolbar struct {
	native *C.GtkToolbar
	// container : record
	// priv : record
}

func ToolbarNewFromC(u unsafe.Pointer) *Toolbar {
	c := (*C.GtkToolbar)(u)
	if c == nil {
		return nil
	}

	g := &Toolbar{native: c}

	return g
}

func (recv *Toolbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *Toolbar) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Toolbar) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Toolbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Toolbar) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to Toolbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Toolbar.
func CastToToolbar(object *gobject.Object) *Toolbar {
	return ToolbarNewFromC(object.ToC())
}

type signalToolbarFocusHomeOrEndDetail struct {
	callback  ToolbarSignalFocusHomeOrEndCallback
	handlerID C.gulong
}

var signalToolbarFocusHomeOrEndId int
var signalToolbarFocusHomeOrEndMap = make(map[int]signalToolbarFocusHomeOrEndDetail)
var signalToolbarFocusHomeOrEndLock sync.Mutex

// ToolbarSignalFocusHomeOrEndCallback is a callback function for a 'focus-home-or-end' signal emitted from a Toolbar.
type ToolbarSignalFocusHomeOrEndCallback func(focusHome bool) bool

/*
ConnectFocusHomeOrEnd connects the callback to the 'focus-home-or-end' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectFocusHomeOrEnd to remove it.
*/
func (recv *Toolbar) ConnectFocusHomeOrEnd(callback ToolbarSignalFocusHomeOrEndCallback) int {
	signalToolbarFocusHomeOrEndLock.Lock()
	defer signalToolbarFocusHomeOrEndLock.Unlock()

	signalToolbarFocusHomeOrEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_focus_home_or_end(instance, C.gpointer(uintptr(signalToolbarFocusHomeOrEndId)))

	detail := signalToolbarFocusHomeOrEndDetail{callback, handlerID}
	signalToolbarFocusHomeOrEndMap[signalToolbarFocusHomeOrEndId] = detail

	return signalToolbarFocusHomeOrEndId
}

/*
DisconnectFocusHomeOrEnd disconnects a callback from the 'focus-home-or-end' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectFocusHomeOrEnd.
*/
func (recv *Toolbar) DisconnectFocusHomeOrEnd(connectionID int) {
	signalToolbarFocusHomeOrEndLock.Lock()
	defer signalToolbarFocusHomeOrEndLock.Unlock()

	detail, exists := signalToolbarFocusHomeOrEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarFocusHomeOrEndMap, connectionID)
}

//export toolbar_focusHomeOrEndHandler
func toolbar_focusHomeOrEndHandler(_ *C.GObject, c_focus_home C.gboolean, data C.gpointer) C.gboolean {
	focusHome := c_focus_home == C.TRUE

	index := int(uintptr(data))
	callback := signalToolbarFocusHomeOrEndMap[index].callback
	retGo := callback(focusHome)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'orientation-changed' for Toolbar : unsupported parameter orientation : type Orientation :

// Unsupported signal 'popup-context-menu' for Toolbar : unsupported parameter x : type gint :

// Unsupported signal 'style-changed' for Toolbar : unsupported parameter style : type ToolbarStyle :

// Creates a new toolbar.
/*

C function : gtk_toolbar_new
*/
func ToolbarNew() *Toolbar {
	retC := C.gtk_toolbar_new()
	retGo := ToolbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the icon size for the toolbar. See gtk_toolbar_set_icon_size().
/*

C function : gtk_toolbar_get_icon_size
*/
func (recv *Toolbar) GetIconSize() IconSize {
	retC := C.gtk_toolbar_get_icon_size((*C.GtkToolbar)(recv.native))
	retGo := (IconSize)(retC)

	return retGo
}

// Retrieves whether the toolbar has text, icons, or both . See
// gtk_toolbar_set_style().
/*

C function : gtk_toolbar_get_style
*/
func (recv *Toolbar) GetStyle() ToolbarStyle {
	retC := C.gtk_toolbar_get_style((*C.GtkToolbar)(recv.native))
	retGo := (ToolbarStyle)(retC)

	return retGo
}

// This function sets the size of stock icons in the toolbar. You
// can call it both before you add the icons and after they’ve been
// added. The size you set will override user preferences for the default
// icon size.
//
// This should only be used for special-purpose toolbars, normal
// application toolbars should respect the user preferences for the
// size of icons.
/*

C function : gtk_toolbar_set_icon_size
*/
func (recv *Toolbar) SetIconSize(iconSize IconSize) {
	c_icon_size := (C.GtkIconSize)(iconSize)

	C.gtk_toolbar_set_icon_size((*C.GtkToolbar)(recv.native), c_icon_size)

	return
}

// Alters the view of @toolbar to display either icons only, text only, or both.
/*

C function : gtk_toolbar_set_style
*/
func (recv *Toolbar) SetStyle(style ToolbarStyle) {
	c_style := (C.GtkToolbarStyle)(style)

	C.gtk_toolbar_set_style((*C.GtkToolbar)(recv.native), c_style)

	return
}

// Unsets toolbar icon size set with gtk_toolbar_set_icon_size(), so that
// user preferences will be used to determine the icon size.
/*

C function : gtk_toolbar_unset_icon_size
*/
func (recv *Toolbar) UnsetIconSize() {
	C.gtk_toolbar_unset_icon_size((*C.GtkToolbar)(recv.native))

	return
}

// Unsets a toolbar style set with gtk_toolbar_set_style(), so that
// user preferences will be used to determine the toolbar style.
/*

C function : gtk_toolbar_unset_style
*/
func (recv *Toolbar) UnsetStyle() {
	C.gtk_toolbar_unset_style((*C.GtkToolbar)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Toolbar
func (recv *Toolbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Toolbar
func (recv *Toolbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Toolbar
func (recv *Toolbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ToolShell returns the ToolShell interface implemented by Toolbar
func (recv *Toolbar) ToolShell() *ToolShell {
	return ToolShellNewFromC(recv.ToC())
}

// Tooltip is a wrapper around the C record GtkTooltip.
type Tooltip struct {
	native *C.GtkTooltip
}

func TooltipNewFromC(u unsafe.Pointer) *Tooltip {
	c := (*C.GtkTooltip)(u)
	if c == nil {
		return nil
	}

	g := &Tooltip{native: c}

	return g
}

func (recv *Tooltip) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *Tooltip) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to Tooltip.
// Exercise care, as this is a potentially dangerous function if the Object is not a Tooltip.
func CastToTooltip(object *gobject.Object) *Tooltip {
	return TooltipNewFromC(object.ToC())
}

// ToplevelAccessible is a wrapper around the C record GtkToplevelAccessible.
type ToplevelAccessible struct {
	native *C.GtkToplevelAccessible
	// parent : record
	// priv : record
}

func ToplevelAccessibleNewFromC(u unsafe.Pointer) *ToplevelAccessible {
	c := (*C.GtkToplevelAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ToplevelAccessible{native: c}

	return g
}

func (recv *ToplevelAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *ToplevelAccessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to ToplevelAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToplevelAccessible.
func CastToToplevelAccessible(object *gobject.Object) *ToplevelAccessible {
	return ToplevelAccessibleNewFromC(object.ToC())
}

/*

C function : gtk_toplevel_accessible_get_children
*/
func (recv *ToplevelAccessible) GetChildren() *glib.List {
	retC := C.gtk_toplevel_accessible_get_children((*C.GtkToplevelAccessible)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TreeModelFilter is a wrapper around the C record GtkTreeModelFilter.
type TreeModelFilter struct {
	native *C.GtkTreeModelFilter
	// parent : record
	// Private : priv
}

func TreeModelFilterNewFromC(u unsafe.Pointer) *TreeModelFilter {
	c := (*C.GtkTreeModelFilter)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelFilter{native: c}

	return g
}

func (recv *TreeModelFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TreeModelFilter) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TreeModelFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeModelFilter.
func CastToTreeModelFilter(object *gobject.Object) *TreeModelFilter {
	return TreeModelFilterNewFromC(object.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeModelFilter
func (recv *TreeModelFilter) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeModelFilter
func (recv *TreeModelFilter) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeModelSort is a wrapper around the C record GtkTreeModelSort.
type TreeModelSort struct {
	native *C.GtkTreeModelSort
	// parent : record
	// Private : priv
}

func TreeModelSortNewFromC(u unsafe.Pointer) *TreeModelSort {
	c := (*C.GtkTreeModelSort)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelSort{native: c}

	return g
}

func (recv *TreeModelSort) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TreeModelSort) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TreeModelSort.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeModelSort.
func CastToTreeModelSort(object *gobject.Object) *TreeModelSort {
	return TreeModelSortNewFromC(object.ToC())
}

// This function should almost never be called.  It clears the @tree_model_sort
// of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node().  This might be useful if the child model being
// sorted is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes.  As a side effect of this function, all unreffed
// iters will be invalid.
/*

C function : gtk_tree_model_sort_clear_cache
*/
func (recv *TreeModelSort) ClearCache() {
	C.gtk_tree_model_sort_clear_cache((*C.GtkTreeModelSort)(recv.native))

	return
}

// Sets @sort_iter to point to the row in @tree_model_sort that corresponds to
// the row pointed at by @child_iter.  If @sort_iter was not set, %FALSE
// is returned.  Note: a boolean is only returned since 2.14.
/*

C function : gtk_tree_model_sort_convert_child_iter_to_iter
*/
func (recv *TreeModelSort) ConvertChildIterToIter(childIter *TreeIter) (bool, *TreeIter) {
	var c_sort_iter C.GtkTreeIter

	c_child_iter := (*C.GtkTreeIter)(C.NULL)
	if childIter != nil {
		c_child_iter = (*C.GtkTreeIter)(childIter.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_child_iter_to_iter((*C.GtkTreeModelSort)(recv.native), &c_sort_iter, c_child_iter)
	retGo := retC == C.TRUE

	sortIter := TreeIterNewFromC(unsafe.Pointer(&c_sort_iter))

	return retGo, sortIter
}

// Converts @child_path to a path relative to @tree_model_sort.  That is,
// @child_path points to a path in the child model.  The returned path will
// point to the same row in the sorted model.  If @child_path isn’t a valid
// path on the child model, then %NULL is returned.
/*

C function : gtk_tree_model_sort_convert_child_path_to_path
*/
func (recv *TreeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	c_child_path := (*C.GtkTreePath)(C.NULL)
	if childPath != nil {
		c_child_path = (*C.GtkTreePath)(childPath.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_child_path_to_path((*C.GtkTreeModelSort)(recv.native), c_child_path)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Sets @child_iter to point to the row pointed to by @sorted_iter.
/*

C function : gtk_tree_model_sort_convert_iter_to_child_iter
*/
func (recv *TreeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) *TreeIter {
	var c_child_iter C.GtkTreeIter

	c_sorted_iter := (*C.GtkTreeIter)(C.NULL)
	if sortedIter != nil {
		c_sorted_iter = (*C.GtkTreeIter)(sortedIter.ToC())
	}

	C.gtk_tree_model_sort_convert_iter_to_child_iter((*C.GtkTreeModelSort)(recv.native), &c_child_iter, c_sorted_iter)

	childIter := TreeIterNewFromC(unsafe.Pointer(&c_child_iter))

	return childIter
}

// Converts @sorted_path to a path on the child model of @tree_model_sort.
// That is, @sorted_path points to a location in @tree_model_sort.  The
// returned path will point to the same location in the model not being
// sorted.  If @sorted_path does not point to a location in the child model,
// %NULL is returned.
/*

C function : gtk_tree_model_sort_convert_path_to_child_path
*/
func (recv *TreeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
	c_sorted_path := (*C.GtkTreePath)(C.NULL)
	if sortedPath != nil {
		c_sorted_path = (*C.GtkTreePath)(sortedPath.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_path_to_child_path((*C.GtkTreeModelSort)(recv.native), c_sorted_path)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the model the #GtkTreeModelSort is sorting.
/*

C function : gtk_tree_model_sort_get_model
*/
func (recv *TreeModelSort) GetModel() *TreeModel {
	retC := C.gtk_tree_model_sort_get_model((*C.GtkTreeModelSort)(recv.native))
	retGo := TreeModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This resets the default sort function to be in the “unsorted” state.  That
// is, it is in the same order as the child model. It will re-sort the model
// to be in the same order as the child model only if the #GtkTreeModelSort
// is in “unsorted” state.
/*

C function : gtk_tree_model_sort_reset_default_sort_func
*/
func (recv *TreeModelSort) ResetDefaultSortFunc() {
	C.gtk_tree_model_sort_reset_default_sort_func((*C.GtkTreeModelSort)(recv.native))

	return
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// TreeSelection is a wrapper around the C record GtkTreeSelection.
type TreeSelection struct {
	native *C.GtkTreeSelection
	// Private : parent
	// Private : priv
}

func TreeSelectionNewFromC(u unsafe.Pointer) *TreeSelection {
	c := (*C.GtkTreeSelection)(u)
	if c == nil {
		return nil
	}

	g := &TreeSelection{native: c}

	return g
}

func (recv *TreeSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TreeSelection) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TreeSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeSelection.
func CastToTreeSelection(object *gobject.Object) *TreeSelection {
	return TreeSelectionNewFromC(object.ToC())
}

type signalTreeSelectionChangedDetail struct {
	callback  TreeSelectionSignalChangedCallback
	handlerID C.gulong
}

var signalTreeSelectionChangedId int
var signalTreeSelectionChangedMap = make(map[int]signalTreeSelectionChangedDetail)
var signalTreeSelectionChangedLock sync.Mutex

// TreeSelectionSignalChangedCallback is a callback function for a 'changed' signal emitted from a TreeSelection.
type TreeSelectionSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the TreeSelection.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *TreeSelection) ConnectChanged(callback TreeSelectionSignalChangedCallback) int {
	signalTreeSelectionChangedLock.Lock()
	defer signalTreeSelectionChangedLock.Unlock()

	signalTreeSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeSelection_signal_connect_changed(instance, C.gpointer(uintptr(signalTreeSelectionChangedId)))

	detail := signalTreeSelectionChangedDetail{callback, handlerID}
	signalTreeSelectionChangedMap[signalTreeSelectionChangedId] = detail

	return signalTreeSelectionChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the TreeSelection.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *TreeSelection) DisconnectChanged(connectionID int) {
	signalTreeSelectionChangedLock.Lock()
	defer signalTreeSelectionChangedLock.Unlock()

	detail, exists := signalTreeSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeSelectionChangedMap, connectionID)
}

//export treeselection_changedHandler
func treeselection_changedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTreeSelectionChangedMap[index].callback
	callback()
}

// Gets the selection mode for @selection. See
// gtk_tree_selection_set_mode().
/*

C function : gtk_tree_selection_get_mode
*/
func (recv *TreeSelection) GetMode() SelectionMode {
	retC := C.gtk_tree_selection_get_mode((*C.GtkTreeSelection)(recv.native))
	retGo := (SelectionMode)(retC)

	return retGo
}

// Sets @iter to the currently selected node if @selection is set to
// #GTK_SELECTION_SINGLE or #GTK_SELECTION_BROWSE.  @iter may be NULL if you
// just want to test if @selection has any selected nodes.  @model is filled
// with the current model as a convenience.  This function will not work if you
// use @selection is #GTK_SELECTION_MULTIPLE.
/*

C function : gtk_tree_selection_get_selected
*/
func (recv *TreeSelection) GetSelected() (bool, *TreeModel, *TreeIter) {
	var c_model *C.GtkTreeModel

	var c_iter C.GtkTreeIter

	retC := C.gtk_tree_selection_get_selected((*C.GtkTreeSelection)(recv.native), &c_model, &c_iter)
	retGo := retC == C.TRUE

	model := TreeModelNewFromC(unsafe.Pointer(c_model))

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, model, iter
}

// Returns the tree view associated with @selection.
/*

C function : gtk_tree_selection_get_tree_view
*/
func (recv *TreeSelection) GetTreeView() *TreeView {
	retC := C.gtk_tree_selection_get_tree_view((*C.GtkTreeSelection)(recv.native))
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the user data for the selection function.
/*

C function : gtk_tree_selection_get_user_data
*/
func (recv *TreeSelection) GetUserData() uintptr {
	retC := C.gtk_tree_selection_get_user_data((*C.GtkTreeSelection)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if the row at @iter is currently selected.
/*

C function : gtk_tree_selection_iter_is_selected
*/
func (recv *TreeSelection) IterIsSelected(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_selection_iter_is_selected((*C.GtkTreeSelection)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Returns %TRUE if the row pointed to by @path is currently selected.  If @path
// does not point to a valid location, %FALSE is returned
/*

C function : gtk_tree_selection_path_is_selected
*/
func (recv *TreeSelection) PathIsSelected(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_selection_path_is_selected((*C.GtkTreeSelection)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// Selects all the nodes. @selection must be set to #GTK_SELECTION_MULTIPLE
// mode.
/*

C function : gtk_tree_selection_select_all
*/
func (recv *TreeSelection) SelectAll() {
	C.gtk_tree_selection_select_all((*C.GtkTreeSelection)(recv.native))

	return
}

// Selects the specified iterator.
/*

C function : gtk_tree_selection_select_iter
*/
func (recv *TreeSelection) SelectIter(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_selection_select_iter((*C.GtkTreeSelection)(recv.native), c_iter)

	return
}

// Select the row at @path.
/*

C function : gtk_tree_selection_select_path
*/
func (recv *TreeSelection) SelectPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_selection_select_path((*C.GtkTreeSelection)(recv.native), c_path)

	return
}

// Selects a range of nodes, determined by @start_path and @end_path inclusive.
// @selection must be set to #GTK_SELECTION_MULTIPLE mode.
/*

C function : gtk_tree_selection_select_range
*/
func (recv *TreeSelection) SelectRange(startPath *TreePath, endPath *TreePath) {
	c_start_path := (*C.GtkTreePath)(C.NULL)
	if startPath != nil {
		c_start_path = (*C.GtkTreePath)(startPath.ToC())
	}

	c_end_path := (*C.GtkTreePath)(C.NULL)
	if endPath != nil {
		c_end_path = (*C.GtkTreePath)(endPath.ToC())
	}

	C.gtk_tree_selection_select_range((*C.GtkTreeSelection)(recv.native), c_start_path, c_end_path)

	return
}

// Unsupported : gtk_tree_selection_selected_foreach : unsupported parameter func : no type generator for TreeSelectionForeachFunc (GtkTreeSelectionForeachFunc) for param func

// Sets the selection mode of the @selection.  If the previous type was
// #GTK_SELECTION_MULTIPLE, then the anchor is kept selected, if it was
// previously selected.
/*

C function : gtk_tree_selection_set_mode
*/
func (recv *TreeSelection) SetMode(type_ SelectionMode) {
	c_type := (C.GtkSelectionMode)(type_)

	C.gtk_tree_selection_set_mode((*C.GtkTreeSelection)(recv.native), c_type)

	return
}

// Unsupported : gtk_tree_selection_set_select_function : unsupported parameter func : no type generator for TreeSelectionFunc (GtkTreeSelectionFunc) for param func

// Unselects all the nodes.
/*

C function : gtk_tree_selection_unselect_all
*/
func (recv *TreeSelection) UnselectAll() {
	C.gtk_tree_selection_unselect_all((*C.GtkTreeSelection)(recv.native))

	return
}

// Unselects the specified iterator.
/*

C function : gtk_tree_selection_unselect_iter
*/
func (recv *TreeSelection) UnselectIter(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_selection_unselect_iter((*C.GtkTreeSelection)(recv.native), c_iter)

	return
}

// Unselects the row at @path.
/*

C function : gtk_tree_selection_unselect_path
*/
func (recv *TreeSelection) UnselectPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_selection_unselect_path((*C.GtkTreeSelection)(recv.native), c_path)

	return
}

// TreeStore is a wrapper around the C record GtkTreeStore.
type TreeStore struct {
	native *C.GtkTreeStore
	// parent : record
	// priv : record
}

func TreeStoreNewFromC(u unsafe.Pointer) *TreeStore {
	c := (*C.GtkTreeStore)(u)
	if c == nil {
		return nil
	}

	g := &TreeStore{native: c}

	return g
}

func (recv *TreeStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *TreeStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to TreeStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeStore.
func CastToTreeStore(object *gobject.Object) *TreeStore {
	return TreeStoreNewFromC(object.ToC())
}

// Unsupported : gtk_tree_store_new : unsupported parameter ... : varargs

// Non vararg creation function.  Used primarily by language bindings.
/*

C function : gtk_tree_store_newv
*/
func TreeStoreNewv(types []gobject.Type) *TreeStore {
	c_n_columns := (C.gint)(len(types))

	c_types := &types[0]

	retC := C.gtk_tree_store_newv(c_n_columns, (*C.GType)(unsafe.Pointer(c_types)))
	retGo := TreeStoreNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Appends a new row to @tree_store.  If @parent is non-%NULL, then it will append the
// new row after the last child of @parent, otherwise it will append a row to
// the top level.  @iter will be changed to point to this new row.  The row will
// be empty after this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
/*

C function : gtk_tree_store_append
*/
func (recv *TreeStore) Append(parent *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	C.gtk_tree_store_append((*C.GtkTreeStore)(recv.native), &c_iter, c_parent)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Removes all rows from @tree_store
/*

C function : gtk_tree_store_clear
*/
func (recv *TreeStore) Clear() {
	C.gtk_tree_store_clear((*C.GtkTreeStore)(recv.native))

	return
}

// Creates a new row at @position.  If parent is non-%NULL, then the row will be
// made a child of @parent.  Otherwise, the row will be created at the toplevel.
// If @position is -1 or is larger than the number of rows at that level, then
// the new row will be inserted to the end of the list.  @iter will be changed
// to point to this new row.  The row will be empty after this function is
// called.  To fill in values, you need to call gtk_tree_store_set() or
// gtk_tree_store_set_value().
/*

C function : gtk_tree_store_insert
*/
func (recv *TreeStore) Insert(parent *TreeIter, position int32) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_tree_store_insert((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_position)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Inserts a new row after @sibling.  If @sibling is %NULL, then the row will be
// prepended to @parent ’s children.  If @parent and @sibling are %NULL, then
// the row will be prepended to the toplevel.  If both @sibling and @parent are
// set, then @parent must be the parent of @sibling.  When @sibling is set,
// @parent is optional.
//
// @iter will be changed to point to this new row.  The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
/*

C function : gtk_tree_store_insert_after
*/
func (recv *TreeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_tree_store_insert_after((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Inserts a new row before @sibling.  If @sibling is %NULL, then the row will
// be appended to @parent ’s children.  If @parent and @sibling are %NULL, then
// the row will be appended to the toplevel.  If both @sibling and @parent are
// set, then @parent must be the parent of @sibling.  When @sibling is set,
// @parent is optional.
//
// @iter will be changed to point to this new row.  The row will be empty after
// this function is called.  To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
/*

C function : gtk_tree_store_insert_before
*/
func (recv *TreeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_tree_store_insert_before((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Returns %TRUE if @iter is an ancestor of @descendant.  That is, @iter is the
// parent (or grandparent or great-grandparent) of @descendant.
/*

C function : gtk_tree_store_is_ancestor
*/
func (recv *TreeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_descendant := (*C.GtkTreeIter)(C.NULL)
	if descendant != nil {
		c_descendant = (*C.GtkTreeIter)(descendant.ToC())
	}

	retC := C.gtk_tree_store_is_ancestor((*C.GtkTreeStore)(recv.native), c_iter, c_descendant)
	retGo := retC == C.TRUE

	return retGo
}

// Returns the depth of @iter.  This will be 0 for anything on the root level, 1
// for anything down a level, etc.
/*

C function : gtk_tree_store_iter_depth
*/
func (recv *TreeStore) IterDepth(iter *TreeIter) int32 {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_store_iter_depth((*C.GtkTreeStore)(recv.native), c_iter)
	retGo := (int32)(retC)

	return retGo
}

// Prepends a new row to @tree_store.  If @parent is non-%NULL, then it will prepend
// the new row before the first child of @parent, otherwise it will prepend a row
// to the top level.  @iter will be changed to point to this new row.  The row
// will be empty after this function is called.  To fill in values, you need to
// call gtk_tree_store_set() or gtk_tree_store_set_value().
/*

C function : gtk_tree_store_prepend
*/
func (recv *TreeStore) Prepend(parent *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	C.gtk_tree_store_prepend((*C.GtkTreeStore)(recv.native), &c_iter, c_parent)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Removes @iter from @tree_store.  After being removed, @iter is set to the
// next valid row at that level, or invalidated if it previously pointed to the
// last one.
/*

C function : gtk_tree_store_remove
*/
func (recv *TreeStore) Remove(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_store_remove((*C.GtkTreeStore)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_tree_store_set : unsupported parameter ... : varargs

// This function is meant primarily for #GObjects that inherit from
// #GtkTreeStore, and should only be used when constructing a new
// #GtkTreeStore.  It will not function after a row has been added,
// or a method on the #GtkTreeModel interface is called.
/*

C function : gtk_tree_store_set_column_types
*/
func (recv *TreeStore) SetColumnTypes(types []gobject.Type) {
	c_n_columns := (C.gint)(len(types))

	c_types := &types[0]

	C.gtk_tree_store_set_column_types((*C.GtkTreeStore)(recv.native), c_n_columns, (*C.GType)(unsafe.Pointer(c_types)))

	return
}

// Unsupported : gtk_tree_store_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Sets the data in the cell specified by @iter and @column.
// The type of @value must be convertible to the type of the
// column.
/*

C function : gtk_tree_store_set_value
*/
func (recv *TreeStore) SetValue(iter *TreeIter, column int32, value *gobject.Value) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_column := (C.gint)(column)

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_tree_store_set_value((*C.GtkTreeStore)(recv.native), c_iter, c_column, c_value)

	return
}

// Buildable returns the Buildable interface implemented by TreeStore
func (recv *TreeStore) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TreeDragDest returns the TreeDragDest interface implemented by TreeStore
func (recv *TreeStore) TreeDragDest() *TreeDragDest {
	return TreeDragDestNewFromC(recv.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeStore
func (recv *TreeStore) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeStore
func (recv *TreeStore) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by TreeStore
func (recv *TreeStore) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// TreeView is a wrapper around the C record GtkTreeView.
type TreeView struct {
	native *C.GtkTreeView
	// parent : record
	// Private : priv
}

func TreeViewNewFromC(u unsafe.Pointer) *TreeView {
	c := (*C.GtkTreeView)(u)
	if c == nil {
		return nil
	}

	g := &TreeView{native: c}

	return g
}

func (recv *TreeView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Container upcasts to *Container
func (recv *TreeView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *TreeView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TreeView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TreeView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitary Object to TreeView.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeView.
func CastToTreeView(object *gobject.Object) *TreeView {
	return TreeViewNewFromC(object.ToC())
}

type signalTreeViewColumnsChangedDetail struct {
	callback  TreeViewSignalColumnsChangedCallback
	handlerID C.gulong
}

var signalTreeViewColumnsChangedId int
var signalTreeViewColumnsChangedMap = make(map[int]signalTreeViewColumnsChangedDetail)
var signalTreeViewColumnsChangedLock sync.Mutex

// TreeViewSignalColumnsChangedCallback is a callback function for a 'columns-changed' signal emitted from a TreeView.
type TreeViewSignalColumnsChangedCallback func()

/*
ConnectColumnsChanged connects the callback to the 'columns-changed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectColumnsChanged to remove it.
*/
func (recv *TreeView) ConnectColumnsChanged(callback TreeViewSignalColumnsChangedCallback) int {
	signalTreeViewColumnsChangedLock.Lock()
	defer signalTreeViewColumnsChangedLock.Unlock()

	signalTreeViewColumnsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_columns_changed(instance, C.gpointer(uintptr(signalTreeViewColumnsChangedId)))

	detail := signalTreeViewColumnsChangedDetail{callback, handlerID}
	signalTreeViewColumnsChangedMap[signalTreeViewColumnsChangedId] = detail

	return signalTreeViewColumnsChangedId
}

/*
DisconnectColumnsChanged disconnects a callback from the 'columns-changed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectColumnsChanged.
*/
func (recv *TreeView) DisconnectColumnsChanged(connectionID int) {
	signalTreeViewColumnsChangedLock.Lock()
	defer signalTreeViewColumnsChangedLock.Unlock()

	detail, exists := signalTreeViewColumnsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewColumnsChangedMap, connectionID)
}

//export treeview_columnsChangedHandler
func treeview_columnsChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTreeViewColumnsChangedMap[index].callback
	callback()
}

type signalTreeViewCursorChangedDetail struct {
	callback  TreeViewSignalCursorChangedCallback
	handlerID C.gulong
}

var signalTreeViewCursorChangedId int
var signalTreeViewCursorChangedMap = make(map[int]signalTreeViewCursorChangedDetail)
var signalTreeViewCursorChangedLock sync.Mutex

// TreeViewSignalCursorChangedCallback is a callback function for a 'cursor-changed' signal emitted from a TreeView.
type TreeViewSignalCursorChangedCallback func()

/*
ConnectCursorChanged connects the callback to the 'cursor-changed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectCursorChanged to remove it.
*/
func (recv *TreeView) ConnectCursorChanged(callback TreeViewSignalCursorChangedCallback) int {
	signalTreeViewCursorChangedLock.Lock()
	defer signalTreeViewCursorChangedLock.Unlock()

	signalTreeViewCursorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_cursor_changed(instance, C.gpointer(uintptr(signalTreeViewCursorChangedId)))

	detail := signalTreeViewCursorChangedDetail{callback, handlerID}
	signalTreeViewCursorChangedMap[signalTreeViewCursorChangedId] = detail

	return signalTreeViewCursorChangedId
}

/*
DisconnectCursorChanged disconnects a callback from the 'cursor-changed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectCursorChanged.
*/
func (recv *TreeView) DisconnectCursorChanged(connectionID int) {
	signalTreeViewCursorChangedLock.Lock()
	defer signalTreeViewCursorChangedLock.Unlock()

	detail, exists := signalTreeViewCursorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewCursorChangedMap, connectionID)
}

//export treeview_cursorChangedHandler
func treeview_cursorChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTreeViewCursorChangedMap[index].callback
	callback()
}

type signalTreeViewExpandCollapseCursorRowDetail struct {
	callback  TreeViewSignalExpandCollapseCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewExpandCollapseCursorRowId int
var signalTreeViewExpandCollapseCursorRowMap = make(map[int]signalTreeViewExpandCollapseCursorRowDetail)
var signalTreeViewExpandCollapseCursorRowLock sync.Mutex

// TreeViewSignalExpandCollapseCursorRowCallback is a callback function for a 'expand-collapse-cursor-row' signal emitted from a TreeView.
type TreeViewSignalExpandCollapseCursorRowCallback func(object bool, p0 bool, p1 bool) bool

/*
ConnectExpandCollapseCursorRow connects the callback to the 'expand-collapse-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectExpandCollapseCursorRow to remove it.
*/
func (recv *TreeView) ConnectExpandCollapseCursorRow(callback TreeViewSignalExpandCollapseCursorRowCallback) int {
	signalTreeViewExpandCollapseCursorRowLock.Lock()
	defer signalTreeViewExpandCollapseCursorRowLock.Unlock()

	signalTreeViewExpandCollapseCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_expand_collapse_cursor_row(instance, C.gpointer(uintptr(signalTreeViewExpandCollapseCursorRowId)))

	detail := signalTreeViewExpandCollapseCursorRowDetail{callback, handlerID}
	signalTreeViewExpandCollapseCursorRowMap[signalTreeViewExpandCollapseCursorRowId] = detail

	return signalTreeViewExpandCollapseCursorRowId
}

/*
DisconnectExpandCollapseCursorRow disconnects a callback from the 'expand-collapse-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectExpandCollapseCursorRow.
*/
func (recv *TreeView) DisconnectExpandCollapseCursorRow(connectionID int) {
	signalTreeViewExpandCollapseCursorRowLock.Lock()
	defer signalTreeViewExpandCollapseCursorRowLock.Unlock()

	detail, exists := signalTreeViewExpandCollapseCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewExpandCollapseCursorRowMap, connectionID)
}

//export treeview_expandCollapseCursorRowHandler
func treeview_expandCollapseCursorRowHandler(_ *C.GObject, c_object C.gboolean, c_p0 C.gboolean, c_p1 C.gboolean, data C.gpointer) C.gboolean {
	object := c_object == C.TRUE

	p0 := c_p0 == C.TRUE

	p1 := c_p1 == C.TRUE

	index := int(uintptr(data))
	callback := signalTreeViewExpandCollapseCursorRowMap[index].callback
	retGo := callback(object, p0, p1)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'move-cursor' for TreeView : unsupported parameter step : type MovementStep :

type signalTreeViewRowActivatedDetail struct {
	callback  TreeViewSignalRowActivatedCallback
	handlerID C.gulong
}

var signalTreeViewRowActivatedId int
var signalTreeViewRowActivatedMap = make(map[int]signalTreeViewRowActivatedDetail)
var signalTreeViewRowActivatedLock sync.Mutex

// TreeViewSignalRowActivatedCallback is a callback function for a 'row-activated' signal emitted from a TreeView.
type TreeViewSignalRowActivatedCallback func(path *TreePath, column *TreeViewColumn)

/*
ConnectRowActivated connects the callback to the 'row-activated' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowActivated to remove it.
*/
func (recv *TreeView) ConnectRowActivated(callback TreeViewSignalRowActivatedCallback) int {
	signalTreeViewRowActivatedLock.Lock()
	defer signalTreeViewRowActivatedLock.Unlock()

	signalTreeViewRowActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_activated(instance, C.gpointer(uintptr(signalTreeViewRowActivatedId)))

	detail := signalTreeViewRowActivatedDetail{callback, handlerID}
	signalTreeViewRowActivatedMap[signalTreeViewRowActivatedId] = detail

	return signalTreeViewRowActivatedId
}

/*
DisconnectRowActivated disconnects a callback from the 'row-activated' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowActivated.
*/
func (recv *TreeView) DisconnectRowActivated(connectionID int) {
	signalTreeViewRowActivatedLock.Lock()
	defer signalTreeViewRowActivatedLock.Unlock()

	detail, exists := signalTreeViewRowActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowActivatedMap, connectionID)
}

//export treeview_rowActivatedHandler
func treeview_rowActivatedHandler(_ *C.GObject, c_path *C.GtkTreePath, c_column *C.GtkTreeViewColumn, data C.gpointer) {
	path := TreePathNewFromC(unsafe.Pointer(c_path))

	column := TreeViewColumnNewFromC(unsafe.Pointer(c_column))

	index := int(uintptr(data))
	callback := signalTreeViewRowActivatedMap[index].callback
	callback(path, column)
}

type signalTreeViewRowCollapsedDetail struct {
	callback  TreeViewSignalRowCollapsedCallback
	handlerID C.gulong
}

var signalTreeViewRowCollapsedId int
var signalTreeViewRowCollapsedMap = make(map[int]signalTreeViewRowCollapsedDetail)
var signalTreeViewRowCollapsedLock sync.Mutex

// TreeViewSignalRowCollapsedCallback is a callback function for a 'row-collapsed' signal emitted from a TreeView.
type TreeViewSignalRowCollapsedCallback func(iter *TreeIter, path *TreePath)

/*
ConnectRowCollapsed connects the callback to the 'row-collapsed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowCollapsed to remove it.
*/
func (recv *TreeView) ConnectRowCollapsed(callback TreeViewSignalRowCollapsedCallback) int {
	signalTreeViewRowCollapsedLock.Lock()
	defer signalTreeViewRowCollapsedLock.Unlock()

	signalTreeViewRowCollapsedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_collapsed(instance, C.gpointer(uintptr(signalTreeViewRowCollapsedId)))

	detail := signalTreeViewRowCollapsedDetail{callback, handlerID}
	signalTreeViewRowCollapsedMap[signalTreeViewRowCollapsedId] = detail

	return signalTreeViewRowCollapsedId
}

/*
DisconnectRowCollapsed disconnects a callback from the 'row-collapsed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowCollapsed.
*/
func (recv *TreeView) DisconnectRowCollapsed(connectionID int) {
	signalTreeViewRowCollapsedLock.Lock()
	defer signalTreeViewRowCollapsedLock.Unlock()

	detail, exists := signalTreeViewRowCollapsedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowCollapsedMap, connectionID)
}

//export treeview_rowCollapsedHandler
func treeview_rowCollapsedHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) {
	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewRowCollapsedMap[index].callback
	callback(iter, path)
}

type signalTreeViewRowExpandedDetail struct {
	callback  TreeViewSignalRowExpandedCallback
	handlerID C.gulong
}

var signalTreeViewRowExpandedId int
var signalTreeViewRowExpandedMap = make(map[int]signalTreeViewRowExpandedDetail)
var signalTreeViewRowExpandedLock sync.Mutex

// TreeViewSignalRowExpandedCallback is a callback function for a 'row-expanded' signal emitted from a TreeView.
type TreeViewSignalRowExpandedCallback func(iter *TreeIter, path *TreePath)

/*
ConnectRowExpanded connects the callback to the 'row-expanded' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowExpanded to remove it.
*/
func (recv *TreeView) ConnectRowExpanded(callback TreeViewSignalRowExpandedCallback) int {
	signalTreeViewRowExpandedLock.Lock()
	defer signalTreeViewRowExpandedLock.Unlock()

	signalTreeViewRowExpandedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_expanded(instance, C.gpointer(uintptr(signalTreeViewRowExpandedId)))

	detail := signalTreeViewRowExpandedDetail{callback, handlerID}
	signalTreeViewRowExpandedMap[signalTreeViewRowExpandedId] = detail

	return signalTreeViewRowExpandedId
}

/*
DisconnectRowExpanded disconnects a callback from the 'row-expanded' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowExpanded.
*/
func (recv *TreeView) DisconnectRowExpanded(connectionID int) {
	signalTreeViewRowExpandedLock.Lock()
	defer signalTreeViewRowExpandedLock.Unlock()

	detail, exists := signalTreeViewRowExpandedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowExpandedMap, connectionID)
}

//export treeview_rowExpandedHandler
func treeview_rowExpandedHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) {
	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewRowExpandedMap[index].callback
	callback(iter, path)
}

type signalTreeViewSelectAllDetail struct {
	callback  TreeViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalTreeViewSelectAllId int
var signalTreeViewSelectAllMap = make(map[int]signalTreeViewSelectAllDetail)
var signalTreeViewSelectAllLock sync.Mutex

// TreeViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a TreeView.
type TreeViewSignalSelectAllCallback func() bool

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *TreeView) ConnectSelectAll(callback TreeViewSignalSelectAllCallback) int {
	signalTreeViewSelectAllLock.Lock()
	defer signalTreeViewSelectAllLock.Unlock()

	signalTreeViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_all(instance, C.gpointer(uintptr(signalTreeViewSelectAllId)))

	detail := signalTreeViewSelectAllDetail{callback, handlerID}
	signalTreeViewSelectAllMap[signalTreeViewSelectAllId] = detail

	return signalTreeViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *TreeView) DisconnectSelectAll(connectionID int) {
	signalTreeViewSelectAllLock.Lock()
	defer signalTreeViewSelectAllLock.Unlock()

	detail, exists := signalTreeViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectAllMap, connectionID)
}

//export treeview_selectAllHandler
func treeview_selectAllHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewSelectAllMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewSelectCursorParentDetail struct {
	callback  TreeViewSignalSelectCursorParentCallback
	handlerID C.gulong
}

var signalTreeViewSelectCursorParentId int
var signalTreeViewSelectCursorParentMap = make(map[int]signalTreeViewSelectCursorParentDetail)
var signalTreeViewSelectCursorParentLock sync.Mutex

// TreeViewSignalSelectCursorParentCallback is a callback function for a 'select-cursor-parent' signal emitted from a TreeView.
type TreeViewSignalSelectCursorParentCallback func() bool

/*
ConnectSelectCursorParent connects the callback to the 'select-cursor-parent' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorParent to remove it.
*/
func (recv *TreeView) ConnectSelectCursorParent(callback TreeViewSignalSelectCursorParentCallback) int {
	signalTreeViewSelectCursorParentLock.Lock()
	defer signalTreeViewSelectCursorParentLock.Unlock()

	signalTreeViewSelectCursorParentId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_cursor_parent(instance, C.gpointer(uintptr(signalTreeViewSelectCursorParentId)))

	detail := signalTreeViewSelectCursorParentDetail{callback, handlerID}
	signalTreeViewSelectCursorParentMap[signalTreeViewSelectCursorParentId] = detail

	return signalTreeViewSelectCursorParentId
}

/*
DisconnectSelectCursorParent disconnects a callback from the 'select-cursor-parent' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectCursorParent.
*/
func (recv *TreeView) DisconnectSelectCursorParent(connectionID int) {
	signalTreeViewSelectCursorParentLock.Lock()
	defer signalTreeViewSelectCursorParentLock.Unlock()

	detail, exists := signalTreeViewSelectCursorParentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectCursorParentMap, connectionID)
}

//export treeview_selectCursorParentHandler
func treeview_selectCursorParentHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewSelectCursorParentMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewSelectCursorRowDetail struct {
	callback  TreeViewSignalSelectCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewSelectCursorRowId int
var signalTreeViewSelectCursorRowMap = make(map[int]signalTreeViewSelectCursorRowDetail)
var signalTreeViewSelectCursorRowLock sync.Mutex

// TreeViewSignalSelectCursorRowCallback is a callback function for a 'select-cursor-row' signal emitted from a TreeView.
type TreeViewSignalSelectCursorRowCallback func(object bool) bool

/*
ConnectSelectCursorRow connects the callback to the 'select-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorRow to remove it.
*/
func (recv *TreeView) ConnectSelectCursorRow(callback TreeViewSignalSelectCursorRowCallback) int {
	signalTreeViewSelectCursorRowLock.Lock()
	defer signalTreeViewSelectCursorRowLock.Unlock()

	signalTreeViewSelectCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_cursor_row(instance, C.gpointer(uintptr(signalTreeViewSelectCursorRowId)))

	detail := signalTreeViewSelectCursorRowDetail{callback, handlerID}
	signalTreeViewSelectCursorRowMap[signalTreeViewSelectCursorRowId] = detail

	return signalTreeViewSelectCursorRowId
}

/*
DisconnectSelectCursorRow disconnects a callback from the 'select-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectCursorRow.
*/
func (recv *TreeView) DisconnectSelectCursorRow(connectionID int) {
	signalTreeViewSelectCursorRowLock.Lock()
	defer signalTreeViewSelectCursorRowLock.Unlock()

	detail, exists := signalTreeViewSelectCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectCursorRowMap, connectionID)
}

//export treeview_selectCursorRowHandler
func treeview_selectCursorRowHandler(_ *C.GObject, c_object C.gboolean, data C.gpointer) C.gboolean {
	object := c_object == C.TRUE

	index := int(uintptr(data))
	callback := signalTreeViewSelectCursorRowMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewStartInteractiveSearchDetail struct {
	callback  TreeViewSignalStartInteractiveSearchCallback
	handlerID C.gulong
}

var signalTreeViewStartInteractiveSearchId int
var signalTreeViewStartInteractiveSearchMap = make(map[int]signalTreeViewStartInteractiveSearchDetail)
var signalTreeViewStartInteractiveSearchLock sync.Mutex

// TreeViewSignalStartInteractiveSearchCallback is a callback function for a 'start-interactive-search' signal emitted from a TreeView.
type TreeViewSignalStartInteractiveSearchCallback func() bool

/*
ConnectStartInteractiveSearch connects the callback to the 'start-interactive-search' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectStartInteractiveSearch to remove it.
*/
func (recv *TreeView) ConnectStartInteractiveSearch(callback TreeViewSignalStartInteractiveSearchCallback) int {
	signalTreeViewStartInteractiveSearchLock.Lock()
	defer signalTreeViewStartInteractiveSearchLock.Unlock()

	signalTreeViewStartInteractiveSearchId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_start_interactive_search(instance, C.gpointer(uintptr(signalTreeViewStartInteractiveSearchId)))

	detail := signalTreeViewStartInteractiveSearchDetail{callback, handlerID}
	signalTreeViewStartInteractiveSearchMap[signalTreeViewStartInteractiveSearchId] = detail

	return signalTreeViewStartInteractiveSearchId
}

/*
DisconnectStartInteractiveSearch disconnects a callback from the 'start-interactive-search' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectStartInteractiveSearch.
*/
func (recv *TreeView) DisconnectStartInteractiveSearch(connectionID int) {
	signalTreeViewStartInteractiveSearchLock.Lock()
	defer signalTreeViewStartInteractiveSearchLock.Unlock()

	detail, exists := signalTreeViewStartInteractiveSearchMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewStartInteractiveSearchMap, connectionID)
}

//export treeview_startInteractiveSearchHandler
func treeview_startInteractiveSearchHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewStartInteractiveSearchMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewTestCollapseRowDetail struct {
	callback  TreeViewSignalTestCollapseRowCallback
	handlerID C.gulong
}

var signalTreeViewTestCollapseRowId int
var signalTreeViewTestCollapseRowMap = make(map[int]signalTreeViewTestCollapseRowDetail)
var signalTreeViewTestCollapseRowLock sync.Mutex

// TreeViewSignalTestCollapseRowCallback is a callback function for a 'test-collapse-row' signal emitted from a TreeView.
type TreeViewSignalTestCollapseRowCallback func(iter *TreeIter, path *TreePath) bool

/*
ConnectTestCollapseRow connects the callback to the 'test-collapse-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectTestCollapseRow to remove it.
*/
func (recv *TreeView) ConnectTestCollapseRow(callback TreeViewSignalTestCollapseRowCallback) int {
	signalTreeViewTestCollapseRowLock.Lock()
	defer signalTreeViewTestCollapseRowLock.Unlock()

	signalTreeViewTestCollapseRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_test_collapse_row(instance, C.gpointer(uintptr(signalTreeViewTestCollapseRowId)))

	detail := signalTreeViewTestCollapseRowDetail{callback, handlerID}
	signalTreeViewTestCollapseRowMap[signalTreeViewTestCollapseRowId] = detail

	return signalTreeViewTestCollapseRowId
}

/*
DisconnectTestCollapseRow disconnects a callback from the 'test-collapse-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectTestCollapseRow.
*/
func (recv *TreeView) DisconnectTestCollapseRow(connectionID int) {
	signalTreeViewTestCollapseRowLock.Lock()
	defer signalTreeViewTestCollapseRowLock.Unlock()

	detail, exists := signalTreeViewTestCollapseRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewTestCollapseRowMap, connectionID)
}

//export treeview_testCollapseRowHandler
func treeview_testCollapseRowHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) C.gboolean {
	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewTestCollapseRowMap[index].callback
	retGo := callback(iter, path)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewTestExpandRowDetail struct {
	callback  TreeViewSignalTestExpandRowCallback
	handlerID C.gulong
}

var signalTreeViewTestExpandRowId int
var signalTreeViewTestExpandRowMap = make(map[int]signalTreeViewTestExpandRowDetail)
var signalTreeViewTestExpandRowLock sync.Mutex

// TreeViewSignalTestExpandRowCallback is a callback function for a 'test-expand-row' signal emitted from a TreeView.
type TreeViewSignalTestExpandRowCallback func(iter *TreeIter, path *TreePath) bool

/*
ConnectTestExpandRow connects the callback to the 'test-expand-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectTestExpandRow to remove it.
*/
func (recv *TreeView) ConnectTestExpandRow(callback TreeViewSignalTestExpandRowCallback) int {
	signalTreeViewTestExpandRowLock.Lock()
	defer signalTreeViewTestExpandRowLock.Unlock()

	signalTreeViewTestExpandRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_test_expand_row(instance, C.gpointer(uintptr(signalTreeViewTestExpandRowId)))

	detail := signalTreeViewTestExpandRowDetail{callback, handlerID}
	signalTreeViewTestExpandRowMap[signalTreeViewTestExpandRowId] = detail

	return signalTreeViewTestExpandRowId
}

/*
DisconnectTestExpandRow disconnects a callback from the 'test-expand-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectTestExpandRow.
*/
func (recv *TreeView) DisconnectTestExpandRow(connectionID int) {
	signalTreeViewTestExpandRowLock.Lock()
	defer signalTreeViewTestExpandRowLock.Unlock()

	detail, exists := signalTreeViewTestExpandRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewTestExpandRowMap, connectionID)
}

//export treeview_testExpandRowHandler
func treeview_testExpandRowHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) C.gboolean {
	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewTestExpandRowMap[index].callback
	retGo := callback(iter, path)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewToggleCursorRowDetail struct {
	callback  TreeViewSignalToggleCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewToggleCursorRowId int
var signalTreeViewToggleCursorRowMap = make(map[int]signalTreeViewToggleCursorRowDetail)
var signalTreeViewToggleCursorRowLock sync.Mutex

// TreeViewSignalToggleCursorRowCallback is a callback function for a 'toggle-cursor-row' signal emitted from a TreeView.
type TreeViewSignalToggleCursorRowCallback func() bool

/*
ConnectToggleCursorRow connects the callback to the 'toggle-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorRow to remove it.
*/
func (recv *TreeView) ConnectToggleCursorRow(callback TreeViewSignalToggleCursorRowCallback) int {
	signalTreeViewToggleCursorRowLock.Lock()
	defer signalTreeViewToggleCursorRowLock.Unlock()

	signalTreeViewToggleCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_toggle_cursor_row(instance, C.gpointer(uintptr(signalTreeViewToggleCursorRowId)))

	detail := signalTreeViewToggleCursorRowDetail{callback, handlerID}
	signalTreeViewToggleCursorRowMap[signalTreeViewToggleCursorRowId] = detail

	return signalTreeViewToggleCursorRowId
}

/*
DisconnectToggleCursorRow disconnects a callback from the 'toggle-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectToggleCursorRow.
*/
func (recv *TreeView) DisconnectToggleCursorRow(connectionID int) {
	signalTreeViewToggleCursorRowLock.Lock()
	defer signalTreeViewToggleCursorRowLock.Unlock()

	detail, exists := signalTreeViewToggleCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewToggleCursorRowMap, connectionID)
}

//export treeview_toggleCursorRowHandler
func treeview_toggleCursorRowHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewToggleCursorRowMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewUnselectAllDetail struct {
	callback  TreeViewSignalUnselectAllCallback
	handlerID C.gulong
}

var signalTreeViewUnselectAllId int
var signalTreeViewUnselectAllMap = make(map[int]signalTreeViewUnselectAllDetail)
var signalTreeViewUnselectAllLock sync.Mutex

// TreeViewSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a TreeView.
type TreeViewSignalUnselectAllCallback func() bool

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *TreeView) ConnectUnselectAll(callback TreeViewSignalUnselectAllCallback) int {
	signalTreeViewUnselectAllLock.Lock()
	defer signalTreeViewUnselectAllLock.Unlock()

	signalTreeViewUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalTreeViewUnselectAllId)))

	detail := signalTreeViewUnselectAllDetail{callback, handlerID}
	signalTreeViewUnselectAllMap[signalTreeViewUnselectAllId] = detail

	return signalTreeViewUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *TreeView) DisconnectUnselectAll(connectionID int) {
	signalTreeViewUnselectAllLock.Lock()
	defer signalTreeViewUnselectAllLock.Unlock()

	detail, exists := signalTreeViewUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewUnselectAllMap, connectionID)
}

//export treeview_unselectAllHandler
func treeview_unselectAllHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalTreeViewUnselectAllMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Creates a new #GtkTreeView widget.
/*

C function : gtk_tree_view_new
*/
func TreeViewNew() *TreeView {
	retC := C.gtk_tree_view_new()
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #GtkTreeView widget with the model initialized to @model.
/*

C function : gtk_tree_view_new_with_model
*/
func TreeViewNewWithModel(model *TreeModel) *TreeView {
	c_model := (*C.GtkTreeModel)(model.ToC())

	retC := C.gtk_tree_view_new_with_model(c_model)
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Appends @column to the list of columns. If @tree_view has “fixed_height”
// mode enabled, then @column must have its “sizing” property set to be
// GTK_TREE_VIEW_COLUMN_FIXED.
/*

C function : gtk_tree_view_append_column
*/
func (recv *TreeView) AppendColumn(column *TreeViewColumn) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	retC := C.gtk_tree_view_append_column((*C.GtkTreeView)(recv.native), c_column)
	retGo := (int32)(retC)

	return retGo
}

// Recursively collapses all visible, expanded nodes in @tree_view.
/*

C function : gtk_tree_view_collapse_all
*/
func (recv *TreeView) CollapseAll() {
	C.gtk_tree_view_collapse_all((*C.GtkTreeView)(recv.native))

	return
}

// Collapses a row (hides its child rows, if they exist).
/*

C function : gtk_tree_view_collapse_row
*/
func (recv *TreeView) CollapseRow(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_collapse_row((*C.GtkTreeView)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// Resizes all columns to their optimal width. Only works after the
// treeview has been realized.
/*

C function : gtk_tree_view_columns_autosize
*/
func (recv *TreeView) ColumnsAutosize() {
	C.gtk_tree_view_columns_autosize((*C.GtkTreeView)(recv.native))

	return
}

// Creates a #cairo_surface_t representation of the row at @path.
// This image is used for a drag icon.
/*

C function : gtk_tree_view_create_row_drag_icon
*/
func (recv *TreeView) CreateRowDragIcon(path *TreePath) *cairo.Surface {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_create_row_drag_icon((*C.GtkTreeView)(recv.native), c_path)
	retGo := cairo.SurfaceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_enable_model_drag_dest : unsupported parameter targets :

// Unsupported : gtk_tree_view_enable_model_drag_source : unsupported parameter targets :

// Recursively expands all nodes in the @tree_view.
/*

C function : gtk_tree_view_expand_all
*/
func (recv *TreeView) ExpandAll() {
	C.gtk_tree_view_expand_all((*C.GtkTreeView)(recv.native))

	return
}

// Opens the row so its children are visible.
/*

C function : gtk_tree_view_expand_row
*/
func (recv *TreeView) ExpandRow(path *TreePath, openAll bool) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_open_all :=
		boolToGboolean(openAll)

	retC := C.gtk_tree_view_expand_row((*C.GtkTreeView)(recv.native), c_path, c_open_all)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_tree_view_get_background_area : unsupported parameter rect : Blacklisted record : GdkRectangle

// Returns the window that @tree_view renders to.
// This is used primarily to compare to `event->window`
// to confirm that the event on @tree_view is on the right window.
/*

C function : gtk_tree_view_get_bin_window
*/
func (recv *TreeView) GetBinWindow() *gdk.Window {
	retC := C.gtk_tree_view_get_bin_window((*C.GtkTreeView)(recv.native))
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_tree_view_get_cell_area : unsupported parameter rect : Blacklisted record : GdkRectangle

// Gets the #GtkTreeViewColumn at the given position in the #tree_view.
/*

C function : gtk_tree_view_get_column
*/
func (recv *TreeView) GetColumn(n int32) *TreeViewColumn {
	c_n := (C.gint)(n)

	retC := C.gtk_tree_view_get_column((*C.GtkTreeView)(recv.native), c_n)
	var retGo (*TreeViewColumn)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreeViewColumnNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns a #GList of all the #GtkTreeViewColumn s currently in @tree_view.
// The returned list must be freed with g_list_free ().
/*

C function : gtk_tree_view_get_columns
*/
func (recv *TreeView) GetColumns() *glib.List {
	retC := C.gtk_tree_view_get_columns((*C.GtkTreeView)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Fills in @path and @focus_column with the current path and focus column.  If
// the cursor isn’t currently set, then *@path will be %NULL.  If no column
// currently has focus, then *@focus_column will be %NULL.
//
// The returned #GtkTreePath must be freed with gtk_tree_path_free() when
// you are done with it.
/*

C function : gtk_tree_view_get_cursor
*/
func (recv *TreeView) GetCursor() (*TreePath, *TreeViewColumn) {
	var c_path *C.GtkTreePath

	var c_focus_column *C.GtkTreeViewColumn

	C.gtk_tree_view_get_cursor((*C.GtkTreeView)(recv.native), &c_path, &c_focus_column)

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	focusColumn := TreeViewColumnNewFromC(unsafe.Pointer(c_focus_column))

	return path, focusColumn
}

// Unsupported : gtk_tree_view_get_dest_row_at_pos : unsupported parameter pos : GtkTreeViewDropPosition* with indirection level of 1

// Unsupported : gtk_tree_view_get_drag_dest_row : unsupported parameter pos : GtkTreeViewDropPosition* with indirection level of 1

// Returns whether or not the tree allows to start interactive searching
// by typing in text.
/*

C function : gtk_tree_view_get_enable_search
*/
func (recv *TreeView) GetEnableSearch() bool {
	retC := C.gtk_tree_view_get_enable_search((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the column that is the current expander column.
// This column has the expander arrow drawn next to it.
/*

C function : gtk_tree_view_get_expander_column
*/
func (recv *TreeView) GetExpanderColumn() *TreeViewColumn {
	retC := C.gtk_tree_view_get_expander_column((*C.GtkTreeView)(recv.native))
	retGo := TreeViewColumnNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the #GtkAdjustment currently being used for the horizontal aspect.
/*

C function : gtk_tree_view_get_hadjustment
*/
func (recv *TreeView) GetHadjustment() *Adjustment {
	retC := C.gtk_tree_view_get_hadjustment((*C.GtkTreeView)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if the headers on the @tree_view are visible.
/*

C function : gtk_tree_view_get_headers_visible
*/
func (recv *TreeView) GetHeadersVisible() bool {
	retC := C.gtk_tree_view_get_headers_visible((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the model the #GtkTreeView is based on.  Returns %NULL if the
// model is unset.
/*

C function : gtk_tree_view_get_model
*/
func (recv *TreeView) GetModel() *TreeModel {
	retC := C.gtk_tree_view_get_model((*C.GtkTreeView)(recv.native))
	var retGo (*TreeModel)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreeModelNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Finds the path at the point (@x, @y), relative to bin_window coordinates
// (please see gtk_tree_view_get_bin_window()).
// That is, @x and @y are relative to an events coordinates. @x and @y must
// come from an event on the @tree_view only where `event->window ==
// gtk_tree_view_get_bin_window ()`. It is primarily for
// things like popup menus. If @path is non-%NULL, then it will be filled
// with the #GtkTreePath at that point.  This path should be freed with
// gtk_tree_path_free().  If @column is non-%NULL, then it will be filled
// with the column at that point.  @cell_x and @cell_y return the coordinates
// relative to the cell background (i.e. the @background_area passed to
// gtk_cell_renderer_render()).  This function is only meaningful if
// @tree_view is realized.  Therefore this function will always return %FALSE
// if @tree_view is not realized or does not have a model.
//
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
/*

C function : gtk_tree_view_get_path_at_pos
*/
func (recv *TreeView) GetPathAtPos(x int32, y int32) (bool, *TreePath, *TreeViewColumn, int32, int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	var c_path *C.GtkTreePath

	var c_column *C.GtkTreeViewColumn

	var c_cell_x C.gint

	var c_cell_y C.gint

	retC := C.gtk_tree_view_get_path_at_pos((*C.GtkTreeView)(recv.native), c_x, c_y, &c_path, &c_column, &c_cell_x, &c_cell_y)
	retGo := retC == C.TRUE

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	column := TreeViewColumnNewFromC(unsafe.Pointer(c_column))

	cellX := (int32)(c_cell_x)

	cellY := (int32)(c_cell_y)

	return retGo, path, column, cellX, cellY
}

// Retrieves whether the user can reorder the tree via drag-and-drop. See
// gtk_tree_view_set_reorderable().
/*

C function : gtk_tree_view_get_reorderable
*/
func (recv *TreeView) GetReorderable() bool {
	retC := C.gtk_tree_view_get_reorderable((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the setting set by gtk_tree_view_set_rules_hint().
/*

C function : gtk_tree_view_get_rules_hint
*/
func (recv *TreeView) GetRulesHint() bool {
	retC := C.gtk_tree_view_get_rules_hint((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the column searched on by the interactive search code.
/*

C function : gtk_tree_view_get_search_column
*/
func (recv *TreeView) GetSearchColumn() int32 {
	retC := C.gtk_tree_view_get_search_column((*C.GtkTreeView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Unsupported : gtk_tree_view_get_search_equal_func : no return generator

// Gets the #GtkTreeSelection associated with @tree_view.
/*

C function : gtk_tree_view_get_selection
*/
func (recv *TreeView) GetSelection() *TreeSelection {
	retC := C.gtk_tree_view_get_selection((*C.GtkTreeView)(recv.native))
	retGo := TreeSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the #GtkAdjustment currently being used for the vertical aspect.
/*

C function : gtk_tree_view_get_vadjustment
*/
func (recv *TreeView) GetVadjustment() *Adjustment {
	retC := C.gtk_tree_view_get_vadjustment((*C.GtkTreeView)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_get_visible_rect : unsupported parameter visible_rect : Blacklisted record : GdkRectangle

// This inserts the @column into the @tree_view at @position.  If @position is
// -1, then the column is inserted at the end. If @tree_view has
// “fixed_height” mode enabled, then @column must have its “sizing” property
// set to be GTK_TREE_VIEW_COLUMN_FIXED.
/*

C function : gtk_tree_view_insert_column
*/
func (recv *TreeView) InsertColumn(column *TreeViewColumn, position int32) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_tree_view_insert_column((*C.GtkTreeView)(recv.native), c_column, c_position)
	retGo := (int32)(retC)

	return retGo
}

// Unsupported : gtk_tree_view_insert_column_with_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_tree_view_insert_column_with_data_func : unsupported parameter func : no type generator for TreeCellDataFunc (GtkTreeCellDataFunc) for param func

// Unsupported : gtk_tree_view_map_expanded_rows : unsupported parameter func : no type generator for TreeViewMappingFunc (GtkTreeViewMappingFunc) for param func

// Moves @column to be after to @base_column.  If @base_column is %NULL, then
// @column is placed in the first position.
/*

C function : gtk_tree_view_move_column_after
*/
func (recv *TreeView) MoveColumnAfter(column *TreeViewColumn, baseColumn *TreeViewColumn) {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_base_column := (*C.GtkTreeViewColumn)(C.NULL)
	if baseColumn != nil {
		c_base_column = (*C.GtkTreeViewColumn)(baseColumn.ToC())
	}

	C.gtk_tree_view_move_column_after((*C.GtkTreeView)(recv.native), c_column, c_base_column)

	return
}

// Removes @column from @tree_view.
/*

C function : gtk_tree_view_remove_column
*/
func (recv *TreeView) RemoveColumn(column *TreeViewColumn) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	retC := C.gtk_tree_view_remove_column((*C.GtkTreeView)(recv.native), c_column)
	retGo := (int32)(retC)

	return retGo
}

// Activates the cell determined by @path and @column.
/*

C function : gtk_tree_view_row_activated
*/
func (recv *TreeView) RowActivated(path *TreePath, column *TreeViewColumn) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	C.gtk_tree_view_row_activated((*C.GtkTreeView)(recv.native), c_path, c_column)

	return
}

// Returns %TRUE if the node pointed to by @path is expanded in @tree_view.
/*

C function : gtk_tree_view_row_expanded
*/
func (recv *TreeView) RowExpanded(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_row_expanded((*C.GtkTreeView)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// Moves the alignments of @tree_view to the position specified by @column and
// @path.  If @column is %NULL, then no horizontal scrolling occurs.  Likewise,
// if @path is %NULL no vertical scrolling occurs.  At a minimum, one of @column
// or @path need to be non-%NULL.  @row_align determines where the row is
// placed, and @col_align determines where @column is placed.  Both are expected
// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
// right/bottom alignment, 0.5 means center.
//
// If @use_align is %FALSE, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen.
// This means that the cell will be scrolled to the edge closest to its current
// position.  If the cell is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and @path is a valid row on the
// model.  If the model changes before the @tree_view is realized, the centered
// path will be modified to reflect this change.
/*

C function : gtk_tree_view_scroll_to_cell
*/
func (recv *TreeView) ScrollToCell(path *TreePath, column *TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_use_align :=
		boolToGboolean(useAlign)

	c_row_align := (C.gfloat)(rowAlign)

	c_col_align := (C.gfloat)(colAlign)

	C.gtk_tree_view_scroll_to_cell((*C.GtkTreeView)(recv.native), c_path, c_column, c_use_align, c_row_align, c_col_align)

	return
}

// Scrolls the tree view such that the top-left corner of the visible
// area is @tree_x, @tree_y, where @tree_x and @tree_y are specified
// in tree coordinates.  The @tree_view must be realized before
// this function is called.  If it isn't, you probably want to be
// using gtk_tree_view_scroll_to_cell().
//
// If either @tree_x or @tree_y are -1, then that direction isn’t scrolled.
/*

C function : gtk_tree_view_scroll_to_point
*/
func (recv *TreeView) ScrollToPoint(treeX int32, treeY int32) {
	c_tree_x := (C.gint)(treeX)

	c_tree_y := (C.gint)(treeY)

	C.gtk_tree_view_scroll_to_point((*C.GtkTreeView)(recv.native), c_tree_x, c_tree_y)

	return
}

// Unsupported : gtk_tree_view_set_column_drag_function : unsupported parameter func : no type generator for TreeViewColumnDropFunc (GtkTreeViewColumnDropFunc) for param func

// Sets the current keyboard focus to be at @path, and selects it.  This is
// useful when you want to focus the user’s attention on a particular row.  If
// @focus_column is not %NULL, then focus is given to the column specified by
// it. Additionally, if @focus_column is specified, and @start_editing is
// %TRUE, then editing should be started in the specified cell.
// This function is often followed by @gtk_widget_grab_focus (@tree_view)
// in order to give keyboard focus to the widget.  Please note that editing
// can only happen when the widget is realized.
//
// If @path is invalid for @model, the current cursor (if any) will be unset
// and the function will return without failing.
/*

C function : gtk_tree_view_set_cursor
*/
func (recv *TreeView) SetCursor(path *TreePath, focusColumn *TreeViewColumn, startEditing bool) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_focus_column := (*C.GtkTreeViewColumn)(C.NULL)
	if focusColumn != nil {
		c_focus_column = (*C.GtkTreeViewColumn)(focusColumn.ToC())
	}

	c_start_editing :=
		boolToGboolean(startEditing)

	C.gtk_tree_view_set_cursor((*C.GtkTreeView)(recv.native), c_path, c_focus_column, c_start_editing)

	return
}

// Unsupported : gtk_tree_view_set_destroy_count_func : unsupported parameter func : no type generator for TreeDestroyCountFunc (GtkTreeDestroyCountFunc) for param func

// Sets the row that is highlighted for feedback.
// If @path is %NULL, an existing highlight is removed.
/*

C function : gtk_tree_view_set_drag_dest_row
*/
func (recv *TreeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_pos := (C.GtkTreeViewDropPosition)(pos)

	C.gtk_tree_view_set_drag_dest_row((*C.GtkTreeView)(recv.native), c_path, c_pos)

	return
}

// If @enable_search is set, then the user can type in text to search through
// the tree interactively (this is sometimes called "typeahead find").
//
// Note that even if this is %FALSE, the user can still initiate a search
// using the “start-interactive-search” key binding.
/*

C function : gtk_tree_view_set_enable_search
*/
func (recv *TreeView) SetEnableSearch(enableSearch bool) {
	c_enable_search :=
		boolToGboolean(enableSearch)

	C.gtk_tree_view_set_enable_search((*C.GtkTreeView)(recv.native), c_enable_search)

	return
}

// Sets the column to draw the expander arrow at. It must be in @tree_view.
// If @column is %NULL, then the expander arrow is always at the first
// visible column.
//
// If you do not want expander arrow to appear in your tree, set the
// expander column to a hidden column.
/*

C function : gtk_tree_view_set_expander_column
*/
func (recv *TreeView) SetExpanderColumn(column *TreeViewColumn) {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	C.gtk_tree_view_set_expander_column((*C.GtkTreeView)(recv.native), c_column)

	return
}

// Sets the #GtkAdjustment for the current horizontal aspect.
/*

C function : gtk_tree_view_set_hadjustment
*/
func (recv *TreeView) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_tree_view_set_hadjustment((*C.GtkTreeView)(recv.native), c_adjustment)

	return
}

// Allow the column title buttons to be clicked.
/*

C function : gtk_tree_view_set_headers_clickable
*/
func (recv *TreeView) SetHeadersClickable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_set_headers_clickable((*C.GtkTreeView)(recv.native), c_setting)

	return
}

// Sets the visibility state of the headers.
/*

C function : gtk_tree_view_set_headers_visible
*/
func (recv *TreeView) SetHeadersVisible(headersVisible bool) {
	c_headers_visible :=
		boolToGboolean(headersVisible)

	C.gtk_tree_view_set_headers_visible((*C.GtkTreeView)(recv.native), c_headers_visible)

	return
}

// Sets the model for a #GtkTreeView.  If the @tree_view already has a model
// set, it will remove it before setting the new model.  If @model is %NULL,
// then it will unset the old model.
/*

C function : gtk_tree_view_set_model
*/
func (recv *TreeView) SetModel(model *TreeModel) {
	c_model := (*C.GtkTreeModel)(model.ToC())

	C.gtk_tree_view_set_model((*C.GtkTreeView)(recv.native), c_model)

	return
}

// This function is a convenience function to allow you to reorder
// models that support the #GtkTreeDragSourceIface and the
// #GtkTreeDragDestIface.  Both #GtkTreeStore and #GtkListStore support
// these.  If @reorderable is %TRUE, then the user can reorder the
// model by dragging and dropping rows. The developer can listen to
// these changes by connecting to the model’s #GtkTreeModel::row-inserted
// and #GtkTreeModel::row-deleted signals. The reordering is implemented
// by setting up the tree view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any
// other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed.  If more control is needed, you should probably
// handle drag and drop manually.
/*

C function : gtk_tree_view_set_reorderable
*/
func (recv *TreeView) SetReorderable(reorderable bool) {
	c_reorderable :=
		boolToGboolean(reorderable)

	C.gtk_tree_view_set_reorderable((*C.GtkTreeView)(recv.native), c_reorderable)

	return
}

// Sets a hint for the theme to draw even/odd rows in the @tree_view
// with different colors, also known as "zebra striping".
//
// This function tells the GTK+ theme that the user interface for your
// application requires users to read across tree rows and associate
// cells with one another.
//
// Do not use it just because you prefer the appearance of the ruled
// tree; that’s a question for the theme. Some themes will draw tree
// rows in alternating colors even when rules are turned off, and
// users who prefer that appearance all the time can choose those
// themes. You should call this function only as a semantic hint to
// the theme engine that your tree makes alternating colors useful
// from a functional standpoint (since it has lots of columns,
// generally).
/*

C function : gtk_tree_view_set_rules_hint
*/
func (recv *TreeView) SetRulesHint(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_set_rules_hint((*C.GtkTreeView)(recv.native), c_setting)

	return
}

// Sets @column as the column where the interactive search code should
// search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search”
// key binding to bring up search popup. The enable-search property controls
// whether simply typing text will also start an interactive search.
//
// Note that @column refers to a column of the current model. The search
// column is reset to -1 when the model is changed.
/*

C function : gtk_tree_view_set_search_column
*/
func (recv *TreeView) SetSearchColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_tree_view_set_search_column((*C.GtkTreeView)(recv.native), c_column)

	return
}

// Unsupported : gtk_tree_view_set_search_equal_func : unsupported parameter search_equal_func : no type generator for TreeViewSearchEqualFunc (GtkTreeViewSearchEqualFunc) for param search_equal_func

// Sets the #GtkAdjustment for the current vertical aspect.
/*

C function : gtk_tree_view_set_vadjustment
*/
func (recv *TreeView) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_tree_view_set_vadjustment((*C.GtkTreeView)(recv.native), c_adjustment)

	return
}

// Undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// #GtkTreeView:reorderable to %FALSE.
/*

C function : gtk_tree_view_unset_rows_drag_dest
*/
func (recv *TreeView) UnsetRowsDragDest() {
	C.gtk_tree_view_unset_rows_drag_dest((*C.GtkTreeView)(recv.native))

	return
}

// Undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// #GtkTreeView:reorderable to %FALSE.
/*

C function : gtk_tree_view_unset_rows_drag_source
*/
func (recv *TreeView) UnsetRowsDragSource() {
	C.gtk_tree_view_unset_rows_drag_source((*C.GtkTreeView)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by TreeView
func (recv *TreeView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TreeView
func (recv *TreeView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by TreeView
func (recv *TreeView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// TreeViewAccessible is a wrapper around the C record GtkTreeViewAccessible.
type TreeViewAccessible struct {
	native *C.GtkTreeViewAccessible
	// parent : record
	// priv : record
}

func TreeViewAccessibleNewFromC(u unsafe.Pointer) *TreeViewAccessible {
	c := (*C.GtkTreeViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewAccessible{native: c}

	return g
}

func (recv *TreeViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *TreeViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *TreeViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TreeViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TreeViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to TreeViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeViewAccessible.
func CastToTreeViewAccessible(object *gobject.Object) *TreeViewAccessible {
	return TreeViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Table returns the Table interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Table() *atk.Table {
	return atk.TableNewFromC(recv.ToC())
}

// CellAccessibleParent returns the CellAccessibleParent interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) CellAccessibleParent() *CellAccessibleParent {
	return CellAccessibleParentNewFromC(recv.ToC())
}

// TreeViewColumn is a wrapper around the C record GtkTreeViewColumn.
type TreeViewColumn struct {
	native *C.GtkTreeViewColumn
	// parent_instance : record
	// priv : record
}

func TreeViewColumnNewFromC(u unsafe.Pointer) *TreeViewColumn {
	c := (*C.GtkTreeViewColumn)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewColumn{native: c}

	return g
}

func (recv *TreeViewColumn) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TreeViewColumn) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *TreeViewColumn) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to TreeViewColumn.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeViewColumn.
func CastToTreeViewColumn(object *gobject.Object) *TreeViewColumn {
	return TreeViewColumnNewFromC(object.ToC())
}

type signalTreeViewColumnClickedDetail struct {
	callback  TreeViewColumnSignalClickedCallback
	handlerID C.gulong
}

var signalTreeViewColumnClickedId int
var signalTreeViewColumnClickedMap = make(map[int]signalTreeViewColumnClickedDetail)
var signalTreeViewColumnClickedLock sync.Mutex

// TreeViewColumnSignalClickedCallback is a callback function for a 'clicked' signal emitted from a TreeViewColumn.
type TreeViewColumnSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the TreeViewColumn.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *TreeViewColumn) ConnectClicked(callback TreeViewColumnSignalClickedCallback) int {
	signalTreeViewColumnClickedLock.Lock()
	defer signalTreeViewColumnClickedLock.Unlock()

	signalTreeViewColumnClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeViewColumn_signal_connect_clicked(instance, C.gpointer(uintptr(signalTreeViewColumnClickedId)))

	detail := signalTreeViewColumnClickedDetail{callback, handlerID}
	signalTreeViewColumnClickedMap[signalTreeViewColumnClickedId] = detail

	return signalTreeViewColumnClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the TreeViewColumn.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *TreeViewColumn) DisconnectClicked(connectionID int) {
	signalTreeViewColumnClickedLock.Lock()
	defer signalTreeViewColumnClickedLock.Unlock()

	detail, exists := signalTreeViewColumnClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewColumnClickedMap, connectionID)
}

//export treeviewcolumn_clickedHandler
func treeviewcolumn_clickedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalTreeViewColumnClickedMap[index].callback
	callback()
}

// Creates a new #GtkTreeViewColumn.
/*

C function : gtk_tree_view_column_new
*/
func TreeViewColumnNew() *TreeViewColumn {
	retC := C.gtk_tree_view_column_new()
	retGo := TreeViewColumnNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_column_new_with_attributes : unsupported parameter ... : varargs

// Adds an attribute mapping to the list in @tree_column.  The @column is the
// column of the model to get a value from, and the @attribute is the
// parameter on @cell_renderer to be set from the value. So for example
// if column 2 of the model contains strings, you could have the
// “text” attribute of a #GtkCellRendererText get its values from
// column 2.
/*

C function : gtk_tree_view_column_add_attribute
*/
func (recv *TreeViewColumn) AddAttribute(cellRenderer *CellRenderer, attribute string, column int32) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_column := (C.gint)(column)

	C.gtk_tree_view_column_add_attribute((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer, c_attribute, c_column)

	return
}

// Obtains the horizontal position and size of a cell in a column. If the
// cell is not found in the column, @start_pos and @width are not changed and
// %FALSE is returned.
/*

C function : gtk_tree_view_column_cell_get_position
*/
func (recv *TreeViewColumn) CellGetPosition(cellRenderer *CellRenderer) (bool, int32, int32) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	var c_x_offset C.gint

	var c_width C.gint

	retC := C.gtk_tree_view_column_cell_get_position((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer, &c_x_offset, &c_width)
	retGo := retC == C.TRUE

	xOffset := (int32)(c_x_offset)

	width := (int32)(c_width)

	return retGo, xOffset, width
}

// Unsupported : gtk_tree_view_column_cell_get_size : unsupported parameter cell_area : Blacklisted record : GdkRectangle

// Returns %TRUE if any of the cells packed into the @tree_column are visible.
// For this to be meaningful, you must first initialize the cells with
// gtk_tree_view_column_cell_set_cell_data()
/*

C function : gtk_tree_view_column_cell_is_visible
*/
func (recv *TreeViewColumn) CellIsVisible() bool {
	retC := C.gtk_tree_view_column_cell_is_visible((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Sets the cell renderer based on the @tree_model and @iter.  That is, for
// every attribute mapping in @tree_column, it will get a value from the set
// column on the @iter, and use that value to set the attribute on the cell
// renderer.  This is used primarily by the #GtkTreeView.
/*

C function : gtk_tree_view_column_cell_set_cell_data
*/
func (recv *TreeViewColumn) CellSetCellData(treeModel *TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	c_tree_model := (*C.GtkTreeModel)(treeModel.ToC())

	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_is_expander :=
		boolToGboolean(isExpander)

	c_is_expanded :=
		boolToGboolean(isExpanded)

	C.gtk_tree_view_column_cell_set_cell_data((*C.GtkTreeViewColumn)(recv.native), c_tree_model, c_iter, c_is_expander, c_is_expanded)

	return
}

// Unsets all the mappings on all renderers on the @tree_column.
/*

C function : gtk_tree_view_column_clear
*/
func (recv *TreeViewColumn) Clear() {
	C.gtk_tree_view_column_clear((*C.GtkTreeViewColumn)(recv.native))

	return
}

// Clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
/*

C function : gtk_tree_view_column_clear_attributes
*/
func (recv *TreeViewColumn) ClearAttributes(cellRenderer *CellRenderer) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	C.gtk_tree_view_column_clear_attributes((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer)

	return
}

// Emits the “clicked” signal on the column.  This function will only work if
// @tree_column is clickable.
/*

C function : gtk_tree_view_column_clicked
*/
func (recv *TreeViewColumn) Clicked() {
	C.gtk_tree_view_column_clicked((*C.GtkTreeViewColumn)(recv.native))

	return
}

// Returns the current x alignment of @tree_column.  This value can range
// between 0.0 and 1.0.
/*

C function : gtk_tree_view_column_get_alignment
*/
func (recv *TreeViewColumn) GetAlignment() float32 {
	retC := C.gtk_tree_view_column_get_alignment((*C.GtkTreeViewColumn)(recv.native))
	retGo := (float32)(retC)

	return retGo
}

// Returns %TRUE if the user can click on the header for the column.
/*

C function : gtk_tree_view_column_get_clickable
*/
func (recv *TreeViewColumn) GetClickable() bool {
	retC := C.gtk_tree_view_column_get_clickable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the fixed width of the column.  This may not be the actual displayed
// width of the column; for that, use gtk_tree_view_column_get_width().
/*

C function : gtk_tree_view_column_get_fixed_width
*/
func (recv *TreeViewColumn) GetFixedWidth() int32 {
	retC := C.gtk_tree_view_column_get_fixed_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the maximum width in pixels of the @tree_column, or -1 if no maximum
// width is set.
/*

C function : gtk_tree_view_column_get_max_width
*/
func (recv *TreeViewColumn) GetMaxWidth() int32 {
	retC := C.gtk_tree_view_column_get_max_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the minimum width in pixels of the @tree_column, or -1 if no minimum
// width is set.
/*

C function : gtk_tree_view_column_get_min_width
*/
func (recv *TreeViewColumn) GetMinWidth() int32 {
	retC := C.gtk_tree_view_column_get_min_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns %TRUE if the @tree_column can be reordered by the user.
/*

C function : gtk_tree_view_column_get_reorderable
*/
func (recv *TreeViewColumn) GetReorderable() bool {
	retC := C.gtk_tree_view_column_get_reorderable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns %TRUE if the @tree_column can be resized by the end user.
/*

C function : gtk_tree_view_column_get_resizable
*/
func (recv *TreeViewColumn) GetResizable() bool {
	retC := C.gtk_tree_view_column_get_resizable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the current type of @tree_column.
/*

C function : gtk_tree_view_column_get_sizing
*/
func (recv *TreeViewColumn) GetSizing() TreeViewColumnSizing {
	retC := C.gtk_tree_view_column_get_sizing((*C.GtkTreeViewColumn)(recv.native))
	retGo := (TreeViewColumnSizing)(retC)

	return retGo
}

// Gets the logical @sort_column_id that the model sorts on when this
// column is selected for sorting.
// See gtk_tree_view_column_set_sort_column_id().
/*

C function : gtk_tree_view_column_get_sort_column_id
*/
func (recv *TreeViewColumn) GetSortColumnId() int32 {
	retC := C.gtk_tree_view_column_get_sort_column_id((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the value set by gtk_tree_view_column_set_sort_indicator().
/*

C function : gtk_tree_view_column_get_sort_indicator
*/
func (recv *TreeViewColumn) GetSortIndicator() bool {
	retC := C.gtk_tree_view_column_get_sort_indicator((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the value set by gtk_tree_view_column_set_sort_order().
/*

C function : gtk_tree_view_column_get_sort_order
*/
func (recv *TreeViewColumn) GetSortOrder() SortType {
	retC := C.gtk_tree_view_column_get_sort_order((*C.GtkTreeViewColumn)(recv.native))
	retGo := (SortType)(retC)

	return retGo
}

// Returns the spacing of @tree_column.
/*

C function : gtk_tree_view_column_get_spacing
*/
func (recv *TreeViewColumn) GetSpacing() int32 {
	retC := C.gtk_tree_view_column_get_spacing((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the title of the widget.
/*

C function : gtk_tree_view_column_get_title
*/
func (recv *TreeViewColumn) GetTitle() string {
	retC := C.gtk_tree_view_column_get_title((*C.GtkTreeViewColumn)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Returns %TRUE if @tree_column is visible.
/*

C function : gtk_tree_view_column_get_visible
*/
func (recv *TreeViewColumn) GetVisible() bool {
	retC := C.gtk_tree_view_column_get_visible((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the #GtkWidget in the button on the column header.
// If a custom widget has not been set then %NULL is returned.
/*

C function : gtk_tree_view_column_get_widget
*/
func (recv *TreeViewColumn) GetWidget() *Widget {
	retC := C.gtk_tree_view_column_get_widget((*C.GtkTreeViewColumn)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the current size of @tree_column in pixels.
/*

C function : gtk_tree_view_column_get_width
*/
func (recv *TreeViewColumn) GetWidth() int32 {
	retC := C.gtk_tree_view_column_get_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Adds the @cell to end of the column. If @expand is %FALSE, then the @cell
// is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which @expand is %TRUE.
/*

C function : gtk_tree_view_column_pack_end
*/
func (recv *TreeViewColumn) PackEnd(cell *CellRenderer, expand bool) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	C.gtk_tree_view_column_pack_end((*C.GtkTreeViewColumn)(recv.native), c_cell, c_expand)

	return
}

// Packs the @cell into the beginning of the column. If @expand is %FALSE, then
// the @cell is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which @expand is %TRUE.
/*

C function : gtk_tree_view_column_pack_start
*/
func (recv *TreeViewColumn) PackStart(cell *CellRenderer, expand bool) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	C.gtk_tree_view_column_pack_start((*C.GtkTreeViewColumn)(recv.native), c_cell, c_expand)

	return
}

// Sets the alignment of the title or custom widget inside the column header.
// The alignment determines its location inside the button -- 0.0 for left, 0.5
// for center, 1.0 for right.
/*

C function : gtk_tree_view_column_set_alignment
*/
func (recv *TreeViewColumn) SetAlignment(xalign float32) {
	c_xalign := (C.gfloat)(xalign)

	C.gtk_tree_view_column_set_alignment((*C.GtkTreeViewColumn)(recv.native), c_xalign)

	return
}

// Unsupported : gtk_tree_view_column_set_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_tree_view_column_set_cell_data_func : unsupported parameter func : no type generator for TreeCellDataFunc (GtkTreeCellDataFunc) for param func

// Sets the header to be active if @clickable is %TRUE.  When the header is
// active, then it can take keyboard focus, and can be clicked.
/*

C function : gtk_tree_view_column_set_clickable
*/
func (recv *TreeViewColumn) SetClickable(clickable bool) {
	c_clickable :=
		boolToGboolean(clickable)

	C.gtk_tree_view_column_set_clickable((*C.GtkTreeViewColumn)(recv.native), c_clickable)

	return
}

// If @fixed_width is not -1, sets the fixed width of @tree_column; otherwise
// unsets it.  The effective value of @fixed_width is clamped between the
// minimum and maximum width of the column; however, the value stored in the
// “fixed-width” property is not clamped.  If the column sizing is
// #GTK_TREE_VIEW_COLUMN_GROW_ONLY or #GTK_TREE_VIEW_COLUMN_AUTOSIZE, setting
// a fixed width overrides the automatically calculated width.  Note that
// @fixed_width is only a hint to GTK+; the width actually allocated to the
// column may be greater or less than requested.
//
// Along with “expand”, the “fixed-width” property changes when the column is
// resized by the user.
/*

C function : gtk_tree_view_column_set_fixed_width
*/
func (recv *TreeViewColumn) SetFixedWidth(fixedWidth int32) {
	c_fixed_width := (C.gint)(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width((*C.GtkTreeViewColumn)(recv.native), c_fixed_width)

	return
}

// Sets the maximum width of the @tree_column.  If @max_width is -1, then the
// maximum width is unset.  Note, the column can actually be wider than max
// width if it’s the last column in a view.  In this case, the column expands to
// fill any extra space.
/*

C function : gtk_tree_view_column_set_max_width
*/
func (recv *TreeViewColumn) SetMaxWidth(maxWidth int32) {
	c_max_width := (C.gint)(maxWidth)

	C.gtk_tree_view_column_set_max_width((*C.GtkTreeViewColumn)(recv.native), c_max_width)

	return
}

// Sets the minimum width of the @tree_column.  If @min_width is -1, then the
// minimum width is unset.
/*

C function : gtk_tree_view_column_set_min_width
*/
func (recv *TreeViewColumn) SetMinWidth(minWidth int32) {
	c_min_width := (C.gint)(minWidth)

	C.gtk_tree_view_column_set_min_width((*C.GtkTreeViewColumn)(recv.native), c_min_width)

	return
}

// If @reorderable is %TRUE, then the column can be reordered by the end user
// dragging the header.
/*

C function : gtk_tree_view_column_set_reorderable
*/
func (recv *TreeViewColumn) SetReorderable(reorderable bool) {
	c_reorderable :=
		boolToGboolean(reorderable)

	C.gtk_tree_view_column_set_reorderable((*C.GtkTreeViewColumn)(recv.native), c_reorderable)

	return
}

// If @resizable is %TRUE, then the user can explicitly resize the column by
// grabbing the outer edge of the column button.  If resizable is %TRUE and
// sizing mode of the column is #GTK_TREE_VIEW_COLUMN_AUTOSIZE, then the sizing
// mode is changed to #GTK_TREE_VIEW_COLUMN_GROW_ONLY.
/*

C function : gtk_tree_view_column_set_resizable
*/
func (recv *TreeViewColumn) SetResizable(resizable bool) {
	c_resizable :=
		boolToGboolean(resizable)

	C.gtk_tree_view_column_set_resizable((*C.GtkTreeViewColumn)(recv.native), c_resizable)

	return
}

// Sets the growth behavior of @tree_column to @type.
/*

C function : gtk_tree_view_column_set_sizing
*/
func (recv *TreeViewColumn) SetSizing(type_ TreeViewColumnSizing) {
	c_type := (C.GtkTreeViewColumnSizing)(type_)

	C.gtk_tree_view_column_set_sizing((*C.GtkTreeViewColumn)(recv.native), c_type)

	return
}

// Sets the logical @sort_column_id that this column sorts on when this column
// is selected for sorting.  Doing so makes the column header clickable.
/*

C function : gtk_tree_view_column_set_sort_column_id
*/
func (recv *TreeViewColumn) SetSortColumnId(sortColumnId int32) {
	c_sort_column_id := (C.gint)(sortColumnId)

	C.gtk_tree_view_column_set_sort_column_id((*C.GtkTreeViewColumn)(recv.native), c_sort_column_id)

	return
}

// Call this function with a @setting of %TRUE to display an arrow in
// the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of
// the arrow.
/*

C function : gtk_tree_view_column_set_sort_indicator
*/
func (recv *TreeViewColumn) SetSortIndicator(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_column_set_sort_indicator((*C.GtkTreeViewColumn)(recv.native), c_setting)

	return
}

// Changes the appearance of the sort indicator.
//
// This does not actually sort the model.  Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support.  This function is primarily for custom sorting behavior, and should
// be used in conjunction with gtk_tree_sortable_set_sort_column_id() to do
// that. For custom models, the mechanism will vary.
//
// The sort indicator changes direction to indicate normal sort or reverse sort.
// Note that you must have the sort indicator enabled to see anything when
// calling this function; see gtk_tree_view_column_set_sort_indicator().
/*

C function : gtk_tree_view_column_set_sort_order
*/
func (recv *TreeViewColumn) SetSortOrder(order SortType) {
	c_order := (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order((*C.GtkTreeViewColumn)(recv.native), c_order)

	return
}

// Sets the spacing field of @tree_column, which is the number of pixels to
// place between cell renderers packed into it.
/*

C function : gtk_tree_view_column_set_spacing
*/
func (recv *TreeViewColumn) SetSpacing(spacing int32) {
	c_spacing := (C.gint)(spacing)

	C.gtk_tree_view_column_set_spacing((*C.GtkTreeViewColumn)(recv.native), c_spacing)

	return
}

// Sets the title of the @tree_column.  If a custom widget has been set, then
// this value is ignored.
/*

C function : gtk_tree_view_column_set_title
*/
func (recv *TreeViewColumn) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_tree_view_column_set_title((*C.GtkTreeViewColumn)(recv.native), c_title)

	return
}

// Sets the visibility of @tree_column.
/*

C function : gtk_tree_view_column_set_visible
*/
func (recv *TreeViewColumn) SetVisible(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_tree_view_column_set_visible((*C.GtkTreeViewColumn)(recv.native), c_visible)

	return
}

// Sets the widget in the header to be @widget.  If widget is %NULL, then the
// header button is set with a #GtkLabel set to the title of @tree_column.
/*

C function : gtk_tree_view_column_set_widget
*/
func (recv *TreeViewColumn) SetWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_tree_view_column_set_widget((*C.GtkTreeViewColumn)(recv.native), c_widget)

	return
}

// Buildable returns the Buildable interface implemented by TreeViewColumn
func (recv *TreeViewColumn) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by TreeViewColumn
func (recv *TreeViewColumn) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// UIManager is a wrapper around the C record GtkUIManager.
type UIManager struct {
	native *C.GtkUIManager
	// parent : record
	// Private : private_data
}

func UIManagerNewFromC(u unsafe.Pointer) *UIManager {
	c := (*C.GtkUIManager)(u)
	if c == nil {
		return nil
	}

	g := &UIManager{native: c}

	return g
}

func (recv *UIManager) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *UIManager) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to UIManager.
// Exercise care, as this is a potentially dangerous function if the Object is not a UIManager.
func CastToUIManager(object *gobject.Object) *UIManager {
	return UIManagerNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by UIManager
func (recv *UIManager) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// VBox is a wrapper around the C record GtkVBox.
type VBox struct {
	native *C.GtkVBox
	// box : record
}

func VBoxNewFromC(u unsafe.Pointer) *VBox {
	c := (*C.GtkVBox)(u)
	if c == nil {
		return nil
	}

	g := &VBox{native: c}

	return g
}

func (recv *VBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Box upcasts to *Box
func (recv *VBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *VBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *VBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitary Object to VBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a VBox.
func CastToVBox(object *gobject.Object) *VBox {
	return VBoxNewFromC(object.ToC())
}

// Creates a new #GtkVBox.
/*

C function : gtk_vbox_new
*/
func VBoxNew(homogeneous bool, spacing int32) *VBox {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	c_spacing := (C.gint)(spacing)

	retC := C.gtk_vbox_new(c_homogeneous, c_spacing)
	retGo := VBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VBox
func (recv *VBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VBox
func (recv *VBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VBox
func (recv *VBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VButtonBox is a wrapper around the C record GtkVButtonBox.
type VButtonBox struct {
	native *C.GtkVButtonBox
	// button_box : record
}

func VButtonBoxNewFromC(u unsafe.Pointer) *VButtonBox {
	c := (*C.GtkVButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &VButtonBox{native: c}

	return g
}

func (recv *VButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ButtonBox upcasts to *ButtonBox
func (recv *VButtonBox) ButtonBox() *ButtonBox {
	return ButtonBoxNewFromC(unsafe.Pointer(recv.native))
}

// Box upcasts to *Box
func (recv *VButtonBox) Box() *Box {
	return recv.ButtonBox().Box()
}

// Container upcasts to *Container
func (recv *VButtonBox) Container() *Container {
	return recv.ButtonBox().Container()
}

// Widget upcasts to *Widget
func (recv *VButtonBox) Widget() *Widget {
	return recv.ButtonBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ButtonBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VButtonBox) Object() *gobject.Object {
	return recv.ButtonBox().Object()
}

// CastToWidget down casts any arbitary Object to VButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a VButtonBox.
func CastToVButtonBox(object *gobject.Object) *VButtonBox {
	return VButtonBoxNewFromC(object.ToC())
}

// Creates a new vertical button box.
/*

C function : gtk_vbutton_box_new
*/
func VButtonBoxNew() *VButtonBox {
	retC := C.gtk_vbutton_box_new()
	retGo := VButtonBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VButtonBox
func (recv *VButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VButtonBox
func (recv *VButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VButtonBox
func (recv *VButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VPaned is a wrapper around the C record GtkVPaned.
type VPaned struct {
	native *C.GtkVPaned
	// paned : record
}

func VPanedNewFromC(u unsafe.Pointer) *VPaned {
	c := (*C.GtkVPaned)(u)
	if c == nil {
		return nil
	}

	g := &VPaned{native: c}

	return g
}

func (recv *VPaned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Paned upcasts to *Paned
func (recv *VPaned) Paned() *Paned {
	return PanedNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *VPaned) Container() *Container {
	return recv.Paned().Container()
}

// Widget upcasts to *Widget
func (recv *VPaned) Widget() *Widget {
	return recv.Paned().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VPaned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Paned().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VPaned) Object() *gobject.Object {
	return recv.Paned().Object()
}

// CastToWidget down casts any arbitary Object to VPaned.
// Exercise care, as this is a potentially dangerous function if the Object is not a VPaned.
func CastToVPaned(object *gobject.Object) *VPaned {
	return VPanedNewFromC(object.ToC())
}

// Create a new #GtkVPaned
/*

C function : gtk_vpaned_new
*/
func VPanedNew() *VPaned {
	retC := C.gtk_vpaned_new()
	retGo := VPanedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VPaned
func (recv *VPaned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VPaned
func (recv *VPaned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VPaned
func (recv *VPaned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VScale is a wrapper around the C record GtkVScale.
type VScale struct {
	native *C.GtkVScale
	// scale : record
}

func VScaleNewFromC(u unsafe.Pointer) *VScale {
	c := (*C.GtkVScale)(u)
	if c == nil {
		return nil
	}

	g := &VScale{native: c}

	return g
}

func (recv *VScale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Scale upcasts to *Scale
func (recv *VScale) Scale() *Scale {
	return ScaleNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *VScale) Range() *Range {
	return recv.Scale().Range()
}

// Widget upcasts to *Widget
func (recv *VScale) Widget() *Widget {
	return recv.Scale().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VScale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scale().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VScale) Object() *gobject.Object {
	return recv.Scale().Object()
}

// CastToWidget down casts any arbitary Object to VScale.
// Exercise care, as this is a potentially dangerous function if the Object is not a VScale.
func CastToVScale(object *gobject.Object) *VScale {
	return VScaleNewFromC(object.ToC())
}

// Creates a new #GtkVScale.
/*

C function : gtk_vscale_new
*/
func VScaleNew(adjustment *Adjustment) *VScale {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_vscale_new(c_adjustment)
	retGo := VScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new vertical scale widget that lets the user input a
// number between @min and @max (including @min and @max) with the
// increment @step.  @step must be nonzero; it’s the distance the
// slider moves when using the arrow keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if @step
// is a power of ten. If the resulting precision is not suitable for your
// needs, use gtk_scale_set_digits() to correct it.
/*

C function : gtk_vscale_new_with_range
*/
func VScaleNewWithRange(min float64, max float64, step float64) *VScale {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_vscale_new_with_range(c_min, c_max, c_step)
	retGo := VScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VScale
func (recv *VScale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VScale
func (recv *VScale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VScale
func (recv *VScale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VScrollbar is a wrapper around the C record GtkVScrollbar.
type VScrollbar struct {
	native *C.GtkVScrollbar
	// scrollbar : record
}

func VScrollbarNewFromC(u unsafe.Pointer) *VScrollbar {
	c := (*C.GtkVScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &VScrollbar{native: c}

	return g
}

func (recv *VScrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Scrollbar upcasts to *Scrollbar
func (recv *VScrollbar) Scrollbar() *Scrollbar {
	return ScrollbarNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *VScrollbar) Range() *Range {
	return recv.Scrollbar().Range()
}

// Widget upcasts to *Widget
func (recv *VScrollbar) Widget() *Widget {
	return recv.Scrollbar().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VScrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scrollbar().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VScrollbar) Object() *gobject.Object {
	return recv.Scrollbar().Object()
}

// CastToWidget down casts any arbitary Object to VScrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a VScrollbar.
func CastToVScrollbar(object *gobject.Object) *VScrollbar {
	return VScrollbarNewFromC(object.ToC())
}

// Creates a new vertical scrollbar.
/*

C function : gtk_vscrollbar_new
*/
func VScrollbarNew(adjustment *Adjustment) *VScrollbar {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_vscrollbar_new(c_adjustment)
	retGo := VScrollbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VScrollbar
func (recv *VScrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VScrollbar
func (recv *VScrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VScrollbar
func (recv *VScrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VSeparator is a wrapper around the C record GtkVSeparator.
type VSeparator struct {
	native *C.GtkVSeparator
	// separator : record
}

func VSeparatorNewFromC(u unsafe.Pointer) *VSeparator {
	c := (*C.GtkVSeparator)(u)
	if c == nil {
		return nil
	}

	g := &VSeparator{native: c}

	return g
}

func (recv *VSeparator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Separator upcasts to *Separator
func (recv *VSeparator) Separator() *Separator {
	return SeparatorNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *VSeparator) Widget() *Widget {
	return recv.Separator().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VSeparator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Separator().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VSeparator) Object() *gobject.Object {
	return recv.Separator().Object()
}

// CastToWidget down casts any arbitary Object to VSeparator.
// Exercise care, as this is a potentially dangerous function if the Object is not a VSeparator.
func CastToVSeparator(object *gobject.Object) *VSeparator {
	return VSeparatorNewFromC(object.ToC())
}

// Creates a new #GtkVSeparator.
/*

C function : gtk_vseparator_new
*/
func VSeparatorNew() *VSeparator {
	retC := C.gtk_vseparator_new()
	retGo := VSeparatorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VSeparator
func (recv *VSeparator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VSeparator
func (recv *VSeparator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VSeparator
func (recv *VSeparator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Viewport is a wrapper around the C record GtkViewport.
type Viewport struct {
	native *C.GtkViewport
	// bin : record
	// Private : priv
}

func ViewportNewFromC(u unsafe.Pointer) *Viewport {
	c := (*C.GtkViewport)(u)
	if c == nil {
		return nil
	}

	g := &Viewport{native: c}

	return g
}

func (recv *Viewport) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Viewport) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Viewport) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Viewport) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Viewport) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Viewport) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Viewport.
// Exercise care, as this is a potentially dangerous function if the Object is not a Viewport.
func CastToViewport(object *gobject.Object) *Viewport {
	return ViewportNewFromC(object.ToC())
}

// Creates a new #GtkViewport with the given adjustments, or with default
// adjustments if none are given.
/*

C function : gtk_viewport_new
*/
func ViewportNew(hadjustment *Adjustment, vadjustment *Adjustment) *Viewport {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_viewport_new(c_hadjustment, c_vadjustment)
	retGo := ViewportNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the horizontal adjustment of the viewport.
/*

C function : gtk_viewport_get_hadjustment
*/
func (recv *Viewport) GetHadjustment() *Adjustment {
	retC := C.gtk_viewport_get_hadjustment((*C.GtkViewport)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the shadow type of the #GtkViewport. See
// gtk_viewport_set_shadow_type().
/*

C function : gtk_viewport_get_shadow_type
*/
func (recv *Viewport) GetShadowType() ShadowType {
	retC := C.gtk_viewport_get_shadow_type((*C.GtkViewport)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// Returns the vertical adjustment of the viewport.
/*

C function : gtk_viewport_get_vadjustment
*/
func (recv *Viewport) GetVadjustment() *Adjustment {
	retC := C.gtk_viewport_get_vadjustment((*C.GtkViewport)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Sets the horizontal adjustment of the viewport.
/*

C function : gtk_viewport_set_hadjustment
*/
func (recv *Viewport) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_viewport_set_hadjustment((*C.GtkViewport)(recv.native), c_adjustment)

	return
}

// Sets the shadow type of the viewport.
/*

C function : gtk_viewport_set_shadow_type
*/
func (recv *Viewport) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_viewport_set_shadow_type((*C.GtkViewport)(recv.native), c_type)

	return
}

// Sets the vertical adjustment of the viewport.
/*

C function : gtk_viewport_set_vadjustment
*/
func (recv *Viewport) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_viewport_set_vadjustment((*C.GtkViewport)(recv.native), c_adjustment)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Viewport
func (recv *Viewport) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Viewport
func (recv *Viewport) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by Viewport
func (recv *Viewport) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// VolumeButton is a wrapper around the C record GtkVolumeButton.
type VolumeButton struct {
	native *C.GtkVolumeButton
	// parent : record
}

func VolumeButtonNewFromC(u unsafe.Pointer) *VolumeButton {
	c := (*C.GtkVolumeButton)(u)
	if c == nil {
		return nil
	}

	g := &VolumeButton{native: c}

	return g
}

func (recv *VolumeButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ScaleButton upcasts to *ScaleButton
func (recv *VolumeButton) ScaleButton() *ScaleButton {
	return ScaleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *VolumeButton) Button() *Button {
	return recv.ScaleButton().Button()
}

// Bin upcasts to *Bin
func (recv *VolumeButton) Bin() *Bin {
	return recv.ScaleButton().Bin()
}

// Container upcasts to *Container
func (recv *VolumeButton) Container() *Container {
	return recv.ScaleButton().Container()
}

// Widget upcasts to *Widget
func (recv *VolumeButton) Widget() *Widget {
	return recv.ScaleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VolumeButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ScaleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VolumeButton) Object() *gobject.Object {
	return recv.ScaleButton().Object()
}

// CastToWidget down casts any arbitary Object to VolumeButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a VolumeButton.
func CastToVolumeButton(object *gobject.Object) *VolumeButton {
	return VolumeButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by VolumeButton
func (recv *VolumeButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by VolumeButton
func (recv *VolumeButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by VolumeButton
func (recv *VolumeButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VolumeButton
func (recv *VolumeButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VolumeButton
func (recv *VolumeButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Widget is a wrapper around the C record GtkWidget.
type Widget struct {
	native *C.GtkWidget
	// parent_instance : record
	// Private : priv
}

func WidgetNewFromC(u unsafe.Pointer) *Widget {
	c := (*C.GtkWidget)(u)
	if c == nil {
		return nil
	}

	g := &Widget{native: c}

	return g
}

func (recv *Widget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Widget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Widget) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitary Object to Widget.
// Exercise care, as this is a potentially dangerous function if the Object is not a Widget.
func CastToWidget(object *gobject.Object) *Widget {
	return WidgetNewFromC(object.ToC())
}

type signalWidgetAccelClosuresChangedDetail struct {
	callback  WidgetSignalAccelClosuresChangedCallback
	handlerID C.gulong
}

var signalWidgetAccelClosuresChangedId int
var signalWidgetAccelClosuresChangedMap = make(map[int]signalWidgetAccelClosuresChangedDetail)
var signalWidgetAccelClosuresChangedLock sync.Mutex

// WidgetSignalAccelClosuresChangedCallback is a callback function for a 'accel-closures-changed' signal emitted from a Widget.
type WidgetSignalAccelClosuresChangedCallback func()

/*
ConnectAccelClosuresChanged connects the callback to the 'accel-closures-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectAccelClosuresChanged to remove it.
*/
func (recv *Widget) ConnectAccelClosuresChanged(callback WidgetSignalAccelClosuresChangedCallback) int {
	signalWidgetAccelClosuresChangedLock.Lock()
	defer signalWidgetAccelClosuresChangedLock.Unlock()

	signalWidgetAccelClosuresChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_accel_closures_changed(instance, C.gpointer(uintptr(signalWidgetAccelClosuresChangedId)))

	detail := signalWidgetAccelClosuresChangedDetail{callback, handlerID}
	signalWidgetAccelClosuresChangedMap[signalWidgetAccelClosuresChangedId] = detail

	return signalWidgetAccelClosuresChangedId
}

/*
DisconnectAccelClosuresChanged disconnects a callback from the 'accel-closures-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectAccelClosuresChanged.
*/
func (recv *Widget) DisconnectAccelClosuresChanged(connectionID int) {
	signalWidgetAccelClosuresChangedLock.Lock()
	defer signalWidgetAccelClosuresChangedLock.Unlock()

	detail, exists := signalWidgetAccelClosuresChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetAccelClosuresChangedMap, connectionID)
}

//export widget_accelClosuresChangedHandler
func widget_accelClosuresChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetAccelClosuresChangedMap[index].callback
	callback()
}

type signalWidgetButtonPressEventDetail struct {
	callback  WidgetSignalButtonPressEventCallback
	handlerID C.gulong
}

var signalWidgetButtonPressEventId int
var signalWidgetButtonPressEventMap = make(map[int]signalWidgetButtonPressEventDetail)
var signalWidgetButtonPressEventLock sync.Mutex

// WidgetSignalButtonPressEventCallback is a callback function for a 'button-press-event' signal emitted from a Widget.
type WidgetSignalButtonPressEventCallback func(event *gdk.EventButton) bool

/*
ConnectButtonPressEvent connects the callback to the 'button-press-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectButtonPressEvent to remove it.
*/
func (recv *Widget) ConnectButtonPressEvent(callback WidgetSignalButtonPressEventCallback) int {
	signalWidgetButtonPressEventLock.Lock()
	defer signalWidgetButtonPressEventLock.Unlock()

	signalWidgetButtonPressEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_button_press_event(instance, C.gpointer(uintptr(signalWidgetButtonPressEventId)))

	detail := signalWidgetButtonPressEventDetail{callback, handlerID}
	signalWidgetButtonPressEventMap[signalWidgetButtonPressEventId] = detail

	return signalWidgetButtonPressEventId
}

/*
DisconnectButtonPressEvent disconnects a callback from the 'button-press-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectButtonPressEvent.
*/
func (recv *Widget) DisconnectButtonPressEvent(connectionID int) {
	signalWidgetButtonPressEventLock.Lock()
	defer signalWidgetButtonPressEventLock.Unlock()

	detail, exists := signalWidgetButtonPressEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetButtonPressEventMap, connectionID)
}

//export widget_buttonPressEventHandler
func widget_buttonPressEventHandler(_ *C.GObject, c_event *C.GdkEventButton, data C.gpointer) C.gboolean {
	event := gdk.EventButtonNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetButtonPressEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetButtonReleaseEventDetail struct {
	callback  WidgetSignalButtonReleaseEventCallback
	handlerID C.gulong
}

var signalWidgetButtonReleaseEventId int
var signalWidgetButtonReleaseEventMap = make(map[int]signalWidgetButtonReleaseEventDetail)
var signalWidgetButtonReleaseEventLock sync.Mutex

// WidgetSignalButtonReleaseEventCallback is a callback function for a 'button-release-event' signal emitted from a Widget.
type WidgetSignalButtonReleaseEventCallback func(event *gdk.EventButton) bool

/*
ConnectButtonReleaseEvent connects the callback to the 'button-release-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectButtonReleaseEvent to remove it.
*/
func (recv *Widget) ConnectButtonReleaseEvent(callback WidgetSignalButtonReleaseEventCallback) int {
	signalWidgetButtonReleaseEventLock.Lock()
	defer signalWidgetButtonReleaseEventLock.Unlock()

	signalWidgetButtonReleaseEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_button_release_event(instance, C.gpointer(uintptr(signalWidgetButtonReleaseEventId)))

	detail := signalWidgetButtonReleaseEventDetail{callback, handlerID}
	signalWidgetButtonReleaseEventMap[signalWidgetButtonReleaseEventId] = detail

	return signalWidgetButtonReleaseEventId
}

/*
DisconnectButtonReleaseEvent disconnects a callback from the 'button-release-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectButtonReleaseEvent.
*/
func (recv *Widget) DisconnectButtonReleaseEvent(connectionID int) {
	signalWidgetButtonReleaseEventLock.Lock()
	defer signalWidgetButtonReleaseEventLock.Unlock()

	detail, exists := signalWidgetButtonReleaseEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetButtonReleaseEventMap, connectionID)
}

//export widget_buttonReleaseEventHandler
func widget_buttonReleaseEventHandler(_ *C.GObject, c_event *C.GdkEventButton, data C.gpointer) C.gboolean {
	event := gdk.EventButtonNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetButtonReleaseEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'can-activate-accel' for Widget : unsupported parameter signal_id : type guint :

// Unsupported signal 'child-notify' for Widget : unsupported parameter child_property : type GObject.ParamSpec : Blacklisted record : GParamSpec

type signalWidgetCompositedChangedDetail struct {
	callback  WidgetSignalCompositedChangedCallback
	handlerID C.gulong
}

var signalWidgetCompositedChangedId int
var signalWidgetCompositedChangedMap = make(map[int]signalWidgetCompositedChangedDetail)
var signalWidgetCompositedChangedLock sync.Mutex

// WidgetSignalCompositedChangedCallback is a callback function for a 'composited-changed' signal emitted from a Widget.
type WidgetSignalCompositedChangedCallback func()

/*
ConnectCompositedChanged connects the callback to the 'composited-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectCompositedChanged to remove it.
*/
func (recv *Widget) ConnectCompositedChanged(callback WidgetSignalCompositedChangedCallback) int {
	signalWidgetCompositedChangedLock.Lock()
	defer signalWidgetCompositedChangedLock.Unlock()

	signalWidgetCompositedChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_composited_changed(instance, C.gpointer(uintptr(signalWidgetCompositedChangedId)))

	detail := signalWidgetCompositedChangedDetail{callback, handlerID}
	signalWidgetCompositedChangedMap[signalWidgetCompositedChangedId] = detail

	return signalWidgetCompositedChangedId
}

/*
DisconnectCompositedChanged disconnects a callback from the 'composited-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectCompositedChanged.
*/
func (recv *Widget) DisconnectCompositedChanged(connectionID int) {
	signalWidgetCompositedChangedLock.Lock()
	defer signalWidgetCompositedChangedLock.Unlock()

	detail, exists := signalWidgetCompositedChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetCompositedChangedMap, connectionID)
}

//export widget_compositedChangedHandler
func widget_compositedChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetCompositedChangedMap[index].callback
	callback()
}

type signalWidgetConfigureEventDetail struct {
	callback  WidgetSignalConfigureEventCallback
	handlerID C.gulong
}

var signalWidgetConfigureEventId int
var signalWidgetConfigureEventMap = make(map[int]signalWidgetConfigureEventDetail)
var signalWidgetConfigureEventLock sync.Mutex

// WidgetSignalConfigureEventCallback is a callback function for a 'configure-event' signal emitted from a Widget.
type WidgetSignalConfigureEventCallback func(event *gdk.EventConfigure) bool

/*
ConnectConfigureEvent connects the callback to the 'configure-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectConfigureEvent to remove it.
*/
func (recv *Widget) ConnectConfigureEvent(callback WidgetSignalConfigureEventCallback) int {
	signalWidgetConfigureEventLock.Lock()
	defer signalWidgetConfigureEventLock.Unlock()

	signalWidgetConfigureEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_configure_event(instance, C.gpointer(uintptr(signalWidgetConfigureEventId)))

	detail := signalWidgetConfigureEventDetail{callback, handlerID}
	signalWidgetConfigureEventMap[signalWidgetConfigureEventId] = detail

	return signalWidgetConfigureEventId
}

/*
DisconnectConfigureEvent disconnects a callback from the 'configure-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectConfigureEvent.
*/
func (recv *Widget) DisconnectConfigureEvent(connectionID int) {
	signalWidgetConfigureEventLock.Lock()
	defer signalWidgetConfigureEventLock.Unlock()

	detail, exists := signalWidgetConfigureEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetConfigureEventMap, connectionID)
}

//export widget_configureEventHandler
func widget_configureEventHandler(_ *C.GObject, c_event *C.GdkEventConfigure, data C.gpointer) C.gboolean {
	event := gdk.EventConfigureNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetConfigureEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'delete-event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

type signalWidgetDestroyDetail struct {
	callback  WidgetSignalDestroyCallback
	handlerID C.gulong
}

var signalWidgetDestroyId int
var signalWidgetDestroyMap = make(map[int]signalWidgetDestroyDetail)
var signalWidgetDestroyLock sync.Mutex

// WidgetSignalDestroyCallback is a callback function for a 'destroy' signal emitted from a Widget.
type WidgetSignalDestroyCallback func()

/*
ConnectDestroy connects the callback to the 'destroy' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDestroy to remove it.
*/
func (recv *Widget) ConnectDestroy(callback WidgetSignalDestroyCallback) int {
	signalWidgetDestroyLock.Lock()
	defer signalWidgetDestroyLock.Unlock()

	signalWidgetDestroyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_destroy(instance, C.gpointer(uintptr(signalWidgetDestroyId)))

	detail := signalWidgetDestroyDetail{callback, handlerID}
	signalWidgetDestroyMap[signalWidgetDestroyId] = detail

	return signalWidgetDestroyId
}

/*
DisconnectDestroy disconnects a callback from the 'destroy' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDestroy.
*/
func (recv *Widget) DisconnectDestroy(connectionID int) {
	signalWidgetDestroyLock.Lock()
	defer signalWidgetDestroyLock.Unlock()

	detail, exists := signalWidgetDestroyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDestroyMap, connectionID)
}

//export widget_destroyHandler
func widget_destroyHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetDestroyMap[index].callback
	callback()
}

// Unsupported signal 'destroy-event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

// Unsupported signal 'direction-changed' for Widget : unsupported parameter previous_direction : type TextDirection :

type signalWidgetDragBeginDetail struct {
	callback  WidgetSignalDragBeginCallback
	handlerID C.gulong
}

var signalWidgetDragBeginId int
var signalWidgetDragBeginMap = make(map[int]signalWidgetDragBeginDetail)
var signalWidgetDragBeginLock sync.Mutex

// WidgetSignalDragBeginCallback is a callback function for a 'drag-begin' signal emitted from a Widget.
type WidgetSignalDragBeginCallback func(context *gdk.DragContext)

/*
ConnectDragBegin connects the callback to the 'drag-begin' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragBegin to remove it.
*/
func (recv *Widget) ConnectDragBegin(callback WidgetSignalDragBeginCallback) int {
	signalWidgetDragBeginLock.Lock()
	defer signalWidgetDragBeginLock.Unlock()

	signalWidgetDragBeginId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_begin(instance, C.gpointer(uintptr(signalWidgetDragBeginId)))

	detail := signalWidgetDragBeginDetail{callback, handlerID}
	signalWidgetDragBeginMap[signalWidgetDragBeginId] = detail

	return signalWidgetDragBeginId
}

/*
DisconnectDragBegin disconnects a callback from the 'drag-begin' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragBegin.
*/
func (recv *Widget) DisconnectDragBegin(connectionID int) {
	signalWidgetDragBeginLock.Lock()
	defer signalWidgetDragBeginLock.Unlock()

	detail, exists := signalWidgetDragBeginMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragBeginMap, connectionID)
}

//export widget_dragBeginHandler
func widget_dragBeginHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragBeginMap[index].callback
	callback(context)
}

type signalWidgetDragDataDeleteDetail struct {
	callback  WidgetSignalDragDataDeleteCallback
	handlerID C.gulong
}

var signalWidgetDragDataDeleteId int
var signalWidgetDragDataDeleteMap = make(map[int]signalWidgetDragDataDeleteDetail)
var signalWidgetDragDataDeleteLock sync.Mutex

// WidgetSignalDragDataDeleteCallback is a callback function for a 'drag-data-delete' signal emitted from a Widget.
type WidgetSignalDragDataDeleteCallback func(context *gdk.DragContext)

/*
ConnectDragDataDelete connects the callback to the 'drag-data-delete' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDataDelete to remove it.
*/
func (recv *Widget) ConnectDragDataDelete(callback WidgetSignalDragDataDeleteCallback) int {
	signalWidgetDragDataDeleteLock.Lock()
	defer signalWidgetDragDataDeleteLock.Unlock()

	signalWidgetDragDataDeleteId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_data_delete(instance, C.gpointer(uintptr(signalWidgetDragDataDeleteId)))

	detail := signalWidgetDragDataDeleteDetail{callback, handlerID}
	signalWidgetDragDataDeleteMap[signalWidgetDragDataDeleteId] = detail

	return signalWidgetDragDataDeleteId
}

/*
DisconnectDragDataDelete disconnects a callback from the 'drag-data-delete' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDataDelete.
*/
func (recv *Widget) DisconnectDragDataDelete(connectionID int) {
	signalWidgetDragDataDeleteLock.Lock()
	defer signalWidgetDragDataDeleteLock.Unlock()

	detail, exists := signalWidgetDragDataDeleteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDataDeleteMap, connectionID)
}

//export widget_dragDataDeleteHandler
func widget_dragDataDeleteHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragDataDeleteMap[index].callback
	callback(context)
}

// Unsupported signal 'drag-data-get' for Widget : unsupported parameter info : type guint :

// Unsupported signal 'drag-data-received' for Widget : unsupported parameter x : type gint :

// Unsupported signal 'drag-drop' for Widget : unsupported parameter x : type gint :

type signalWidgetDragEndDetail struct {
	callback  WidgetSignalDragEndCallback
	handlerID C.gulong
}

var signalWidgetDragEndId int
var signalWidgetDragEndMap = make(map[int]signalWidgetDragEndDetail)
var signalWidgetDragEndLock sync.Mutex

// WidgetSignalDragEndCallback is a callback function for a 'drag-end' signal emitted from a Widget.
type WidgetSignalDragEndCallback func(context *gdk.DragContext)

/*
ConnectDragEnd connects the callback to the 'drag-end' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragEnd to remove it.
*/
func (recv *Widget) ConnectDragEnd(callback WidgetSignalDragEndCallback) int {
	signalWidgetDragEndLock.Lock()
	defer signalWidgetDragEndLock.Unlock()

	signalWidgetDragEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_end(instance, C.gpointer(uintptr(signalWidgetDragEndId)))

	detail := signalWidgetDragEndDetail{callback, handlerID}
	signalWidgetDragEndMap[signalWidgetDragEndId] = detail

	return signalWidgetDragEndId
}

/*
DisconnectDragEnd disconnects a callback from the 'drag-end' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragEnd.
*/
func (recv *Widget) DisconnectDragEnd(connectionID int) {
	signalWidgetDragEndLock.Lock()
	defer signalWidgetDragEndLock.Unlock()

	detail, exists := signalWidgetDragEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragEndMap, connectionID)
}

//export widget_dragEndHandler
func widget_dragEndHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragEndMap[index].callback
	callback(context)
}

// Unsupported signal 'drag-leave' for Widget : unsupported parameter time : type guint :

// Unsupported signal 'drag-motion' for Widget : unsupported parameter x : type gint :

type signalWidgetEnterNotifyEventDetail struct {
	callback  WidgetSignalEnterNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetEnterNotifyEventId int
var signalWidgetEnterNotifyEventMap = make(map[int]signalWidgetEnterNotifyEventDetail)
var signalWidgetEnterNotifyEventLock sync.Mutex

// WidgetSignalEnterNotifyEventCallback is a callback function for a 'enter-notify-event' signal emitted from a Widget.
type WidgetSignalEnterNotifyEventCallback func(event *gdk.EventCrossing) bool

/*
ConnectEnterNotifyEvent connects the callback to the 'enter-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectEnterNotifyEvent to remove it.
*/
func (recv *Widget) ConnectEnterNotifyEvent(callback WidgetSignalEnterNotifyEventCallback) int {
	signalWidgetEnterNotifyEventLock.Lock()
	defer signalWidgetEnterNotifyEventLock.Unlock()

	signalWidgetEnterNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_enter_notify_event(instance, C.gpointer(uintptr(signalWidgetEnterNotifyEventId)))

	detail := signalWidgetEnterNotifyEventDetail{callback, handlerID}
	signalWidgetEnterNotifyEventMap[signalWidgetEnterNotifyEventId] = detail

	return signalWidgetEnterNotifyEventId
}

/*
DisconnectEnterNotifyEvent disconnects a callback from the 'enter-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectEnterNotifyEvent.
*/
func (recv *Widget) DisconnectEnterNotifyEvent(connectionID int) {
	signalWidgetEnterNotifyEventLock.Lock()
	defer signalWidgetEnterNotifyEventLock.Unlock()

	detail, exists := signalWidgetEnterNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetEnterNotifyEventMap, connectionID)
}

//export widget_enterNotifyEventHandler
func widget_enterNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventCrossing, data C.gpointer) C.gboolean {
	event := gdk.EventCrossingNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetEnterNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'event' for Widget : unsupported parameter event : no type generator for Gdk.Event,

// Unsupported signal 'event-after' for Widget : unsupported parameter event : no type generator for Gdk.Event,

// Unsupported signal 'focus' for Widget : unsupported parameter direction : type DirectionType :

type signalWidgetFocusInEventDetail struct {
	callback  WidgetSignalFocusInEventCallback
	handlerID C.gulong
}

var signalWidgetFocusInEventId int
var signalWidgetFocusInEventMap = make(map[int]signalWidgetFocusInEventDetail)
var signalWidgetFocusInEventLock sync.Mutex

// WidgetSignalFocusInEventCallback is a callback function for a 'focus-in-event' signal emitted from a Widget.
type WidgetSignalFocusInEventCallback func(event *gdk.EventFocus) bool

/*
ConnectFocusInEvent connects the callback to the 'focus-in-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocusInEvent to remove it.
*/
func (recv *Widget) ConnectFocusInEvent(callback WidgetSignalFocusInEventCallback) int {
	signalWidgetFocusInEventLock.Lock()
	defer signalWidgetFocusInEventLock.Unlock()

	signalWidgetFocusInEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus_in_event(instance, C.gpointer(uintptr(signalWidgetFocusInEventId)))

	detail := signalWidgetFocusInEventDetail{callback, handlerID}
	signalWidgetFocusInEventMap[signalWidgetFocusInEventId] = detail

	return signalWidgetFocusInEventId
}

/*
DisconnectFocusInEvent disconnects a callback from the 'focus-in-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocusInEvent.
*/
func (recv *Widget) DisconnectFocusInEvent(connectionID int) {
	signalWidgetFocusInEventLock.Lock()
	defer signalWidgetFocusInEventLock.Unlock()

	detail, exists := signalWidgetFocusInEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusInEventMap, connectionID)
}

//export widget_focusInEventHandler
func widget_focusInEventHandler(_ *C.GObject, c_event *C.GdkEventFocus, data C.gpointer) C.gboolean {
	event := gdk.EventFocusNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetFocusInEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetFocusOutEventDetail struct {
	callback  WidgetSignalFocusOutEventCallback
	handlerID C.gulong
}

var signalWidgetFocusOutEventId int
var signalWidgetFocusOutEventMap = make(map[int]signalWidgetFocusOutEventDetail)
var signalWidgetFocusOutEventLock sync.Mutex

// WidgetSignalFocusOutEventCallback is a callback function for a 'focus-out-event' signal emitted from a Widget.
type WidgetSignalFocusOutEventCallback func(event *gdk.EventFocus) bool

/*
ConnectFocusOutEvent connects the callback to the 'focus-out-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocusOutEvent to remove it.
*/
func (recv *Widget) ConnectFocusOutEvent(callback WidgetSignalFocusOutEventCallback) int {
	signalWidgetFocusOutEventLock.Lock()
	defer signalWidgetFocusOutEventLock.Unlock()

	signalWidgetFocusOutEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus_out_event(instance, C.gpointer(uintptr(signalWidgetFocusOutEventId)))

	detail := signalWidgetFocusOutEventDetail{callback, handlerID}
	signalWidgetFocusOutEventMap[signalWidgetFocusOutEventId] = detail

	return signalWidgetFocusOutEventId
}

/*
DisconnectFocusOutEvent disconnects a callback from the 'focus-out-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocusOutEvent.
*/
func (recv *Widget) DisconnectFocusOutEvent(connectionID int) {
	signalWidgetFocusOutEventLock.Lock()
	defer signalWidgetFocusOutEventLock.Unlock()

	detail, exists := signalWidgetFocusOutEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusOutEventMap, connectionID)
}

//export widget_focusOutEventHandler
func widget_focusOutEventHandler(_ *C.GObject, c_event *C.GdkEventFocus, data C.gpointer) C.gboolean {
	event := gdk.EventFocusNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetFocusOutEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetGrabFocusDetail struct {
	callback  WidgetSignalGrabFocusCallback
	handlerID C.gulong
}

var signalWidgetGrabFocusId int
var signalWidgetGrabFocusMap = make(map[int]signalWidgetGrabFocusDetail)
var signalWidgetGrabFocusLock sync.Mutex

// WidgetSignalGrabFocusCallback is a callback function for a 'grab-focus' signal emitted from a Widget.
type WidgetSignalGrabFocusCallback func()

/*
ConnectGrabFocus connects the callback to the 'grab-focus' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabFocus to remove it.
*/
func (recv *Widget) ConnectGrabFocus(callback WidgetSignalGrabFocusCallback) int {
	signalWidgetGrabFocusLock.Lock()
	defer signalWidgetGrabFocusLock.Unlock()

	signalWidgetGrabFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_focus(instance, C.gpointer(uintptr(signalWidgetGrabFocusId)))

	detail := signalWidgetGrabFocusDetail{callback, handlerID}
	signalWidgetGrabFocusMap[signalWidgetGrabFocusId] = detail

	return signalWidgetGrabFocusId
}

/*
DisconnectGrabFocus disconnects a callback from the 'grab-focus' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabFocus.
*/
func (recv *Widget) DisconnectGrabFocus(connectionID int) {
	signalWidgetGrabFocusLock.Lock()
	defer signalWidgetGrabFocusLock.Unlock()

	detail, exists := signalWidgetGrabFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabFocusMap, connectionID)
}

//export widget_grabFocusHandler
func widget_grabFocusHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetGrabFocusMap[index].callback
	callback()
}

type signalWidgetGrabNotifyDetail struct {
	callback  WidgetSignalGrabNotifyCallback
	handlerID C.gulong
}

var signalWidgetGrabNotifyId int
var signalWidgetGrabNotifyMap = make(map[int]signalWidgetGrabNotifyDetail)
var signalWidgetGrabNotifyLock sync.Mutex

// WidgetSignalGrabNotifyCallback is a callback function for a 'grab-notify' signal emitted from a Widget.
type WidgetSignalGrabNotifyCallback func(wasGrabbed bool)

/*
ConnectGrabNotify connects the callback to the 'grab-notify' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabNotify to remove it.
*/
func (recv *Widget) ConnectGrabNotify(callback WidgetSignalGrabNotifyCallback) int {
	signalWidgetGrabNotifyLock.Lock()
	defer signalWidgetGrabNotifyLock.Unlock()

	signalWidgetGrabNotifyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_notify(instance, C.gpointer(uintptr(signalWidgetGrabNotifyId)))

	detail := signalWidgetGrabNotifyDetail{callback, handlerID}
	signalWidgetGrabNotifyMap[signalWidgetGrabNotifyId] = detail

	return signalWidgetGrabNotifyId
}

/*
DisconnectGrabNotify disconnects a callback from the 'grab-notify' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabNotify.
*/
func (recv *Widget) DisconnectGrabNotify(connectionID int) {
	signalWidgetGrabNotifyLock.Lock()
	defer signalWidgetGrabNotifyLock.Unlock()

	detail, exists := signalWidgetGrabNotifyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabNotifyMap, connectionID)
}

//export widget_grabNotifyHandler
func widget_grabNotifyHandler(_ *C.GObject, c_was_grabbed C.gboolean, data C.gpointer) {
	wasGrabbed := c_was_grabbed == C.TRUE

	index := int(uintptr(data))
	callback := signalWidgetGrabNotifyMap[index].callback
	callback(wasGrabbed)
}

type signalWidgetHideDetail struct {
	callback  WidgetSignalHideCallback
	handlerID C.gulong
}

var signalWidgetHideId int
var signalWidgetHideMap = make(map[int]signalWidgetHideDetail)
var signalWidgetHideLock sync.Mutex

// WidgetSignalHideCallback is a callback function for a 'hide' signal emitted from a Widget.
type WidgetSignalHideCallback func()

/*
ConnectHide connects the callback to the 'hide' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectHide to remove it.
*/
func (recv *Widget) ConnectHide(callback WidgetSignalHideCallback) int {
	signalWidgetHideLock.Lock()
	defer signalWidgetHideLock.Unlock()

	signalWidgetHideId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_hide(instance, C.gpointer(uintptr(signalWidgetHideId)))

	detail := signalWidgetHideDetail{callback, handlerID}
	signalWidgetHideMap[signalWidgetHideId] = detail

	return signalWidgetHideId
}

/*
DisconnectHide disconnects a callback from the 'hide' signal for the Widget.

The connectionID should be a value returned from a call to ConnectHide.
*/
func (recv *Widget) DisconnectHide(connectionID int) {
	signalWidgetHideLock.Lock()
	defer signalWidgetHideLock.Unlock()

	detail, exists := signalWidgetHideMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetHideMap, connectionID)
}

//export widget_hideHandler
func widget_hideHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetHideMap[index].callback
	callback()
}

type signalWidgetHierarchyChangedDetail struct {
	callback  WidgetSignalHierarchyChangedCallback
	handlerID C.gulong
}

var signalWidgetHierarchyChangedId int
var signalWidgetHierarchyChangedMap = make(map[int]signalWidgetHierarchyChangedDetail)
var signalWidgetHierarchyChangedLock sync.Mutex

// WidgetSignalHierarchyChangedCallback is a callback function for a 'hierarchy-changed' signal emitted from a Widget.
type WidgetSignalHierarchyChangedCallback func(previousToplevel *Widget)

/*
ConnectHierarchyChanged connects the callback to the 'hierarchy-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectHierarchyChanged to remove it.
*/
func (recv *Widget) ConnectHierarchyChanged(callback WidgetSignalHierarchyChangedCallback) int {
	signalWidgetHierarchyChangedLock.Lock()
	defer signalWidgetHierarchyChangedLock.Unlock()

	signalWidgetHierarchyChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_hierarchy_changed(instance, C.gpointer(uintptr(signalWidgetHierarchyChangedId)))

	detail := signalWidgetHierarchyChangedDetail{callback, handlerID}
	signalWidgetHierarchyChangedMap[signalWidgetHierarchyChangedId] = detail

	return signalWidgetHierarchyChangedId
}

/*
DisconnectHierarchyChanged disconnects a callback from the 'hierarchy-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectHierarchyChanged.
*/
func (recv *Widget) DisconnectHierarchyChanged(connectionID int) {
	signalWidgetHierarchyChangedLock.Lock()
	defer signalWidgetHierarchyChangedLock.Unlock()

	detail, exists := signalWidgetHierarchyChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetHierarchyChangedMap, connectionID)
}

//export widget_hierarchyChangedHandler
func widget_hierarchyChangedHandler(_ *C.GObject, c_previous_toplevel *C.GtkWidget, data C.gpointer) {
	previousToplevel := WidgetNewFromC(unsafe.Pointer(c_previous_toplevel))

	index := int(uintptr(data))
	callback := signalWidgetHierarchyChangedMap[index].callback
	callback(previousToplevel)
}

type signalWidgetKeyPressEventDetail struct {
	callback  WidgetSignalKeyPressEventCallback
	handlerID C.gulong
}

var signalWidgetKeyPressEventId int
var signalWidgetKeyPressEventMap = make(map[int]signalWidgetKeyPressEventDetail)
var signalWidgetKeyPressEventLock sync.Mutex

// WidgetSignalKeyPressEventCallback is a callback function for a 'key-press-event' signal emitted from a Widget.
type WidgetSignalKeyPressEventCallback func(event *gdk.EventKey) bool

/*
ConnectKeyPressEvent connects the callback to the 'key-press-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeyPressEvent to remove it.
*/
func (recv *Widget) ConnectKeyPressEvent(callback WidgetSignalKeyPressEventCallback) int {
	signalWidgetKeyPressEventLock.Lock()
	defer signalWidgetKeyPressEventLock.Unlock()

	signalWidgetKeyPressEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_key_press_event(instance, C.gpointer(uintptr(signalWidgetKeyPressEventId)))

	detail := signalWidgetKeyPressEventDetail{callback, handlerID}
	signalWidgetKeyPressEventMap[signalWidgetKeyPressEventId] = detail

	return signalWidgetKeyPressEventId
}

/*
DisconnectKeyPressEvent disconnects a callback from the 'key-press-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeyPressEvent.
*/
func (recv *Widget) DisconnectKeyPressEvent(connectionID int) {
	signalWidgetKeyPressEventLock.Lock()
	defer signalWidgetKeyPressEventLock.Unlock()

	detail, exists := signalWidgetKeyPressEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeyPressEventMap, connectionID)
}

//export widget_keyPressEventHandler
func widget_keyPressEventHandler(_ *C.GObject, c_event *C.GdkEventKey, data C.gpointer) C.gboolean {
	event := gdk.EventKeyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetKeyPressEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetKeyReleaseEventDetail struct {
	callback  WidgetSignalKeyReleaseEventCallback
	handlerID C.gulong
}

var signalWidgetKeyReleaseEventId int
var signalWidgetKeyReleaseEventMap = make(map[int]signalWidgetKeyReleaseEventDetail)
var signalWidgetKeyReleaseEventLock sync.Mutex

// WidgetSignalKeyReleaseEventCallback is a callback function for a 'key-release-event' signal emitted from a Widget.
type WidgetSignalKeyReleaseEventCallback func(event *gdk.EventKey) bool

/*
ConnectKeyReleaseEvent connects the callback to the 'key-release-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeyReleaseEvent to remove it.
*/
func (recv *Widget) ConnectKeyReleaseEvent(callback WidgetSignalKeyReleaseEventCallback) int {
	signalWidgetKeyReleaseEventLock.Lock()
	defer signalWidgetKeyReleaseEventLock.Unlock()

	signalWidgetKeyReleaseEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_key_release_event(instance, C.gpointer(uintptr(signalWidgetKeyReleaseEventId)))

	detail := signalWidgetKeyReleaseEventDetail{callback, handlerID}
	signalWidgetKeyReleaseEventMap[signalWidgetKeyReleaseEventId] = detail

	return signalWidgetKeyReleaseEventId
}

/*
DisconnectKeyReleaseEvent disconnects a callback from the 'key-release-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeyReleaseEvent.
*/
func (recv *Widget) DisconnectKeyReleaseEvent(connectionID int) {
	signalWidgetKeyReleaseEventLock.Lock()
	defer signalWidgetKeyReleaseEventLock.Unlock()

	detail, exists := signalWidgetKeyReleaseEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeyReleaseEventMap, connectionID)
}

//export widget_keyReleaseEventHandler
func widget_keyReleaseEventHandler(_ *C.GObject, c_event *C.GdkEventKey, data C.gpointer) C.gboolean {
	event := gdk.EventKeyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetKeyReleaseEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetLeaveNotifyEventDetail struct {
	callback  WidgetSignalLeaveNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetLeaveNotifyEventId int
var signalWidgetLeaveNotifyEventMap = make(map[int]signalWidgetLeaveNotifyEventDetail)
var signalWidgetLeaveNotifyEventLock sync.Mutex

// WidgetSignalLeaveNotifyEventCallback is a callback function for a 'leave-notify-event' signal emitted from a Widget.
type WidgetSignalLeaveNotifyEventCallback func(event *gdk.EventCrossing) bool

/*
ConnectLeaveNotifyEvent connects the callback to the 'leave-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectLeaveNotifyEvent to remove it.
*/
func (recv *Widget) ConnectLeaveNotifyEvent(callback WidgetSignalLeaveNotifyEventCallback) int {
	signalWidgetLeaveNotifyEventLock.Lock()
	defer signalWidgetLeaveNotifyEventLock.Unlock()

	signalWidgetLeaveNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_leave_notify_event(instance, C.gpointer(uintptr(signalWidgetLeaveNotifyEventId)))

	detail := signalWidgetLeaveNotifyEventDetail{callback, handlerID}
	signalWidgetLeaveNotifyEventMap[signalWidgetLeaveNotifyEventId] = detail

	return signalWidgetLeaveNotifyEventId
}

/*
DisconnectLeaveNotifyEvent disconnects a callback from the 'leave-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectLeaveNotifyEvent.
*/
func (recv *Widget) DisconnectLeaveNotifyEvent(connectionID int) {
	signalWidgetLeaveNotifyEventLock.Lock()
	defer signalWidgetLeaveNotifyEventLock.Unlock()

	detail, exists := signalWidgetLeaveNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetLeaveNotifyEventMap, connectionID)
}

//export widget_leaveNotifyEventHandler
func widget_leaveNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventCrossing, data C.gpointer) C.gboolean {
	event := gdk.EventCrossingNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetLeaveNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMapDetail struct {
	callback  WidgetSignalMapCallback
	handlerID C.gulong
}

var signalWidgetMapId int
var signalWidgetMapMap = make(map[int]signalWidgetMapDetail)
var signalWidgetMapLock sync.Mutex

// WidgetSignalMapCallback is a callback function for a 'map' signal emitted from a Widget.
type WidgetSignalMapCallback func()

/*
ConnectMap connects the callback to the 'map' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMap to remove it.
*/
func (recv *Widget) ConnectMap(callback WidgetSignalMapCallback) int {
	signalWidgetMapLock.Lock()
	defer signalWidgetMapLock.Unlock()

	signalWidgetMapId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_map(instance, C.gpointer(uintptr(signalWidgetMapId)))

	detail := signalWidgetMapDetail{callback, handlerID}
	signalWidgetMapMap[signalWidgetMapId] = detail

	return signalWidgetMapId
}

/*
DisconnectMap disconnects a callback from the 'map' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMap.
*/
func (recv *Widget) DisconnectMap(connectionID int) {
	signalWidgetMapLock.Lock()
	defer signalWidgetMapLock.Unlock()

	detail, exists := signalWidgetMapMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMapMap, connectionID)
}

//export widget_mapHandler
func widget_mapHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetMapMap[index].callback
	callback()
}

type signalWidgetMapEventDetail struct {
	callback  WidgetSignalMapEventCallback
	handlerID C.gulong
}

var signalWidgetMapEventId int
var signalWidgetMapEventMap = make(map[int]signalWidgetMapEventDetail)
var signalWidgetMapEventLock sync.Mutex

// WidgetSignalMapEventCallback is a callback function for a 'map-event' signal emitted from a Widget.
type WidgetSignalMapEventCallback func(event *gdk.EventAny) bool

/*
ConnectMapEvent connects the callback to the 'map-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMapEvent to remove it.
*/
func (recv *Widget) ConnectMapEvent(callback WidgetSignalMapEventCallback) int {
	signalWidgetMapEventLock.Lock()
	defer signalWidgetMapEventLock.Unlock()

	signalWidgetMapEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_map_event(instance, C.gpointer(uintptr(signalWidgetMapEventId)))

	detail := signalWidgetMapEventDetail{callback, handlerID}
	signalWidgetMapEventMap[signalWidgetMapEventId] = detail

	return signalWidgetMapEventId
}

/*
DisconnectMapEvent disconnects a callback from the 'map-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMapEvent.
*/
func (recv *Widget) DisconnectMapEvent(connectionID int) {
	signalWidgetMapEventLock.Lock()
	defer signalWidgetMapEventLock.Unlock()

	detail, exists := signalWidgetMapEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMapEventMap, connectionID)
}

//export widget_mapEventHandler
func widget_mapEventHandler(_ *C.GObject, c_event *C.GdkEventAny, data C.gpointer) C.gboolean {
	event := gdk.EventAnyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetMapEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMnemonicActivateDetail struct {
	callback  WidgetSignalMnemonicActivateCallback
	handlerID C.gulong
}

var signalWidgetMnemonicActivateId int
var signalWidgetMnemonicActivateMap = make(map[int]signalWidgetMnemonicActivateDetail)
var signalWidgetMnemonicActivateLock sync.Mutex

// WidgetSignalMnemonicActivateCallback is a callback function for a 'mnemonic-activate' signal emitted from a Widget.
type WidgetSignalMnemonicActivateCallback func(groupCycling bool) bool

/*
ConnectMnemonicActivate connects the callback to the 'mnemonic-activate' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMnemonicActivate to remove it.
*/
func (recv *Widget) ConnectMnemonicActivate(callback WidgetSignalMnemonicActivateCallback) int {
	signalWidgetMnemonicActivateLock.Lock()
	defer signalWidgetMnemonicActivateLock.Unlock()

	signalWidgetMnemonicActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_mnemonic_activate(instance, C.gpointer(uintptr(signalWidgetMnemonicActivateId)))

	detail := signalWidgetMnemonicActivateDetail{callback, handlerID}
	signalWidgetMnemonicActivateMap[signalWidgetMnemonicActivateId] = detail

	return signalWidgetMnemonicActivateId
}

/*
DisconnectMnemonicActivate disconnects a callback from the 'mnemonic-activate' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMnemonicActivate.
*/
func (recv *Widget) DisconnectMnemonicActivate(connectionID int) {
	signalWidgetMnemonicActivateLock.Lock()
	defer signalWidgetMnemonicActivateLock.Unlock()

	detail, exists := signalWidgetMnemonicActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMnemonicActivateMap, connectionID)
}

//export widget_mnemonicActivateHandler
func widget_mnemonicActivateHandler(_ *C.GObject, c_group_cycling C.gboolean, data C.gpointer) C.gboolean {
	groupCycling := c_group_cycling == C.TRUE

	index := int(uintptr(data))
	callback := signalWidgetMnemonicActivateMap[index].callback
	retGo := callback(groupCycling)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMotionNotifyEventDetail struct {
	callback  WidgetSignalMotionNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetMotionNotifyEventId int
var signalWidgetMotionNotifyEventMap = make(map[int]signalWidgetMotionNotifyEventDetail)
var signalWidgetMotionNotifyEventLock sync.Mutex

// WidgetSignalMotionNotifyEventCallback is a callback function for a 'motion-notify-event' signal emitted from a Widget.
type WidgetSignalMotionNotifyEventCallback func(event *gdk.EventMotion) bool

/*
ConnectMotionNotifyEvent connects the callback to the 'motion-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMotionNotifyEvent to remove it.
*/
func (recv *Widget) ConnectMotionNotifyEvent(callback WidgetSignalMotionNotifyEventCallback) int {
	signalWidgetMotionNotifyEventLock.Lock()
	defer signalWidgetMotionNotifyEventLock.Unlock()

	signalWidgetMotionNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_motion_notify_event(instance, C.gpointer(uintptr(signalWidgetMotionNotifyEventId)))

	detail := signalWidgetMotionNotifyEventDetail{callback, handlerID}
	signalWidgetMotionNotifyEventMap[signalWidgetMotionNotifyEventId] = detail

	return signalWidgetMotionNotifyEventId
}

/*
DisconnectMotionNotifyEvent disconnects a callback from the 'motion-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMotionNotifyEvent.
*/
func (recv *Widget) DisconnectMotionNotifyEvent(connectionID int) {
	signalWidgetMotionNotifyEventLock.Lock()
	defer signalWidgetMotionNotifyEventLock.Unlock()

	detail, exists := signalWidgetMotionNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMotionNotifyEventMap, connectionID)
}

//export widget_motionNotifyEventHandler
func widget_motionNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventMotion, data C.gpointer) C.gboolean {
	event := gdk.EventMotionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetMotionNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'move-focus' for Widget : unsupported parameter direction : type DirectionType :

type signalWidgetParentSetDetail struct {
	callback  WidgetSignalParentSetCallback
	handlerID C.gulong
}

var signalWidgetParentSetId int
var signalWidgetParentSetMap = make(map[int]signalWidgetParentSetDetail)
var signalWidgetParentSetLock sync.Mutex

// WidgetSignalParentSetCallback is a callback function for a 'parent-set' signal emitted from a Widget.
type WidgetSignalParentSetCallback func(oldParent *Widget)

/*
ConnectParentSet connects the callback to the 'parent-set' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectParentSet to remove it.
*/
func (recv *Widget) ConnectParentSet(callback WidgetSignalParentSetCallback) int {
	signalWidgetParentSetLock.Lock()
	defer signalWidgetParentSetLock.Unlock()

	signalWidgetParentSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_parent_set(instance, C.gpointer(uintptr(signalWidgetParentSetId)))

	detail := signalWidgetParentSetDetail{callback, handlerID}
	signalWidgetParentSetMap[signalWidgetParentSetId] = detail

	return signalWidgetParentSetId
}

/*
DisconnectParentSet disconnects a callback from the 'parent-set' signal for the Widget.

The connectionID should be a value returned from a call to ConnectParentSet.
*/
func (recv *Widget) DisconnectParentSet(connectionID int) {
	signalWidgetParentSetLock.Lock()
	defer signalWidgetParentSetLock.Unlock()

	detail, exists := signalWidgetParentSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetParentSetMap, connectionID)
}

//export widget_parentSetHandler
func widget_parentSetHandler(_ *C.GObject, c_old_parent *C.GtkWidget, data C.gpointer) {
	oldParent := WidgetNewFromC(unsafe.Pointer(c_old_parent))

	index := int(uintptr(data))
	callback := signalWidgetParentSetMap[index].callback
	callback(oldParent)
}

type signalWidgetPopupMenuDetail struct {
	callback  WidgetSignalPopupMenuCallback
	handlerID C.gulong
}

var signalWidgetPopupMenuId int
var signalWidgetPopupMenuMap = make(map[int]signalWidgetPopupMenuDetail)
var signalWidgetPopupMenuLock sync.Mutex

// WidgetSignalPopupMenuCallback is a callback function for a 'popup-menu' signal emitted from a Widget.
type WidgetSignalPopupMenuCallback func() bool

/*
ConnectPopupMenu connects the callback to the 'popup-menu' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectPopupMenu to remove it.
*/
func (recv *Widget) ConnectPopupMenu(callback WidgetSignalPopupMenuCallback) int {
	signalWidgetPopupMenuLock.Lock()
	defer signalWidgetPopupMenuLock.Unlock()

	signalWidgetPopupMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_popup_menu(instance, C.gpointer(uintptr(signalWidgetPopupMenuId)))

	detail := signalWidgetPopupMenuDetail{callback, handlerID}
	signalWidgetPopupMenuMap[signalWidgetPopupMenuId] = detail

	return signalWidgetPopupMenuId
}

/*
DisconnectPopupMenu disconnects a callback from the 'popup-menu' signal for the Widget.

The connectionID should be a value returned from a call to ConnectPopupMenu.
*/
func (recv *Widget) DisconnectPopupMenu(connectionID int) {
	signalWidgetPopupMenuLock.Lock()
	defer signalWidgetPopupMenuLock.Unlock()

	detail, exists := signalWidgetPopupMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetPopupMenuMap, connectionID)
}

//export widget_popupMenuHandler
func widget_popupMenuHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	index := int(uintptr(data))
	callback := signalWidgetPopupMenuMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetPropertyNotifyEventDetail struct {
	callback  WidgetSignalPropertyNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetPropertyNotifyEventId int
var signalWidgetPropertyNotifyEventMap = make(map[int]signalWidgetPropertyNotifyEventDetail)
var signalWidgetPropertyNotifyEventLock sync.Mutex

// WidgetSignalPropertyNotifyEventCallback is a callback function for a 'property-notify-event' signal emitted from a Widget.
type WidgetSignalPropertyNotifyEventCallback func(event *gdk.EventProperty) bool

/*
ConnectPropertyNotifyEvent connects the callback to the 'property-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectPropertyNotifyEvent to remove it.
*/
func (recv *Widget) ConnectPropertyNotifyEvent(callback WidgetSignalPropertyNotifyEventCallback) int {
	signalWidgetPropertyNotifyEventLock.Lock()
	defer signalWidgetPropertyNotifyEventLock.Unlock()

	signalWidgetPropertyNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_property_notify_event(instance, C.gpointer(uintptr(signalWidgetPropertyNotifyEventId)))

	detail := signalWidgetPropertyNotifyEventDetail{callback, handlerID}
	signalWidgetPropertyNotifyEventMap[signalWidgetPropertyNotifyEventId] = detail

	return signalWidgetPropertyNotifyEventId
}

/*
DisconnectPropertyNotifyEvent disconnects a callback from the 'property-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectPropertyNotifyEvent.
*/
func (recv *Widget) DisconnectPropertyNotifyEvent(connectionID int) {
	signalWidgetPropertyNotifyEventLock.Lock()
	defer signalWidgetPropertyNotifyEventLock.Unlock()

	detail, exists := signalWidgetPropertyNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetPropertyNotifyEventMap, connectionID)
}

//export widget_propertyNotifyEventHandler
func widget_propertyNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventProperty, data C.gpointer) C.gboolean {
	event := gdk.EventPropertyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetPropertyNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetProximityInEventDetail struct {
	callback  WidgetSignalProximityInEventCallback
	handlerID C.gulong
}

var signalWidgetProximityInEventId int
var signalWidgetProximityInEventMap = make(map[int]signalWidgetProximityInEventDetail)
var signalWidgetProximityInEventLock sync.Mutex

// WidgetSignalProximityInEventCallback is a callback function for a 'proximity-in-event' signal emitted from a Widget.
type WidgetSignalProximityInEventCallback func(event *gdk.EventProximity) bool

/*
ConnectProximityInEvent connects the callback to the 'proximity-in-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectProximityInEvent to remove it.
*/
func (recv *Widget) ConnectProximityInEvent(callback WidgetSignalProximityInEventCallback) int {
	signalWidgetProximityInEventLock.Lock()
	defer signalWidgetProximityInEventLock.Unlock()

	signalWidgetProximityInEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_proximity_in_event(instance, C.gpointer(uintptr(signalWidgetProximityInEventId)))

	detail := signalWidgetProximityInEventDetail{callback, handlerID}
	signalWidgetProximityInEventMap[signalWidgetProximityInEventId] = detail

	return signalWidgetProximityInEventId
}

/*
DisconnectProximityInEvent disconnects a callback from the 'proximity-in-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectProximityInEvent.
*/
func (recv *Widget) DisconnectProximityInEvent(connectionID int) {
	signalWidgetProximityInEventLock.Lock()
	defer signalWidgetProximityInEventLock.Unlock()

	detail, exists := signalWidgetProximityInEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetProximityInEventMap, connectionID)
}

//export widget_proximityInEventHandler
func widget_proximityInEventHandler(_ *C.GObject, c_event *C.GdkEventProximity, data C.gpointer) C.gboolean {
	event := gdk.EventProximityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetProximityInEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetProximityOutEventDetail struct {
	callback  WidgetSignalProximityOutEventCallback
	handlerID C.gulong
}

var signalWidgetProximityOutEventId int
var signalWidgetProximityOutEventMap = make(map[int]signalWidgetProximityOutEventDetail)
var signalWidgetProximityOutEventLock sync.Mutex

// WidgetSignalProximityOutEventCallback is a callback function for a 'proximity-out-event' signal emitted from a Widget.
type WidgetSignalProximityOutEventCallback func(event *gdk.EventProximity) bool

/*
ConnectProximityOutEvent connects the callback to the 'proximity-out-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectProximityOutEvent to remove it.
*/
func (recv *Widget) ConnectProximityOutEvent(callback WidgetSignalProximityOutEventCallback) int {
	signalWidgetProximityOutEventLock.Lock()
	defer signalWidgetProximityOutEventLock.Unlock()

	signalWidgetProximityOutEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_proximity_out_event(instance, C.gpointer(uintptr(signalWidgetProximityOutEventId)))

	detail := signalWidgetProximityOutEventDetail{callback, handlerID}
	signalWidgetProximityOutEventMap[signalWidgetProximityOutEventId] = detail

	return signalWidgetProximityOutEventId
}

/*
DisconnectProximityOutEvent disconnects a callback from the 'proximity-out-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectProximityOutEvent.
*/
func (recv *Widget) DisconnectProximityOutEvent(connectionID int) {
	signalWidgetProximityOutEventLock.Lock()
	defer signalWidgetProximityOutEventLock.Unlock()

	detail, exists := signalWidgetProximityOutEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetProximityOutEventMap, connectionID)
}

//export widget_proximityOutEventHandler
func widget_proximityOutEventHandler(_ *C.GObject, c_event *C.GdkEventProximity, data C.gpointer) C.gboolean {
	event := gdk.EventProximityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetProximityOutEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetRealizeDetail struct {
	callback  WidgetSignalRealizeCallback
	handlerID C.gulong
}

var signalWidgetRealizeId int
var signalWidgetRealizeMap = make(map[int]signalWidgetRealizeDetail)
var signalWidgetRealizeLock sync.Mutex

// WidgetSignalRealizeCallback is a callback function for a 'realize' signal emitted from a Widget.
type WidgetSignalRealizeCallback func()

/*
ConnectRealize connects the callback to the 'realize' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectRealize to remove it.
*/
func (recv *Widget) ConnectRealize(callback WidgetSignalRealizeCallback) int {
	signalWidgetRealizeLock.Lock()
	defer signalWidgetRealizeLock.Unlock()

	signalWidgetRealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_realize(instance, C.gpointer(uintptr(signalWidgetRealizeId)))

	detail := signalWidgetRealizeDetail{callback, handlerID}
	signalWidgetRealizeMap[signalWidgetRealizeId] = detail

	return signalWidgetRealizeId
}

/*
DisconnectRealize disconnects a callback from the 'realize' signal for the Widget.

The connectionID should be a value returned from a call to ConnectRealize.
*/
func (recv *Widget) DisconnectRealize(connectionID int) {
	signalWidgetRealizeLock.Lock()
	defer signalWidgetRealizeLock.Unlock()

	detail, exists := signalWidgetRealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetRealizeMap, connectionID)
}

//export widget_realizeHandler
func widget_realizeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetRealizeMap[index].callback
	callback()
}

type signalWidgetScreenChangedDetail struct {
	callback  WidgetSignalScreenChangedCallback
	handlerID C.gulong
}

var signalWidgetScreenChangedId int
var signalWidgetScreenChangedMap = make(map[int]signalWidgetScreenChangedDetail)
var signalWidgetScreenChangedLock sync.Mutex

// WidgetSignalScreenChangedCallback is a callback function for a 'screen-changed' signal emitted from a Widget.
type WidgetSignalScreenChangedCallback func(previousScreen *gdk.Screen)

/*
ConnectScreenChanged connects the callback to the 'screen-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectScreenChanged to remove it.
*/
func (recv *Widget) ConnectScreenChanged(callback WidgetSignalScreenChangedCallback) int {
	signalWidgetScreenChangedLock.Lock()
	defer signalWidgetScreenChangedLock.Unlock()

	signalWidgetScreenChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_screen_changed(instance, C.gpointer(uintptr(signalWidgetScreenChangedId)))

	detail := signalWidgetScreenChangedDetail{callback, handlerID}
	signalWidgetScreenChangedMap[signalWidgetScreenChangedId] = detail

	return signalWidgetScreenChangedId
}

/*
DisconnectScreenChanged disconnects a callback from the 'screen-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectScreenChanged.
*/
func (recv *Widget) DisconnectScreenChanged(connectionID int) {
	signalWidgetScreenChangedLock.Lock()
	defer signalWidgetScreenChangedLock.Unlock()

	detail, exists := signalWidgetScreenChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetScreenChangedMap, connectionID)
}

//export widget_screenChangedHandler
func widget_screenChangedHandler(_ *C.GObject, c_previous_screen *C.GdkScreen, data C.gpointer) {
	previousScreen := gdk.ScreenNewFromC(unsafe.Pointer(c_previous_screen))

	index := int(uintptr(data))
	callback := signalWidgetScreenChangedMap[index].callback
	callback(previousScreen)
}

type signalWidgetScrollEventDetail struct {
	callback  WidgetSignalScrollEventCallback
	handlerID C.gulong
}

var signalWidgetScrollEventId int
var signalWidgetScrollEventMap = make(map[int]signalWidgetScrollEventDetail)
var signalWidgetScrollEventLock sync.Mutex

// WidgetSignalScrollEventCallback is a callback function for a 'scroll-event' signal emitted from a Widget.
type WidgetSignalScrollEventCallback func(event *gdk.EventScroll) bool

/*
ConnectScrollEvent connects the callback to the 'scroll-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectScrollEvent to remove it.
*/
func (recv *Widget) ConnectScrollEvent(callback WidgetSignalScrollEventCallback) int {
	signalWidgetScrollEventLock.Lock()
	defer signalWidgetScrollEventLock.Unlock()

	signalWidgetScrollEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_scroll_event(instance, C.gpointer(uintptr(signalWidgetScrollEventId)))

	detail := signalWidgetScrollEventDetail{callback, handlerID}
	signalWidgetScrollEventMap[signalWidgetScrollEventId] = detail

	return signalWidgetScrollEventId
}

/*
DisconnectScrollEvent disconnects a callback from the 'scroll-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectScrollEvent.
*/
func (recv *Widget) DisconnectScrollEvent(connectionID int) {
	signalWidgetScrollEventLock.Lock()
	defer signalWidgetScrollEventLock.Unlock()

	detail, exists := signalWidgetScrollEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetScrollEventMap, connectionID)
}

//export widget_scrollEventHandler
func widget_scrollEventHandler(_ *C.GObject, c_event *C.GdkEventScroll, data C.gpointer) C.gboolean {
	event := gdk.EventScrollNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetScrollEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSelectionClearEventDetail struct {
	callback  WidgetSignalSelectionClearEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionClearEventId int
var signalWidgetSelectionClearEventMap = make(map[int]signalWidgetSelectionClearEventDetail)
var signalWidgetSelectionClearEventLock sync.Mutex

// WidgetSignalSelectionClearEventCallback is a callback function for a 'selection-clear-event' signal emitted from a Widget.
type WidgetSignalSelectionClearEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionClearEvent connects the callback to the 'selection-clear-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionClearEvent to remove it.
*/
func (recv *Widget) ConnectSelectionClearEvent(callback WidgetSignalSelectionClearEventCallback) int {
	signalWidgetSelectionClearEventLock.Lock()
	defer signalWidgetSelectionClearEventLock.Unlock()

	signalWidgetSelectionClearEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_clear_event(instance, C.gpointer(uintptr(signalWidgetSelectionClearEventId)))

	detail := signalWidgetSelectionClearEventDetail{callback, handlerID}
	signalWidgetSelectionClearEventMap[signalWidgetSelectionClearEventId] = detail

	return signalWidgetSelectionClearEventId
}

/*
DisconnectSelectionClearEvent disconnects a callback from the 'selection-clear-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionClearEvent.
*/
func (recv *Widget) DisconnectSelectionClearEvent(connectionID int) {
	signalWidgetSelectionClearEventLock.Lock()
	defer signalWidgetSelectionClearEventLock.Unlock()

	detail, exists := signalWidgetSelectionClearEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionClearEventMap, connectionID)
}

//export widget_selectionClearEventHandler
func widget_selectionClearEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionClearEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'selection-get' for Widget : unsupported parameter info : type guint :

type signalWidgetSelectionNotifyEventDetail struct {
	callback  WidgetSignalSelectionNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionNotifyEventId int
var signalWidgetSelectionNotifyEventMap = make(map[int]signalWidgetSelectionNotifyEventDetail)
var signalWidgetSelectionNotifyEventLock sync.Mutex

// WidgetSignalSelectionNotifyEventCallback is a callback function for a 'selection-notify-event' signal emitted from a Widget.
type WidgetSignalSelectionNotifyEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionNotifyEvent connects the callback to the 'selection-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionNotifyEvent to remove it.
*/
func (recv *Widget) ConnectSelectionNotifyEvent(callback WidgetSignalSelectionNotifyEventCallback) int {
	signalWidgetSelectionNotifyEventLock.Lock()
	defer signalWidgetSelectionNotifyEventLock.Unlock()

	signalWidgetSelectionNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_notify_event(instance, C.gpointer(uintptr(signalWidgetSelectionNotifyEventId)))

	detail := signalWidgetSelectionNotifyEventDetail{callback, handlerID}
	signalWidgetSelectionNotifyEventMap[signalWidgetSelectionNotifyEventId] = detail

	return signalWidgetSelectionNotifyEventId
}

/*
DisconnectSelectionNotifyEvent disconnects a callback from the 'selection-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionNotifyEvent.
*/
func (recv *Widget) DisconnectSelectionNotifyEvent(connectionID int) {
	signalWidgetSelectionNotifyEventLock.Lock()
	defer signalWidgetSelectionNotifyEventLock.Unlock()

	detail, exists := signalWidgetSelectionNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionNotifyEventMap, connectionID)
}

//export widget_selectionNotifyEventHandler
func widget_selectionNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported signal 'selection-received' for Widget : unsupported parameter time : type guint :

type signalWidgetSelectionRequestEventDetail struct {
	callback  WidgetSignalSelectionRequestEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionRequestEventId int
var signalWidgetSelectionRequestEventMap = make(map[int]signalWidgetSelectionRequestEventDetail)
var signalWidgetSelectionRequestEventLock sync.Mutex

// WidgetSignalSelectionRequestEventCallback is a callback function for a 'selection-request-event' signal emitted from a Widget.
type WidgetSignalSelectionRequestEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionRequestEvent connects the callback to the 'selection-request-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionRequestEvent to remove it.
*/
func (recv *Widget) ConnectSelectionRequestEvent(callback WidgetSignalSelectionRequestEventCallback) int {
	signalWidgetSelectionRequestEventLock.Lock()
	defer signalWidgetSelectionRequestEventLock.Unlock()

	signalWidgetSelectionRequestEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_request_event(instance, C.gpointer(uintptr(signalWidgetSelectionRequestEventId)))

	detail := signalWidgetSelectionRequestEventDetail{callback, handlerID}
	signalWidgetSelectionRequestEventMap[signalWidgetSelectionRequestEventId] = detail

	return signalWidgetSelectionRequestEventId
}

/*
DisconnectSelectionRequestEvent disconnects a callback from the 'selection-request-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionRequestEvent.
*/
func (recv *Widget) DisconnectSelectionRequestEvent(connectionID int) {
	signalWidgetSelectionRequestEventLock.Lock()
	defer signalWidgetSelectionRequestEventLock.Unlock()

	detail, exists := signalWidgetSelectionRequestEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionRequestEventMap, connectionID)
}

//export widget_selectionRequestEventHandler
func widget_selectionRequestEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionRequestEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetShowDetail struct {
	callback  WidgetSignalShowCallback
	handlerID C.gulong
}

var signalWidgetShowId int
var signalWidgetShowMap = make(map[int]signalWidgetShowDetail)
var signalWidgetShowLock sync.Mutex

// WidgetSignalShowCallback is a callback function for a 'show' signal emitted from a Widget.
type WidgetSignalShowCallback func()

/*
ConnectShow connects the callback to the 'show' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectShow to remove it.
*/
func (recv *Widget) ConnectShow(callback WidgetSignalShowCallback) int {
	signalWidgetShowLock.Lock()
	defer signalWidgetShowLock.Unlock()

	signalWidgetShowId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_show(instance, C.gpointer(uintptr(signalWidgetShowId)))

	detail := signalWidgetShowDetail{callback, handlerID}
	signalWidgetShowMap[signalWidgetShowId] = detail

	return signalWidgetShowId
}

/*
DisconnectShow disconnects a callback from the 'show' signal for the Widget.

The connectionID should be a value returned from a call to ConnectShow.
*/
func (recv *Widget) DisconnectShow(connectionID int) {
	signalWidgetShowLock.Lock()
	defer signalWidgetShowLock.Unlock()

	detail, exists := signalWidgetShowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetShowMap, connectionID)
}

//export widget_showHandler
func widget_showHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetShowMap[index].callback
	callback()
}

// Unsupported signal 'show-help' for Widget : unsupported parameter help_type : type WidgetHelpType :

// Unsupported signal 'size-allocate' for Widget : unsupported parameter allocation : type Allocation : Blacklisted record : GdkRectangle

// Unsupported signal 'state-changed' for Widget : unsupported parameter state : type StateType :

type signalWidgetStyleSetDetail struct {
	callback  WidgetSignalStyleSetCallback
	handlerID C.gulong
}

var signalWidgetStyleSetId int
var signalWidgetStyleSetMap = make(map[int]signalWidgetStyleSetDetail)
var signalWidgetStyleSetLock sync.Mutex

// WidgetSignalStyleSetCallback is a callback function for a 'style-set' signal emitted from a Widget.
type WidgetSignalStyleSetCallback func(previousStyle *Style)

/*
ConnectStyleSet connects the callback to the 'style-set' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectStyleSet to remove it.
*/
func (recv *Widget) ConnectStyleSet(callback WidgetSignalStyleSetCallback) int {
	signalWidgetStyleSetLock.Lock()
	defer signalWidgetStyleSetLock.Unlock()

	signalWidgetStyleSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_style_set(instance, C.gpointer(uintptr(signalWidgetStyleSetId)))

	detail := signalWidgetStyleSetDetail{callback, handlerID}
	signalWidgetStyleSetMap[signalWidgetStyleSetId] = detail

	return signalWidgetStyleSetId
}

/*
DisconnectStyleSet disconnects a callback from the 'style-set' signal for the Widget.

The connectionID should be a value returned from a call to ConnectStyleSet.
*/
func (recv *Widget) DisconnectStyleSet(connectionID int) {
	signalWidgetStyleSetLock.Lock()
	defer signalWidgetStyleSetLock.Unlock()

	detail, exists := signalWidgetStyleSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetStyleSetMap, connectionID)
}

//export widget_styleSetHandler
func widget_styleSetHandler(_ *C.GObject, c_previous_style *C.GtkStyle, data C.gpointer) {
	previousStyle := StyleNewFromC(unsafe.Pointer(c_previous_style))

	index := int(uintptr(data))
	callback := signalWidgetStyleSetMap[index].callback
	callback(previousStyle)
}

// Unsupported signal 'touch-event' for Widget : unsupported parameter object : no type generator for Gdk.Event,

type signalWidgetUnmapDetail struct {
	callback  WidgetSignalUnmapCallback
	handlerID C.gulong
}

var signalWidgetUnmapId int
var signalWidgetUnmapMap = make(map[int]signalWidgetUnmapDetail)
var signalWidgetUnmapLock sync.Mutex

// WidgetSignalUnmapCallback is a callback function for a 'unmap' signal emitted from a Widget.
type WidgetSignalUnmapCallback func()

/*
ConnectUnmap connects the callback to the 'unmap' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnmap to remove it.
*/
func (recv *Widget) ConnectUnmap(callback WidgetSignalUnmapCallback) int {
	signalWidgetUnmapLock.Lock()
	defer signalWidgetUnmapLock.Unlock()

	signalWidgetUnmapId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unmap(instance, C.gpointer(uintptr(signalWidgetUnmapId)))

	detail := signalWidgetUnmapDetail{callback, handlerID}
	signalWidgetUnmapMap[signalWidgetUnmapId] = detail

	return signalWidgetUnmapId
}

/*
DisconnectUnmap disconnects a callback from the 'unmap' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnmap.
*/
func (recv *Widget) DisconnectUnmap(connectionID int) {
	signalWidgetUnmapLock.Lock()
	defer signalWidgetUnmapLock.Unlock()

	detail, exists := signalWidgetUnmapMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnmapMap, connectionID)
}

//export widget_unmapHandler
func widget_unmapHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetUnmapMap[index].callback
	callback()
}

type signalWidgetUnmapEventDetail struct {
	callback  WidgetSignalUnmapEventCallback
	handlerID C.gulong
}

var signalWidgetUnmapEventId int
var signalWidgetUnmapEventMap = make(map[int]signalWidgetUnmapEventDetail)
var signalWidgetUnmapEventLock sync.Mutex

// WidgetSignalUnmapEventCallback is a callback function for a 'unmap-event' signal emitted from a Widget.
type WidgetSignalUnmapEventCallback func(event *gdk.EventAny) bool

/*
ConnectUnmapEvent connects the callback to the 'unmap-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnmapEvent to remove it.
*/
func (recv *Widget) ConnectUnmapEvent(callback WidgetSignalUnmapEventCallback) int {
	signalWidgetUnmapEventLock.Lock()
	defer signalWidgetUnmapEventLock.Unlock()

	signalWidgetUnmapEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unmap_event(instance, C.gpointer(uintptr(signalWidgetUnmapEventId)))

	detail := signalWidgetUnmapEventDetail{callback, handlerID}
	signalWidgetUnmapEventMap[signalWidgetUnmapEventId] = detail

	return signalWidgetUnmapEventId
}

/*
DisconnectUnmapEvent disconnects a callback from the 'unmap-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnmapEvent.
*/
func (recv *Widget) DisconnectUnmapEvent(connectionID int) {
	signalWidgetUnmapEventLock.Lock()
	defer signalWidgetUnmapEventLock.Unlock()

	detail, exists := signalWidgetUnmapEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnmapEventMap, connectionID)
}

//export widget_unmapEventHandler
func widget_unmapEventHandler(_ *C.GObject, c_event *C.GdkEventAny, data C.gpointer) C.gboolean {
	event := gdk.EventAnyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetUnmapEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetUnrealizeDetail struct {
	callback  WidgetSignalUnrealizeCallback
	handlerID C.gulong
}

var signalWidgetUnrealizeId int
var signalWidgetUnrealizeMap = make(map[int]signalWidgetUnrealizeDetail)
var signalWidgetUnrealizeLock sync.Mutex

// WidgetSignalUnrealizeCallback is a callback function for a 'unrealize' signal emitted from a Widget.
type WidgetSignalUnrealizeCallback func()

/*
ConnectUnrealize connects the callback to the 'unrealize' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnrealize to remove it.
*/
func (recv *Widget) ConnectUnrealize(callback WidgetSignalUnrealizeCallback) int {
	signalWidgetUnrealizeLock.Lock()
	defer signalWidgetUnrealizeLock.Unlock()

	signalWidgetUnrealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unrealize(instance, C.gpointer(uintptr(signalWidgetUnrealizeId)))

	detail := signalWidgetUnrealizeDetail{callback, handlerID}
	signalWidgetUnrealizeMap[signalWidgetUnrealizeId] = detail

	return signalWidgetUnrealizeId
}

/*
DisconnectUnrealize disconnects a callback from the 'unrealize' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnrealize.
*/
func (recv *Widget) DisconnectUnrealize(connectionID int) {
	signalWidgetUnrealizeLock.Lock()
	defer signalWidgetUnrealizeLock.Unlock()

	detail, exists := signalWidgetUnrealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnrealizeMap, connectionID)
}

//export widget_unrealizeHandler
func widget_unrealizeHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWidgetUnrealizeMap[index].callback
	callback()
}

type signalWidgetVisibilityNotifyEventDetail struct {
	callback  WidgetSignalVisibilityNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetVisibilityNotifyEventId int
var signalWidgetVisibilityNotifyEventMap = make(map[int]signalWidgetVisibilityNotifyEventDetail)
var signalWidgetVisibilityNotifyEventLock sync.Mutex

// WidgetSignalVisibilityNotifyEventCallback is a callback function for a 'visibility-notify-event' signal emitted from a Widget.
type WidgetSignalVisibilityNotifyEventCallback func(event *gdk.EventVisibility) bool

/*
ConnectVisibilityNotifyEvent connects the callback to the 'visibility-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectVisibilityNotifyEvent to remove it.
*/
func (recv *Widget) ConnectVisibilityNotifyEvent(callback WidgetSignalVisibilityNotifyEventCallback) int {
	signalWidgetVisibilityNotifyEventLock.Lock()
	defer signalWidgetVisibilityNotifyEventLock.Unlock()

	signalWidgetVisibilityNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_visibility_notify_event(instance, C.gpointer(uintptr(signalWidgetVisibilityNotifyEventId)))

	detail := signalWidgetVisibilityNotifyEventDetail{callback, handlerID}
	signalWidgetVisibilityNotifyEventMap[signalWidgetVisibilityNotifyEventId] = detail

	return signalWidgetVisibilityNotifyEventId
}

/*
DisconnectVisibilityNotifyEvent disconnects a callback from the 'visibility-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectVisibilityNotifyEvent.
*/
func (recv *Widget) DisconnectVisibilityNotifyEvent(connectionID int) {
	signalWidgetVisibilityNotifyEventLock.Lock()
	defer signalWidgetVisibilityNotifyEventLock.Unlock()

	detail, exists := signalWidgetVisibilityNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetVisibilityNotifyEventMap, connectionID)
}

//export widget_visibilityNotifyEventHandler
func widget_visibilityNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventVisibility, data C.gpointer) C.gboolean {
	event := gdk.EventVisibilityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetVisibilityNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetWindowStateEventDetail struct {
	callback  WidgetSignalWindowStateEventCallback
	handlerID C.gulong
}

var signalWidgetWindowStateEventId int
var signalWidgetWindowStateEventMap = make(map[int]signalWidgetWindowStateEventDetail)
var signalWidgetWindowStateEventLock sync.Mutex

// WidgetSignalWindowStateEventCallback is a callback function for a 'window-state-event' signal emitted from a Widget.
type WidgetSignalWindowStateEventCallback func(event *gdk.EventWindowState) bool

/*
ConnectWindowStateEvent connects the callback to the 'window-state-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectWindowStateEvent to remove it.
*/
func (recv *Widget) ConnectWindowStateEvent(callback WidgetSignalWindowStateEventCallback) int {
	signalWidgetWindowStateEventLock.Lock()
	defer signalWidgetWindowStateEventLock.Unlock()

	signalWidgetWindowStateEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_window_state_event(instance, C.gpointer(uintptr(signalWidgetWindowStateEventId)))

	detail := signalWidgetWindowStateEventDetail{callback, handlerID}
	signalWidgetWindowStateEventMap[signalWidgetWindowStateEventId] = detail

	return signalWidgetWindowStateEventId
}

/*
DisconnectWindowStateEvent disconnects a callback from the 'window-state-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectWindowStateEvent.
*/
func (recv *Widget) DisconnectWindowStateEvent(connectionID int) {
	signalWidgetWindowStateEventLock.Lock()
	defer signalWidgetWindowStateEventLock.Unlock()

	detail, exists := signalWidgetWindowStateEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetWindowStateEventMap, connectionID)
}

//export widget_windowStateEventHandler
func widget_windowStateEventHandler(_ *C.GObject, c_event *C.GdkEventWindowState, data C.gpointer) C.gboolean {
	event := gdk.EventWindowStateNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetWindowStateEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported : gtk_widget_new : unsupported parameter ... : varargs

// For widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them. Activation is what happens when you
// press Enter on a widget during key navigation. If @widget isn't
// activatable, the function returns %FALSE.
/*

C function : gtk_widget_activate
*/
func (recv *Widget) Activate() bool {
	retC := C.gtk_widget_activate((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Installs an accelerator for this @widget in @accel_group that causes
// @accel_signal to be emitted if the accelerator is activated.
// The @accel_group needs to be added to the widget’s toplevel via
// gtk_window_add_accel_group(), and the signal must be of type %G_SIGNAL_ACTION.
// Accelerators added through this function are not user changeable during
// runtime. If you want to support accelerators that can be changed by the
// user, use gtk_accel_map_add_entry() and gtk_widget_set_accel_path() or
// gtk_menu_item_set_accel_path() instead.
/*

C function : gtk_widget_add_accelerator
*/
func (recv *Widget) AddAccelerator(accelSignal string, accelGroup *AccelGroup, accelKey uint32, accelMods gdk.ModifierType, accelFlags AccelFlags) {
	c_accel_signal := C.CString(accelSignal)
	defer C.free(unsafe.Pointer(c_accel_signal))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	c_accel_flags := (C.GtkAccelFlags)(accelFlags)

	C.gtk_widget_add_accelerator((*C.GtkWidget)(recv.native), c_accel_signal, c_accel_group, c_accel_key, c_accel_mods, c_accel_flags)

	return
}

// Adds the events in the bitfield @events to the event mask for
// @widget. See gtk_widget_set_events() and the
// [input handling overview][event-masks] for details.
/*

C function : gtk_widget_add_events
*/
func (recv *Widget) AddEvents(events int32) {
	c_events := (C.gint)(events)

	C.gtk_widget_add_events((*C.GtkWidget)(recv.native), c_events)

	return
}

// This function is used by custom widget implementations; if you're
// writing an app, you’d use gtk_widget_grab_focus() to move the focus
// to a particular widget, and gtk_container_set_focus_chain() to
// change the focus tab order. So you may want to investigate those
// functions instead.
//
// gtk_widget_child_focus() is called by containers as the user moves
// around the window using keyboard shortcuts. @direction indicates
// what kind of motion is taking place (up, down, left, right, tab
// forward, tab backward). gtk_widget_child_focus() emits the
// #GtkWidget::focus signal; widgets override the default handler
// for this signal in order to implement appropriate focus behavior.
//
// The default ::focus handler for a widget should return %TRUE if
// moving in @direction left the focus on a focusable location inside
// that widget, and %FALSE if moving in @direction moved the focus
// outside the widget. If returning %TRUE, widgets normally
// call gtk_widget_grab_focus() to place the focus accordingly;
// if returning %FALSE, they don’t modify the current focus location.
/*

C function : gtk_widget_child_focus
*/
func (recv *Widget) ChildFocus(direction DirectionType) bool {
	c_direction := (C.GtkDirectionType)(direction)

	retC := C.gtk_widget_child_focus((*C.GtkWidget)(recv.native), c_direction)
	retGo := retC == C.TRUE

	return retGo
}

// Emits a #GtkWidget::child-notify signal for the
// [child property][child-properties] @child_property
// on @widget.
//
// This is the analogue of g_object_notify() for child properties.
//
// Also see gtk_container_child_notify().
/*

C function : gtk_widget_child_notify
*/
func (recv *Widget) ChildNotify(childProperty string) {
	c_child_property := C.CString(childProperty)
	defer C.free(unsafe.Pointer(c_child_property))

	C.gtk_widget_child_notify((*C.GtkWidget)(recv.native), c_child_property)

	return
}

// Same as gtk_widget_path(), but always uses the name of a widget’s type,
// never uses a custom name set with gtk_widget_set_name().
/*

C function : gtk_widget_class_path
*/
func (recv *Widget) ClassPath() (uint32, string, string) {
	var c_path_length C.guint

	var c_path *C.gchar

	var c_path_reversed *C.gchar

	C.gtk_widget_class_path((*C.GtkWidget)(recv.native), &c_path_length, &c_path, &c_path_reversed)

	pathLength := (uint32)(c_path_length)

	path := C.GoString(c_path)
	defer C.free(unsafe.Pointer(c_path))

	pathReversed := C.GoString(c_path_reversed)
	defer C.free(unsafe.Pointer(c_path_reversed))

	return pathLength, path, pathReversed
}

// Computes whether a container should give this widget extra space
// when possible. Containers should check this, rather than
// looking at gtk_widget_get_hexpand() or gtk_widget_get_vexpand().
//
// This function already checks whether the widget is visible, so
// visibility does not need to be checked separately. Non-visible
// widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly
// set on the widget itself, or, if none has been explicitly set,
// the widget may expand if some of its children do.
/*

C function : gtk_widget_compute_expand
*/
func (recv *Widget) ComputeExpand(orientation Orientation) bool {
	c_orientation := (C.GtkOrientation)(orientation)

	retC := C.gtk_widget_compute_expand((*C.GtkWidget)(recv.native), c_orientation)
	retGo := retC == C.TRUE

	return retGo
}

// Creates a new #PangoContext with the appropriate font map,
// font options, font description, and base direction for drawing
// text for this widget. See also gtk_widget_get_pango_context().
/*

C function : gtk_widget_create_pango_context
*/
func (recv *Widget) CreatePangoContext() *pango.Context {
	retC := C.gtk_widget_create_pango_context((*C.GtkWidget)(recv.native))
	retGo := pango.ContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Creates a new #PangoLayout with the appropriate font map,
// font description, and base direction for drawing text for
// this widget.
//
// If you keep a #PangoLayout created in this way around, you need
// to re-create it when the widget #PangoContext is replaced.
// This can be tracked by using the #GtkWidget::screen-changed signal
// on the widget.
/*

C function : gtk_widget_create_pango_layout
*/
func (recv *Widget) CreatePangoLayout(text string) *pango.Layout {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	retC := C.gtk_widget_create_pango_layout((*C.GtkWidget)(recv.native), c_text)
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Destroys a widget.
//
// When a widget is destroyed all references it holds on other objects
// will be released:
//
// - if the widget is inside a container, it will be removed from its
// parent
// - if the widget is a container, all its children will be destroyed,
// recursively
// - if the widget is a top level, it will be removed from the list
// of top level widgets that GTK+ maintains internally
//
// It's expected that all references held on the widget will also
// be released; you should connect to the #GtkWidget::destroy signal
// if you hold a reference to @widget and you wish to remove it when
// this function is called. It is not necessary to do so if you are
// implementing a #GtkContainer, as you'll be able to use the
// #GtkContainerClass.remove() virtual function for that.
//
// It's important to notice that gtk_widget_destroy() will only cause
// the @widget to be finalized if no additional references, acquired
// using g_object_ref(), are held on it. In case additional references
// are in place, the @widget will be in an "inert" state after calling
// this function; @widget will still point to valid memory, allowing you
// to release the references you hold, but you may not query the widget's
// own state.
//
// You should typically call this function on top level widgets, and
// rarely on child widgets.
//
// See also: gtk_container_remove()
/*

C function : gtk_widget_destroy
*/
func (recv *Widget) Destroy() {
	C.gtk_widget_destroy((*C.GtkWidget)(recv.native))

	return
}

// This function sets *@widget_pointer to %NULL if @widget_pointer !=
// %NULL.  It’s intended to be used as a callback connected to the
// “destroy” signal of a widget. You connect gtk_widget_destroyed()
// as a signal handler, and pass the address of your widget variable
// as user data. Then when the widget is destroyed, the variable will
// be set to %NULL. Useful for example to avoid multiple copies
// of the same dialog.
/*

C function : gtk_widget_destroyed
*/
func (recv *Widget) Destroyed(widgetPointer *Widget) {
	c_widget_pointer := (**C.GtkWidget)(C.NULL)
	if widgetPointer != nil {
		c_widget_pointer = (**C.GtkWidget)(widgetPointer.ToC())
	}

	C.gtk_widget_destroyed((*C.GtkWidget)(recv.native), c_widget_pointer)

	return
}

// Unsupported : gtk_drag_begin : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Checks to see if a mouse drag starting at (@start_x, @start_y) and ending
// at (@current_x, @current_y) has passed the GTK+ drag threshold, and thus
// should trigger the beginning of a drag-and-drop operation.
/*

C function : gtk_drag_check_threshold
*/
func (recv *Widget) DragCheckThreshold(startX int32, startY int32, currentX int32, currentY int32) bool {
	c_start_x := (C.gint)(startX)

	c_start_y := (C.gint)(startY)

	c_current_x := (C.gint)(currentX)

	c_current_y := (C.gint)(currentY)

	retC := C.gtk_drag_check_threshold((*C.GtkWidget)(recv.native), c_start_x, c_start_y, c_current_x, c_current_y)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_drag_dest_find_target : return type : Blacklisted record : GdkAtom

// Returns the list of targets this widget can accept from
// drag-and-drop.
/*

C function : gtk_drag_dest_get_target_list
*/
func (recv *Widget) DragDestGetTargetList() *TargetList {
	retC := C.gtk_drag_dest_get_target_list((*C.GtkWidget)(recv.native))
	var retGo (*TargetList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TargetListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_drag_dest_set : unsupported parameter targets :

// Sets this widget as a proxy for drops to another window.
/*

C function : gtk_drag_dest_set_proxy
*/
func (recv *Widget) DragDestSetProxy(proxyWindow *gdk.Window, protocol gdk.DragProtocol, useCoordinates bool) {
	c_proxy_window := (*C.GdkWindow)(C.NULL)
	if proxyWindow != nil {
		c_proxy_window = (*C.GdkWindow)(proxyWindow.ToC())
	}

	c_protocol := (C.GdkDragProtocol)(protocol)

	c_use_coordinates :=
		boolToGboolean(useCoordinates)

	C.gtk_drag_dest_set_proxy((*C.GtkWidget)(recv.native), c_proxy_window, c_protocol, c_use_coordinates)

	return
}

// Sets the target types that this widget can accept from drag-and-drop.
// The widget must first be made into a drag destination with
// gtk_drag_dest_set().
/*

C function : gtk_drag_dest_set_target_list
*/
func (recv *Widget) DragDestSetTargetList(targetList *TargetList) {
	c_target_list := (*C.GtkTargetList)(C.NULL)
	if targetList != nil {
		c_target_list = (*C.GtkTargetList)(targetList.ToC())
	}

	C.gtk_drag_dest_set_target_list((*C.GtkWidget)(recv.native), c_target_list)

	return
}

// Clears information about a drop destination set with
// gtk_drag_dest_set(). The widget will no longer receive
// notification of drags.
/*

C function : gtk_drag_dest_unset
*/
func (recv *Widget) DragDestUnset() {
	C.gtk_drag_dest_unset((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_drag_get_data : unsupported parameter target : Blacklisted record : GdkAtom

// Highlights a widget as a currently hovered drop target.
// To end the highlight, call gtk_drag_unhighlight().
// GTK+ calls this automatically if %GTK_DEST_DEFAULT_HIGHLIGHT is set.
/*

C function : gtk_drag_highlight
*/
func (recv *Widget) DragHighlight() {
	C.gtk_drag_highlight((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_drag_source_set : unsupported parameter targets :

// Sets the icon that will be used for drags from a particular widget
// from a #GdkPixbuf. GTK+ retains a reference for @pixbuf and will
// release it when it is no longer needed.
/*

C function : gtk_drag_source_set_icon_pixbuf
*/
func (recv *Widget) DragSourceSetIconPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_drag_source_set_icon_pixbuf((*C.GtkWidget)(recv.native), c_pixbuf)

	return
}

// Sets the icon that will be used for drags from a particular source
// to a stock icon.
/*

C function : gtk_drag_source_set_icon_stock
*/
func (recv *Widget) DragSourceSetIconStock(stockId string) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	C.gtk_drag_source_set_icon_stock((*C.GtkWidget)(recv.native), c_stock_id)

	return
}

// Undoes the effects of gtk_drag_source_set().
/*

C function : gtk_drag_source_unset
*/
func (recv *Widget) DragSourceUnset() {
	C.gtk_drag_source_unset((*C.GtkWidget)(recv.native))

	return
}

// Removes a highlight set by gtk_drag_highlight() from
// a widget.
/*

C function : gtk_drag_unhighlight
*/
func (recv *Widget) DragUnhighlight() {
	C.gtk_drag_unhighlight((*C.GtkWidget)(recv.native))

	return
}

// Ensures that @widget has a style (@widget->style).
//
// Not a very useful function; most of the time, if you
// want the style, the widget is realized, and realized
// widgets are guaranteed to have a style already.
/*

C function : gtk_widget_ensure_style
*/
func (recv *Widget) EnsureStyle() {
	C.gtk_widget_ensure_style((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_widget_event : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Stops emission of #GtkWidget::child-notify signals on @widget. The
// signals are queued until gtk_widget_thaw_child_notify() is called
// on @widget.
//
// This is the analogue of g_object_freeze_notify() for child properties.
/*

C function : gtk_widget_freeze_child_notify
*/
func (recv *Widget) FreezeChildNotify() {
	C.gtk_widget_freeze_child_notify((*C.GtkWidget)(recv.native))

	return
}

// Returns the accessible object that describes the widget to an
// assistive technology.
//
// If accessibility support is not available, this #AtkObject
// instance may be a no-op. Likewise, if no class-specific #AtkObject
// implementation is available for the widget instance in question,
// it will inherit an #AtkObject implementation from the first ancestor
// class for which such an implementation is defined.
//
// The documentation of the
// [ATK](http://developer.gnome.org/atk/stable/)
// library contains more information about accessible objects and their uses.
/*

C function : gtk_widget_get_accessible
*/
func (recv *Widget) GetAccessible() *atk.Object {
	retC := C.gtk_widget_get_accessible((*C.GtkWidget)(recv.native))
	retGo := atk.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the height that has currently been allocated to @widget.
// This function is intended to be used when implementing handlers
// for the #GtkWidget::draw function.
/*

C function : gtk_widget_get_allocated_height
*/
func (recv *Widget) GetAllocatedHeight() int32 {
	retC := C.gtk_widget_get_allocated_height((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Returns the width that has currently been allocated to @widget.
// This function is intended to be used when implementing handlers
// for the #GtkWidget::draw function.
/*

C function : gtk_widget_get_allocated_width
*/
func (recv *Widget) GetAllocatedWidth() int32 {
	retC := C.gtk_widget_get_allocated_width((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the first ancestor of @widget with type @widget_type. For example,
// `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets
// the first #GtkBox that’s an ancestor of @widget. No reference will be
// added to the returned widget; it should not be unreferenced. See note
// about checking for a toplevel #GtkWindow in the docs for
// gtk_widget_get_toplevel().
//
// Note that unlike gtk_widget_is_ancestor(), gtk_widget_get_ancestor()
// considers @widget to be an ancestor of itself.
/*

C function : gtk_widget_get_ancestor
*/
func (recv *Widget) GetAncestor(widgetType gobject.Type) *Widget {
	c_widget_type := (C.GType)(widgetType)

	retC := C.gtk_widget_get_ancestor((*C.GtkWidget)(recv.native), c_widget_type)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// This function is only for use in widget implementations. Obtains
// @widget->requisition, unless someone has forced a particular
// geometry on the widget (e.g. with gtk_widget_set_size_request()),
// in which case it returns that geometry instead of the widget's
// requisition.
//
// This function differs from gtk_widget_size_request() in that
// it retrieves the last size request value from @widget->requisition,
// while gtk_widget_size_request() actually calls the "size_request" method
// on @widget to compute the size request and fill in @widget->requisition,
// and only then returns @widget->requisition.
//
// Because this function does not call the “size_request” method, it
// can only be used when you know that @widget->requisition is
// up-to-date, that is, gtk_widget_size_request() has been called
// since the last time a resize was queued. In general, only container
// implementations have this information; applications should use
// gtk_widget_size_request().
/*

C function : gtk_widget_get_child_requisition
*/
func (recv *Widget) GetChildRequisition() *Requisition {
	var c_requisition C.GtkRequisition

	C.gtk_widget_get_child_requisition((*C.GtkWidget)(recv.native), &c_requisition)

	requisition := RequisitionNewFromC(unsafe.Pointer(&c_requisition))

	return requisition
}

// Gets the value set with gtk_widget_set_child_visible().
// If you feel a need to use this function, your code probably
// needs reorganization.
//
// This function is only useful for container implementations and
// never should be called by an application.
/*

C function : gtk_widget_get_child_visible
*/
func (recv *Widget) GetChildVisible() bool {
	retC := C.gtk_widget_get_child_visible((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Obtains the composite name of a widget.
/*

C function : gtk_widget_get_composite_name
*/
func (recv *Widget) GetCompositeName() string {
	retC := C.gtk_widget_get_composite_name((*C.GtkWidget)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Gets the reading direction for a particular widget. See
// gtk_widget_set_direction().
/*

C function : gtk_widget_get_direction
*/
func (recv *Widget) GetDirection() TextDirection {
	retC := C.gtk_widget_get_direction((*C.GtkWidget)(recv.native))
	retGo := (TextDirection)(retC)

	return retGo
}

// Returns the event mask (see #GdkEventMask) for the widget. These are the
// events that the widget will receive.
//
// Note: Internally, the widget event mask will be the logical OR of the event
// mask set through gtk_widget_set_events() or gtk_widget_add_events(), and the
// event mask necessary to cater for every #GtkEventController created for the
// widget.
/*

C function : gtk_widget_get_events
*/
func (recv *Widget) GetEvents() int32 {
	retC := C.gtk_widget_get_events((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Gets the value of the #GtkWidget:halign property.
//
// For backwards compatibility reasons this method will never return
// %GTK_ALIGN_BASELINE, but instead it will convert it to
// %GTK_ALIGN_FILL. Baselines are not supported for horizontal
// alignment.
/*

C function : gtk_widget_get_halign
*/
func (recv *Widget) GetHalign() Align {
	retC := C.gtk_widget_get_halign((*C.GtkWidget)(recv.native))
	retGo := (Align)(retC)

	return retGo
}

// Gets whether the widget would like any available extra horizontal
// space. When a user resizes a #GtkWindow, widgets with expand=TRUE
// generally receive the extra space. For example, a list or
// scrollable area or document in your window would often be set to
// expand.
//
// Containers should use gtk_widget_compute_expand() rather than
// this function, to see whether a widget, or any of its children,
// has the expand flag set. If any child of a widget wants to
// expand, the parent may ask to expand also.
//
// This function only looks at the widget’s own hexpand flag, rather
// than computing whether the entire widget tree rooted at this widget
// wants to expand.
/*

C function : gtk_widget_get_hexpand
*/
func (recv *Widget) GetHexpand() bool {
	retC := C.gtk_widget_get_hexpand((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets whether gtk_widget_set_hexpand() has been used to
// explicitly set the expand flag on this widget.
//
// If hexpand is set, then it overrides any computed
// expand value based on child widgets. If hexpand is not
// set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here
// for completeness and consistency.
/*

C function : gtk_widget_get_hexpand_set
*/
func (recv *Widget) GetHexpandSet() bool {
	retC := C.gtk_widget_get_hexpand_set((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the current modifier style for the widget. (As set by
// gtk_widget_modify_style().) If no style has previously set, a new
// #GtkRcStyle will be created with all values unset, and set as the
// modifier style for the widget. If you make changes to this rc
// style, you must call gtk_widget_modify_style(), passing in the
// returned rc style, to make sure that your changes take effect.
//
// Caution: passing the style back to gtk_widget_modify_style() will
// normally end up destroying it, because gtk_widget_modify_style() copies
// the passed-in style and sets the copy as the new modifier style,
// thus dropping any reference to the old modifier style. Add a reference
// to the modifier style if you want to keep it alive.
/*

C function : gtk_widget_get_modifier_style
*/
func (recv *Widget) GetModifierStyle() *RcStyle {
	retC := C.gtk_widget_get_modifier_style((*C.GtkWidget)(recv.native))
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Retrieves the name of a widget. See gtk_widget_set_name() for the
// significance of widget names.
/*

C function : gtk_widget_get_name
*/
func (recv *Widget) GetName() string {
	retC := C.gtk_widget_get_name((*C.GtkWidget)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Gets a #PangoContext with the appropriate font map, font description,
// and base direction for this widget. Unlike the context returned
// by gtk_widget_create_pango_context(), this context is owned by
// the widget (it can be used until the screen for the widget changes
// or the widget is removed from its toplevel), and will be updated to
// match any changes to the widget’s attributes. This can be tracked
// by using the #GtkWidget::screen-changed signal on the widget.
/*

C function : gtk_widget_get_pango_context
*/
func (recv *Widget) GetPangoContext() *pango.Context {
	retC := C.gtk_widget_get_pango_context((*C.GtkWidget)(recv.native))
	retGo := pango.ContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the parent container of @widget.
/*

C function : gtk_widget_get_parent
*/
func (recv *Widget) GetParent() *Widget {
	retC := C.gtk_widget_get_parent((*C.GtkWidget)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets @widget’s parent window, or %NULL if it does not have one.
/*

C function : gtk_widget_get_parent_window
*/
func (recv *Widget) GetParentWindow() *gdk.Window {
	retC := C.gtk_widget_get_parent_window((*C.GtkWidget)(recv.native))
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Returns the #GtkWidgetPath representing @widget, if the widget
// is not connected to a toplevel widget, a partial path will be
// created.
/*

C function : gtk_widget_get_path
*/
func (recv *Widget) GetPath() *WidgetPath {
	retC := C.gtk_widget_get_path((*C.GtkWidget)(recv.native))
	retGo := WidgetPathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Obtains the location of the mouse pointer in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are
// defined as @widget->window coordinates for widgets that return %TRUE for
// gtk_widget_get_has_window(); and are relative to @widget->allocation.x,
// @widget->allocation.y otherwise.
/*

C function : gtk_widget_get_pointer
*/
func (recv *Widget) GetPointer() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_widget_get_pointer((*C.GtkWidget)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// Gets the settings object holding the settings used for this widget.
//
// Note that this function can only be called when the #GtkWidget
// is attached to a toplevel, since the settings object is specific
// to a particular #GdkScreen.
/*

C function : gtk_widget_get_settings
*/
func (recv *Widget) GetSettings() *Settings {
	retC := C.gtk_widget_get_settings((*C.GtkWidget)(recv.native))
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the size request that was explicitly set for the widget using
// gtk_widget_set_size_request(). A value of -1 stored in @width or
// @height indicates that that dimension has not been set explicitly
// and the natural requisition of the widget will be used instead. See
// gtk_widget_set_size_request(). To get the size a widget will
// actually request, call gtk_widget_get_preferred_size() instead of
// this function.
/*

C function : gtk_widget_get_size_request
*/
func (recv *Widget) GetSizeRequest() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_widget_get_size_request((*C.GtkWidget)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// Simply an accessor function that returns @widget->style.
/*

C function : gtk_widget_get_style
*/
func (recv *Widget) GetStyle() *Style {
	retC := C.gtk_widget_get_style((*C.GtkWidget)(recv.native))
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the style context associated to @widget. The returned object is
// guaranteed to be the same for the lifetime of @widget.
/*

C function : gtk_widget_get_style_context
*/
func (recv *Widget) GetStyleContext() *StyleContext {
	retC := C.gtk_widget_get_style_context((*C.GtkWidget)(recv.native))
	retGo := StyleContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns %TRUE if @widget is multiple pointer aware. See
// gtk_widget_set_support_multidevice() for more information.
/*

C function : gtk_widget_get_support_multidevice
*/
func (recv *Widget) GetSupportMultidevice() bool {
	retC := C.gtk_widget_get_support_multidevice((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Fetch an object build from the template XML for @widget_type in this @widget instance.
//
// This will only report children which were previously declared with
// gtk_widget_class_bind_template_child_full() or one of its
// variants.
//
// This function is only meant to be called for code which is private to the @widget_type which
// declared the child and is meant for language bindings which cannot easily make use
// of the GObject structure offsets.
/*

C function : gtk_widget_get_template_child
*/
func (recv *Widget) GetTemplateChild(widgetType gobject.Type, name string) *gobject.Object {
	c_widget_type := (C.GType)(widgetType)

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_widget_get_template_child((*C.GtkWidget)(recv.native), c_widget_type, c_name)
	retGo := gobject.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This function returns the topmost widget in the container hierarchy
// @widget is a part of. If @widget has no parent widgets, it will be
// returned as the topmost widget. No reference will be added to the
// returned widget; it should not be unreferenced.
//
// Note the difference in behavior vs. gtk_widget_get_ancestor();
// `gtk_widget_get_ancestor (widget, GTK_TYPE_WINDOW)`
// would return
// %NULL if @widget wasn’t inside a toplevel window, and if the
// window was inside a #GtkWindow-derived widget which was in turn
// inside the toplevel #GtkWindow. While the second case may
// seem unlikely, it actually happens when a #GtkPlug is embedded
// inside a #GtkSocket within the same application.
//
// To reliably find the toplevel #GtkWindow, use
// gtk_widget_get_toplevel() and call GTK_IS_WINDOW()
// on the result. For instance, to get the title of a widget's toplevel
// window, one might use:
// |[<!-- language="C" -->
// static const char *
// get_widget_toplevel_title (GtkWidget *widget)
// {
// GtkWidget *toplevel = gtk_widget_get_toplevel (widget);
// if (GTK_IS_WINDOW (toplevel))
// {
// return gtk_window_get_title (GTK_WINDOW (toplevel));
// }
//
// return NULL;
// }
// ]|
/*

C function : gtk_widget_get_toplevel
*/
func (recv *Widget) GetToplevel() *Widget {
	retC := C.gtk_widget_get_toplevel((*C.GtkWidget)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Gets the value of the #GtkWidget:valign property.
//
// For backwards compatibility reasons this method will never return
// %GTK_ALIGN_BASELINE, but instead it will convert it to
// %GTK_ALIGN_FILL. If your widget want to support baseline aligned
// children it must use gtk_widget_get_valign_with_baseline(), or
// `g_object_get (widget, "valign", &value, NULL)`, which will
// also report the true value.
/*

C function : gtk_widget_get_valign
*/
func (recv *Widget) GetValign() Align {
	retC := C.gtk_widget_get_valign((*C.GtkWidget)(recv.native))
	retGo := (Align)(retC)

	return retGo
}

// Gets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_get_hexpand() for more detail.
/*

C function : gtk_widget_get_vexpand
*/
func (recv *Widget) GetVexpand() bool {
	retC := C.gtk_widget_get_vexpand((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets whether gtk_widget_set_vexpand() has been used to
// explicitly set the expand flag on this widget.
//
// See gtk_widget_get_hexpand_set() for more detail.
/*

C function : gtk_widget_get_vexpand_set
*/
func (recv *Widget) GetVexpandSet() bool {
	retC := C.gtk_widget_get_vexpand_set((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the visual that will be used to render @widget.
/*

C function : gtk_widget_get_visual
*/
func (recv *Widget) GetVisual() *gdk.Visual {
	retC := C.gtk_widget_get_visual((*C.GtkWidget)(recv.native))
	retGo := gdk.VisualNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Makes @widget the current grabbed widget.
//
// This means that interaction with other widgets in the same
// application is blocked and mouse as well as keyboard events
// are delivered to this widget.
//
// If @widget is not sensitive, it is not set as the current
// grabbed widget and this function does nothing.
/*

C function : gtk_grab_add
*/
func (recv *Widget) GrabAdd() {
	C.gtk_grab_add((*C.GtkWidget)(recv.native))

	return
}

// Causes @widget to become the default widget. @widget must be able to be
// a default widget; typically you would ensure this yourself
// by calling gtk_widget_set_can_default() with a %TRUE value.
// The default widget is activated when
// the user presses Enter in a window. Default widgets must be
// activatable, that is, gtk_widget_activate() should affect them. Note
// that #GtkEntry widgets require the “activates-default” property
// set to %TRUE before they activate the default widget when Enter
// is pressed and the #GtkEntry is focused.
/*

C function : gtk_widget_grab_default
*/
func (recv *Widget) GrabDefault() {
	C.gtk_widget_grab_default((*C.GtkWidget)(recv.native))

	return
}

// Causes @widget to have the keyboard focus for the #GtkWindow it's
// inside. @widget must be a focusable widget, such as a #GtkEntry;
// something like #GtkFrame won’t work.
//
// More precisely, it must have the %GTK_CAN_FOCUS flag set. Use
// gtk_widget_set_can_focus() to modify that flag.
//
// The widget also needs to be realized and mapped. This is indicated by the
// related signals. Grabbing the focus immediately after creating the widget
// will likely fail and cause critical warnings.
/*

C function : gtk_widget_grab_focus
*/
func (recv *Widget) GrabFocus() {
	C.gtk_widget_grab_focus((*C.GtkWidget)(recv.native))

	return
}

// Removes the grab from the given widget.
//
// You have to pair calls to gtk_grab_add() and gtk_grab_remove().
//
// If @widget does not have the grab, this function does nothing.
/*

C function : gtk_grab_remove
*/
func (recv *Widget) GrabRemove() {
	C.gtk_grab_remove((*C.GtkWidget)(recv.native))

	return
}

// Reverses the effects of gtk_widget_show(), causing the widget to be
// hidden (invisible to the user).
/*

C function : gtk_widget_hide
*/
func (recv *Widget) Hide() {
	C.gtk_widget_hide((*C.GtkWidget)(recv.native))

	return
}

// Utility function; intended to be connected to the #GtkWidget::delete-event
// signal on a #GtkWindow. The function calls gtk_widget_hide() on its
// argument, then returns %TRUE. If connected to ::delete-event, the
// result is that clicking the close button for a window (on the
// window frame, top right corner usually) will hide but not destroy
// the window. By default, GTK+ destroys windows when ::delete-event
// is received.
/*

C function : gtk_widget_hide_on_delete
*/
func (recv *Widget) HideOnDelete() bool {
	retC := C.gtk_widget_hide_on_delete((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns whether the widget is currently being destroyed.
// This information can sometimes be used to avoid doing
// unnecessary work.
/*

C function : gtk_widget_in_destruction
*/
func (recv *Widget) InDestruction() bool {
	retC := C.gtk_widget_in_destruction((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_widget_intersect : unsupported parameter area : Blacklisted record : GdkRectangle

// Determines whether @widget is somewhere inside @ancestor, possibly with
// intermediate containers.
/*

C function : gtk_widget_is_ancestor
*/
func (recv *Widget) IsAncestor(ancestor *Widget) bool {
	c_ancestor := (*C.GtkWidget)(C.NULL)
	if ancestor != nil {
		c_ancestor = (*C.GtkWidget)(ancestor.ToC())
	}

	retC := C.gtk_widget_is_ancestor((*C.GtkWidget)(recv.native), c_ancestor)
	retGo := retC == C.TRUE

	return retGo
}

// Determines if the widget is the focus widget within its
// toplevel. (This does not mean that the #GtkWidget:has-focus property is
// necessarily set; #GtkWidget:has-focus will only be set if the
// toplevel widget additionally has the global input focus.)
/*

C function : gtk_widget_is_focus
*/
func (recv *Widget) IsFocus() bool {
	retC := C.gtk_widget_is_focus((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Lists the closures used by @widget for accelerator group connections
// with gtk_accel_group_connect_by_path() or gtk_accel_group_connect().
// The closures can be used to monitor accelerator changes on @widget,
// by connecting to the @GtkAccelGroup::accel-changed signal of the
// #GtkAccelGroup of a closure which can be found out with
// gtk_accel_group_from_accel_closure().
/*

C function : gtk_widget_list_accel_closures
*/
func (recv *Widget) ListAccelClosures() *glib.List {
	retC := C.gtk_widget_list_accel_closures((*C.GtkWidget)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// This function is only for use in widget implementations. Causes
// a widget to be mapped if it isn’t already.
/*

C function : gtk_widget_map
*/
func (recv *Widget) Map() {
	C.gtk_widget_map((*C.GtkWidget)(recv.native))

	return
}

// Emits the #GtkWidget::mnemonic-activate signal.
/*

C function : gtk_widget_mnemonic_activate
*/
func (recv *Widget) MnemonicActivate(groupCycling bool) bool {
	c_group_cycling :=
		boolToGboolean(groupCycling)

	retC := C.gtk_widget_mnemonic_activate((*C.GtkWidget)(recv.native), c_group_cycling)
	retGo := retC == C.TRUE

	return retGo
}

// Sets the base color for a widget in a particular state.
// All other style values are left untouched. The base color
// is the background color used along with the text color
// (see gtk_widget_modify_text()) for widgets such as #GtkEntry
// and #GtkTextView. See also gtk_widget_modify_style().
//
// > Note that “no window” widgets (which have the %GTK_NO_WINDOW
// > flag set) draw on their parent container’s window and thus may
// > not draw any background themselves. This is the case for e.g.
// > #GtkLabel.
// >
// > To modify the background of such widgets, you have to set the
// > base color on their parent; if you want to set the background
// > of a rectangular area around a label, try placing the label in
// > a #GtkEventBox widget and setting the base color on that.
/*

C function : gtk_widget_modify_base
*/
func (recv *Widget) ModifyBase(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_base((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Sets the background color for a widget in a particular state.
//
// All other style values are left untouched.
// See also gtk_widget_modify_style().
//
// > Note that “no window” widgets (which have the %GTK_NO_WINDOW
// > flag set) draw on their parent container’s window and thus may
// > not draw any background themselves. This is the case for e.g.
// > #GtkLabel.
// >
// > To modify the background of such widgets, you have to set the
// > background color on their parent; if you want to set the background
// > of a rectangular area around a label, try placing the label in
// > a #GtkEventBox widget and setting the background color on that.
/*

C function : gtk_widget_modify_bg
*/
func (recv *Widget) ModifyBg(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_bg((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Sets the foreground color for a widget in a particular state.
//
// All other style values are left untouched.
// See also gtk_widget_modify_style().
/*

C function : gtk_widget_modify_fg
*/
func (recv *Widget) ModifyFg(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_fg((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Sets the font to use for a widget.
//
// All other style values are left untouched.
// See also gtk_widget_modify_style().
/*

C function : gtk_widget_modify_font
*/
func (recv *Widget) ModifyFont(fontDesc *pango.FontDescription) {
	c_font_desc := (*C.PangoFontDescription)(C.NULL)
	if fontDesc != nil {
		c_font_desc = (*C.PangoFontDescription)(fontDesc.ToC())
	}

	C.gtk_widget_modify_font((*C.GtkWidget)(recv.native), c_font_desc)

	return
}

// Modifies style values on the widget.
//
// Modifications made using this technique take precedence over
// style values set via an RC file, however, they will be overridden
// if a style is explicitly set on the widget using gtk_widget_set_style().
// The #GtkRcStyle-struct is designed so each field can either be
// set or unset, so it is possible, using this function, to modify some
// style values and leave the others unchanged.
//
// Note that modifications made with this function are not cumulative
// with previous calls to gtk_widget_modify_style() or with such
// functions as gtk_widget_modify_fg(). If you wish to retain
// previous values, you must first call gtk_widget_get_modifier_style(),
// make your modifications to the returned style, then call
// gtk_widget_modify_style() with that style. On the other hand,
// if you first call gtk_widget_modify_style(), subsequent calls
// to such functions gtk_widget_modify_fg() will have a cumulative
// effect with the initial modifications.
/*

C function : gtk_widget_modify_style
*/
func (recv *Widget) ModifyStyle(style *RcStyle) {
	c_style := (*C.GtkRcStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkRcStyle)(style.ToC())
	}

	C.gtk_widget_modify_style((*C.GtkWidget)(recv.native), c_style)

	return
}

// Sets the text color for a widget in a particular state.
//
// All other style values are left untouched.
// The text color is the foreground color used along with the
// base color (see gtk_widget_modify_base()) for widgets such
// as #GtkEntry and #GtkTextView.
// See also gtk_widget_modify_style().
/*

C function : gtk_widget_modify_text
*/
func (recv *Widget) ModifyText(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_text((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Obtains the full path to @widget. The path is simply the name of a
// widget and all its parents in the container hierarchy, separated by
// periods. The name of a widget comes from
// gtk_widget_get_name(). Paths are used to apply styles to a widget
// in gtkrc configuration files. Widget names are the type of the
// widget by default (e.g. “GtkButton”) or can be set to an
// application-specific value with gtk_widget_set_name(). By setting
// the name of a widget, you allow users or theme authors to apply
// styles to that specific widget in their gtkrc
// file. @path_reversed_p fills in the path in reverse order,
// i.e. starting with @widget’s name instead of starting with the name
// of @widget’s outermost ancestor.
/*

C function : gtk_widget_path
*/
func (recv *Widget) Path() (uint32, string, string) {
	var c_path_length C.guint

	var c_path *C.gchar

	var c_path_reversed *C.gchar

	C.gtk_widget_path((*C.GtkWidget)(recv.native), &c_path_length, &c_path, &c_path_reversed)

	pathLength := (uint32)(c_path_length)

	path := C.GoString(c_path)
	defer C.free(unsafe.Pointer(c_path))

	pathReversed := C.GoString(c_path_reversed)
	defer C.free(unsafe.Pointer(c_path_reversed))

	return pathLength, path, pathReversed
}

// Mark @widget as needing to recompute its expand flags. Call
// this function when setting legacy expand child properties
// on the child of a container.
//
// See gtk_widget_compute_expand().
/*

C function : gtk_widget_queue_compute_expand
*/
func (recv *Widget) QueueComputeExpand() {
	C.gtk_widget_queue_compute_expand((*C.GtkWidget)(recv.native))

	return
}

// Equivalent to calling gtk_widget_queue_draw_area() for the
// entire area of a widget.
/*

C function : gtk_widget_queue_draw
*/
func (recv *Widget) QueueDraw() {
	C.gtk_widget_queue_draw((*C.GtkWidget)(recv.native))

	return
}

// Convenience function that calls gtk_widget_queue_draw_region() on
// the region created from the given coordinates.
//
// The region here is specified in widget coordinates.
// Widget coordinates are a bit odd; for historical reasons, they are
// defined as @widget->window coordinates for widgets that return %TRUE for
// gtk_widget_get_has_window(), and are relative to @widget->allocation.x,
// @widget->allocation.y otherwise.
//
// @width or @height may be 0, in this case this function does
// nothing. Negative values for @width and @height are not allowed.
/*

C function : gtk_widget_queue_draw_area
*/
func (recv *Widget) QueueDrawArea(x int32, y int32, width int32, height int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_widget_queue_draw_area((*C.GtkWidget)(recv.native), c_x, c_y, c_width, c_height)

	return
}

// This function is only for use in widget implementations.
// Flags a widget to have its size renegotiated; should
// be called when a widget for some reason has a new size request.
// For example, when you change the text in a #GtkLabel, #GtkLabel
// queues a resize to ensure there’s enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget
// from inside its implementation of the GtkWidgetClass::size_allocate
// virtual method. Calls to gtk_widget_queue_resize() from inside
// GtkWidgetClass::size_allocate will be silently ignored.
/*

C function : gtk_widget_queue_resize
*/
func (recv *Widget) QueueResize() {
	C.gtk_widget_queue_resize((*C.GtkWidget)(recv.native))

	return
}

// Creates the GDK (windowing system) resources associated with a
// widget.  For example, @widget->window will be created when a widget
// is realized.  Normally realization happens implicitly; if you show
// a widget and all its parent containers, then the widget will be
// realized and mapped automatically.
//
// Realizing a widget requires all
// the widget’s parent widgets to be realized; calling
// gtk_widget_realize() realizes the widget’s parents in addition to
// @widget itself. If a widget is not yet inside a toplevel window
// when you realize it, bad things will happen.
//
// This function is primarily used in widget implementations, and
// isn’t very useful otherwise. Many times when you think you might
// need it, a better approach is to connect to a signal that will be
// called after the widget is realized automatically, such as
// #GtkWidget::draw. Or simply g_signal_connect () to the
// #GtkWidget::realize signal.
/*

C function : gtk_widget_realize
*/
func (recv *Widget) Realize() {
	C.gtk_widget_realize((*C.GtkWidget)(recv.native))

	return
}

// Computes the intersection of a @widget’s area and @region, returning
// the intersection. The result may be empty, use cairo_region_is_empty() to
// check.
/*

C function : gtk_widget_region_intersect
*/
func (recv *Widget) RegionIntersect(region *cairo.Region) *cairo.Region {
	c_region := (*C.cairo_region_t)(C.NULL)
	if region != nil {
		c_region = (*C.cairo_region_t)(region.ToC())
	}

	retC := C.gtk_widget_region_intersect((*C.GtkWidget)(recv.native), c_region)
	retGo := cairo.RegionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Removes an accelerator from @widget, previously installed with
// gtk_widget_add_accelerator().
/*

C function : gtk_widget_remove_accelerator
*/
func (recv *Widget) RemoveAccelerator(accelGroup *AccelGroup, accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_widget_remove_accelerator((*C.GtkWidget)(recv.native), c_accel_group, c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// A convenience function that uses the theme settings for @widget
// to look up @stock_id and render it to a pixbuf. @stock_id should
// be a stock icon ID such as #GTK_STOCK_OPEN or #GTK_STOCK_OK. @size
// should be a size such as #GTK_ICON_SIZE_MENU. @detail should be a
// string that identifies the widget or code doing the rendering, so
// that theme engines can special-case rendering for that widget or
// code.
//
// The pixels in the returned #GdkPixbuf are shared with the rest of
// the application and should not be modified. The pixbuf should be
// freed after use with g_object_unref().
/*

C function : gtk_widget_render_icon
*/
func (recv *Widget) RenderIcon(stockId string, size IconSize, detail string) *gdkpixbuf.Pixbuf {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	retC := C.gtk_widget_render_icon((*C.GtkWidget)(recv.native), c_stock_id, c_size, c_detail)
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Moves a widget from one #GtkContainer to another, handling reference
// count issues to avoid destroying the widget.
/*

C function : gtk_widget_reparent
*/
func (recv *Widget) Reparent(newParent *Widget) {
	c_new_parent := (*C.GtkWidget)(C.NULL)
	if newParent != nil {
		c_new_parent = (*C.GtkWidget)(newParent.ToC())
	}

	C.gtk_widget_reparent((*C.GtkWidget)(recv.native), c_new_parent)

	return
}

// Reset the styles of @widget and all descendents, so when
// they are looked up again, they get the correct values
// for the currently loaded RC file settings.
//
// This function is not useful for applications.
/*

C function : gtk_widget_reset_rc_styles
*/
func (recv *Widget) ResetRcStyles() {
	C.gtk_widget_reset_rc_styles((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_widget_send_expose : unsupported parameter event : no type generator for Gdk.Event (GdkEvent*) for param event

// Given an accelerator group, @accel_group, and an accelerator path,
// @accel_path, sets up an accelerator in @accel_group so whenever the
// key binding that is defined for @accel_path is pressed, @widget
// will be activated.  This removes any accelerators (for any
// accelerator group) installed by previous calls to
// gtk_widget_set_accel_path(). Associating accelerators with
// paths allows them to be modified by the user and the modifications
// to be saved for future use. (See gtk_accel_map_save().)
//
// This function is a low level function that would most likely
// be used by a menu creation system like #GtkUIManager. If you
// use #GtkUIManager, setting up accelerator paths will be done
// automatically.
//
// Even when you you aren’t using #GtkUIManager, if you only want to
// set up accelerators on menu items gtk_menu_item_set_accel_path()
// provides a somewhat more convenient interface.
//
// Note that @accel_path string will be stored in a #GQuark. Therefore, if you
// pass a static string, you can save some memory by interning it first with
// g_intern_static_string().
/*

C function : gtk_widget_set_accel_path
*/
func (recv *Widget) SetAccelPath(accelPath string, accelGroup *AccelGroup) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_widget_set_accel_path((*C.GtkWidget)(recv.native), c_accel_path, c_accel_group)

	return
}

// Sets whether the application intends to draw on the widget in
// an #GtkWidget::draw handler.
//
// This is a hint to the widget and does not affect the behavior of
// the GTK+ core; many widgets ignore this flag entirely. For widgets
// that do pay attention to the flag, such as #GtkEventBox and #GtkWindow,
// the effect is to suppress default themed drawing of the widget's
// background. (Children of the widget will still be drawn.) The application
// is then entirely responsible for drawing the widget background.
//
// Note that the background is still drawn when the widget is mapped.
/*

C function : gtk_widget_set_app_paintable
*/
func (recv *Widget) SetAppPaintable(appPaintable bool) {
	c_app_paintable :=
		boolToGboolean(appPaintable)

	C.gtk_widget_set_app_paintable((*C.GtkWidget)(recv.native), c_app_paintable)

	return
}

// Sets whether @widget should be mapped along with its when its parent
// is mapped and @widget has been shown with gtk_widget_show().
//
// The child visibility can be set for widget before it is added to
// a container with gtk_widget_set_parent(), to avoid mapping
// children unnecessary before immediately unmapping them. However
// it will be reset to its default state of %TRUE when the widget
// is removed from a container.
//
// Note that changing the child visibility of a widget does not
// queue a resize on the widget. Most of the time, the size of
// a widget is computed from all visible children, whether or
// not they are mapped. If this is not the case, the container
// can queue a resize itself.
//
// This function is only useful for container implementations and
// never should be called by an application.
/*

C function : gtk_widget_set_child_visible
*/
func (recv *Widget) SetChildVisible(isVisible bool) {
	c_is_visible :=
		boolToGboolean(isVisible)

	C.gtk_widget_set_child_visible((*C.GtkWidget)(recv.native), c_is_visible)

	return
}

// Sets a widgets composite name. The widget must be
// a composite child of its parent; see gtk_widget_push_composite_child().
/*

C function : gtk_widget_set_composite_name
*/
func (recv *Widget) SetCompositeName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_widget_set_composite_name((*C.GtkWidget)(recv.native), c_name)

	return
}

// Sets the reading direction on a particular widget. This direction
// controls the primary direction for widgets containing text,
// and also the direction in which the children of a container are
// packed. The ability to set the direction is present in order
// so that correct localization into languages with right-to-left
// reading directions can be done. Generally, applications will
// let the default reading direction present, except for containers
// where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
//
// If the direction is set to %GTK_TEXT_DIR_NONE, then the value
// set by gtk_widget_set_default_direction() will be used.
/*

C function : gtk_widget_set_direction
*/
func (recv *Widget) SetDirection(dir TextDirection) {
	c_dir := (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction((*C.GtkWidget)(recv.native), c_dir)

	return
}

// Widgets are double buffered by default; you can use this function
// to turn off the buffering. “Double buffered” simply means that
// gdk_window_begin_draw_frame() and gdk_window_end_draw_frame() are called
// automatically around expose events sent to the
// widget. gdk_window_begin_draw_frame() diverts all drawing to a widget's
// window to an offscreen buffer, and gdk_window_end_draw_frame() draws the
// buffer to the screen. The result is that users see the window
// update in one smooth step, and don’t see individual graphics
// primitives being rendered.
//
// In very simple terms, double buffered widgets don’t flicker,
// so you would only use this function to turn off double buffering
// if you had special needs and really knew what you were doing.
//
// Note: if you turn off double-buffering, you have to handle
// expose events, since even the clearing to the background color or
// pixmap will not happen automatically (as it is done in
// gdk_window_begin_draw_frame()).
//
// In 3.10 GTK and GDK have been restructured for translucent drawing. Since
// then expose events for double-buffered widgets are culled into a single
// event to the toplevel GDK window. If you now unset double buffering, you
// will cause a separate rendering pass for every widget. This will likely
// cause rendering problems - in particular related to stacking - and usually
// increases rendering times significantly.
/*

C function : gtk_widget_set_double_buffered
*/
func (recv *Widget) SetDoubleBuffered(doubleBuffered bool) {
	c_double_buffered :=
		boolToGboolean(doubleBuffered)

	C.gtk_widget_set_double_buffered((*C.GtkWidget)(recv.native), c_double_buffered)

	return
}

// Sets the event mask (see #GdkEventMask) for a widget. The event
// mask determines which events a widget will receive. Keep in mind
// that different widgets have different default event masks, and by
// changing the event mask you may disrupt a widget’s functionality,
// so be careful. This function must be called while a widget is
// unrealized. Consider gtk_widget_add_events() for widgets that are
// already realized, or if you want to preserve the existing event
// mask. This function can’t be used with widgets that have no window.
// (See gtk_widget_get_has_window()).  To get events on those widgets,
// place them inside a #GtkEventBox and receive events on the event
// box.
/*

C function : gtk_widget_set_events
*/
func (recv *Widget) SetEvents(events int32) {
	c_events := (C.gint)(events)

	C.gtk_widget_set_events((*C.GtkWidget)(recv.native), c_events)

	return
}

// Sets the horizontal alignment of @widget.
// See the #GtkWidget:halign property.
/*

C function : gtk_widget_set_halign
*/
func (recv *Widget) SetHalign(align Align) {
	c_align := (C.GtkAlign)(align)

	C.gtk_widget_set_halign((*C.GtkWidget)(recv.native), c_align)

	return
}

// Sets whether the widget would like any available extra horizontal
// space. When a user resizes a #GtkWindow, widgets with expand=TRUE
// generally receive the extra space. For example, a list or
// scrollable area or document in your window would often be set to
// expand.
//
// Call this function to set the expand flag if you would like your
// widget to become larger horizontally when the window has extra
// room.
//
// By default, widgets automatically expand if any of their children
// want to expand. (To see if a widget will automatically expand given
// its current children and state, call gtk_widget_compute_expand(). A
// container can decide how the expandability of children affects the
// expansion of the container by overriding the compute_expand virtual
// method on #GtkWidget.).
//
// Setting hexpand explicitly with this function will override the
// automatic expand behavior.
//
// This function forces the widget to expand or not to expand,
// regardless of children.  The override occurs because
// gtk_widget_set_hexpand() sets the hexpand-set property (see
// gtk_widget_set_hexpand_set()) which causes the widget’s hexpand
// value to be used, rather than looking at children and widget state.
/*

C function : gtk_widget_set_hexpand
*/
func (recv *Widget) SetHexpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_widget_set_hexpand((*C.GtkWidget)(recv.native), c_expand)

	return
}

// Sets whether the hexpand flag (see gtk_widget_get_hexpand()) will
// be used.
//
// The hexpand-set property will be set automatically when you call
// gtk_widget_set_hexpand() to set hexpand, so the most likely
// reason to use this function would be to unset an explicit expand
// flag.
//
// If hexpand is set, then it overrides any computed
// expand value based on child widgets. If hexpand is not
// set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here
// for completeness and consistency.
/*

C function : gtk_widget_set_hexpand_set
*/
func (recv *Widget) SetHexpandSet(set bool) {
	c_set :=
		boolToGboolean(set)

	C.gtk_widget_set_hexpand_set((*C.GtkWidget)(recv.native), c_set)

	return
}

// Widgets can be named, which allows you to refer to them from a
// CSS file. You can apply a style to widgets with a particular name
// in the CSS file. See the documentation for the CSS syntax (on the
// same page as the docs for #GtkStyleContext).
//
// Note that the CSS syntax has certain special characters to delimit
// and represent elements in a selector (period, #, >, *...), so using
// these will make your widget impossible to match by name. Any combination
// of alphanumeric symbols, dashes and underscores will suffice.
/*

C function : gtk_widget_set_name
*/
func (recv *Widget) SetName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_widget_set_name((*C.GtkWidget)(recv.native), c_name)

	return
}

// This function is useful only when implementing subclasses of
// #GtkContainer.
// Sets the container as the parent of @widget, and takes care of
// some details such as updating the state and style of the child
// to reflect its new location. The opposite function is
// gtk_widget_unparent().
/*

C function : gtk_widget_set_parent
*/
func (recv *Widget) SetParent(parent *Widget) {
	c_parent := (*C.GtkWidget)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWidget)(parent.ToC())
	}

	C.gtk_widget_set_parent((*C.GtkWidget)(recv.native), c_parent)

	return
}

// Sets a non default parent window for @widget.
//
// For #GtkWindow classes, setting a @parent_window effects whether
// the window is a toplevel window or can be embedded into other
// widgets.
//
// For #GtkWindow classes, this needs to be called before the
// window is realized.
/*

C function : gtk_widget_set_parent_window
*/
func (recv *Widget) SetParentWindow(parentWindow *gdk.Window) {
	c_parent_window := (*C.GdkWindow)(C.NULL)
	if parentWindow != nil {
		c_parent_window = (*C.GdkWindow)(parentWindow.ToC())
	}

	C.gtk_widget_set_parent_window((*C.GtkWidget)(recv.native), c_parent_window)

	return
}

// Sets whether the entire widget is queued for drawing when its size
// allocation changes. By default, this setting is %TRUE and
// the entire widget is redrawn on every size change. If your widget
// leaves the upper left unchanged when made bigger, turning this
// setting off will improve performance.
//
// Note that for widgets where gtk_widget_get_has_window() is %FALSE
// setting this flag to %FALSE turns off all allocation on resizing:
// the widget will not even redraw if its position changes; this is to
// allow containers that don’t draw anything to avoid excess
// invalidations. If you set this flag on a widget with no window that
// does draw on @widget->window, you are
// responsible for invalidating both the old and new allocation of the
// widget when the widget is moved and responsible for invalidating
// regions newly when the widget increases size.
/*

C function : gtk_widget_set_redraw_on_allocate
*/
func (recv *Widget) SetRedrawOnAllocate(redrawOnAllocate bool) {
	c_redraw_on_allocate :=
		boolToGboolean(redrawOnAllocate)

	C.gtk_widget_set_redraw_on_allocate((*C.GtkWidget)(recv.native), c_redraw_on_allocate)

	return
}

// Sets the sensitivity of a widget. A widget is sensitive if the user
// can interact with it. Insensitive widgets are “grayed out” and the
// user can’t interact with them. Insensitive widgets are known as
// “inactive”, “disabled”, or “ghosted” in some other toolkits.
/*

C function : gtk_widget_set_sensitive
*/
func (recv *Widget) SetSensitive(sensitive bool) {
	c_sensitive :=
		boolToGboolean(sensitive)

	C.gtk_widget_set_sensitive((*C.GtkWidget)(recv.native), c_sensitive)

	return
}

// Sets the minimum size of a widget; that is, the widget’s size
// request will be at least @width by @height. You can use this
// function to force a widget to be larger than it normally would be.
//
// In most cases, gtk_window_set_default_size() is a better choice for
// toplevel windows than this function; setting the default size will
// still allow users to shrink the window. Setting the size request
// will force them to leave the window at least as large as the size
// request. When dealing with window sizes,
// gtk_window_set_geometry_hints() can be a useful function as well.
//
// Note the inherent danger of setting any fixed size - themes,
// translations into other languages, different fonts, and user action
// can all change the appropriate size for a given widget. So, it's
// basically impossible to hardcode a size that will always be
// correct.
//
// The size request of a widget is the smallest size a widget can
// accept while still functioning well and drawing itself correctly.
// However in some strange cases a widget may be allocated less than
// its requested size, and in many cases a widget may be allocated more
// space than it requested.
//
// If the size request in a given direction is -1 (unset), then
// the “natural” size request of the widget will be used instead.
//
// The size request set here does not include any margin from the
// #GtkWidget properties margin-left, margin-right, margin-top, and
// margin-bottom, but it does include pretty much all other padding
// or border properties set by any subclass of #GtkWidget.
/*

C function : gtk_widget_set_size_request
*/
func (recv *Widget) SetSizeRequest(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_widget_set_size_request((*C.GtkWidget)(recv.native), c_width, c_height)

	return
}

// This function is for use in widget implementations. Sets the state
// of a widget (insensitive, prelighted, etc.) Usually you should set
// the state using wrapper functions such as gtk_widget_set_sensitive().
/*

C function : gtk_widget_set_state
*/
func (recv *Widget) SetState(state StateType) {
	c_state := (C.GtkStateType)(state)

	C.gtk_widget_set_state((*C.GtkWidget)(recv.native), c_state)

	return
}

// Used to set the #GtkStyle for a widget (@widget->style). Since
// GTK 3, this function does nothing, the passed in style is ignored.
/*

C function : gtk_widget_set_style
*/
func (recv *Widget) SetStyle(style *Style) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	C.gtk_widget_set_style((*C.GtkWidget)(recv.native), c_style)

	return
}

// Sets the vertical alignment of @widget.
// See the #GtkWidget:valign property.
/*

C function : gtk_widget_set_valign
*/
func (recv *Widget) SetValign(align Align) {
	c_align := (C.GtkAlign)(align)

	C.gtk_widget_set_valign((*C.GtkWidget)(recv.native), c_align)

	return
}

// Sets whether the widget would like any available extra vertical
// space.
//
// See gtk_widget_set_hexpand() for more detail.
/*

C function : gtk_widget_set_vexpand
*/
func (recv *Widget) SetVexpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_widget_set_vexpand((*C.GtkWidget)(recv.native), c_expand)

	return
}

// Sets whether the vexpand flag (see gtk_widget_get_vexpand()) will
// be used.
//
// See gtk_widget_set_hexpand_set() for more detail.
/*

C function : gtk_widget_set_vexpand_set
*/
func (recv *Widget) SetVexpandSet(set bool) {
	c_set :=
		boolToGboolean(set)

	C.gtk_widget_set_vexpand_set((*C.GtkWidget)(recv.native), c_set)

	return
}

// Sets the visual that should be used for by widget and its children for
// creating #GdkWindows. The visual must be on the same #GdkScreen as
// returned by gtk_widget_get_screen(), so handling the
// #GtkWidget::screen-changed signal is necessary.
//
// Setting a new @visual will not cause @widget to recreate its windows,
// so you should call this function before @widget is realized.
/*

C function : gtk_widget_set_visual
*/
func (recv *Widget) SetVisual(visual *gdk.Visual) {
	c_visual := (*C.GdkVisual)(C.NULL)
	if visual != nil {
		c_visual = (*C.GdkVisual)(visual.ToC())
	}

	C.gtk_widget_set_visual((*C.GtkWidget)(recv.native), c_visual)

	return
}

// Flags a widget to be displayed. Any widget that isn’t shown will
// not appear on the screen. If you want to show all the widgets in a
// container, it’s easier to call gtk_widget_show_all() on the
// container, instead of individually showing the widgets.
//
// Remember that you have to show the containers containing a widget,
// in addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and
// mapped; other shown widgets are realized and mapped when their
// toplevel container is realized and mapped.
/*

C function : gtk_widget_show
*/
func (recv *Widget) Show() {
	C.gtk_widget_show((*C.GtkWidget)(recv.native))

	return
}

// Recursively shows a widget, and any child widgets (if the widget is
// a container).
/*

C function : gtk_widget_show_all
*/
func (recv *Widget) ShowAll() {
	C.gtk_widget_show_all((*C.GtkWidget)(recv.native))

	return
}

// Shows a widget. If the widget is an unmapped toplevel widget
// (i.e. a #GtkWindow that has not yet been shown), enter the main
// loop and wait for the window to actually be mapped. Be careful;
// because the main loop is running, anything can happen during
// this function.
/*

C function : gtk_widget_show_now
*/
func (recv *Widget) ShowNow() {
	C.gtk_widget_show_now((*C.GtkWidget)(recv.native))

	return
}

// Unsupported : gtk_widget_size_allocate : unsupported parameter allocation : Blacklisted record : GdkRectangle

// This function is typically used when implementing a #GtkContainer
// subclass.  Obtains the preferred size of a widget. The container
// uses this information to arrange its child widgets and decide what
// size allocations to give them with gtk_widget_size_allocate().
//
// You can also call this function from an application, with some
// caveats. Most notably, getting a size request requires the widget
// to be associated with a screen, because font information may be
// needed. Multihead-aware applications should keep this in mind.
//
// Also remember that the size request is not necessarily the size
// a widget will actually be allocated.
/*

C function : gtk_widget_size_request
*/
func (recv *Widget) SizeRequest() *Requisition {
	var c_requisition C.GtkRequisition

	C.gtk_widget_size_request((*C.GtkWidget)(recv.native), &c_requisition)

	requisition := RequisitionNewFromC(unsafe.Pointer(&c_requisition))

	return requisition
}

// Unsupported : gtk_widget_style_get : unsupported parameter ... : varargs

// Gets the value of a style property of @widget.
/*

C function : gtk_widget_style_get_property
*/
func (recv *Widget) StyleGetProperty(propertyName string, value *gobject.Value) {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_widget_style_get_property((*C.GtkWidget)(recv.native), c_property_name, c_value)

	return
}

// Unsupported : gtk_widget_style_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Reverts the effect of a previous call to gtk_widget_freeze_child_notify().
// This causes all queued #GtkWidget::child-notify signals on @widget to be
// emitted.
/*

C function : gtk_widget_thaw_child_notify
*/
func (recv *Widget) ThawChildNotify() {
	C.gtk_widget_thaw_child_notify((*C.GtkWidget)(recv.native))

	return
}

// Translate coordinates relative to @src_widget’s allocation to coordinates
// relative to @dest_widget’s allocations. In order to perform this
// operation, both widgets must be realized, and must share a common
// toplevel.
/*

C function : gtk_widget_translate_coordinates
*/
func (recv *Widget) TranslateCoordinates(destWidget *Widget, srcX int32, srcY int32) (bool, int32, int32) {
	c_dest_widget := (*C.GtkWidget)(C.NULL)
	if destWidget != nil {
		c_dest_widget = (*C.GtkWidget)(destWidget.ToC())
	}

	c_src_x := (C.gint)(srcX)

	c_src_y := (C.gint)(srcY)

	var c_dest_x C.gint

	var c_dest_y C.gint

	retC := C.gtk_widget_translate_coordinates((*C.GtkWidget)(recv.native), c_dest_widget, c_src_x, c_src_y, &c_dest_x, &c_dest_y)
	retGo := retC == C.TRUE

	destX := (int32)(c_dest_x)

	destY := (int32)(c_dest_y)

	return retGo, destX, destY
}

// This function is only for use in widget implementations. Causes
// a widget to be unmapped if it’s currently mapped.
/*

C function : gtk_widget_unmap
*/
func (recv *Widget) Unmap() {
	C.gtk_widget_unmap((*C.GtkWidget)(recv.native))

	return
}

// This function is only for use in widget implementations.
// Should be called by implementations of the remove method
// on #GtkContainer, to dissociate a child from the container.
/*

C function : gtk_widget_unparent
*/
func (recv *Widget) Unparent() {
	C.gtk_widget_unparent((*C.GtkWidget)(recv.native))

	return
}

// This function is only useful in widget implementations.
// Causes a widget to be unrealized (frees all GDK resources
// associated with the widget, such as @widget->window).
/*

C function : gtk_widget_unrealize
*/
func (recv *Widget) Unrealize() {
	C.gtk_widget_unrealize((*C.GtkWidget)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Widget
func (recv *Widget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Widget
func (recv *Widget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// WidgetAccessible is a wrapper around the C record GtkWidgetAccessible.
type WidgetAccessible struct {
	native *C.GtkWidgetAccessible
	// parent : record
	// priv : record
}

func WidgetAccessibleNewFromC(u unsafe.Pointer) *WidgetAccessible {
	c := (*C.GtkWidgetAccessible)(u)
	if c == nil {
		return nil
	}

	g := &WidgetAccessible{native: c}

	return g
}

func (recv *WidgetAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Accessible upcasts to *Accessible
func (recv *WidgetAccessible) Accessible() *Accessible {
	return AccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *WidgetAccessible) Object() *atk.Object {
	return recv.Accessible().Object()
}

// CastToWidget down casts any arbitary Object to WidgetAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a WidgetAccessible.
func CastToWidgetAccessible(object *gobject.Object) *WidgetAccessible {
	return WidgetAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by WidgetAccessible
func (recv *WidgetAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Window is a wrapper around the C record GtkWindow.
type Window struct {
	native *C.GtkWindow
	// bin : record
	// priv : record
}

func WindowNewFromC(u unsafe.Pointer) *Window {
	c := (*C.GtkWindow)(u)
	if c == nil {
		return nil
	}

	g := &Window{native: c}

	return g
}

func (recv *Window) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Bin upcasts to *Bin
func (recv *Window) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Window) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Window) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Window) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Window) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitary Object to Window.
// Exercise care, as this is a potentially dangerous function if the Object is not a Window.
func CastToWindow(object *gobject.Object) *Window {
	return WindowNewFromC(object.ToC())
}

type signalWindowActivateDefaultDetail struct {
	callback  WindowSignalActivateDefaultCallback
	handlerID C.gulong
}

var signalWindowActivateDefaultId int
var signalWindowActivateDefaultMap = make(map[int]signalWindowActivateDefaultDetail)
var signalWindowActivateDefaultLock sync.Mutex

// WindowSignalActivateDefaultCallback is a callback function for a 'activate-default' signal emitted from a Window.
type WindowSignalActivateDefaultCallback func()

/*
ConnectActivateDefault connects the callback to the 'activate-default' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectActivateDefault to remove it.
*/
func (recv *Window) ConnectActivateDefault(callback WindowSignalActivateDefaultCallback) int {
	signalWindowActivateDefaultLock.Lock()
	defer signalWindowActivateDefaultLock.Unlock()

	signalWindowActivateDefaultId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_activate_default(instance, C.gpointer(uintptr(signalWindowActivateDefaultId)))

	detail := signalWindowActivateDefaultDetail{callback, handlerID}
	signalWindowActivateDefaultMap[signalWindowActivateDefaultId] = detail

	return signalWindowActivateDefaultId
}

/*
DisconnectActivateDefault disconnects a callback from the 'activate-default' signal for the Window.

The connectionID should be a value returned from a call to ConnectActivateDefault.
*/
func (recv *Window) DisconnectActivateDefault(connectionID int) {
	signalWindowActivateDefaultLock.Lock()
	defer signalWindowActivateDefaultLock.Unlock()

	detail, exists := signalWindowActivateDefaultMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowActivateDefaultMap, connectionID)
}

//export window_activateDefaultHandler
func window_activateDefaultHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWindowActivateDefaultMap[index].callback
	callback()
}

type signalWindowActivateFocusDetail struct {
	callback  WindowSignalActivateFocusCallback
	handlerID C.gulong
}

var signalWindowActivateFocusId int
var signalWindowActivateFocusMap = make(map[int]signalWindowActivateFocusDetail)
var signalWindowActivateFocusLock sync.Mutex

// WindowSignalActivateFocusCallback is a callback function for a 'activate-focus' signal emitted from a Window.
type WindowSignalActivateFocusCallback func()

/*
ConnectActivateFocus connects the callback to the 'activate-focus' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectActivateFocus to remove it.
*/
func (recv *Window) ConnectActivateFocus(callback WindowSignalActivateFocusCallback) int {
	signalWindowActivateFocusLock.Lock()
	defer signalWindowActivateFocusLock.Unlock()

	signalWindowActivateFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_activate_focus(instance, C.gpointer(uintptr(signalWindowActivateFocusId)))

	detail := signalWindowActivateFocusDetail{callback, handlerID}
	signalWindowActivateFocusMap[signalWindowActivateFocusId] = detail

	return signalWindowActivateFocusId
}

/*
DisconnectActivateFocus disconnects a callback from the 'activate-focus' signal for the Window.

The connectionID should be a value returned from a call to ConnectActivateFocus.
*/
func (recv *Window) DisconnectActivateFocus(connectionID int) {
	signalWindowActivateFocusLock.Lock()
	defer signalWindowActivateFocusLock.Unlock()

	detail, exists := signalWindowActivateFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowActivateFocusMap, connectionID)
}

//export window_activateFocusHandler
func window_activateFocusHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWindowActivateFocusMap[index].callback
	callback()
}

type signalWindowEnableDebuggingDetail struct {
	callback  WindowSignalEnableDebuggingCallback
	handlerID C.gulong
}

var signalWindowEnableDebuggingId int
var signalWindowEnableDebuggingMap = make(map[int]signalWindowEnableDebuggingDetail)
var signalWindowEnableDebuggingLock sync.Mutex

// WindowSignalEnableDebuggingCallback is a callback function for a 'enable-debugging' signal emitted from a Window.
type WindowSignalEnableDebuggingCallback func(toggle bool) bool

/*
ConnectEnableDebugging connects the callback to the 'enable-debugging' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectEnableDebugging to remove it.
*/
func (recv *Window) ConnectEnableDebugging(callback WindowSignalEnableDebuggingCallback) int {
	signalWindowEnableDebuggingLock.Lock()
	defer signalWindowEnableDebuggingLock.Unlock()

	signalWindowEnableDebuggingId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_enable_debugging(instance, C.gpointer(uintptr(signalWindowEnableDebuggingId)))

	detail := signalWindowEnableDebuggingDetail{callback, handlerID}
	signalWindowEnableDebuggingMap[signalWindowEnableDebuggingId] = detail

	return signalWindowEnableDebuggingId
}

/*
DisconnectEnableDebugging disconnects a callback from the 'enable-debugging' signal for the Window.

The connectionID should be a value returned from a call to ConnectEnableDebugging.
*/
func (recv *Window) DisconnectEnableDebugging(connectionID int) {
	signalWindowEnableDebuggingLock.Lock()
	defer signalWindowEnableDebuggingLock.Unlock()

	detail, exists := signalWindowEnableDebuggingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowEnableDebuggingMap, connectionID)
}

//export window_enableDebuggingHandler
func window_enableDebuggingHandler(_ *C.GObject, c_toggle C.gboolean, data C.gpointer) C.gboolean {
	toggle := c_toggle == C.TRUE

	index := int(uintptr(data))
	callback := signalWindowEnableDebuggingMap[index].callback
	retGo := callback(toggle)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWindowKeysChangedDetail struct {
	callback  WindowSignalKeysChangedCallback
	handlerID C.gulong
}

var signalWindowKeysChangedId int
var signalWindowKeysChangedMap = make(map[int]signalWindowKeysChangedDetail)
var signalWindowKeysChangedLock sync.Mutex

// WindowSignalKeysChangedCallback is a callback function for a 'keys-changed' signal emitted from a Window.
type WindowSignalKeysChangedCallback func()

/*
ConnectKeysChanged connects the callback to the 'keys-changed' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectKeysChanged to remove it.
*/
func (recv *Window) ConnectKeysChanged(callback WindowSignalKeysChangedCallback) int {
	signalWindowKeysChangedLock.Lock()
	defer signalWindowKeysChangedLock.Unlock()

	signalWindowKeysChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_keys_changed(instance, C.gpointer(uintptr(signalWindowKeysChangedId)))

	detail := signalWindowKeysChangedDetail{callback, handlerID}
	signalWindowKeysChangedMap[signalWindowKeysChangedId] = detail

	return signalWindowKeysChangedId
}

/*
DisconnectKeysChanged disconnects a callback from the 'keys-changed' signal for the Window.

The connectionID should be a value returned from a call to ConnectKeysChanged.
*/
func (recv *Window) DisconnectKeysChanged(connectionID int) {
	signalWindowKeysChangedLock.Lock()
	defer signalWindowKeysChangedLock.Unlock()

	detail, exists := signalWindowKeysChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowKeysChangedMap, connectionID)
}

//export window_keysChangedHandler
func window_keysChangedHandler(_ *C.GObject, data C.gpointer) {
	index := int(uintptr(data))
	callback := signalWindowKeysChangedMap[index].callback
	callback()
}

type signalWindowSetFocusDetail struct {
	callback  WindowSignalSetFocusCallback
	handlerID C.gulong
}

var signalWindowSetFocusId int
var signalWindowSetFocusMap = make(map[int]signalWindowSetFocusDetail)
var signalWindowSetFocusLock sync.Mutex

// WindowSignalSetFocusCallback is a callback function for a 'set-focus' signal emitted from a Window.
type WindowSignalSetFocusCallback func(object *Widget)

/*
ConnectSetFocus connects the callback to the 'set-focus' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectSetFocus to remove it.
*/
func (recv *Window) ConnectSetFocus(callback WindowSignalSetFocusCallback) int {
	signalWindowSetFocusLock.Lock()
	defer signalWindowSetFocusLock.Unlock()

	signalWindowSetFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_set_focus(instance, C.gpointer(uintptr(signalWindowSetFocusId)))

	detail := signalWindowSetFocusDetail{callback, handlerID}
	signalWindowSetFocusMap[signalWindowSetFocusId] = detail

	return signalWindowSetFocusId
}

/*
DisconnectSetFocus disconnects a callback from the 'set-focus' signal for the Window.

The connectionID should be a value returned from a call to ConnectSetFocus.
*/
func (recv *Window) DisconnectSetFocus(connectionID int) {
	signalWindowSetFocusLock.Lock()
	defer signalWindowSetFocusLock.Unlock()

	detail, exists := signalWindowSetFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowSetFocusMap, connectionID)
}

//export window_setFocusHandler
func window_setFocusHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalWindowSetFocusMap[index].callback
	callback(object)
}

// Creates a new #GtkWindow, which is a toplevel window that can
// contain other widgets. Nearly always, the type of the window should
// be #GTK_WINDOW_TOPLEVEL. If you’re implementing something like a
// popup menu from scratch (which is a bad idea, just use #GtkMenu),
// you might use #GTK_WINDOW_POPUP. #GTK_WINDOW_POPUP is not for
// dialogs, though in some other toolkits dialogs are called “popups”.
// In GTK+, #GTK_WINDOW_POPUP means a pop-up menu or pop-up tooltip.
// On X11, popup windows are not controlled by the
// [window manager][gtk-X11-arch].
//
// If you simply want an undecorated window (no window borders), use
// gtk_window_set_decorated(), don’t use #GTK_WINDOW_POPUP.
//
// All top-level windows created by gtk_window_new() are stored in
// an internal top-level window list.  This list can be obtained from
// gtk_window_list_toplevels().  Due to Gtk+ keeping a reference to
// the window internally, gtk_window_new() does not return a reference
// to the caller.
//
// To delete a #GtkWindow, call gtk_widget_destroy().
/*

C function : gtk_window_new
*/
func WindowNew(type_ WindowType) *Window {
	c_type := (C.GtkWindowType)(type_)

	retC := C.gtk_window_new(c_type)
	retGo := WindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Activates the default widget for the window, unless the current
// focused widget has been configured to receive the default action
// (see gtk_widget_set_receives_default()), in which case the
// focused widget is activated.
/*

C function : gtk_window_activate_default
*/
func (recv *Window) ActivateDefault() bool {
	retC := C.gtk_window_activate_default((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Activates the current focused widget within the window.
/*

C function : gtk_window_activate_focus
*/
func (recv *Window) ActivateFocus() bool {
	retC := C.gtk_window_activate_focus((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Associate @accel_group with @window, such that calling
// gtk_accel_groups_activate() on @window will activate accelerators
// in @accel_group.
/*

C function : gtk_window_add_accel_group
*/
func (recv *Window) AddAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_window_add_accel_group((*C.GtkWindow)(recv.native), c_accel_group)

	return
}

// Adds a mnemonic to this window.
/*

C function : gtk_window_add_mnemonic
*/
func (recv *Window) AddMnemonic(keyval uint32, target *Widget) {
	c_keyval := (C.guint)(keyval)

	c_target := (*C.GtkWidget)(C.NULL)
	if target != nil {
		c_target = (*C.GtkWidget)(target.ToC())
	}

	C.gtk_window_add_mnemonic((*C.GtkWindow)(recv.native), c_keyval, c_target)

	return
}

// Starts moving a window. This function is used if an application has
// window movement grips. When GDK can support it, the window movement
// will be done using the standard mechanism for the
// [window manager][gtk-X11-arch] or windowing
// system. Otherwise, GDK will try to emulate window movement,
// potentially not all that well, depending on the windowing system.
/*

C function : gtk_window_begin_move_drag
*/
func (recv *Window) BeginMoveDrag(button int32, rootX int32, rootY int32, timestamp uint32) {
	c_button := (C.gint)(button)

	c_root_x := (C.gint)(rootX)

	c_root_y := (C.gint)(rootY)

	c_timestamp := (C.guint32)(timestamp)

	C.gtk_window_begin_move_drag((*C.GtkWindow)(recv.native), c_button, c_root_x, c_root_y, c_timestamp)

	return
}

// Starts resizing a window. This function is used if an application
// has window resizing controls. When GDK can support it, the resize
// will be done using the standard mechanism for the
// [window manager][gtk-X11-arch] or windowing
// system. Otherwise, GDK will try to emulate window resizing,
// potentially not all that well, depending on the windowing system.
/*

C function : gtk_window_begin_resize_drag
*/
func (recv *Window) BeginResizeDrag(edge gdk.WindowEdge, button int32, rootX int32, rootY int32, timestamp uint32) {
	c_edge := (C.GdkWindowEdge)(edge)

	c_button := (C.gint)(button)

	c_root_x := (C.gint)(rootX)

	c_root_y := (C.gint)(rootY)

	c_timestamp := (C.guint32)(timestamp)

	C.gtk_window_begin_resize_drag((*C.GtkWindow)(recv.native), c_edge, c_button, c_root_x, c_root_y, c_timestamp)

	return
}

// Asks to deiconify (i.e. unminimize) the specified @window. Note
// that you shouldn’t assume the window is definitely deiconified
// afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch])) could iconify it
// again before your code which assumes deiconification gets to run.
//
// You can track iconification via the “window-state-event” signal
// on #GtkWidget.
/*

C function : gtk_window_deiconify
*/
func (recv *Window) Deiconify() {
	C.gtk_window_deiconify((*C.GtkWindow)(recv.native))

	return
}

// Returns whether the window has been set to have decorations
// such as a title bar via gtk_window_set_decorated().
/*

C function : gtk_window_get_decorated
*/
func (recv *Window) GetDecorated() bool {
	retC := C.gtk_window_get_decorated((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Gets the default size of the window. A value of -1 for the width or
// height indicates that a default size has not been explicitly set
// for that dimension, so the “natural” size of the window will be
// used.
/*

C function : gtk_window_get_default_size
*/
func (recv *Window) GetDefaultSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_window_get_default_size((*C.GtkWindow)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// Returns whether the window will be destroyed with its transient parent. See
// gtk_window_set_destroy_with_parent ().
/*

C function : gtk_window_get_destroy_with_parent
*/
func (recv *Window) GetDestroyWithParent() bool {
	retC := C.gtk_window_get_destroy_with_parent((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Retrieves the current focused widget within the window.
// Note that this is the widget that would have the focus
// if the toplevel window focused; if the toplevel window
// is not focused then  `gtk_widget_has_focus (widget)` will
// not be %TRUE for the widget.
/*

C function : gtk_window_get_focus
*/
func (recv *Window) GetFocus() *Widget {
	retC := C.gtk_window_get_focus((*C.GtkWindow)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets the value set by gtk_window_set_gravity().
/*

C function : gtk_window_get_gravity
*/
func (recv *Window) GetGravity() gdk.Gravity {
	retC := C.gtk_window_get_gravity((*C.GtkWindow)(recv.native))
	retGo := (gdk.Gravity)(retC)

	return retGo
}

// Gets the value set by gtk_window_set_icon() (or if you've
// called gtk_window_set_icon_list(), gets the first icon in
// the icon list).
/*

C function : gtk_window_get_icon
*/
func (recv *Window) GetIcon() *gdkpixbuf.Pixbuf {
	retC := C.gtk_window_get_icon((*C.GtkWindow)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Retrieves the list of icons set by gtk_window_set_icon_list().
// The list is copied, but the reference count on each
// member won’t be incremented.
/*

C function : gtk_window_get_icon_list
*/
func (recv *Window) GetIconList() *glib.List {
	retC := C.gtk_window_get_icon_list((*C.GtkWindow)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Returns the mnemonic modifier for this window. See
// gtk_window_set_mnemonic_modifier().
/*

C function : gtk_window_get_mnemonic_modifier
*/
func (recv *Window) GetMnemonicModifier() gdk.ModifierType {
	retC := C.gtk_window_get_mnemonic_modifier((*C.GtkWindow)(recv.native))
	retGo := (gdk.ModifierType)(retC)

	return retGo
}

// Returns whether the window is modal. See gtk_window_set_modal().
/*

C function : gtk_window_get_modal
*/
func (recv *Window) GetModal() bool {
	retC := C.gtk_window_get_modal((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// This function returns the position you need to pass to
// gtk_window_move() to keep @window in its current position.
// This means that the meaning of the returned value varies with
// window gravity. See gtk_window_move() for more details.
//
// The reliability of this function depends on the windowing system
// currently in use. Some windowing systems, such as Wayland, do not
// support a global coordinate system, and thus the position of the
// window will always be (0, 0). Others, like X11, do not have a reliable
// way to obtain the geometry of the decorations of a window if they are
// provided by the window manager. Additionally, on X11, window manager
// have been known to mismanage window gravity, which result in windows
// moving even if you use the coordinates of the current position as
// returned by this function.
//
// If you haven’t changed the window gravity, its gravity will be
// #GDK_GRAVITY_NORTH_WEST. This means that gtk_window_get_position()
// gets the position of the top-left corner of the window manager
// frame for the window. gtk_window_move() sets the position of this
// same top-left corner.
//
// If a window has gravity #GDK_GRAVITY_STATIC the window manager
// frame is not relevant, and thus gtk_window_get_position() will
// always produce accurate results. However you can’t use static
// gravity to do things like place a window in a corner of the screen,
// because static gravity ignores the window manager decorations.
//
// Ideally, this function should return appropriate values if the
// window has client side decorations, assuming that the windowing
// system supports global coordinates.
//
// In practice, saving the window position should not be left to
// applications, as they lack enough knowledge of the windowing
// system and the window manager state to effectively do so. The
// appropriate way to implement saving the window position is to
// use a platform-specific protocol, wherever that is available.
/*

C function : gtk_window_get_position
*/
func (recv *Window) GetPosition() (int32, int32) {
	var c_root_x C.gint

	var c_root_y C.gint

	C.gtk_window_get_position((*C.GtkWindow)(recv.native), &c_root_x, &c_root_y)

	rootX := (int32)(c_root_x)

	rootY := (int32)(c_root_y)

	return rootX, rootY
}

// Gets the value set by gtk_window_set_resizable().
/*

C function : gtk_window_get_resizable
*/
func (recv *Window) GetResizable() bool {
	retC := C.gtk_window_get_resizable((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Returns the role of the window. See gtk_window_set_role() for
// further explanation.
/*

C function : gtk_window_get_role
*/
func (recv *Window) GetRole() string {
	retC := C.gtk_window_get_role((*C.GtkWindow)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Obtains the current size of @window.
//
// If @window is not visible on screen, this function return the size GTK+
// will suggest to the [window manager][gtk-X11-arch] for the initial window
// size (but this is not reliably the same as the size the window manager
// will actually select). See: gtk_window_set_default_size().
//
// Depending on the windowing system and the window manager constraints,
// the size returned by this function may not match the size set using
// gtk_window_resize(); additionally, since gtk_window_resize() may be
// implemented as an asynchronous operation, GTK+ cannot guarantee in any
// way that this code:
//
// |[<!-- language="C" -->
// width and height are set elsewhere
// gtk_window_resize (window, width, height);
//
// int new_width, new_height;
// gtk_window_get_size (window, &new_width, &new_height);
// ]|
//
// will result in `new_width` and `new_height` matching `width` and
// `height`, respectively.
//
// This function will return the logical size of the #GtkWindow,
// excluding the widgets used in client side decorations; there is,
// however, no guarantee that the result will be completely accurate
// because client side decoration may include widgets that depend on
// the user preferences and that may not be visibile at the time you
// call this function.
//
// The dimensions returned by this function are suitable for being
// stored across sessions; use gtk_window_set_default_size() to
// restore them when before showing the window.
//
// To avoid potential race conditions, you should only call this
// function in response to a size change notification, for instance
// inside a handler for the #GtkWidget::size-allocate signal, or
// inside a handler for the #GtkWidget::configure-event signal:
//
// |[<!-- language="C" -->
// static void
// on_size_allocate (GtkWidget *widget, GtkAllocation *allocation)
// {
// int new_width, new_height;
//
// gtk_window_get_size (GTK_WINDOW (widget), &new_width, &new_height);
//
// ...
// }
// ]|
//
// Note that, if you connect to the #GtkWidget::size-allocate signal,
// you should not use the dimensions of the #GtkAllocation passed to
// the signal handler, as the allocation may contain client side
// decorations added by GTK+, depending on the windowing system in
// use.
//
// If you are getting a window size in order to position the window
// on the screen, you should, instead, simply set the window’s semantic
// type with gtk_window_set_type_hint(), which allows the window manager
// to e.g. center dialogs. Also, if you set the transient parent of
// dialogs with gtk_window_set_transient_for() window managers will
// often center the dialog over its parent window. It's much preferred
// to let the window manager handle these cases rather than doing it
// yourself, because all apps will behave consistently and according to
// user or system preferences, if the window manager handles it. Also,
// the window manager can take into account the size of the window
// decorations and border that it may add, and of which GTK+ has no
// knowledge. Additionally, positioning windows in global screen coordinates
// may not be allowed by the windowing system. For more information,
// see: gtk_window_set_position().
/*

C function : gtk_window_get_size
*/
func (recv *Window) GetSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_window_get_size((*C.GtkWindow)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// Retrieves the title of the window. See gtk_window_set_title().
/*

C function : gtk_window_get_title
*/
func (recv *Window) GetTitle() string {
	retC := C.gtk_window_get_title((*C.GtkWindow)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Fetches the transient parent for this window. See
// gtk_window_set_transient_for().
/*

C function : gtk_window_get_transient_for
*/
func (recv *Window) GetTransientFor() *Window {
	retC := C.gtk_window_get_transient_for((*C.GtkWindow)(recv.native))
	var retGo (*Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Gets the type hint for this window. See gtk_window_set_type_hint().
/*

C function : gtk_window_get_type_hint
*/
func (recv *Window) GetTypeHint() gdk.WindowTypeHint {
	retC := C.gtk_window_get_type_hint((*C.GtkWindow)(recv.native))
	retGo := (gdk.WindowTypeHint)(retC)

	return retGo
}

// Returns whether @window has an explicit window group.
/*

C function : gtk_window_has_group
*/
func (recv *Window) HasGroup() bool {
	retC := C.gtk_window_has_group((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Asks to iconify (i.e. minimize) the specified @window. Note that
// you shouldn’t assume the window is definitely iconified afterward,
// because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could deiconify it
// again, or there may not be a window manager in which case
// iconification isn’t possible, etc. But normally the window will end
// up iconified. Just don’t write code that crashes if not.
//
// It’s permitted to call this function before showing a window,
// in which case the window will be iconified before it ever appears
// onscreen.
//
// You can track iconification via the “window-state-event” signal
// on #GtkWidget.
/*

C function : gtk_window_iconify
*/
func (recv *Window) Iconify() {
	C.gtk_window_iconify((*C.GtkWindow)(recv.native))

	return
}

// Asks to maximize @window, so that it becomes full-screen. Note that
// you shouldn’t assume the window is definitely maximized afterward,
// because other entities (e.g. the user or
// [window manager][gtk-X11-arch]) could unmaximize it
// again, and not all window managers support maximization. But
// normally the window will end up maximized. Just don’t write code
// that crashes if not.
//
// It’s permitted to call this function before showing a window,
// in which case the window will be maximized when it appears onscreen
// initially.
//
// You can track maximization via the “window-state-event” signal
// on #GtkWidget, or by listening to notifications on the
// #GtkWindow:is-maximized property.
/*

C function : gtk_window_maximize
*/
func (recv *Window) Maximize() {
	C.gtk_window_maximize((*C.GtkWindow)(recv.native))

	return
}

// Activates the targets associated with the mnemonic.
/*

C function : gtk_window_mnemonic_activate
*/
func (recv *Window) MnemonicActivate(keyval uint32, modifier gdk.ModifierType) bool {
	c_keyval := (C.guint)(keyval)

	c_modifier := (C.GdkModifierType)(modifier)

	retC := C.gtk_window_mnemonic_activate((*C.GtkWindow)(recv.native), c_keyval, c_modifier)
	retGo := retC == C.TRUE

	return retGo
}

// Asks the [window manager][gtk-X11-arch] to move
// @window to the given position.  Window managers are free to ignore
// this; most window managers ignore requests for initial window
// positions (instead using a user-defined placement algorithm) and
// honor requests after the window has already been shown.
//
// Note: the position is the position of the gravity-determined
// reference point for the window. The gravity determines two things:
// first, the location of the reference point in root window
// coordinates; and second, which point on the window is positioned at
// the reference point.
//
// By default the gravity is #GDK_GRAVITY_NORTH_WEST, so the reference
// point is simply the @x, @y supplied to gtk_window_move(). The
// top-left corner of the window decorations (aka window frame or
// border) will be placed at @x, @y.  Therefore, to position a window
// at the top left of the screen, you want to use the default gravity
// (which is #GDK_GRAVITY_NORTH_WEST) and move the window to 0,0.
//
// To position a window at the bottom right corner of the screen, you
// would set #GDK_GRAVITY_SOUTH_EAST, which means that the reference
// point is at @x + the window width and @y + the window height, and
// the bottom-right corner of the window border will be placed at that
// reference point. So, to place a window in the bottom right corner
// you would first set gravity to south east, then write:
// `gtk_window_move (window, gdk_screen_width () - window_width,
// gdk_screen_height () - window_height)` (note that this
// example does not take multi-head scenarios into account).
//
// The [Extended Window Manager Hints Specification](http://www.freedesktop.org/Standards/wm-spec)
// has a nice table of gravities in the “implementation notes” section.
//
// The gtk_window_get_position() documentation may also be relevant.
/*

C function : gtk_window_move
*/
func (recv *Window) Move(x int32, y int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_window_move((*C.GtkWindow)(recv.native), c_x, c_y)

	return
}

// Parses a standard X Window System geometry string - see the
// manual page for X (type “man X”) for details on this.
// gtk_window_parse_geometry() does work on all GTK+ ports
// including Win32 but is primarily intended for an X environment.
//
// If either a size or a position can be extracted from the
// geometry string, gtk_window_parse_geometry() returns %TRUE
// and calls gtk_window_set_default_size() and/or gtk_window_move()
// to resize/move the window.
//
// If gtk_window_parse_geometry() returns %TRUE, it will also
// set the #GDK_HINT_USER_POS and/or #GDK_HINT_USER_SIZE hints
// indicating to the window manager that the size/position of
// the window was user-specified. This causes most window
// managers to honor the geometry.
//
// Note that for gtk_window_parse_geometry() to work as expected, it has
// to be called when the window has its “final” size, i.e. after calling
// gtk_widget_show_all() on the contents and gtk_window_set_geometry_hints()
// on the window.
// |[<!-- language="C" -->
// #include <gtk/gtk.h>
//
// static void
// fill_with_content (GtkWidget *vbox)
// {
// fill with content...
// }
//
// int
// main (int argc, char *argv[])
// {
// GtkWidget *window, *vbox;
// GdkGeometry size_hints = {
// 100, 50, 0, 0, 100, 50, 10,
// 10, 0.0, 0.0, GDK_GRAVITY_NORTH_WEST
// };
//
// gtk_init (&argc, &argv);
//
// window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
// vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
//
// gtk_container_add (GTK_CONTAINER (window), vbox);
// fill_with_content (vbox);
// gtk_widget_show_all (vbox);
//
// gtk_window_set_geometry_hints (GTK_WINDOW (window),
// NULL,
// &size_hints,
// GDK_HINT_MIN_SIZE |
// GDK_HINT_BASE_SIZE |
// GDK_HINT_RESIZE_INC);
//
// if (argc > 1)
// {
// gboolean res;
// res = gtk_window_parse_geometry (GTK_WINDOW (window),
// argv[1]);
// if (! res)
// fprintf (stderr,
// "Failed to parse “%s”\n",
// argv[1]);
// }
//
// gtk_widget_show_all (window);
// gtk_main ();
//
// return 0;
// }
// ]|
/*

C function : gtk_window_parse_geometry
*/
func (recv *Window) ParseGeometry(geometry string) bool {
	c_geometry := C.CString(geometry)
	defer C.free(unsafe.Pointer(c_geometry))

	retC := C.gtk_window_parse_geometry((*C.GtkWindow)(recv.native), c_geometry)
	retGo := retC == C.TRUE

	return retGo
}

// Presents a window to the user. This may mean raising the window
// in the stacking order, deiconifying it, moving it to the current
// desktop, and/or giving it the keyboard focus, possibly dependent
// on the user’s platform, window manager, and preferences.
//
// If @window is hidden, this function calls gtk_widget_show()
// as well.
//
// This function should be used when the user tries to open a window
// that’s already open. Say for example the preferences dialog is
// currently open, and the user chooses Preferences from the menu
// a second time; use gtk_window_present() to move the already-open dialog
// where the user can see it.
//
// If you are calling this function in response to a user interaction,
// it is preferable to use gtk_window_present_with_time().
/*

C function : gtk_window_present
*/
func (recv *Window) Present() {
	C.gtk_window_present((*C.GtkWindow)(recv.native))

	return
}

// Reverses the effects of gtk_window_add_accel_group().
/*

C function : gtk_window_remove_accel_group
*/
func (recv *Window) RemoveAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_window_remove_accel_group((*C.GtkWindow)(recv.native), c_accel_group)

	return
}

// Removes a mnemonic from this window.
/*

C function : gtk_window_remove_mnemonic
*/
func (recv *Window) RemoveMnemonic(keyval uint32, target *Widget) {
	c_keyval := (C.guint)(keyval)

	c_target := (*C.GtkWidget)(C.NULL)
	if target != nil {
		c_target = (*C.GtkWidget)(target.ToC())
	}

	C.gtk_window_remove_mnemonic((*C.GtkWindow)(recv.native), c_keyval, c_target)

	return
}

// Hides @window, then reshows it, resetting the
// default size and position of the window. Used
// by GUI builders only.
/*

C function : gtk_window_reshow_with_initial_size
*/
func (recv *Window) ReshowWithInitialSize() {
	C.gtk_window_reshow_with_initial_size((*C.GtkWindow)(recv.native))

	return
}

// Resizes the window as if the user had done so, obeying geometry
// constraints. The default geometry constraint is that windows may
// not be smaller than their size request; to override this
// constraint, call gtk_widget_set_size_request() to set the window's
// request to a smaller value.
//
// If gtk_window_resize() is called before showing a window for the
// first time, it overrides any default size set with
// gtk_window_set_default_size().
//
// Windows may not be resized smaller than 1 by 1 pixels.
//
// When using client side decorations, GTK+ will do its best to adjust
// the given size so that the resulting window size matches the
// requested size without the title bar, borders and shadows added for
// the client side decorations, but there is no guarantee that the
// result will be totally accurate because these widgets added for
// client side decorations depend on the theme and may not be realized
// or visible at the time gtk_window_resize() is issued.
//
// If the GtkWindow has a titlebar widget (see gtk_window_set_titlebar()), then
// typically, gtk_window_resize() will compensate for the height of the titlebar
// widget only if the height is known when the resulting GtkWindow configuration
// is issued.
// For example, if new widgets are added after the GtkWindow configuration
// and cause the titlebar widget to grow in height, this will result in a
// window content smaller that specified by gtk_window_resize() and not
// a larger window.
/*

C function : gtk_window_resize
*/
func (recv *Window) Resize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_window_resize((*C.GtkWindow)(recv.native), c_width, c_height)

	return
}

// By default, windows are decorated with a title bar, resize
// controls, etc.  Some [window managers][gtk-X11-arch]
// allow GTK+ to disable these decorations, creating a
// borderless window. If you set the decorated property to %FALSE
// using this function, GTK+ will do its best to convince the window
// manager not to decorate the window. Depending on the system, this
// function may not have any effect when called on a window that is
// already visible, so you should call it before calling gtk_widget_show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
/*

C function : gtk_window_set_decorated
*/
func (recv *Window) SetDecorated(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_decorated((*C.GtkWindow)(recv.native), c_setting)

	return
}

// The default widget is the widget that’s activated when the user
// presses Enter in a dialog (for example). This function sets or
// unsets the default widget for a #GtkWindow. When setting (rather
// than unsetting) the default widget it’s generally easier to call
// gtk_widget_grab_default() on the widget. Before making a widget
// the default widget, you must call gtk_widget_set_can_default() on
// the widget you’d like to make the default.
/*

C function : gtk_window_set_default
*/
func (recv *Window) SetDefault(defaultWidget *Widget) {
	c_default_widget := (*C.GtkWidget)(C.NULL)
	if defaultWidget != nil {
		c_default_widget = (*C.GtkWidget)(defaultWidget.ToC())
	}

	C.gtk_window_set_default((*C.GtkWindow)(recv.native), c_default_widget)

	return
}

// Sets the default size of a window. If the window’s “natural” size
// (its size request) is larger than the default, the default will be
// ignored. More generally, if the default size does not obey the
// geometry hints for the window (gtk_window_set_geometry_hints() can
// be used to set these explicitly), the default size will be clamped
// to the nearest permitted size.
//
// Unlike gtk_widget_set_size_request(), which sets a size request for
// a widget and thus would keep users from shrinking the window, this
// function only sets the initial size, just as if the user had
// resized the window themselves. Users can still shrink the window
// again as they normally would. Setting a default size of -1 means to
// use the “natural” default size (the size request of the window).
//
// For more control over a window’s initial size and how resizing works,
// investigate gtk_window_set_geometry_hints().
//
// For some uses, gtk_window_resize() is a more appropriate function.
// gtk_window_resize() changes the current size of the window, rather
// than the size to be used on initial display. gtk_window_resize() always
// affects the window itself, not the geometry widget.
//
// The default size of a window only affects the first time a window is
// shown; if a window is hidden and re-shown, it will remember the size
// it had prior to hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but
// passing 0 for @width and @height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size,
// note that the appropriate size to save is the one returned by
// gtk_window_get_size(). Using the window allocation directly will not
// work in all circumstances and can lead to growing or shrinking windows.
/*

C function : gtk_window_set_default_size
*/
func (recv *Window) SetDefaultSize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_window_set_default_size((*C.GtkWindow)(recv.native), c_width, c_height)

	return
}

// If @setting is %TRUE, then destroying the transient parent of @window
// will also destroy @window itself. This is useful for dialogs that
// shouldn’t persist beyond the lifetime of the main window they're
// associated with, for example.
/*

C function : gtk_window_set_destroy_with_parent
*/
func (recv *Window) SetDestroyWithParent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_destroy_with_parent((*C.GtkWindow)(recv.native), c_setting)

	return
}

// If @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the window. If @focus is %NULL, unsets
// the focus widget for this window. To set the focus to a particular
// widget in the toplevel, it is usually more convenient to use
// gtk_widget_grab_focus() instead of this function.
/*

C function : gtk_window_set_focus
*/
func (recv *Window) SetFocus(focus *Widget) {
	c_focus := (*C.GtkWidget)(C.NULL)
	if focus != nil {
		c_focus = (*C.GtkWidget)(focus.ToC())
	}

	C.gtk_window_set_focus((*C.GtkWindow)(recv.native), c_focus)

	return
}

// This function sets up hints about how a window can be resized by
// the user.  You can set a minimum and maximum size; allowed resize
// increments (e.g. for xterm, you can only resize by the size of a
// character); aspect ratios; and more. See the #GdkGeometry struct.
/*

C function : gtk_window_set_geometry_hints
*/
func (recv *Window) SetGeometryHints(geometryWidget *Widget, geometry *gdk.Geometry, geomMask gdk.WindowHints) {
	c_geometry_widget := (*C.GtkWidget)(C.NULL)
	if geometryWidget != nil {
		c_geometry_widget = (*C.GtkWidget)(geometryWidget.ToC())
	}

	c_geometry := (*C.GdkGeometry)(C.NULL)
	if geometry != nil {
		c_geometry = (*C.GdkGeometry)(geometry.ToC())
	}

	c_geom_mask := (C.GdkWindowHints)(geomMask)

	C.gtk_window_set_geometry_hints((*C.GtkWindow)(recv.native), c_geometry_widget, c_geometry, c_geom_mask)

	return
}

// Window gravity defines the meaning of coordinates passed to
// gtk_window_move(). See gtk_window_move() and #GdkGravity for
// more details.
//
// The default window gravity is #GDK_GRAVITY_NORTH_WEST which will
// typically “do what you mean.”
/*

C function : gtk_window_set_gravity
*/
func (recv *Window) SetGravity(gravity gdk.Gravity) {
	c_gravity := (C.GdkGravity)(gravity)

	C.gtk_window_set_gravity((*C.GtkWindow)(recv.native), c_gravity)

	return
}

// Sets up the icon representing a #GtkWindow. This icon is used when
// the window is minimized (also known as iconified).  Some window
// managers or desktop environments may also place it in the window
// frame, or display it in other contexts. On others, the icon is not
// used at all, so your mileage may vary.
//
// The icon should be provided in whatever size it was naturally
// drawn; that is, don’t scale the image before passing it to
// GTK+. Scaling is postponed until the last minute, when the desired
// final size is known, to allow best quality.
//
// If you have your icon hand-drawn in multiple sizes, use
// gtk_window_set_icon_list(). Then the best size will be used.
//
// This function is equivalent to calling gtk_window_set_icon_list()
// with a 1-element list.
//
// See also gtk_window_set_default_icon_list() to set the icon
// for all windows in your application in one go.
/*

C function : gtk_window_set_icon
*/
func (recv *Window) SetIcon(icon *gdkpixbuf.Pixbuf) {
	c_icon := (*C.GdkPixbuf)(C.NULL)
	if icon != nil {
		c_icon = (*C.GdkPixbuf)(icon.ToC())
	}

	C.gtk_window_set_icon((*C.GtkWindow)(recv.native), c_icon)

	return
}

// Sets up the icon representing a #GtkWindow. The icon is used when
// the window is minimized (also known as iconified).  Some window
// managers or desktop environments may also place it in the window
// frame, or display it in other contexts. On others, the icon is not
// used at all, so your mileage may vary.
//
// gtk_window_set_icon_list() allows you to pass in the same icon in
// several hand-drawn sizes. The list should contain the natural sizes
// your icon is available in; that is, don’t scale the image before
// passing it to GTK+. Scaling is postponed until the last minute,
// when the desired final size is known, to allow best quality.
//
// By passing several sizes, you may improve the final image quality
// of the icon, by reducing or eliminating automatic image scaling.
//
// Recommended sizes to provide: 16x16, 32x32, 48x48 at minimum, and
// larger images (64x64, 128x128) if you have them.
//
// See also gtk_window_set_default_icon_list() to set the icon
// for all windows in your application in one go.
//
// Note that transient windows (those who have been set transient for another
// window using gtk_window_set_transient_for()) will inherit their
// icon from their transient parent. So there’s no need to explicitly
// set the icon on transient windows.
/*

C function : gtk_window_set_icon_list
*/
func (recv *Window) SetIconList(list *glib.List) {
	c_list := (*C.GList)(C.NULL)
	if list != nil {
		c_list = (*C.GList)(list.ToC())
	}

	C.gtk_window_set_icon_list((*C.GtkWindow)(recv.native), c_list)

	return
}

// Sets the mnemonic modifier for this window.
/*

C function : gtk_window_set_mnemonic_modifier
*/
func (recv *Window) SetMnemonicModifier(modifier gdk.ModifierType) {
	c_modifier := (C.GdkModifierType)(modifier)

	C.gtk_window_set_mnemonic_modifier((*C.GtkWindow)(recv.native), c_modifier)

	return
}

// Sets a window modal or non-modal. Modal windows prevent interaction
// with other windows in the same application. To keep modal dialogs
// on top of main application windows, use
// gtk_window_set_transient_for() to make the dialog transient for the
// parent; most [window managers][gtk-X11-arch]
// will then disallow lowering the dialog below the parent.
/*

C function : gtk_window_set_modal
*/
func (recv *Window) SetModal(modal bool) {
	c_modal :=
		boolToGboolean(modal)

	C.gtk_window_set_modal((*C.GtkWindow)(recv.native), c_modal)

	return
}

// Sets a position constraint for this window. If the old or new
// constraint is %GTK_WIN_POS_CENTER_ALWAYS, this will also cause
// the window to be repositioned to satisfy the new constraint.
/*

C function : gtk_window_set_position
*/
func (recv *Window) SetPosition(position WindowPosition) {
	c_position := (C.GtkWindowPosition)(position)

	C.gtk_window_set_position((*C.GtkWindow)(recv.native), c_position)

	return
}

// Sets whether the user can resize a window. Windows are user resizable
// by default.
/*

C function : gtk_window_set_resizable
*/
func (recv *Window) SetResizable(resizable bool) {
	c_resizable :=
		boolToGboolean(resizable)

	C.gtk_window_set_resizable((*C.GtkWindow)(recv.native), c_resizable)

	return
}

// This function is only useful on X11, not with other GTK+ targets.
//
// In combination with the window title, the window role allows a
// [window manager][gtk-X11-arch] to identify "the
// same" window when an application is restarted. So for example you
// might set the “toolbox” role on your app’s toolbox window, so that
// when the user restarts their session, the window manager can put
// the toolbox back in the same place.
//
// If a window already has a unique title, you don’t need to set the
// role, since the WM can use the title to identify the window when
// restoring the session.
/*

C function : gtk_window_set_role
*/
func (recv *Window) SetRole(role string) {
	c_role := C.CString(role)
	defer C.free(unsafe.Pointer(c_role))

	C.gtk_window_set_role((*C.GtkWindow)(recv.native), c_role)

	return
}

// Sets the title of the #GtkWindow. The title of a window will be
// displayed in its title bar; on the X Window System, the title bar
// is rendered by the [window manager][gtk-X11-arch],
// so exactly how the title appears to users may vary
// according to a user’s exact configuration. The title should help a
// user distinguish this window from other windows they may have
// open. A good title might include the application name and current
// document filename, for example.
/*

C function : gtk_window_set_title
*/
func (recv *Window) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_window_set_title((*C.GtkWindow)(recv.native), c_title)

	return
}

// Dialog windows should be set transient for the main application
// window they were spawned from. This allows
// [window managers][gtk-X11-arch] to e.g. keep the
// dialog on top of the main window, or center the dialog over the
// main window. gtk_dialog_new_with_buttons() and other convenience
// functions in GTK+ will sometimes call
// gtk_window_set_transient_for() on your behalf.
//
// Passing %NULL for @parent unsets the current transient window.
//
// On Wayland, this function can also be used to attach a new
// #GTK_WINDOW_POPUP to a #GTK_WINDOW_TOPLEVEL parent already mapped
// on screen so that the #GTK_WINDOW_POPUP will be created as a
// subsurface-based window #GDK_WINDOW_SUBSURFACE which can be
// positioned at will relatively to the #GTK_WINDOW_TOPLEVEL surface.
//
// On Windows, this function puts the child window on top of the parent,
// much as the window manager would have done on X.
/*

C function : gtk_window_set_transient_for
*/
func (recv *Window) SetTransientFor(parent *Window) {
	c_parent := (*C.GtkWindow)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWindow)(parent.ToC())
	}

	C.gtk_window_set_transient_for((*C.GtkWindow)(recv.native), c_parent)

	return
}

// By setting the type hint for the window, you allow the window
// manager to decorate and handle the window in a way which is
// suitable to the function of the window in your application.
//
// This function should be called before the window becomes visible.
//
// gtk_dialog_new_with_buttons() and other convenience functions in GTK+
// will sometimes call gtk_window_set_type_hint() on your behalf.
/*

C function : gtk_window_set_type_hint
*/
func (recv *Window) SetTypeHint(hint gdk.WindowTypeHint) {
	c_hint := (C.GdkWindowTypeHint)(hint)

	C.gtk_window_set_type_hint((*C.GtkWindow)(recv.native), c_hint)

	return
}

// Don’t use this function. It sets the X Window System “class” and
// “name” hints for a window.  According to the ICCCM, you should
// always set these to the same value for all windows in an
// application, and GTK+ sets them to that value by default, so calling
// this function is sort of pointless. However, you may want to call
// gtk_window_set_role() on each window in your application, for the
// benefit of the session manager. Setting the role allows the window
// manager to restore window positions when loading a saved session.
/*

C function : gtk_window_set_wmclass
*/
func (recv *Window) SetWmclass(wmclassName string, wmclassClass string) {
	c_wmclass_name := C.CString(wmclassName)
	defer C.free(unsafe.Pointer(c_wmclass_name))

	c_wmclass_class := C.CString(wmclassClass)
	defer C.free(unsafe.Pointer(c_wmclass_class))

	C.gtk_window_set_wmclass((*C.GtkWindow)(recv.native), c_wmclass_name, c_wmclass_class)

	return
}

// Asks to stick @window, which means that it will appear on all user
// desktops. Note that you shouldn’t assume the window is definitely
// stuck afterward, because other entities (e.g. the user or
// [window manager][gtk-X11-arch] could unstick it
// again, and some window managers do not support sticking
// windows. But normally the window will end up stuck. Just don't
// write code that crashes if not.
//
// It’s permitted to call this function before showing a window.
//
// You can track stickiness via the “window-state-event” signal
// on #GtkWidget.
/*

C function : gtk_window_stick
*/
func (recv *Window) Stick() {
	C.gtk_window_stick((*C.GtkWindow)(recv.native))

	return
}

// Asks to unmaximize @window. Note that you shouldn’t assume the
// window is definitely unmaximized afterward, because other entities
// (e.g. the user or [window manager][gtk-X11-arch])
// could maximize it again, and not all window
// managers honor requests to unmaximize. But normally the window will
// end up unmaximized. Just don’t write code that crashes if not.
//
// You can track maximization via the “window-state-event” signal
// on #GtkWidget.
/*

C function : gtk_window_unmaximize
*/
func (recv *Window) Unmaximize() {
	C.gtk_window_unmaximize((*C.GtkWindow)(recv.native))

	return
}

// Asks to unstick @window, which means that it will appear on only
// one of the user’s desktops. Note that you shouldn’t assume the
// window is definitely unstuck afterward, because other entities
// (e.g. the user or [window manager][gtk-X11-arch]) could
// stick it again. But normally the window will
// end up stuck. Just don’t write code that crashes if not.
//
// You can track stickiness via the “window-state-event” signal
// on #GtkWidget.
/*

C function : gtk_window_unstick
*/
func (recv *Window) Unstick() {
	C.gtk_window_unstick((*C.GtkWindow)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Window
func (recv *Window) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Window
func (recv *Window) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// WindowAccessible is a wrapper around the C record GtkWindowAccessible.
type WindowAccessible struct {
	native *C.GtkWindowAccessible
	// parent : record
	// priv : record
}

func WindowAccessibleNewFromC(u unsafe.Pointer) *WindowAccessible {
	c := (*C.GtkWindowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &WindowAccessible{native: c}

	return g
}

func (recv *WindowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *WindowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *WindowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *WindowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *WindowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitary Object to WindowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a WindowAccessible.
func CastToWindowAccessible(object *gobject.Object) *WindowAccessible {
	return WindowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by WindowAccessible
func (recv *WindowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Window returns the Window interface implemented by WindowAccessible
func (recv *WindowAccessible) Window() *atk.Window {
	return atk.WindowNewFromC(recv.ToC())
}

// WindowGroup is a wrapper around the C record GtkWindowGroup.
type WindowGroup struct {
	native *C.GtkWindowGroup
	// parent_instance : record
	// priv : record
}

func WindowGroupNewFromC(u unsafe.Pointer) *WindowGroup {
	c := (*C.GtkWindowGroup)(u)
	if c == nil {
		return nil
	}

	g := &WindowGroup{native: c}

	return g
}

func (recv *WindowGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Object upcasts to *Object
func (recv *WindowGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitary Object to WindowGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a WindowGroup.
func CastToWindowGroup(object *gobject.Object) *WindowGroup {
	return WindowGroupNewFromC(object.ToC())
}

// Creates a new #GtkWindowGroup object. Grabs added with
// gtk_grab_add() only affect windows within the same #GtkWindowGroup.
/*

C function : gtk_window_group_new
*/
func WindowGroupNew() *WindowGroup {
	retC := C.gtk_window_group_new()
	retGo := WindowGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Adds a window to a #GtkWindowGroup.
/*

C function : gtk_window_group_add_window
*/
func (recv *WindowGroup) AddWindow(window *Window) {
	c_window := (*C.GtkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GtkWindow)(window.ToC())
	}

	C.gtk_window_group_add_window((*C.GtkWindowGroup)(recv.native), c_window)

	return
}

// Removes a window from a #GtkWindowGroup.
/*

C function : gtk_window_group_remove_window
*/
func (recv *WindowGroup) RemoveWindow(window *Window) {
	c_window := (*C.GtkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GtkWindow)(window.ToC())
	}

	C.gtk_window_group_remove_window((*C.GtkWindowGroup)(recv.native), c_window)

	return
}
