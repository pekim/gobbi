// Code generated - DO NOT EDIT.

package gtk

import (
	gi "github.com/pekim/gobbi/internal/cgo/gi"
	atk "github.com/pekim/gobbi/lib/atk"
	cairo "github.com/pekim/gobbi/lib/cairo"
	gdk "github.com/pekim/gobbi/lib/gdk"
	gdkpixbuf "github.com/pekim/gobbi/lib/gdkpixbuf"
	gio "github.com/pekim/gobbi/lib/gio"
	glib "github.com/pekim/gobbi/lib/glib"
	gobject "github.com/pekim/gobbi/lib/gobject"
	pango "github.com/pekim/gobbi/lib/pango"
	"runtime"
	"sync"
	"unsafe"
)

var aboutDialogClassStruct *gi.Struct
var aboutDialogClassStruct_Once sync.Once

func aboutDialogClassStruct_Set() error {
	var err error
	aboutDialogClassStruct_Once.Do(func() {
		aboutDialogClassStruct, err = gi.StructNew("Gtk", "AboutDialogClass")
	})
	return err
}

type AboutDialogClass struct {
	native unsafe.Pointer
}

func AboutDialogClassNewFromNative(native unsafe.Pointer) *AboutDialogClass {
	err := aboutDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AboutDialogClass{native: native}

	return instance
}

/*
CastToAboutDialogClass down casts any arbitrary Object to AboutDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AboutDialogClass.
*/
func CastToAboutDialogClass(object *gobject.Object) *AboutDialogClass {
	return AboutDialogClassNewFromNative(object.Native())
}

// Equals compares this AboutDialogClass with another AboutDialogClass, and returns true if they represent the same Object.
func (recv *AboutDialogClass) Equals(other *AboutDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AboutDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AboutDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(aboutDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AboutDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(aboutDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'activate_link' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_link' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// AboutDialogClassStruct creates an uninitialised AboutDialogClass.
func AboutDialogClassStruct() *AboutDialogClass {
	err := aboutDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AboutDialogClassNewFromNative(aboutDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAboutDialogClass)
	return structGo
}
func finalizeAboutDialogClass(obj *AboutDialogClass) {
	aboutDialogClassStruct.Free(obj.Native())
}

var aboutDialogPrivateStruct *gi.Struct
var aboutDialogPrivateStruct_Once sync.Once

func aboutDialogPrivateStruct_Set() error {
	var err error
	aboutDialogPrivateStruct_Once.Do(func() {
		aboutDialogPrivateStruct, err = gi.StructNew("Gtk", "AboutDialogPrivate")
	})
	return err
}

type AboutDialogPrivate struct {
	native unsafe.Pointer
}

func AboutDialogPrivateNewFromNative(native unsafe.Pointer) *AboutDialogPrivate {
	err := aboutDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AboutDialogPrivate{native: native}

	return instance
}

/*
CastToAboutDialogPrivate down casts any arbitrary Object to AboutDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AboutDialogPrivate.
*/
func CastToAboutDialogPrivate(object *gobject.Object) *AboutDialogPrivate {
	return AboutDialogPrivateNewFromNative(object.Native())
}

// Equals compares this AboutDialogPrivate with another AboutDialogPrivate, and returns true if they represent the same Object.
func (recv *AboutDialogPrivate) Equals(other *AboutDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AboutDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AboutDialogPrivateStruct creates an uninitialised AboutDialogPrivate.
func AboutDialogPrivateStruct() *AboutDialogPrivate {
	err := aboutDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AboutDialogPrivateNewFromNative(aboutDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAboutDialogPrivate)
	return structGo
}
func finalizeAboutDialogPrivate(obj *AboutDialogPrivate) {
	aboutDialogPrivateStruct.Free(obj.Native())
}

var accelGroupClassStruct *gi.Struct
var accelGroupClassStruct_Once sync.Once

func accelGroupClassStruct_Set() error {
	var err error
	accelGroupClassStruct_Once.Do(func() {
		accelGroupClassStruct, err = gi.StructNew("Gtk", "AccelGroupClass")
	})
	return err
}

type AccelGroupClass struct {
	native unsafe.Pointer
}

func AccelGroupClassNewFromNative(native unsafe.Pointer) *AccelGroupClass {
	err := accelGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccelGroupClass{native: native}

	return instance
}

/*
CastToAccelGroupClass down casts any arbitrary Object to AccelGroupClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccelGroupClass.
*/
func CastToAccelGroupClass(object *gobject.Object) *AccelGroupClass {
	return AccelGroupClassNewFromNative(object.Native())
}

// Equals compares this AccelGroupClass with another AccelGroupClass, and returns true if they represent the same Object.
func (recv *AccelGroupClass) Equals(other *AccelGroupClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AccelGroupClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AccelGroupClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(accelGroupClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AccelGroupClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(accelGroupClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'accel_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'accel_changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// AccelGroupClassStruct creates an uninitialised AccelGroupClass.
func AccelGroupClassStruct() *AccelGroupClass {
	err := accelGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccelGroupClassNewFromNative(accelGroupClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccelGroupClass)
	return structGo
}
func finalizeAccelGroupClass(obj *AccelGroupClass) {
	accelGroupClassStruct.Free(obj.Native())
}

var accelGroupEntryStruct *gi.Struct
var accelGroupEntryStruct_Once sync.Once

func accelGroupEntryStruct_Set() error {
	var err error
	accelGroupEntryStruct_Once.Do(func() {
		accelGroupEntryStruct, err = gi.StructNew("Gtk", "AccelGroupEntry")
	})
	return err
}

type AccelGroupEntry struct {
	native unsafe.Pointer
}

func AccelGroupEntryNewFromNative(native unsafe.Pointer) *AccelGroupEntry {
	err := accelGroupEntryStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccelGroupEntry{native: native}

	return instance
}

/*
CastToAccelGroupEntry down casts any arbitrary Object to AccelGroupEntry.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccelGroupEntry.
*/
func CastToAccelGroupEntry(object *gobject.Object) *AccelGroupEntry {
	return AccelGroupEntryNewFromNative(object.Native())
}

// Equals compares this AccelGroupEntry with another AccelGroupEntry, and returns true if they represent the same Object.
func (recv *AccelGroupEntry) Equals(other *AccelGroupEntry) bool {
	return other.Native() == recv.Native()
}

func (recv *AccelGroupEntry) Native() unsafe.Pointer {
	return recv.native
}

// FieldKey returns the C field 'key'.
func (recv *AccelGroupEntry) FieldKey() *AccelKey {
	argValue := gi.StructFieldGet(accelGroupEntryStruct, recv.Native(), "key")
	value := AccelKeyNewFromNative(argValue.Pointer())
	return value
}

// SetFieldKey sets the value of the C field 'key'.
func (recv *AccelGroupEntry) SetFieldKey(value *AccelKey) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(accelGroupEntryStruct, recv.Native(), "key", argValue)
}

// FieldClosure returns the C field 'closure'.
func (recv *AccelGroupEntry) FieldClosure() *gobject.Closure {
	argValue := gi.StructFieldGet(accelGroupEntryStruct, recv.Native(), "closure")
	value := gobject.ClosureNewFromNative(argValue.Pointer())
	return value
}

// SetFieldClosure sets the value of the C field 'closure'.
func (recv *AccelGroupEntry) SetFieldClosure(value *gobject.Closure) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(accelGroupEntryStruct, recv.Native(), "closure", argValue)
}

// FieldAccelPathQuark returns the C field 'accel_path_quark'.
func (recv *AccelGroupEntry) FieldAccelPathQuark() glib.Quark {
	argValue := gi.StructFieldGet(accelGroupEntryStruct, recv.Native(), "accel_path_quark")
	value := glib.Quark(argValue.Uint32())
	return value
}

// SetFieldAccelPathQuark sets the value of the C field 'accel_path_quark'.
func (recv *AccelGroupEntry) SetFieldAccelPathQuark(value glib.Quark) {
	var argValue gi.Argument
	argValue.SetUint32(uint32(value))
	gi.StructFieldSet(accelGroupEntryStruct, recv.Native(), "accel_path_quark", argValue)
}

// AccelGroupEntryStruct creates an uninitialised AccelGroupEntry.
func AccelGroupEntryStruct() *AccelGroupEntry {
	err := accelGroupEntryStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccelGroupEntryNewFromNative(accelGroupEntryStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccelGroupEntry)
	return structGo
}
func finalizeAccelGroupEntry(obj *AccelGroupEntry) {
	accelGroupEntryStruct.Free(obj.Native())
}

var accelGroupPrivateStruct *gi.Struct
var accelGroupPrivateStruct_Once sync.Once

func accelGroupPrivateStruct_Set() error {
	var err error
	accelGroupPrivateStruct_Once.Do(func() {
		accelGroupPrivateStruct, err = gi.StructNew("Gtk", "AccelGroupPrivate")
	})
	return err
}

type AccelGroupPrivate struct {
	native unsafe.Pointer
}

func AccelGroupPrivateNewFromNative(native unsafe.Pointer) *AccelGroupPrivate {
	err := accelGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccelGroupPrivate{native: native}

	return instance
}

/*
CastToAccelGroupPrivate down casts any arbitrary Object to AccelGroupPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccelGroupPrivate.
*/
func CastToAccelGroupPrivate(object *gobject.Object) *AccelGroupPrivate {
	return AccelGroupPrivateNewFromNative(object.Native())
}

// Equals compares this AccelGroupPrivate with another AccelGroupPrivate, and returns true if they represent the same Object.
func (recv *AccelGroupPrivate) Equals(other *AccelGroupPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AccelGroupPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AccelGroupPrivateStruct creates an uninitialised AccelGroupPrivate.
func AccelGroupPrivateStruct() *AccelGroupPrivate {
	err := accelGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccelGroupPrivateNewFromNative(accelGroupPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccelGroupPrivate)
	return structGo
}
func finalizeAccelGroupPrivate(obj *AccelGroupPrivate) {
	accelGroupPrivateStruct.Free(obj.Native())
}

var accelKeyStruct *gi.Struct
var accelKeyStruct_Once sync.Once

func accelKeyStruct_Set() error {
	var err error
	accelKeyStruct_Once.Do(func() {
		accelKeyStruct, err = gi.StructNew("Gtk", "AccelKey")
	})
	return err
}

type AccelKey struct {
	native unsafe.Pointer
}

func AccelKeyNewFromNative(native unsafe.Pointer) *AccelKey {
	err := accelKeyStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccelKey{native: native}

	return instance
}

/*
CastToAccelKey down casts any arbitrary Object to AccelKey.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccelKey.
*/
func CastToAccelKey(object *gobject.Object) *AccelKey {
	return AccelKeyNewFromNative(object.Native())
}

// Equals compares this AccelKey with another AccelKey, and returns true if they represent the same Object.
func (recv *AccelKey) Equals(other *AccelKey) bool {
	return other.Native() == recv.Native()
}

func (recv *AccelKey) Native() unsafe.Pointer {
	return recv.native
}

// FieldAccelKey returns the C field 'accel_key'.
func (recv *AccelKey) FieldAccelKey() uint32 {
	argValue := gi.StructFieldGet(accelKeyStruct, recv.Native(), "accel_key")
	value := argValue.Uint32()
	return value
}

// SetFieldAccelKey sets the value of the C field 'accel_key'.
func (recv *AccelKey) SetFieldAccelKey(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(accelKeyStruct, recv.Native(), "accel_key", argValue)
}

// UNSUPPORTED : C value 'accel_mods' : for field getter : no Go type for 'Gdk.ModifierType'

// UNSUPPORTED : C value 'accel_mods' : for field setter : no Go type for 'Gdk.ModifierType'

// FieldAccelFlags returns the C field 'accel_flags'.
func (recv *AccelKey) FieldAccelFlags() uint32 {
	argValue := gi.StructFieldGet(accelKeyStruct, recv.Native(), "accel_flags")
	value := argValue.Uint32()
	return value
}

// SetFieldAccelFlags sets the value of the C field 'accel_flags'.
func (recv *AccelKey) SetFieldAccelFlags(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(accelKeyStruct, recv.Native(), "accel_flags", argValue)
}

// AccelKeyStruct creates an uninitialised AccelKey.
func AccelKeyStruct() *AccelKey {
	err := accelKeyStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccelKeyNewFromNative(accelKeyStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccelKey)
	return structGo
}
func finalizeAccelKey(obj *AccelKey) {
	accelKeyStruct.Free(obj.Native())
}

var accelLabelClassStruct *gi.Struct
var accelLabelClassStruct_Once sync.Once

func accelLabelClassStruct_Set() error {
	var err error
	accelLabelClassStruct_Once.Do(func() {
		accelLabelClassStruct, err = gi.StructNew("Gtk", "AccelLabelClass")
	})
	return err
}

type AccelLabelClass struct {
	native unsafe.Pointer
}

func AccelLabelClassNewFromNative(native unsafe.Pointer) *AccelLabelClass {
	err := accelLabelClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccelLabelClass{native: native}

	return instance
}

/*
CastToAccelLabelClass down casts any arbitrary Object to AccelLabelClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccelLabelClass.
*/
func CastToAccelLabelClass(object *gobject.Object) *AccelLabelClass {
	return AccelLabelClassNewFromNative(object.Native())
}

// Equals compares this AccelLabelClass with another AccelLabelClass, and returns true if they represent the same Object.
func (recv *AccelLabelClass) Equals(other *AccelLabelClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AccelLabelClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AccelLabelClass) FieldParentClass() *LabelClass {
	argValue := gi.StructFieldGet(accelLabelClassStruct, recv.Native(), "parent_class")
	value := LabelClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AccelLabelClass) SetFieldParentClass(value *LabelClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(accelLabelClassStruct, recv.Native(), "parent_class", argValue)
}

// FieldSignalQuote1 returns the C field 'signal_quote1'.
func (recv *AccelLabelClass) FieldSignalQuote1() string {
	argValue := gi.StructFieldGet(accelLabelClassStruct, recv.Native(), "signal_quote1")
	value := argValue.String(false)
	return value
}

// SetFieldSignalQuote1 sets the value of the C field 'signal_quote1'.
func (recv *AccelLabelClass) SetFieldSignalQuote1(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(accelLabelClassStruct, recv.Native(), "signal_quote1", argValue)
}

// FieldSignalQuote2 returns the C field 'signal_quote2'.
func (recv *AccelLabelClass) FieldSignalQuote2() string {
	argValue := gi.StructFieldGet(accelLabelClassStruct, recv.Native(), "signal_quote2")
	value := argValue.String(false)
	return value
}

// SetFieldSignalQuote2 sets the value of the C field 'signal_quote2'.
func (recv *AccelLabelClass) SetFieldSignalQuote2(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(accelLabelClassStruct, recv.Native(), "signal_quote2", argValue)
}

// FieldModNameShift returns the C field 'mod_name_shift'.
func (recv *AccelLabelClass) FieldModNameShift() string {
	argValue := gi.StructFieldGet(accelLabelClassStruct, recv.Native(), "mod_name_shift")
	value := argValue.String(false)
	return value
}

// SetFieldModNameShift sets the value of the C field 'mod_name_shift'.
func (recv *AccelLabelClass) SetFieldModNameShift(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(accelLabelClassStruct, recv.Native(), "mod_name_shift", argValue)
}

// FieldModNameControl returns the C field 'mod_name_control'.
func (recv *AccelLabelClass) FieldModNameControl() string {
	argValue := gi.StructFieldGet(accelLabelClassStruct, recv.Native(), "mod_name_control")
	value := argValue.String(false)
	return value
}

// SetFieldModNameControl sets the value of the C field 'mod_name_control'.
func (recv *AccelLabelClass) SetFieldModNameControl(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(accelLabelClassStruct, recv.Native(), "mod_name_control", argValue)
}

// FieldModNameAlt returns the C field 'mod_name_alt'.
func (recv *AccelLabelClass) FieldModNameAlt() string {
	argValue := gi.StructFieldGet(accelLabelClassStruct, recv.Native(), "mod_name_alt")
	value := argValue.String(false)
	return value
}

// SetFieldModNameAlt sets the value of the C field 'mod_name_alt'.
func (recv *AccelLabelClass) SetFieldModNameAlt(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(accelLabelClassStruct, recv.Native(), "mod_name_alt", argValue)
}

// FieldModSeparator returns the C field 'mod_separator'.
func (recv *AccelLabelClass) FieldModSeparator() string {
	argValue := gi.StructFieldGet(accelLabelClassStruct, recv.Native(), "mod_separator")
	value := argValue.String(false)
	return value
}

// SetFieldModSeparator sets the value of the C field 'mod_separator'.
func (recv *AccelLabelClass) SetFieldModSeparator(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(accelLabelClassStruct, recv.Native(), "mod_separator", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// AccelLabelClassStruct creates an uninitialised AccelLabelClass.
func AccelLabelClassStruct() *AccelLabelClass {
	err := accelLabelClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccelLabelClassNewFromNative(accelLabelClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccelLabelClass)
	return structGo
}
func finalizeAccelLabelClass(obj *AccelLabelClass) {
	accelLabelClassStruct.Free(obj.Native())
}

var accelLabelPrivateStruct *gi.Struct
var accelLabelPrivateStruct_Once sync.Once

func accelLabelPrivateStruct_Set() error {
	var err error
	accelLabelPrivateStruct_Once.Do(func() {
		accelLabelPrivateStruct, err = gi.StructNew("Gtk", "AccelLabelPrivate")
	})
	return err
}

type AccelLabelPrivate struct {
	native unsafe.Pointer
}

func AccelLabelPrivateNewFromNative(native unsafe.Pointer) *AccelLabelPrivate {
	err := accelLabelPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccelLabelPrivate{native: native}

	return instance
}

/*
CastToAccelLabelPrivate down casts any arbitrary Object to AccelLabelPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccelLabelPrivate.
*/
func CastToAccelLabelPrivate(object *gobject.Object) *AccelLabelPrivate {
	return AccelLabelPrivateNewFromNative(object.Native())
}

// Equals compares this AccelLabelPrivate with another AccelLabelPrivate, and returns true if they represent the same Object.
func (recv *AccelLabelPrivate) Equals(other *AccelLabelPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AccelLabelPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AccelLabelPrivateStruct creates an uninitialised AccelLabelPrivate.
func AccelLabelPrivateStruct() *AccelLabelPrivate {
	err := accelLabelPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccelLabelPrivateNewFromNative(accelLabelPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccelLabelPrivate)
	return structGo
}
func finalizeAccelLabelPrivate(obj *AccelLabelPrivate) {
	accelLabelPrivateStruct.Free(obj.Native())
}

var accelMapClassStruct *gi.Struct
var accelMapClassStruct_Once sync.Once

func accelMapClassStruct_Set() error {
	var err error
	accelMapClassStruct_Once.Do(func() {
		accelMapClassStruct, err = gi.StructNew("Gtk", "AccelMapClass")
	})
	return err
}

type AccelMapClass struct {
	native unsafe.Pointer
}

func AccelMapClassNewFromNative(native unsafe.Pointer) *AccelMapClass {
	err := accelMapClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccelMapClass{native: native}

	return instance
}

/*
CastToAccelMapClass down casts any arbitrary Object to AccelMapClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccelMapClass.
*/
func CastToAccelMapClass(object *gobject.Object) *AccelMapClass {
	return AccelMapClassNewFromNative(object.Native())
}

// Equals compares this AccelMapClass with another AccelMapClass, and returns true if they represent the same Object.
func (recv *AccelMapClass) Equals(other *AccelMapClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AccelMapClass) Native() unsafe.Pointer {
	return recv.native
}

// AccelMapClassStruct creates an uninitialised AccelMapClass.
func AccelMapClassStruct() *AccelMapClass {
	err := accelMapClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccelMapClassNewFromNative(accelMapClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccelMapClass)
	return structGo
}
func finalizeAccelMapClass(obj *AccelMapClass) {
	accelMapClassStruct.Free(obj.Native())
}

var accessibleClassStruct *gi.Struct
var accessibleClassStruct_Once sync.Once

func accessibleClassStruct_Set() error {
	var err error
	accessibleClassStruct_Once.Do(func() {
		accessibleClassStruct, err = gi.StructNew("Gtk", "AccessibleClass")
	})
	return err
}

type AccessibleClass struct {
	native unsafe.Pointer
}

func AccessibleClassNewFromNative(native unsafe.Pointer) *AccessibleClass {
	err := accessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccessibleClass{native: native}

	return instance
}

/*
CastToAccessibleClass down casts any arbitrary Object to AccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccessibleClass.
*/
func CastToAccessibleClass(object *gobject.Object) *AccessibleClass {
	return AccessibleClassNewFromNative(object.Native())
}

// Equals compares this AccessibleClass with another AccessibleClass, and returns true if they represent the same Object.
func (recv *AccessibleClass) Equals(other *AccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AccessibleClass) FieldParentClass() *atk.ObjectClass {
	argValue := gi.StructFieldGet(accessibleClassStruct, recv.Native(), "parent_class")
	value := atk.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AccessibleClass) SetFieldParentClass(value *atk.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(accessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'connect_widget_destroyed' : for field getter : missing Type

// UNSUPPORTED : C value 'connect_widget_destroyed' : for field setter : missing Type

// UNSUPPORTED : C value 'widget_set' : for field getter : missing Type

// UNSUPPORTED : C value 'widget_set' : for field setter : missing Type

// UNSUPPORTED : C value 'widget_unset' : for field getter : missing Type

// UNSUPPORTED : C value 'widget_unset' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// AccessibleClassStruct creates an uninitialised AccessibleClass.
func AccessibleClassStruct() *AccessibleClass {
	err := accessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccessibleClassNewFromNative(accessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccessibleClass)
	return structGo
}
func finalizeAccessibleClass(obj *AccessibleClass) {
	accessibleClassStruct.Free(obj.Native())
}

var accessiblePrivateStruct *gi.Struct
var accessiblePrivateStruct_Once sync.Once

func accessiblePrivateStruct_Set() error {
	var err error
	accessiblePrivateStruct_Once.Do(func() {
		accessiblePrivateStruct, err = gi.StructNew("Gtk", "AccessiblePrivate")
	})
	return err
}

type AccessiblePrivate struct {
	native unsafe.Pointer
}

func AccessiblePrivateNewFromNative(native unsafe.Pointer) *AccessiblePrivate {
	err := accessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AccessiblePrivate{native: native}

	return instance
}

/*
CastToAccessiblePrivate down casts any arbitrary Object to AccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AccessiblePrivate.
*/
func CastToAccessiblePrivate(object *gobject.Object) *AccessiblePrivate {
	return AccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this AccessiblePrivate with another AccessiblePrivate, and returns true if they represent the same Object.
func (recv *AccessiblePrivate) Equals(other *AccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// AccessiblePrivateStruct creates an uninitialised AccessiblePrivate.
func AccessiblePrivateStruct() *AccessiblePrivate {
	err := accessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AccessiblePrivateNewFromNative(accessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAccessiblePrivate)
	return structGo
}
func finalizeAccessiblePrivate(obj *AccessiblePrivate) {
	accessiblePrivateStruct.Free(obj.Native())
}

var actionBarClassStruct *gi.Struct
var actionBarClassStruct_Once sync.Once

func actionBarClassStruct_Set() error {
	var err error
	actionBarClassStruct_Once.Do(func() {
		actionBarClassStruct, err = gi.StructNew("Gtk", "ActionBarClass")
	})
	return err
}

type ActionBarClass struct {
	native unsafe.Pointer
}

func ActionBarClassNewFromNative(native unsafe.Pointer) *ActionBarClass {
	err := actionBarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActionBarClass{native: native}

	return instance
}

/*
CastToActionBarClass down casts any arbitrary Object to ActionBarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActionBarClass.
*/
func CastToActionBarClass(object *gobject.Object) *ActionBarClass {
	return ActionBarClassNewFromNative(object.Native())
}

// Equals compares this ActionBarClass with another ActionBarClass, and returns true if they represent the same Object.
func (recv *ActionBarClass) Equals(other *ActionBarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ActionBarClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ActionBarClassStruct creates an uninitialised ActionBarClass.
func ActionBarClassStruct() *ActionBarClass {
	err := actionBarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActionBarClassNewFromNative(actionBarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActionBarClass)
	return structGo
}
func finalizeActionBarClass(obj *ActionBarClass) {
	actionBarClassStruct.Free(obj.Native())
}

var actionBarPrivateStruct *gi.Struct
var actionBarPrivateStruct_Once sync.Once

func actionBarPrivateStruct_Set() error {
	var err error
	actionBarPrivateStruct_Once.Do(func() {
		actionBarPrivateStruct, err = gi.StructNew("Gtk", "ActionBarPrivate")
	})
	return err
}

type ActionBarPrivate struct {
	native unsafe.Pointer
}

func ActionBarPrivateNewFromNative(native unsafe.Pointer) *ActionBarPrivate {
	err := actionBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActionBarPrivate{native: native}

	return instance
}

/*
CastToActionBarPrivate down casts any arbitrary Object to ActionBarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActionBarPrivate.
*/
func CastToActionBarPrivate(object *gobject.Object) *ActionBarPrivate {
	return ActionBarPrivateNewFromNative(object.Native())
}

// Equals compares this ActionBarPrivate with another ActionBarPrivate, and returns true if they represent the same Object.
func (recv *ActionBarPrivate) Equals(other *ActionBarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ActionBarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ActionBarPrivateStruct creates an uninitialised ActionBarPrivate.
func ActionBarPrivateStruct() *ActionBarPrivate {
	err := actionBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActionBarPrivateNewFromNative(actionBarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActionBarPrivate)
	return structGo
}
func finalizeActionBarPrivate(obj *ActionBarPrivate) {
	actionBarPrivateStruct.Free(obj.Native())
}

var actionClassStruct *gi.Struct
var actionClassStruct_Once sync.Once

func actionClassStruct_Set() error {
	var err error
	actionClassStruct_Once.Do(func() {
		actionClassStruct, err = gi.StructNew("Gtk", "ActionClass")
	})
	return err
}

type ActionClass struct {
	native unsafe.Pointer
}

func ActionClassNewFromNative(native unsafe.Pointer) *ActionClass {
	err := actionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActionClass{native: native}

	return instance
}

/*
CastToActionClass down casts any arbitrary Object to ActionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActionClass.
*/
func CastToActionClass(object *gobject.Object) *ActionClass {
	return ActionClassNewFromNative(object.Native())
}

// Equals compares this ActionClass with another ActionClass, and returns true if they represent the same Object.
func (recv *ActionClass) Equals(other *ActionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ActionClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ActionClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(actionClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ActionClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(actionClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value 'create_menu_item' : for field getter : missing Type

// UNSUPPORTED : C value 'create_menu_item' : for field setter : missing Type

// UNSUPPORTED : C value 'create_tool_item' : for field getter : missing Type

// UNSUPPORTED : C value 'create_tool_item' : for field setter : missing Type

// UNSUPPORTED : C value 'connect_proxy' : for field getter : missing Type

// UNSUPPORTED : C value 'connect_proxy' : for field setter : missing Type

// UNSUPPORTED : C value 'disconnect_proxy' : for field getter : missing Type

// UNSUPPORTED : C value 'disconnect_proxy' : for field setter : missing Type

// UNSUPPORTED : C value 'create_menu' : for field getter : missing Type

// UNSUPPORTED : C value 'create_menu' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ActionClassStruct creates an uninitialised ActionClass.
func ActionClassStruct() *ActionClass {
	err := actionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActionClassNewFromNative(actionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActionClass)
	return structGo
}
func finalizeActionClass(obj *ActionClass) {
	actionClassStruct.Free(obj.Native())
}

var actionEntryStruct *gi.Struct
var actionEntryStruct_Once sync.Once

func actionEntryStruct_Set() error {
	var err error
	actionEntryStruct_Once.Do(func() {
		actionEntryStruct, err = gi.StructNew("Gtk", "ActionEntry")
	})
	return err
}

type ActionEntry struct {
	native unsafe.Pointer
}

func ActionEntryNewFromNative(native unsafe.Pointer) *ActionEntry {
	err := actionEntryStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActionEntry{native: native}

	return instance
}

/*
CastToActionEntry down casts any arbitrary Object to ActionEntry.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActionEntry.
*/
func CastToActionEntry(object *gobject.Object) *ActionEntry {
	return ActionEntryNewFromNative(object.Native())
}

// Equals compares this ActionEntry with another ActionEntry, and returns true if they represent the same Object.
func (recv *ActionEntry) Equals(other *ActionEntry) bool {
	return other.Native() == recv.Native()
}

func (recv *ActionEntry) Native() unsafe.Pointer {
	return recv.native
}

// FieldName returns the C field 'name'.
func (recv *ActionEntry) FieldName() string {
	argValue := gi.StructFieldGet(actionEntryStruct, recv.Native(), "name")
	value := argValue.String(false)
	return value
}

// SetFieldName sets the value of the C field 'name'.
func (recv *ActionEntry) SetFieldName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(actionEntryStruct, recv.Native(), "name", argValue)
}

// FieldStockId returns the C field 'stock_id'.
func (recv *ActionEntry) FieldStockId() string {
	argValue := gi.StructFieldGet(actionEntryStruct, recv.Native(), "stock_id")
	value := argValue.String(false)
	return value
}

// SetFieldStockId sets the value of the C field 'stock_id'.
func (recv *ActionEntry) SetFieldStockId(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(actionEntryStruct, recv.Native(), "stock_id", argValue)
}

// FieldLabel returns the C field 'label'.
func (recv *ActionEntry) FieldLabel() string {
	argValue := gi.StructFieldGet(actionEntryStruct, recv.Native(), "label")
	value := argValue.String(false)
	return value
}

// SetFieldLabel sets the value of the C field 'label'.
func (recv *ActionEntry) SetFieldLabel(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(actionEntryStruct, recv.Native(), "label", argValue)
}

// FieldAccelerator returns the C field 'accelerator'.
func (recv *ActionEntry) FieldAccelerator() string {
	argValue := gi.StructFieldGet(actionEntryStruct, recv.Native(), "accelerator")
	value := argValue.String(false)
	return value
}

// SetFieldAccelerator sets the value of the C field 'accelerator'.
func (recv *ActionEntry) SetFieldAccelerator(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(actionEntryStruct, recv.Native(), "accelerator", argValue)
}

// FieldTooltip returns the C field 'tooltip'.
func (recv *ActionEntry) FieldTooltip() string {
	argValue := gi.StructFieldGet(actionEntryStruct, recv.Native(), "tooltip")
	value := argValue.String(false)
	return value
}

// SetFieldTooltip sets the value of the C field 'tooltip'.
func (recv *ActionEntry) SetFieldTooltip(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(actionEntryStruct, recv.Native(), "tooltip", argValue)
}

// UNSUPPORTED : C value 'callback' : for field getter : no Go type for 'GObject.Callback'

// UNSUPPORTED : C value 'callback' : for field setter : no Go type for 'GObject.Callback'

// ActionEntryStruct creates an uninitialised ActionEntry.
func ActionEntryStruct() *ActionEntry {
	err := actionEntryStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActionEntryNewFromNative(actionEntryStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActionEntry)
	return structGo
}
func finalizeActionEntry(obj *ActionEntry) {
	actionEntryStruct.Free(obj.Native())
}

var actionGroupClassStruct *gi.Struct
var actionGroupClassStruct_Once sync.Once

func actionGroupClassStruct_Set() error {
	var err error
	actionGroupClassStruct_Once.Do(func() {
		actionGroupClassStruct, err = gi.StructNew("Gtk", "ActionGroupClass")
	})
	return err
}

type ActionGroupClass struct {
	native unsafe.Pointer
}

func ActionGroupClassNewFromNative(native unsafe.Pointer) *ActionGroupClass {
	err := actionGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActionGroupClass{native: native}

	return instance
}

/*
CastToActionGroupClass down casts any arbitrary Object to ActionGroupClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActionGroupClass.
*/
func CastToActionGroupClass(object *gobject.Object) *ActionGroupClass {
	return ActionGroupClassNewFromNative(object.Native())
}

// Equals compares this ActionGroupClass with another ActionGroupClass, and returns true if they represent the same Object.
func (recv *ActionGroupClass) Equals(other *ActionGroupClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ActionGroupClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ActionGroupClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(actionGroupClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ActionGroupClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(actionGroupClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'get_action' : for field getter : missing Type

// UNSUPPORTED : C value 'get_action' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ActionGroupClassStruct creates an uninitialised ActionGroupClass.
func ActionGroupClassStruct() *ActionGroupClass {
	err := actionGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActionGroupClassNewFromNative(actionGroupClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActionGroupClass)
	return structGo
}
func finalizeActionGroupClass(obj *ActionGroupClass) {
	actionGroupClassStruct.Free(obj.Native())
}

var actionGroupPrivateStruct *gi.Struct
var actionGroupPrivateStruct_Once sync.Once

func actionGroupPrivateStruct_Set() error {
	var err error
	actionGroupPrivateStruct_Once.Do(func() {
		actionGroupPrivateStruct, err = gi.StructNew("Gtk", "ActionGroupPrivate")
	})
	return err
}

type ActionGroupPrivate struct {
	native unsafe.Pointer
}

func ActionGroupPrivateNewFromNative(native unsafe.Pointer) *ActionGroupPrivate {
	err := actionGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActionGroupPrivate{native: native}

	return instance
}

/*
CastToActionGroupPrivate down casts any arbitrary Object to ActionGroupPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActionGroupPrivate.
*/
func CastToActionGroupPrivate(object *gobject.Object) *ActionGroupPrivate {
	return ActionGroupPrivateNewFromNative(object.Native())
}

// Equals compares this ActionGroupPrivate with another ActionGroupPrivate, and returns true if they represent the same Object.
func (recv *ActionGroupPrivate) Equals(other *ActionGroupPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ActionGroupPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ActionGroupPrivateStruct creates an uninitialised ActionGroupPrivate.
func ActionGroupPrivateStruct() *ActionGroupPrivate {
	err := actionGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActionGroupPrivateNewFromNative(actionGroupPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActionGroupPrivate)
	return structGo
}
func finalizeActionGroupPrivate(obj *ActionGroupPrivate) {
	actionGroupPrivateStruct.Free(obj.Native())
}

var actionPrivateStruct *gi.Struct
var actionPrivateStruct_Once sync.Once

func actionPrivateStruct_Set() error {
	var err error
	actionPrivateStruct_Once.Do(func() {
		actionPrivateStruct, err = gi.StructNew("Gtk", "ActionPrivate")
	})
	return err
}

type ActionPrivate struct {
	native unsafe.Pointer
}

func ActionPrivateNewFromNative(native unsafe.Pointer) *ActionPrivate {
	err := actionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActionPrivate{native: native}

	return instance
}

/*
CastToActionPrivate down casts any arbitrary Object to ActionPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActionPrivate.
*/
func CastToActionPrivate(object *gobject.Object) *ActionPrivate {
	return ActionPrivateNewFromNative(object.Native())
}

// Equals compares this ActionPrivate with another ActionPrivate, and returns true if they represent the same Object.
func (recv *ActionPrivate) Equals(other *ActionPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ActionPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ActionPrivateStruct creates an uninitialised ActionPrivate.
func ActionPrivateStruct() *ActionPrivate {
	err := actionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActionPrivateNewFromNative(actionPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActionPrivate)
	return structGo
}
func finalizeActionPrivate(obj *ActionPrivate) {
	actionPrivateStruct.Free(obj.Native())
}

var actionableInterfaceStruct *gi.Struct
var actionableInterfaceStruct_Once sync.Once

func actionableInterfaceStruct_Set() error {
	var err error
	actionableInterfaceStruct_Once.Do(func() {
		actionableInterfaceStruct, err = gi.StructNew("Gtk", "ActionableInterface")
	})
	return err
}

type ActionableInterface struct {
	native unsafe.Pointer
}

func ActionableInterfaceNewFromNative(native unsafe.Pointer) *ActionableInterface {
	err := actionableInterfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActionableInterface{native: native}

	return instance
}

/*
CastToActionableInterface down casts any arbitrary Object to ActionableInterface.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActionableInterface.
*/
func CastToActionableInterface(object *gobject.Object) *ActionableInterface {
	return ActionableInterfaceNewFromNative(object.Native())
}

// Equals compares this ActionableInterface with another ActionableInterface, and returns true if they represent the same Object.
func (recv *ActionableInterface) Equals(other *ActionableInterface) bool {
	return other.Native() == recv.Native()
}

func (recv *ActionableInterface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'get_action_name' : for field getter : missing Type

// UNSUPPORTED : C value 'get_action_name' : for field setter : missing Type

// UNSUPPORTED : C value 'set_action_name' : for field getter : missing Type

// UNSUPPORTED : C value 'set_action_name' : for field setter : missing Type

// UNSUPPORTED : C value 'get_action_target_value' : for field getter : missing Type

// UNSUPPORTED : C value 'get_action_target_value' : for field setter : missing Type

// UNSUPPORTED : C value 'set_action_target_value' : for field getter : missing Type

// UNSUPPORTED : C value 'set_action_target_value' : for field setter : missing Type

// ActionableInterfaceStruct creates an uninitialised ActionableInterface.
func ActionableInterfaceStruct() *ActionableInterface {
	err := actionableInterfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActionableInterfaceNewFromNative(actionableInterfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActionableInterface)
	return structGo
}
func finalizeActionableInterface(obj *ActionableInterface) {
	actionableInterfaceStruct.Free(obj.Native())
}

var activatableIfaceStruct *gi.Struct
var activatableIfaceStruct_Once sync.Once

func activatableIfaceStruct_Set() error {
	var err error
	activatableIfaceStruct_Once.Do(func() {
		activatableIfaceStruct, err = gi.StructNew("Gtk", "ActivatableIface")
	})
	return err
}

type ActivatableIface struct {
	native unsafe.Pointer
}

func ActivatableIfaceNewFromNative(native unsafe.Pointer) *ActivatableIface {
	err := activatableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ActivatableIface{native: native}

	return instance
}

/*
CastToActivatableIface down casts any arbitrary Object to ActivatableIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a ActivatableIface.
*/
func CastToActivatableIface(object *gobject.Object) *ActivatableIface {
	return ActivatableIfaceNewFromNative(object.Native())
}

// Equals compares this ActivatableIface with another ActivatableIface, and returns true if they represent the same Object.
func (recv *ActivatableIface) Equals(other *ActivatableIface) bool {
	return other.Native() == recv.Native()
}

func (recv *ActivatableIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'update' : for field getter : missing Type

// UNSUPPORTED : C value 'update' : for field setter : missing Type

// UNSUPPORTED : C value 'sync_action_properties' : for field getter : missing Type

// UNSUPPORTED : C value 'sync_action_properties' : for field setter : missing Type

// ActivatableIfaceStruct creates an uninitialised ActivatableIface.
func ActivatableIfaceStruct() *ActivatableIface {
	err := activatableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ActivatableIfaceNewFromNative(activatableIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeActivatableIface)
	return structGo
}
func finalizeActivatableIface(obj *ActivatableIface) {
	activatableIfaceStruct.Free(obj.Native())
}

var adjustmentClassStruct *gi.Struct
var adjustmentClassStruct_Once sync.Once

func adjustmentClassStruct_Set() error {
	var err error
	adjustmentClassStruct_Once.Do(func() {
		adjustmentClassStruct, err = gi.StructNew("Gtk", "AdjustmentClass")
	})
	return err
}

type AdjustmentClass struct {
	native unsafe.Pointer
}

func AdjustmentClassNewFromNative(native unsafe.Pointer) *AdjustmentClass {
	err := adjustmentClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AdjustmentClass{native: native}

	return instance
}

/*
CastToAdjustmentClass down casts any arbitrary Object to AdjustmentClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AdjustmentClass.
*/
func CastToAdjustmentClass(object *gobject.Object) *AdjustmentClass {
	return AdjustmentClassNewFromNative(object.Native())
}

// Equals compares this AdjustmentClass with another AdjustmentClass, and returns true if they represent the same Object.
func (recv *AdjustmentClass) Equals(other *AdjustmentClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AdjustmentClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AdjustmentClass) FieldParentClass() *gobject.InitiallyUnownedClass {
	argValue := gi.StructFieldGet(adjustmentClassStruct, recv.Native(), "parent_class")
	value := gobject.InitiallyUnownedClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AdjustmentClass) SetFieldParentClass(value *gobject.InitiallyUnownedClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(adjustmentClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value 'value_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'value_changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// AdjustmentClassStruct creates an uninitialised AdjustmentClass.
func AdjustmentClassStruct() *AdjustmentClass {
	err := adjustmentClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AdjustmentClassNewFromNative(adjustmentClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAdjustmentClass)
	return structGo
}
func finalizeAdjustmentClass(obj *AdjustmentClass) {
	adjustmentClassStruct.Free(obj.Native())
}

var adjustmentPrivateStruct *gi.Struct
var adjustmentPrivateStruct_Once sync.Once

func adjustmentPrivateStruct_Set() error {
	var err error
	adjustmentPrivateStruct_Once.Do(func() {
		adjustmentPrivateStruct, err = gi.StructNew("Gtk", "AdjustmentPrivate")
	})
	return err
}

type AdjustmentPrivate struct {
	native unsafe.Pointer
}

func AdjustmentPrivateNewFromNative(native unsafe.Pointer) *AdjustmentPrivate {
	err := adjustmentPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AdjustmentPrivate{native: native}

	return instance
}

/*
CastToAdjustmentPrivate down casts any arbitrary Object to AdjustmentPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AdjustmentPrivate.
*/
func CastToAdjustmentPrivate(object *gobject.Object) *AdjustmentPrivate {
	return AdjustmentPrivateNewFromNative(object.Native())
}

// Equals compares this AdjustmentPrivate with another AdjustmentPrivate, and returns true if they represent the same Object.
func (recv *AdjustmentPrivate) Equals(other *AdjustmentPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AdjustmentPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AdjustmentPrivateStruct creates an uninitialised AdjustmentPrivate.
func AdjustmentPrivateStruct() *AdjustmentPrivate {
	err := adjustmentPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AdjustmentPrivateNewFromNative(adjustmentPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAdjustmentPrivate)
	return structGo
}
func finalizeAdjustmentPrivate(obj *AdjustmentPrivate) {
	adjustmentPrivateStruct.Free(obj.Native())
}

var alignmentClassStruct *gi.Struct
var alignmentClassStruct_Once sync.Once

func alignmentClassStruct_Set() error {
	var err error
	alignmentClassStruct_Once.Do(func() {
		alignmentClassStruct, err = gi.StructNew("Gtk", "AlignmentClass")
	})
	return err
}

type AlignmentClass struct {
	native unsafe.Pointer
}

func AlignmentClassNewFromNative(native unsafe.Pointer) *AlignmentClass {
	err := alignmentClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AlignmentClass{native: native}

	return instance
}

/*
CastToAlignmentClass down casts any arbitrary Object to AlignmentClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AlignmentClass.
*/
func CastToAlignmentClass(object *gobject.Object) *AlignmentClass {
	return AlignmentClassNewFromNative(object.Native())
}

// Equals compares this AlignmentClass with another AlignmentClass, and returns true if they represent the same Object.
func (recv *AlignmentClass) Equals(other *AlignmentClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AlignmentClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AlignmentClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(alignmentClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AlignmentClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(alignmentClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// AlignmentClassStruct creates an uninitialised AlignmentClass.
func AlignmentClassStruct() *AlignmentClass {
	err := alignmentClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AlignmentClassNewFromNative(alignmentClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAlignmentClass)
	return structGo
}
func finalizeAlignmentClass(obj *AlignmentClass) {
	alignmentClassStruct.Free(obj.Native())
}

var alignmentPrivateStruct *gi.Struct
var alignmentPrivateStruct_Once sync.Once

func alignmentPrivateStruct_Set() error {
	var err error
	alignmentPrivateStruct_Once.Do(func() {
		alignmentPrivateStruct, err = gi.StructNew("Gtk", "AlignmentPrivate")
	})
	return err
}

type AlignmentPrivate struct {
	native unsafe.Pointer
}

func AlignmentPrivateNewFromNative(native unsafe.Pointer) *AlignmentPrivate {
	err := alignmentPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AlignmentPrivate{native: native}

	return instance
}

/*
CastToAlignmentPrivate down casts any arbitrary Object to AlignmentPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AlignmentPrivate.
*/
func CastToAlignmentPrivate(object *gobject.Object) *AlignmentPrivate {
	return AlignmentPrivateNewFromNative(object.Native())
}

// Equals compares this AlignmentPrivate with another AlignmentPrivate, and returns true if they represent the same Object.
func (recv *AlignmentPrivate) Equals(other *AlignmentPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AlignmentPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AlignmentPrivateStruct creates an uninitialised AlignmentPrivate.
func AlignmentPrivateStruct() *AlignmentPrivate {
	err := alignmentPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AlignmentPrivateNewFromNative(alignmentPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAlignmentPrivate)
	return structGo
}
func finalizeAlignmentPrivate(obj *AlignmentPrivate) {
	alignmentPrivateStruct.Free(obj.Native())
}

var appChooserButtonClassStruct *gi.Struct
var appChooserButtonClassStruct_Once sync.Once

func appChooserButtonClassStruct_Set() error {
	var err error
	appChooserButtonClassStruct_Once.Do(func() {
		appChooserButtonClassStruct, err = gi.StructNew("Gtk", "AppChooserButtonClass")
	})
	return err
}

type AppChooserButtonClass struct {
	native unsafe.Pointer
}

func AppChooserButtonClassNewFromNative(native unsafe.Pointer) *AppChooserButtonClass {
	err := appChooserButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AppChooserButtonClass{native: native}

	return instance
}

/*
CastToAppChooserButtonClass down casts any arbitrary Object to AppChooserButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AppChooserButtonClass.
*/
func CastToAppChooserButtonClass(object *gobject.Object) *AppChooserButtonClass {
	return AppChooserButtonClassNewFromNative(object.Native())
}

// Equals compares this AppChooserButtonClass with another AppChooserButtonClass, and returns true if they represent the same Object.
func (recv *AppChooserButtonClass) Equals(other *AppChooserButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AppChooserButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AppChooserButtonClass) FieldParentClass() *ComboBoxClass {
	argValue := gi.StructFieldGet(appChooserButtonClassStruct, recv.Native(), "parent_class")
	value := ComboBoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AppChooserButtonClass) SetFieldParentClass(value *ComboBoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(appChooserButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'custom_item_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'custom_item_activated' : for field setter : missing Type

// AppChooserButtonClassStruct creates an uninitialised AppChooserButtonClass.
func AppChooserButtonClassStruct() *AppChooserButtonClass {
	err := appChooserButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AppChooserButtonClassNewFromNative(appChooserButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAppChooserButtonClass)
	return structGo
}
func finalizeAppChooserButtonClass(obj *AppChooserButtonClass) {
	appChooserButtonClassStruct.Free(obj.Native())
}

var appChooserButtonPrivateStruct *gi.Struct
var appChooserButtonPrivateStruct_Once sync.Once

func appChooserButtonPrivateStruct_Set() error {
	var err error
	appChooserButtonPrivateStruct_Once.Do(func() {
		appChooserButtonPrivateStruct, err = gi.StructNew("Gtk", "AppChooserButtonPrivate")
	})
	return err
}

type AppChooserButtonPrivate struct {
	native unsafe.Pointer
}

func AppChooserButtonPrivateNewFromNative(native unsafe.Pointer) *AppChooserButtonPrivate {
	err := appChooserButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AppChooserButtonPrivate{native: native}

	return instance
}

/*
CastToAppChooserButtonPrivate down casts any arbitrary Object to AppChooserButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AppChooserButtonPrivate.
*/
func CastToAppChooserButtonPrivate(object *gobject.Object) *AppChooserButtonPrivate {
	return AppChooserButtonPrivateNewFromNative(object.Native())
}

// Equals compares this AppChooserButtonPrivate with another AppChooserButtonPrivate, and returns true if they represent the same Object.
func (recv *AppChooserButtonPrivate) Equals(other *AppChooserButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AppChooserButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AppChooserButtonPrivateStruct creates an uninitialised AppChooserButtonPrivate.
func AppChooserButtonPrivateStruct() *AppChooserButtonPrivate {
	err := appChooserButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AppChooserButtonPrivateNewFromNative(appChooserButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAppChooserButtonPrivate)
	return structGo
}
func finalizeAppChooserButtonPrivate(obj *AppChooserButtonPrivate) {
	appChooserButtonPrivateStruct.Free(obj.Native())
}

var appChooserDialogClassStruct *gi.Struct
var appChooserDialogClassStruct_Once sync.Once

func appChooserDialogClassStruct_Set() error {
	var err error
	appChooserDialogClassStruct_Once.Do(func() {
		appChooserDialogClassStruct, err = gi.StructNew("Gtk", "AppChooserDialogClass")
	})
	return err
}

type AppChooserDialogClass struct {
	native unsafe.Pointer
}

func AppChooserDialogClassNewFromNative(native unsafe.Pointer) *AppChooserDialogClass {
	err := appChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AppChooserDialogClass{native: native}

	return instance
}

/*
CastToAppChooserDialogClass down casts any arbitrary Object to AppChooserDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AppChooserDialogClass.
*/
func CastToAppChooserDialogClass(object *gobject.Object) *AppChooserDialogClass {
	return AppChooserDialogClassNewFromNative(object.Native())
}

// Equals compares this AppChooserDialogClass with another AppChooserDialogClass, and returns true if they represent the same Object.
func (recv *AppChooserDialogClass) Equals(other *AppChooserDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AppChooserDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AppChooserDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(appChooserDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AppChooserDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(appChooserDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// AppChooserDialogClassStruct creates an uninitialised AppChooserDialogClass.
func AppChooserDialogClassStruct() *AppChooserDialogClass {
	err := appChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AppChooserDialogClassNewFromNative(appChooserDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAppChooserDialogClass)
	return structGo
}
func finalizeAppChooserDialogClass(obj *AppChooserDialogClass) {
	appChooserDialogClassStruct.Free(obj.Native())
}

var appChooserDialogPrivateStruct *gi.Struct
var appChooserDialogPrivateStruct_Once sync.Once

func appChooserDialogPrivateStruct_Set() error {
	var err error
	appChooserDialogPrivateStruct_Once.Do(func() {
		appChooserDialogPrivateStruct, err = gi.StructNew("Gtk", "AppChooserDialogPrivate")
	})
	return err
}

type AppChooserDialogPrivate struct {
	native unsafe.Pointer
}

func AppChooserDialogPrivateNewFromNative(native unsafe.Pointer) *AppChooserDialogPrivate {
	err := appChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AppChooserDialogPrivate{native: native}

	return instance
}

/*
CastToAppChooserDialogPrivate down casts any arbitrary Object to AppChooserDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AppChooserDialogPrivate.
*/
func CastToAppChooserDialogPrivate(object *gobject.Object) *AppChooserDialogPrivate {
	return AppChooserDialogPrivateNewFromNative(object.Native())
}

// Equals compares this AppChooserDialogPrivate with another AppChooserDialogPrivate, and returns true if they represent the same Object.
func (recv *AppChooserDialogPrivate) Equals(other *AppChooserDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AppChooserDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AppChooserDialogPrivateStruct creates an uninitialised AppChooserDialogPrivate.
func AppChooserDialogPrivateStruct() *AppChooserDialogPrivate {
	err := appChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AppChooserDialogPrivateNewFromNative(appChooserDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAppChooserDialogPrivate)
	return structGo
}
func finalizeAppChooserDialogPrivate(obj *AppChooserDialogPrivate) {
	appChooserDialogPrivateStruct.Free(obj.Native())
}

var appChooserWidgetClassStruct *gi.Struct
var appChooserWidgetClassStruct_Once sync.Once

func appChooserWidgetClassStruct_Set() error {
	var err error
	appChooserWidgetClassStruct_Once.Do(func() {
		appChooserWidgetClassStruct, err = gi.StructNew("Gtk", "AppChooserWidgetClass")
	})
	return err
}

type AppChooserWidgetClass struct {
	native unsafe.Pointer
}

func AppChooserWidgetClassNewFromNative(native unsafe.Pointer) *AppChooserWidgetClass {
	err := appChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AppChooserWidgetClass{native: native}

	return instance
}

/*
CastToAppChooserWidgetClass down casts any arbitrary Object to AppChooserWidgetClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AppChooserWidgetClass.
*/
func CastToAppChooserWidgetClass(object *gobject.Object) *AppChooserWidgetClass {
	return AppChooserWidgetClassNewFromNative(object.Native())
}

// Equals compares this AppChooserWidgetClass with another AppChooserWidgetClass, and returns true if they represent the same Object.
func (recv *AppChooserWidgetClass) Equals(other *AppChooserWidgetClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AppChooserWidgetClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AppChooserWidgetClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(appChooserWidgetClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AppChooserWidgetClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(appChooserWidgetClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'application_selected' : for field getter : missing Type

// UNSUPPORTED : C value 'application_selected' : for field setter : missing Type

// UNSUPPORTED : C value 'application_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'application_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'populate_popup' : for field getter : missing Type

// UNSUPPORTED : C value 'populate_popup' : for field setter : missing Type

// AppChooserWidgetClassStruct creates an uninitialised AppChooserWidgetClass.
func AppChooserWidgetClassStruct() *AppChooserWidgetClass {
	err := appChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AppChooserWidgetClassNewFromNative(appChooserWidgetClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAppChooserWidgetClass)
	return structGo
}
func finalizeAppChooserWidgetClass(obj *AppChooserWidgetClass) {
	appChooserWidgetClassStruct.Free(obj.Native())
}

var appChooserWidgetPrivateStruct *gi.Struct
var appChooserWidgetPrivateStruct_Once sync.Once

func appChooserWidgetPrivateStruct_Set() error {
	var err error
	appChooserWidgetPrivateStruct_Once.Do(func() {
		appChooserWidgetPrivateStruct, err = gi.StructNew("Gtk", "AppChooserWidgetPrivate")
	})
	return err
}

type AppChooserWidgetPrivate struct {
	native unsafe.Pointer
}

func AppChooserWidgetPrivateNewFromNative(native unsafe.Pointer) *AppChooserWidgetPrivate {
	err := appChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AppChooserWidgetPrivate{native: native}

	return instance
}

/*
CastToAppChooserWidgetPrivate down casts any arbitrary Object to AppChooserWidgetPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AppChooserWidgetPrivate.
*/
func CastToAppChooserWidgetPrivate(object *gobject.Object) *AppChooserWidgetPrivate {
	return AppChooserWidgetPrivateNewFromNative(object.Native())
}

// Equals compares this AppChooserWidgetPrivate with another AppChooserWidgetPrivate, and returns true if they represent the same Object.
func (recv *AppChooserWidgetPrivate) Equals(other *AppChooserWidgetPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AppChooserWidgetPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AppChooserWidgetPrivateStruct creates an uninitialised AppChooserWidgetPrivate.
func AppChooserWidgetPrivateStruct() *AppChooserWidgetPrivate {
	err := appChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AppChooserWidgetPrivateNewFromNative(appChooserWidgetPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAppChooserWidgetPrivate)
	return structGo
}
func finalizeAppChooserWidgetPrivate(obj *AppChooserWidgetPrivate) {
	appChooserWidgetPrivateStruct.Free(obj.Native())
}

var applicationClassStruct *gi.Struct
var applicationClassStruct_Once sync.Once

func applicationClassStruct_Set() error {
	var err error
	applicationClassStruct_Once.Do(func() {
		applicationClassStruct, err = gi.StructNew("Gtk", "ApplicationClass")
	})
	return err
}

type ApplicationClass struct {
	native unsafe.Pointer
}

func ApplicationClassNewFromNative(native unsafe.Pointer) *ApplicationClass {
	err := applicationClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ApplicationClass{native: native}

	return instance
}

/*
CastToApplicationClass down casts any arbitrary Object to ApplicationClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ApplicationClass.
*/
func CastToApplicationClass(object *gobject.Object) *ApplicationClass {
	return ApplicationClassNewFromNative(object.Native())
}

// Equals compares this ApplicationClass with another ApplicationClass, and returns true if they represent the same Object.
func (recv *ApplicationClass) Equals(other *ApplicationClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ApplicationClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ApplicationClass) FieldParentClass() *gio.ApplicationClass {
	argValue := gi.StructFieldGet(applicationClassStruct, recv.Native(), "parent_class")
	value := gio.ApplicationClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ApplicationClass) SetFieldParentClass(value *gio.ApplicationClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(applicationClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'window_added' : for field getter : missing Type

// UNSUPPORTED : C value 'window_added' : for field setter : missing Type

// UNSUPPORTED : C value 'window_removed' : for field getter : missing Type

// UNSUPPORTED : C value 'window_removed' : for field setter : missing Type

// ApplicationClassStruct creates an uninitialised ApplicationClass.
func ApplicationClassStruct() *ApplicationClass {
	err := applicationClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ApplicationClassNewFromNative(applicationClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeApplicationClass)
	return structGo
}
func finalizeApplicationClass(obj *ApplicationClass) {
	applicationClassStruct.Free(obj.Native())
}

var applicationPrivateStruct *gi.Struct
var applicationPrivateStruct_Once sync.Once

func applicationPrivateStruct_Set() error {
	var err error
	applicationPrivateStruct_Once.Do(func() {
		applicationPrivateStruct, err = gi.StructNew("Gtk", "ApplicationPrivate")
	})
	return err
}

type ApplicationPrivate struct {
	native unsafe.Pointer
}

func ApplicationPrivateNewFromNative(native unsafe.Pointer) *ApplicationPrivate {
	err := applicationPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ApplicationPrivate{native: native}

	return instance
}

/*
CastToApplicationPrivate down casts any arbitrary Object to ApplicationPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ApplicationPrivate.
*/
func CastToApplicationPrivate(object *gobject.Object) *ApplicationPrivate {
	return ApplicationPrivateNewFromNative(object.Native())
}

// Equals compares this ApplicationPrivate with another ApplicationPrivate, and returns true if they represent the same Object.
func (recv *ApplicationPrivate) Equals(other *ApplicationPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ApplicationPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ApplicationPrivateStruct creates an uninitialised ApplicationPrivate.
func ApplicationPrivateStruct() *ApplicationPrivate {
	err := applicationPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ApplicationPrivateNewFromNative(applicationPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeApplicationPrivate)
	return structGo
}
func finalizeApplicationPrivate(obj *ApplicationPrivate) {
	applicationPrivateStruct.Free(obj.Native())
}

var applicationWindowClassStruct *gi.Struct
var applicationWindowClassStruct_Once sync.Once

func applicationWindowClassStruct_Set() error {
	var err error
	applicationWindowClassStruct_Once.Do(func() {
		applicationWindowClassStruct, err = gi.StructNew("Gtk", "ApplicationWindowClass")
	})
	return err
}

type ApplicationWindowClass struct {
	native unsafe.Pointer
}

func ApplicationWindowClassNewFromNative(native unsafe.Pointer) *ApplicationWindowClass {
	err := applicationWindowClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ApplicationWindowClass{native: native}

	return instance
}

/*
CastToApplicationWindowClass down casts any arbitrary Object to ApplicationWindowClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ApplicationWindowClass.
*/
func CastToApplicationWindowClass(object *gobject.Object) *ApplicationWindowClass {
	return ApplicationWindowClassNewFromNative(object.Native())
}

// Equals compares this ApplicationWindowClass with another ApplicationWindowClass, and returns true if they represent the same Object.
func (recv *ApplicationWindowClass) Equals(other *ApplicationWindowClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ApplicationWindowClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ApplicationWindowClass) FieldParentClass() *WindowClass {
	argValue := gi.StructFieldGet(applicationWindowClassStruct, recv.Native(), "parent_class")
	value := WindowClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ApplicationWindowClass) SetFieldParentClass(value *WindowClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(applicationWindowClassStruct, recv.Native(), "parent_class", argValue)
}

// ApplicationWindowClassStruct creates an uninitialised ApplicationWindowClass.
func ApplicationWindowClassStruct() *ApplicationWindowClass {
	err := applicationWindowClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ApplicationWindowClassNewFromNative(applicationWindowClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeApplicationWindowClass)
	return structGo
}
func finalizeApplicationWindowClass(obj *ApplicationWindowClass) {
	applicationWindowClassStruct.Free(obj.Native())
}

var applicationWindowPrivateStruct *gi.Struct
var applicationWindowPrivateStruct_Once sync.Once

func applicationWindowPrivateStruct_Set() error {
	var err error
	applicationWindowPrivateStruct_Once.Do(func() {
		applicationWindowPrivateStruct, err = gi.StructNew("Gtk", "ApplicationWindowPrivate")
	})
	return err
}

type ApplicationWindowPrivate struct {
	native unsafe.Pointer
}

func ApplicationWindowPrivateNewFromNative(native unsafe.Pointer) *ApplicationWindowPrivate {
	err := applicationWindowPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ApplicationWindowPrivate{native: native}

	return instance
}

/*
CastToApplicationWindowPrivate down casts any arbitrary Object to ApplicationWindowPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ApplicationWindowPrivate.
*/
func CastToApplicationWindowPrivate(object *gobject.Object) *ApplicationWindowPrivate {
	return ApplicationWindowPrivateNewFromNative(object.Native())
}

// Equals compares this ApplicationWindowPrivate with another ApplicationWindowPrivate, and returns true if they represent the same Object.
func (recv *ApplicationWindowPrivate) Equals(other *ApplicationWindowPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ApplicationWindowPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ApplicationWindowPrivateStruct creates an uninitialised ApplicationWindowPrivate.
func ApplicationWindowPrivateStruct() *ApplicationWindowPrivate {
	err := applicationWindowPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ApplicationWindowPrivateNewFromNative(applicationWindowPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeApplicationWindowPrivate)
	return structGo
}
func finalizeApplicationWindowPrivate(obj *ApplicationWindowPrivate) {
	applicationWindowPrivateStruct.Free(obj.Native())
}

var arrowAccessibleClassStruct *gi.Struct
var arrowAccessibleClassStruct_Once sync.Once

func arrowAccessibleClassStruct_Set() error {
	var err error
	arrowAccessibleClassStruct_Once.Do(func() {
		arrowAccessibleClassStruct, err = gi.StructNew("Gtk", "ArrowAccessibleClass")
	})
	return err
}

type ArrowAccessibleClass struct {
	native unsafe.Pointer
}

func ArrowAccessibleClassNewFromNative(native unsafe.Pointer) *ArrowAccessibleClass {
	err := arrowAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ArrowAccessibleClass{native: native}

	return instance
}

/*
CastToArrowAccessibleClass down casts any arbitrary Object to ArrowAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ArrowAccessibleClass.
*/
func CastToArrowAccessibleClass(object *gobject.Object) *ArrowAccessibleClass {
	return ArrowAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ArrowAccessibleClass with another ArrowAccessibleClass, and returns true if they represent the same Object.
func (recv *ArrowAccessibleClass) Equals(other *ArrowAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ArrowAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ArrowAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(arrowAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ArrowAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(arrowAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ArrowAccessibleClassStruct creates an uninitialised ArrowAccessibleClass.
func ArrowAccessibleClassStruct() *ArrowAccessibleClass {
	err := arrowAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ArrowAccessibleClassNewFromNative(arrowAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeArrowAccessibleClass)
	return structGo
}
func finalizeArrowAccessibleClass(obj *ArrowAccessibleClass) {
	arrowAccessibleClassStruct.Free(obj.Native())
}

var arrowAccessiblePrivateStruct *gi.Struct
var arrowAccessiblePrivateStruct_Once sync.Once

func arrowAccessiblePrivateStruct_Set() error {
	var err error
	arrowAccessiblePrivateStruct_Once.Do(func() {
		arrowAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ArrowAccessiblePrivate")
	})
	return err
}

type ArrowAccessiblePrivate struct {
	native unsafe.Pointer
}

func ArrowAccessiblePrivateNewFromNative(native unsafe.Pointer) *ArrowAccessiblePrivate {
	err := arrowAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ArrowAccessiblePrivate{native: native}

	return instance
}

/*
CastToArrowAccessiblePrivate down casts any arbitrary Object to ArrowAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ArrowAccessiblePrivate.
*/
func CastToArrowAccessiblePrivate(object *gobject.Object) *ArrowAccessiblePrivate {
	return ArrowAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ArrowAccessiblePrivate with another ArrowAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ArrowAccessiblePrivate) Equals(other *ArrowAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ArrowAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ArrowAccessiblePrivateStruct creates an uninitialised ArrowAccessiblePrivate.
func ArrowAccessiblePrivateStruct() *ArrowAccessiblePrivate {
	err := arrowAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ArrowAccessiblePrivateNewFromNative(arrowAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeArrowAccessiblePrivate)
	return structGo
}
func finalizeArrowAccessiblePrivate(obj *ArrowAccessiblePrivate) {
	arrowAccessiblePrivateStruct.Free(obj.Native())
}

var arrowClassStruct *gi.Struct
var arrowClassStruct_Once sync.Once

func arrowClassStruct_Set() error {
	var err error
	arrowClassStruct_Once.Do(func() {
		arrowClassStruct, err = gi.StructNew("Gtk", "ArrowClass")
	})
	return err
}

type ArrowClass struct {
	native unsafe.Pointer
}

func ArrowClassNewFromNative(native unsafe.Pointer) *ArrowClass {
	err := arrowClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ArrowClass{native: native}

	return instance
}

/*
CastToArrowClass down casts any arbitrary Object to ArrowClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ArrowClass.
*/
func CastToArrowClass(object *gobject.Object) *ArrowClass {
	return ArrowClassNewFromNative(object.Native())
}

// Equals compares this ArrowClass with another ArrowClass, and returns true if they represent the same Object.
func (recv *ArrowClass) Equals(other *ArrowClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ArrowClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ArrowClass) FieldParentClass() *MiscClass {
	argValue := gi.StructFieldGet(arrowClassStruct, recv.Native(), "parent_class")
	value := MiscClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ArrowClass) SetFieldParentClass(value *MiscClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(arrowClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ArrowClassStruct creates an uninitialised ArrowClass.
func ArrowClassStruct() *ArrowClass {
	err := arrowClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ArrowClassNewFromNative(arrowClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeArrowClass)
	return structGo
}
func finalizeArrowClass(obj *ArrowClass) {
	arrowClassStruct.Free(obj.Native())
}

var arrowPrivateStruct *gi.Struct
var arrowPrivateStruct_Once sync.Once

func arrowPrivateStruct_Set() error {
	var err error
	arrowPrivateStruct_Once.Do(func() {
		arrowPrivateStruct, err = gi.StructNew("Gtk", "ArrowPrivate")
	})
	return err
}

type ArrowPrivate struct {
	native unsafe.Pointer
}

func ArrowPrivateNewFromNative(native unsafe.Pointer) *ArrowPrivate {
	err := arrowPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ArrowPrivate{native: native}

	return instance
}

/*
CastToArrowPrivate down casts any arbitrary Object to ArrowPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ArrowPrivate.
*/
func CastToArrowPrivate(object *gobject.Object) *ArrowPrivate {
	return ArrowPrivateNewFromNative(object.Native())
}

// Equals compares this ArrowPrivate with another ArrowPrivate, and returns true if they represent the same Object.
func (recv *ArrowPrivate) Equals(other *ArrowPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ArrowPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ArrowPrivateStruct creates an uninitialised ArrowPrivate.
func ArrowPrivateStruct() *ArrowPrivate {
	err := arrowPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ArrowPrivateNewFromNative(arrowPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeArrowPrivate)
	return structGo
}
func finalizeArrowPrivate(obj *ArrowPrivate) {
	arrowPrivateStruct.Free(obj.Native())
}

var aspectFrameClassStruct *gi.Struct
var aspectFrameClassStruct_Once sync.Once

func aspectFrameClassStruct_Set() error {
	var err error
	aspectFrameClassStruct_Once.Do(func() {
		aspectFrameClassStruct, err = gi.StructNew("Gtk", "AspectFrameClass")
	})
	return err
}

type AspectFrameClass struct {
	native unsafe.Pointer
}

func AspectFrameClassNewFromNative(native unsafe.Pointer) *AspectFrameClass {
	err := aspectFrameClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AspectFrameClass{native: native}

	return instance
}

/*
CastToAspectFrameClass down casts any arbitrary Object to AspectFrameClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AspectFrameClass.
*/
func CastToAspectFrameClass(object *gobject.Object) *AspectFrameClass {
	return AspectFrameClassNewFromNative(object.Native())
}

// Equals compares this AspectFrameClass with another AspectFrameClass, and returns true if they represent the same Object.
func (recv *AspectFrameClass) Equals(other *AspectFrameClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AspectFrameClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AspectFrameClass) FieldParentClass() *FrameClass {
	argValue := gi.StructFieldGet(aspectFrameClassStruct, recv.Native(), "parent_class")
	value := FrameClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AspectFrameClass) SetFieldParentClass(value *FrameClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(aspectFrameClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// AspectFrameClassStruct creates an uninitialised AspectFrameClass.
func AspectFrameClassStruct() *AspectFrameClass {
	err := aspectFrameClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AspectFrameClassNewFromNative(aspectFrameClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAspectFrameClass)
	return structGo
}
func finalizeAspectFrameClass(obj *AspectFrameClass) {
	aspectFrameClassStruct.Free(obj.Native())
}

var aspectFramePrivateStruct *gi.Struct
var aspectFramePrivateStruct_Once sync.Once

func aspectFramePrivateStruct_Set() error {
	var err error
	aspectFramePrivateStruct_Once.Do(func() {
		aspectFramePrivateStruct, err = gi.StructNew("Gtk", "AspectFramePrivate")
	})
	return err
}

type AspectFramePrivate struct {
	native unsafe.Pointer
}

func AspectFramePrivateNewFromNative(native unsafe.Pointer) *AspectFramePrivate {
	err := aspectFramePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AspectFramePrivate{native: native}

	return instance
}

/*
CastToAspectFramePrivate down casts any arbitrary Object to AspectFramePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AspectFramePrivate.
*/
func CastToAspectFramePrivate(object *gobject.Object) *AspectFramePrivate {
	return AspectFramePrivateNewFromNative(object.Native())
}

// Equals compares this AspectFramePrivate with another AspectFramePrivate, and returns true if they represent the same Object.
func (recv *AspectFramePrivate) Equals(other *AspectFramePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AspectFramePrivate) Native() unsafe.Pointer {
	return recv.native
}

// AspectFramePrivateStruct creates an uninitialised AspectFramePrivate.
func AspectFramePrivateStruct() *AspectFramePrivate {
	err := aspectFramePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AspectFramePrivateNewFromNative(aspectFramePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAspectFramePrivate)
	return structGo
}
func finalizeAspectFramePrivate(obj *AspectFramePrivate) {
	aspectFramePrivateStruct.Free(obj.Native())
}

var assistantClassStruct *gi.Struct
var assistantClassStruct_Once sync.Once

func assistantClassStruct_Set() error {
	var err error
	assistantClassStruct_Once.Do(func() {
		assistantClassStruct, err = gi.StructNew("Gtk", "AssistantClass")
	})
	return err
}

type AssistantClass struct {
	native unsafe.Pointer
}

func AssistantClassNewFromNative(native unsafe.Pointer) *AssistantClass {
	err := assistantClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AssistantClass{native: native}

	return instance
}

/*
CastToAssistantClass down casts any arbitrary Object to AssistantClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a AssistantClass.
*/
func CastToAssistantClass(object *gobject.Object) *AssistantClass {
	return AssistantClassNewFromNative(object.Native())
}

// Equals compares this AssistantClass with another AssistantClass, and returns true if they represent the same Object.
func (recv *AssistantClass) Equals(other *AssistantClass) bool {
	return other.Native() == recv.Native()
}

func (recv *AssistantClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *AssistantClass) FieldParentClass() *WindowClass {
	argValue := gi.StructFieldGet(assistantClassStruct, recv.Native(), "parent_class")
	value := WindowClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *AssistantClass) SetFieldParentClass(value *WindowClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(assistantClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'prepare' : for field getter : missing Type

// UNSUPPORTED : C value 'prepare' : for field setter : missing Type

// UNSUPPORTED : C value 'apply' : for field getter : missing Type

// UNSUPPORTED : C value 'apply' : for field setter : missing Type

// UNSUPPORTED : C value 'close' : for field getter : missing Type

// UNSUPPORTED : C value 'close' : for field setter : missing Type

// UNSUPPORTED : C value 'cancel' : for field getter : missing Type

// UNSUPPORTED : C value 'cancel' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// AssistantClassStruct creates an uninitialised AssistantClass.
func AssistantClassStruct() *AssistantClass {
	err := assistantClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AssistantClassNewFromNative(assistantClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAssistantClass)
	return structGo
}
func finalizeAssistantClass(obj *AssistantClass) {
	assistantClassStruct.Free(obj.Native())
}

var assistantPrivateStruct *gi.Struct
var assistantPrivateStruct_Once sync.Once

func assistantPrivateStruct_Set() error {
	var err error
	assistantPrivateStruct_Once.Do(func() {
		assistantPrivateStruct, err = gi.StructNew("Gtk", "AssistantPrivate")
	})
	return err
}

type AssistantPrivate struct {
	native unsafe.Pointer
}

func AssistantPrivateNewFromNative(native unsafe.Pointer) *AssistantPrivate {
	err := assistantPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &AssistantPrivate{native: native}

	return instance
}

/*
CastToAssistantPrivate down casts any arbitrary Object to AssistantPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a AssistantPrivate.
*/
func CastToAssistantPrivate(object *gobject.Object) *AssistantPrivate {
	return AssistantPrivateNewFromNative(object.Native())
}

// Equals compares this AssistantPrivate with another AssistantPrivate, and returns true if they represent the same Object.
func (recv *AssistantPrivate) Equals(other *AssistantPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *AssistantPrivate) Native() unsafe.Pointer {
	return recv.native
}

// AssistantPrivateStruct creates an uninitialised AssistantPrivate.
func AssistantPrivateStruct() *AssistantPrivate {
	err := assistantPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := AssistantPrivateNewFromNative(assistantPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeAssistantPrivate)
	return structGo
}
func finalizeAssistantPrivate(obj *AssistantPrivate) {
	assistantPrivateStruct.Free(obj.Native())
}

var binClassStruct *gi.Struct
var binClassStruct_Once sync.Once

func binClassStruct_Set() error {
	var err error
	binClassStruct_Once.Do(func() {
		binClassStruct, err = gi.StructNew("Gtk", "BinClass")
	})
	return err
}

type BinClass struct {
	native unsafe.Pointer
}

func BinClassNewFromNative(native unsafe.Pointer) *BinClass {
	err := binClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BinClass{native: native}

	return instance
}

/*
CastToBinClass down casts any arbitrary Object to BinClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a BinClass.
*/
func CastToBinClass(object *gobject.Object) *BinClass {
	return BinClassNewFromNative(object.Native())
}

// Equals compares this BinClass with another BinClass, and returns true if they represent the same Object.
func (recv *BinClass) Equals(other *BinClass) bool {
	return other.Native() == recv.Native()
}

func (recv *BinClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *BinClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(binClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *BinClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(binClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// BinClassStruct creates an uninitialised BinClass.
func BinClassStruct() *BinClass {
	err := binClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BinClassNewFromNative(binClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBinClass)
	return structGo
}
func finalizeBinClass(obj *BinClass) {
	binClassStruct.Free(obj.Native())
}

var binPrivateStruct *gi.Struct
var binPrivateStruct_Once sync.Once

func binPrivateStruct_Set() error {
	var err error
	binPrivateStruct_Once.Do(func() {
		binPrivateStruct, err = gi.StructNew("Gtk", "BinPrivate")
	})
	return err
}

type BinPrivate struct {
	native unsafe.Pointer
}

func BinPrivateNewFromNative(native unsafe.Pointer) *BinPrivate {
	err := binPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BinPrivate{native: native}

	return instance
}

/*
CastToBinPrivate down casts any arbitrary Object to BinPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a BinPrivate.
*/
func CastToBinPrivate(object *gobject.Object) *BinPrivate {
	return BinPrivateNewFromNative(object.Native())
}

// Equals compares this BinPrivate with another BinPrivate, and returns true if they represent the same Object.
func (recv *BinPrivate) Equals(other *BinPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *BinPrivate) Native() unsafe.Pointer {
	return recv.native
}

// BinPrivateStruct creates an uninitialised BinPrivate.
func BinPrivateStruct() *BinPrivate {
	err := binPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BinPrivateNewFromNative(binPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBinPrivate)
	return structGo
}
func finalizeBinPrivate(obj *BinPrivate) {
	binPrivateStruct.Free(obj.Native())
}

var bindingArgStruct *gi.Struct
var bindingArgStruct_Once sync.Once

func bindingArgStruct_Set() error {
	var err error
	bindingArgStruct_Once.Do(func() {
		bindingArgStruct, err = gi.StructNew("Gtk", "BindingArg")
	})
	return err
}

type BindingArg struct {
	native unsafe.Pointer
}

func BindingArgNewFromNative(native unsafe.Pointer) *BindingArg {
	err := bindingArgStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BindingArg{native: native}

	return instance
}

/*
CastToBindingArg down casts any arbitrary Object to BindingArg.
Exercise care, as this is a potentially dangerous function
if the Object is not a BindingArg.
*/
func CastToBindingArg(object *gobject.Object) *BindingArg {
	return BindingArgNewFromNative(object.Native())
}

// Equals compares this BindingArg with another BindingArg, and returns true if they represent the same Object.
func (recv *BindingArg) Equals(other *BindingArg) bool {
	return other.Native() == recv.Native()
}

func (recv *BindingArg) Native() unsafe.Pointer {
	return recv.native
}

// FieldArgType returns the C field 'arg_type'.
func (recv *BindingArg) FieldArgType() int64 {
	argValue := gi.StructFieldGet(bindingArgStruct, recv.Native(), "arg_type")
	value := argValue.Int64()
	return value
}

// SetFieldArgType sets the value of the C field 'arg_type'.
func (recv *BindingArg) SetFieldArgType(value int64) {
	var argValue gi.Argument
	argValue.SetInt64(value)
	gi.StructFieldSet(bindingArgStruct, recv.Native(), "arg_type", argValue)
}

// BindingArgStruct creates an uninitialised BindingArg.
func BindingArgStruct() *BindingArg {
	err := bindingArgStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BindingArgNewFromNative(bindingArgStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBindingArg)
	return structGo
}
func finalizeBindingArg(obj *BindingArg) {
	bindingArgStruct.Free(obj.Native())
}

var bindingEntryStruct *gi.Struct
var bindingEntryStruct_Once sync.Once

func bindingEntryStruct_Set() error {
	var err error
	bindingEntryStruct_Once.Do(func() {
		bindingEntryStruct, err = gi.StructNew("Gtk", "BindingEntry")
	})
	return err
}

type BindingEntry struct {
	native unsafe.Pointer
}

func BindingEntryNewFromNative(native unsafe.Pointer) *BindingEntry {
	err := bindingEntryStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BindingEntry{native: native}

	return instance
}

/*
CastToBindingEntry down casts any arbitrary Object to BindingEntry.
Exercise care, as this is a potentially dangerous function
if the Object is not a BindingEntry.
*/
func CastToBindingEntry(object *gobject.Object) *BindingEntry {
	return BindingEntryNewFromNative(object.Native())
}

// Equals compares this BindingEntry with another BindingEntry, and returns true if they represent the same Object.
func (recv *BindingEntry) Equals(other *BindingEntry) bool {
	return other.Native() == recv.Native()
}

func (recv *BindingEntry) Native() unsafe.Pointer {
	return recv.native
}

// FieldKeyval returns the C field 'keyval'.
func (recv *BindingEntry) FieldKeyval() uint32 {
	argValue := gi.StructFieldGet(bindingEntryStruct, recv.Native(), "keyval")
	value := argValue.Uint32()
	return value
}

// SetFieldKeyval sets the value of the C field 'keyval'.
func (recv *BindingEntry) SetFieldKeyval(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(bindingEntryStruct, recv.Native(), "keyval", argValue)
}

// UNSUPPORTED : C value 'modifiers' : for field getter : no Go type for 'Gdk.ModifierType'

// UNSUPPORTED : C value 'modifiers' : for field setter : no Go type for 'Gdk.ModifierType'

// FieldBindingSet returns the C field 'binding_set'.
func (recv *BindingEntry) FieldBindingSet() *BindingSet {
	argValue := gi.StructFieldGet(bindingEntryStruct, recv.Native(), "binding_set")
	value := BindingSetNewFromNative(argValue.Pointer())
	return value
}

// SetFieldBindingSet sets the value of the C field 'binding_set'.
func (recv *BindingEntry) SetFieldBindingSet(value *BindingSet) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingEntryStruct, recv.Native(), "binding_set", argValue)
}

// FieldDestroyed returns the C field 'destroyed'.
func (recv *BindingEntry) FieldDestroyed() uint32 {
	argValue := gi.StructFieldGet(bindingEntryStruct, recv.Native(), "destroyed")
	value := argValue.Uint32()
	return value
}

// SetFieldDestroyed sets the value of the C field 'destroyed'.
func (recv *BindingEntry) SetFieldDestroyed(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(bindingEntryStruct, recv.Native(), "destroyed", argValue)
}

// FieldInEmission returns the C field 'in_emission'.
func (recv *BindingEntry) FieldInEmission() uint32 {
	argValue := gi.StructFieldGet(bindingEntryStruct, recv.Native(), "in_emission")
	value := argValue.Uint32()
	return value
}

// SetFieldInEmission sets the value of the C field 'in_emission'.
func (recv *BindingEntry) SetFieldInEmission(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(bindingEntryStruct, recv.Native(), "in_emission", argValue)
}

// FieldMarksUnbound returns the C field 'marks_unbound'.
func (recv *BindingEntry) FieldMarksUnbound() uint32 {
	argValue := gi.StructFieldGet(bindingEntryStruct, recv.Native(), "marks_unbound")
	value := argValue.Uint32()
	return value
}

// SetFieldMarksUnbound sets the value of the C field 'marks_unbound'.
func (recv *BindingEntry) SetFieldMarksUnbound(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(bindingEntryStruct, recv.Native(), "marks_unbound", argValue)
}

// FieldSetNext returns the C field 'set_next'.
func (recv *BindingEntry) FieldSetNext() *BindingEntry {
	argValue := gi.StructFieldGet(bindingEntryStruct, recv.Native(), "set_next")
	value := BindingEntryNewFromNative(argValue.Pointer())
	return value
}

// SetFieldSetNext sets the value of the C field 'set_next'.
func (recv *BindingEntry) SetFieldSetNext(value *BindingEntry) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingEntryStruct, recv.Native(), "set_next", argValue)
}

// FieldHashNext returns the C field 'hash_next'.
func (recv *BindingEntry) FieldHashNext() *BindingEntry {
	argValue := gi.StructFieldGet(bindingEntryStruct, recv.Native(), "hash_next")
	value := BindingEntryNewFromNative(argValue.Pointer())
	return value
}

// SetFieldHashNext sets the value of the C field 'hash_next'.
func (recv *BindingEntry) SetFieldHashNext(value *BindingEntry) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingEntryStruct, recv.Native(), "hash_next", argValue)
}

// FieldSignals returns the C field 'signals'.
func (recv *BindingEntry) FieldSignals() *BindingSignal {
	argValue := gi.StructFieldGet(bindingEntryStruct, recv.Native(), "signals")
	value := BindingSignalNewFromNative(argValue.Pointer())
	return value
}

// SetFieldSignals sets the value of the C field 'signals'.
func (recv *BindingEntry) SetFieldSignals(value *BindingSignal) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingEntryStruct, recv.Native(), "signals", argValue)
}

// BindingEntryStruct creates an uninitialised BindingEntry.
func BindingEntryStruct() *BindingEntry {
	err := bindingEntryStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BindingEntryNewFromNative(bindingEntryStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBindingEntry)
	return structGo
}
func finalizeBindingEntry(obj *BindingEntry) {
	bindingEntryStruct.Free(obj.Native())
}

var bindingSetStruct *gi.Struct
var bindingSetStruct_Once sync.Once

func bindingSetStruct_Set() error {
	var err error
	bindingSetStruct_Once.Do(func() {
		bindingSetStruct, err = gi.StructNew("Gtk", "BindingSet")
	})
	return err
}

type BindingSet struct {
	native unsafe.Pointer
}

func BindingSetNewFromNative(native unsafe.Pointer) *BindingSet {
	err := bindingSetStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BindingSet{native: native}

	return instance
}

/*
CastToBindingSet down casts any arbitrary Object to BindingSet.
Exercise care, as this is a potentially dangerous function
if the Object is not a BindingSet.
*/
func CastToBindingSet(object *gobject.Object) *BindingSet {
	return BindingSetNewFromNative(object.Native())
}

// Equals compares this BindingSet with another BindingSet, and returns true if they represent the same Object.
func (recv *BindingSet) Equals(other *BindingSet) bool {
	return other.Native() == recv.Native()
}

func (recv *BindingSet) Native() unsafe.Pointer {
	return recv.native
}

// FieldSetName returns the C field 'set_name'.
func (recv *BindingSet) FieldSetName() string {
	argValue := gi.StructFieldGet(bindingSetStruct, recv.Native(), "set_name")
	value := argValue.String(false)
	return value
}

// SetFieldSetName sets the value of the C field 'set_name'.
func (recv *BindingSet) SetFieldSetName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(bindingSetStruct, recv.Native(), "set_name", argValue)
}

// FieldPriority returns the C field 'priority'.
func (recv *BindingSet) FieldPriority() int32 {
	argValue := gi.StructFieldGet(bindingSetStruct, recv.Native(), "priority")
	value := argValue.Int32()
	return value
}

// SetFieldPriority sets the value of the C field 'priority'.
func (recv *BindingSet) SetFieldPriority(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(bindingSetStruct, recv.Native(), "priority", argValue)
}

// FieldWidgetPathPspecs returns the C field 'widget_path_pspecs'.
func (recv *BindingSet) FieldWidgetPathPspecs() *glib.SList {
	argValue := gi.StructFieldGet(bindingSetStruct, recv.Native(), "widget_path_pspecs")
	value := glib.SListNewFromNative(argValue.Pointer())
	return value
}

// SetFieldWidgetPathPspecs sets the value of the C field 'widget_path_pspecs'.
func (recv *BindingSet) SetFieldWidgetPathPspecs(value *glib.SList) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingSetStruct, recv.Native(), "widget_path_pspecs", argValue)
}

// FieldWidgetClassPspecs returns the C field 'widget_class_pspecs'.
func (recv *BindingSet) FieldWidgetClassPspecs() *glib.SList {
	argValue := gi.StructFieldGet(bindingSetStruct, recv.Native(), "widget_class_pspecs")
	value := glib.SListNewFromNative(argValue.Pointer())
	return value
}

// SetFieldWidgetClassPspecs sets the value of the C field 'widget_class_pspecs'.
func (recv *BindingSet) SetFieldWidgetClassPspecs(value *glib.SList) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingSetStruct, recv.Native(), "widget_class_pspecs", argValue)
}

// FieldClassBranchPspecs returns the C field 'class_branch_pspecs'.
func (recv *BindingSet) FieldClassBranchPspecs() *glib.SList {
	argValue := gi.StructFieldGet(bindingSetStruct, recv.Native(), "class_branch_pspecs")
	value := glib.SListNewFromNative(argValue.Pointer())
	return value
}

// SetFieldClassBranchPspecs sets the value of the C field 'class_branch_pspecs'.
func (recv *BindingSet) SetFieldClassBranchPspecs(value *glib.SList) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingSetStruct, recv.Native(), "class_branch_pspecs", argValue)
}

// FieldEntries returns the C field 'entries'.
func (recv *BindingSet) FieldEntries() *BindingEntry {
	argValue := gi.StructFieldGet(bindingSetStruct, recv.Native(), "entries")
	value := BindingEntryNewFromNative(argValue.Pointer())
	return value
}

// SetFieldEntries sets the value of the C field 'entries'.
func (recv *BindingSet) SetFieldEntries(value *BindingEntry) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingSetStruct, recv.Native(), "entries", argValue)
}

// FieldCurrent returns the C field 'current'.
func (recv *BindingSet) FieldCurrent() *BindingEntry {
	argValue := gi.StructFieldGet(bindingSetStruct, recv.Native(), "current")
	value := BindingEntryNewFromNative(argValue.Pointer())
	return value
}

// SetFieldCurrent sets the value of the C field 'current'.
func (recv *BindingSet) SetFieldCurrent(value *BindingEntry) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingSetStruct, recv.Native(), "current", argValue)
}

// FieldParsed returns the C field 'parsed'.
func (recv *BindingSet) FieldParsed() uint32 {
	argValue := gi.StructFieldGet(bindingSetStruct, recv.Native(), "parsed")
	value := argValue.Uint32()
	return value
}

// SetFieldParsed sets the value of the C field 'parsed'.
func (recv *BindingSet) SetFieldParsed(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(bindingSetStruct, recv.Native(), "parsed", argValue)
}

// UNSUPPORTED : C value 'gtk_binding_set_activate' : parameter 'modifiers' of type 'Gdk.ModifierType' not supported

var bindingSetAddPathFunction *gi.Function
var bindingSetAddPathFunction_Once sync.Once

func bindingSetAddPathFunction_Set() error {
	var err error
	bindingSetAddPathFunction_Once.Do(func() {
		err = bindingSetStruct_Set()
		if err != nil {
			return
		}
		bindingSetAddPathFunction, err = bindingSetStruct.InvokerNew("add_path")
	})
	return err
}

// AddPath is a representation of the C type gtk_binding_set_add_path.
func (recv *BindingSet) AddPath(pathType PathType, pathPattern string, priority PathPriorityType) {
	var inArgs [4]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(pathType))
	inArgs[2].SetString(pathPattern)
	inArgs[3].SetInt32(int32(priority))

	err := bindingSetAddPathFunction_Set()
	if err == nil {
		bindingSetAddPathFunction.Invoke(inArgs[:], nil)
	}

	return
}

// BindingSetStruct creates an uninitialised BindingSet.
func BindingSetStruct() *BindingSet {
	err := bindingSetStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BindingSetNewFromNative(bindingSetStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBindingSet)
	return structGo
}
func finalizeBindingSet(obj *BindingSet) {
	bindingSetStruct.Free(obj.Native())
}

var bindingSignalStruct *gi.Struct
var bindingSignalStruct_Once sync.Once

func bindingSignalStruct_Set() error {
	var err error
	bindingSignalStruct_Once.Do(func() {
		bindingSignalStruct, err = gi.StructNew("Gtk", "BindingSignal")
	})
	return err
}

type BindingSignal struct {
	native unsafe.Pointer
}

func BindingSignalNewFromNative(native unsafe.Pointer) *BindingSignal {
	err := bindingSignalStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BindingSignal{native: native}

	return instance
}

/*
CastToBindingSignal down casts any arbitrary Object to BindingSignal.
Exercise care, as this is a potentially dangerous function
if the Object is not a BindingSignal.
*/
func CastToBindingSignal(object *gobject.Object) *BindingSignal {
	return BindingSignalNewFromNative(object.Native())
}

// Equals compares this BindingSignal with another BindingSignal, and returns true if they represent the same Object.
func (recv *BindingSignal) Equals(other *BindingSignal) bool {
	return other.Native() == recv.Native()
}

func (recv *BindingSignal) Native() unsafe.Pointer {
	return recv.native
}

// FieldNext returns the C field 'next'.
func (recv *BindingSignal) FieldNext() *BindingSignal {
	argValue := gi.StructFieldGet(bindingSignalStruct, recv.Native(), "next")
	value := BindingSignalNewFromNative(argValue.Pointer())
	return value
}

// SetFieldNext sets the value of the C field 'next'.
func (recv *BindingSignal) SetFieldNext(value *BindingSignal) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(bindingSignalStruct, recv.Native(), "next", argValue)
}

// FieldSignalName returns the C field 'signal_name'.
func (recv *BindingSignal) FieldSignalName() string {
	argValue := gi.StructFieldGet(bindingSignalStruct, recv.Native(), "signal_name")
	value := argValue.String(false)
	return value
}

// SetFieldSignalName sets the value of the C field 'signal_name'.
func (recv *BindingSignal) SetFieldSignalName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(bindingSignalStruct, recv.Native(), "signal_name", argValue)
}

// FieldNArgs returns the C field 'n_args'.
func (recv *BindingSignal) FieldNArgs() uint32 {
	argValue := gi.StructFieldGet(bindingSignalStruct, recv.Native(), "n_args")
	value := argValue.Uint32()
	return value
}

// SetFieldNArgs sets the value of the C field 'n_args'.
func (recv *BindingSignal) SetFieldNArgs(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(bindingSignalStruct, recv.Native(), "n_args", argValue)
}

// UNSUPPORTED : C value 'args' : for field getter : missing Type

// UNSUPPORTED : C value 'args' : for field setter : missing Type

// BindingSignalStruct creates an uninitialised BindingSignal.
func BindingSignalStruct() *BindingSignal {
	err := bindingSignalStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BindingSignalNewFromNative(bindingSignalStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBindingSignal)
	return structGo
}
func finalizeBindingSignal(obj *BindingSignal) {
	bindingSignalStruct.Free(obj.Native())
}

var booleanCellAccessibleClassStruct *gi.Struct
var booleanCellAccessibleClassStruct_Once sync.Once

func booleanCellAccessibleClassStruct_Set() error {
	var err error
	booleanCellAccessibleClassStruct_Once.Do(func() {
		booleanCellAccessibleClassStruct, err = gi.StructNew("Gtk", "BooleanCellAccessibleClass")
	})
	return err
}

type BooleanCellAccessibleClass struct {
	native unsafe.Pointer
}

func BooleanCellAccessibleClassNewFromNative(native unsafe.Pointer) *BooleanCellAccessibleClass {
	err := booleanCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BooleanCellAccessibleClass{native: native}

	return instance
}

/*
CastToBooleanCellAccessibleClass down casts any arbitrary Object to BooleanCellAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a BooleanCellAccessibleClass.
*/
func CastToBooleanCellAccessibleClass(object *gobject.Object) *BooleanCellAccessibleClass {
	return BooleanCellAccessibleClassNewFromNative(object.Native())
}

// Equals compares this BooleanCellAccessibleClass with another BooleanCellAccessibleClass, and returns true if they represent the same Object.
func (recv *BooleanCellAccessibleClass) Equals(other *BooleanCellAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *BooleanCellAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *BooleanCellAccessibleClass) FieldParentClass() *RendererCellAccessibleClass {
	argValue := gi.StructFieldGet(booleanCellAccessibleClassStruct, recv.Native(), "parent_class")
	value := RendererCellAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *BooleanCellAccessibleClass) SetFieldParentClass(value *RendererCellAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(booleanCellAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// BooleanCellAccessibleClassStruct creates an uninitialised BooleanCellAccessibleClass.
func BooleanCellAccessibleClassStruct() *BooleanCellAccessibleClass {
	err := booleanCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BooleanCellAccessibleClassNewFromNative(booleanCellAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBooleanCellAccessibleClass)
	return structGo
}
func finalizeBooleanCellAccessibleClass(obj *BooleanCellAccessibleClass) {
	booleanCellAccessibleClassStruct.Free(obj.Native())
}

var booleanCellAccessiblePrivateStruct *gi.Struct
var booleanCellAccessiblePrivateStruct_Once sync.Once

func booleanCellAccessiblePrivateStruct_Set() error {
	var err error
	booleanCellAccessiblePrivateStruct_Once.Do(func() {
		booleanCellAccessiblePrivateStruct, err = gi.StructNew("Gtk", "BooleanCellAccessiblePrivate")
	})
	return err
}

type BooleanCellAccessiblePrivate struct {
	native unsafe.Pointer
}

func BooleanCellAccessiblePrivateNewFromNative(native unsafe.Pointer) *BooleanCellAccessiblePrivate {
	err := booleanCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BooleanCellAccessiblePrivate{native: native}

	return instance
}

/*
CastToBooleanCellAccessiblePrivate down casts any arbitrary Object to BooleanCellAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a BooleanCellAccessiblePrivate.
*/
func CastToBooleanCellAccessiblePrivate(object *gobject.Object) *BooleanCellAccessiblePrivate {
	return BooleanCellAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this BooleanCellAccessiblePrivate with another BooleanCellAccessiblePrivate, and returns true if they represent the same Object.
func (recv *BooleanCellAccessiblePrivate) Equals(other *BooleanCellAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *BooleanCellAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// BooleanCellAccessiblePrivateStruct creates an uninitialised BooleanCellAccessiblePrivate.
func BooleanCellAccessiblePrivateStruct() *BooleanCellAccessiblePrivate {
	err := booleanCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BooleanCellAccessiblePrivateNewFromNative(booleanCellAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBooleanCellAccessiblePrivate)
	return structGo
}
func finalizeBooleanCellAccessiblePrivate(obj *BooleanCellAccessiblePrivate) {
	booleanCellAccessiblePrivateStruct.Free(obj.Native())
}

var borderStruct *gi.Struct
var borderStruct_Once sync.Once

func borderStruct_Set() error {
	var err error
	borderStruct_Once.Do(func() {
		borderStruct, err = gi.StructNew("Gtk", "Border")
	})
	return err
}

type Border struct {
	native unsafe.Pointer
}

func BorderNewFromNative(native unsafe.Pointer) *Border {
	err := borderStruct_Set()
	if err != nil {
		return nil
	}

	instance := &Border{native: native}

	return instance
}

/*
CastToBorder down casts any arbitrary Object to Border.
Exercise care, as this is a potentially dangerous function
if the Object is not a Border.
*/
func CastToBorder(object *gobject.Object) *Border {
	return BorderNewFromNative(object.Native())
}

// Equals compares this Border with another Border, and returns true if they represent the same Object.
func (recv *Border) Equals(other *Border) bool {
	return other.Native() == recv.Native()
}

func (recv *Border) Native() unsafe.Pointer {
	return recv.native
}

// FieldLeft returns the C field 'left'.
func (recv *Border) FieldLeft() int16 {
	argValue := gi.StructFieldGet(borderStruct, recv.Native(), "left")
	value := argValue.Int16()
	return value
}

// SetFieldLeft sets the value of the C field 'left'.
func (recv *Border) SetFieldLeft(value int16) {
	var argValue gi.Argument
	argValue.SetInt16(value)
	gi.StructFieldSet(borderStruct, recv.Native(), "left", argValue)
}

// FieldRight returns the C field 'right'.
func (recv *Border) FieldRight() int16 {
	argValue := gi.StructFieldGet(borderStruct, recv.Native(), "right")
	value := argValue.Int16()
	return value
}

// SetFieldRight sets the value of the C field 'right'.
func (recv *Border) SetFieldRight(value int16) {
	var argValue gi.Argument
	argValue.SetInt16(value)
	gi.StructFieldSet(borderStruct, recv.Native(), "right", argValue)
}

// FieldTop returns the C field 'top'.
func (recv *Border) FieldTop() int16 {
	argValue := gi.StructFieldGet(borderStruct, recv.Native(), "top")
	value := argValue.Int16()
	return value
}

// SetFieldTop sets the value of the C field 'top'.
func (recv *Border) SetFieldTop(value int16) {
	var argValue gi.Argument
	argValue.SetInt16(value)
	gi.StructFieldSet(borderStruct, recv.Native(), "top", argValue)
}

// FieldBottom returns the C field 'bottom'.
func (recv *Border) FieldBottom() int16 {
	argValue := gi.StructFieldGet(borderStruct, recv.Native(), "bottom")
	value := argValue.Int16()
	return value
}

// SetFieldBottom sets the value of the C field 'bottom'.
func (recv *Border) SetFieldBottom(value int16) {
	var argValue gi.Argument
	argValue.SetInt16(value)
	gi.StructFieldSet(borderStruct, recv.Native(), "bottom", argValue)
}

var borderNewFunction *gi.Function
var borderNewFunction_Once sync.Once

func borderNewFunction_Set() error {
	var err error
	borderNewFunction_Once.Do(func() {
		err = borderStruct_Set()
		if err != nil {
			return
		}
		borderNewFunction, err = borderStruct.InvokerNew("new")
	})
	return err
}

// BorderNew is a representation of the C type gtk_border_new.
func BorderNew() *Border {

	var ret gi.Argument

	err := borderNewFunction_Set()
	if err == nil {
		ret = borderNewFunction.Invoke(nil, nil)
	}

	retGo := BorderNewFromNative(ret.Pointer())

	return retGo
}

var borderCopyFunction *gi.Function
var borderCopyFunction_Once sync.Once

func borderCopyFunction_Set() error {
	var err error
	borderCopyFunction_Once.Do(func() {
		err = borderStruct_Set()
		if err != nil {
			return
		}
		borderCopyFunction, err = borderStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_border_copy.
func (recv *Border) Copy() *Border {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := borderCopyFunction_Set()
	if err == nil {
		ret = borderCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := BorderNewFromNative(ret.Pointer())

	return retGo
}

var borderFreeFunction *gi.Function
var borderFreeFunction_Once sync.Once

func borderFreeFunction_Set() error {
	var err error
	borderFreeFunction_Once.Do(func() {
		err = borderStruct_Set()
		if err != nil {
			return
		}
		borderFreeFunction, err = borderStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_border_free.
func (recv *Border) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := borderFreeFunction_Set()
	if err == nil {
		borderFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var boxClassStruct *gi.Struct
var boxClassStruct_Once sync.Once

func boxClassStruct_Set() error {
	var err error
	boxClassStruct_Once.Do(func() {
		boxClassStruct, err = gi.StructNew("Gtk", "BoxClass")
	})
	return err
}

type BoxClass struct {
	native unsafe.Pointer
}

func BoxClassNewFromNative(native unsafe.Pointer) *BoxClass {
	err := boxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BoxClass{native: native}

	return instance
}

/*
CastToBoxClass down casts any arbitrary Object to BoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a BoxClass.
*/
func CastToBoxClass(object *gobject.Object) *BoxClass {
	return BoxClassNewFromNative(object.Native())
}

// Equals compares this BoxClass with another BoxClass, and returns true if they represent the same Object.
func (recv *BoxClass) Equals(other *BoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *BoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *BoxClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(boxClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *BoxClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(boxClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// BoxClassStruct creates an uninitialised BoxClass.
func BoxClassStruct() *BoxClass {
	err := boxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BoxClassNewFromNative(boxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBoxClass)
	return structGo
}
func finalizeBoxClass(obj *BoxClass) {
	boxClassStruct.Free(obj.Native())
}

var boxPrivateStruct *gi.Struct
var boxPrivateStruct_Once sync.Once

func boxPrivateStruct_Set() error {
	var err error
	boxPrivateStruct_Once.Do(func() {
		boxPrivateStruct, err = gi.StructNew("Gtk", "BoxPrivate")
	})
	return err
}

type BoxPrivate struct {
	native unsafe.Pointer
}

func BoxPrivateNewFromNative(native unsafe.Pointer) *BoxPrivate {
	err := boxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BoxPrivate{native: native}

	return instance
}

/*
CastToBoxPrivate down casts any arbitrary Object to BoxPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a BoxPrivate.
*/
func CastToBoxPrivate(object *gobject.Object) *BoxPrivate {
	return BoxPrivateNewFromNative(object.Native())
}

// Equals compares this BoxPrivate with another BoxPrivate, and returns true if they represent the same Object.
func (recv *BoxPrivate) Equals(other *BoxPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *BoxPrivate) Native() unsafe.Pointer {
	return recv.native
}

// BoxPrivateStruct creates an uninitialised BoxPrivate.
func BoxPrivateStruct() *BoxPrivate {
	err := boxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BoxPrivateNewFromNative(boxPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBoxPrivate)
	return structGo
}
func finalizeBoxPrivate(obj *BoxPrivate) {
	boxPrivateStruct.Free(obj.Native())
}

var buildableIfaceStruct *gi.Struct
var buildableIfaceStruct_Once sync.Once

func buildableIfaceStruct_Set() error {
	var err error
	buildableIfaceStruct_Once.Do(func() {
		buildableIfaceStruct, err = gi.StructNew("Gtk", "BuildableIface")
	})
	return err
}

type BuildableIface struct {
	native unsafe.Pointer
}

func BuildableIfaceNewFromNative(native unsafe.Pointer) *BuildableIface {
	err := buildableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BuildableIface{native: native}

	return instance
}

/*
CastToBuildableIface down casts any arbitrary Object to BuildableIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a BuildableIface.
*/
func CastToBuildableIface(object *gobject.Object) *BuildableIface {
	return BuildableIfaceNewFromNative(object.Native())
}

// Equals compares this BuildableIface with another BuildableIface, and returns true if they represent the same Object.
func (recv *BuildableIface) Equals(other *BuildableIface) bool {
	return other.Native() == recv.Native()
}

func (recv *BuildableIface) Native() unsafe.Pointer {
	return recv.native
}

// FieldGIface returns the C field 'g_iface'.
func (recv *BuildableIface) FieldGIface() *gobject.TypeInterface {
	argValue := gi.StructFieldGet(buildableIfaceStruct, recv.Native(), "g_iface")
	value := gobject.TypeInterfaceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldGIface sets the value of the C field 'g_iface'.
func (recv *BuildableIface) SetFieldGIface(value *gobject.TypeInterface) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(buildableIfaceStruct, recv.Native(), "g_iface", argValue)
}

// UNSUPPORTED : C value 'set_name' : for field getter : missing Type

// UNSUPPORTED : C value 'set_name' : for field setter : missing Type

// UNSUPPORTED : C value 'get_name' : for field getter : missing Type

// UNSUPPORTED : C value 'get_name' : for field setter : missing Type

// UNSUPPORTED : C value 'add_child' : for field getter : missing Type

// UNSUPPORTED : C value 'add_child' : for field setter : missing Type

// UNSUPPORTED : C value 'set_buildable_property' : for field getter : missing Type

// UNSUPPORTED : C value 'set_buildable_property' : for field setter : missing Type

// UNSUPPORTED : C value 'construct_child' : for field getter : missing Type

// UNSUPPORTED : C value 'construct_child' : for field setter : missing Type

// UNSUPPORTED : C value 'custom_tag_start' : for field getter : missing Type

// UNSUPPORTED : C value 'custom_tag_start' : for field setter : missing Type

// UNSUPPORTED : C value 'custom_tag_end' : for field getter : missing Type

// UNSUPPORTED : C value 'custom_tag_end' : for field setter : missing Type

// UNSUPPORTED : C value 'custom_finished' : for field getter : missing Type

// UNSUPPORTED : C value 'custom_finished' : for field setter : missing Type

// UNSUPPORTED : C value 'parser_finished' : for field getter : missing Type

// UNSUPPORTED : C value 'parser_finished' : for field setter : missing Type

// UNSUPPORTED : C value 'get_internal_child' : for field getter : missing Type

// UNSUPPORTED : C value 'get_internal_child' : for field setter : missing Type

// BuildableIfaceStruct creates an uninitialised BuildableIface.
func BuildableIfaceStruct() *BuildableIface {
	err := buildableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BuildableIfaceNewFromNative(buildableIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBuildableIface)
	return structGo
}
func finalizeBuildableIface(obj *BuildableIface) {
	buildableIfaceStruct.Free(obj.Native())
}

var builderClassStruct *gi.Struct
var builderClassStruct_Once sync.Once

func builderClassStruct_Set() error {
	var err error
	builderClassStruct_Once.Do(func() {
		builderClassStruct, err = gi.StructNew("Gtk", "BuilderClass")
	})
	return err
}

type BuilderClass struct {
	native unsafe.Pointer
}

func BuilderClassNewFromNative(native unsafe.Pointer) *BuilderClass {
	err := builderClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BuilderClass{native: native}

	return instance
}

/*
CastToBuilderClass down casts any arbitrary Object to BuilderClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a BuilderClass.
*/
func CastToBuilderClass(object *gobject.Object) *BuilderClass {
	return BuilderClassNewFromNative(object.Native())
}

// Equals compares this BuilderClass with another BuilderClass, and returns true if they represent the same Object.
func (recv *BuilderClass) Equals(other *BuilderClass) bool {
	return other.Native() == recv.Native()
}

func (recv *BuilderClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *BuilderClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(builderClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *BuilderClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(builderClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'get_type_from_name' : for field getter : missing Type

// UNSUPPORTED : C value 'get_type_from_name' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// BuilderClassStruct creates an uninitialised BuilderClass.
func BuilderClassStruct() *BuilderClass {
	err := builderClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BuilderClassNewFromNative(builderClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBuilderClass)
	return structGo
}
func finalizeBuilderClass(obj *BuilderClass) {
	builderClassStruct.Free(obj.Native())
}

var builderPrivateStruct *gi.Struct
var builderPrivateStruct_Once sync.Once

func builderPrivateStruct_Set() error {
	var err error
	builderPrivateStruct_Once.Do(func() {
		builderPrivateStruct, err = gi.StructNew("Gtk", "BuilderPrivate")
	})
	return err
}

type BuilderPrivate struct {
	native unsafe.Pointer
}

func BuilderPrivateNewFromNative(native unsafe.Pointer) *BuilderPrivate {
	err := builderPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &BuilderPrivate{native: native}

	return instance
}

/*
CastToBuilderPrivate down casts any arbitrary Object to BuilderPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a BuilderPrivate.
*/
func CastToBuilderPrivate(object *gobject.Object) *BuilderPrivate {
	return BuilderPrivateNewFromNative(object.Native())
}

// Equals compares this BuilderPrivate with another BuilderPrivate, and returns true if they represent the same Object.
func (recv *BuilderPrivate) Equals(other *BuilderPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *BuilderPrivate) Native() unsafe.Pointer {
	return recv.native
}

// BuilderPrivateStruct creates an uninitialised BuilderPrivate.
func BuilderPrivateStruct() *BuilderPrivate {
	err := builderPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := BuilderPrivateNewFromNative(builderPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeBuilderPrivate)
	return structGo
}
func finalizeBuilderPrivate(obj *BuilderPrivate) {
	builderPrivateStruct.Free(obj.Native())
}

var buttonAccessibleClassStruct *gi.Struct
var buttonAccessibleClassStruct_Once sync.Once

func buttonAccessibleClassStruct_Set() error {
	var err error
	buttonAccessibleClassStruct_Once.Do(func() {
		buttonAccessibleClassStruct, err = gi.StructNew("Gtk", "ButtonAccessibleClass")
	})
	return err
}

type ButtonAccessibleClass struct {
	native unsafe.Pointer
}

func ButtonAccessibleClassNewFromNative(native unsafe.Pointer) *ButtonAccessibleClass {
	err := buttonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ButtonAccessibleClass{native: native}

	return instance
}

/*
CastToButtonAccessibleClass down casts any arbitrary Object to ButtonAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ButtonAccessibleClass.
*/
func CastToButtonAccessibleClass(object *gobject.Object) *ButtonAccessibleClass {
	return ButtonAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ButtonAccessibleClass with another ButtonAccessibleClass, and returns true if they represent the same Object.
func (recv *ButtonAccessibleClass) Equals(other *ButtonAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ButtonAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ButtonAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(buttonAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ButtonAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(buttonAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ButtonAccessibleClassStruct creates an uninitialised ButtonAccessibleClass.
func ButtonAccessibleClassStruct() *ButtonAccessibleClass {
	err := buttonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ButtonAccessibleClassNewFromNative(buttonAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeButtonAccessibleClass)
	return structGo
}
func finalizeButtonAccessibleClass(obj *ButtonAccessibleClass) {
	buttonAccessibleClassStruct.Free(obj.Native())
}

var buttonAccessiblePrivateStruct *gi.Struct
var buttonAccessiblePrivateStruct_Once sync.Once

func buttonAccessiblePrivateStruct_Set() error {
	var err error
	buttonAccessiblePrivateStruct_Once.Do(func() {
		buttonAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ButtonAccessiblePrivate")
	})
	return err
}

type ButtonAccessiblePrivate struct {
	native unsafe.Pointer
}

func ButtonAccessiblePrivateNewFromNative(native unsafe.Pointer) *ButtonAccessiblePrivate {
	err := buttonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ButtonAccessiblePrivate{native: native}

	return instance
}

/*
CastToButtonAccessiblePrivate down casts any arbitrary Object to ButtonAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ButtonAccessiblePrivate.
*/
func CastToButtonAccessiblePrivate(object *gobject.Object) *ButtonAccessiblePrivate {
	return ButtonAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ButtonAccessiblePrivate with another ButtonAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ButtonAccessiblePrivate) Equals(other *ButtonAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ButtonAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ButtonAccessiblePrivateStruct creates an uninitialised ButtonAccessiblePrivate.
func ButtonAccessiblePrivateStruct() *ButtonAccessiblePrivate {
	err := buttonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ButtonAccessiblePrivateNewFromNative(buttonAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeButtonAccessiblePrivate)
	return structGo
}
func finalizeButtonAccessiblePrivate(obj *ButtonAccessiblePrivate) {
	buttonAccessiblePrivateStruct.Free(obj.Native())
}

var buttonBoxClassStruct *gi.Struct
var buttonBoxClassStruct_Once sync.Once

func buttonBoxClassStruct_Set() error {
	var err error
	buttonBoxClassStruct_Once.Do(func() {
		buttonBoxClassStruct, err = gi.StructNew("Gtk", "ButtonBoxClass")
	})
	return err
}

type ButtonBoxClass struct {
	native unsafe.Pointer
}

func ButtonBoxClassNewFromNative(native unsafe.Pointer) *ButtonBoxClass {
	err := buttonBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ButtonBoxClass{native: native}

	return instance
}

/*
CastToButtonBoxClass down casts any arbitrary Object to ButtonBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ButtonBoxClass.
*/
func CastToButtonBoxClass(object *gobject.Object) *ButtonBoxClass {
	return ButtonBoxClassNewFromNative(object.Native())
}

// Equals compares this ButtonBoxClass with another ButtonBoxClass, and returns true if they represent the same Object.
func (recv *ButtonBoxClass) Equals(other *ButtonBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ButtonBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ButtonBoxClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(buttonBoxClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ButtonBoxClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(buttonBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ButtonBoxClassStruct creates an uninitialised ButtonBoxClass.
func ButtonBoxClassStruct() *ButtonBoxClass {
	err := buttonBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ButtonBoxClassNewFromNative(buttonBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeButtonBoxClass)
	return structGo
}
func finalizeButtonBoxClass(obj *ButtonBoxClass) {
	buttonBoxClassStruct.Free(obj.Native())
}

var buttonBoxPrivateStruct *gi.Struct
var buttonBoxPrivateStruct_Once sync.Once

func buttonBoxPrivateStruct_Set() error {
	var err error
	buttonBoxPrivateStruct_Once.Do(func() {
		buttonBoxPrivateStruct, err = gi.StructNew("Gtk", "ButtonBoxPrivate")
	})
	return err
}

type ButtonBoxPrivate struct {
	native unsafe.Pointer
}

func ButtonBoxPrivateNewFromNative(native unsafe.Pointer) *ButtonBoxPrivate {
	err := buttonBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ButtonBoxPrivate{native: native}

	return instance
}

/*
CastToButtonBoxPrivate down casts any arbitrary Object to ButtonBoxPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ButtonBoxPrivate.
*/
func CastToButtonBoxPrivate(object *gobject.Object) *ButtonBoxPrivate {
	return ButtonBoxPrivateNewFromNative(object.Native())
}

// Equals compares this ButtonBoxPrivate with another ButtonBoxPrivate, and returns true if they represent the same Object.
func (recv *ButtonBoxPrivate) Equals(other *ButtonBoxPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ButtonBoxPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ButtonBoxPrivateStruct creates an uninitialised ButtonBoxPrivate.
func ButtonBoxPrivateStruct() *ButtonBoxPrivate {
	err := buttonBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ButtonBoxPrivateNewFromNative(buttonBoxPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeButtonBoxPrivate)
	return structGo
}
func finalizeButtonBoxPrivate(obj *ButtonBoxPrivate) {
	buttonBoxPrivateStruct.Free(obj.Native())
}

var buttonClassStruct *gi.Struct
var buttonClassStruct_Once sync.Once

func buttonClassStruct_Set() error {
	var err error
	buttonClassStruct_Once.Do(func() {
		buttonClassStruct, err = gi.StructNew("Gtk", "ButtonClass")
	})
	return err
}

type ButtonClass struct {
	native unsafe.Pointer
}

func ButtonClassNewFromNative(native unsafe.Pointer) *ButtonClass {
	err := buttonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ButtonClass{native: native}

	return instance
}

/*
CastToButtonClass down casts any arbitrary Object to ButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ButtonClass.
*/
func CastToButtonClass(object *gobject.Object) *ButtonClass {
	return ButtonClassNewFromNative(object.Native())
}

// Equals compares this ButtonClass with another ButtonClass, and returns true if they represent the same Object.
func (recv *ButtonClass) Equals(other *ButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ButtonClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(buttonClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ButtonClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(buttonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'pressed' : for field getter : missing Type

// UNSUPPORTED : C value 'pressed' : for field setter : missing Type

// UNSUPPORTED : C value 'released' : for field getter : missing Type

// UNSUPPORTED : C value 'released' : for field setter : missing Type

// UNSUPPORTED : C value 'clicked' : for field getter : missing Type

// UNSUPPORTED : C value 'clicked' : for field setter : missing Type

// UNSUPPORTED : C value 'enter' : for field getter : missing Type

// UNSUPPORTED : C value 'enter' : for field setter : missing Type

// UNSUPPORTED : C value 'leave' : for field getter : missing Type

// UNSUPPORTED : C value 'leave' : for field setter : missing Type

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ButtonClassStruct creates an uninitialised ButtonClass.
func ButtonClassStruct() *ButtonClass {
	err := buttonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ButtonClassNewFromNative(buttonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeButtonClass)
	return structGo
}
func finalizeButtonClass(obj *ButtonClass) {
	buttonClassStruct.Free(obj.Native())
}

var buttonPrivateStruct *gi.Struct
var buttonPrivateStruct_Once sync.Once

func buttonPrivateStruct_Set() error {
	var err error
	buttonPrivateStruct_Once.Do(func() {
		buttonPrivateStruct, err = gi.StructNew("Gtk", "ButtonPrivate")
	})
	return err
}

type ButtonPrivate struct {
	native unsafe.Pointer
}

func ButtonPrivateNewFromNative(native unsafe.Pointer) *ButtonPrivate {
	err := buttonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ButtonPrivate{native: native}

	return instance
}

/*
CastToButtonPrivate down casts any arbitrary Object to ButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ButtonPrivate.
*/
func CastToButtonPrivate(object *gobject.Object) *ButtonPrivate {
	return ButtonPrivateNewFromNative(object.Native())
}

// Equals compares this ButtonPrivate with another ButtonPrivate, and returns true if they represent the same Object.
func (recv *ButtonPrivate) Equals(other *ButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ButtonPrivateStruct creates an uninitialised ButtonPrivate.
func ButtonPrivateStruct() *ButtonPrivate {
	err := buttonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ButtonPrivateNewFromNative(buttonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeButtonPrivate)
	return structGo
}
func finalizeButtonPrivate(obj *ButtonPrivate) {
	buttonPrivateStruct.Free(obj.Native())
}

var calendarClassStruct *gi.Struct
var calendarClassStruct_Once sync.Once

func calendarClassStruct_Set() error {
	var err error
	calendarClassStruct_Once.Do(func() {
		calendarClassStruct, err = gi.StructNew("Gtk", "CalendarClass")
	})
	return err
}

type CalendarClass struct {
	native unsafe.Pointer
}

func CalendarClassNewFromNative(native unsafe.Pointer) *CalendarClass {
	err := calendarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CalendarClass{native: native}

	return instance
}

/*
CastToCalendarClass down casts any arbitrary Object to CalendarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CalendarClass.
*/
func CastToCalendarClass(object *gobject.Object) *CalendarClass {
	return CalendarClassNewFromNative(object.Native())
}

// Equals compares this CalendarClass with another CalendarClass, and returns true if they represent the same Object.
func (recv *CalendarClass) Equals(other *CalendarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CalendarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CalendarClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(calendarClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CalendarClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(calendarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'month_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'month_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'day_selected' : for field getter : missing Type

// UNSUPPORTED : C value 'day_selected' : for field setter : missing Type

// UNSUPPORTED : C value 'day_selected_double_click' : for field getter : missing Type

// UNSUPPORTED : C value 'day_selected_double_click' : for field setter : missing Type

// UNSUPPORTED : C value 'prev_month' : for field getter : missing Type

// UNSUPPORTED : C value 'prev_month' : for field setter : missing Type

// UNSUPPORTED : C value 'next_month' : for field getter : missing Type

// UNSUPPORTED : C value 'next_month' : for field setter : missing Type

// UNSUPPORTED : C value 'prev_year' : for field getter : missing Type

// UNSUPPORTED : C value 'prev_year' : for field setter : missing Type

// UNSUPPORTED : C value 'next_year' : for field getter : missing Type

// UNSUPPORTED : C value 'next_year' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CalendarClassStruct creates an uninitialised CalendarClass.
func CalendarClassStruct() *CalendarClass {
	err := calendarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CalendarClassNewFromNative(calendarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCalendarClass)
	return structGo
}
func finalizeCalendarClass(obj *CalendarClass) {
	calendarClassStruct.Free(obj.Native())
}

var calendarPrivateStruct *gi.Struct
var calendarPrivateStruct_Once sync.Once

func calendarPrivateStruct_Set() error {
	var err error
	calendarPrivateStruct_Once.Do(func() {
		calendarPrivateStruct, err = gi.StructNew("Gtk", "CalendarPrivate")
	})
	return err
}

type CalendarPrivate struct {
	native unsafe.Pointer
}

func CalendarPrivateNewFromNative(native unsafe.Pointer) *CalendarPrivate {
	err := calendarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CalendarPrivate{native: native}

	return instance
}

/*
CastToCalendarPrivate down casts any arbitrary Object to CalendarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CalendarPrivate.
*/
func CastToCalendarPrivate(object *gobject.Object) *CalendarPrivate {
	return CalendarPrivateNewFromNative(object.Native())
}

// Equals compares this CalendarPrivate with another CalendarPrivate, and returns true if they represent the same Object.
func (recv *CalendarPrivate) Equals(other *CalendarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CalendarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CalendarPrivateStruct creates an uninitialised CalendarPrivate.
func CalendarPrivateStruct() *CalendarPrivate {
	err := calendarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CalendarPrivateNewFromNative(calendarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCalendarPrivate)
	return structGo
}
func finalizeCalendarPrivate(obj *CalendarPrivate) {
	calendarPrivateStruct.Free(obj.Native())
}

var cellAccessibleClassStruct *gi.Struct
var cellAccessibleClassStruct_Once sync.Once

func cellAccessibleClassStruct_Set() error {
	var err error
	cellAccessibleClassStruct_Once.Do(func() {
		cellAccessibleClassStruct, err = gi.StructNew("Gtk", "CellAccessibleClass")
	})
	return err
}

type CellAccessibleClass struct {
	native unsafe.Pointer
}

func CellAccessibleClassNewFromNative(native unsafe.Pointer) *CellAccessibleClass {
	err := cellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAccessibleClass{native: native}

	return instance
}

/*
CastToCellAccessibleClass down casts any arbitrary Object to CellAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAccessibleClass.
*/
func CastToCellAccessibleClass(object *gobject.Object) *CellAccessibleClass {
	return CellAccessibleClassNewFromNative(object.Native())
}

// Equals compares this CellAccessibleClass with another CellAccessibleClass, and returns true if they represent the same Object.
func (recv *CellAccessibleClass) Equals(other *CellAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CellAccessibleClass) FieldParentClass() *AccessibleClass {
	argValue := gi.StructFieldGet(cellAccessibleClassStruct, recv.Native(), "parent_class")
	value := AccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CellAccessibleClass) SetFieldParentClass(value *AccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'update_cache' : for field getter : missing Type

// UNSUPPORTED : C value 'update_cache' : for field setter : missing Type

// CellAccessibleClassStruct creates an uninitialised CellAccessibleClass.
func CellAccessibleClassStruct() *CellAccessibleClass {
	err := cellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAccessibleClassNewFromNative(cellAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAccessibleClass)
	return structGo
}
func finalizeCellAccessibleClass(obj *CellAccessibleClass) {
	cellAccessibleClassStruct.Free(obj.Native())
}

var cellAccessibleParentIfaceStruct *gi.Struct
var cellAccessibleParentIfaceStruct_Once sync.Once

func cellAccessibleParentIfaceStruct_Set() error {
	var err error
	cellAccessibleParentIfaceStruct_Once.Do(func() {
		cellAccessibleParentIfaceStruct, err = gi.StructNew("Gtk", "CellAccessibleParentIface")
	})
	return err
}

type CellAccessibleParentIface struct {
	native unsafe.Pointer
}

func CellAccessibleParentIfaceNewFromNative(native unsafe.Pointer) *CellAccessibleParentIface {
	err := cellAccessibleParentIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAccessibleParentIface{native: native}

	return instance
}

/*
CastToCellAccessibleParentIface down casts any arbitrary Object to CellAccessibleParentIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAccessibleParentIface.
*/
func CastToCellAccessibleParentIface(object *gobject.Object) *CellAccessibleParentIface {
	return CellAccessibleParentIfaceNewFromNative(object.Native())
}

// Equals compares this CellAccessibleParentIface with another CellAccessibleParentIface, and returns true if they represent the same Object.
func (recv *CellAccessibleParentIface) Equals(other *CellAccessibleParentIface) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAccessibleParentIface) Native() unsafe.Pointer {
	return recv.native
}

// FieldParent returns the C field 'parent'.
func (recv *CellAccessibleParentIface) FieldParent() *gobject.TypeInterface {
	argValue := gi.StructFieldGet(cellAccessibleParentIfaceStruct, recv.Native(), "parent")
	value := gobject.TypeInterfaceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParent sets the value of the C field 'parent'.
func (recv *CellAccessibleParentIface) SetFieldParent(value *gobject.TypeInterface) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellAccessibleParentIfaceStruct, recv.Native(), "parent", argValue)
}

// UNSUPPORTED : C value 'get_cell_extents' : for field getter : missing Type

// UNSUPPORTED : C value 'get_cell_extents' : for field setter : missing Type

// UNSUPPORTED : C value 'get_cell_area' : for field getter : missing Type

// UNSUPPORTED : C value 'get_cell_area' : for field setter : missing Type

// UNSUPPORTED : C value 'grab_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'grab_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'get_child_index' : for field getter : missing Type

// UNSUPPORTED : C value 'get_child_index' : for field setter : missing Type

// UNSUPPORTED : C value 'get_renderer_state' : for field getter : missing Type

// UNSUPPORTED : C value 'get_renderer_state' : for field setter : missing Type

// UNSUPPORTED : C value 'expand_collapse' : for field getter : missing Type

// UNSUPPORTED : C value 'expand_collapse' : for field setter : missing Type

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value 'edit' : for field getter : missing Type

// UNSUPPORTED : C value 'edit' : for field setter : missing Type

// UNSUPPORTED : C value 'update_relationset' : for field getter : missing Type

// UNSUPPORTED : C value 'update_relationset' : for field setter : missing Type

// UNSUPPORTED : C value 'get_cell_position' : for field getter : missing Type

// UNSUPPORTED : C value 'get_cell_position' : for field setter : missing Type

// UNSUPPORTED : C value 'get_column_header_cells' : for field getter : missing Type

// UNSUPPORTED : C value 'get_column_header_cells' : for field setter : missing Type

// UNSUPPORTED : C value 'get_row_header_cells' : for field getter : missing Type

// UNSUPPORTED : C value 'get_row_header_cells' : for field setter : missing Type

// CellAccessibleParentIfaceStruct creates an uninitialised CellAccessibleParentIface.
func CellAccessibleParentIfaceStruct() *CellAccessibleParentIface {
	err := cellAccessibleParentIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAccessibleParentIfaceNewFromNative(cellAccessibleParentIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAccessibleParentIface)
	return structGo
}
func finalizeCellAccessibleParentIface(obj *CellAccessibleParentIface) {
	cellAccessibleParentIfaceStruct.Free(obj.Native())
}

var cellAccessiblePrivateStruct *gi.Struct
var cellAccessiblePrivateStruct_Once sync.Once

func cellAccessiblePrivateStruct_Set() error {
	var err error
	cellAccessiblePrivateStruct_Once.Do(func() {
		cellAccessiblePrivateStruct, err = gi.StructNew("Gtk", "CellAccessiblePrivate")
	})
	return err
}

type CellAccessiblePrivate struct {
	native unsafe.Pointer
}

func CellAccessiblePrivateNewFromNative(native unsafe.Pointer) *CellAccessiblePrivate {
	err := cellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAccessiblePrivate{native: native}

	return instance
}

/*
CastToCellAccessiblePrivate down casts any arbitrary Object to CellAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAccessiblePrivate.
*/
func CastToCellAccessiblePrivate(object *gobject.Object) *CellAccessiblePrivate {
	return CellAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this CellAccessiblePrivate with another CellAccessiblePrivate, and returns true if they represent the same Object.
func (recv *CellAccessiblePrivate) Equals(other *CellAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellAccessiblePrivateStruct creates an uninitialised CellAccessiblePrivate.
func CellAccessiblePrivateStruct() *CellAccessiblePrivate {
	err := cellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAccessiblePrivateNewFromNative(cellAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAccessiblePrivate)
	return structGo
}
func finalizeCellAccessiblePrivate(obj *CellAccessiblePrivate) {
	cellAccessiblePrivateStruct.Free(obj.Native())
}

var cellAreaBoxClassStruct *gi.Struct
var cellAreaBoxClassStruct_Once sync.Once

func cellAreaBoxClassStruct_Set() error {
	var err error
	cellAreaBoxClassStruct_Once.Do(func() {
		cellAreaBoxClassStruct, err = gi.StructNew("Gtk", "CellAreaBoxClass")
	})
	return err
}

type CellAreaBoxClass struct {
	native unsafe.Pointer
}

func CellAreaBoxClassNewFromNative(native unsafe.Pointer) *CellAreaBoxClass {
	err := cellAreaBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAreaBoxClass{native: native}

	return instance
}

/*
CastToCellAreaBoxClass down casts any arbitrary Object to CellAreaBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAreaBoxClass.
*/
func CastToCellAreaBoxClass(object *gobject.Object) *CellAreaBoxClass {
	return CellAreaBoxClassNewFromNative(object.Native())
}

// Equals compares this CellAreaBoxClass with another CellAreaBoxClass, and returns true if they represent the same Object.
func (recv *CellAreaBoxClass) Equals(other *CellAreaBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAreaBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellAreaBoxClassStruct creates an uninitialised CellAreaBoxClass.
func CellAreaBoxClassStruct() *CellAreaBoxClass {
	err := cellAreaBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAreaBoxClassNewFromNative(cellAreaBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAreaBoxClass)
	return structGo
}
func finalizeCellAreaBoxClass(obj *CellAreaBoxClass) {
	cellAreaBoxClassStruct.Free(obj.Native())
}

var cellAreaBoxPrivateStruct *gi.Struct
var cellAreaBoxPrivateStruct_Once sync.Once

func cellAreaBoxPrivateStruct_Set() error {
	var err error
	cellAreaBoxPrivateStruct_Once.Do(func() {
		cellAreaBoxPrivateStruct, err = gi.StructNew("Gtk", "CellAreaBoxPrivate")
	})
	return err
}

type CellAreaBoxPrivate struct {
	native unsafe.Pointer
}

func CellAreaBoxPrivateNewFromNative(native unsafe.Pointer) *CellAreaBoxPrivate {
	err := cellAreaBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAreaBoxPrivate{native: native}

	return instance
}

/*
CastToCellAreaBoxPrivate down casts any arbitrary Object to CellAreaBoxPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAreaBoxPrivate.
*/
func CastToCellAreaBoxPrivate(object *gobject.Object) *CellAreaBoxPrivate {
	return CellAreaBoxPrivateNewFromNative(object.Native())
}

// Equals compares this CellAreaBoxPrivate with another CellAreaBoxPrivate, and returns true if they represent the same Object.
func (recv *CellAreaBoxPrivate) Equals(other *CellAreaBoxPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAreaBoxPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellAreaBoxPrivateStruct creates an uninitialised CellAreaBoxPrivate.
func CellAreaBoxPrivateStruct() *CellAreaBoxPrivate {
	err := cellAreaBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAreaBoxPrivateNewFromNative(cellAreaBoxPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAreaBoxPrivate)
	return structGo
}
func finalizeCellAreaBoxPrivate(obj *CellAreaBoxPrivate) {
	cellAreaBoxPrivateStruct.Free(obj.Native())
}

var cellAreaClassStruct *gi.Struct
var cellAreaClassStruct_Once sync.Once

func cellAreaClassStruct_Set() error {
	var err error
	cellAreaClassStruct_Once.Do(func() {
		cellAreaClassStruct, err = gi.StructNew("Gtk", "CellAreaClass")
	})
	return err
}

type CellAreaClass struct {
	native unsafe.Pointer
}

func CellAreaClassNewFromNative(native unsafe.Pointer) *CellAreaClass {
	err := cellAreaClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAreaClass{native: native}

	return instance
}

/*
CastToCellAreaClass down casts any arbitrary Object to CellAreaClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAreaClass.
*/
func CastToCellAreaClass(object *gobject.Object) *CellAreaClass {
	return CellAreaClassNewFromNative(object.Native())
}

// Equals compares this CellAreaClass with another CellAreaClass, and returns true if they represent the same Object.
func (recv *CellAreaClass) Equals(other *CellAreaClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAreaClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'add' : for field getter : missing Type

// UNSUPPORTED : C value 'add' : for field setter : missing Type

// UNSUPPORTED : C value 'remove' : for field getter : missing Type

// UNSUPPORTED : C value 'remove' : for field setter : missing Type

// UNSUPPORTED : C value 'foreach' : for field getter : missing Type

// UNSUPPORTED : C value 'foreach' : for field setter : missing Type

// UNSUPPORTED : C value 'foreach_alloc' : for field getter : missing Type

// UNSUPPORTED : C value 'foreach_alloc' : for field setter : missing Type

// UNSUPPORTED : C value 'event' : for field getter : missing Type

// UNSUPPORTED : C value 'event' : for field setter : missing Type

// UNSUPPORTED : C value 'render' : for field getter : missing Type

// UNSUPPORTED : C value 'render' : for field setter : missing Type

// UNSUPPORTED : C value 'apply_attributes' : for field getter : missing Type

// UNSUPPORTED : C value 'apply_attributes' : for field setter : missing Type

// UNSUPPORTED : C value 'create_context' : for field getter : missing Type

// UNSUPPORTED : C value 'create_context' : for field setter : missing Type

// UNSUPPORTED : C value 'copy_context' : for field getter : missing Type

// UNSUPPORTED : C value 'copy_context' : for field setter : missing Type

// UNSUPPORTED : C value 'get_request_mode' : for field getter : missing Type

// UNSUPPORTED : C value 'get_request_mode' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_width' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_width' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_for_width' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_for_width' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_height' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_height' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_width_for_height' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_width_for_height' : for field setter : missing Type

// UNSUPPORTED : C value 'set_cell_property' : for field getter : missing Type

// UNSUPPORTED : C value 'set_cell_property' : for field setter : missing Type

// UNSUPPORTED : C value 'get_cell_property' : for field getter : missing Type

// UNSUPPORTED : C value 'get_cell_property' : for field setter : missing Type

// UNSUPPORTED : C value 'focus' : for field getter : missing Type

// UNSUPPORTED : C value 'focus' : for field setter : missing Type

// UNSUPPORTED : C value 'is_activatable' : for field getter : missing Type

// UNSUPPORTED : C value 'is_activatable' : for field setter : missing Type

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

var cellAreaClassFindCellPropertyFunction *gi.Function
var cellAreaClassFindCellPropertyFunction_Once sync.Once

func cellAreaClassFindCellPropertyFunction_Set() error {
	var err error
	cellAreaClassFindCellPropertyFunction_Once.Do(func() {
		err = cellAreaClassStruct_Set()
		if err != nil {
			return
		}
		cellAreaClassFindCellPropertyFunction, err = cellAreaClassStruct.InvokerNew("find_cell_property")
	})
	return err
}

// FindCellProperty is a representation of the C type gtk_cell_area_class_find_cell_property.
func (recv *CellAreaClass) FindCellProperty(propertyName string) *gobject.ParamSpec {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(propertyName)

	var ret gi.Argument

	err := cellAreaClassFindCellPropertyFunction_Set()
	if err == nil {
		ret = cellAreaClassFindCellPropertyFunction.Invoke(inArgs[:], nil)
	}

	retGo := gobject.ParamSpecNewFromNative(ret.Pointer())

	return retGo
}

var cellAreaClassInstallCellPropertyFunction *gi.Function
var cellAreaClassInstallCellPropertyFunction_Once sync.Once

func cellAreaClassInstallCellPropertyFunction_Set() error {
	var err error
	cellAreaClassInstallCellPropertyFunction_Once.Do(func() {
		err = cellAreaClassStruct_Set()
		if err != nil {
			return
		}
		cellAreaClassInstallCellPropertyFunction, err = cellAreaClassStruct.InvokerNew("install_cell_property")
	})
	return err
}

// InstallCellProperty is a representation of the C type gtk_cell_area_class_install_cell_property.
func (recv *CellAreaClass) InstallCellProperty(propertyId uint32, pspec *gobject.ParamSpec) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetUint32(propertyId)
	inArgs[2].SetPointer(pspec.Native())

	err := cellAreaClassInstallCellPropertyFunction_Set()
	if err == nil {
		cellAreaClassInstallCellPropertyFunction.Invoke(inArgs[:], nil)
	}

	return
}

var cellAreaClassListCellPropertiesFunction *gi.Function
var cellAreaClassListCellPropertiesFunction_Once sync.Once

func cellAreaClassListCellPropertiesFunction_Set() error {
	var err error
	cellAreaClassListCellPropertiesFunction_Once.Do(func() {
		err = cellAreaClassStruct_Set()
		if err != nil {
			return
		}
		cellAreaClassListCellPropertiesFunction, err = cellAreaClassStruct.InvokerNew("list_cell_properties")
	})
	return err
}

// ListCellProperties is a representation of the C type gtk_cell_area_class_list_cell_properties.
func (recv *CellAreaClass) ListCellProperties() uint32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var outArgs [1]gi.Argument

	err := cellAreaClassListCellPropertiesFunction_Set()
	if err == nil {
		cellAreaClassListCellPropertiesFunction.Invoke(inArgs[:], outArgs[:])
	}

	out0 := outArgs[0].Uint32()

	return out0
}

// CellAreaClassStruct creates an uninitialised CellAreaClass.
func CellAreaClassStruct() *CellAreaClass {
	err := cellAreaClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAreaClassNewFromNative(cellAreaClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAreaClass)
	return structGo
}
func finalizeCellAreaClass(obj *CellAreaClass) {
	cellAreaClassStruct.Free(obj.Native())
}

var cellAreaContextClassStruct *gi.Struct
var cellAreaContextClassStruct_Once sync.Once

func cellAreaContextClassStruct_Set() error {
	var err error
	cellAreaContextClassStruct_Once.Do(func() {
		cellAreaContextClassStruct, err = gi.StructNew("Gtk", "CellAreaContextClass")
	})
	return err
}

type CellAreaContextClass struct {
	native unsafe.Pointer
}

func CellAreaContextClassNewFromNative(native unsafe.Pointer) *CellAreaContextClass {
	err := cellAreaContextClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAreaContextClass{native: native}

	return instance
}

/*
CastToCellAreaContextClass down casts any arbitrary Object to CellAreaContextClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAreaContextClass.
*/
func CastToCellAreaContextClass(object *gobject.Object) *CellAreaContextClass {
	return CellAreaContextClassNewFromNative(object.Native())
}

// Equals compares this CellAreaContextClass with another CellAreaContextClass, and returns true if they represent the same Object.
func (recv *CellAreaContextClass) Equals(other *CellAreaContextClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAreaContextClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'allocate' : for field getter : missing Type

// UNSUPPORTED : C value 'allocate' : for field setter : missing Type

// UNSUPPORTED : C value 'reset' : for field getter : missing Type

// UNSUPPORTED : C value 'reset' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_for_width' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_for_width' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_width_for_height' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_width_for_height' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// CellAreaContextClassStruct creates an uninitialised CellAreaContextClass.
func CellAreaContextClassStruct() *CellAreaContextClass {
	err := cellAreaContextClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAreaContextClassNewFromNative(cellAreaContextClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAreaContextClass)
	return structGo
}
func finalizeCellAreaContextClass(obj *CellAreaContextClass) {
	cellAreaContextClassStruct.Free(obj.Native())
}

var cellAreaContextPrivateStruct *gi.Struct
var cellAreaContextPrivateStruct_Once sync.Once

func cellAreaContextPrivateStruct_Set() error {
	var err error
	cellAreaContextPrivateStruct_Once.Do(func() {
		cellAreaContextPrivateStruct, err = gi.StructNew("Gtk", "CellAreaContextPrivate")
	})
	return err
}

type CellAreaContextPrivate struct {
	native unsafe.Pointer
}

func CellAreaContextPrivateNewFromNative(native unsafe.Pointer) *CellAreaContextPrivate {
	err := cellAreaContextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAreaContextPrivate{native: native}

	return instance
}

/*
CastToCellAreaContextPrivate down casts any arbitrary Object to CellAreaContextPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAreaContextPrivate.
*/
func CastToCellAreaContextPrivate(object *gobject.Object) *CellAreaContextPrivate {
	return CellAreaContextPrivateNewFromNative(object.Native())
}

// Equals compares this CellAreaContextPrivate with another CellAreaContextPrivate, and returns true if they represent the same Object.
func (recv *CellAreaContextPrivate) Equals(other *CellAreaContextPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAreaContextPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellAreaContextPrivateStruct creates an uninitialised CellAreaContextPrivate.
func CellAreaContextPrivateStruct() *CellAreaContextPrivate {
	err := cellAreaContextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAreaContextPrivateNewFromNative(cellAreaContextPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAreaContextPrivate)
	return structGo
}
func finalizeCellAreaContextPrivate(obj *CellAreaContextPrivate) {
	cellAreaContextPrivateStruct.Free(obj.Native())
}

var cellAreaPrivateStruct *gi.Struct
var cellAreaPrivateStruct_Once sync.Once

func cellAreaPrivateStruct_Set() error {
	var err error
	cellAreaPrivateStruct_Once.Do(func() {
		cellAreaPrivateStruct, err = gi.StructNew("Gtk", "CellAreaPrivate")
	})
	return err
}

type CellAreaPrivate struct {
	native unsafe.Pointer
}

func CellAreaPrivateNewFromNative(native unsafe.Pointer) *CellAreaPrivate {
	err := cellAreaPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellAreaPrivate{native: native}

	return instance
}

/*
CastToCellAreaPrivate down casts any arbitrary Object to CellAreaPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellAreaPrivate.
*/
func CastToCellAreaPrivate(object *gobject.Object) *CellAreaPrivate {
	return CellAreaPrivateNewFromNative(object.Native())
}

// Equals compares this CellAreaPrivate with another CellAreaPrivate, and returns true if they represent the same Object.
func (recv *CellAreaPrivate) Equals(other *CellAreaPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellAreaPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellAreaPrivateStruct creates an uninitialised CellAreaPrivate.
func CellAreaPrivateStruct() *CellAreaPrivate {
	err := cellAreaPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellAreaPrivateNewFromNative(cellAreaPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellAreaPrivate)
	return structGo
}
func finalizeCellAreaPrivate(obj *CellAreaPrivate) {
	cellAreaPrivateStruct.Free(obj.Native())
}

var cellEditableIfaceStruct *gi.Struct
var cellEditableIfaceStruct_Once sync.Once

func cellEditableIfaceStruct_Set() error {
	var err error
	cellEditableIfaceStruct_Once.Do(func() {
		cellEditableIfaceStruct, err = gi.StructNew("Gtk", "CellEditableIface")
	})
	return err
}

type CellEditableIface struct {
	native unsafe.Pointer
}

func CellEditableIfaceNewFromNative(native unsafe.Pointer) *CellEditableIface {
	err := cellEditableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellEditableIface{native: native}

	return instance
}

/*
CastToCellEditableIface down casts any arbitrary Object to CellEditableIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellEditableIface.
*/
func CastToCellEditableIface(object *gobject.Object) *CellEditableIface {
	return CellEditableIfaceNewFromNative(object.Native())
}

// Equals compares this CellEditableIface with another CellEditableIface, and returns true if they represent the same Object.
func (recv *CellEditableIface) Equals(other *CellEditableIface) bool {
	return other.Native() == recv.Native()
}

func (recv *CellEditableIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'editing_done' : for field getter : missing Type

// UNSUPPORTED : C value 'editing_done' : for field setter : missing Type

// UNSUPPORTED : C value 'remove_widget' : for field getter : missing Type

// UNSUPPORTED : C value 'remove_widget' : for field setter : missing Type

// UNSUPPORTED : C value 'start_editing' : for field getter : missing Type

// UNSUPPORTED : C value 'start_editing' : for field setter : missing Type

// CellEditableIfaceStruct creates an uninitialised CellEditableIface.
func CellEditableIfaceStruct() *CellEditableIface {
	err := cellEditableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellEditableIfaceNewFromNative(cellEditableIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellEditableIface)
	return structGo
}
func finalizeCellEditableIface(obj *CellEditableIface) {
	cellEditableIfaceStruct.Free(obj.Native())
}

var cellLayoutIfaceStruct *gi.Struct
var cellLayoutIfaceStruct_Once sync.Once

func cellLayoutIfaceStruct_Set() error {
	var err error
	cellLayoutIfaceStruct_Once.Do(func() {
		cellLayoutIfaceStruct, err = gi.StructNew("Gtk", "CellLayoutIface")
	})
	return err
}

type CellLayoutIface struct {
	native unsafe.Pointer
}

func CellLayoutIfaceNewFromNative(native unsafe.Pointer) *CellLayoutIface {
	err := cellLayoutIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellLayoutIface{native: native}

	return instance
}

/*
CastToCellLayoutIface down casts any arbitrary Object to CellLayoutIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellLayoutIface.
*/
func CastToCellLayoutIface(object *gobject.Object) *CellLayoutIface {
	return CellLayoutIfaceNewFromNative(object.Native())
}

// Equals compares this CellLayoutIface with another CellLayoutIface, and returns true if they represent the same Object.
func (recv *CellLayoutIface) Equals(other *CellLayoutIface) bool {
	return other.Native() == recv.Native()
}

func (recv *CellLayoutIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'pack_start' : for field getter : missing Type

// UNSUPPORTED : C value 'pack_start' : for field setter : missing Type

// UNSUPPORTED : C value 'pack_end' : for field getter : missing Type

// UNSUPPORTED : C value 'pack_end' : for field setter : missing Type

// UNSUPPORTED : C value 'clear' : for field getter : missing Type

// UNSUPPORTED : C value 'clear' : for field setter : missing Type

// UNSUPPORTED : C value 'add_attribute' : for field getter : missing Type

// UNSUPPORTED : C value 'add_attribute' : for field setter : missing Type

// UNSUPPORTED : C value 'set_cell_data_func' : for field getter : missing Type

// UNSUPPORTED : C value 'set_cell_data_func' : for field setter : missing Type

// UNSUPPORTED : C value 'clear_attributes' : for field getter : missing Type

// UNSUPPORTED : C value 'clear_attributes' : for field setter : missing Type

// UNSUPPORTED : C value 'reorder' : for field getter : missing Type

// UNSUPPORTED : C value 'reorder' : for field setter : missing Type

// UNSUPPORTED : C value 'get_cells' : for field getter : missing Type

// UNSUPPORTED : C value 'get_cells' : for field setter : missing Type

// UNSUPPORTED : C value 'get_area' : for field getter : missing Type

// UNSUPPORTED : C value 'get_area' : for field setter : missing Type

// CellLayoutIfaceStruct creates an uninitialised CellLayoutIface.
func CellLayoutIfaceStruct() *CellLayoutIface {
	err := cellLayoutIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellLayoutIfaceNewFromNative(cellLayoutIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellLayoutIface)
	return structGo
}
func finalizeCellLayoutIface(obj *CellLayoutIface) {
	cellLayoutIfaceStruct.Free(obj.Native())
}

var cellRendererAccelClassStruct *gi.Struct
var cellRendererAccelClassStruct_Once sync.Once

func cellRendererAccelClassStruct_Set() error {
	var err error
	cellRendererAccelClassStruct_Once.Do(func() {
		cellRendererAccelClassStruct, err = gi.StructNew("Gtk", "CellRendererAccelClass")
	})
	return err
}

type CellRendererAccelClass struct {
	native unsafe.Pointer
}

func CellRendererAccelClassNewFromNative(native unsafe.Pointer) *CellRendererAccelClass {
	err := cellRendererAccelClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererAccelClass{native: native}

	return instance
}

/*
CastToCellRendererAccelClass down casts any arbitrary Object to CellRendererAccelClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererAccelClass.
*/
func CastToCellRendererAccelClass(object *gobject.Object) *CellRendererAccelClass {
	return CellRendererAccelClassNewFromNative(object.Native())
}

// Equals compares this CellRendererAccelClass with another CellRendererAccelClass, and returns true if they represent the same Object.
func (recv *CellRendererAccelClass) Equals(other *CellRendererAccelClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererAccelClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CellRendererAccelClass) FieldParentClass() *CellRendererTextClass {
	argValue := gi.StructFieldGet(cellRendererAccelClassStruct, recv.Native(), "parent_class")
	value := CellRendererTextClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CellRendererAccelClass) SetFieldParentClass(value *CellRendererTextClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellRendererAccelClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'accel_edited' : for field getter : missing Type

// UNSUPPORTED : C value 'accel_edited' : for field setter : missing Type

// UNSUPPORTED : C value 'accel_cleared' : for field getter : missing Type

// UNSUPPORTED : C value 'accel_cleared' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved0' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved0' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellRendererAccelClassStruct creates an uninitialised CellRendererAccelClass.
func CellRendererAccelClassStruct() *CellRendererAccelClass {
	err := cellRendererAccelClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererAccelClassNewFromNative(cellRendererAccelClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererAccelClass)
	return structGo
}
func finalizeCellRendererAccelClass(obj *CellRendererAccelClass) {
	cellRendererAccelClassStruct.Free(obj.Native())
}

var cellRendererAccelPrivateStruct *gi.Struct
var cellRendererAccelPrivateStruct_Once sync.Once

func cellRendererAccelPrivateStruct_Set() error {
	var err error
	cellRendererAccelPrivateStruct_Once.Do(func() {
		cellRendererAccelPrivateStruct, err = gi.StructNew("Gtk", "CellRendererAccelPrivate")
	})
	return err
}

type CellRendererAccelPrivate struct {
	native unsafe.Pointer
}

func CellRendererAccelPrivateNewFromNative(native unsafe.Pointer) *CellRendererAccelPrivate {
	err := cellRendererAccelPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererAccelPrivate{native: native}

	return instance
}

/*
CastToCellRendererAccelPrivate down casts any arbitrary Object to CellRendererAccelPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererAccelPrivate.
*/
func CastToCellRendererAccelPrivate(object *gobject.Object) *CellRendererAccelPrivate {
	return CellRendererAccelPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererAccelPrivate with another CellRendererAccelPrivate, and returns true if they represent the same Object.
func (recv *CellRendererAccelPrivate) Equals(other *CellRendererAccelPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererAccelPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererAccelPrivateStruct creates an uninitialised CellRendererAccelPrivate.
func CellRendererAccelPrivateStruct() *CellRendererAccelPrivate {
	err := cellRendererAccelPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererAccelPrivateNewFromNative(cellRendererAccelPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererAccelPrivate)
	return structGo
}
func finalizeCellRendererAccelPrivate(obj *CellRendererAccelPrivate) {
	cellRendererAccelPrivateStruct.Free(obj.Native())
}

var cellRendererClassStruct *gi.Struct
var cellRendererClassStruct_Once sync.Once

func cellRendererClassStruct_Set() error {
	var err error
	cellRendererClassStruct_Once.Do(func() {
		cellRendererClassStruct, err = gi.StructNew("Gtk", "CellRendererClass")
	})
	return err
}

type CellRendererClass struct {
	native unsafe.Pointer
}

func CellRendererClassNewFromNative(native unsafe.Pointer) *CellRendererClass {
	err := cellRendererClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererClass{native: native}

	return instance
}

/*
CastToCellRendererClass down casts any arbitrary Object to CellRendererClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererClass.
*/
func CastToCellRendererClass(object *gobject.Object) *CellRendererClass {
	return CellRendererClassNewFromNative(object.Native())
}

// Equals compares this CellRendererClass with another CellRendererClass, and returns true if they represent the same Object.
func (recv *CellRendererClass) Equals(other *CellRendererClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'get_request_mode' : for field getter : missing Type

// UNSUPPORTED : C value 'get_request_mode' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_width' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_width' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_for_width' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_for_width' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_height' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_height' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_width_for_height' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_width_for_height' : for field setter : missing Type

// UNSUPPORTED : C value 'get_aligned_area' : for field getter : missing Type

// UNSUPPORTED : C value 'get_aligned_area' : for field setter : missing Type

// UNSUPPORTED : C value 'get_size' : for field getter : missing Type

// UNSUPPORTED : C value 'get_size' : for field setter : missing Type

// UNSUPPORTED : C value 'render' : for field getter : missing Type

// UNSUPPORTED : C value 'render' : for field setter : missing Type

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value 'start_editing' : for field getter : missing Type

// UNSUPPORTED : C value 'start_editing' : for field setter : missing Type

// UNSUPPORTED : C value 'editing_canceled' : for field getter : missing Type

// UNSUPPORTED : C value 'editing_canceled' : for field setter : missing Type

// UNSUPPORTED : C value 'editing_started' : for field getter : missing Type

// UNSUPPORTED : C value 'editing_started' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

var cellRendererClassSetAccessibleTypeFunction *gi.Function
var cellRendererClassSetAccessibleTypeFunction_Once sync.Once

func cellRendererClassSetAccessibleTypeFunction_Set() error {
	var err error
	cellRendererClassSetAccessibleTypeFunction_Once.Do(func() {
		err = cellRendererClassStruct_Set()
		if err != nil {
			return
		}
		cellRendererClassSetAccessibleTypeFunction, err = cellRendererClassStruct.InvokerNew("set_accessible_type")
	})
	return err
}

// SetAccessibleType is a representation of the C type gtk_cell_renderer_class_set_accessible_type.
func (recv *CellRendererClass) SetAccessibleType(type_ int64) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt64(type_)

	err := cellRendererClassSetAccessibleTypeFunction_Set()
	if err == nil {
		cellRendererClassSetAccessibleTypeFunction.Invoke(inArgs[:], nil)
	}

	return
}

// CellRendererClassStruct creates an uninitialised CellRendererClass.
func CellRendererClassStruct() *CellRendererClass {
	err := cellRendererClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererClassNewFromNative(cellRendererClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererClass)
	return structGo
}
func finalizeCellRendererClass(obj *CellRendererClass) {
	cellRendererClassStruct.Free(obj.Native())
}

var cellRendererClassPrivateStruct *gi.Struct
var cellRendererClassPrivateStruct_Once sync.Once

func cellRendererClassPrivateStruct_Set() error {
	var err error
	cellRendererClassPrivateStruct_Once.Do(func() {
		cellRendererClassPrivateStruct, err = gi.StructNew("Gtk", "CellRendererClassPrivate")
	})
	return err
}

type CellRendererClassPrivate struct {
	native unsafe.Pointer
}

func CellRendererClassPrivateNewFromNative(native unsafe.Pointer) *CellRendererClassPrivate {
	err := cellRendererClassPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererClassPrivate{native: native}

	return instance
}

/*
CastToCellRendererClassPrivate down casts any arbitrary Object to CellRendererClassPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererClassPrivate.
*/
func CastToCellRendererClassPrivate(object *gobject.Object) *CellRendererClassPrivate {
	return CellRendererClassPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererClassPrivate with another CellRendererClassPrivate, and returns true if they represent the same Object.
func (recv *CellRendererClassPrivate) Equals(other *CellRendererClassPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererClassPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererClassPrivateStruct creates an uninitialised CellRendererClassPrivate.
func CellRendererClassPrivateStruct() *CellRendererClassPrivate {
	err := cellRendererClassPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererClassPrivateNewFromNative(cellRendererClassPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererClassPrivate)
	return structGo
}
func finalizeCellRendererClassPrivate(obj *CellRendererClassPrivate) {
	cellRendererClassPrivateStruct.Free(obj.Native())
}

var cellRendererComboClassStruct *gi.Struct
var cellRendererComboClassStruct_Once sync.Once

func cellRendererComboClassStruct_Set() error {
	var err error
	cellRendererComboClassStruct_Once.Do(func() {
		cellRendererComboClassStruct, err = gi.StructNew("Gtk", "CellRendererComboClass")
	})
	return err
}

type CellRendererComboClass struct {
	native unsafe.Pointer
}

func CellRendererComboClassNewFromNative(native unsafe.Pointer) *CellRendererComboClass {
	err := cellRendererComboClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererComboClass{native: native}

	return instance
}

/*
CastToCellRendererComboClass down casts any arbitrary Object to CellRendererComboClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererComboClass.
*/
func CastToCellRendererComboClass(object *gobject.Object) *CellRendererComboClass {
	return CellRendererComboClassNewFromNative(object.Native())
}

// Equals compares this CellRendererComboClass with another CellRendererComboClass, and returns true if they represent the same Object.
func (recv *CellRendererComboClass) Equals(other *CellRendererComboClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererComboClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParent returns the C field 'parent'.
func (recv *CellRendererComboClass) FieldParent() *CellRendererTextClass {
	argValue := gi.StructFieldGet(cellRendererComboClassStruct, recv.Native(), "parent")
	value := CellRendererTextClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParent sets the value of the C field 'parent'.
func (recv *CellRendererComboClass) SetFieldParent(value *CellRendererTextClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellRendererComboClassStruct, recv.Native(), "parent", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellRendererComboClassStruct creates an uninitialised CellRendererComboClass.
func CellRendererComboClassStruct() *CellRendererComboClass {
	err := cellRendererComboClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererComboClassNewFromNative(cellRendererComboClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererComboClass)
	return structGo
}
func finalizeCellRendererComboClass(obj *CellRendererComboClass) {
	cellRendererComboClassStruct.Free(obj.Native())
}

var cellRendererComboPrivateStruct *gi.Struct
var cellRendererComboPrivateStruct_Once sync.Once

func cellRendererComboPrivateStruct_Set() error {
	var err error
	cellRendererComboPrivateStruct_Once.Do(func() {
		cellRendererComboPrivateStruct, err = gi.StructNew("Gtk", "CellRendererComboPrivate")
	})
	return err
}

type CellRendererComboPrivate struct {
	native unsafe.Pointer
}

func CellRendererComboPrivateNewFromNative(native unsafe.Pointer) *CellRendererComboPrivate {
	err := cellRendererComboPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererComboPrivate{native: native}

	return instance
}

/*
CastToCellRendererComboPrivate down casts any arbitrary Object to CellRendererComboPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererComboPrivate.
*/
func CastToCellRendererComboPrivate(object *gobject.Object) *CellRendererComboPrivate {
	return CellRendererComboPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererComboPrivate with another CellRendererComboPrivate, and returns true if they represent the same Object.
func (recv *CellRendererComboPrivate) Equals(other *CellRendererComboPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererComboPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererComboPrivateStruct creates an uninitialised CellRendererComboPrivate.
func CellRendererComboPrivateStruct() *CellRendererComboPrivate {
	err := cellRendererComboPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererComboPrivateNewFromNative(cellRendererComboPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererComboPrivate)
	return structGo
}
func finalizeCellRendererComboPrivate(obj *CellRendererComboPrivate) {
	cellRendererComboPrivateStruct.Free(obj.Native())
}

var cellRendererPixbufClassStruct *gi.Struct
var cellRendererPixbufClassStruct_Once sync.Once

func cellRendererPixbufClassStruct_Set() error {
	var err error
	cellRendererPixbufClassStruct_Once.Do(func() {
		cellRendererPixbufClassStruct, err = gi.StructNew("Gtk", "CellRendererPixbufClass")
	})
	return err
}

type CellRendererPixbufClass struct {
	native unsafe.Pointer
}

func CellRendererPixbufClassNewFromNative(native unsafe.Pointer) *CellRendererPixbufClass {
	err := cellRendererPixbufClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererPixbufClass{native: native}

	return instance
}

/*
CastToCellRendererPixbufClass down casts any arbitrary Object to CellRendererPixbufClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererPixbufClass.
*/
func CastToCellRendererPixbufClass(object *gobject.Object) *CellRendererPixbufClass {
	return CellRendererPixbufClassNewFromNative(object.Native())
}

// Equals compares this CellRendererPixbufClass with another CellRendererPixbufClass, and returns true if they represent the same Object.
func (recv *CellRendererPixbufClass) Equals(other *CellRendererPixbufClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererPixbufClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CellRendererPixbufClass) FieldParentClass() *CellRendererClass {
	argValue := gi.StructFieldGet(cellRendererPixbufClassStruct, recv.Native(), "parent_class")
	value := CellRendererClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CellRendererPixbufClass) SetFieldParentClass(value *CellRendererClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellRendererPixbufClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellRendererPixbufClassStruct creates an uninitialised CellRendererPixbufClass.
func CellRendererPixbufClassStruct() *CellRendererPixbufClass {
	err := cellRendererPixbufClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererPixbufClassNewFromNative(cellRendererPixbufClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererPixbufClass)
	return structGo
}
func finalizeCellRendererPixbufClass(obj *CellRendererPixbufClass) {
	cellRendererPixbufClassStruct.Free(obj.Native())
}

var cellRendererPixbufPrivateStruct *gi.Struct
var cellRendererPixbufPrivateStruct_Once sync.Once

func cellRendererPixbufPrivateStruct_Set() error {
	var err error
	cellRendererPixbufPrivateStruct_Once.Do(func() {
		cellRendererPixbufPrivateStruct, err = gi.StructNew("Gtk", "CellRendererPixbufPrivate")
	})
	return err
}

type CellRendererPixbufPrivate struct {
	native unsafe.Pointer
}

func CellRendererPixbufPrivateNewFromNative(native unsafe.Pointer) *CellRendererPixbufPrivate {
	err := cellRendererPixbufPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererPixbufPrivate{native: native}

	return instance
}

/*
CastToCellRendererPixbufPrivate down casts any arbitrary Object to CellRendererPixbufPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererPixbufPrivate.
*/
func CastToCellRendererPixbufPrivate(object *gobject.Object) *CellRendererPixbufPrivate {
	return CellRendererPixbufPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererPixbufPrivate with another CellRendererPixbufPrivate, and returns true if they represent the same Object.
func (recv *CellRendererPixbufPrivate) Equals(other *CellRendererPixbufPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererPixbufPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererPixbufPrivateStruct creates an uninitialised CellRendererPixbufPrivate.
func CellRendererPixbufPrivateStruct() *CellRendererPixbufPrivate {
	err := cellRendererPixbufPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererPixbufPrivateNewFromNative(cellRendererPixbufPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererPixbufPrivate)
	return structGo
}
func finalizeCellRendererPixbufPrivate(obj *CellRendererPixbufPrivate) {
	cellRendererPixbufPrivateStruct.Free(obj.Native())
}

var cellRendererPrivateStruct *gi.Struct
var cellRendererPrivateStruct_Once sync.Once

func cellRendererPrivateStruct_Set() error {
	var err error
	cellRendererPrivateStruct_Once.Do(func() {
		cellRendererPrivateStruct, err = gi.StructNew("Gtk", "CellRendererPrivate")
	})
	return err
}

type CellRendererPrivate struct {
	native unsafe.Pointer
}

func CellRendererPrivateNewFromNative(native unsafe.Pointer) *CellRendererPrivate {
	err := cellRendererPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererPrivate{native: native}

	return instance
}

/*
CastToCellRendererPrivate down casts any arbitrary Object to CellRendererPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererPrivate.
*/
func CastToCellRendererPrivate(object *gobject.Object) *CellRendererPrivate {
	return CellRendererPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererPrivate with another CellRendererPrivate, and returns true if they represent the same Object.
func (recv *CellRendererPrivate) Equals(other *CellRendererPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererPrivateStruct creates an uninitialised CellRendererPrivate.
func CellRendererPrivateStruct() *CellRendererPrivate {
	err := cellRendererPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererPrivateNewFromNative(cellRendererPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererPrivate)
	return structGo
}
func finalizeCellRendererPrivate(obj *CellRendererPrivate) {
	cellRendererPrivateStruct.Free(obj.Native())
}

var cellRendererProgressClassStruct *gi.Struct
var cellRendererProgressClassStruct_Once sync.Once

func cellRendererProgressClassStruct_Set() error {
	var err error
	cellRendererProgressClassStruct_Once.Do(func() {
		cellRendererProgressClassStruct, err = gi.StructNew("Gtk", "CellRendererProgressClass")
	})
	return err
}

type CellRendererProgressClass struct {
	native unsafe.Pointer
}

func CellRendererProgressClassNewFromNative(native unsafe.Pointer) *CellRendererProgressClass {
	err := cellRendererProgressClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererProgressClass{native: native}

	return instance
}

/*
CastToCellRendererProgressClass down casts any arbitrary Object to CellRendererProgressClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererProgressClass.
*/
func CastToCellRendererProgressClass(object *gobject.Object) *CellRendererProgressClass {
	return CellRendererProgressClassNewFromNative(object.Native())
}

// Equals compares this CellRendererProgressClass with another CellRendererProgressClass, and returns true if they represent the same Object.
func (recv *CellRendererProgressClass) Equals(other *CellRendererProgressClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererProgressClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CellRendererProgressClass) FieldParentClass() *CellRendererClass {
	argValue := gi.StructFieldGet(cellRendererProgressClassStruct, recv.Native(), "parent_class")
	value := CellRendererClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CellRendererProgressClass) SetFieldParentClass(value *CellRendererClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellRendererProgressClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellRendererProgressClassStruct creates an uninitialised CellRendererProgressClass.
func CellRendererProgressClassStruct() *CellRendererProgressClass {
	err := cellRendererProgressClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererProgressClassNewFromNative(cellRendererProgressClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererProgressClass)
	return structGo
}
func finalizeCellRendererProgressClass(obj *CellRendererProgressClass) {
	cellRendererProgressClassStruct.Free(obj.Native())
}

var cellRendererProgressPrivateStruct *gi.Struct
var cellRendererProgressPrivateStruct_Once sync.Once

func cellRendererProgressPrivateStruct_Set() error {
	var err error
	cellRendererProgressPrivateStruct_Once.Do(func() {
		cellRendererProgressPrivateStruct, err = gi.StructNew("Gtk", "CellRendererProgressPrivate")
	})
	return err
}

type CellRendererProgressPrivate struct {
	native unsafe.Pointer
}

func CellRendererProgressPrivateNewFromNative(native unsafe.Pointer) *CellRendererProgressPrivate {
	err := cellRendererProgressPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererProgressPrivate{native: native}

	return instance
}

/*
CastToCellRendererProgressPrivate down casts any arbitrary Object to CellRendererProgressPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererProgressPrivate.
*/
func CastToCellRendererProgressPrivate(object *gobject.Object) *CellRendererProgressPrivate {
	return CellRendererProgressPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererProgressPrivate with another CellRendererProgressPrivate, and returns true if they represent the same Object.
func (recv *CellRendererProgressPrivate) Equals(other *CellRendererProgressPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererProgressPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererProgressPrivateStruct creates an uninitialised CellRendererProgressPrivate.
func CellRendererProgressPrivateStruct() *CellRendererProgressPrivate {
	err := cellRendererProgressPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererProgressPrivateNewFromNative(cellRendererProgressPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererProgressPrivate)
	return structGo
}
func finalizeCellRendererProgressPrivate(obj *CellRendererProgressPrivate) {
	cellRendererProgressPrivateStruct.Free(obj.Native())
}

var cellRendererSpinClassStruct *gi.Struct
var cellRendererSpinClassStruct_Once sync.Once

func cellRendererSpinClassStruct_Set() error {
	var err error
	cellRendererSpinClassStruct_Once.Do(func() {
		cellRendererSpinClassStruct, err = gi.StructNew("Gtk", "CellRendererSpinClass")
	})
	return err
}

type CellRendererSpinClass struct {
	native unsafe.Pointer
}

func CellRendererSpinClassNewFromNative(native unsafe.Pointer) *CellRendererSpinClass {
	err := cellRendererSpinClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererSpinClass{native: native}

	return instance
}

/*
CastToCellRendererSpinClass down casts any arbitrary Object to CellRendererSpinClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererSpinClass.
*/
func CastToCellRendererSpinClass(object *gobject.Object) *CellRendererSpinClass {
	return CellRendererSpinClassNewFromNative(object.Native())
}

// Equals compares this CellRendererSpinClass with another CellRendererSpinClass, and returns true if they represent the same Object.
func (recv *CellRendererSpinClass) Equals(other *CellRendererSpinClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererSpinClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParent returns the C field 'parent'.
func (recv *CellRendererSpinClass) FieldParent() *CellRendererTextClass {
	argValue := gi.StructFieldGet(cellRendererSpinClassStruct, recv.Native(), "parent")
	value := CellRendererTextClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParent sets the value of the C field 'parent'.
func (recv *CellRendererSpinClass) SetFieldParent(value *CellRendererTextClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellRendererSpinClassStruct, recv.Native(), "parent", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellRendererSpinClassStruct creates an uninitialised CellRendererSpinClass.
func CellRendererSpinClassStruct() *CellRendererSpinClass {
	err := cellRendererSpinClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererSpinClassNewFromNative(cellRendererSpinClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererSpinClass)
	return structGo
}
func finalizeCellRendererSpinClass(obj *CellRendererSpinClass) {
	cellRendererSpinClassStruct.Free(obj.Native())
}

var cellRendererSpinPrivateStruct *gi.Struct
var cellRendererSpinPrivateStruct_Once sync.Once

func cellRendererSpinPrivateStruct_Set() error {
	var err error
	cellRendererSpinPrivateStruct_Once.Do(func() {
		cellRendererSpinPrivateStruct, err = gi.StructNew("Gtk", "CellRendererSpinPrivate")
	})
	return err
}

type CellRendererSpinPrivate struct {
	native unsafe.Pointer
}

func CellRendererSpinPrivateNewFromNative(native unsafe.Pointer) *CellRendererSpinPrivate {
	err := cellRendererSpinPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererSpinPrivate{native: native}

	return instance
}

/*
CastToCellRendererSpinPrivate down casts any arbitrary Object to CellRendererSpinPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererSpinPrivate.
*/
func CastToCellRendererSpinPrivate(object *gobject.Object) *CellRendererSpinPrivate {
	return CellRendererSpinPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererSpinPrivate with another CellRendererSpinPrivate, and returns true if they represent the same Object.
func (recv *CellRendererSpinPrivate) Equals(other *CellRendererSpinPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererSpinPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererSpinPrivateStruct creates an uninitialised CellRendererSpinPrivate.
func CellRendererSpinPrivateStruct() *CellRendererSpinPrivate {
	err := cellRendererSpinPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererSpinPrivateNewFromNative(cellRendererSpinPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererSpinPrivate)
	return structGo
}
func finalizeCellRendererSpinPrivate(obj *CellRendererSpinPrivate) {
	cellRendererSpinPrivateStruct.Free(obj.Native())
}

var cellRendererSpinnerClassStruct *gi.Struct
var cellRendererSpinnerClassStruct_Once sync.Once

func cellRendererSpinnerClassStruct_Set() error {
	var err error
	cellRendererSpinnerClassStruct_Once.Do(func() {
		cellRendererSpinnerClassStruct, err = gi.StructNew("Gtk", "CellRendererSpinnerClass")
	})
	return err
}

type CellRendererSpinnerClass struct {
	native unsafe.Pointer
}

func CellRendererSpinnerClassNewFromNative(native unsafe.Pointer) *CellRendererSpinnerClass {
	err := cellRendererSpinnerClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererSpinnerClass{native: native}

	return instance
}

/*
CastToCellRendererSpinnerClass down casts any arbitrary Object to CellRendererSpinnerClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererSpinnerClass.
*/
func CastToCellRendererSpinnerClass(object *gobject.Object) *CellRendererSpinnerClass {
	return CellRendererSpinnerClassNewFromNative(object.Native())
}

// Equals compares this CellRendererSpinnerClass with another CellRendererSpinnerClass, and returns true if they represent the same Object.
func (recv *CellRendererSpinnerClass) Equals(other *CellRendererSpinnerClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererSpinnerClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CellRendererSpinnerClass) FieldParentClass() *CellRendererClass {
	argValue := gi.StructFieldGet(cellRendererSpinnerClassStruct, recv.Native(), "parent_class")
	value := CellRendererClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CellRendererSpinnerClass) SetFieldParentClass(value *CellRendererClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellRendererSpinnerClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellRendererSpinnerClassStruct creates an uninitialised CellRendererSpinnerClass.
func CellRendererSpinnerClassStruct() *CellRendererSpinnerClass {
	err := cellRendererSpinnerClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererSpinnerClassNewFromNative(cellRendererSpinnerClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererSpinnerClass)
	return structGo
}
func finalizeCellRendererSpinnerClass(obj *CellRendererSpinnerClass) {
	cellRendererSpinnerClassStruct.Free(obj.Native())
}

var cellRendererSpinnerPrivateStruct *gi.Struct
var cellRendererSpinnerPrivateStruct_Once sync.Once

func cellRendererSpinnerPrivateStruct_Set() error {
	var err error
	cellRendererSpinnerPrivateStruct_Once.Do(func() {
		cellRendererSpinnerPrivateStruct, err = gi.StructNew("Gtk", "CellRendererSpinnerPrivate")
	})
	return err
}

type CellRendererSpinnerPrivate struct {
	native unsafe.Pointer
}

func CellRendererSpinnerPrivateNewFromNative(native unsafe.Pointer) *CellRendererSpinnerPrivate {
	err := cellRendererSpinnerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererSpinnerPrivate{native: native}

	return instance
}

/*
CastToCellRendererSpinnerPrivate down casts any arbitrary Object to CellRendererSpinnerPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererSpinnerPrivate.
*/
func CastToCellRendererSpinnerPrivate(object *gobject.Object) *CellRendererSpinnerPrivate {
	return CellRendererSpinnerPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererSpinnerPrivate with another CellRendererSpinnerPrivate, and returns true if they represent the same Object.
func (recv *CellRendererSpinnerPrivate) Equals(other *CellRendererSpinnerPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererSpinnerPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererSpinnerPrivateStruct creates an uninitialised CellRendererSpinnerPrivate.
func CellRendererSpinnerPrivateStruct() *CellRendererSpinnerPrivate {
	err := cellRendererSpinnerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererSpinnerPrivateNewFromNative(cellRendererSpinnerPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererSpinnerPrivate)
	return structGo
}
func finalizeCellRendererSpinnerPrivate(obj *CellRendererSpinnerPrivate) {
	cellRendererSpinnerPrivateStruct.Free(obj.Native())
}

var cellRendererTextClassStruct *gi.Struct
var cellRendererTextClassStruct_Once sync.Once

func cellRendererTextClassStruct_Set() error {
	var err error
	cellRendererTextClassStruct_Once.Do(func() {
		cellRendererTextClassStruct, err = gi.StructNew("Gtk", "CellRendererTextClass")
	})
	return err
}

type CellRendererTextClass struct {
	native unsafe.Pointer
}

func CellRendererTextClassNewFromNative(native unsafe.Pointer) *CellRendererTextClass {
	err := cellRendererTextClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererTextClass{native: native}

	return instance
}

/*
CastToCellRendererTextClass down casts any arbitrary Object to CellRendererTextClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererTextClass.
*/
func CastToCellRendererTextClass(object *gobject.Object) *CellRendererTextClass {
	return CellRendererTextClassNewFromNative(object.Native())
}

// Equals compares this CellRendererTextClass with another CellRendererTextClass, and returns true if they represent the same Object.
func (recv *CellRendererTextClass) Equals(other *CellRendererTextClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererTextClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CellRendererTextClass) FieldParentClass() *CellRendererClass {
	argValue := gi.StructFieldGet(cellRendererTextClassStruct, recv.Native(), "parent_class")
	value := CellRendererClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CellRendererTextClass) SetFieldParentClass(value *CellRendererClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellRendererTextClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'edited' : for field getter : missing Type

// UNSUPPORTED : C value 'edited' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellRendererTextClassStruct creates an uninitialised CellRendererTextClass.
func CellRendererTextClassStruct() *CellRendererTextClass {
	err := cellRendererTextClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererTextClassNewFromNative(cellRendererTextClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererTextClass)
	return structGo
}
func finalizeCellRendererTextClass(obj *CellRendererTextClass) {
	cellRendererTextClassStruct.Free(obj.Native())
}

var cellRendererTextPrivateStruct *gi.Struct
var cellRendererTextPrivateStruct_Once sync.Once

func cellRendererTextPrivateStruct_Set() error {
	var err error
	cellRendererTextPrivateStruct_Once.Do(func() {
		cellRendererTextPrivateStruct, err = gi.StructNew("Gtk", "CellRendererTextPrivate")
	})
	return err
}

type CellRendererTextPrivate struct {
	native unsafe.Pointer
}

func CellRendererTextPrivateNewFromNative(native unsafe.Pointer) *CellRendererTextPrivate {
	err := cellRendererTextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererTextPrivate{native: native}

	return instance
}

/*
CastToCellRendererTextPrivate down casts any arbitrary Object to CellRendererTextPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererTextPrivate.
*/
func CastToCellRendererTextPrivate(object *gobject.Object) *CellRendererTextPrivate {
	return CellRendererTextPrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererTextPrivate with another CellRendererTextPrivate, and returns true if they represent the same Object.
func (recv *CellRendererTextPrivate) Equals(other *CellRendererTextPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererTextPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererTextPrivateStruct creates an uninitialised CellRendererTextPrivate.
func CellRendererTextPrivateStruct() *CellRendererTextPrivate {
	err := cellRendererTextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererTextPrivateNewFromNative(cellRendererTextPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererTextPrivate)
	return structGo
}
func finalizeCellRendererTextPrivate(obj *CellRendererTextPrivate) {
	cellRendererTextPrivateStruct.Free(obj.Native())
}

var cellRendererToggleClassStruct *gi.Struct
var cellRendererToggleClassStruct_Once sync.Once

func cellRendererToggleClassStruct_Set() error {
	var err error
	cellRendererToggleClassStruct_Once.Do(func() {
		cellRendererToggleClassStruct, err = gi.StructNew("Gtk", "CellRendererToggleClass")
	})
	return err
}

type CellRendererToggleClass struct {
	native unsafe.Pointer
}

func CellRendererToggleClassNewFromNative(native unsafe.Pointer) *CellRendererToggleClass {
	err := cellRendererToggleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererToggleClass{native: native}

	return instance
}

/*
CastToCellRendererToggleClass down casts any arbitrary Object to CellRendererToggleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererToggleClass.
*/
func CastToCellRendererToggleClass(object *gobject.Object) *CellRendererToggleClass {
	return CellRendererToggleClassNewFromNative(object.Native())
}

// Equals compares this CellRendererToggleClass with another CellRendererToggleClass, and returns true if they represent the same Object.
func (recv *CellRendererToggleClass) Equals(other *CellRendererToggleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererToggleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CellRendererToggleClass) FieldParentClass() *CellRendererClass {
	argValue := gi.StructFieldGet(cellRendererToggleClassStruct, recv.Native(), "parent_class")
	value := CellRendererClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CellRendererToggleClass) SetFieldParentClass(value *CellRendererClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellRendererToggleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'toggled' : for field getter : missing Type

// UNSUPPORTED : C value 'toggled' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellRendererToggleClassStruct creates an uninitialised CellRendererToggleClass.
func CellRendererToggleClassStruct() *CellRendererToggleClass {
	err := cellRendererToggleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererToggleClassNewFromNative(cellRendererToggleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererToggleClass)
	return structGo
}
func finalizeCellRendererToggleClass(obj *CellRendererToggleClass) {
	cellRendererToggleClassStruct.Free(obj.Native())
}

var cellRendererTogglePrivateStruct *gi.Struct
var cellRendererTogglePrivateStruct_Once sync.Once

func cellRendererTogglePrivateStruct_Set() error {
	var err error
	cellRendererTogglePrivateStruct_Once.Do(func() {
		cellRendererTogglePrivateStruct, err = gi.StructNew("Gtk", "CellRendererTogglePrivate")
	})
	return err
}

type CellRendererTogglePrivate struct {
	native unsafe.Pointer
}

func CellRendererTogglePrivateNewFromNative(native unsafe.Pointer) *CellRendererTogglePrivate {
	err := cellRendererTogglePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellRendererTogglePrivate{native: native}

	return instance
}

/*
CastToCellRendererTogglePrivate down casts any arbitrary Object to CellRendererTogglePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellRendererTogglePrivate.
*/
func CastToCellRendererTogglePrivate(object *gobject.Object) *CellRendererTogglePrivate {
	return CellRendererTogglePrivateNewFromNative(object.Native())
}

// Equals compares this CellRendererTogglePrivate with another CellRendererTogglePrivate, and returns true if they represent the same Object.
func (recv *CellRendererTogglePrivate) Equals(other *CellRendererTogglePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellRendererTogglePrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellRendererTogglePrivateStruct creates an uninitialised CellRendererTogglePrivate.
func CellRendererTogglePrivateStruct() *CellRendererTogglePrivate {
	err := cellRendererTogglePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellRendererTogglePrivateNewFromNative(cellRendererTogglePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellRendererTogglePrivate)
	return structGo
}
func finalizeCellRendererTogglePrivate(obj *CellRendererTogglePrivate) {
	cellRendererTogglePrivateStruct.Free(obj.Native())
}

var cellViewClassStruct *gi.Struct
var cellViewClassStruct_Once sync.Once

func cellViewClassStruct_Set() error {
	var err error
	cellViewClassStruct_Once.Do(func() {
		cellViewClassStruct, err = gi.StructNew("Gtk", "CellViewClass")
	})
	return err
}

type CellViewClass struct {
	native unsafe.Pointer
}

func CellViewClassNewFromNative(native unsafe.Pointer) *CellViewClass {
	err := cellViewClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellViewClass{native: native}

	return instance
}

/*
CastToCellViewClass down casts any arbitrary Object to CellViewClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellViewClass.
*/
func CastToCellViewClass(object *gobject.Object) *CellViewClass {
	return CellViewClassNewFromNative(object.Native())
}

// Equals compares this CellViewClass with another CellViewClass, and returns true if they represent the same Object.
func (recv *CellViewClass) Equals(other *CellViewClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CellViewClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CellViewClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(cellViewClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CellViewClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cellViewClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CellViewClassStruct creates an uninitialised CellViewClass.
func CellViewClassStruct() *CellViewClass {
	err := cellViewClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellViewClassNewFromNative(cellViewClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellViewClass)
	return structGo
}
func finalizeCellViewClass(obj *CellViewClass) {
	cellViewClassStruct.Free(obj.Native())
}

var cellViewPrivateStruct *gi.Struct
var cellViewPrivateStruct_Once sync.Once

func cellViewPrivateStruct_Set() error {
	var err error
	cellViewPrivateStruct_Once.Do(func() {
		cellViewPrivateStruct, err = gi.StructNew("Gtk", "CellViewPrivate")
	})
	return err
}

type CellViewPrivate struct {
	native unsafe.Pointer
}

func CellViewPrivateNewFromNative(native unsafe.Pointer) *CellViewPrivate {
	err := cellViewPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CellViewPrivate{native: native}

	return instance
}

/*
CastToCellViewPrivate down casts any arbitrary Object to CellViewPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CellViewPrivate.
*/
func CastToCellViewPrivate(object *gobject.Object) *CellViewPrivate {
	return CellViewPrivateNewFromNative(object.Native())
}

// Equals compares this CellViewPrivate with another CellViewPrivate, and returns true if they represent the same Object.
func (recv *CellViewPrivate) Equals(other *CellViewPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CellViewPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CellViewPrivateStruct creates an uninitialised CellViewPrivate.
func CellViewPrivateStruct() *CellViewPrivate {
	err := cellViewPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CellViewPrivateNewFromNative(cellViewPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCellViewPrivate)
	return structGo
}
func finalizeCellViewPrivate(obj *CellViewPrivate) {
	cellViewPrivateStruct.Free(obj.Native())
}

var checkButtonClassStruct *gi.Struct
var checkButtonClassStruct_Once sync.Once

func checkButtonClassStruct_Set() error {
	var err error
	checkButtonClassStruct_Once.Do(func() {
		checkButtonClassStruct, err = gi.StructNew("Gtk", "CheckButtonClass")
	})
	return err
}

type CheckButtonClass struct {
	native unsafe.Pointer
}

func CheckButtonClassNewFromNative(native unsafe.Pointer) *CheckButtonClass {
	err := checkButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CheckButtonClass{native: native}

	return instance
}

/*
CastToCheckButtonClass down casts any arbitrary Object to CheckButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CheckButtonClass.
*/
func CastToCheckButtonClass(object *gobject.Object) *CheckButtonClass {
	return CheckButtonClassNewFromNative(object.Native())
}

// Equals compares this CheckButtonClass with another CheckButtonClass, and returns true if they represent the same Object.
func (recv *CheckButtonClass) Equals(other *CheckButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CheckButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CheckButtonClass) FieldParentClass() *ToggleButtonClass {
	argValue := gi.StructFieldGet(checkButtonClassStruct, recv.Native(), "parent_class")
	value := ToggleButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CheckButtonClass) SetFieldParentClass(value *ToggleButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(checkButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'draw_indicator' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_indicator' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CheckButtonClassStruct creates an uninitialised CheckButtonClass.
func CheckButtonClassStruct() *CheckButtonClass {
	err := checkButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CheckButtonClassNewFromNative(checkButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCheckButtonClass)
	return structGo
}
func finalizeCheckButtonClass(obj *CheckButtonClass) {
	checkButtonClassStruct.Free(obj.Native())
}

var checkMenuItemAccessibleClassStruct *gi.Struct
var checkMenuItemAccessibleClassStruct_Once sync.Once

func checkMenuItemAccessibleClassStruct_Set() error {
	var err error
	checkMenuItemAccessibleClassStruct_Once.Do(func() {
		checkMenuItemAccessibleClassStruct, err = gi.StructNew("Gtk", "CheckMenuItemAccessibleClass")
	})
	return err
}

type CheckMenuItemAccessibleClass struct {
	native unsafe.Pointer
}

func CheckMenuItemAccessibleClassNewFromNative(native unsafe.Pointer) *CheckMenuItemAccessibleClass {
	err := checkMenuItemAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CheckMenuItemAccessibleClass{native: native}

	return instance
}

/*
CastToCheckMenuItemAccessibleClass down casts any arbitrary Object to CheckMenuItemAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CheckMenuItemAccessibleClass.
*/
func CastToCheckMenuItemAccessibleClass(object *gobject.Object) *CheckMenuItemAccessibleClass {
	return CheckMenuItemAccessibleClassNewFromNative(object.Native())
}

// Equals compares this CheckMenuItemAccessibleClass with another CheckMenuItemAccessibleClass, and returns true if they represent the same Object.
func (recv *CheckMenuItemAccessibleClass) Equals(other *CheckMenuItemAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CheckMenuItemAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CheckMenuItemAccessibleClass) FieldParentClass() *MenuItemAccessibleClass {
	argValue := gi.StructFieldGet(checkMenuItemAccessibleClassStruct, recv.Native(), "parent_class")
	value := MenuItemAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CheckMenuItemAccessibleClass) SetFieldParentClass(value *MenuItemAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(checkMenuItemAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// CheckMenuItemAccessibleClassStruct creates an uninitialised CheckMenuItemAccessibleClass.
func CheckMenuItemAccessibleClassStruct() *CheckMenuItemAccessibleClass {
	err := checkMenuItemAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CheckMenuItemAccessibleClassNewFromNative(checkMenuItemAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCheckMenuItemAccessibleClass)
	return structGo
}
func finalizeCheckMenuItemAccessibleClass(obj *CheckMenuItemAccessibleClass) {
	checkMenuItemAccessibleClassStruct.Free(obj.Native())
}

var checkMenuItemAccessiblePrivateStruct *gi.Struct
var checkMenuItemAccessiblePrivateStruct_Once sync.Once

func checkMenuItemAccessiblePrivateStruct_Set() error {
	var err error
	checkMenuItemAccessiblePrivateStruct_Once.Do(func() {
		checkMenuItemAccessiblePrivateStruct, err = gi.StructNew("Gtk", "CheckMenuItemAccessiblePrivate")
	})
	return err
}

type CheckMenuItemAccessiblePrivate struct {
	native unsafe.Pointer
}

func CheckMenuItemAccessiblePrivateNewFromNative(native unsafe.Pointer) *CheckMenuItemAccessiblePrivate {
	err := checkMenuItemAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CheckMenuItemAccessiblePrivate{native: native}

	return instance
}

/*
CastToCheckMenuItemAccessiblePrivate down casts any arbitrary Object to CheckMenuItemAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CheckMenuItemAccessiblePrivate.
*/
func CastToCheckMenuItemAccessiblePrivate(object *gobject.Object) *CheckMenuItemAccessiblePrivate {
	return CheckMenuItemAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this CheckMenuItemAccessiblePrivate with another CheckMenuItemAccessiblePrivate, and returns true if they represent the same Object.
func (recv *CheckMenuItemAccessiblePrivate) Equals(other *CheckMenuItemAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CheckMenuItemAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// CheckMenuItemAccessiblePrivateStruct creates an uninitialised CheckMenuItemAccessiblePrivate.
func CheckMenuItemAccessiblePrivateStruct() *CheckMenuItemAccessiblePrivate {
	err := checkMenuItemAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CheckMenuItemAccessiblePrivateNewFromNative(checkMenuItemAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCheckMenuItemAccessiblePrivate)
	return structGo
}
func finalizeCheckMenuItemAccessiblePrivate(obj *CheckMenuItemAccessiblePrivate) {
	checkMenuItemAccessiblePrivateStruct.Free(obj.Native())
}

var checkMenuItemClassStruct *gi.Struct
var checkMenuItemClassStruct_Once sync.Once

func checkMenuItemClassStruct_Set() error {
	var err error
	checkMenuItemClassStruct_Once.Do(func() {
		checkMenuItemClassStruct, err = gi.StructNew("Gtk", "CheckMenuItemClass")
	})
	return err
}

type CheckMenuItemClass struct {
	native unsafe.Pointer
}

func CheckMenuItemClassNewFromNative(native unsafe.Pointer) *CheckMenuItemClass {
	err := checkMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CheckMenuItemClass{native: native}

	return instance
}

/*
CastToCheckMenuItemClass down casts any arbitrary Object to CheckMenuItemClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CheckMenuItemClass.
*/
func CastToCheckMenuItemClass(object *gobject.Object) *CheckMenuItemClass {
	return CheckMenuItemClassNewFromNative(object.Native())
}

// Equals compares this CheckMenuItemClass with another CheckMenuItemClass, and returns true if they represent the same Object.
func (recv *CheckMenuItemClass) Equals(other *CheckMenuItemClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CheckMenuItemClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CheckMenuItemClass) FieldParentClass() *MenuItemClass {
	argValue := gi.StructFieldGet(checkMenuItemClassStruct, recv.Native(), "parent_class")
	value := MenuItemClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CheckMenuItemClass) SetFieldParentClass(value *MenuItemClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(checkMenuItemClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'toggled' : for field getter : missing Type

// UNSUPPORTED : C value 'toggled' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_indicator' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_indicator' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CheckMenuItemClassStruct creates an uninitialised CheckMenuItemClass.
func CheckMenuItemClassStruct() *CheckMenuItemClass {
	err := checkMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CheckMenuItemClassNewFromNative(checkMenuItemClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCheckMenuItemClass)
	return structGo
}
func finalizeCheckMenuItemClass(obj *CheckMenuItemClass) {
	checkMenuItemClassStruct.Free(obj.Native())
}

var checkMenuItemPrivateStruct *gi.Struct
var checkMenuItemPrivateStruct_Once sync.Once

func checkMenuItemPrivateStruct_Set() error {
	var err error
	checkMenuItemPrivateStruct_Once.Do(func() {
		checkMenuItemPrivateStruct, err = gi.StructNew("Gtk", "CheckMenuItemPrivate")
	})
	return err
}

type CheckMenuItemPrivate struct {
	native unsafe.Pointer
}

func CheckMenuItemPrivateNewFromNative(native unsafe.Pointer) *CheckMenuItemPrivate {
	err := checkMenuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CheckMenuItemPrivate{native: native}

	return instance
}

/*
CastToCheckMenuItemPrivate down casts any arbitrary Object to CheckMenuItemPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CheckMenuItemPrivate.
*/
func CastToCheckMenuItemPrivate(object *gobject.Object) *CheckMenuItemPrivate {
	return CheckMenuItemPrivateNewFromNative(object.Native())
}

// Equals compares this CheckMenuItemPrivate with another CheckMenuItemPrivate, and returns true if they represent the same Object.
func (recv *CheckMenuItemPrivate) Equals(other *CheckMenuItemPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CheckMenuItemPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CheckMenuItemPrivateStruct creates an uninitialised CheckMenuItemPrivate.
func CheckMenuItemPrivateStruct() *CheckMenuItemPrivate {
	err := checkMenuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CheckMenuItemPrivateNewFromNative(checkMenuItemPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCheckMenuItemPrivate)
	return structGo
}
func finalizeCheckMenuItemPrivate(obj *CheckMenuItemPrivate) {
	checkMenuItemPrivateStruct.Free(obj.Native())
}

var colorButtonClassStruct *gi.Struct
var colorButtonClassStruct_Once sync.Once

func colorButtonClassStruct_Set() error {
	var err error
	colorButtonClassStruct_Once.Do(func() {
		colorButtonClassStruct, err = gi.StructNew("Gtk", "ColorButtonClass")
	})
	return err
}

type ColorButtonClass struct {
	native unsafe.Pointer
}

func ColorButtonClassNewFromNative(native unsafe.Pointer) *ColorButtonClass {
	err := colorButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorButtonClass{native: native}

	return instance
}

/*
CastToColorButtonClass down casts any arbitrary Object to ColorButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorButtonClass.
*/
func CastToColorButtonClass(object *gobject.Object) *ColorButtonClass {
	return ColorButtonClassNewFromNative(object.Native())
}

// Equals compares this ColorButtonClass with another ColorButtonClass, and returns true if they represent the same Object.
func (recv *ColorButtonClass) Equals(other *ColorButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ColorButtonClass) FieldParentClass() *ButtonClass {
	argValue := gi.StructFieldGet(colorButtonClassStruct, recv.Native(), "parent_class")
	value := ButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ColorButtonClass) SetFieldParentClass(value *ButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(colorButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'color_set' : for field getter : missing Type

// UNSUPPORTED : C value 'color_set' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ColorButtonClassStruct creates an uninitialised ColorButtonClass.
func ColorButtonClassStruct() *ColorButtonClass {
	err := colorButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorButtonClassNewFromNative(colorButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorButtonClass)
	return structGo
}
func finalizeColorButtonClass(obj *ColorButtonClass) {
	colorButtonClassStruct.Free(obj.Native())
}

var colorButtonPrivateStruct *gi.Struct
var colorButtonPrivateStruct_Once sync.Once

func colorButtonPrivateStruct_Set() error {
	var err error
	colorButtonPrivateStruct_Once.Do(func() {
		colorButtonPrivateStruct, err = gi.StructNew("Gtk", "ColorButtonPrivate")
	})
	return err
}

type ColorButtonPrivate struct {
	native unsafe.Pointer
}

func ColorButtonPrivateNewFromNative(native unsafe.Pointer) *ColorButtonPrivate {
	err := colorButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorButtonPrivate{native: native}

	return instance
}

/*
CastToColorButtonPrivate down casts any arbitrary Object to ColorButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorButtonPrivate.
*/
func CastToColorButtonPrivate(object *gobject.Object) *ColorButtonPrivate {
	return ColorButtonPrivateNewFromNative(object.Native())
}

// Equals compares this ColorButtonPrivate with another ColorButtonPrivate, and returns true if they represent the same Object.
func (recv *ColorButtonPrivate) Equals(other *ColorButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ColorButtonPrivateStruct creates an uninitialised ColorButtonPrivate.
func ColorButtonPrivateStruct() *ColorButtonPrivate {
	err := colorButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorButtonPrivateNewFromNative(colorButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorButtonPrivate)
	return structGo
}
func finalizeColorButtonPrivate(obj *ColorButtonPrivate) {
	colorButtonPrivateStruct.Free(obj.Native())
}

var colorChooserDialogClassStruct *gi.Struct
var colorChooserDialogClassStruct_Once sync.Once

func colorChooserDialogClassStruct_Set() error {
	var err error
	colorChooserDialogClassStruct_Once.Do(func() {
		colorChooserDialogClassStruct, err = gi.StructNew("Gtk", "ColorChooserDialogClass")
	})
	return err
}

type ColorChooserDialogClass struct {
	native unsafe.Pointer
}

func ColorChooserDialogClassNewFromNative(native unsafe.Pointer) *ColorChooserDialogClass {
	err := colorChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorChooserDialogClass{native: native}

	return instance
}

/*
CastToColorChooserDialogClass down casts any arbitrary Object to ColorChooserDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorChooserDialogClass.
*/
func CastToColorChooserDialogClass(object *gobject.Object) *ColorChooserDialogClass {
	return ColorChooserDialogClassNewFromNative(object.Native())
}

// Equals compares this ColorChooserDialogClass with another ColorChooserDialogClass, and returns true if they represent the same Object.
func (recv *ColorChooserDialogClass) Equals(other *ColorChooserDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorChooserDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ColorChooserDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(colorChooserDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ColorChooserDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(colorChooserDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ColorChooserDialogClassStruct creates an uninitialised ColorChooserDialogClass.
func ColorChooserDialogClassStruct() *ColorChooserDialogClass {
	err := colorChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorChooserDialogClassNewFromNative(colorChooserDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorChooserDialogClass)
	return structGo
}
func finalizeColorChooserDialogClass(obj *ColorChooserDialogClass) {
	colorChooserDialogClassStruct.Free(obj.Native())
}

var colorChooserDialogPrivateStruct *gi.Struct
var colorChooserDialogPrivateStruct_Once sync.Once

func colorChooserDialogPrivateStruct_Set() error {
	var err error
	colorChooserDialogPrivateStruct_Once.Do(func() {
		colorChooserDialogPrivateStruct, err = gi.StructNew("Gtk", "ColorChooserDialogPrivate")
	})
	return err
}

type ColorChooserDialogPrivate struct {
	native unsafe.Pointer
}

func ColorChooserDialogPrivateNewFromNative(native unsafe.Pointer) *ColorChooserDialogPrivate {
	err := colorChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorChooserDialogPrivate{native: native}

	return instance
}

/*
CastToColorChooserDialogPrivate down casts any arbitrary Object to ColorChooserDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorChooserDialogPrivate.
*/
func CastToColorChooserDialogPrivate(object *gobject.Object) *ColorChooserDialogPrivate {
	return ColorChooserDialogPrivateNewFromNative(object.Native())
}

// Equals compares this ColorChooserDialogPrivate with another ColorChooserDialogPrivate, and returns true if they represent the same Object.
func (recv *ColorChooserDialogPrivate) Equals(other *ColorChooserDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorChooserDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ColorChooserDialogPrivateStruct creates an uninitialised ColorChooserDialogPrivate.
func ColorChooserDialogPrivateStruct() *ColorChooserDialogPrivate {
	err := colorChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorChooserDialogPrivateNewFromNative(colorChooserDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorChooserDialogPrivate)
	return structGo
}
func finalizeColorChooserDialogPrivate(obj *ColorChooserDialogPrivate) {
	colorChooserDialogPrivateStruct.Free(obj.Native())
}

var colorChooserInterfaceStruct *gi.Struct
var colorChooserInterfaceStruct_Once sync.Once

func colorChooserInterfaceStruct_Set() error {
	var err error
	colorChooserInterfaceStruct_Once.Do(func() {
		colorChooserInterfaceStruct, err = gi.StructNew("Gtk", "ColorChooserInterface")
	})
	return err
}

type ColorChooserInterface struct {
	native unsafe.Pointer
}

func ColorChooserInterfaceNewFromNative(native unsafe.Pointer) *ColorChooserInterface {
	err := colorChooserInterfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorChooserInterface{native: native}

	return instance
}

/*
CastToColorChooserInterface down casts any arbitrary Object to ColorChooserInterface.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorChooserInterface.
*/
func CastToColorChooserInterface(object *gobject.Object) *ColorChooserInterface {
	return ColorChooserInterfaceNewFromNative(object.Native())
}

// Equals compares this ColorChooserInterface with another ColorChooserInterface, and returns true if they represent the same Object.
func (recv *ColorChooserInterface) Equals(other *ColorChooserInterface) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorChooserInterface) Native() unsafe.Pointer {
	return recv.native
}

// FieldBaseInterface returns the C field 'base_interface'.
func (recv *ColorChooserInterface) FieldBaseInterface() *gobject.TypeInterface {
	argValue := gi.StructFieldGet(colorChooserInterfaceStruct, recv.Native(), "base_interface")
	value := gobject.TypeInterfaceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldBaseInterface sets the value of the C field 'base_interface'.
func (recv *ColorChooserInterface) SetFieldBaseInterface(value *gobject.TypeInterface) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(colorChooserInterfaceStruct, recv.Native(), "base_interface", argValue)
}

// UNSUPPORTED : C value 'get_rgba' : for field getter : missing Type

// UNSUPPORTED : C value 'get_rgba' : for field setter : missing Type

// UNSUPPORTED : C value 'set_rgba' : for field getter : missing Type

// UNSUPPORTED : C value 'set_rgba' : for field setter : missing Type

// UNSUPPORTED : C value 'add_palette' : for field getter : missing Type

// UNSUPPORTED : C value 'add_palette' : for field setter : missing Type

// UNSUPPORTED : C value 'color_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'color_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'padding' : for field getter : missing Type

// UNSUPPORTED : C value 'padding' : for field setter : missing Type

// ColorChooserInterfaceStruct creates an uninitialised ColorChooserInterface.
func ColorChooserInterfaceStruct() *ColorChooserInterface {
	err := colorChooserInterfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorChooserInterfaceNewFromNative(colorChooserInterfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorChooserInterface)
	return structGo
}
func finalizeColorChooserInterface(obj *ColorChooserInterface) {
	colorChooserInterfaceStruct.Free(obj.Native())
}

var colorChooserWidgetClassStruct *gi.Struct
var colorChooserWidgetClassStruct_Once sync.Once

func colorChooserWidgetClassStruct_Set() error {
	var err error
	colorChooserWidgetClassStruct_Once.Do(func() {
		colorChooserWidgetClassStruct, err = gi.StructNew("Gtk", "ColorChooserWidgetClass")
	})
	return err
}

type ColorChooserWidgetClass struct {
	native unsafe.Pointer
}

func ColorChooserWidgetClassNewFromNative(native unsafe.Pointer) *ColorChooserWidgetClass {
	err := colorChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorChooserWidgetClass{native: native}

	return instance
}

/*
CastToColorChooserWidgetClass down casts any arbitrary Object to ColorChooserWidgetClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorChooserWidgetClass.
*/
func CastToColorChooserWidgetClass(object *gobject.Object) *ColorChooserWidgetClass {
	return ColorChooserWidgetClassNewFromNative(object.Native())
}

// Equals compares this ColorChooserWidgetClass with another ColorChooserWidgetClass, and returns true if they represent the same Object.
func (recv *ColorChooserWidgetClass) Equals(other *ColorChooserWidgetClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorChooserWidgetClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ColorChooserWidgetClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(colorChooserWidgetClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ColorChooserWidgetClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(colorChooserWidgetClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// ColorChooserWidgetClassStruct creates an uninitialised ColorChooserWidgetClass.
func ColorChooserWidgetClassStruct() *ColorChooserWidgetClass {
	err := colorChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorChooserWidgetClassNewFromNative(colorChooserWidgetClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorChooserWidgetClass)
	return structGo
}
func finalizeColorChooserWidgetClass(obj *ColorChooserWidgetClass) {
	colorChooserWidgetClassStruct.Free(obj.Native())
}

var colorChooserWidgetPrivateStruct *gi.Struct
var colorChooserWidgetPrivateStruct_Once sync.Once

func colorChooserWidgetPrivateStruct_Set() error {
	var err error
	colorChooserWidgetPrivateStruct_Once.Do(func() {
		colorChooserWidgetPrivateStruct, err = gi.StructNew("Gtk", "ColorChooserWidgetPrivate")
	})
	return err
}

type ColorChooserWidgetPrivate struct {
	native unsafe.Pointer
}

func ColorChooserWidgetPrivateNewFromNative(native unsafe.Pointer) *ColorChooserWidgetPrivate {
	err := colorChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorChooserWidgetPrivate{native: native}

	return instance
}

/*
CastToColorChooserWidgetPrivate down casts any arbitrary Object to ColorChooserWidgetPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorChooserWidgetPrivate.
*/
func CastToColorChooserWidgetPrivate(object *gobject.Object) *ColorChooserWidgetPrivate {
	return ColorChooserWidgetPrivateNewFromNative(object.Native())
}

// Equals compares this ColorChooserWidgetPrivate with another ColorChooserWidgetPrivate, and returns true if they represent the same Object.
func (recv *ColorChooserWidgetPrivate) Equals(other *ColorChooserWidgetPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorChooserWidgetPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ColorChooserWidgetPrivateStruct creates an uninitialised ColorChooserWidgetPrivate.
func ColorChooserWidgetPrivateStruct() *ColorChooserWidgetPrivate {
	err := colorChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorChooserWidgetPrivateNewFromNative(colorChooserWidgetPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorChooserWidgetPrivate)
	return structGo
}
func finalizeColorChooserWidgetPrivate(obj *ColorChooserWidgetPrivate) {
	colorChooserWidgetPrivateStruct.Free(obj.Native())
}

var colorSelectionClassStruct *gi.Struct
var colorSelectionClassStruct_Once sync.Once

func colorSelectionClassStruct_Set() error {
	var err error
	colorSelectionClassStruct_Once.Do(func() {
		colorSelectionClassStruct, err = gi.StructNew("Gtk", "ColorSelectionClass")
	})
	return err
}

type ColorSelectionClass struct {
	native unsafe.Pointer
}

func ColorSelectionClassNewFromNative(native unsafe.Pointer) *ColorSelectionClass {
	err := colorSelectionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorSelectionClass{native: native}

	return instance
}

/*
CastToColorSelectionClass down casts any arbitrary Object to ColorSelectionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorSelectionClass.
*/
func CastToColorSelectionClass(object *gobject.Object) *ColorSelectionClass {
	return ColorSelectionClassNewFromNative(object.Native())
}

// Equals compares this ColorSelectionClass with another ColorSelectionClass, and returns true if they represent the same Object.
func (recv *ColorSelectionClass) Equals(other *ColorSelectionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorSelectionClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ColorSelectionClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(colorSelectionClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ColorSelectionClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(colorSelectionClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'color_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'color_changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ColorSelectionClassStruct creates an uninitialised ColorSelectionClass.
func ColorSelectionClassStruct() *ColorSelectionClass {
	err := colorSelectionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorSelectionClassNewFromNative(colorSelectionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorSelectionClass)
	return structGo
}
func finalizeColorSelectionClass(obj *ColorSelectionClass) {
	colorSelectionClassStruct.Free(obj.Native())
}

var colorSelectionDialogClassStruct *gi.Struct
var colorSelectionDialogClassStruct_Once sync.Once

func colorSelectionDialogClassStruct_Set() error {
	var err error
	colorSelectionDialogClassStruct_Once.Do(func() {
		colorSelectionDialogClassStruct, err = gi.StructNew("Gtk", "ColorSelectionDialogClass")
	})
	return err
}

type ColorSelectionDialogClass struct {
	native unsafe.Pointer
}

func ColorSelectionDialogClassNewFromNative(native unsafe.Pointer) *ColorSelectionDialogClass {
	err := colorSelectionDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorSelectionDialogClass{native: native}

	return instance
}

/*
CastToColorSelectionDialogClass down casts any arbitrary Object to ColorSelectionDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorSelectionDialogClass.
*/
func CastToColorSelectionDialogClass(object *gobject.Object) *ColorSelectionDialogClass {
	return ColorSelectionDialogClassNewFromNative(object.Native())
}

// Equals compares this ColorSelectionDialogClass with another ColorSelectionDialogClass, and returns true if they represent the same Object.
func (recv *ColorSelectionDialogClass) Equals(other *ColorSelectionDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorSelectionDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ColorSelectionDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(colorSelectionDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ColorSelectionDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(colorSelectionDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ColorSelectionDialogClassStruct creates an uninitialised ColorSelectionDialogClass.
func ColorSelectionDialogClassStruct() *ColorSelectionDialogClass {
	err := colorSelectionDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorSelectionDialogClassNewFromNative(colorSelectionDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorSelectionDialogClass)
	return structGo
}
func finalizeColorSelectionDialogClass(obj *ColorSelectionDialogClass) {
	colorSelectionDialogClassStruct.Free(obj.Native())
}

var colorSelectionDialogPrivateStruct *gi.Struct
var colorSelectionDialogPrivateStruct_Once sync.Once

func colorSelectionDialogPrivateStruct_Set() error {
	var err error
	colorSelectionDialogPrivateStruct_Once.Do(func() {
		colorSelectionDialogPrivateStruct, err = gi.StructNew("Gtk", "ColorSelectionDialogPrivate")
	})
	return err
}

type ColorSelectionDialogPrivate struct {
	native unsafe.Pointer
}

func ColorSelectionDialogPrivateNewFromNative(native unsafe.Pointer) *ColorSelectionDialogPrivate {
	err := colorSelectionDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorSelectionDialogPrivate{native: native}

	return instance
}

/*
CastToColorSelectionDialogPrivate down casts any arbitrary Object to ColorSelectionDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorSelectionDialogPrivate.
*/
func CastToColorSelectionDialogPrivate(object *gobject.Object) *ColorSelectionDialogPrivate {
	return ColorSelectionDialogPrivateNewFromNative(object.Native())
}

// Equals compares this ColorSelectionDialogPrivate with another ColorSelectionDialogPrivate, and returns true if they represent the same Object.
func (recv *ColorSelectionDialogPrivate) Equals(other *ColorSelectionDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorSelectionDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ColorSelectionDialogPrivateStruct creates an uninitialised ColorSelectionDialogPrivate.
func ColorSelectionDialogPrivateStruct() *ColorSelectionDialogPrivate {
	err := colorSelectionDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorSelectionDialogPrivateNewFromNative(colorSelectionDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorSelectionDialogPrivate)
	return structGo
}
func finalizeColorSelectionDialogPrivate(obj *ColorSelectionDialogPrivate) {
	colorSelectionDialogPrivateStruct.Free(obj.Native())
}

var colorSelectionPrivateStruct *gi.Struct
var colorSelectionPrivateStruct_Once sync.Once

func colorSelectionPrivateStruct_Set() error {
	var err error
	colorSelectionPrivateStruct_Once.Do(func() {
		colorSelectionPrivateStruct, err = gi.StructNew("Gtk", "ColorSelectionPrivate")
	})
	return err
}

type ColorSelectionPrivate struct {
	native unsafe.Pointer
}

func ColorSelectionPrivateNewFromNative(native unsafe.Pointer) *ColorSelectionPrivate {
	err := colorSelectionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ColorSelectionPrivate{native: native}

	return instance
}

/*
CastToColorSelectionPrivate down casts any arbitrary Object to ColorSelectionPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ColorSelectionPrivate.
*/
func CastToColorSelectionPrivate(object *gobject.Object) *ColorSelectionPrivate {
	return ColorSelectionPrivateNewFromNative(object.Native())
}

// Equals compares this ColorSelectionPrivate with another ColorSelectionPrivate, and returns true if they represent the same Object.
func (recv *ColorSelectionPrivate) Equals(other *ColorSelectionPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ColorSelectionPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ColorSelectionPrivateStruct creates an uninitialised ColorSelectionPrivate.
func ColorSelectionPrivateStruct() *ColorSelectionPrivate {
	err := colorSelectionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ColorSelectionPrivateNewFromNative(colorSelectionPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeColorSelectionPrivate)
	return structGo
}
func finalizeColorSelectionPrivate(obj *ColorSelectionPrivate) {
	colorSelectionPrivateStruct.Free(obj.Native())
}

var comboBoxAccessibleClassStruct *gi.Struct
var comboBoxAccessibleClassStruct_Once sync.Once

func comboBoxAccessibleClassStruct_Set() error {
	var err error
	comboBoxAccessibleClassStruct_Once.Do(func() {
		comboBoxAccessibleClassStruct, err = gi.StructNew("Gtk", "ComboBoxAccessibleClass")
	})
	return err
}

type ComboBoxAccessibleClass struct {
	native unsafe.Pointer
}

func ComboBoxAccessibleClassNewFromNative(native unsafe.Pointer) *ComboBoxAccessibleClass {
	err := comboBoxAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ComboBoxAccessibleClass{native: native}

	return instance
}

/*
CastToComboBoxAccessibleClass down casts any arbitrary Object to ComboBoxAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ComboBoxAccessibleClass.
*/
func CastToComboBoxAccessibleClass(object *gobject.Object) *ComboBoxAccessibleClass {
	return ComboBoxAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ComboBoxAccessibleClass with another ComboBoxAccessibleClass, and returns true if they represent the same Object.
func (recv *ComboBoxAccessibleClass) Equals(other *ComboBoxAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ComboBoxAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ComboBoxAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(comboBoxAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ComboBoxAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(comboBoxAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ComboBoxAccessibleClassStruct creates an uninitialised ComboBoxAccessibleClass.
func ComboBoxAccessibleClassStruct() *ComboBoxAccessibleClass {
	err := comboBoxAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ComboBoxAccessibleClassNewFromNative(comboBoxAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeComboBoxAccessibleClass)
	return structGo
}
func finalizeComboBoxAccessibleClass(obj *ComboBoxAccessibleClass) {
	comboBoxAccessibleClassStruct.Free(obj.Native())
}

var comboBoxAccessiblePrivateStruct *gi.Struct
var comboBoxAccessiblePrivateStruct_Once sync.Once

func comboBoxAccessiblePrivateStruct_Set() error {
	var err error
	comboBoxAccessiblePrivateStruct_Once.Do(func() {
		comboBoxAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ComboBoxAccessiblePrivate")
	})
	return err
}

type ComboBoxAccessiblePrivate struct {
	native unsafe.Pointer
}

func ComboBoxAccessiblePrivateNewFromNative(native unsafe.Pointer) *ComboBoxAccessiblePrivate {
	err := comboBoxAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ComboBoxAccessiblePrivate{native: native}

	return instance
}

/*
CastToComboBoxAccessiblePrivate down casts any arbitrary Object to ComboBoxAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ComboBoxAccessiblePrivate.
*/
func CastToComboBoxAccessiblePrivate(object *gobject.Object) *ComboBoxAccessiblePrivate {
	return ComboBoxAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ComboBoxAccessiblePrivate with another ComboBoxAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ComboBoxAccessiblePrivate) Equals(other *ComboBoxAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ComboBoxAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ComboBoxAccessiblePrivateStruct creates an uninitialised ComboBoxAccessiblePrivate.
func ComboBoxAccessiblePrivateStruct() *ComboBoxAccessiblePrivate {
	err := comboBoxAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ComboBoxAccessiblePrivateNewFromNative(comboBoxAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeComboBoxAccessiblePrivate)
	return structGo
}
func finalizeComboBoxAccessiblePrivate(obj *ComboBoxAccessiblePrivate) {
	comboBoxAccessiblePrivateStruct.Free(obj.Native())
}

var comboBoxClassStruct *gi.Struct
var comboBoxClassStruct_Once sync.Once

func comboBoxClassStruct_Set() error {
	var err error
	comboBoxClassStruct_Once.Do(func() {
		comboBoxClassStruct, err = gi.StructNew("Gtk", "ComboBoxClass")
	})
	return err
}

type ComboBoxClass struct {
	native unsafe.Pointer
}

func ComboBoxClassNewFromNative(native unsafe.Pointer) *ComboBoxClass {
	err := comboBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ComboBoxClass{native: native}

	return instance
}

/*
CastToComboBoxClass down casts any arbitrary Object to ComboBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ComboBoxClass.
*/
func CastToComboBoxClass(object *gobject.Object) *ComboBoxClass {
	return ComboBoxClassNewFromNative(object.Native())
}

// Equals compares this ComboBoxClass with another ComboBoxClass, and returns true if they represent the same Object.
func (recv *ComboBoxClass) Equals(other *ComboBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ComboBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ComboBoxClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(comboBoxClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ComboBoxClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(comboBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value 'format_entry_text' : for field getter : missing Type

// UNSUPPORTED : C value 'format_entry_text' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// ComboBoxClassStruct creates an uninitialised ComboBoxClass.
func ComboBoxClassStruct() *ComboBoxClass {
	err := comboBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ComboBoxClassNewFromNative(comboBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeComboBoxClass)
	return structGo
}
func finalizeComboBoxClass(obj *ComboBoxClass) {
	comboBoxClassStruct.Free(obj.Native())
}

var comboBoxPrivateStruct *gi.Struct
var comboBoxPrivateStruct_Once sync.Once

func comboBoxPrivateStruct_Set() error {
	var err error
	comboBoxPrivateStruct_Once.Do(func() {
		comboBoxPrivateStruct, err = gi.StructNew("Gtk", "ComboBoxPrivate")
	})
	return err
}

type ComboBoxPrivate struct {
	native unsafe.Pointer
}

func ComboBoxPrivateNewFromNative(native unsafe.Pointer) *ComboBoxPrivate {
	err := comboBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ComboBoxPrivate{native: native}

	return instance
}

/*
CastToComboBoxPrivate down casts any arbitrary Object to ComboBoxPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ComboBoxPrivate.
*/
func CastToComboBoxPrivate(object *gobject.Object) *ComboBoxPrivate {
	return ComboBoxPrivateNewFromNative(object.Native())
}

// Equals compares this ComboBoxPrivate with another ComboBoxPrivate, and returns true if they represent the same Object.
func (recv *ComboBoxPrivate) Equals(other *ComboBoxPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ComboBoxPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ComboBoxPrivateStruct creates an uninitialised ComboBoxPrivate.
func ComboBoxPrivateStruct() *ComboBoxPrivate {
	err := comboBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ComboBoxPrivateNewFromNative(comboBoxPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeComboBoxPrivate)
	return structGo
}
func finalizeComboBoxPrivate(obj *ComboBoxPrivate) {
	comboBoxPrivateStruct.Free(obj.Native())
}

var comboBoxTextClassStruct *gi.Struct
var comboBoxTextClassStruct_Once sync.Once

func comboBoxTextClassStruct_Set() error {
	var err error
	comboBoxTextClassStruct_Once.Do(func() {
		comboBoxTextClassStruct, err = gi.StructNew("Gtk", "ComboBoxTextClass")
	})
	return err
}

type ComboBoxTextClass struct {
	native unsafe.Pointer
}

func ComboBoxTextClassNewFromNative(native unsafe.Pointer) *ComboBoxTextClass {
	err := comboBoxTextClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ComboBoxTextClass{native: native}

	return instance
}

/*
CastToComboBoxTextClass down casts any arbitrary Object to ComboBoxTextClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ComboBoxTextClass.
*/
func CastToComboBoxTextClass(object *gobject.Object) *ComboBoxTextClass {
	return ComboBoxTextClassNewFromNative(object.Native())
}

// Equals compares this ComboBoxTextClass with another ComboBoxTextClass, and returns true if they represent the same Object.
func (recv *ComboBoxTextClass) Equals(other *ComboBoxTextClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ComboBoxTextClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ComboBoxTextClass) FieldParentClass() *ComboBoxClass {
	argValue := gi.StructFieldGet(comboBoxTextClassStruct, recv.Native(), "parent_class")
	value := ComboBoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ComboBoxTextClass) SetFieldParentClass(value *ComboBoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(comboBoxTextClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ComboBoxTextClassStruct creates an uninitialised ComboBoxTextClass.
func ComboBoxTextClassStruct() *ComboBoxTextClass {
	err := comboBoxTextClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ComboBoxTextClassNewFromNative(comboBoxTextClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeComboBoxTextClass)
	return structGo
}
func finalizeComboBoxTextClass(obj *ComboBoxTextClass) {
	comboBoxTextClassStruct.Free(obj.Native())
}

var comboBoxTextPrivateStruct *gi.Struct
var comboBoxTextPrivateStruct_Once sync.Once

func comboBoxTextPrivateStruct_Set() error {
	var err error
	comboBoxTextPrivateStruct_Once.Do(func() {
		comboBoxTextPrivateStruct, err = gi.StructNew("Gtk", "ComboBoxTextPrivate")
	})
	return err
}

type ComboBoxTextPrivate struct {
	native unsafe.Pointer
}

func ComboBoxTextPrivateNewFromNative(native unsafe.Pointer) *ComboBoxTextPrivate {
	err := comboBoxTextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ComboBoxTextPrivate{native: native}

	return instance
}

/*
CastToComboBoxTextPrivate down casts any arbitrary Object to ComboBoxTextPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ComboBoxTextPrivate.
*/
func CastToComboBoxTextPrivate(object *gobject.Object) *ComboBoxTextPrivate {
	return ComboBoxTextPrivateNewFromNative(object.Native())
}

// Equals compares this ComboBoxTextPrivate with another ComboBoxTextPrivate, and returns true if they represent the same Object.
func (recv *ComboBoxTextPrivate) Equals(other *ComboBoxTextPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ComboBoxTextPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ComboBoxTextPrivateStruct creates an uninitialised ComboBoxTextPrivate.
func ComboBoxTextPrivateStruct() *ComboBoxTextPrivate {
	err := comboBoxTextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ComboBoxTextPrivateNewFromNative(comboBoxTextPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeComboBoxTextPrivate)
	return structGo
}
func finalizeComboBoxTextPrivate(obj *ComboBoxTextPrivate) {
	comboBoxTextPrivateStruct.Free(obj.Native())
}

var containerAccessibleClassStruct *gi.Struct
var containerAccessibleClassStruct_Once sync.Once

func containerAccessibleClassStruct_Set() error {
	var err error
	containerAccessibleClassStruct_Once.Do(func() {
		containerAccessibleClassStruct, err = gi.StructNew("Gtk", "ContainerAccessibleClass")
	})
	return err
}

type ContainerAccessibleClass struct {
	native unsafe.Pointer
}

func ContainerAccessibleClassNewFromNative(native unsafe.Pointer) *ContainerAccessibleClass {
	err := containerAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ContainerAccessibleClass{native: native}

	return instance
}

/*
CastToContainerAccessibleClass down casts any arbitrary Object to ContainerAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ContainerAccessibleClass.
*/
func CastToContainerAccessibleClass(object *gobject.Object) *ContainerAccessibleClass {
	return ContainerAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ContainerAccessibleClass with another ContainerAccessibleClass, and returns true if they represent the same Object.
func (recv *ContainerAccessibleClass) Equals(other *ContainerAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ContainerAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ContainerAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(containerAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ContainerAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(containerAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'add_gtk' : for field getter : missing Type

// UNSUPPORTED : C value 'add_gtk' : for field setter : missing Type

// UNSUPPORTED : C value 'remove_gtk' : for field getter : missing Type

// UNSUPPORTED : C value 'remove_gtk' : for field setter : missing Type

// ContainerAccessibleClassStruct creates an uninitialised ContainerAccessibleClass.
func ContainerAccessibleClassStruct() *ContainerAccessibleClass {
	err := containerAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ContainerAccessibleClassNewFromNative(containerAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeContainerAccessibleClass)
	return structGo
}
func finalizeContainerAccessibleClass(obj *ContainerAccessibleClass) {
	containerAccessibleClassStruct.Free(obj.Native())
}

var containerAccessiblePrivateStruct *gi.Struct
var containerAccessiblePrivateStruct_Once sync.Once

func containerAccessiblePrivateStruct_Set() error {
	var err error
	containerAccessiblePrivateStruct_Once.Do(func() {
		containerAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ContainerAccessiblePrivate")
	})
	return err
}

type ContainerAccessiblePrivate struct {
	native unsafe.Pointer
}

func ContainerAccessiblePrivateNewFromNative(native unsafe.Pointer) *ContainerAccessiblePrivate {
	err := containerAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ContainerAccessiblePrivate{native: native}

	return instance
}

/*
CastToContainerAccessiblePrivate down casts any arbitrary Object to ContainerAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ContainerAccessiblePrivate.
*/
func CastToContainerAccessiblePrivate(object *gobject.Object) *ContainerAccessiblePrivate {
	return ContainerAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ContainerAccessiblePrivate with another ContainerAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ContainerAccessiblePrivate) Equals(other *ContainerAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ContainerAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ContainerAccessiblePrivateStruct creates an uninitialised ContainerAccessiblePrivate.
func ContainerAccessiblePrivateStruct() *ContainerAccessiblePrivate {
	err := containerAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ContainerAccessiblePrivateNewFromNative(containerAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeContainerAccessiblePrivate)
	return structGo
}
func finalizeContainerAccessiblePrivate(obj *ContainerAccessiblePrivate) {
	containerAccessiblePrivateStruct.Free(obj.Native())
}

var containerCellAccessibleClassStruct *gi.Struct
var containerCellAccessibleClassStruct_Once sync.Once

func containerCellAccessibleClassStruct_Set() error {
	var err error
	containerCellAccessibleClassStruct_Once.Do(func() {
		containerCellAccessibleClassStruct, err = gi.StructNew("Gtk", "ContainerCellAccessibleClass")
	})
	return err
}

type ContainerCellAccessibleClass struct {
	native unsafe.Pointer
}

func ContainerCellAccessibleClassNewFromNative(native unsafe.Pointer) *ContainerCellAccessibleClass {
	err := containerCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ContainerCellAccessibleClass{native: native}

	return instance
}

/*
CastToContainerCellAccessibleClass down casts any arbitrary Object to ContainerCellAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ContainerCellAccessibleClass.
*/
func CastToContainerCellAccessibleClass(object *gobject.Object) *ContainerCellAccessibleClass {
	return ContainerCellAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ContainerCellAccessibleClass with another ContainerCellAccessibleClass, and returns true if they represent the same Object.
func (recv *ContainerCellAccessibleClass) Equals(other *ContainerCellAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ContainerCellAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ContainerCellAccessibleClass) FieldParentClass() *CellAccessibleClass {
	argValue := gi.StructFieldGet(containerCellAccessibleClassStruct, recv.Native(), "parent_class")
	value := CellAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ContainerCellAccessibleClass) SetFieldParentClass(value *CellAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(containerCellAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ContainerCellAccessibleClassStruct creates an uninitialised ContainerCellAccessibleClass.
func ContainerCellAccessibleClassStruct() *ContainerCellAccessibleClass {
	err := containerCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ContainerCellAccessibleClassNewFromNative(containerCellAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeContainerCellAccessibleClass)
	return structGo
}
func finalizeContainerCellAccessibleClass(obj *ContainerCellAccessibleClass) {
	containerCellAccessibleClassStruct.Free(obj.Native())
}

var containerCellAccessiblePrivateStruct *gi.Struct
var containerCellAccessiblePrivateStruct_Once sync.Once

func containerCellAccessiblePrivateStruct_Set() error {
	var err error
	containerCellAccessiblePrivateStruct_Once.Do(func() {
		containerCellAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ContainerCellAccessiblePrivate")
	})
	return err
}

type ContainerCellAccessiblePrivate struct {
	native unsafe.Pointer
}

func ContainerCellAccessiblePrivateNewFromNative(native unsafe.Pointer) *ContainerCellAccessiblePrivate {
	err := containerCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ContainerCellAccessiblePrivate{native: native}

	return instance
}

/*
CastToContainerCellAccessiblePrivate down casts any arbitrary Object to ContainerCellAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ContainerCellAccessiblePrivate.
*/
func CastToContainerCellAccessiblePrivate(object *gobject.Object) *ContainerCellAccessiblePrivate {
	return ContainerCellAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ContainerCellAccessiblePrivate with another ContainerCellAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ContainerCellAccessiblePrivate) Equals(other *ContainerCellAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ContainerCellAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ContainerCellAccessiblePrivateStruct creates an uninitialised ContainerCellAccessiblePrivate.
func ContainerCellAccessiblePrivateStruct() *ContainerCellAccessiblePrivate {
	err := containerCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ContainerCellAccessiblePrivateNewFromNative(containerCellAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeContainerCellAccessiblePrivate)
	return structGo
}
func finalizeContainerCellAccessiblePrivate(obj *ContainerCellAccessiblePrivate) {
	containerCellAccessiblePrivateStruct.Free(obj.Native())
}

var containerClassStruct *gi.Struct
var containerClassStruct_Once sync.Once

func containerClassStruct_Set() error {
	var err error
	containerClassStruct_Once.Do(func() {
		containerClassStruct, err = gi.StructNew("Gtk", "ContainerClass")
	})
	return err
}

type ContainerClass struct {
	native unsafe.Pointer
}

func ContainerClassNewFromNative(native unsafe.Pointer) *ContainerClass {
	err := containerClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ContainerClass{native: native}

	return instance
}

/*
CastToContainerClass down casts any arbitrary Object to ContainerClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ContainerClass.
*/
func CastToContainerClass(object *gobject.Object) *ContainerClass {
	return ContainerClassNewFromNative(object.Native())
}

// Equals compares this ContainerClass with another ContainerClass, and returns true if they represent the same Object.
func (recv *ContainerClass) Equals(other *ContainerClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ContainerClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ContainerClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(containerClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ContainerClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(containerClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'add' : for field getter : missing Type

// UNSUPPORTED : C value 'add' : for field setter : missing Type

// UNSUPPORTED : C value 'remove' : for field getter : missing Type

// UNSUPPORTED : C value 'remove' : for field setter : missing Type

// UNSUPPORTED : C value 'check_resize' : for field getter : missing Type

// UNSUPPORTED : C value 'check_resize' : for field setter : missing Type

// UNSUPPORTED : C value 'forall' : for field getter : missing Type

// UNSUPPORTED : C value 'forall' : for field setter : missing Type

// UNSUPPORTED : C value 'set_focus_child' : for field getter : missing Type

// UNSUPPORTED : C value 'set_focus_child' : for field setter : missing Type

// UNSUPPORTED : C value 'child_type' : for field getter : missing Type

// UNSUPPORTED : C value 'child_type' : for field setter : missing Type

// UNSUPPORTED : C value 'composite_name' : for field getter : missing Type

// UNSUPPORTED : C value 'composite_name' : for field setter : missing Type

// UNSUPPORTED : C value 'set_child_property' : for field getter : missing Type

// UNSUPPORTED : C value 'set_child_property' : for field setter : missing Type

// UNSUPPORTED : C value 'get_child_property' : for field getter : missing Type

// UNSUPPORTED : C value 'get_child_property' : for field setter : missing Type

// UNSUPPORTED : C value 'get_path_for_child' : for field getter : missing Type

// UNSUPPORTED : C value 'get_path_for_child' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

var containerClassFindChildPropertyFunction *gi.Function
var containerClassFindChildPropertyFunction_Once sync.Once

func containerClassFindChildPropertyFunction_Set() error {
	var err error
	containerClassFindChildPropertyFunction_Once.Do(func() {
		err = containerClassStruct_Set()
		if err != nil {
			return
		}
		containerClassFindChildPropertyFunction, err = containerClassStruct.InvokerNew("find_child_property")
	})
	return err
}

// FindChildProperty is a representation of the C type gtk_container_class_find_child_property.
func (recv *ContainerClass) FindChildProperty(propertyName string) *gobject.ParamSpec {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(propertyName)

	var ret gi.Argument

	err := containerClassFindChildPropertyFunction_Set()
	if err == nil {
		ret = containerClassFindChildPropertyFunction.Invoke(inArgs[:], nil)
	}

	retGo := gobject.ParamSpecNewFromNative(ret.Pointer())

	return retGo
}

var containerClassHandleBorderWidthFunction *gi.Function
var containerClassHandleBorderWidthFunction_Once sync.Once

func containerClassHandleBorderWidthFunction_Set() error {
	var err error
	containerClassHandleBorderWidthFunction_Once.Do(func() {
		err = containerClassStruct_Set()
		if err != nil {
			return
		}
		containerClassHandleBorderWidthFunction, err = containerClassStruct.InvokerNew("handle_border_width")
	})
	return err
}

// HandleBorderWidth is a representation of the C type gtk_container_class_handle_border_width.
func (recv *ContainerClass) HandleBorderWidth() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := containerClassHandleBorderWidthFunction_Set()
	if err == nil {
		containerClassHandleBorderWidthFunction.Invoke(inArgs[:], nil)
	}

	return
}

// UNSUPPORTED : C value 'gtk_container_class_install_child_properties' : array parameter 'pspecs'

var containerClassInstallChildPropertyFunction *gi.Function
var containerClassInstallChildPropertyFunction_Once sync.Once

func containerClassInstallChildPropertyFunction_Set() error {
	var err error
	containerClassInstallChildPropertyFunction_Once.Do(func() {
		err = containerClassStruct_Set()
		if err != nil {
			return
		}
		containerClassInstallChildPropertyFunction, err = containerClassStruct.InvokerNew("install_child_property")
	})
	return err
}

// InstallChildProperty is a representation of the C type gtk_container_class_install_child_property.
func (recv *ContainerClass) InstallChildProperty(propertyId uint32, pspec *gobject.ParamSpec) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetUint32(propertyId)
	inArgs[2].SetPointer(pspec.Native())

	err := containerClassInstallChildPropertyFunction_Set()
	if err == nil {
		containerClassInstallChildPropertyFunction.Invoke(inArgs[:], nil)
	}

	return
}

var containerClassListChildPropertiesFunction *gi.Function
var containerClassListChildPropertiesFunction_Once sync.Once

func containerClassListChildPropertiesFunction_Set() error {
	var err error
	containerClassListChildPropertiesFunction_Once.Do(func() {
		err = containerClassStruct_Set()
		if err != nil {
			return
		}
		containerClassListChildPropertiesFunction, err = containerClassStruct.InvokerNew("list_child_properties")
	})
	return err
}

// ListChildProperties is a representation of the C type gtk_container_class_list_child_properties.
func (recv *ContainerClass) ListChildProperties() uint32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var outArgs [1]gi.Argument

	err := containerClassListChildPropertiesFunction_Set()
	if err == nil {
		containerClassListChildPropertiesFunction.Invoke(inArgs[:], outArgs[:])
	}

	out0 := outArgs[0].Uint32()

	return out0
}

// ContainerClassStruct creates an uninitialised ContainerClass.
func ContainerClassStruct() *ContainerClass {
	err := containerClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ContainerClassNewFromNative(containerClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeContainerClass)
	return structGo
}
func finalizeContainerClass(obj *ContainerClass) {
	containerClassStruct.Free(obj.Native())
}

var containerPrivateStruct *gi.Struct
var containerPrivateStruct_Once sync.Once

func containerPrivateStruct_Set() error {
	var err error
	containerPrivateStruct_Once.Do(func() {
		containerPrivateStruct, err = gi.StructNew("Gtk", "ContainerPrivate")
	})
	return err
}

type ContainerPrivate struct {
	native unsafe.Pointer
}

func ContainerPrivateNewFromNative(native unsafe.Pointer) *ContainerPrivate {
	err := containerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ContainerPrivate{native: native}

	return instance
}

/*
CastToContainerPrivate down casts any arbitrary Object to ContainerPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ContainerPrivate.
*/
func CastToContainerPrivate(object *gobject.Object) *ContainerPrivate {
	return ContainerPrivateNewFromNative(object.Native())
}

// Equals compares this ContainerPrivate with another ContainerPrivate, and returns true if they represent the same Object.
func (recv *ContainerPrivate) Equals(other *ContainerPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ContainerPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ContainerPrivateStruct creates an uninitialised ContainerPrivate.
func ContainerPrivateStruct() *ContainerPrivate {
	err := containerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ContainerPrivateNewFromNative(containerPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeContainerPrivate)
	return structGo
}
func finalizeContainerPrivate(obj *ContainerPrivate) {
	containerPrivateStruct.Free(obj.Native())
}

var cssProviderClassStruct *gi.Struct
var cssProviderClassStruct_Once sync.Once

func cssProviderClassStruct_Set() error {
	var err error
	cssProviderClassStruct_Once.Do(func() {
		cssProviderClassStruct, err = gi.StructNew("Gtk", "CssProviderClass")
	})
	return err
}

type CssProviderClass struct {
	native unsafe.Pointer
}

func CssProviderClassNewFromNative(native unsafe.Pointer) *CssProviderClass {
	err := cssProviderClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CssProviderClass{native: native}

	return instance
}

/*
CastToCssProviderClass down casts any arbitrary Object to CssProviderClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a CssProviderClass.
*/
func CastToCssProviderClass(object *gobject.Object) *CssProviderClass {
	return CssProviderClassNewFromNative(object.Native())
}

// Equals compares this CssProviderClass with another CssProviderClass, and returns true if they represent the same Object.
func (recv *CssProviderClass) Equals(other *CssProviderClass) bool {
	return other.Native() == recv.Native()
}

func (recv *CssProviderClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *CssProviderClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(cssProviderClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *CssProviderClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(cssProviderClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'parsing_error' : for field getter : missing Type

// UNSUPPORTED : C value 'parsing_error' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// CssProviderClassStruct creates an uninitialised CssProviderClass.
func CssProviderClassStruct() *CssProviderClass {
	err := cssProviderClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CssProviderClassNewFromNative(cssProviderClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCssProviderClass)
	return structGo
}
func finalizeCssProviderClass(obj *CssProviderClass) {
	cssProviderClassStruct.Free(obj.Native())
}

var cssProviderPrivateStruct *gi.Struct
var cssProviderPrivateStruct_Once sync.Once

func cssProviderPrivateStruct_Set() error {
	var err error
	cssProviderPrivateStruct_Once.Do(func() {
		cssProviderPrivateStruct, err = gi.StructNew("Gtk", "CssProviderPrivate")
	})
	return err
}

type CssProviderPrivate struct {
	native unsafe.Pointer
}

func CssProviderPrivateNewFromNative(native unsafe.Pointer) *CssProviderPrivate {
	err := cssProviderPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CssProviderPrivate{native: native}

	return instance
}

/*
CastToCssProviderPrivate down casts any arbitrary Object to CssProviderPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a CssProviderPrivate.
*/
func CastToCssProviderPrivate(object *gobject.Object) *CssProviderPrivate {
	return CssProviderPrivateNewFromNative(object.Native())
}

// Equals compares this CssProviderPrivate with another CssProviderPrivate, and returns true if they represent the same Object.
func (recv *CssProviderPrivate) Equals(other *CssProviderPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *CssProviderPrivate) Native() unsafe.Pointer {
	return recv.native
}

// CssProviderPrivateStruct creates an uninitialised CssProviderPrivate.
func CssProviderPrivateStruct() *CssProviderPrivate {
	err := cssProviderPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CssProviderPrivateNewFromNative(cssProviderPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCssProviderPrivate)
	return structGo
}
func finalizeCssProviderPrivate(obj *CssProviderPrivate) {
	cssProviderPrivateStruct.Free(obj.Native())
}

var cssSectionStruct *gi.Struct
var cssSectionStruct_Once sync.Once

func cssSectionStruct_Set() error {
	var err error
	cssSectionStruct_Once.Do(func() {
		cssSectionStruct, err = gi.StructNew("Gtk", "CssSection")
	})
	return err
}

type CssSection struct {
	native unsafe.Pointer
}

func CssSectionNewFromNative(native unsafe.Pointer) *CssSection {
	err := cssSectionStruct_Set()
	if err != nil {
		return nil
	}

	instance := &CssSection{native: native}

	return instance
}

/*
CastToCssSection down casts any arbitrary Object to CssSection.
Exercise care, as this is a potentially dangerous function
if the Object is not a CssSection.
*/
func CastToCssSection(object *gobject.Object) *CssSection {
	return CssSectionNewFromNative(object.Native())
}

// Equals compares this CssSection with another CssSection, and returns true if they represent the same Object.
func (recv *CssSection) Equals(other *CssSection) bool {
	return other.Native() == recv.Native()
}

func (recv *CssSection) Native() unsafe.Pointer {
	return recv.native
}

var cssSectionGetEndLineFunction *gi.Function
var cssSectionGetEndLineFunction_Once sync.Once

func cssSectionGetEndLineFunction_Set() error {
	var err error
	cssSectionGetEndLineFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionGetEndLineFunction, err = cssSectionStruct.InvokerNew("get_end_line")
	})
	return err
}

// GetEndLine is a representation of the C type gtk_css_section_get_end_line.
func (recv *CssSection) GetEndLine() uint32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := cssSectionGetEndLineFunction_Set()
	if err == nil {
		ret = cssSectionGetEndLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Uint32()

	return retGo
}

var cssSectionGetEndPositionFunction *gi.Function
var cssSectionGetEndPositionFunction_Once sync.Once

func cssSectionGetEndPositionFunction_Set() error {
	var err error
	cssSectionGetEndPositionFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionGetEndPositionFunction, err = cssSectionStruct.InvokerNew("get_end_position")
	})
	return err
}

// GetEndPosition is a representation of the C type gtk_css_section_get_end_position.
func (recv *CssSection) GetEndPosition() uint32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := cssSectionGetEndPositionFunction_Set()
	if err == nil {
		ret = cssSectionGetEndPositionFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Uint32()

	return retGo
}

var cssSectionGetFileFunction *gi.Function
var cssSectionGetFileFunction_Once sync.Once

func cssSectionGetFileFunction_Set() error {
	var err error
	cssSectionGetFileFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionGetFileFunction, err = cssSectionStruct.InvokerNew("get_file")
	})
	return err
}

// GetFile is a representation of the C type gtk_css_section_get_file.
func (recv *CssSection) GetFile() *gio.File {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := cssSectionGetFileFunction_Set()
	if err == nil {
		ret = cssSectionGetFileFunction.Invoke(inArgs[:], nil)
	}

	retGo := gio.FileNewFromNative(ret.Pointer())

	return retGo
}

var cssSectionGetParentFunction *gi.Function
var cssSectionGetParentFunction_Once sync.Once

func cssSectionGetParentFunction_Set() error {
	var err error
	cssSectionGetParentFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionGetParentFunction, err = cssSectionStruct.InvokerNew("get_parent")
	})
	return err
}

// GetParent is a representation of the C type gtk_css_section_get_parent.
func (recv *CssSection) GetParent() *CssSection {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := cssSectionGetParentFunction_Set()
	if err == nil {
		ret = cssSectionGetParentFunction.Invoke(inArgs[:], nil)
	}

	retGo := CssSectionNewFromNative(ret.Pointer())

	return retGo
}

var cssSectionGetSectionTypeFunction *gi.Function
var cssSectionGetSectionTypeFunction_Once sync.Once

func cssSectionGetSectionTypeFunction_Set() error {
	var err error
	cssSectionGetSectionTypeFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionGetSectionTypeFunction, err = cssSectionStruct.InvokerNew("get_section_type")
	})
	return err
}

// GetSectionType is a representation of the C type gtk_css_section_get_section_type.
func (recv *CssSection) GetSectionType() CssSectionType {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := cssSectionGetSectionTypeFunction_Set()
	if err == nil {
		ret = cssSectionGetSectionTypeFunction.Invoke(inArgs[:], nil)
	}

	retGo := CssSectionType(ret.Int32())

	return retGo
}

var cssSectionGetStartLineFunction *gi.Function
var cssSectionGetStartLineFunction_Once sync.Once

func cssSectionGetStartLineFunction_Set() error {
	var err error
	cssSectionGetStartLineFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionGetStartLineFunction, err = cssSectionStruct.InvokerNew("get_start_line")
	})
	return err
}

// GetStartLine is a representation of the C type gtk_css_section_get_start_line.
func (recv *CssSection) GetStartLine() uint32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := cssSectionGetStartLineFunction_Set()
	if err == nil {
		ret = cssSectionGetStartLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Uint32()

	return retGo
}

var cssSectionGetStartPositionFunction *gi.Function
var cssSectionGetStartPositionFunction_Once sync.Once

func cssSectionGetStartPositionFunction_Set() error {
	var err error
	cssSectionGetStartPositionFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionGetStartPositionFunction, err = cssSectionStruct.InvokerNew("get_start_position")
	})
	return err
}

// GetStartPosition is a representation of the C type gtk_css_section_get_start_position.
func (recv *CssSection) GetStartPosition() uint32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := cssSectionGetStartPositionFunction_Set()
	if err == nil {
		ret = cssSectionGetStartPositionFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Uint32()

	return retGo
}

var cssSectionRefFunction *gi.Function
var cssSectionRefFunction_Once sync.Once

func cssSectionRefFunction_Set() error {
	var err error
	cssSectionRefFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionRefFunction, err = cssSectionStruct.InvokerNew("ref")
	})
	return err
}

// Ref is a representation of the C type gtk_css_section_ref.
func (recv *CssSection) Ref() *CssSection {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := cssSectionRefFunction_Set()
	if err == nil {
		ret = cssSectionRefFunction.Invoke(inArgs[:], nil)
	}

	retGo := CssSectionNewFromNative(ret.Pointer())

	return retGo
}

var cssSectionUnrefFunction *gi.Function
var cssSectionUnrefFunction_Once sync.Once

func cssSectionUnrefFunction_Set() error {
	var err error
	cssSectionUnrefFunction_Once.Do(func() {
		err = cssSectionStruct_Set()
		if err != nil {
			return
		}
		cssSectionUnrefFunction, err = cssSectionStruct.InvokerNew("unref")
	})
	return err
}

// Unref is a representation of the C type gtk_css_section_unref.
func (recv *CssSection) Unref() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := cssSectionUnrefFunction_Set()
	if err == nil {
		cssSectionUnrefFunction.Invoke(inArgs[:], nil)
	}

	return
}

// CssSectionStruct creates an uninitialised CssSection.
func CssSectionStruct() *CssSection {
	err := cssSectionStruct_Set()
	if err != nil {
		return nil
	}

	structGo := CssSectionNewFromNative(cssSectionStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeCssSection)
	return structGo
}
func finalizeCssSection(obj *CssSection) {
	cssSectionStruct.Free(obj.Native())
}

var dialogClassStruct *gi.Struct
var dialogClassStruct_Once sync.Once

func dialogClassStruct_Set() error {
	var err error
	dialogClassStruct_Once.Do(func() {
		dialogClassStruct, err = gi.StructNew("Gtk", "DialogClass")
	})
	return err
}

type DialogClass struct {
	native unsafe.Pointer
}

func DialogClassNewFromNative(native unsafe.Pointer) *DialogClass {
	err := dialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &DialogClass{native: native}

	return instance
}

/*
CastToDialogClass down casts any arbitrary Object to DialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a DialogClass.
*/
func CastToDialogClass(object *gobject.Object) *DialogClass {
	return DialogClassNewFromNative(object.Native())
}

// Equals compares this DialogClass with another DialogClass, and returns true if they represent the same Object.
func (recv *DialogClass) Equals(other *DialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *DialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *DialogClass) FieldParentClass() *WindowClass {
	argValue := gi.StructFieldGet(dialogClassStruct, recv.Native(), "parent_class")
	value := WindowClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *DialogClass) SetFieldParentClass(value *WindowClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(dialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'response' : for field getter : missing Type

// UNSUPPORTED : C value 'response' : for field setter : missing Type

// UNSUPPORTED : C value 'close' : for field getter : missing Type

// UNSUPPORTED : C value 'close' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// DialogClassStruct creates an uninitialised DialogClass.
func DialogClassStruct() *DialogClass {
	err := dialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := DialogClassNewFromNative(dialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeDialogClass)
	return structGo
}
func finalizeDialogClass(obj *DialogClass) {
	dialogClassStruct.Free(obj.Native())
}

var dialogPrivateStruct *gi.Struct
var dialogPrivateStruct_Once sync.Once

func dialogPrivateStruct_Set() error {
	var err error
	dialogPrivateStruct_Once.Do(func() {
		dialogPrivateStruct, err = gi.StructNew("Gtk", "DialogPrivate")
	})
	return err
}

type DialogPrivate struct {
	native unsafe.Pointer
}

func DialogPrivateNewFromNative(native unsafe.Pointer) *DialogPrivate {
	err := dialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &DialogPrivate{native: native}

	return instance
}

/*
CastToDialogPrivate down casts any arbitrary Object to DialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a DialogPrivate.
*/
func CastToDialogPrivate(object *gobject.Object) *DialogPrivate {
	return DialogPrivateNewFromNative(object.Native())
}

// Equals compares this DialogPrivate with another DialogPrivate, and returns true if they represent the same Object.
func (recv *DialogPrivate) Equals(other *DialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *DialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// DialogPrivateStruct creates an uninitialised DialogPrivate.
func DialogPrivateStruct() *DialogPrivate {
	err := dialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := DialogPrivateNewFromNative(dialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeDialogPrivate)
	return structGo
}
func finalizeDialogPrivate(obj *DialogPrivate) {
	dialogPrivateStruct.Free(obj.Native())
}

var drawingAreaClassStruct *gi.Struct
var drawingAreaClassStruct_Once sync.Once

func drawingAreaClassStruct_Set() error {
	var err error
	drawingAreaClassStruct_Once.Do(func() {
		drawingAreaClassStruct, err = gi.StructNew("Gtk", "DrawingAreaClass")
	})
	return err
}

type DrawingAreaClass struct {
	native unsafe.Pointer
}

func DrawingAreaClassNewFromNative(native unsafe.Pointer) *DrawingAreaClass {
	err := drawingAreaClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &DrawingAreaClass{native: native}

	return instance
}

/*
CastToDrawingAreaClass down casts any arbitrary Object to DrawingAreaClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a DrawingAreaClass.
*/
func CastToDrawingAreaClass(object *gobject.Object) *DrawingAreaClass {
	return DrawingAreaClassNewFromNative(object.Native())
}

// Equals compares this DrawingAreaClass with another DrawingAreaClass, and returns true if they represent the same Object.
func (recv *DrawingAreaClass) Equals(other *DrawingAreaClass) bool {
	return other.Native() == recv.Native()
}

func (recv *DrawingAreaClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *DrawingAreaClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(drawingAreaClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *DrawingAreaClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(drawingAreaClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// DrawingAreaClassStruct creates an uninitialised DrawingAreaClass.
func DrawingAreaClassStruct() *DrawingAreaClass {
	err := drawingAreaClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := DrawingAreaClassNewFromNative(drawingAreaClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeDrawingAreaClass)
	return structGo
}
func finalizeDrawingAreaClass(obj *DrawingAreaClass) {
	drawingAreaClassStruct.Free(obj.Native())
}

var editableInterfaceStruct *gi.Struct
var editableInterfaceStruct_Once sync.Once

func editableInterfaceStruct_Set() error {
	var err error
	editableInterfaceStruct_Once.Do(func() {
		editableInterfaceStruct, err = gi.StructNew("Gtk", "EditableInterface")
	})
	return err
}

type EditableInterface struct {
	native unsafe.Pointer
}

func EditableInterfaceNewFromNative(native unsafe.Pointer) *EditableInterface {
	err := editableInterfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EditableInterface{native: native}

	return instance
}

/*
CastToEditableInterface down casts any arbitrary Object to EditableInterface.
Exercise care, as this is a potentially dangerous function
if the Object is not a EditableInterface.
*/
func CastToEditableInterface(object *gobject.Object) *EditableInterface {
	return EditableInterfaceNewFromNative(object.Native())
}

// Equals compares this EditableInterface with another EditableInterface, and returns true if they represent the same Object.
func (recv *EditableInterface) Equals(other *EditableInterface) bool {
	return other.Native() == recv.Native()
}

func (recv *EditableInterface) Native() unsafe.Pointer {
	return recv.native
}

// FieldBaseIface returns the C field 'base_iface'.
func (recv *EditableInterface) FieldBaseIface() *gobject.TypeInterface {
	argValue := gi.StructFieldGet(editableInterfaceStruct, recv.Native(), "base_iface")
	value := gobject.TypeInterfaceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldBaseIface sets the value of the C field 'base_iface'.
func (recv *EditableInterface) SetFieldBaseIface(value *gobject.TypeInterface) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(editableInterfaceStruct, recv.Native(), "base_iface", argValue)
}

// UNSUPPORTED : C value 'insert_text' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_text' : for field setter : missing Type

// UNSUPPORTED : C value 'delete_text' : for field getter : missing Type

// UNSUPPORTED : C value 'delete_text' : for field setter : missing Type

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value 'do_insert_text' : for field getter : missing Type

// UNSUPPORTED : C value 'do_insert_text' : for field setter : missing Type

// UNSUPPORTED : C value 'do_delete_text' : for field getter : missing Type

// UNSUPPORTED : C value 'do_delete_text' : for field setter : missing Type

// UNSUPPORTED : C value 'get_chars' : for field getter : missing Type

// UNSUPPORTED : C value 'get_chars' : for field setter : missing Type

// UNSUPPORTED : C value 'set_selection_bounds' : for field getter : missing Type

// UNSUPPORTED : C value 'set_selection_bounds' : for field setter : missing Type

// UNSUPPORTED : C value 'get_selection_bounds' : for field getter : missing Type

// UNSUPPORTED : C value 'get_selection_bounds' : for field setter : missing Type

// UNSUPPORTED : C value 'set_position' : for field getter : missing Type

// UNSUPPORTED : C value 'set_position' : for field setter : missing Type

// UNSUPPORTED : C value 'get_position' : for field getter : missing Type

// UNSUPPORTED : C value 'get_position' : for field setter : missing Type

// EditableInterfaceStruct creates an uninitialised EditableInterface.
func EditableInterfaceStruct() *EditableInterface {
	err := editableInterfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EditableInterfaceNewFromNative(editableInterfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEditableInterface)
	return structGo
}
func finalizeEditableInterface(obj *EditableInterface) {
	editableInterfaceStruct.Free(obj.Native())
}

var entryAccessibleClassStruct *gi.Struct
var entryAccessibleClassStruct_Once sync.Once

func entryAccessibleClassStruct_Set() error {
	var err error
	entryAccessibleClassStruct_Once.Do(func() {
		entryAccessibleClassStruct, err = gi.StructNew("Gtk", "EntryAccessibleClass")
	})
	return err
}

type EntryAccessibleClass struct {
	native unsafe.Pointer
}

func EntryAccessibleClassNewFromNative(native unsafe.Pointer) *EntryAccessibleClass {
	err := entryAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EntryAccessibleClass{native: native}

	return instance
}

/*
CastToEntryAccessibleClass down casts any arbitrary Object to EntryAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EntryAccessibleClass.
*/
func CastToEntryAccessibleClass(object *gobject.Object) *EntryAccessibleClass {
	return EntryAccessibleClassNewFromNative(object.Native())
}

// Equals compares this EntryAccessibleClass with another EntryAccessibleClass, and returns true if they represent the same Object.
func (recv *EntryAccessibleClass) Equals(other *EntryAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EntryAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *EntryAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(entryAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *EntryAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(entryAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// EntryAccessibleClassStruct creates an uninitialised EntryAccessibleClass.
func EntryAccessibleClassStruct() *EntryAccessibleClass {
	err := entryAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EntryAccessibleClassNewFromNative(entryAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEntryAccessibleClass)
	return structGo
}
func finalizeEntryAccessibleClass(obj *EntryAccessibleClass) {
	entryAccessibleClassStruct.Free(obj.Native())
}

var entryAccessiblePrivateStruct *gi.Struct
var entryAccessiblePrivateStruct_Once sync.Once

func entryAccessiblePrivateStruct_Set() error {
	var err error
	entryAccessiblePrivateStruct_Once.Do(func() {
		entryAccessiblePrivateStruct, err = gi.StructNew("Gtk", "EntryAccessiblePrivate")
	})
	return err
}

type EntryAccessiblePrivate struct {
	native unsafe.Pointer
}

func EntryAccessiblePrivateNewFromNative(native unsafe.Pointer) *EntryAccessiblePrivate {
	err := entryAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EntryAccessiblePrivate{native: native}

	return instance
}

/*
CastToEntryAccessiblePrivate down casts any arbitrary Object to EntryAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a EntryAccessiblePrivate.
*/
func CastToEntryAccessiblePrivate(object *gobject.Object) *EntryAccessiblePrivate {
	return EntryAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this EntryAccessiblePrivate with another EntryAccessiblePrivate, and returns true if they represent the same Object.
func (recv *EntryAccessiblePrivate) Equals(other *EntryAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *EntryAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// EntryAccessiblePrivateStruct creates an uninitialised EntryAccessiblePrivate.
func EntryAccessiblePrivateStruct() *EntryAccessiblePrivate {
	err := entryAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EntryAccessiblePrivateNewFromNative(entryAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEntryAccessiblePrivate)
	return structGo
}
func finalizeEntryAccessiblePrivate(obj *EntryAccessiblePrivate) {
	entryAccessiblePrivateStruct.Free(obj.Native())
}

var entryBufferClassStruct *gi.Struct
var entryBufferClassStruct_Once sync.Once

func entryBufferClassStruct_Set() error {
	var err error
	entryBufferClassStruct_Once.Do(func() {
		entryBufferClassStruct, err = gi.StructNew("Gtk", "EntryBufferClass")
	})
	return err
}

type EntryBufferClass struct {
	native unsafe.Pointer
}

func EntryBufferClassNewFromNative(native unsafe.Pointer) *EntryBufferClass {
	err := entryBufferClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EntryBufferClass{native: native}

	return instance
}

/*
CastToEntryBufferClass down casts any arbitrary Object to EntryBufferClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EntryBufferClass.
*/
func CastToEntryBufferClass(object *gobject.Object) *EntryBufferClass {
	return EntryBufferClassNewFromNative(object.Native())
}

// Equals compares this EntryBufferClass with another EntryBufferClass, and returns true if they represent the same Object.
func (recv *EntryBufferClass) Equals(other *EntryBufferClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EntryBufferClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *EntryBufferClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(entryBufferClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *EntryBufferClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(entryBufferClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'inserted_text' : for field getter : missing Type

// UNSUPPORTED : C value 'inserted_text' : for field setter : missing Type

// UNSUPPORTED : C value 'deleted_text' : for field getter : missing Type

// UNSUPPORTED : C value 'deleted_text' : for field setter : missing Type

// UNSUPPORTED : C value 'get_text' : for field getter : missing Type

// UNSUPPORTED : C value 'get_text' : for field setter : missing Type

// UNSUPPORTED : C value 'get_length' : for field getter : missing Type

// UNSUPPORTED : C value 'get_length' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_text' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_text' : for field setter : missing Type

// UNSUPPORTED : C value 'delete_text' : for field getter : missing Type

// UNSUPPORTED : C value 'delete_text' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// EntryBufferClassStruct creates an uninitialised EntryBufferClass.
func EntryBufferClassStruct() *EntryBufferClass {
	err := entryBufferClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EntryBufferClassNewFromNative(entryBufferClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEntryBufferClass)
	return structGo
}
func finalizeEntryBufferClass(obj *EntryBufferClass) {
	entryBufferClassStruct.Free(obj.Native())
}

var entryBufferPrivateStruct *gi.Struct
var entryBufferPrivateStruct_Once sync.Once

func entryBufferPrivateStruct_Set() error {
	var err error
	entryBufferPrivateStruct_Once.Do(func() {
		entryBufferPrivateStruct, err = gi.StructNew("Gtk", "EntryBufferPrivate")
	})
	return err
}

type EntryBufferPrivate struct {
	native unsafe.Pointer
}

func EntryBufferPrivateNewFromNative(native unsafe.Pointer) *EntryBufferPrivate {
	err := entryBufferPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EntryBufferPrivate{native: native}

	return instance
}

/*
CastToEntryBufferPrivate down casts any arbitrary Object to EntryBufferPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a EntryBufferPrivate.
*/
func CastToEntryBufferPrivate(object *gobject.Object) *EntryBufferPrivate {
	return EntryBufferPrivateNewFromNative(object.Native())
}

// Equals compares this EntryBufferPrivate with another EntryBufferPrivate, and returns true if they represent the same Object.
func (recv *EntryBufferPrivate) Equals(other *EntryBufferPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *EntryBufferPrivate) Native() unsafe.Pointer {
	return recv.native
}

// EntryBufferPrivateStruct creates an uninitialised EntryBufferPrivate.
func EntryBufferPrivateStruct() *EntryBufferPrivate {
	err := entryBufferPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EntryBufferPrivateNewFromNative(entryBufferPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEntryBufferPrivate)
	return structGo
}
func finalizeEntryBufferPrivate(obj *EntryBufferPrivate) {
	entryBufferPrivateStruct.Free(obj.Native())
}

var entryClassStruct *gi.Struct
var entryClassStruct_Once sync.Once

func entryClassStruct_Set() error {
	var err error
	entryClassStruct_Once.Do(func() {
		entryClassStruct, err = gi.StructNew("Gtk", "EntryClass")
	})
	return err
}

type EntryClass struct {
	native unsafe.Pointer
}

func EntryClassNewFromNative(native unsafe.Pointer) *EntryClass {
	err := entryClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EntryClass{native: native}

	return instance
}

/*
CastToEntryClass down casts any arbitrary Object to EntryClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EntryClass.
*/
func CastToEntryClass(object *gobject.Object) *EntryClass {
	return EntryClassNewFromNative(object.Native())
}

// Equals compares this EntryClass with another EntryClass, and returns true if they represent the same Object.
func (recv *EntryClass) Equals(other *EntryClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EntryClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *EntryClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(entryClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *EntryClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(entryClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'populate_popup' : for field getter : missing Type

// UNSUPPORTED : C value 'populate_popup' : for field setter : missing Type

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_at_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_at_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'delete_from_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'delete_from_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'backspace' : for field getter : missing Type

// UNSUPPORTED : C value 'backspace' : for field setter : missing Type

// UNSUPPORTED : C value 'cut_clipboard' : for field getter : missing Type

// UNSUPPORTED : C value 'cut_clipboard' : for field setter : missing Type

// UNSUPPORTED : C value 'copy_clipboard' : for field getter : missing Type

// UNSUPPORTED : C value 'copy_clipboard' : for field setter : missing Type

// UNSUPPORTED : C value 'paste_clipboard' : for field getter : missing Type

// UNSUPPORTED : C value 'paste_clipboard' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_overwrite' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_overwrite' : for field setter : missing Type

// UNSUPPORTED : C value 'get_text_area_size' : for field getter : missing Type

// UNSUPPORTED : C value 'get_text_area_size' : for field setter : missing Type

// UNSUPPORTED : C value 'get_frame_size' : for field getter : missing Type

// UNSUPPORTED : C value 'get_frame_size' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_emoji' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_emoji' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// EntryClassStruct creates an uninitialised EntryClass.
func EntryClassStruct() *EntryClass {
	err := entryClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EntryClassNewFromNative(entryClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEntryClass)
	return structGo
}
func finalizeEntryClass(obj *EntryClass) {
	entryClassStruct.Free(obj.Native())
}

var entryCompletionClassStruct *gi.Struct
var entryCompletionClassStruct_Once sync.Once

func entryCompletionClassStruct_Set() error {
	var err error
	entryCompletionClassStruct_Once.Do(func() {
		entryCompletionClassStruct, err = gi.StructNew("Gtk", "EntryCompletionClass")
	})
	return err
}

type EntryCompletionClass struct {
	native unsafe.Pointer
}

func EntryCompletionClassNewFromNative(native unsafe.Pointer) *EntryCompletionClass {
	err := entryCompletionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EntryCompletionClass{native: native}

	return instance
}

/*
CastToEntryCompletionClass down casts any arbitrary Object to EntryCompletionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EntryCompletionClass.
*/
func CastToEntryCompletionClass(object *gobject.Object) *EntryCompletionClass {
	return EntryCompletionClassNewFromNative(object.Native())
}

// Equals compares this EntryCompletionClass with another EntryCompletionClass, and returns true if they represent the same Object.
func (recv *EntryCompletionClass) Equals(other *EntryCompletionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EntryCompletionClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *EntryCompletionClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(entryCompletionClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *EntryCompletionClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(entryCompletionClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'match_selected' : for field getter : missing Type

// UNSUPPORTED : C value 'match_selected' : for field setter : missing Type

// UNSUPPORTED : C value 'action_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'action_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_prefix' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_prefix' : for field setter : missing Type

// UNSUPPORTED : C value 'cursor_on_match' : for field getter : missing Type

// UNSUPPORTED : C value 'cursor_on_match' : for field setter : missing Type

// UNSUPPORTED : C value 'no_matches' : for field getter : missing Type

// UNSUPPORTED : C value 'no_matches' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved0' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved0' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// EntryCompletionClassStruct creates an uninitialised EntryCompletionClass.
func EntryCompletionClassStruct() *EntryCompletionClass {
	err := entryCompletionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EntryCompletionClassNewFromNative(entryCompletionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEntryCompletionClass)
	return structGo
}
func finalizeEntryCompletionClass(obj *EntryCompletionClass) {
	entryCompletionClassStruct.Free(obj.Native())
}

var entryCompletionPrivateStruct *gi.Struct
var entryCompletionPrivateStruct_Once sync.Once

func entryCompletionPrivateStruct_Set() error {
	var err error
	entryCompletionPrivateStruct_Once.Do(func() {
		entryCompletionPrivateStruct, err = gi.StructNew("Gtk", "EntryCompletionPrivate")
	})
	return err
}

type EntryCompletionPrivate struct {
	native unsafe.Pointer
}

func EntryCompletionPrivateNewFromNative(native unsafe.Pointer) *EntryCompletionPrivate {
	err := entryCompletionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EntryCompletionPrivate{native: native}

	return instance
}

/*
CastToEntryCompletionPrivate down casts any arbitrary Object to EntryCompletionPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a EntryCompletionPrivate.
*/
func CastToEntryCompletionPrivate(object *gobject.Object) *EntryCompletionPrivate {
	return EntryCompletionPrivateNewFromNative(object.Native())
}

// Equals compares this EntryCompletionPrivate with another EntryCompletionPrivate, and returns true if they represent the same Object.
func (recv *EntryCompletionPrivate) Equals(other *EntryCompletionPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *EntryCompletionPrivate) Native() unsafe.Pointer {
	return recv.native
}

// EntryCompletionPrivateStruct creates an uninitialised EntryCompletionPrivate.
func EntryCompletionPrivateStruct() *EntryCompletionPrivate {
	err := entryCompletionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EntryCompletionPrivateNewFromNative(entryCompletionPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEntryCompletionPrivate)
	return structGo
}
func finalizeEntryCompletionPrivate(obj *EntryCompletionPrivate) {
	entryCompletionPrivateStruct.Free(obj.Native())
}

var entryPrivateStruct *gi.Struct
var entryPrivateStruct_Once sync.Once

func entryPrivateStruct_Set() error {
	var err error
	entryPrivateStruct_Once.Do(func() {
		entryPrivateStruct, err = gi.StructNew("Gtk", "EntryPrivate")
	})
	return err
}

type EntryPrivate struct {
	native unsafe.Pointer
}

func EntryPrivateNewFromNative(native unsafe.Pointer) *EntryPrivate {
	err := entryPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EntryPrivate{native: native}

	return instance
}

/*
CastToEntryPrivate down casts any arbitrary Object to EntryPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a EntryPrivate.
*/
func CastToEntryPrivate(object *gobject.Object) *EntryPrivate {
	return EntryPrivateNewFromNative(object.Native())
}

// Equals compares this EntryPrivate with another EntryPrivate, and returns true if they represent the same Object.
func (recv *EntryPrivate) Equals(other *EntryPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *EntryPrivate) Native() unsafe.Pointer {
	return recv.native
}

// EntryPrivateStruct creates an uninitialised EntryPrivate.
func EntryPrivateStruct() *EntryPrivate {
	err := entryPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EntryPrivateNewFromNative(entryPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEntryPrivate)
	return structGo
}
func finalizeEntryPrivate(obj *EntryPrivate) {
	entryPrivateStruct.Free(obj.Native())
}

var eventBoxClassStruct *gi.Struct
var eventBoxClassStruct_Once sync.Once

func eventBoxClassStruct_Set() error {
	var err error
	eventBoxClassStruct_Once.Do(func() {
		eventBoxClassStruct, err = gi.StructNew("Gtk", "EventBoxClass")
	})
	return err
}

type EventBoxClass struct {
	native unsafe.Pointer
}

func EventBoxClassNewFromNative(native unsafe.Pointer) *EventBoxClass {
	err := eventBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EventBoxClass{native: native}

	return instance
}

/*
CastToEventBoxClass down casts any arbitrary Object to EventBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EventBoxClass.
*/
func CastToEventBoxClass(object *gobject.Object) *EventBoxClass {
	return EventBoxClassNewFromNative(object.Native())
}

// Equals compares this EventBoxClass with another EventBoxClass, and returns true if they represent the same Object.
func (recv *EventBoxClass) Equals(other *EventBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EventBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *EventBoxClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(eventBoxClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *EventBoxClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(eventBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// EventBoxClassStruct creates an uninitialised EventBoxClass.
func EventBoxClassStruct() *EventBoxClass {
	err := eventBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EventBoxClassNewFromNative(eventBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEventBoxClass)
	return structGo
}
func finalizeEventBoxClass(obj *EventBoxClass) {
	eventBoxClassStruct.Free(obj.Native())
}

var eventBoxPrivateStruct *gi.Struct
var eventBoxPrivateStruct_Once sync.Once

func eventBoxPrivateStruct_Set() error {
	var err error
	eventBoxPrivateStruct_Once.Do(func() {
		eventBoxPrivateStruct, err = gi.StructNew("Gtk", "EventBoxPrivate")
	})
	return err
}

type EventBoxPrivate struct {
	native unsafe.Pointer
}

func EventBoxPrivateNewFromNative(native unsafe.Pointer) *EventBoxPrivate {
	err := eventBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EventBoxPrivate{native: native}

	return instance
}

/*
CastToEventBoxPrivate down casts any arbitrary Object to EventBoxPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a EventBoxPrivate.
*/
func CastToEventBoxPrivate(object *gobject.Object) *EventBoxPrivate {
	return EventBoxPrivateNewFromNative(object.Native())
}

// Equals compares this EventBoxPrivate with another EventBoxPrivate, and returns true if they represent the same Object.
func (recv *EventBoxPrivate) Equals(other *EventBoxPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *EventBoxPrivate) Native() unsafe.Pointer {
	return recv.native
}

// EventBoxPrivateStruct creates an uninitialised EventBoxPrivate.
func EventBoxPrivateStruct() *EventBoxPrivate {
	err := eventBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EventBoxPrivateNewFromNative(eventBoxPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEventBoxPrivate)
	return structGo
}
func finalizeEventBoxPrivate(obj *EventBoxPrivate) {
	eventBoxPrivateStruct.Free(obj.Native())
}

var eventControllerClassStruct *gi.Struct
var eventControllerClassStruct_Once sync.Once

func eventControllerClassStruct_Set() error {
	var err error
	eventControllerClassStruct_Once.Do(func() {
		eventControllerClassStruct, err = gi.StructNew("Gtk", "EventControllerClass")
	})
	return err
}

type EventControllerClass struct {
	native unsafe.Pointer
}

func EventControllerClassNewFromNative(native unsafe.Pointer) *EventControllerClass {
	err := eventControllerClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EventControllerClass{native: native}

	return instance
}

/*
CastToEventControllerClass down casts any arbitrary Object to EventControllerClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EventControllerClass.
*/
func CastToEventControllerClass(object *gobject.Object) *EventControllerClass {
	return EventControllerClassNewFromNative(object.Native())
}

// Equals compares this EventControllerClass with another EventControllerClass, and returns true if they represent the same Object.
func (recv *EventControllerClass) Equals(other *EventControllerClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EventControllerClass) Native() unsafe.Pointer {
	return recv.native
}

// EventControllerClassStruct creates an uninitialised EventControllerClass.
func EventControllerClassStruct() *EventControllerClass {
	err := eventControllerClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EventControllerClassNewFromNative(eventControllerClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEventControllerClass)
	return structGo
}
func finalizeEventControllerClass(obj *EventControllerClass) {
	eventControllerClassStruct.Free(obj.Native())
}

var eventControllerKeyClassStruct *gi.Struct
var eventControllerKeyClassStruct_Once sync.Once

func eventControllerKeyClassStruct_Set() error {
	var err error
	eventControllerKeyClassStruct_Once.Do(func() {
		eventControllerKeyClassStruct, err = gi.StructNew("Gtk", "EventControllerKeyClass")
	})
	return err
}

type EventControllerKeyClass struct {
	native unsafe.Pointer
}

func EventControllerKeyClassNewFromNative(native unsafe.Pointer) *EventControllerKeyClass {
	err := eventControllerKeyClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EventControllerKeyClass{native: native}

	return instance
}

/*
CastToEventControllerKeyClass down casts any arbitrary Object to EventControllerKeyClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EventControllerKeyClass.
*/
func CastToEventControllerKeyClass(object *gobject.Object) *EventControllerKeyClass {
	return EventControllerKeyClassNewFromNative(object.Native())
}

// Equals compares this EventControllerKeyClass with another EventControllerKeyClass, and returns true if they represent the same Object.
func (recv *EventControllerKeyClass) Equals(other *EventControllerKeyClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EventControllerKeyClass) Native() unsafe.Pointer {
	return recv.native
}

// EventControllerKeyClassStruct creates an uninitialised EventControllerKeyClass.
func EventControllerKeyClassStruct() *EventControllerKeyClass {
	err := eventControllerKeyClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EventControllerKeyClassNewFromNative(eventControllerKeyClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEventControllerKeyClass)
	return structGo
}
func finalizeEventControllerKeyClass(obj *EventControllerKeyClass) {
	eventControllerKeyClassStruct.Free(obj.Native())
}

var eventControllerMotionClassStruct *gi.Struct
var eventControllerMotionClassStruct_Once sync.Once

func eventControllerMotionClassStruct_Set() error {
	var err error
	eventControllerMotionClassStruct_Once.Do(func() {
		eventControllerMotionClassStruct, err = gi.StructNew("Gtk", "EventControllerMotionClass")
	})
	return err
}

type EventControllerMotionClass struct {
	native unsafe.Pointer
}

func EventControllerMotionClassNewFromNative(native unsafe.Pointer) *EventControllerMotionClass {
	err := eventControllerMotionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EventControllerMotionClass{native: native}

	return instance
}

/*
CastToEventControllerMotionClass down casts any arbitrary Object to EventControllerMotionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EventControllerMotionClass.
*/
func CastToEventControllerMotionClass(object *gobject.Object) *EventControllerMotionClass {
	return EventControllerMotionClassNewFromNative(object.Native())
}

// Equals compares this EventControllerMotionClass with another EventControllerMotionClass, and returns true if they represent the same Object.
func (recv *EventControllerMotionClass) Equals(other *EventControllerMotionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EventControllerMotionClass) Native() unsafe.Pointer {
	return recv.native
}

// EventControllerMotionClassStruct creates an uninitialised EventControllerMotionClass.
func EventControllerMotionClassStruct() *EventControllerMotionClass {
	err := eventControllerMotionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EventControllerMotionClassNewFromNative(eventControllerMotionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEventControllerMotionClass)
	return structGo
}
func finalizeEventControllerMotionClass(obj *EventControllerMotionClass) {
	eventControllerMotionClassStruct.Free(obj.Native())
}

var eventControllerScrollClassStruct *gi.Struct
var eventControllerScrollClassStruct_Once sync.Once

func eventControllerScrollClassStruct_Set() error {
	var err error
	eventControllerScrollClassStruct_Once.Do(func() {
		eventControllerScrollClassStruct, err = gi.StructNew("Gtk", "EventControllerScrollClass")
	})
	return err
}

type EventControllerScrollClass struct {
	native unsafe.Pointer
}

func EventControllerScrollClassNewFromNative(native unsafe.Pointer) *EventControllerScrollClass {
	err := eventControllerScrollClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &EventControllerScrollClass{native: native}

	return instance
}

/*
CastToEventControllerScrollClass down casts any arbitrary Object to EventControllerScrollClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a EventControllerScrollClass.
*/
func CastToEventControllerScrollClass(object *gobject.Object) *EventControllerScrollClass {
	return EventControllerScrollClassNewFromNative(object.Native())
}

// Equals compares this EventControllerScrollClass with another EventControllerScrollClass, and returns true if they represent the same Object.
func (recv *EventControllerScrollClass) Equals(other *EventControllerScrollClass) bool {
	return other.Native() == recv.Native()
}

func (recv *EventControllerScrollClass) Native() unsafe.Pointer {
	return recv.native
}

// EventControllerScrollClassStruct creates an uninitialised EventControllerScrollClass.
func EventControllerScrollClassStruct() *EventControllerScrollClass {
	err := eventControllerScrollClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := EventControllerScrollClassNewFromNative(eventControllerScrollClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeEventControllerScrollClass)
	return structGo
}
func finalizeEventControllerScrollClass(obj *EventControllerScrollClass) {
	eventControllerScrollClassStruct.Free(obj.Native())
}

var expanderAccessibleClassStruct *gi.Struct
var expanderAccessibleClassStruct_Once sync.Once

func expanderAccessibleClassStruct_Set() error {
	var err error
	expanderAccessibleClassStruct_Once.Do(func() {
		expanderAccessibleClassStruct, err = gi.StructNew("Gtk", "ExpanderAccessibleClass")
	})
	return err
}

type ExpanderAccessibleClass struct {
	native unsafe.Pointer
}

func ExpanderAccessibleClassNewFromNative(native unsafe.Pointer) *ExpanderAccessibleClass {
	err := expanderAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ExpanderAccessibleClass{native: native}

	return instance
}

/*
CastToExpanderAccessibleClass down casts any arbitrary Object to ExpanderAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ExpanderAccessibleClass.
*/
func CastToExpanderAccessibleClass(object *gobject.Object) *ExpanderAccessibleClass {
	return ExpanderAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ExpanderAccessibleClass with another ExpanderAccessibleClass, and returns true if they represent the same Object.
func (recv *ExpanderAccessibleClass) Equals(other *ExpanderAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ExpanderAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ExpanderAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(expanderAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ExpanderAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(expanderAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ExpanderAccessibleClassStruct creates an uninitialised ExpanderAccessibleClass.
func ExpanderAccessibleClassStruct() *ExpanderAccessibleClass {
	err := expanderAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ExpanderAccessibleClassNewFromNative(expanderAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeExpanderAccessibleClass)
	return structGo
}
func finalizeExpanderAccessibleClass(obj *ExpanderAccessibleClass) {
	expanderAccessibleClassStruct.Free(obj.Native())
}

var expanderAccessiblePrivateStruct *gi.Struct
var expanderAccessiblePrivateStruct_Once sync.Once

func expanderAccessiblePrivateStruct_Set() error {
	var err error
	expanderAccessiblePrivateStruct_Once.Do(func() {
		expanderAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ExpanderAccessiblePrivate")
	})
	return err
}

type ExpanderAccessiblePrivate struct {
	native unsafe.Pointer
}

func ExpanderAccessiblePrivateNewFromNative(native unsafe.Pointer) *ExpanderAccessiblePrivate {
	err := expanderAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ExpanderAccessiblePrivate{native: native}

	return instance
}

/*
CastToExpanderAccessiblePrivate down casts any arbitrary Object to ExpanderAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ExpanderAccessiblePrivate.
*/
func CastToExpanderAccessiblePrivate(object *gobject.Object) *ExpanderAccessiblePrivate {
	return ExpanderAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ExpanderAccessiblePrivate with another ExpanderAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ExpanderAccessiblePrivate) Equals(other *ExpanderAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ExpanderAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ExpanderAccessiblePrivateStruct creates an uninitialised ExpanderAccessiblePrivate.
func ExpanderAccessiblePrivateStruct() *ExpanderAccessiblePrivate {
	err := expanderAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ExpanderAccessiblePrivateNewFromNative(expanderAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeExpanderAccessiblePrivate)
	return structGo
}
func finalizeExpanderAccessiblePrivate(obj *ExpanderAccessiblePrivate) {
	expanderAccessiblePrivateStruct.Free(obj.Native())
}

var expanderClassStruct *gi.Struct
var expanderClassStruct_Once sync.Once

func expanderClassStruct_Set() error {
	var err error
	expanderClassStruct_Once.Do(func() {
		expanderClassStruct, err = gi.StructNew("Gtk", "ExpanderClass")
	})
	return err
}

type ExpanderClass struct {
	native unsafe.Pointer
}

func ExpanderClassNewFromNative(native unsafe.Pointer) *ExpanderClass {
	err := expanderClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ExpanderClass{native: native}

	return instance
}

/*
CastToExpanderClass down casts any arbitrary Object to ExpanderClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ExpanderClass.
*/
func CastToExpanderClass(object *gobject.Object) *ExpanderClass {
	return ExpanderClassNewFromNative(object.Native())
}

// Equals compares this ExpanderClass with another ExpanderClass, and returns true if they represent the same Object.
func (recv *ExpanderClass) Equals(other *ExpanderClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ExpanderClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ExpanderClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(expanderClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ExpanderClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(expanderClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ExpanderClassStruct creates an uninitialised ExpanderClass.
func ExpanderClassStruct() *ExpanderClass {
	err := expanderClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ExpanderClassNewFromNative(expanderClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeExpanderClass)
	return structGo
}
func finalizeExpanderClass(obj *ExpanderClass) {
	expanderClassStruct.Free(obj.Native())
}

var expanderPrivateStruct *gi.Struct
var expanderPrivateStruct_Once sync.Once

func expanderPrivateStruct_Set() error {
	var err error
	expanderPrivateStruct_Once.Do(func() {
		expanderPrivateStruct, err = gi.StructNew("Gtk", "ExpanderPrivate")
	})
	return err
}

type ExpanderPrivate struct {
	native unsafe.Pointer
}

func ExpanderPrivateNewFromNative(native unsafe.Pointer) *ExpanderPrivate {
	err := expanderPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ExpanderPrivate{native: native}

	return instance
}

/*
CastToExpanderPrivate down casts any arbitrary Object to ExpanderPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ExpanderPrivate.
*/
func CastToExpanderPrivate(object *gobject.Object) *ExpanderPrivate {
	return ExpanderPrivateNewFromNative(object.Native())
}

// Equals compares this ExpanderPrivate with another ExpanderPrivate, and returns true if they represent the same Object.
func (recv *ExpanderPrivate) Equals(other *ExpanderPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ExpanderPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ExpanderPrivateStruct creates an uninitialised ExpanderPrivate.
func ExpanderPrivateStruct() *ExpanderPrivate {
	err := expanderPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ExpanderPrivateNewFromNative(expanderPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeExpanderPrivate)
	return structGo
}
func finalizeExpanderPrivate(obj *ExpanderPrivate) {
	expanderPrivateStruct.Free(obj.Native())
}

var fileChooserButtonClassStruct *gi.Struct
var fileChooserButtonClassStruct_Once sync.Once

func fileChooserButtonClassStruct_Set() error {
	var err error
	fileChooserButtonClassStruct_Once.Do(func() {
		fileChooserButtonClassStruct, err = gi.StructNew("Gtk", "FileChooserButtonClass")
	})
	return err
}

type FileChooserButtonClass struct {
	native unsafe.Pointer
}

func FileChooserButtonClassNewFromNative(native unsafe.Pointer) *FileChooserButtonClass {
	err := fileChooserButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FileChooserButtonClass{native: native}

	return instance
}

/*
CastToFileChooserButtonClass down casts any arbitrary Object to FileChooserButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FileChooserButtonClass.
*/
func CastToFileChooserButtonClass(object *gobject.Object) *FileChooserButtonClass {
	return FileChooserButtonClassNewFromNative(object.Native())
}

// Equals compares this FileChooserButtonClass with another FileChooserButtonClass, and returns true if they represent the same Object.
func (recv *FileChooserButtonClass) Equals(other *FileChooserButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FileChooserButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FileChooserButtonClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(fileChooserButtonClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FileChooserButtonClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fileChooserButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'file_set' : for field getter : missing Type

// UNSUPPORTED : C value 'file_set' : for field setter : missing Type

// UNSUPPORTED : C value '__gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '__gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '__gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '__gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '__gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '__gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '__gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '__gtk_reserved4' : for field setter : missing Type

// FileChooserButtonClassStruct creates an uninitialised FileChooserButtonClass.
func FileChooserButtonClassStruct() *FileChooserButtonClass {
	err := fileChooserButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FileChooserButtonClassNewFromNative(fileChooserButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFileChooserButtonClass)
	return structGo
}
func finalizeFileChooserButtonClass(obj *FileChooserButtonClass) {
	fileChooserButtonClassStruct.Free(obj.Native())
}

var fileChooserButtonPrivateStruct *gi.Struct
var fileChooserButtonPrivateStruct_Once sync.Once

func fileChooserButtonPrivateStruct_Set() error {
	var err error
	fileChooserButtonPrivateStruct_Once.Do(func() {
		fileChooserButtonPrivateStruct, err = gi.StructNew("Gtk", "FileChooserButtonPrivate")
	})
	return err
}

type FileChooserButtonPrivate struct {
	native unsafe.Pointer
}

func FileChooserButtonPrivateNewFromNative(native unsafe.Pointer) *FileChooserButtonPrivate {
	err := fileChooserButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FileChooserButtonPrivate{native: native}

	return instance
}

/*
CastToFileChooserButtonPrivate down casts any arbitrary Object to FileChooserButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FileChooserButtonPrivate.
*/
func CastToFileChooserButtonPrivate(object *gobject.Object) *FileChooserButtonPrivate {
	return FileChooserButtonPrivateNewFromNative(object.Native())
}

// Equals compares this FileChooserButtonPrivate with another FileChooserButtonPrivate, and returns true if they represent the same Object.
func (recv *FileChooserButtonPrivate) Equals(other *FileChooserButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FileChooserButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FileChooserButtonPrivateStruct creates an uninitialised FileChooserButtonPrivate.
func FileChooserButtonPrivateStruct() *FileChooserButtonPrivate {
	err := fileChooserButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FileChooserButtonPrivateNewFromNative(fileChooserButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFileChooserButtonPrivate)
	return structGo
}
func finalizeFileChooserButtonPrivate(obj *FileChooserButtonPrivate) {
	fileChooserButtonPrivateStruct.Free(obj.Native())
}

var fileChooserDialogClassStruct *gi.Struct
var fileChooserDialogClassStruct_Once sync.Once

func fileChooserDialogClassStruct_Set() error {
	var err error
	fileChooserDialogClassStruct_Once.Do(func() {
		fileChooserDialogClassStruct, err = gi.StructNew("Gtk", "FileChooserDialogClass")
	})
	return err
}

type FileChooserDialogClass struct {
	native unsafe.Pointer
}

func FileChooserDialogClassNewFromNative(native unsafe.Pointer) *FileChooserDialogClass {
	err := fileChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FileChooserDialogClass{native: native}

	return instance
}

/*
CastToFileChooserDialogClass down casts any arbitrary Object to FileChooserDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FileChooserDialogClass.
*/
func CastToFileChooserDialogClass(object *gobject.Object) *FileChooserDialogClass {
	return FileChooserDialogClassNewFromNative(object.Native())
}

// Equals compares this FileChooserDialogClass with another FileChooserDialogClass, and returns true if they represent the same Object.
func (recv *FileChooserDialogClass) Equals(other *FileChooserDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FileChooserDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FileChooserDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(fileChooserDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FileChooserDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fileChooserDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// FileChooserDialogClassStruct creates an uninitialised FileChooserDialogClass.
func FileChooserDialogClassStruct() *FileChooserDialogClass {
	err := fileChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FileChooserDialogClassNewFromNative(fileChooserDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFileChooserDialogClass)
	return structGo
}
func finalizeFileChooserDialogClass(obj *FileChooserDialogClass) {
	fileChooserDialogClassStruct.Free(obj.Native())
}

var fileChooserDialogPrivateStruct *gi.Struct
var fileChooserDialogPrivateStruct_Once sync.Once

func fileChooserDialogPrivateStruct_Set() error {
	var err error
	fileChooserDialogPrivateStruct_Once.Do(func() {
		fileChooserDialogPrivateStruct, err = gi.StructNew("Gtk", "FileChooserDialogPrivate")
	})
	return err
}

type FileChooserDialogPrivate struct {
	native unsafe.Pointer
}

func FileChooserDialogPrivateNewFromNative(native unsafe.Pointer) *FileChooserDialogPrivate {
	err := fileChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FileChooserDialogPrivate{native: native}

	return instance
}

/*
CastToFileChooserDialogPrivate down casts any arbitrary Object to FileChooserDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FileChooserDialogPrivate.
*/
func CastToFileChooserDialogPrivate(object *gobject.Object) *FileChooserDialogPrivate {
	return FileChooserDialogPrivateNewFromNative(object.Native())
}

// Equals compares this FileChooserDialogPrivate with another FileChooserDialogPrivate, and returns true if they represent the same Object.
func (recv *FileChooserDialogPrivate) Equals(other *FileChooserDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FileChooserDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FileChooserDialogPrivateStruct creates an uninitialised FileChooserDialogPrivate.
func FileChooserDialogPrivateStruct() *FileChooserDialogPrivate {
	err := fileChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FileChooserDialogPrivateNewFromNative(fileChooserDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFileChooserDialogPrivate)
	return structGo
}
func finalizeFileChooserDialogPrivate(obj *FileChooserDialogPrivate) {
	fileChooserDialogPrivateStruct.Free(obj.Native())
}

var fileChooserNativeClassStruct *gi.Struct
var fileChooserNativeClassStruct_Once sync.Once

func fileChooserNativeClassStruct_Set() error {
	var err error
	fileChooserNativeClassStruct_Once.Do(func() {
		fileChooserNativeClassStruct, err = gi.StructNew("Gtk", "FileChooserNativeClass")
	})
	return err
}

type FileChooserNativeClass struct {
	native unsafe.Pointer
}

func FileChooserNativeClassNewFromNative(native unsafe.Pointer) *FileChooserNativeClass {
	err := fileChooserNativeClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FileChooserNativeClass{native: native}

	return instance
}

/*
CastToFileChooserNativeClass down casts any arbitrary Object to FileChooserNativeClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FileChooserNativeClass.
*/
func CastToFileChooserNativeClass(object *gobject.Object) *FileChooserNativeClass {
	return FileChooserNativeClassNewFromNative(object.Native())
}

// Equals compares this FileChooserNativeClass with another FileChooserNativeClass, and returns true if they represent the same Object.
func (recv *FileChooserNativeClass) Equals(other *FileChooserNativeClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FileChooserNativeClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FileChooserNativeClass) FieldParentClass() *NativeDialogClass {
	argValue := gi.StructFieldGet(fileChooserNativeClassStruct, recv.Native(), "parent_class")
	value := NativeDialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FileChooserNativeClass) SetFieldParentClass(value *NativeDialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fileChooserNativeClassStruct, recv.Native(), "parent_class", argValue)
}

// FileChooserNativeClassStruct creates an uninitialised FileChooserNativeClass.
func FileChooserNativeClassStruct() *FileChooserNativeClass {
	err := fileChooserNativeClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FileChooserNativeClassNewFromNative(fileChooserNativeClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFileChooserNativeClass)
	return structGo
}
func finalizeFileChooserNativeClass(obj *FileChooserNativeClass) {
	fileChooserNativeClassStruct.Free(obj.Native())
}

var fileChooserWidgetClassStruct *gi.Struct
var fileChooserWidgetClassStruct_Once sync.Once

func fileChooserWidgetClassStruct_Set() error {
	var err error
	fileChooserWidgetClassStruct_Once.Do(func() {
		fileChooserWidgetClassStruct, err = gi.StructNew("Gtk", "FileChooserWidgetClass")
	})
	return err
}

type FileChooserWidgetClass struct {
	native unsafe.Pointer
}

func FileChooserWidgetClassNewFromNative(native unsafe.Pointer) *FileChooserWidgetClass {
	err := fileChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FileChooserWidgetClass{native: native}

	return instance
}

/*
CastToFileChooserWidgetClass down casts any arbitrary Object to FileChooserWidgetClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FileChooserWidgetClass.
*/
func CastToFileChooserWidgetClass(object *gobject.Object) *FileChooserWidgetClass {
	return FileChooserWidgetClassNewFromNative(object.Native())
}

// Equals compares this FileChooserWidgetClass with another FileChooserWidgetClass, and returns true if they represent the same Object.
func (recv *FileChooserWidgetClass) Equals(other *FileChooserWidgetClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FileChooserWidgetClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FileChooserWidgetClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(fileChooserWidgetClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FileChooserWidgetClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fileChooserWidgetClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// FileChooserWidgetClassStruct creates an uninitialised FileChooserWidgetClass.
func FileChooserWidgetClassStruct() *FileChooserWidgetClass {
	err := fileChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FileChooserWidgetClassNewFromNative(fileChooserWidgetClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFileChooserWidgetClass)
	return structGo
}
func finalizeFileChooserWidgetClass(obj *FileChooserWidgetClass) {
	fileChooserWidgetClassStruct.Free(obj.Native())
}

var fileChooserWidgetPrivateStruct *gi.Struct
var fileChooserWidgetPrivateStruct_Once sync.Once

func fileChooserWidgetPrivateStruct_Set() error {
	var err error
	fileChooserWidgetPrivateStruct_Once.Do(func() {
		fileChooserWidgetPrivateStruct, err = gi.StructNew("Gtk", "FileChooserWidgetPrivate")
	})
	return err
}

type FileChooserWidgetPrivate struct {
	native unsafe.Pointer
}

func FileChooserWidgetPrivateNewFromNative(native unsafe.Pointer) *FileChooserWidgetPrivate {
	err := fileChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FileChooserWidgetPrivate{native: native}

	return instance
}

/*
CastToFileChooserWidgetPrivate down casts any arbitrary Object to FileChooserWidgetPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FileChooserWidgetPrivate.
*/
func CastToFileChooserWidgetPrivate(object *gobject.Object) *FileChooserWidgetPrivate {
	return FileChooserWidgetPrivateNewFromNative(object.Native())
}

// Equals compares this FileChooserWidgetPrivate with another FileChooserWidgetPrivate, and returns true if they represent the same Object.
func (recv *FileChooserWidgetPrivate) Equals(other *FileChooserWidgetPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FileChooserWidgetPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FileChooserWidgetPrivateStruct creates an uninitialised FileChooserWidgetPrivate.
func FileChooserWidgetPrivateStruct() *FileChooserWidgetPrivate {
	err := fileChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FileChooserWidgetPrivateNewFromNative(fileChooserWidgetPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFileChooserWidgetPrivate)
	return structGo
}
func finalizeFileChooserWidgetPrivate(obj *FileChooserWidgetPrivate) {
	fileChooserWidgetPrivateStruct.Free(obj.Native())
}

var fileFilterInfoStruct *gi.Struct
var fileFilterInfoStruct_Once sync.Once

func fileFilterInfoStruct_Set() error {
	var err error
	fileFilterInfoStruct_Once.Do(func() {
		fileFilterInfoStruct, err = gi.StructNew("Gtk", "FileFilterInfo")
	})
	return err
}

type FileFilterInfo struct {
	native unsafe.Pointer
}

func FileFilterInfoNewFromNative(native unsafe.Pointer) *FileFilterInfo {
	err := fileFilterInfoStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FileFilterInfo{native: native}

	return instance
}

/*
CastToFileFilterInfo down casts any arbitrary Object to FileFilterInfo.
Exercise care, as this is a potentially dangerous function
if the Object is not a FileFilterInfo.
*/
func CastToFileFilterInfo(object *gobject.Object) *FileFilterInfo {
	return FileFilterInfoNewFromNative(object.Native())
}

// Equals compares this FileFilterInfo with another FileFilterInfo, and returns true if they represent the same Object.
func (recv *FileFilterInfo) Equals(other *FileFilterInfo) bool {
	return other.Native() == recv.Native()
}

func (recv *FileFilterInfo) Native() unsafe.Pointer {
	return recv.native
}

// FieldContains returns the C field 'contains'.
func (recv *FileFilterInfo) FieldContains() FileFilterFlags {
	argValue := gi.StructFieldGet(fileFilterInfoStruct, recv.Native(), "contains")
	value := FileFilterFlags(argValue.Int32())
	return value
}

// SetFieldContains sets the value of the C field 'contains'.
func (recv *FileFilterInfo) SetFieldContains(value FileFilterFlags) {
	var argValue gi.Argument
	argValue.SetInt32(int32(value))
	gi.StructFieldSet(fileFilterInfoStruct, recv.Native(), "contains", argValue)
}

// FieldFilename returns the C field 'filename'.
func (recv *FileFilterInfo) FieldFilename() string {
	argValue := gi.StructFieldGet(fileFilterInfoStruct, recv.Native(), "filename")
	value := argValue.String(false)
	return value
}

// SetFieldFilename sets the value of the C field 'filename'.
func (recv *FileFilterInfo) SetFieldFilename(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(fileFilterInfoStruct, recv.Native(), "filename", argValue)
}

// FieldUri returns the C field 'uri'.
func (recv *FileFilterInfo) FieldUri() string {
	argValue := gi.StructFieldGet(fileFilterInfoStruct, recv.Native(), "uri")
	value := argValue.String(false)
	return value
}

// SetFieldUri sets the value of the C field 'uri'.
func (recv *FileFilterInfo) SetFieldUri(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(fileFilterInfoStruct, recv.Native(), "uri", argValue)
}

// FieldDisplayName returns the C field 'display_name'.
func (recv *FileFilterInfo) FieldDisplayName() string {
	argValue := gi.StructFieldGet(fileFilterInfoStruct, recv.Native(), "display_name")
	value := argValue.String(false)
	return value
}

// SetFieldDisplayName sets the value of the C field 'display_name'.
func (recv *FileFilterInfo) SetFieldDisplayName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(fileFilterInfoStruct, recv.Native(), "display_name", argValue)
}

// FieldMimeType returns the C field 'mime_type'.
func (recv *FileFilterInfo) FieldMimeType() string {
	argValue := gi.StructFieldGet(fileFilterInfoStruct, recv.Native(), "mime_type")
	value := argValue.String(false)
	return value
}

// SetFieldMimeType sets the value of the C field 'mime_type'.
func (recv *FileFilterInfo) SetFieldMimeType(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(fileFilterInfoStruct, recv.Native(), "mime_type", argValue)
}

// FileFilterInfoStruct creates an uninitialised FileFilterInfo.
func FileFilterInfoStruct() *FileFilterInfo {
	err := fileFilterInfoStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FileFilterInfoNewFromNative(fileFilterInfoStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFileFilterInfo)
	return structGo
}
func finalizeFileFilterInfo(obj *FileFilterInfo) {
	fileFilterInfoStruct.Free(obj.Native())
}

var fixedChildStruct *gi.Struct
var fixedChildStruct_Once sync.Once

func fixedChildStruct_Set() error {
	var err error
	fixedChildStruct_Once.Do(func() {
		fixedChildStruct, err = gi.StructNew("Gtk", "FixedChild")
	})
	return err
}

type FixedChild struct {
	native unsafe.Pointer
}

func FixedChildNewFromNative(native unsafe.Pointer) *FixedChild {
	err := fixedChildStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FixedChild{native: native}

	return instance
}

/*
CastToFixedChild down casts any arbitrary Object to FixedChild.
Exercise care, as this is a potentially dangerous function
if the Object is not a FixedChild.
*/
func CastToFixedChild(object *gobject.Object) *FixedChild {
	return FixedChildNewFromNative(object.Native())
}

// Equals compares this FixedChild with another FixedChild, and returns true if they represent the same Object.
func (recv *FixedChild) Equals(other *FixedChild) bool {
	return other.Native() == recv.Native()
}

func (recv *FixedChild) Native() unsafe.Pointer {
	return recv.native
}

// FieldWidget returns the C field 'widget'.
func (recv *FixedChild) FieldWidget() *Widget {
	argValue := gi.StructFieldGet(fixedChildStruct, recv.Native(), "widget")
	value := WidgetNewFromNative(argValue.Pointer())
	return value
}

// SetFieldWidget sets the value of the C field 'widget'.
func (recv *FixedChild) SetFieldWidget(value *Widget) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fixedChildStruct, recv.Native(), "widget", argValue)
}

// FieldX returns the C field 'x'.
func (recv *FixedChild) FieldX() int32 {
	argValue := gi.StructFieldGet(fixedChildStruct, recv.Native(), "x")
	value := argValue.Int32()
	return value
}

// SetFieldX sets the value of the C field 'x'.
func (recv *FixedChild) SetFieldX(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(fixedChildStruct, recv.Native(), "x", argValue)
}

// FieldY returns the C field 'y'.
func (recv *FixedChild) FieldY() int32 {
	argValue := gi.StructFieldGet(fixedChildStruct, recv.Native(), "y")
	value := argValue.Int32()
	return value
}

// SetFieldY sets the value of the C field 'y'.
func (recv *FixedChild) SetFieldY(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(fixedChildStruct, recv.Native(), "y", argValue)
}

// FixedChildStruct creates an uninitialised FixedChild.
func FixedChildStruct() *FixedChild {
	err := fixedChildStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FixedChildNewFromNative(fixedChildStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFixedChild)
	return structGo
}
func finalizeFixedChild(obj *FixedChild) {
	fixedChildStruct.Free(obj.Native())
}

var fixedClassStruct *gi.Struct
var fixedClassStruct_Once sync.Once

func fixedClassStruct_Set() error {
	var err error
	fixedClassStruct_Once.Do(func() {
		fixedClassStruct, err = gi.StructNew("Gtk", "FixedClass")
	})
	return err
}

type FixedClass struct {
	native unsafe.Pointer
}

func FixedClassNewFromNative(native unsafe.Pointer) *FixedClass {
	err := fixedClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FixedClass{native: native}

	return instance
}

/*
CastToFixedClass down casts any arbitrary Object to FixedClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FixedClass.
*/
func CastToFixedClass(object *gobject.Object) *FixedClass {
	return FixedClassNewFromNative(object.Native())
}

// Equals compares this FixedClass with another FixedClass, and returns true if they represent the same Object.
func (recv *FixedClass) Equals(other *FixedClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FixedClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FixedClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(fixedClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FixedClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fixedClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// FixedClassStruct creates an uninitialised FixedClass.
func FixedClassStruct() *FixedClass {
	err := fixedClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FixedClassNewFromNative(fixedClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFixedClass)
	return structGo
}
func finalizeFixedClass(obj *FixedClass) {
	fixedClassStruct.Free(obj.Native())
}

var fixedPrivateStruct *gi.Struct
var fixedPrivateStruct_Once sync.Once

func fixedPrivateStruct_Set() error {
	var err error
	fixedPrivateStruct_Once.Do(func() {
		fixedPrivateStruct, err = gi.StructNew("Gtk", "FixedPrivate")
	})
	return err
}

type FixedPrivate struct {
	native unsafe.Pointer
}

func FixedPrivateNewFromNative(native unsafe.Pointer) *FixedPrivate {
	err := fixedPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FixedPrivate{native: native}

	return instance
}

/*
CastToFixedPrivate down casts any arbitrary Object to FixedPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FixedPrivate.
*/
func CastToFixedPrivate(object *gobject.Object) *FixedPrivate {
	return FixedPrivateNewFromNative(object.Native())
}

// Equals compares this FixedPrivate with another FixedPrivate, and returns true if they represent the same Object.
func (recv *FixedPrivate) Equals(other *FixedPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FixedPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FixedPrivateStruct creates an uninitialised FixedPrivate.
func FixedPrivateStruct() *FixedPrivate {
	err := fixedPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FixedPrivateNewFromNative(fixedPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFixedPrivate)
	return structGo
}
func finalizeFixedPrivate(obj *FixedPrivate) {
	fixedPrivateStruct.Free(obj.Native())
}

var flowBoxAccessibleClassStruct *gi.Struct
var flowBoxAccessibleClassStruct_Once sync.Once

func flowBoxAccessibleClassStruct_Set() error {
	var err error
	flowBoxAccessibleClassStruct_Once.Do(func() {
		flowBoxAccessibleClassStruct, err = gi.StructNew("Gtk", "FlowBoxAccessibleClass")
	})
	return err
}

type FlowBoxAccessibleClass struct {
	native unsafe.Pointer
}

func FlowBoxAccessibleClassNewFromNative(native unsafe.Pointer) *FlowBoxAccessibleClass {
	err := flowBoxAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FlowBoxAccessibleClass{native: native}

	return instance
}

/*
CastToFlowBoxAccessibleClass down casts any arbitrary Object to FlowBoxAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FlowBoxAccessibleClass.
*/
func CastToFlowBoxAccessibleClass(object *gobject.Object) *FlowBoxAccessibleClass {
	return FlowBoxAccessibleClassNewFromNative(object.Native())
}

// Equals compares this FlowBoxAccessibleClass with another FlowBoxAccessibleClass, and returns true if they represent the same Object.
func (recv *FlowBoxAccessibleClass) Equals(other *FlowBoxAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FlowBoxAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FlowBoxAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(flowBoxAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FlowBoxAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(flowBoxAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// FlowBoxAccessibleClassStruct creates an uninitialised FlowBoxAccessibleClass.
func FlowBoxAccessibleClassStruct() *FlowBoxAccessibleClass {
	err := flowBoxAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FlowBoxAccessibleClassNewFromNative(flowBoxAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFlowBoxAccessibleClass)
	return structGo
}
func finalizeFlowBoxAccessibleClass(obj *FlowBoxAccessibleClass) {
	flowBoxAccessibleClassStruct.Free(obj.Native())
}

var flowBoxAccessiblePrivateStruct *gi.Struct
var flowBoxAccessiblePrivateStruct_Once sync.Once

func flowBoxAccessiblePrivateStruct_Set() error {
	var err error
	flowBoxAccessiblePrivateStruct_Once.Do(func() {
		flowBoxAccessiblePrivateStruct, err = gi.StructNew("Gtk", "FlowBoxAccessiblePrivate")
	})
	return err
}

type FlowBoxAccessiblePrivate struct {
	native unsafe.Pointer
}

func FlowBoxAccessiblePrivateNewFromNative(native unsafe.Pointer) *FlowBoxAccessiblePrivate {
	err := flowBoxAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FlowBoxAccessiblePrivate{native: native}

	return instance
}

/*
CastToFlowBoxAccessiblePrivate down casts any arbitrary Object to FlowBoxAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FlowBoxAccessiblePrivate.
*/
func CastToFlowBoxAccessiblePrivate(object *gobject.Object) *FlowBoxAccessiblePrivate {
	return FlowBoxAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this FlowBoxAccessiblePrivate with another FlowBoxAccessiblePrivate, and returns true if they represent the same Object.
func (recv *FlowBoxAccessiblePrivate) Equals(other *FlowBoxAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FlowBoxAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// FlowBoxAccessiblePrivateStruct creates an uninitialised FlowBoxAccessiblePrivate.
func FlowBoxAccessiblePrivateStruct() *FlowBoxAccessiblePrivate {
	err := flowBoxAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FlowBoxAccessiblePrivateNewFromNative(flowBoxAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFlowBoxAccessiblePrivate)
	return structGo
}
func finalizeFlowBoxAccessiblePrivate(obj *FlowBoxAccessiblePrivate) {
	flowBoxAccessiblePrivateStruct.Free(obj.Native())
}

var flowBoxChildAccessibleClassStruct *gi.Struct
var flowBoxChildAccessibleClassStruct_Once sync.Once

func flowBoxChildAccessibleClassStruct_Set() error {
	var err error
	flowBoxChildAccessibleClassStruct_Once.Do(func() {
		flowBoxChildAccessibleClassStruct, err = gi.StructNew("Gtk", "FlowBoxChildAccessibleClass")
	})
	return err
}

type FlowBoxChildAccessibleClass struct {
	native unsafe.Pointer
}

func FlowBoxChildAccessibleClassNewFromNative(native unsafe.Pointer) *FlowBoxChildAccessibleClass {
	err := flowBoxChildAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FlowBoxChildAccessibleClass{native: native}

	return instance
}

/*
CastToFlowBoxChildAccessibleClass down casts any arbitrary Object to FlowBoxChildAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FlowBoxChildAccessibleClass.
*/
func CastToFlowBoxChildAccessibleClass(object *gobject.Object) *FlowBoxChildAccessibleClass {
	return FlowBoxChildAccessibleClassNewFromNative(object.Native())
}

// Equals compares this FlowBoxChildAccessibleClass with another FlowBoxChildAccessibleClass, and returns true if they represent the same Object.
func (recv *FlowBoxChildAccessibleClass) Equals(other *FlowBoxChildAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FlowBoxChildAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FlowBoxChildAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(flowBoxChildAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FlowBoxChildAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(flowBoxChildAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// FlowBoxChildAccessibleClassStruct creates an uninitialised FlowBoxChildAccessibleClass.
func FlowBoxChildAccessibleClassStruct() *FlowBoxChildAccessibleClass {
	err := flowBoxChildAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FlowBoxChildAccessibleClassNewFromNative(flowBoxChildAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFlowBoxChildAccessibleClass)
	return structGo
}
func finalizeFlowBoxChildAccessibleClass(obj *FlowBoxChildAccessibleClass) {
	flowBoxChildAccessibleClassStruct.Free(obj.Native())
}

var flowBoxChildClassStruct *gi.Struct
var flowBoxChildClassStruct_Once sync.Once

func flowBoxChildClassStruct_Set() error {
	var err error
	flowBoxChildClassStruct_Once.Do(func() {
		flowBoxChildClassStruct, err = gi.StructNew("Gtk", "FlowBoxChildClass")
	})
	return err
}

type FlowBoxChildClass struct {
	native unsafe.Pointer
}

func FlowBoxChildClassNewFromNative(native unsafe.Pointer) *FlowBoxChildClass {
	err := flowBoxChildClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FlowBoxChildClass{native: native}

	return instance
}

/*
CastToFlowBoxChildClass down casts any arbitrary Object to FlowBoxChildClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FlowBoxChildClass.
*/
func CastToFlowBoxChildClass(object *gobject.Object) *FlowBoxChildClass {
	return FlowBoxChildClassNewFromNative(object.Native())
}

// Equals compares this FlowBoxChildClass with another FlowBoxChildClass, and returns true if they represent the same Object.
func (recv *FlowBoxChildClass) Equals(other *FlowBoxChildClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FlowBoxChildClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FlowBoxChildClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(flowBoxChildClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FlowBoxChildClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(flowBoxChildClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// FlowBoxChildClassStruct creates an uninitialised FlowBoxChildClass.
func FlowBoxChildClassStruct() *FlowBoxChildClass {
	err := flowBoxChildClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FlowBoxChildClassNewFromNative(flowBoxChildClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFlowBoxChildClass)
	return structGo
}
func finalizeFlowBoxChildClass(obj *FlowBoxChildClass) {
	flowBoxChildClassStruct.Free(obj.Native())
}

var flowBoxClassStruct *gi.Struct
var flowBoxClassStruct_Once sync.Once

func flowBoxClassStruct_Set() error {
	var err error
	flowBoxClassStruct_Once.Do(func() {
		flowBoxClassStruct, err = gi.StructNew("Gtk", "FlowBoxClass")
	})
	return err
}

type FlowBoxClass struct {
	native unsafe.Pointer
}

func FlowBoxClassNewFromNative(native unsafe.Pointer) *FlowBoxClass {
	err := flowBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FlowBoxClass{native: native}

	return instance
}

/*
CastToFlowBoxClass down casts any arbitrary Object to FlowBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FlowBoxClass.
*/
func CastToFlowBoxClass(object *gobject.Object) *FlowBoxClass {
	return FlowBoxClassNewFromNative(object.Native())
}

// Equals compares this FlowBoxClass with another FlowBoxClass, and returns true if they represent the same Object.
func (recv *FlowBoxClass) Equals(other *FlowBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FlowBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FlowBoxClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(flowBoxClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FlowBoxClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(flowBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'child_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'child_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'selected_children_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'selected_children_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'activate_cursor_child' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_cursor_child' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_cursor_child' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_cursor_child' : for field setter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'select_all' : for field getter : missing Type

// UNSUPPORTED : C value 'select_all' : for field setter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field getter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// FlowBoxClassStruct creates an uninitialised FlowBoxClass.
func FlowBoxClassStruct() *FlowBoxClass {
	err := flowBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FlowBoxClassNewFromNative(flowBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFlowBoxClass)
	return structGo
}
func finalizeFlowBoxClass(obj *FlowBoxClass) {
	flowBoxClassStruct.Free(obj.Native())
}

var fontButtonClassStruct *gi.Struct
var fontButtonClassStruct_Once sync.Once

func fontButtonClassStruct_Set() error {
	var err error
	fontButtonClassStruct_Once.Do(func() {
		fontButtonClassStruct, err = gi.StructNew("Gtk", "FontButtonClass")
	})
	return err
}

type FontButtonClass struct {
	native unsafe.Pointer
}

func FontButtonClassNewFromNative(native unsafe.Pointer) *FontButtonClass {
	err := fontButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontButtonClass{native: native}

	return instance
}

/*
CastToFontButtonClass down casts any arbitrary Object to FontButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontButtonClass.
*/
func CastToFontButtonClass(object *gobject.Object) *FontButtonClass {
	return FontButtonClassNewFromNative(object.Native())
}

// Equals compares this FontButtonClass with another FontButtonClass, and returns true if they represent the same Object.
func (recv *FontButtonClass) Equals(other *FontButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FontButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FontButtonClass) FieldParentClass() *ButtonClass {
	argValue := gi.StructFieldGet(fontButtonClassStruct, recv.Native(), "parent_class")
	value := ButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FontButtonClass) SetFieldParentClass(value *ButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fontButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'font_set' : for field getter : missing Type

// UNSUPPORTED : C value 'font_set' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// FontButtonClassStruct creates an uninitialised FontButtonClass.
func FontButtonClassStruct() *FontButtonClass {
	err := fontButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontButtonClassNewFromNative(fontButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontButtonClass)
	return structGo
}
func finalizeFontButtonClass(obj *FontButtonClass) {
	fontButtonClassStruct.Free(obj.Native())
}

var fontButtonPrivateStruct *gi.Struct
var fontButtonPrivateStruct_Once sync.Once

func fontButtonPrivateStruct_Set() error {
	var err error
	fontButtonPrivateStruct_Once.Do(func() {
		fontButtonPrivateStruct, err = gi.StructNew("Gtk", "FontButtonPrivate")
	})
	return err
}

type FontButtonPrivate struct {
	native unsafe.Pointer
}

func FontButtonPrivateNewFromNative(native unsafe.Pointer) *FontButtonPrivate {
	err := fontButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontButtonPrivate{native: native}

	return instance
}

/*
CastToFontButtonPrivate down casts any arbitrary Object to FontButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontButtonPrivate.
*/
func CastToFontButtonPrivate(object *gobject.Object) *FontButtonPrivate {
	return FontButtonPrivateNewFromNative(object.Native())
}

// Equals compares this FontButtonPrivate with another FontButtonPrivate, and returns true if they represent the same Object.
func (recv *FontButtonPrivate) Equals(other *FontButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FontButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FontButtonPrivateStruct creates an uninitialised FontButtonPrivate.
func FontButtonPrivateStruct() *FontButtonPrivate {
	err := fontButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontButtonPrivateNewFromNative(fontButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontButtonPrivate)
	return structGo
}
func finalizeFontButtonPrivate(obj *FontButtonPrivate) {
	fontButtonPrivateStruct.Free(obj.Native())
}

var fontChooserDialogClassStruct *gi.Struct
var fontChooserDialogClassStruct_Once sync.Once

func fontChooserDialogClassStruct_Set() error {
	var err error
	fontChooserDialogClassStruct_Once.Do(func() {
		fontChooserDialogClassStruct, err = gi.StructNew("Gtk", "FontChooserDialogClass")
	})
	return err
}

type FontChooserDialogClass struct {
	native unsafe.Pointer
}

func FontChooserDialogClassNewFromNative(native unsafe.Pointer) *FontChooserDialogClass {
	err := fontChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontChooserDialogClass{native: native}

	return instance
}

/*
CastToFontChooserDialogClass down casts any arbitrary Object to FontChooserDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontChooserDialogClass.
*/
func CastToFontChooserDialogClass(object *gobject.Object) *FontChooserDialogClass {
	return FontChooserDialogClassNewFromNative(object.Native())
}

// Equals compares this FontChooserDialogClass with another FontChooserDialogClass, and returns true if they represent the same Object.
func (recv *FontChooserDialogClass) Equals(other *FontChooserDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FontChooserDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FontChooserDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(fontChooserDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FontChooserDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fontChooserDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// FontChooserDialogClassStruct creates an uninitialised FontChooserDialogClass.
func FontChooserDialogClassStruct() *FontChooserDialogClass {
	err := fontChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontChooserDialogClassNewFromNative(fontChooserDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontChooserDialogClass)
	return structGo
}
func finalizeFontChooserDialogClass(obj *FontChooserDialogClass) {
	fontChooserDialogClassStruct.Free(obj.Native())
}

var fontChooserDialogPrivateStruct *gi.Struct
var fontChooserDialogPrivateStruct_Once sync.Once

func fontChooserDialogPrivateStruct_Set() error {
	var err error
	fontChooserDialogPrivateStruct_Once.Do(func() {
		fontChooserDialogPrivateStruct, err = gi.StructNew("Gtk", "FontChooserDialogPrivate")
	})
	return err
}

type FontChooserDialogPrivate struct {
	native unsafe.Pointer
}

func FontChooserDialogPrivateNewFromNative(native unsafe.Pointer) *FontChooserDialogPrivate {
	err := fontChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontChooserDialogPrivate{native: native}

	return instance
}

/*
CastToFontChooserDialogPrivate down casts any arbitrary Object to FontChooserDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontChooserDialogPrivate.
*/
func CastToFontChooserDialogPrivate(object *gobject.Object) *FontChooserDialogPrivate {
	return FontChooserDialogPrivateNewFromNative(object.Native())
}

// Equals compares this FontChooserDialogPrivate with another FontChooserDialogPrivate, and returns true if they represent the same Object.
func (recv *FontChooserDialogPrivate) Equals(other *FontChooserDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FontChooserDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FontChooserDialogPrivateStruct creates an uninitialised FontChooserDialogPrivate.
func FontChooserDialogPrivateStruct() *FontChooserDialogPrivate {
	err := fontChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontChooserDialogPrivateNewFromNative(fontChooserDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontChooserDialogPrivate)
	return structGo
}
func finalizeFontChooserDialogPrivate(obj *FontChooserDialogPrivate) {
	fontChooserDialogPrivateStruct.Free(obj.Native())
}

var fontChooserIfaceStruct *gi.Struct
var fontChooserIfaceStruct_Once sync.Once

func fontChooserIfaceStruct_Set() error {
	var err error
	fontChooserIfaceStruct_Once.Do(func() {
		fontChooserIfaceStruct, err = gi.StructNew("Gtk", "FontChooserIface")
	})
	return err
}

type FontChooserIface struct {
	native unsafe.Pointer
}

func FontChooserIfaceNewFromNative(native unsafe.Pointer) *FontChooserIface {
	err := fontChooserIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontChooserIface{native: native}

	return instance
}

/*
CastToFontChooserIface down casts any arbitrary Object to FontChooserIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontChooserIface.
*/
func CastToFontChooserIface(object *gobject.Object) *FontChooserIface {
	return FontChooserIfaceNewFromNative(object.Native())
}

// Equals compares this FontChooserIface with another FontChooserIface, and returns true if they represent the same Object.
func (recv *FontChooserIface) Equals(other *FontChooserIface) bool {
	return other.Native() == recv.Native()
}

func (recv *FontChooserIface) Native() unsafe.Pointer {
	return recv.native
}

// FieldBaseIface returns the C field 'base_iface'.
func (recv *FontChooserIface) FieldBaseIface() *gobject.TypeInterface {
	argValue := gi.StructFieldGet(fontChooserIfaceStruct, recv.Native(), "base_iface")
	value := gobject.TypeInterfaceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldBaseIface sets the value of the C field 'base_iface'.
func (recv *FontChooserIface) SetFieldBaseIface(value *gobject.TypeInterface) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fontChooserIfaceStruct, recv.Native(), "base_iface", argValue)
}

// UNSUPPORTED : C value 'get_font_family' : for field getter : missing Type

// UNSUPPORTED : C value 'get_font_family' : for field setter : missing Type

// UNSUPPORTED : C value 'get_font_face' : for field getter : missing Type

// UNSUPPORTED : C value 'get_font_face' : for field setter : missing Type

// UNSUPPORTED : C value 'get_font_size' : for field getter : missing Type

// UNSUPPORTED : C value 'get_font_size' : for field setter : missing Type

// UNSUPPORTED : C value 'set_filter_func' : for field getter : missing Type

// UNSUPPORTED : C value 'set_filter_func' : for field setter : missing Type

// UNSUPPORTED : C value 'font_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'font_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'set_font_map' : for field getter : missing Type

// UNSUPPORTED : C value 'set_font_map' : for field setter : missing Type

// UNSUPPORTED : C value 'get_font_map' : for field getter : missing Type

// UNSUPPORTED : C value 'get_font_map' : for field setter : missing Type

// UNSUPPORTED : C value 'padding' : for field getter : missing Type

// UNSUPPORTED : C value 'padding' : for field setter : missing Type

// FontChooserIfaceStruct creates an uninitialised FontChooserIface.
func FontChooserIfaceStruct() *FontChooserIface {
	err := fontChooserIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontChooserIfaceNewFromNative(fontChooserIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontChooserIface)
	return structGo
}
func finalizeFontChooserIface(obj *FontChooserIface) {
	fontChooserIfaceStruct.Free(obj.Native())
}

var fontChooserWidgetClassStruct *gi.Struct
var fontChooserWidgetClassStruct_Once sync.Once

func fontChooserWidgetClassStruct_Set() error {
	var err error
	fontChooserWidgetClassStruct_Once.Do(func() {
		fontChooserWidgetClassStruct, err = gi.StructNew("Gtk", "FontChooserWidgetClass")
	})
	return err
}

type FontChooserWidgetClass struct {
	native unsafe.Pointer
}

func FontChooserWidgetClassNewFromNative(native unsafe.Pointer) *FontChooserWidgetClass {
	err := fontChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontChooserWidgetClass{native: native}

	return instance
}

/*
CastToFontChooserWidgetClass down casts any arbitrary Object to FontChooserWidgetClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontChooserWidgetClass.
*/
func CastToFontChooserWidgetClass(object *gobject.Object) *FontChooserWidgetClass {
	return FontChooserWidgetClassNewFromNative(object.Native())
}

// Equals compares this FontChooserWidgetClass with another FontChooserWidgetClass, and returns true if they represent the same Object.
func (recv *FontChooserWidgetClass) Equals(other *FontChooserWidgetClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FontChooserWidgetClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FontChooserWidgetClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(fontChooserWidgetClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FontChooserWidgetClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fontChooserWidgetClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// FontChooserWidgetClassStruct creates an uninitialised FontChooserWidgetClass.
func FontChooserWidgetClassStruct() *FontChooserWidgetClass {
	err := fontChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontChooserWidgetClassNewFromNative(fontChooserWidgetClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontChooserWidgetClass)
	return structGo
}
func finalizeFontChooserWidgetClass(obj *FontChooserWidgetClass) {
	fontChooserWidgetClassStruct.Free(obj.Native())
}

var fontChooserWidgetPrivateStruct *gi.Struct
var fontChooserWidgetPrivateStruct_Once sync.Once

func fontChooserWidgetPrivateStruct_Set() error {
	var err error
	fontChooserWidgetPrivateStruct_Once.Do(func() {
		fontChooserWidgetPrivateStruct, err = gi.StructNew("Gtk", "FontChooserWidgetPrivate")
	})
	return err
}

type FontChooserWidgetPrivate struct {
	native unsafe.Pointer
}

func FontChooserWidgetPrivateNewFromNative(native unsafe.Pointer) *FontChooserWidgetPrivate {
	err := fontChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontChooserWidgetPrivate{native: native}

	return instance
}

/*
CastToFontChooserWidgetPrivate down casts any arbitrary Object to FontChooserWidgetPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontChooserWidgetPrivate.
*/
func CastToFontChooserWidgetPrivate(object *gobject.Object) *FontChooserWidgetPrivate {
	return FontChooserWidgetPrivateNewFromNative(object.Native())
}

// Equals compares this FontChooserWidgetPrivate with another FontChooserWidgetPrivate, and returns true if they represent the same Object.
func (recv *FontChooserWidgetPrivate) Equals(other *FontChooserWidgetPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FontChooserWidgetPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FontChooserWidgetPrivateStruct creates an uninitialised FontChooserWidgetPrivate.
func FontChooserWidgetPrivateStruct() *FontChooserWidgetPrivate {
	err := fontChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontChooserWidgetPrivateNewFromNative(fontChooserWidgetPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontChooserWidgetPrivate)
	return structGo
}
func finalizeFontChooserWidgetPrivate(obj *FontChooserWidgetPrivate) {
	fontChooserWidgetPrivateStruct.Free(obj.Native())
}

var fontSelectionClassStruct *gi.Struct
var fontSelectionClassStruct_Once sync.Once

func fontSelectionClassStruct_Set() error {
	var err error
	fontSelectionClassStruct_Once.Do(func() {
		fontSelectionClassStruct, err = gi.StructNew("Gtk", "FontSelectionClass")
	})
	return err
}

type FontSelectionClass struct {
	native unsafe.Pointer
}

func FontSelectionClassNewFromNative(native unsafe.Pointer) *FontSelectionClass {
	err := fontSelectionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontSelectionClass{native: native}

	return instance
}

/*
CastToFontSelectionClass down casts any arbitrary Object to FontSelectionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontSelectionClass.
*/
func CastToFontSelectionClass(object *gobject.Object) *FontSelectionClass {
	return FontSelectionClassNewFromNative(object.Native())
}

// Equals compares this FontSelectionClass with another FontSelectionClass, and returns true if they represent the same Object.
func (recv *FontSelectionClass) Equals(other *FontSelectionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FontSelectionClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FontSelectionClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(fontSelectionClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FontSelectionClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fontSelectionClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// FontSelectionClassStruct creates an uninitialised FontSelectionClass.
func FontSelectionClassStruct() *FontSelectionClass {
	err := fontSelectionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontSelectionClassNewFromNative(fontSelectionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontSelectionClass)
	return structGo
}
func finalizeFontSelectionClass(obj *FontSelectionClass) {
	fontSelectionClassStruct.Free(obj.Native())
}

var fontSelectionDialogClassStruct *gi.Struct
var fontSelectionDialogClassStruct_Once sync.Once

func fontSelectionDialogClassStruct_Set() error {
	var err error
	fontSelectionDialogClassStruct_Once.Do(func() {
		fontSelectionDialogClassStruct, err = gi.StructNew("Gtk", "FontSelectionDialogClass")
	})
	return err
}

type FontSelectionDialogClass struct {
	native unsafe.Pointer
}

func FontSelectionDialogClassNewFromNative(native unsafe.Pointer) *FontSelectionDialogClass {
	err := fontSelectionDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontSelectionDialogClass{native: native}

	return instance
}

/*
CastToFontSelectionDialogClass down casts any arbitrary Object to FontSelectionDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontSelectionDialogClass.
*/
func CastToFontSelectionDialogClass(object *gobject.Object) *FontSelectionDialogClass {
	return FontSelectionDialogClassNewFromNative(object.Native())
}

// Equals compares this FontSelectionDialogClass with another FontSelectionDialogClass, and returns true if they represent the same Object.
func (recv *FontSelectionDialogClass) Equals(other *FontSelectionDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FontSelectionDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FontSelectionDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(fontSelectionDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FontSelectionDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(fontSelectionDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// FontSelectionDialogClassStruct creates an uninitialised FontSelectionDialogClass.
func FontSelectionDialogClassStruct() *FontSelectionDialogClass {
	err := fontSelectionDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontSelectionDialogClassNewFromNative(fontSelectionDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontSelectionDialogClass)
	return structGo
}
func finalizeFontSelectionDialogClass(obj *FontSelectionDialogClass) {
	fontSelectionDialogClassStruct.Free(obj.Native())
}

var fontSelectionDialogPrivateStruct *gi.Struct
var fontSelectionDialogPrivateStruct_Once sync.Once

func fontSelectionDialogPrivateStruct_Set() error {
	var err error
	fontSelectionDialogPrivateStruct_Once.Do(func() {
		fontSelectionDialogPrivateStruct, err = gi.StructNew("Gtk", "FontSelectionDialogPrivate")
	})
	return err
}

type FontSelectionDialogPrivate struct {
	native unsafe.Pointer
}

func FontSelectionDialogPrivateNewFromNative(native unsafe.Pointer) *FontSelectionDialogPrivate {
	err := fontSelectionDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontSelectionDialogPrivate{native: native}

	return instance
}

/*
CastToFontSelectionDialogPrivate down casts any arbitrary Object to FontSelectionDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontSelectionDialogPrivate.
*/
func CastToFontSelectionDialogPrivate(object *gobject.Object) *FontSelectionDialogPrivate {
	return FontSelectionDialogPrivateNewFromNative(object.Native())
}

// Equals compares this FontSelectionDialogPrivate with another FontSelectionDialogPrivate, and returns true if they represent the same Object.
func (recv *FontSelectionDialogPrivate) Equals(other *FontSelectionDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FontSelectionDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FontSelectionDialogPrivateStruct creates an uninitialised FontSelectionDialogPrivate.
func FontSelectionDialogPrivateStruct() *FontSelectionDialogPrivate {
	err := fontSelectionDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontSelectionDialogPrivateNewFromNative(fontSelectionDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontSelectionDialogPrivate)
	return structGo
}
func finalizeFontSelectionDialogPrivate(obj *FontSelectionDialogPrivate) {
	fontSelectionDialogPrivateStruct.Free(obj.Native())
}

var fontSelectionPrivateStruct *gi.Struct
var fontSelectionPrivateStruct_Once sync.Once

func fontSelectionPrivateStruct_Set() error {
	var err error
	fontSelectionPrivateStruct_Once.Do(func() {
		fontSelectionPrivateStruct, err = gi.StructNew("Gtk", "FontSelectionPrivate")
	})
	return err
}

type FontSelectionPrivate struct {
	native unsafe.Pointer
}

func FontSelectionPrivateNewFromNative(native unsafe.Pointer) *FontSelectionPrivate {
	err := fontSelectionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FontSelectionPrivate{native: native}

	return instance
}

/*
CastToFontSelectionPrivate down casts any arbitrary Object to FontSelectionPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FontSelectionPrivate.
*/
func CastToFontSelectionPrivate(object *gobject.Object) *FontSelectionPrivate {
	return FontSelectionPrivateNewFromNative(object.Native())
}

// Equals compares this FontSelectionPrivate with another FontSelectionPrivate, and returns true if they represent the same Object.
func (recv *FontSelectionPrivate) Equals(other *FontSelectionPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FontSelectionPrivate) Native() unsafe.Pointer {
	return recv.native
}

// FontSelectionPrivateStruct creates an uninitialised FontSelectionPrivate.
func FontSelectionPrivateStruct() *FontSelectionPrivate {
	err := fontSelectionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FontSelectionPrivateNewFromNative(fontSelectionPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFontSelectionPrivate)
	return structGo
}
func finalizeFontSelectionPrivate(obj *FontSelectionPrivate) {
	fontSelectionPrivateStruct.Free(obj.Native())
}

var frameAccessibleClassStruct *gi.Struct
var frameAccessibleClassStruct_Once sync.Once

func frameAccessibleClassStruct_Set() error {
	var err error
	frameAccessibleClassStruct_Once.Do(func() {
		frameAccessibleClassStruct, err = gi.StructNew("Gtk", "FrameAccessibleClass")
	})
	return err
}

type FrameAccessibleClass struct {
	native unsafe.Pointer
}

func FrameAccessibleClassNewFromNative(native unsafe.Pointer) *FrameAccessibleClass {
	err := frameAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FrameAccessibleClass{native: native}

	return instance
}

/*
CastToFrameAccessibleClass down casts any arbitrary Object to FrameAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FrameAccessibleClass.
*/
func CastToFrameAccessibleClass(object *gobject.Object) *FrameAccessibleClass {
	return FrameAccessibleClassNewFromNative(object.Native())
}

// Equals compares this FrameAccessibleClass with another FrameAccessibleClass, and returns true if they represent the same Object.
func (recv *FrameAccessibleClass) Equals(other *FrameAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FrameAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FrameAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(frameAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FrameAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(frameAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// FrameAccessibleClassStruct creates an uninitialised FrameAccessibleClass.
func FrameAccessibleClassStruct() *FrameAccessibleClass {
	err := frameAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FrameAccessibleClassNewFromNative(frameAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFrameAccessibleClass)
	return structGo
}
func finalizeFrameAccessibleClass(obj *FrameAccessibleClass) {
	frameAccessibleClassStruct.Free(obj.Native())
}

var frameAccessiblePrivateStruct *gi.Struct
var frameAccessiblePrivateStruct_Once sync.Once

func frameAccessiblePrivateStruct_Set() error {
	var err error
	frameAccessiblePrivateStruct_Once.Do(func() {
		frameAccessiblePrivateStruct, err = gi.StructNew("Gtk", "FrameAccessiblePrivate")
	})
	return err
}

type FrameAccessiblePrivate struct {
	native unsafe.Pointer
}

func FrameAccessiblePrivateNewFromNative(native unsafe.Pointer) *FrameAccessiblePrivate {
	err := frameAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FrameAccessiblePrivate{native: native}

	return instance
}

/*
CastToFrameAccessiblePrivate down casts any arbitrary Object to FrameAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FrameAccessiblePrivate.
*/
func CastToFrameAccessiblePrivate(object *gobject.Object) *FrameAccessiblePrivate {
	return FrameAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this FrameAccessiblePrivate with another FrameAccessiblePrivate, and returns true if they represent the same Object.
func (recv *FrameAccessiblePrivate) Equals(other *FrameAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FrameAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// FrameAccessiblePrivateStruct creates an uninitialised FrameAccessiblePrivate.
func FrameAccessiblePrivateStruct() *FrameAccessiblePrivate {
	err := frameAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FrameAccessiblePrivateNewFromNative(frameAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFrameAccessiblePrivate)
	return structGo
}
func finalizeFrameAccessiblePrivate(obj *FrameAccessiblePrivate) {
	frameAccessiblePrivateStruct.Free(obj.Native())
}

var frameClassStruct *gi.Struct
var frameClassStruct_Once sync.Once

func frameClassStruct_Set() error {
	var err error
	frameClassStruct_Once.Do(func() {
		frameClassStruct, err = gi.StructNew("Gtk", "FrameClass")
	})
	return err
}

type FrameClass struct {
	native unsafe.Pointer
}

func FrameClassNewFromNative(native unsafe.Pointer) *FrameClass {
	err := frameClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FrameClass{native: native}

	return instance
}

/*
CastToFrameClass down casts any arbitrary Object to FrameClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a FrameClass.
*/
func CastToFrameClass(object *gobject.Object) *FrameClass {
	return FrameClassNewFromNative(object.Native())
}

// Equals compares this FrameClass with another FrameClass, and returns true if they represent the same Object.
func (recv *FrameClass) Equals(other *FrameClass) bool {
	return other.Native() == recv.Native()
}

func (recv *FrameClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *FrameClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(frameClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *FrameClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(frameClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'compute_child_allocation' : for field getter : missing Type

// UNSUPPORTED : C value 'compute_child_allocation' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// FrameClassStruct creates an uninitialised FrameClass.
func FrameClassStruct() *FrameClass {
	err := frameClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FrameClassNewFromNative(frameClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFrameClass)
	return structGo
}
func finalizeFrameClass(obj *FrameClass) {
	frameClassStruct.Free(obj.Native())
}

var framePrivateStruct *gi.Struct
var framePrivateStruct_Once sync.Once

func framePrivateStruct_Set() error {
	var err error
	framePrivateStruct_Once.Do(func() {
		framePrivateStruct, err = gi.StructNew("Gtk", "FramePrivate")
	})
	return err
}

type FramePrivate struct {
	native unsafe.Pointer
}

func FramePrivateNewFromNative(native unsafe.Pointer) *FramePrivate {
	err := framePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &FramePrivate{native: native}

	return instance
}

/*
CastToFramePrivate down casts any arbitrary Object to FramePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a FramePrivate.
*/
func CastToFramePrivate(object *gobject.Object) *FramePrivate {
	return FramePrivateNewFromNative(object.Native())
}

// Equals compares this FramePrivate with another FramePrivate, and returns true if they represent the same Object.
func (recv *FramePrivate) Equals(other *FramePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *FramePrivate) Native() unsafe.Pointer {
	return recv.native
}

// FramePrivateStruct creates an uninitialised FramePrivate.
func FramePrivateStruct() *FramePrivate {
	err := framePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := FramePrivateNewFromNative(framePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeFramePrivate)
	return structGo
}
func finalizeFramePrivate(obj *FramePrivate) {
	framePrivateStruct.Free(obj.Native())
}

var gLAreaClassStruct *gi.Struct
var gLAreaClassStruct_Once sync.Once

func gLAreaClassStruct_Set() error {
	var err error
	gLAreaClassStruct_Once.Do(func() {
		gLAreaClassStruct, err = gi.StructNew("Gtk", "GLAreaClass")
	})
	return err
}

type GLAreaClass struct {
	native unsafe.Pointer
}

func GLAreaClassNewFromNative(native unsafe.Pointer) *GLAreaClass {
	err := gLAreaClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GLAreaClass{native: native}

	return instance
}

/*
CastToGLAreaClass down casts any arbitrary Object to GLAreaClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GLAreaClass.
*/
func CastToGLAreaClass(object *gobject.Object) *GLAreaClass {
	return GLAreaClassNewFromNative(object.Native())
}

// Equals compares this GLAreaClass with another GLAreaClass, and returns true if they represent the same Object.
func (recv *GLAreaClass) Equals(other *GLAreaClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GLAreaClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'render' : for field getter : missing Type

// UNSUPPORTED : C value 'render' : for field setter : missing Type

// UNSUPPORTED : C value 'resize' : for field getter : missing Type

// UNSUPPORTED : C value 'resize' : for field setter : missing Type

// UNSUPPORTED : C value 'create_context' : for field getter : missing Type

// UNSUPPORTED : C value 'create_context' : for field setter : missing Type

// GLAreaClassStruct creates an uninitialised GLAreaClass.
func GLAreaClassStruct() *GLAreaClass {
	err := gLAreaClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GLAreaClassNewFromNative(gLAreaClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGLAreaClass)
	return structGo
}
func finalizeGLAreaClass(obj *GLAreaClass) {
	gLAreaClassStruct.Free(obj.Native())
}

var gestureClassStruct *gi.Struct
var gestureClassStruct_Once sync.Once

func gestureClassStruct_Set() error {
	var err error
	gestureClassStruct_Once.Do(func() {
		gestureClassStruct, err = gi.StructNew("Gtk", "GestureClass")
	})
	return err
}

type GestureClass struct {
	native unsafe.Pointer
}

func GestureClassNewFromNative(native unsafe.Pointer) *GestureClass {
	err := gestureClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureClass{native: native}

	return instance
}

/*
CastToGestureClass down casts any arbitrary Object to GestureClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureClass.
*/
func CastToGestureClass(object *gobject.Object) *GestureClass {
	return GestureClassNewFromNative(object.Native())
}

// Equals compares this GestureClass with another GestureClass, and returns true if they represent the same Object.
func (recv *GestureClass) Equals(other *GestureClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureClassStruct creates an uninitialised GestureClass.
func GestureClassStruct() *GestureClass {
	err := gestureClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureClassNewFromNative(gestureClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureClass)
	return structGo
}
func finalizeGestureClass(obj *GestureClass) {
	gestureClassStruct.Free(obj.Native())
}

var gestureDragClassStruct *gi.Struct
var gestureDragClassStruct_Once sync.Once

func gestureDragClassStruct_Set() error {
	var err error
	gestureDragClassStruct_Once.Do(func() {
		gestureDragClassStruct, err = gi.StructNew("Gtk", "GestureDragClass")
	})
	return err
}

type GestureDragClass struct {
	native unsafe.Pointer
}

func GestureDragClassNewFromNative(native unsafe.Pointer) *GestureDragClass {
	err := gestureDragClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureDragClass{native: native}

	return instance
}

/*
CastToGestureDragClass down casts any arbitrary Object to GestureDragClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureDragClass.
*/
func CastToGestureDragClass(object *gobject.Object) *GestureDragClass {
	return GestureDragClassNewFromNative(object.Native())
}

// Equals compares this GestureDragClass with another GestureDragClass, and returns true if they represent the same Object.
func (recv *GestureDragClass) Equals(other *GestureDragClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureDragClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureDragClassStruct creates an uninitialised GestureDragClass.
func GestureDragClassStruct() *GestureDragClass {
	err := gestureDragClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureDragClassNewFromNative(gestureDragClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureDragClass)
	return structGo
}
func finalizeGestureDragClass(obj *GestureDragClass) {
	gestureDragClassStruct.Free(obj.Native())
}

var gestureLongPressClassStruct *gi.Struct
var gestureLongPressClassStruct_Once sync.Once

func gestureLongPressClassStruct_Set() error {
	var err error
	gestureLongPressClassStruct_Once.Do(func() {
		gestureLongPressClassStruct, err = gi.StructNew("Gtk", "GestureLongPressClass")
	})
	return err
}

type GestureLongPressClass struct {
	native unsafe.Pointer
}

func GestureLongPressClassNewFromNative(native unsafe.Pointer) *GestureLongPressClass {
	err := gestureLongPressClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureLongPressClass{native: native}

	return instance
}

/*
CastToGestureLongPressClass down casts any arbitrary Object to GestureLongPressClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureLongPressClass.
*/
func CastToGestureLongPressClass(object *gobject.Object) *GestureLongPressClass {
	return GestureLongPressClassNewFromNative(object.Native())
}

// Equals compares this GestureLongPressClass with another GestureLongPressClass, and returns true if they represent the same Object.
func (recv *GestureLongPressClass) Equals(other *GestureLongPressClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureLongPressClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureLongPressClassStruct creates an uninitialised GestureLongPressClass.
func GestureLongPressClassStruct() *GestureLongPressClass {
	err := gestureLongPressClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureLongPressClassNewFromNative(gestureLongPressClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureLongPressClass)
	return structGo
}
func finalizeGestureLongPressClass(obj *GestureLongPressClass) {
	gestureLongPressClassStruct.Free(obj.Native())
}

var gestureMultiPressClassStruct *gi.Struct
var gestureMultiPressClassStruct_Once sync.Once

func gestureMultiPressClassStruct_Set() error {
	var err error
	gestureMultiPressClassStruct_Once.Do(func() {
		gestureMultiPressClassStruct, err = gi.StructNew("Gtk", "GestureMultiPressClass")
	})
	return err
}

type GestureMultiPressClass struct {
	native unsafe.Pointer
}

func GestureMultiPressClassNewFromNative(native unsafe.Pointer) *GestureMultiPressClass {
	err := gestureMultiPressClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureMultiPressClass{native: native}

	return instance
}

/*
CastToGestureMultiPressClass down casts any arbitrary Object to GestureMultiPressClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureMultiPressClass.
*/
func CastToGestureMultiPressClass(object *gobject.Object) *GestureMultiPressClass {
	return GestureMultiPressClassNewFromNative(object.Native())
}

// Equals compares this GestureMultiPressClass with another GestureMultiPressClass, and returns true if they represent the same Object.
func (recv *GestureMultiPressClass) Equals(other *GestureMultiPressClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureMultiPressClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureMultiPressClassStruct creates an uninitialised GestureMultiPressClass.
func GestureMultiPressClassStruct() *GestureMultiPressClass {
	err := gestureMultiPressClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureMultiPressClassNewFromNative(gestureMultiPressClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureMultiPressClass)
	return structGo
}
func finalizeGestureMultiPressClass(obj *GestureMultiPressClass) {
	gestureMultiPressClassStruct.Free(obj.Native())
}

var gesturePanClassStruct *gi.Struct
var gesturePanClassStruct_Once sync.Once

func gesturePanClassStruct_Set() error {
	var err error
	gesturePanClassStruct_Once.Do(func() {
		gesturePanClassStruct, err = gi.StructNew("Gtk", "GesturePanClass")
	})
	return err
}

type GesturePanClass struct {
	native unsafe.Pointer
}

func GesturePanClassNewFromNative(native unsafe.Pointer) *GesturePanClass {
	err := gesturePanClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GesturePanClass{native: native}

	return instance
}

/*
CastToGesturePanClass down casts any arbitrary Object to GesturePanClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GesturePanClass.
*/
func CastToGesturePanClass(object *gobject.Object) *GesturePanClass {
	return GesturePanClassNewFromNative(object.Native())
}

// Equals compares this GesturePanClass with another GesturePanClass, and returns true if they represent the same Object.
func (recv *GesturePanClass) Equals(other *GesturePanClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GesturePanClass) Native() unsafe.Pointer {
	return recv.native
}

// GesturePanClassStruct creates an uninitialised GesturePanClass.
func GesturePanClassStruct() *GesturePanClass {
	err := gesturePanClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GesturePanClassNewFromNative(gesturePanClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGesturePanClass)
	return structGo
}
func finalizeGesturePanClass(obj *GesturePanClass) {
	gesturePanClassStruct.Free(obj.Native())
}

var gestureRotateClassStruct *gi.Struct
var gestureRotateClassStruct_Once sync.Once

func gestureRotateClassStruct_Set() error {
	var err error
	gestureRotateClassStruct_Once.Do(func() {
		gestureRotateClassStruct, err = gi.StructNew("Gtk", "GestureRotateClass")
	})
	return err
}

type GestureRotateClass struct {
	native unsafe.Pointer
}

func GestureRotateClassNewFromNative(native unsafe.Pointer) *GestureRotateClass {
	err := gestureRotateClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureRotateClass{native: native}

	return instance
}

/*
CastToGestureRotateClass down casts any arbitrary Object to GestureRotateClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureRotateClass.
*/
func CastToGestureRotateClass(object *gobject.Object) *GestureRotateClass {
	return GestureRotateClassNewFromNative(object.Native())
}

// Equals compares this GestureRotateClass with another GestureRotateClass, and returns true if they represent the same Object.
func (recv *GestureRotateClass) Equals(other *GestureRotateClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureRotateClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureRotateClassStruct creates an uninitialised GestureRotateClass.
func GestureRotateClassStruct() *GestureRotateClass {
	err := gestureRotateClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureRotateClassNewFromNative(gestureRotateClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureRotateClass)
	return structGo
}
func finalizeGestureRotateClass(obj *GestureRotateClass) {
	gestureRotateClassStruct.Free(obj.Native())
}

var gestureSingleClassStruct *gi.Struct
var gestureSingleClassStruct_Once sync.Once

func gestureSingleClassStruct_Set() error {
	var err error
	gestureSingleClassStruct_Once.Do(func() {
		gestureSingleClassStruct, err = gi.StructNew("Gtk", "GestureSingleClass")
	})
	return err
}

type GestureSingleClass struct {
	native unsafe.Pointer
}

func GestureSingleClassNewFromNative(native unsafe.Pointer) *GestureSingleClass {
	err := gestureSingleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureSingleClass{native: native}

	return instance
}

/*
CastToGestureSingleClass down casts any arbitrary Object to GestureSingleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureSingleClass.
*/
func CastToGestureSingleClass(object *gobject.Object) *GestureSingleClass {
	return GestureSingleClassNewFromNative(object.Native())
}

// Equals compares this GestureSingleClass with another GestureSingleClass, and returns true if they represent the same Object.
func (recv *GestureSingleClass) Equals(other *GestureSingleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureSingleClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureSingleClassStruct creates an uninitialised GestureSingleClass.
func GestureSingleClassStruct() *GestureSingleClass {
	err := gestureSingleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureSingleClassNewFromNative(gestureSingleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureSingleClass)
	return structGo
}
func finalizeGestureSingleClass(obj *GestureSingleClass) {
	gestureSingleClassStruct.Free(obj.Native())
}

var gestureStylusClassStruct *gi.Struct
var gestureStylusClassStruct_Once sync.Once

func gestureStylusClassStruct_Set() error {
	var err error
	gestureStylusClassStruct_Once.Do(func() {
		gestureStylusClassStruct, err = gi.StructNew("Gtk", "GestureStylusClass")
	})
	return err
}

type GestureStylusClass struct {
	native unsafe.Pointer
}

func GestureStylusClassNewFromNative(native unsafe.Pointer) *GestureStylusClass {
	err := gestureStylusClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureStylusClass{native: native}

	return instance
}

/*
CastToGestureStylusClass down casts any arbitrary Object to GestureStylusClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureStylusClass.
*/
func CastToGestureStylusClass(object *gobject.Object) *GestureStylusClass {
	return GestureStylusClassNewFromNative(object.Native())
}

// Equals compares this GestureStylusClass with another GestureStylusClass, and returns true if they represent the same Object.
func (recv *GestureStylusClass) Equals(other *GestureStylusClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureStylusClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureStylusClassStruct creates an uninitialised GestureStylusClass.
func GestureStylusClassStruct() *GestureStylusClass {
	err := gestureStylusClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureStylusClassNewFromNative(gestureStylusClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureStylusClass)
	return structGo
}
func finalizeGestureStylusClass(obj *GestureStylusClass) {
	gestureStylusClassStruct.Free(obj.Native())
}

var gestureSwipeClassStruct *gi.Struct
var gestureSwipeClassStruct_Once sync.Once

func gestureSwipeClassStruct_Set() error {
	var err error
	gestureSwipeClassStruct_Once.Do(func() {
		gestureSwipeClassStruct, err = gi.StructNew("Gtk", "GestureSwipeClass")
	})
	return err
}

type GestureSwipeClass struct {
	native unsafe.Pointer
}

func GestureSwipeClassNewFromNative(native unsafe.Pointer) *GestureSwipeClass {
	err := gestureSwipeClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureSwipeClass{native: native}

	return instance
}

/*
CastToGestureSwipeClass down casts any arbitrary Object to GestureSwipeClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureSwipeClass.
*/
func CastToGestureSwipeClass(object *gobject.Object) *GestureSwipeClass {
	return GestureSwipeClassNewFromNative(object.Native())
}

// Equals compares this GestureSwipeClass with another GestureSwipeClass, and returns true if they represent the same Object.
func (recv *GestureSwipeClass) Equals(other *GestureSwipeClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureSwipeClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureSwipeClassStruct creates an uninitialised GestureSwipeClass.
func GestureSwipeClassStruct() *GestureSwipeClass {
	err := gestureSwipeClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureSwipeClassNewFromNative(gestureSwipeClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureSwipeClass)
	return structGo
}
func finalizeGestureSwipeClass(obj *GestureSwipeClass) {
	gestureSwipeClassStruct.Free(obj.Native())
}

var gestureZoomClassStruct *gi.Struct
var gestureZoomClassStruct_Once sync.Once

func gestureZoomClassStruct_Set() error {
	var err error
	gestureZoomClassStruct_Once.Do(func() {
		gestureZoomClassStruct, err = gi.StructNew("Gtk", "GestureZoomClass")
	})
	return err
}

type GestureZoomClass struct {
	native unsafe.Pointer
}

func GestureZoomClassNewFromNative(native unsafe.Pointer) *GestureZoomClass {
	err := gestureZoomClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GestureZoomClass{native: native}

	return instance
}

/*
CastToGestureZoomClass down casts any arbitrary Object to GestureZoomClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GestureZoomClass.
*/
func CastToGestureZoomClass(object *gobject.Object) *GestureZoomClass {
	return GestureZoomClassNewFromNative(object.Native())
}

// Equals compares this GestureZoomClass with another GestureZoomClass, and returns true if they represent the same Object.
func (recv *GestureZoomClass) Equals(other *GestureZoomClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GestureZoomClass) Native() unsafe.Pointer {
	return recv.native
}

// GestureZoomClassStruct creates an uninitialised GestureZoomClass.
func GestureZoomClassStruct() *GestureZoomClass {
	err := gestureZoomClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GestureZoomClassNewFromNative(gestureZoomClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGestureZoomClass)
	return structGo
}
func finalizeGestureZoomClass(obj *GestureZoomClass) {
	gestureZoomClassStruct.Free(obj.Native())
}

var gradientStruct *gi.Struct
var gradientStruct_Once sync.Once

func gradientStruct_Set() error {
	var err error
	gradientStruct_Once.Do(func() {
		gradientStruct, err = gi.StructNew("Gtk", "Gradient")
	})
	return err
}

type Gradient struct {
	native unsafe.Pointer
}

func GradientNewFromNative(native unsafe.Pointer) *Gradient {
	err := gradientStruct_Set()
	if err != nil {
		return nil
	}

	instance := &Gradient{native: native}

	return instance
}

/*
CastToGradient down casts any arbitrary Object to Gradient.
Exercise care, as this is a potentially dangerous function
if the Object is not a Gradient.
*/
func CastToGradient(object *gobject.Object) *Gradient {
	return GradientNewFromNative(object.Native())
}

// Equals compares this Gradient with another Gradient, and returns true if they represent the same Object.
func (recv *Gradient) Equals(other *Gradient) bool {
	return other.Native() == recv.Native()
}

func (recv *Gradient) Native() unsafe.Pointer {
	return recv.native
}

var gradientNewLinearFunction *gi.Function
var gradientNewLinearFunction_Once sync.Once

func gradientNewLinearFunction_Set() error {
	var err error
	gradientNewLinearFunction_Once.Do(func() {
		err = gradientStruct_Set()
		if err != nil {
			return
		}
		gradientNewLinearFunction, err = gradientStruct.InvokerNew("new_linear")
	})
	return err
}

// GradientNewLinear is a representation of the C type gtk_gradient_new_linear.
func GradientNewLinear(x0 float64, y0 float64, x1 float64, y1 float64) *Gradient {
	var inArgs [4]gi.Argument
	inArgs[0].SetFloat64(x0)
	inArgs[1].SetFloat64(y0)
	inArgs[2].SetFloat64(x1)
	inArgs[3].SetFloat64(y1)

	var ret gi.Argument

	err := gradientNewLinearFunction_Set()
	if err == nil {
		ret = gradientNewLinearFunction.Invoke(inArgs[:], nil)
	}

	retGo := GradientNewFromNative(ret.Pointer())

	return retGo
}

var gradientNewRadialFunction *gi.Function
var gradientNewRadialFunction_Once sync.Once

func gradientNewRadialFunction_Set() error {
	var err error
	gradientNewRadialFunction_Once.Do(func() {
		err = gradientStruct_Set()
		if err != nil {
			return
		}
		gradientNewRadialFunction, err = gradientStruct.InvokerNew("new_radial")
	})
	return err
}

// GradientNewRadial is a representation of the C type gtk_gradient_new_radial.
func GradientNewRadial(x0 float64, y0 float64, radius0 float64, x1 float64, y1 float64, radius1 float64) *Gradient {
	var inArgs [6]gi.Argument
	inArgs[0].SetFloat64(x0)
	inArgs[1].SetFloat64(y0)
	inArgs[2].SetFloat64(radius0)
	inArgs[3].SetFloat64(x1)
	inArgs[4].SetFloat64(y1)
	inArgs[5].SetFloat64(radius1)

	var ret gi.Argument

	err := gradientNewRadialFunction_Set()
	if err == nil {
		ret = gradientNewRadialFunction.Invoke(inArgs[:], nil)
	}

	retGo := GradientNewFromNative(ret.Pointer())

	return retGo
}

var gradientAddColorStopFunction *gi.Function
var gradientAddColorStopFunction_Once sync.Once

func gradientAddColorStopFunction_Set() error {
	var err error
	gradientAddColorStopFunction_Once.Do(func() {
		err = gradientStruct_Set()
		if err != nil {
			return
		}
		gradientAddColorStopFunction, err = gradientStruct.InvokerNew("add_color_stop")
	})
	return err
}

// AddColorStop is a representation of the C type gtk_gradient_add_color_stop.
func (recv *Gradient) AddColorStop(offset float64, color *SymbolicColor) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetFloat64(offset)
	inArgs[2].SetPointer(color.Native())

	err := gradientAddColorStopFunction_Set()
	if err == nil {
		gradientAddColorStopFunction.Invoke(inArgs[:], nil)
	}

	return
}

var gradientRefFunction *gi.Function
var gradientRefFunction_Once sync.Once

func gradientRefFunction_Set() error {
	var err error
	gradientRefFunction_Once.Do(func() {
		err = gradientStruct_Set()
		if err != nil {
			return
		}
		gradientRefFunction, err = gradientStruct.InvokerNew("ref")
	})
	return err
}

// Ref is a representation of the C type gtk_gradient_ref.
func (recv *Gradient) Ref() *Gradient {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := gradientRefFunction_Set()
	if err == nil {
		ret = gradientRefFunction.Invoke(inArgs[:], nil)
	}

	retGo := GradientNewFromNative(ret.Pointer())

	return retGo
}

var gradientResolveFunction *gi.Function
var gradientResolveFunction_Once sync.Once

func gradientResolveFunction_Set() error {
	var err error
	gradientResolveFunction_Once.Do(func() {
		err = gradientStruct_Set()
		if err != nil {
			return
		}
		gradientResolveFunction, err = gradientStruct.InvokerNew("resolve")
	})
	return err
}

// Resolve is a representation of the C type gtk_gradient_resolve.
func (recv *Gradient) Resolve(props *StyleProperties) (bool, *cairo.Pattern) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(props.Native())

	var outArgs [1]gi.Argument
	var ret gi.Argument

	err := gradientResolveFunction_Set()
	if err == nil {
		ret = gradientResolveFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := cairo.PatternNewFromNative(outArgs[0].Pointer())

	return retGo, out0
}

var gradientResolveForContextFunction *gi.Function
var gradientResolveForContextFunction_Once sync.Once

func gradientResolveForContextFunction_Set() error {
	var err error
	gradientResolveForContextFunction_Once.Do(func() {
		err = gradientStruct_Set()
		if err != nil {
			return
		}
		gradientResolveForContextFunction, err = gradientStruct.InvokerNew("resolve_for_context")
	})
	return err
}

// ResolveForContext is a representation of the C type gtk_gradient_resolve_for_context.
func (recv *Gradient) ResolveForContext(context *StyleContext) *cairo.Pattern {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(context.Native())

	var ret gi.Argument

	err := gradientResolveForContextFunction_Set()
	if err == nil {
		ret = gradientResolveForContextFunction.Invoke(inArgs[:], nil)
	}

	retGo := cairo.PatternNewFromNative(ret.Pointer())

	return retGo
}

var gradientToStringFunction *gi.Function
var gradientToStringFunction_Once sync.Once

func gradientToStringFunction_Set() error {
	var err error
	gradientToStringFunction_Once.Do(func() {
		err = gradientStruct_Set()
		if err != nil {
			return
		}
		gradientToStringFunction, err = gradientStruct.InvokerNew("to_string")
	})
	return err
}

// ToString is a representation of the C type gtk_gradient_to_string.
func (recv *Gradient) ToString() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := gradientToStringFunction_Set()
	if err == nil {
		ret = gradientToStringFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var gradientUnrefFunction *gi.Function
var gradientUnrefFunction_Once sync.Once

func gradientUnrefFunction_Set() error {
	var err error
	gradientUnrefFunction_Once.Do(func() {
		err = gradientStruct_Set()
		if err != nil {
			return
		}
		gradientUnrefFunction, err = gradientStruct.InvokerNew("unref")
	})
	return err
}

// Unref is a representation of the C type gtk_gradient_unref.
func (recv *Gradient) Unref() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := gradientUnrefFunction_Set()
	if err == nil {
		gradientUnrefFunction.Invoke(inArgs[:], nil)
	}

	return
}

var gridClassStruct *gi.Struct
var gridClassStruct_Once sync.Once

func gridClassStruct_Set() error {
	var err error
	gridClassStruct_Once.Do(func() {
		gridClassStruct, err = gi.StructNew("Gtk", "GridClass")
	})
	return err
}

type GridClass struct {
	native unsafe.Pointer
}

func GridClassNewFromNative(native unsafe.Pointer) *GridClass {
	err := gridClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GridClass{native: native}

	return instance
}

/*
CastToGridClass down casts any arbitrary Object to GridClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a GridClass.
*/
func CastToGridClass(object *gobject.Object) *GridClass {
	return GridClassNewFromNative(object.Native())
}

// Equals compares this GridClass with another GridClass, and returns true if they represent the same Object.
func (recv *GridClass) Equals(other *GridClass) bool {
	return other.Native() == recv.Native()
}

func (recv *GridClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *GridClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(gridClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *GridClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(gridClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// GridClassStruct creates an uninitialised GridClass.
func GridClassStruct() *GridClass {
	err := gridClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GridClassNewFromNative(gridClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGridClass)
	return structGo
}
func finalizeGridClass(obj *GridClass) {
	gridClassStruct.Free(obj.Native())
}

var gridPrivateStruct *gi.Struct
var gridPrivateStruct_Once sync.Once

func gridPrivateStruct_Set() error {
	var err error
	gridPrivateStruct_Once.Do(func() {
		gridPrivateStruct, err = gi.StructNew("Gtk", "GridPrivate")
	})
	return err
}

type GridPrivate struct {
	native unsafe.Pointer
}

func GridPrivateNewFromNative(native unsafe.Pointer) *GridPrivate {
	err := gridPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &GridPrivate{native: native}

	return instance
}

/*
CastToGridPrivate down casts any arbitrary Object to GridPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a GridPrivate.
*/
func CastToGridPrivate(object *gobject.Object) *GridPrivate {
	return GridPrivateNewFromNative(object.Native())
}

// Equals compares this GridPrivate with another GridPrivate, and returns true if they represent the same Object.
func (recv *GridPrivate) Equals(other *GridPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *GridPrivate) Native() unsafe.Pointer {
	return recv.native
}

// GridPrivateStruct creates an uninitialised GridPrivate.
func GridPrivateStruct() *GridPrivate {
	err := gridPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := GridPrivateNewFromNative(gridPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeGridPrivate)
	return structGo
}
func finalizeGridPrivate(obj *GridPrivate) {
	gridPrivateStruct.Free(obj.Native())
}

var hBoxClassStruct *gi.Struct
var hBoxClassStruct_Once sync.Once

func hBoxClassStruct_Set() error {
	var err error
	hBoxClassStruct_Once.Do(func() {
		hBoxClassStruct, err = gi.StructNew("Gtk", "HBoxClass")
	})
	return err
}

type HBoxClass struct {
	native unsafe.Pointer
}

func HBoxClassNewFromNative(native unsafe.Pointer) *HBoxClass {
	err := hBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HBoxClass{native: native}

	return instance
}

/*
CastToHBoxClass down casts any arbitrary Object to HBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HBoxClass.
*/
func CastToHBoxClass(object *gobject.Object) *HBoxClass {
	return HBoxClassNewFromNative(object.Native())
}

// Equals compares this HBoxClass with another HBoxClass, and returns true if they represent the same Object.
func (recv *HBoxClass) Equals(other *HBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HBoxClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(hBoxClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HBoxClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(hBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// HBoxClassStruct creates an uninitialised HBoxClass.
func HBoxClassStruct() *HBoxClass {
	err := hBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HBoxClassNewFromNative(hBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHBoxClass)
	return structGo
}
func finalizeHBoxClass(obj *HBoxClass) {
	hBoxClassStruct.Free(obj.Native())
}

var hButtonBoxClassStruct *gi.Struct
var hButtonBoxClassStruct_Once sync.Once

func hButtonBoxClassStruct_Set() error {
	var err error
	hButtonBoxClassStruct_Once.Do(func() {
		hButtonBoxClassStruct, err = gi.StructNew("Gtk", "HButtonBoxClass")
	})
	return err
}

type HButtonBoxClass struct {
	native unsafe.Pointer
}

func HButtonBoxClassNewFromNative(native unsafe.Pointer) *HButtonBoxClass {
	err := hButtonBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HButtonBoxClass{native: native}

	return instance
}

/*
CastToHButtonBoxClass down casts any arbitrary Object to HButtonBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HButtonBoxClass.
*/
func CastToHButtonBoxClass(object *gobject.Object) *HButtonBoxClass {
	return HButtonBoxClassNewFromNative(object.Native())
}

// Equals compares this HButtonBoxClass with another HButtonBoxClass, and returns true if they represent the same Object.
func (recv *HButtonBoxClass) Equals(other *HButtonBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HButtonBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HButtonBoxClass) FieldParentClass() *ButtonBoxClass {
	argValue := gi.StructFieldGet(hButtonBoxClassStruct, recv.Native(), "parent_class")
	value := ButtonBoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HButtonBoxClass) SetFieldParentClass(value *ButtonBoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(hButtonBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// HButtonBoxClassStruct creates an uninitialised HButtonBoxClass.
func HButtonBoxClassStruct() *HButtonBoxClass {
	err := hButtonBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HButtonBoxClassNewFromNative(hButtonBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHButtonBoxClass)
	return structGo
}
func finalizeHButtonBoxClass(obj *HButtonBoxClass) {
	hButtonBoxClassStruct.Free(obj.Native())
}

var hPanedClassStruct *gi.Struct
var hPanedClassStruct_Once sync.Once

func hPanedClassStruct_Set() error {
	var err error
	hPanedClassStruct_Once.Do(func() {
		hPanedClassStruct, err = gi.StructNew("Gtk", "HPanedClass")
	})
	return err
}

type HPanedClass struct {
	native unsafe.Pointer
}

func HPanedClassNewFromNative(native unsafe.Pointer) *HPanedClass {
	err := hPanedClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HPanedClass{native: native}

	return instance
}

/*
CastToHPanedClass down casts any arbitrary Object to HPanedClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HPanedClass.
*/
func CastToHPanedClass(object *gobject.Object) *HPanedClass {
	return HPanedClassNewFromNative(object.Native())
}

// Equals compares this HPanedClass with another HPanedClass, and returns true if they represent the same Object.
func (recv *HPanedClass) Equals(other *HPanedClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HPanedClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HPanedClass) FieldParentClass() *PanedClass {
	argValue := gi.StructFieldGet(hPanedClassStruct, recv.Native(), "parent_class")
	value := PanedClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HPanedClass) SetFieldParentClass(value *PanedClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(hPanedClassStruct, recv.Native(), "parent_class", argValue)
}

// HPanedClassStruct creates an uninitialised HPanedClass.
func HPanedClassStruct() *HPanedClass {
	err := hPanedClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HPanedClassNewFromNative(hPanedClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHPanedClass)
	return structGo
}
func finalizeHPanedClass(obj *HPanedClass) {
	hPanedClassStruct.Free(obj.Native())
}

var hSVClassStruct *gi.Struct
var hSVClassStruct_Once sync.Once

func hSVClassStruct_Set() error {
	var err error
	hSVClassStruct_Once.Do(func() {
		hSVClassStruct, err = gi.StructNew("Gtk", "HSVClass")
	})
	return err
}

type HSVClass struct {
	native unsafe.Pointer
}

func HSVClassNewFromNative(native unsafe.Pointer) *HSVClass {
	err := hSVClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HSVClass{native: native}

	return instance
}

/*
CastToHSVClass down casts any arbitrary Object to HSVClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HSVClass.
*/
func CastToHSVClass(object *gobject.Object) *HSVClass {
	return HSVClassNewFromNative(object.Native())
}

// Equals compares this HSVClass with another HSVClass, and returns true if they represent the same Object.
func (recv *HSVClass) Equals(other *HSVClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HSVClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HSVClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(hSVClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HSVClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(hSVClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value 'move' : for field getter : missing Type

// UNSUPPORTED : C value 'move' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// HSVClassStruct creates an uninitialised HSVClass.
func HSVClassStruct() *HSVClass {
	err := hSVClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HSVClassNewFromNative(hSVClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHSVClass)
	return structGo
}
func finalizeHSVClass(obj *HSVClass) {
	hSVClassStruct.Free(obj.Native())
}

var hSVPrivateStruct *gi.Struct
var hSVPrivateStruct_Once sync.Once

func hSVPrivateStruct_Set() error {
	var err error
	hSVPrivateStruct_Once.Do(func() {
		hSVPrivateStruct, err = gi.StructNew("Gtk", "HSVPrivate")
	})
	return err
}

type HSVPrivate struct {
	native unsafe.Pointer
}

func HSVPrivateNewFromNative(native unsafe.Pointer) *HSVPrivate {
	err := hSVPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HSVPrivate{native: native}

	return instance
}

/*
CastToHSVPrivate down casts any arbitrary Object to HSVPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a HSVPrivate.
*/
func CastToHSVPrivate(object *gobject.Object) *HSVPrivate {
	return HSVPrivateNewFromNative(object.Native())
}

// Equals compares this HSVPrivate with another HSVPrivate, and returns true if they represent the same Object.
func (recv *HSVPrivate) Equals(other *HSVPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *HSVPrivate) Native() unsafe.Pointer {
	return recv.native
}

// HSVPrivateStruct creates an uninitialised HSVPrivate.
func HSVPrivateStruct() *HSVPrivate {
	err := hSVPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HSVPrivateNewFromNative(hSVPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHSVPrivate)
	return structGo
}
func finalizeHSVPrivate(obj *HSVPrivate) {
	hSVPrivateStruct.Free(obj.Native())
}

var hScaleClassStruct *gi.Struct
var hScaleClassStruct_Once sync.Once

func hScaleClassStruct_Set() error {
	var err error
	hScaleClassStruct_Once.Do(func() {
		hScaleClassStruct, err = gi.StructNew("Gtk", "HScaleClass")
	})
	return err
}

type HScaleClass struct {
	native unsafe.Pointer
}

func HScaleClassNewFromNative(native unsafe.Pointer) *HScaleClass {
	err := hScaleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HScaleClass{native: native}

	return instance
}

/*
CastToHScaleClass down casts any arbitrary Object to HScaleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HScaleClass.
*/
func CastToHScaleClass(object *gobject.Object) *HScaleClass {
	return HScaleClassNewFromNative(object.Native())
}

// Equals compares this HScaleClass with another HScaleClass, and returns true if they represent the same Object.
func (recv *HScaleClass) Equals(other *HScaleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HScaleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HScaleClass) FieldParentClass() *ScaleClass {
	argValue := gi.StructFieldGet(hScaleClassStruct, recv.Native(), "parent_class")
	value := ScaleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HScaleClass) SetFieldParentClass(value *ScaleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(hScaleClassStruct, recv.Native(), "parent_class", argValue)
}

// HScaleClassStruct creates an uninitialised HScaleClass.
func HScaleClassStruct() *HScaleClass {
	err := hScaleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HScaleClassNewFromNative(hScaleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHScaleClass)
	return structGo
}
func finalizeHScaleClass(obj *HScaleClass) {
	hScaleClassStruct.Free(obj.Native())
}

var hScrollbarClassStruct *gi.Struct
var hScrollbarClassStruct_Once sync.Once

func hScrollbarClassStruct_Set() error {
	var err error
	hScrollbarClassStruct_Once.Do(func() {
		hScrollbarClassStruct, err = gi.StructNew("Gtk", "HScrollbarClass")
	})
	return err
}

type HScrollbarClass struct {
	native unsafe.Pointer
}

func HScrollbarClassNewFromNative(native unsafe.Pointer) *HScrollbarClass {
	err := hScrollbarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HScrollbarClass{native: native}

	return instance
}

/*
CastToHScrollbarClass down casts any arbitrary Object to HScrollbarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HScrollbarClass.
*/
func CastToHScrollbarClass(object *gobject.Object) *HScrollbarClass {
	return HScrollbarClassNewFromNative(object.Native())
}

// Equals compares this HScrollbarClass with another HScrollbarClass, and returns true if they represent the same Object.
func (recv *HScrollbarClass) Equals(other *HScrollbarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HScrollbarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HScrollbarClass) FieldParentClass() *ScrollbarClass {
	argValue := gi.StructFieldGet(hScrollbarClassStruct, recv.Native(), "parent_class")
	value := ScrollbarClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HScrollbarClass) SetFieldParentClass(value *ScrollbarClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(hScrollbarClassStruct, recv.Native(), "parent_class", argValue)
}

// HScrollbarClassStruct creates an uninitialised HScrollbarClass.
func HScrollbarClassStruct() *HScrollbarClass {
	err := hScrollbarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HScrollbarClassNewFromNative(hScrollbarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHScrollbarClass)
	return structGo
}
func finalizeHScrollbarClass(obj *HScrollbarClass) {
	hScrollbarClassStruct.Free(obj.Native())
}

var hSeparatorClassStruct *gi.Struct
var hSeparatorClassStruct_Once sync.Once

func hSeparatorClassStruct_Set() error {
	var err error
	hSeparatorClassStruct_Once.Do(func() {
		hSeparatorClassStruct, err = gi.StructNew("Gtk", "HSeparatorClass")
	})
	return err
}

type HSeparatorClass struct {
	native unsafe.Pointer
}

func HSeparatorClassNewFromNative(native unsafe.Pointer) *HSeparatorClass {
	err := hSeparatorClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HSeparatorClass{native: native}

	return instance
}

/*
CastToHSeparatorClass down casts any arbitrary Object to HSeparatorClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HSeparatorClass.
*/
func CastToHSeparatorClass(object *gobject.Object) *HSeparatorClass {
	return HSeparatorClassNewFromNative(object.Native())
}

// Equals compares this HSeparatorClass with another HSeparatorClass, and returns true if they represent the same Object.
func (recv *HSeparatorClass) Equals(other *HSeparatorClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HSeparatorClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HSeparatorClass) FieldParentClass() *SeparatorClass {
	argValue := gi.StructFieldGet(hSeparatorClassStruct, recv.Native(), "parent_class")
	value := SeparatorClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HSeparatorClass) SetFieldParentClass(value *SeparatorClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(hSeparatorClassStruct, recv.Native(), "parent_class", argValue)
}

// HSeparatorClassStruct creates an uninitialised HSeparatorClass.
func HSeparatorClassStruct() *HSeparatorClass {
	err := hSeparatorClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HSeparatorClassNewFromNative(hSeparatorClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHSeparatorClass)
	return structGo
}
func finalizeHSeparatorClass(obj *HSeparatorClass) {
	hSeparatorClassStruct.Free(obj.Native())
}

var handleBoxClassStruct *gi.Struct
var handleBoxClassStruct_Once sync.Once

func handleBoxClassStruct_Set() error {
	var err error
	handleBoxClassStruct_Once.Do(func() {
		handleBoxClassStruct, err = gi.StructNew("Gtk", "HandleBoxClass")
	})
	return err
}

type HandleBoxClass struct {
	native unsafe.Pointer
}

func HandleBoxClassNewFromNative(native unsafe.Pointer) *HandleBoxClass {
	err := handleBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HandleBoxClass{native: native}

	return instance
}

/*
CastToHandleBoxClass down casts any arbitrary Object to HandleBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HandleBoxClass.
*/
func CastToHandleBoxClass(object *gobject.Object) *HandleBoxClass {
	return HandleBoxClassNewFromNative(object.Native())
}

// Equals compares this HandleBoxClass with another HandleBoxClass, and returns true if they represent the same Object.
func (recv *HandleBoxClass) Equals(other *HandleBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HandleBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HandleBoxClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(handleBoxClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HandleBoxClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(handleBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'child_attached' : for field getter : missing Type

// UNSUPPORTED : C value 'child_attached' : for field setter : missing Type

// UNSUPPORTED : C value 'child_detached' : for field getter : missing Type

// UNSUPPORTED : C value 'child_detached' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// HandleBoxClassStruct creates an uninitialised HandleBoxClass.
func HandleBoxClassStruct() *HandleBoxClass {
	err := handleBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HandleBoxClassNewFromNative(handleBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHandleBoxClass)
	return structGo
}
func finalizeHandleBoxClass(obj *HandleBoxClass) {
	handleBoxClassStruct.Free(obj.Native())
}

var handleBoxPrivateStruct *gi.Struct
var handleBoxPrivateStruct_Once sync.Once

func handleBoxPrivateStruct_Set() error {
	var err error
	handleBoxPrivateStruct_Once.Do(func() {
		handleBoxPrivateStruct, err = gi.StructNew("Gtk", "HandleBoxPrivate")
	})
	return err
}

type HandleBoxPrivate struct {
	native unsafe.Pointer
}

func HandleBoxPrivateNewFromNative(native unsafe.Pointer) *HandleBoxPrivate {
	err := handleBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HandleBoxPrivate{native: native}

	return instance
}

/*
CastToHandleBoxPrivate down casts any arbitrary Object to HandleBoxPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a HandleBoxPrivate.
*/
func CastToHandleBoxPrivate(object *gobject.Object) *HandleBoxPrivate {
	return HandleBoxPrivateNewFromNative(object.Native())
}

// Equals compares this HandleBoxPrivate with another HandleBoxPrivate, and returns true if they represent the same Object.
func (recv *HandleBoxPrivate) Equals(other *HandleBoxPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *HandleBoxPrivate) Native() unsafe.Pointer {
	return recv.native
}

// HandleBoxPrivateStruct creates an uninitialised HandleBoxPrivate.
func HandleBoxPrivateStruct() *HandleBoxPrivate {
	err := handleBoxPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HandleBoxPrivateNewFromNative(handleBoxPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHandleBoxPrivate)
	return structGo
}
func finalizeHandleBoxPrivate(obj *HandleBoxPrivate) {
	handleBoxPrivateStruct.Free(obj.Native())
}

var headerBarAccessibleClassStruct *gi.Struct
var headerBarAccessibleClassStruct_Once sync.Once

func headerBarAccessibleClassStruct_Set() error {
	var err error
	headerBarAccessibleClassStruct_Once.Do(func() {
		headerBarAccessibleClassStruct, err = gi.StructNew("Gtk", "HeaderBarAccessibleClass")
	})
	return err
}

type HeaderBarAccessibleClass struct {
	native unsafe.Pointer
}

func HeaderBarAccessibleClassNewFromNative(native unsafe.Pointer) *HeaderBarAccessibleClass {
	err := headerBarAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HeaderBarAccessibleClass{native: native}

	return instance
}

/*
CastToHeaderBarAccessibleClass down casts any arbitrary Object to HeaderBarAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HeaderBarAccessibleClass.
*/
func CastToHeaderBarAccessibleClass(object *gobject.Object) *HeaderBarAccessibleClass {
	return HeaderBarAccessibleClassNewFromNative(object.Native())
}

// Equals compares this HeaderBarAccessibleClass with another HeaderBarAccessibleClass, and returns true if they represent the same Object.
func (recv *HeaderBarAccessibleClass) Equals(other *HeaderBarAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HeaderBarAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HeaderBarAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(headerBarAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HeaderBarAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(headerBarAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// HeaderBarAccessibleClassStruct creates an uninitialised HeaderBarAccessibleClass.
func HeaderBarAccessibleClassStruct() *HeaderBarAccessibleClass {
	err := headerBarAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HeaderBarAccessibleClassNewFromNative(headerBarAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHeaderBarAccessibleClass)
	return structGo
}
func finalizeHeaderBarAccessibleClass(obj *HeaderBarAccessibleClass) {
	headerBarAccessibleClassStruct.Free(obj.Native())
}

var headerBarAccessiblePrivateStruct *gi.Struct
var headerBarAccessiblePrivateStruct_Once sync.Once

func headerBarAccessiblePrivateStruct_Set() error {
	var err error
	headerBarAccessiblePrivateStruct_Once.Do(func() {
		headerBarAccessiblePrivateStruct, err = gi.StructNew("Gtk", "HeaderBarAccessiblePrivate")
	})
	return err
}

type HeaderBarAccessiblePrivate struct {
	native unsafe.Pointer
}

func HeaderBarAccessiblePrivateNewFromNative(native unsafe.Pointer) *HeaderBarAccessiblePrivate {
	err := headerBarAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HeaderBarAccessiblePrivate{native: native}

	return instance
}

/*
CastToHeaderBarAccessiblePrivate down casts any arbitrary Object to HeaderBarAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a HeaderBarAccessiblePrivate.
*/
func CastToHeaderBarAccessiblePrivate(object *gobject.Object) *HeaderBarAccessiblePrivate {
	return HeaderBarAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this HeaderBarAccessiblePrivate with another HeaderBarAccessiblePrivate, and returns true if they represent the same Object.
func (recv *HeaderBarAccessiblePrivate) Equals(other *HeaderBarAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *HeaderBarAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// HeaderBarAccessiblePrivateStruct creates an uninitialised HeaderBarAccessiblePrivate.
func HeaderBarAccessiblePrivateStruct() *HeaderBarAccessiblePrivate {
	err := headerBarAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HeaderBarAccessiblePrivateNewFromNative(headerBarAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHeaderBarAccessiblePrivate)
	return structGo
}
func finalizeHeaderBarAccessiblePrivate(obj *HeaderBarAccessiblePrivate) {
	headerBarAccessiblePrivateStruct.Free(obj.Native())
}

var headerBarClassStruct *gi.Struct
var headerBarClassStruct_Once sync.Once

func headerBarClassStruct_Set() error {
	var err error
	headerBarClassStruct_Once.Do(func() {
		headerBarClassStruct, err = gi.StructNew("Gtk", "HeaderBarClass")
	})
	return err
}

type HeaderBarClass struct {
	native unsafe.Pointer
}

func HeaderBarClassNewFromNative(native unsafe.Pointer) *HeaderBarClass {
	err := headerBarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HeaderBarClass{native: native}

	return instance
}

/*
CastToHeaderBarClass down casts any arbitrary Object to HeaderBarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a HeaderBarClass.
*/
func CastToHeaderBarClass(object *gobject.Object) *HeaderBarClass {
	return HeaderBarClassNewFromNative(object.Native())
}

// Equals compares this HeaderBarClass with another HeaderBarClass, and returns true if they represent the same Object.
func (recv *HeaderBarClass) Equals(other *HeaderBarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *HeaderBarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *HeaderBarClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(headerBarClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *HeaderBarClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(headerBarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// HeaderBarClassStruct creates an uninitialised HeaderBarClass.
func HeaderBarClassStruct() *HeaderBarClass {
	err := headerBarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HeaderBarClassNewFromNative(headerBarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHeaderBarClass)
	return structGo
}
func finalizeHeaderBarClass(obj *HeaderBarClass) {
	headerBarClassStruct.Free(obj.Native())
}

var headerBarPrivateStruct *gi.Struct
var headerBarPrivateStruct_Once sync.Once

func headerBarPrivateStruct_Set() error {
	var err error
	headerBarPrivateStruct_Once.Do(func() {
		headerBarPrivateStruct, err = gi.StructNew("Gtk", "HeaderBarPrivate")
	})
	return err
}

type HeaderBarPrivate struct {
	native unsafe.Pointer
}

func HeaderBarPrivateNewFromNative(native unsafe.Pointer) *HeaderBarPrivate {
	err := headerBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &HeaderBarPrivate{native: native}

	return instance
}

/*
CastToHeaderBarPrivate down casts any arbitrary Object to HeaderBarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a HeaderBarPrivate.
*/
func CastToHeaderBarPrivate(object *gobject.Object) *HeaderBarPrivate {
	return HeaderBarPrivateNewFromNative(object.Native())
}

// Equals compares this HeaderBarPrivate with another HeaderBarPrivate, and returns true if they represent the same Object.
func (recv *HeaderBarPrivate) Equals(other *HeaderBarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *HeaderBarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// HeaderBarPrivateStruct creates an uninitialised HeaderBarPrivate.
func HeaderBarPrivateStruct() *HeaderBarPrivate {
	err := headerBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := HeaderBarPrivateNewFromNative(headerBarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeHeaderBarPrivate)
	return structGo
}
func finalizeHeaderBarPrivate(obj *HeaderBarPrivate) {
	headerBarPrivateStruct.Free(obj.Native())
}

var iMContextClassStruct *gi.Struct
var iMContextClassStruct_Once sync.Once

func iMContextClassStruct_Set() error {
	var err error
	iMContextClassStruct_Once.Do(func() {
		iMContextClassStruct, err = gi.StructNew("Gtk", "IMContextClass")
	})
	return err
}

type IMContextClass struct {
	native unsafe.Pointer
}

func IMContextClassNewFromNative(native unsafe.Pointer) *IMContextClass {
	err := iMContextClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IMContextClass{native: native}

	return instance
}

/*
CastToIMContextClass down casts any arbitrary Object to IMContextClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a IMContextClass.
*/
func CastToIMContextClass(object *gobject.Object) *IMContextClass {
	return IMContextClassNewFromNative(object.Native())
}

// Equals compares this IMContextClass with another IMContextClass, and returns true if they represent the same Object.
func (recv *IMContextClass) Equals(other *IMContextClass) bool {
	return other.Native() == recv.Native()
}

func (recv *IMContextClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'preedit_start' : for field getter : missing Type

// UNSUPPORTED : C value 'preedit_start' : for field setter : missing Type

// UNSUPPORTED : C value 'preedit_end' : for field getter : missing Type

// UNSUPPORTED : C value 'preedit_end' : for field setter : missing Type

// UNSUPPORTED : C value 'preedit_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'preedit_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'commit' : for field getter : missing Type

// UNSUPPORTED : C value 'commit' : for field setter : missing Type

// UNSUPPORTED : C value 'retrieve_surrounding' : for field getter : missing Type

// UNSUPPORTED : C value 'retrieve_surrounding' : for field setter : missing Type

// UNSUPPORTED : C value 'delete_surrounding' : for field getter : missing Type

// UNSUPPORTED : C value 'delete_surrounding' : for field setter : missing Type

// UNSUPPORTED : C value 'set_client_window' : for field getter : missing Type

// UNSUPPORTED : C value 'set_client_window' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preedit_string' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preedit_string' : for field setter : missing Type

// UNSUPPORTED : C value 'filter_keypress' : for field getter : missing Type

// UNSUPPORTED : C value 'filter_keypress' : for field setter : missing Type

// UNSUPPORTED : C value 'focus_in' : for field getter : missing Type

// UNSUPPORTED : C value 'focus_in' : for field setter : missing Type

// UNSUPPORTED : C value 'focus_out' : for field getter : missing Type

// UNSUPPORTED : C value 'focus_out' : for field setter : missing Type

// UNSUPPORTED : C value 'reset' : for field getter : missing Type

// UNSUPPORTED : C value 'reset' : for field setter : missing Type

// UNSUPPORTED : C value 'set_cursor_location' : for field getter : missing Type

// UNSUPPORTED : C value 'set_cursor_location' : for field setter : missing Type

// UNSUPPORTED : C value 'set_use_preedit' : for field getter : missing Type

// UNSUPPORTED : C value 'set_use_preedit' : for field setter : missing Type

// UNSUPPORTED : C value 'set_surrounding' : for field getter : missing Type

// UNSUPPORTED : C value 'set_surrounding' : for field setter : missing Type

// UNSUPPORTED : C value 'get_surrounding' : for field getter : missing Type

// UNSUPPORTED : C value 'get_surrounding' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// IMContextClassStruct creates an uninitialised IMContextClass.
func IMContextClassStruct() *IMContextClass {
	err := iMContextClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IMContextClassNewFromNative(iMContextClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIMContextClass)
	return structGo
}
func finalizeIMContextClass(obj *IMContextClass) {
	iMContextClassStruct.Free(obj.Native())
}

var iMContextInfoStruct *gi.Struct
var iMContextInfoStruct_Once sync.Once

func iMContextInfoStruct_Set() error {
	var err error
	iMContextInfoStruct_Once.Do(func() {
		iMContextInfoStruct, err = gi.StructNew("Gtk", "IMContextInfo")
	})
	return err
}

type IMContextInfo struct {
	native unsafe.Pointer
}

func IMContextInfoNewFromNative(native unsafe.Pointer) *IMContextInfo {
	err := iMContextInfoStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IMContextInfo{native: native}

	return instance
}

/*
CastToIMContextInfo down casts any arbitrary Object to IMContextInfo.
Exercise care, as this is a potentially dangerous function
if the Object is not a IMContextInfo.
*/
func CastToIMContextInfo(object *gobject.Object) *IMContextInfo {
	return IMContextInfoNewFromNative(object.Native())
}

// Equals compares this IMContextInfo with another IMContextInfo, and returns true if they represent the same Object.
func (recv *IMContextInfo) Equals(other *IMContextInfo) bool {
	return other.Native() == recv.Native()
}

func (recv *IMContextInfo) Native() unsafe.Pointer {
	return recv.native
}

// FieldContextId returns the C field 'context_id'.
func (recv *IMContextInfo) FieldContextId() string {
	argValue := gi.StructFieldGet(iMContextInfoStruct, recv.Native(), "context_id")
	value := argValue.String(false)
	return value
}

// SetFieldContextId sets the value of the C field 'context_id'.
func (recv *IMContextInfo) SetFieldContextId(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(iMContextInfoStruct, recv.Native(), "context_id", argValue)
}

// FieldContextName returns the C field 'context_name'.
func (recv *IMContextInfo) FieldContextName() string {
	argValue := gi.StructFieldGet(iMContextInfoStruct, recv.Native(), "context_name")
	value := argValue.String(false)
	return value
}

// SetFieldContextName sets the value of the C field 'context_name'.
func (recv *IMContextInfo) SetFieldContextName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(iMContextInfoStruct, recv.Native(), "context_name", argValue)
}

// FieldDomain returns the C field 'domain'.
func (recv *IMContextInfo) FieldDomain() string {
	argValue := gi.StructFieldGet(iMContextInfoStruct, recv.Native(), "domain")
	value := argValue.String(false)
	return value
}

// SetFieldDomain sets the value of the C field 'domain'.
func (recv *IMContextInfo) SetFieldDomain(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(iMContextInfoStruct, recv.Native(), "domain", argValue)
}

// FieldDomainDirname returns the C field 'domain_dirname'.
func (recv *IMContextInfo) FieldDomainDirname() string {
	argValue := gi.StructFieldGet(iMContextInfoStruct, recv.Native(), "domain_dirname")
	value := argValue.String(false)
	return value
}

// SetFieldDomainDirname sets the value of the C field 'domain_dirname'.
func (recv *IMContextInfo) SetFieldDomainDirname(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(iMContextInfoStruct, recv.Native(), "domain_dirname", argValue)
}

// FieldDefaultLocales returns the C field 'default_locales'.
func (recv *IMContextInfo) FieldDefaultLocales() string {
	argValue := gi.StructFieldGet(iMContextInfoStruct, recv.Native(), "default_locales")
	value := argValue.String(false)
	return value
}

// SetFieldDefaultLocales sets the value of the C field 'default_locales'.
func (recv *IMContextInfo) SetFieldDefaultLocales(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(iMContextInfoStruct, recv.Native(), "default_locales", argValue)
}

// IMContextInfoStruct creates an uninitialised IMContextInfo.
func IMContextInfoStruct() *IMContextInfo {
	err := iMContextInfoStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IMContextInfoNewFromNative(iMContextInfoStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIMContextInfo)
	return structGo
}
func finalizeIMContextInfo(obj *IMContextInfo) {
	iMContextInfoStruct.Free(obj.Native())
}

var iMContextSimpleClassStruct *gi.Struct
var iMContextSimpleClassStruct_Once sync.Once

func iMContextSimpleClassStruct_Set() error {
	var err error
	iMContextSimpleClassStruct_Once.Do(func() {
		iMContextSimpleClassStruct, err = gi.StructNew("Gtk", "IMContextSimpleClass")
	})
	return err
}

type IMContextSimpleClass struct {
	native unsafe.Pointer
}

func IMContextSimpleClassNewFromNative(native unsafe.Pointer) *IMContextSimpleClass {
	err := iMContextSimpleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IMContextSimpleClass{native: native}

	return instance
}

/*
CastToIMContextSimpleClass down casts any arbitrary Object to IMContextSimpleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a IMContextSimpleClass.
*/
func CastToIMContextSimpleClass(object *gobject.Object) *IMContextSimpleClass {
	return IMContextSimpleClassNewFromNative(object.Native())
}

// Equals compares this IMContextSimpleClass with another IMContextSimpleClass, and returns true if they represent the same Object.
func (recv *IMContextSimpleClass) Equals(other *IMContextSimpleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *IMContextSimpleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *IMContextSimpleClass) FieldParentClass() *IMContextClass {
	argValue := gi.StructFieldGet(iMContextSimpleClassStruct, recv.Native(), "parent_class")
	value := IMContextClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *IMContextSimpleClass) SetFieldParentClass(value *IMContextClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(iMContextSimpleClassStruct, recv.Native(), "parent_class", argValue)
}

// IMContextSimpleClassStruct creates an uninitialised IMContextSimpleClass.
func IMContextSimpleClassStruct() *IMContextSimpleClass {
	err := iMContextSimpleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IMContextSimpleClassNewFromNative(iMContextSimpleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIMContextSimpleClass)
	return structGo
}
func finalizeIMContextSimpleClass(obj *IMContextSimpleClass) {
	iMContextSimpleClassStruct.Free(obj.Native())
}

var iMContextSimplePrivateStruct *gi.Struct
var iMContextSimplePrivateStruct_Once sync.Once

func iMContextSimplePrivateStruct_Set() error {
	var err error
	iMContextSimplePrivateStruct_Once.Do(func() {
		iMContextSimplePrivateStruct, err = gi.StructNew("Gtk", "IMContextSimplePrivate")
	})
	return err
}

type IMContextSimplePrivate struct {
	native unsafe.Pointer
}

func IMContextSimplePrivateNewFromNative(native unsafe.Pointer) *IMContextSimplePrivate {
	err := iMContextSimplePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IMContextSimplePrivate{native: native}

	return instance
}

/*
CastToIMContextSimplePrivate down casts any arbitrary Object to IMContextSimplePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a IMContextSimplePrivate.
*/
func CastToIMContextSimplePrivate(object *gobject.Object) *IMContextSimplePrivate {
	return IMContextSimplePrivateNewFromNative(object.Native())
}

// Equals compares this IMContextSimplePrivate with another IMContextSimplePrivate, and returns true if they represent the same Object.
func (recv *IMContextSimplePrivate) Equals(other *IMContextSimplePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *IMContextSimplePrivate) Native() unsafe.Pointer {
	return recv.native
}

// IMContextSimplePrivateStruct creates an uninitialised IMContextSimplePrivate.
func IMContextSimplePrivateStruct() *IMContextSimplePrivate {
	err := iMContextSimplePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IMContextSimplePrivateNewFromNative(iMContextSimplePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIMContextSimplePrivate)
	return structGo
}
func finalizeIMContextSimplePrivate(obj *IMContextSimplePrivate) {
	iMContextSimplePrivateStruct.Free(obj.Native())
}

var iMMulticontextClassStruct *gi.Struct
var iMMulticontextClassStruct_Once sync.Once

func iMMulticontextClassStruct_Set() error {
	var err error
	iMMulticontextClassStruct_Once.Do(func() {
		iMMulticontextClassStruct, err = gi.StructNew("Gtk", "IMMulticontextClass")
	})
	return err
}

type IMMulticontextClass struct {
	native unsafe.Pointer
}

func IMMulticontextClassNewFromNative(native unsafe.Pointer) *IMMulticontextClass {
	err := iMMulticontextClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IMMulticontextClass{native: native}

	return instance
}

/*
CastToIMMulticontextClass down casts any arbitrary Object to IMMulticontextClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a IMMulticontextClass.
*/
func CastToIMMulticontextClass(object *gobject.Object) *IMMulticontextClass {
	return IMMulticontextClassNewFromNative(object.Native())
}

// Equals compares this IMMulticontextClass with another IMMulticontextClass, and returns true if they represent the same Object.
func (recv *IMMulticontextClass) Equals(other *IMMulticontextClass) bool {
	return other.Native() == recv.Native()
}

func (recv *IMMulticontextClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *IMMulticontextClass) FieldParentClass() *IMContextClass {
	argValue := gi.StructFieldGet(iMMulticontextClassStruct, recv.Native(), "parent_class")
	value := IMContextClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *IMMulticontextClass) SetFieldParentClass(value *IMContextClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(iMMulticontextClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// IMMulticontextClassStruct creates an uninitialised IMMulticontextClass.
func IMMulticontextClassStruct() *IMMulticontextClass {
	err := iMMulticontextClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IMMulticontextClassNewFromNative(iMMulticontextClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIMMulticontextClass)
	return structGo
}
func finalizeIMMulticontextClass(obj *IMMulticontextClass) {
	iMMulticontextClassStruct.Free(obj.Native())
}

var iMMulticontextPrivateStruct *gi.Struct
var iMMulticontextPrivateStruct_Once sync.Once

func iMMulticontextPrivateStruct_Set() error {
	var err error
	iMMulticontextPrivateStruct_Once.Do(func() {
		iMMulticontextPrivateStruct, err = gi.StructNew("Gtk", "IMMulticontextPrivate")
	})
	return err
}

type IMMulticontextPrivate struct {
	native unsafe.Pointer
}

func IMMulticontextPrivateNewFromNative(native unsafe.Pointer) *IMMulticontextPrivate {
	err := iMMulticontextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IMMulticontextPrivate{native: native}

	return instance
}

/*
CastToIMMulticontextPrivate down casts any arbitrary Object to IMMulticontextPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a IMMulticontextPrivate.
*/
func CastToIMMulticontextPrivate(object *gobject.Object) *IMMulticontextPrivate {
	return IMMulticontextPrivateNewFromNative(object.Native())
}

// Equals compares this IMMulticontextPrivate with another IMMulticontextPrivate, and returns true if they represent the same Object.
func (recv *IMMulticontextPrivate) Equals(other *IMMulticontextPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *IMMulticontextPrivate) Native() unsafe.Pointer {
	return recv.native
}

// IMMulticontextPrivateStruct creates an uninitialised IMMulticontextPrivate.
func IMMulticontextPrivateStruct() *IMMulticontextPrivate {
	err := iMMulticontextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IMMulticontextPrivateNewFromNative(iMMulticontextPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIMMulticontextPrivate)
	return structGo
}
func finalizeIMMulticontextPrivate(obj *IMMulticontextPrivate) {
	iMMulticontextPrivateStruct.Free(obj.Native())
}

var iconFactoryClassStruct *gi.Struct
var iconFactoryClassStruct_Once sync.Once

func iconFactoryClassStruct_Set() error {
	var err error
	iconFactoryClassStruct_Once.Do(func() {
		iconFactoryClassStruct, err = gi.StructNew("Gtk", "IconFactoryClass")
	})
	return err
}

type IconFactoryClass struct {
	native unsafe.Pointer
}

func IconFactoryClassNewFromNative(native unsafe.Pointer) *IconFactoryClass {
	err := iconFactoryClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconFactoryClass{native: native}

	return instance
}

/*
CastToIconFactoryClass down casts any arbitrary Object to IconFactoryClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconFactoryClass.
*/
func CastToIconFactoryClass(object *gobject.Object) *IconFactoryClass {
	return IconFactoryClassNewFromNative(object.Native())
}

// Equals compares this IconFactoryClass with another IconFactoryClass, and returns true if they represent the same Object.
func (recv *IconFactoryClass) Equals(other *IconFactoryClass) bool {
	return other.Native() == recv.Native()
}

func (recv *IconFactoryClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *IconFactoryClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(iconFactoryClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *IconFactoryClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(iconFactoryClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// IconFactoryClassStruct creates an uninitialised IconFactoryClass.
func IconFactoryClassStruct() *IconFactoryClass {
	err := iconFactoryClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconFactoryClassNewFromNative(iconFactoryClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconFactoryClass)
	return structGo
}
func finalizeIconFactoryClass(obj *IconFactoryClass) {
	iconFactoryClassStruct.Free(obj.Native())
}

var iconFactoryPrivateStruct *gi.Struct
var iconFactoryPrivateStruct_Once sync.Once

func iconFactoryPrivateStruct_Set() error {
	var err error
	iconFactoryPrivateStruct_Once.Do(func() {
		iconFactoryPrivateStruct, err = gi.StructNew("Gtk", "IconFactoryPrivate")
	})
	return err
}

type IconFactoryPrivate struct {
	native unsafe.Pointer
}

func IconFactoryPrivateNewFromNative(native unsafe.Pointer) *IconFactoryPrivate {
	err := iconFactoryPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconFactoryPrivate{native: native}

	return instance
}

/*
CastToIconFactoryPrivate down casts any arbitrary Object to IconFactoryPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconFactoryPrivate.
*/
func CastToIconFactoryPrivate(object *gobject.Object) *IconFactoryPrivate {
	return IconFactoryPrivateNewFromNative(object.Native())
}

// Equals compares this IconFactoryPrivate with another IconFactoryPrivate, and returns true if they represent the same Object.
func (recv *IconFactoryPrivate) Equals(other *IconFactoryPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *IconFactoryPrivate) Native() unsafe.Pointer {
	return recv.native
}

// IconFactoryPrivateStruct creates an uninitialised IconFactoryPrivate.
func IconFactoryPrivateStruct() *IconFactoryPrivate {
	err := iconFactoryPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconFactoryPrivateNewFromNative(iconFactoryPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconFactoryPrivate)
	return structGo
}
func finalizeIconFactoryPrivate(obj *IconFactoryPrivate) {
	iconFactoryPrivateStruct.Free(obj.Native())
}

var iconInfoClassStruct *gi.Struct
var iconInfoClassStruct_Once sync.Once

func iconInfoClassStruct_Set() error {
	var err error
	iconInfoClassStruct_Once.Do(func() {
		iconInfoClassStruct, err = gi.StructNew("Gtk", "IconInfoClass")
	})
	return err
}

type IconInfoClass struct {
	native unsafe.Pointer
}

func IconInfoClassNewFromNative(native unsafe.Pointer) *IconInfoClass {
	err := iconInfoClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconInfoClass{native: native}

	return instance
}

/*
CastToIconInfoClass down casts any arbitrary Object to IconInfoClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconInfoClass.
*/
func CastToIconInfoClass(object *gobject.Object) *IconInfoClass {
	return IconInfoClassNewFromNative(object.Native())
}

// Equals compares this IconInfoClass with another IconInfoClass, and returns true if they represent the same Object.
func (recv *IconInfoClass) Equals(other *IconInfoClass) bool {
	return other.Native() == recv.Native()
}

func (recv *IconInfoClass) Native() unsafe.Pointer {
	return recv.native
}

// IconInfoClassStruct creates an uninitialised IconInfoClass.
func IconInfoClassStruct() *IconInfoClass {
	err := iconInfoClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconInfoClassNewFromNative(iconInfoClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconInfoClass)
	return structGo
}
func finalizeIconInfoClass(obj *IconInfoClass) {
	iconInfoClassStruct.Free(obj.Native())
}

var iconSetStruct *gi.Struct
var iconSetStruct_Once sync.Once

func iconSetStruct_Set() error {
	var err error
	iconSetStruct_Once.Do(func() {
		iconSetStruct, err = gi.StructNew("Gtk", "IconSet")
	})
	return err
}

type IconSet struct {
	native unsafe.Pointer
}

func IconSetNewFromNative(native unsafe.Pointer) *IconSet {
	err := iconSetStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconSet{native: native}

	return instance
}

/*
CastToIconSet down casts any arbitrary Object to IconSet.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconSet.
*/
func CastToIconSet(object *gobject.Object) *IconSet {
	return IconSetNewFromNative(object.Native())
}

// Equals compares this IconSet with another IconSet, and returns true if they represent the same Object.
func (recv *IconSet) Equals(other *IconSet) bool {
	return other.Native() == recv.Native()
}

func (recv *IconSet) Native() unsafe.Pointer {
	return recv.native
}

var iconSetNewFunction *gi.Function
var iconSetNewFunction_Once sync.Once

func iconSetNewFunction_Set() error {
	var err error
	iconSetNewFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetNewFunction, err = iconSetStruct.InvokerNew("new")
	})
	return err
}

// IconSetNew is a representation of the C type gtk_icon_set_new.
func IconSetNew() *IconSet {

	var ret gi.Argument

	err := iconSetNewFunction_Set()
	if err == nil {
		ret = iconSetNewFunction.Invoke(nil, nil)
	}

	retGo := IconSetNewFromNative(ret.Pointer())

	return retGo
}

var iconSetNewFromPixbufFunction *gi.Function
var iconSetNewFromPixbufFunction_Once sync.Once

func iconSetNewFromPixbufFunction_Set() error {
	var err error
	iconSetNewFromPixbufFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetNewFromPixbufFunction, err = iconSetStruct.InvokerNew("new_from_pixbuf")
	})
	return err
}

// IconSetNewFromPixbuf is a representation of the C type gtk_icon_set_new_from_pixbuf.
func IconSetNewFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *IconSet {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(pixbuf.Native())

	var ret gi.Argument

	err := iconSetNewFromPixbufFunction_Set()
	if err == nil {
		ret = iconSetNewFromPixbufFunction.Invoke(inArgs[:], nil)
	}

	retGo := IconSetNewFromNative(ret.Pointer())

	return retGo
}

var iconSetAddSourceFunction *gi.Function
var iconSetAddSourceFunction_Once sync.Once

func iconSetAddSourceFunction_Set() error {
	var err error
	iconSetAddSourceFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetAddSourceFunction, err = iconSetStruct.InvokerNew("add_source")
	})
	return err
}

// AddSource is a representation of the C type gtk_icon_set_add_source.
func (recv *IconSet) AddSource(source *IconSource) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(source.Native())

	err := iconSetAddSourceFunction_Set()
	if err == nil {
		iconSetAddSourceFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSetCopyFunction *gi.Function
var iconSetCopyFunction_Once sync.Once

func iconSetCopyFunction_Set() error {
	var err error
	iconSetCopyFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetCopyFunction, err = iconSetStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_icon_set_copy.
func (recv *IconSet) Copy() *IconSet {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSetCopyFunction_Set()
	if err == nil {
		ret = iconSetCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := IconSetNewFromNative(ret.Pointer())

	return retGo
}

// UNSUPPORTED : C value 'gtk_icon_set_get_sizes' : array parameter 'sizes'

var iconSetRefFunction *gi.Function
var iconSetRefFunction_Once sync.Once

func iconSetRefFunction_Set() error {
	var err error
	iconSetRefFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetRefFunction, err = iconSetStruct.InvokerNew("ref")
	})
	return err
}

// Ref is a representation of the C type gtk_icon_set_ref.
func (recv *IconSet) Ref() *IconSet {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSetRefFunction_Set()
	if err == nil {
		ret = iconSetRefFunction.Invoke(inArgs[:], nil)
	}

	retGo := IconSetNewFromNative(ret.Pointer())

	return retGo
}

var iconSetRenderIconFunction *gi.Function
var iconSetRenderIconFunction_Once sync.Once

func iconSetRenderIconFunction_Set() error {
	var err error
	iconSetRenderIconFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetRenderIconFunction, err = iconSetStruct.InvokerNew("render_icon")
	})
	return err
}

// RenderIcon is a representation of the C type gtk_icon_set_render_icon.
func (recv *IconSet) RenderIcon(style *Style, direction TextDirection, state StateType, size IconSize, widget *Widget, detail string) *gdkpixbuf.Pixbuf {
	var inArgs [7]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(style.Native())
	inArgs[2].SetInt32(int32(direction))
	inArgs[3].SetInt32(int32(state))
	inArgs[4].SetInt32(int32(size))
	inArgs[5].SetPointer(widget.Native())
	inArgs[6].SetString(detail)

	var ret gi.Argument

	err := iconSetRenderIconFunction_Set()
	if err == nil {
		ret = iconSetRenderIconFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdkpixbuf.PixbufNewFromNative(ret.Pointer())

	return retGo
}

var iconSetRenderIconPixbufFunction *gi.Function
var iconSetRenderIconPixbufFunction_Once sync.Once

func iconSetRenderIconPixbufFunction_Set() error {
	var err error
	iconSetRenderIconPixbufFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetRenderIconPixbufFunction, err = iconSetStruct.InvokerNew("render_icon_pixbuf")
	})
	return err
}

// RenderIconPixbuf is a representation of the C type gtk_icon_set_render_icon_pixbuf.
func (recv *IconSet) RenderIconPixbuf(context *StyleContext, size IconSize) *gdkpixbuf.Pixbuf {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(context.Native())
	inArgs[2].SetInt32(int32(size))

	var ret gi.Argument

	err := iconSetRenderIconPixbufFunction_Set()
	if err == nil {
		ret = iconSetRenderIconPixbufFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdkpixbuf.PixbufNewFromNative(ret.Pointer())

	return retGo
}

var iconSetRenderIconSurfaceFunction *gi.Function
var iconSetRenderIconSurfaceFunction_Once sync.Once

func iconSetRenderIconSurfaceFunction_Set() error {
	var err error
	iconSetRenderIconSurfaceFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetRenderIconSurfaceFunction, err = iconSetStruct.InvokerNew("render_icon_surface")
	})
	return err
}

// RenderIconSurface is a representation of the C type gtk_icon_set_render_icon_surface.
func (recv *IconSet) RenderIconSurface(context *StyleContext, size IconSize, scale int32, forWindow *gdk.Window) *cairo.Surface {
	var inArgs [5]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(context.Native())
	inArgs[2].SetInt32(int32(size))
	inArgs[3].SetInt32(scale)
	inArgs[4].SetPointer(forWindow.Native())

	var ret gi.Argument

	err := iconSetRenderIconSurfaceFunction_Set()
	if err == nil {
		ret = iconSetRenderIconSurfaceFunction.Invoke(inArgs[:], nil)
	}

	retGo := cairo.SurfaceNewFromNative(ret.Pointer())

	return retGo
}

var iconSetUnrefFunction *gi.Function
var iconSetUnrefFunction_Once sync.Once

func iconSetUnrefFunction_Set() error {
	var err error
	iconSetUnrefFunction_Once.Do(func() {
		err = iconSetStruct_Set()
		if err != nil {
			return
		}
		iconSetUnrefFunction, err = iconSetStruct.InvokerNew("unref")
	})
	return err
}

// Unref is a representation of the C type gtk_icon_set_unref.
func (recv *IconSet) Unref() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := iconSetUnrefFunction_Set()
	if err == nil {
		iconSetUnrefFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceStruct *gi.Struct
var iconSourceStruct_Once sync.Once

func iconSourceStruct_Set() error {
	var err error
	iconSourceStruct_Once.Do(func() {
		iconSourceStruct, err = gi.StructNew("Gtk", "IconSource")
	})
	return err
}

type IconSource struct {
	native unsafe.Pointer
}

func IconSourceNewFromNative(native unsafe.Pointer) *IconSource {
	err := iconSourceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconSource{native: native}

	return instance
}

/*
CastToIconSource down casts any arbitrary Object to IconSource.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconSource.
*/
func CastToIconSource(object *gobject.Object) *IconSource {
	return IconSourceNewFromNative(object.Native())
}

// Equals compares this IconSource with another IconSource, and returns true if they represent the same Object.
func (recv *IconSource) Equals(other *IconSource) bool {
	return other.Native() == recv.Native()
}

func (recv *IconSource) Native() unsafe.Pointer {
	return recv.native
}

var iconSourceNewFunction *gi.Function
var iconSourceNewFunction_Once sync.Once

func iconSourceNewFunction_Set() error {
	var err error
	iconSourceNewFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceNewFunction, err = iconSourceStruct.InvokerNew("new")
	})
	return err
}

// IconSourceNew is a representation of the C type gtk_icon_source_new.
func IconSourceNew() *IconSource {

	var ret gi.Argument

	err := iconSourceNewFunction_Set()
	if err == nil {
		ret = iconSourceNewFunction.Invoke(nil, nil)
	}

	retGo := IconSourceNewFromNative(ret.Pointer())

	return retGo
}

var iconSourceCopyFunction *gi.Function
var iconSourceCopyFunction_Once sync.Once

func iconSourceCopyFunction_Set() error {
	var err error
	iconSourceCopyFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceCopyFunction, err = iconSourceStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_icon_source_copy.
func (recv *IconSource) Copy() *IconSource {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceCopyFunction_Set()
	if err == nil {
		ret = iconSourceCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := IconSourceNewFromNative(ret.Pointer())

	return retGo
}

var iconSourceFreeFunction *gi.Function
var iconSourceFreeFunction_Once sync.Once

func iconSourceFreeFunction_Set() error {
	var err error
	iconSourceFreeFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceFreeFunction, err = iconSourceStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_icon_source_free.
func (recv *IconSource) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := iconSourceFreeFunction_Set()
	if err == nil {
		iconSourceFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceGetDirectionFunction *gi.Function
var iconSourceGetDirectionFunction_Once sync.Once

func iconSourceGetDirectionFunction_Set() error {
	var err error
	iconSourceGetDirectionFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetDirectionFunction, err = iconSourceStruct.InvokerNew("get_direction")
	})
	return err
}

// GetDirection is a representation of the C type gtk_icon_source_get_direction.
func (recv *IconSource) GetDirection() TextDirection {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetDirectionFunction_Set()
	if err == nil {
		ret = iconSourceGetDirectionFunction.Invoke(inArgs[:], nil)
	}

	retGo := TextDirection(ret.Int32())

	return retGo
}

var iconSourceGetDirectionWildcardedFunction *gi.Function
var iconSourceGetDirectionWildcardedFunction_Once sync.Once

func iconSourceGetDirectionWildcardedFunction_Set() error {
	var err error
	iconSourceGetDirectionWildcardedFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetDirectionWildcardedFunction, err = iconSourceStruct.InvokerNew("get_direction_wildcarded")
	})
	return err
}

// GetDirectionWildcarded is a representation of the C type gtk_icon_source_get_direction_wildcarded.
func (recv *IconSource) GetDirectionWildcarded() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetDirectionWildcardedFunction_Set()
	if err == nil {
		ret = iconSourceGetDirectionWildcardedFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var iconSourceGetFilenameFunction *gi.Function
var iconSourceGetFilenameFunction_Once sync.Once

func iconSourceGetFilenameFunction_Set() error {
	var err error
	iconSourceGetFilenameFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetFilenameFunction, err = iconSourceStruct.InvokerNew("get_filename")
	})
	return err
}

// GetFilename is a representation of the C type gtk_icon_source_get_filename.
func (recv *IconSource) GetFilename() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetFilenameFunction_Set()
	if err == nil {
		ret = iconSourceGetFilenameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var iconSourceGetIconNameFunction *gi.Function
var iconSourceGetIconNameFunction_Once sync.Once

func iconSourceGetIconNameFunction_Set() error {
	var err error
	iconSourceGetIconNameFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetIconNameFunction, err = iconSourceStruct.InvokerNew("get_icon_name")
	})
	return err
}

// GetIconName is a representation of the C type gtk_icon_source_get_icon_name.
func (recv *IconSource) GetIconName() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetIconNameFunction_Set()
	if err == nil {
		ret = iconSourceGetIconNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var iconSourceGetPixbufFunction *gi.Function
var iconSourceGetPixbufFunction_Once sync.Once

func iconSourceGetPixbufFunction_Set() error {
	var err error
	iconSourceGetPixbufFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetPixbufFunction, err = iconSourceStruct.InvokerNew("get_pixbuf")
	})
	return err
}

// GetPixbuf is a representation of the C type gtk_icon_source_get_pixbuf.
func (recv *IconSource) GetPixbuf() *gdkpixbuf.Pixbuf {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetPixbufFunction_Set()
	if err == nil {
		ret = iconSourceGetPixbufFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdkpixbuf.PixbufNewFromNative(ret.Pointer())

	return retGo
}

var iconSourceGetSizeFunction *gi.Function
var iconSourceGetSizeFunction_Once sync.Once

func iconSourceGetSizeFunction_Set() error {
	var err error
	iconSourceGetSizeFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetSizeFunction, err = iconSourceStruct.InvokerNew("get_size")
	})
	return err
}

// GetSize is a representation of the C type gtk_icon_source_get_size.
func (recv *IconSource) GetSize() IconSize {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetSizeFunction_Set()
	if err == nil {
		ret = iconSourceGetSizeFunction.Invoke(inArgs[:], nil)
	}

	retGo := IconSize(ret.Int32())

	return retGo
}

var iconSourceGetSizeWildcardedFunction *gi.Function
var iconSourceGetSizeWildcardedFunction_Once sync.Once

func iconSourceGetSizeWildcardedFunction_Set() error {
	var err error
	iconSourceGetSizeWildcardedFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetSizeWildcardedFunction, err = iconSourceStruct.InvokerNew("get_size_wildcarded")
	})
	return err
}

// GetSizeWildcarded is a representation of the C type gtk_icon_source_get_size_wildcarded.
func (recv *IconSource) GetSizeWildcarded() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetSizeWildcardedFunction_Set()
	if err == nil {
		ret = iconSourceGetSizeWildcardedFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var iconSourceGetStateFunction *gi.Function
var iconSourceGetStateFunction_Once sync.Once

func iconSourceGetStateFunction_Set() error {
	var err error
	iconSourceGetStateFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetStateFunction, err = iconSourceStruct.InvokerNew("get_state")
	})
	return err
}

// GetState is a representation of the C type gtk_icon_source_get_state.
func (recv *IconSource) GetState() StateType {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetStateFunction_Set()
	if err == nil {
		ret = iconSourceGetStateFunction.Invoke(inArgs[:], nil)
	}

	retGo := StateType(ret.Int32())

	return retGo
}

var iconSourceGetStateWildcardedFunction *gi.Function
var iconSourceGetStateWildcardedFunction_Once sync.Once

func iconSourceGetStateWildcardedFunction_Set() error {
	var err error
	iconSourceGetStateWildcardedFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceGetStateWildcardedFunction, err = iconSourceStruct.InvokerNew("get_state_wildcarded")
	})
	return err
}

// GetStateWildcarded is a representation of the C type gtk_icon_source_get_state_wildcarded.
func (recv *IconSource) GetStateWildcarded() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := iconSourceGetStateWildcardedFunction_Set()
	if err == nil {
		ret = iconSourceGetStateWildcardedFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var iconSourceSetDirectionFunction *gi.Function
var iconSourceSetDirectionFunction_Once sync.Once

func iconSourceSetDirectionFunction_Set() error {
	var err error
	iconSourceSetDirectionFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetDirectionFunction, err = iconSourceStruct.InvokerNew("set_direction")
	})
	return err
}

// SetDirection is a representation of the C type gtk_icon_source_set_direction.
func (recv *IconSource) SetDirection(direction TextDirection) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(direction))

	err := iconSourceSetDirectionFunction_Set()
	if err == nil {
		iconSourceSetDirectionFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceSetDirectionWildcardedFunction *gi.Function
var iconSourceSetDirectionWildcardedFunction_Once sync.Once

func iconSourceSetDirectionWildcardedFunction_Set() error {
	var err error
	iconSourceSetDirectionWildcardedFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetDirectionWildcardedFunction, err = iconSourceStruct.InvokerNew("set_direction_wildcarded")
	})
	return err
}

// SetDirectionWildcarded is a representation of the C type gtk_icon_source_set_direction_wildcarded.
func (recv *IconSource) SetDirectionWildcarded(setting bool) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetBoolean(setting)

	err := iconSourceSetDirectionWildcardedFunction_Set()
	if err == nil {
		iconSourceSetDirectionWildcardedFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceSetFilenameFunction *gi.Function
var iconSourceSetFilenameFunction_Once sync.Once

func iconSourceSetFilenameFunction_Set() error {
	var err error
	iconSourceSetFilenameFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetFilenameFunction, err = iconSourceStruct.InvokerNew("set_filename")
	})
	return err
}

// SetFilename is a representation of the C type gtk_icon_source_set_filename.
func (recv *IconSource) SetFilename(filename string) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(filename)

	err := iconSourceSetFilenameFunction_Set()
	if err == nil {
		iconSourceSetFilenameFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceSetIconNameFunction *gi.Function
var iconSourceSetIconNameFunction_Once sync.Once

func iconSourceSetIconNameFunction_Set() error {
	var err error
	iconSourceSetIconNameFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetIconNameFunction, err = iconSourceStruct.InvokerNew("set_icon_name")
	})
	return err
}

// SetIconName is a representation of the C type gtk_icon_source_set_icon_name.
func (recv *IconSource) SetIconName(iconName string) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(iconName)

	err := iconSourceSetIconNameFunction_Set()
	if err == nil {
		iconSourceSetIconNameFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceSetPixbufFunction *gi.Function
var iconSourceSetPixbufFunction_Once sync.Once

func iconSourceSetPixbufFunction_Set() error {
	var err error
	iconSourceSetPixbufFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetPixbufFunction, err = iconSourceStruct.InvokerNew("set_pixbuf")
	})
	return err
}

// SetPixbuf is a representation of the C type gtk_icon_source_set_pixbuf.
func (recv *IconSource) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(pixbuf.Native())

	err := iconSourceSetPixbufFunction_Set()
	if err == nil {
		iconSourceSetPixbufFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceSetSizeFunction *gi.Function
var iconSourceSetSizeFunction_Once sync.Once

func iconSourceSetSizeFunction_Set() error {
	var err error
	iconSourceSetSizeFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetSizeFunction, err = iconSourceStruct.InvokerNew("set_size")
	})
	return err
}

// SetSize is a representation of the C type gtk_icon_source_set_size.
func (recv *IconSource) SetSize(size IconSize) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(size))

	err := iconSourceSetSizeFunction_Set()
	if err == nil {
		iconSourceSetSizeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceSetSizeWildcardedFunction *gi.Function
var iconSourceSetSizeWildcardedFunction_Once sync.Once

func iconSourceSetSizeWildcardedFunction_Set() error {
	var err error
	iconSourceSetSizeWildcardedFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetSizeWildcardedFunction, err = iconSourceStruct.InvokerNew("set_size_wildcarded")
	})
	return err
}

// SetSizeWildcarded is a representation of the C type gtk_icon_source_set_size_wildcarded.
func (recv *IconSource) SetSizeWildcarded(setting bool) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetBoolean(setting)

	err := iconSourceSetSizeWildcardedFunction_Set()
	if err == nil {
		iconSourceSetSizeWildcardedFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceSetStateFunction *gi.Function
var iconSourceSetStateFunction_Once sync.Once

func iconSourceSetStateFunction_Set() error {
	var err error
	iconSourceSetStateFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetStateFunction, err = iconSourceStruct.InvokerNew("set_state")
	})
	return err
}

// SetState is a representation of the C type gtk_icon_source_set_state.
func (recv *IconSource) SetState(state StateType) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(state))

	err := iconSourceSetStateFunction_Set()
	if err == nil {
		iconSourceSetStateFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconSourceSetStateWildcardedFunction *gi.Function
var iconSourceSetStateWildcardedFunction_Once sync.Once

func iconSourceSetStateWildcardedFunction_Set() error {
	var err error
	iconSourceSetStateWildcardedFunction_Once.Do(func() {
		err = iconSourceStruct_Set()
		if err != nil {
			return
		}
		iconSourceSetStateWildcardedFunction, err = iconSourceStruct.InvokerNew("set_state_wildcarded")
	})
	return err
}

// SetStateWildcarded is a representation of the C type gtk_icon_source_set_state_wildcarded.
func (recv *IconSource) SetStateWildcarded(setting bool) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetBoolean(setting)

	err := iconSourceSetStateWildcardedFunction_Set()
	if err == nil {
		iconSourceSetStateWildcardedFunction.Invoke(inArgs[:], nil)
	}

	return
}

var iconThemeClassStruct *gi.Struct
var iconThemeClassStruct_Once sync.Once

func iconThemeClassStruct_Set() error {
	var err error
	iconThemeClassStruct_Once.Do(func() {
		iconThemeClassStruct, err = gi.StructNew("Gtk", "IconThemeClass")
	})
	return err
}

type IconThemeClass struct {
	native unsafe.Pointer
}

func IconThemeClassNewFromNative(native unsafe.Pointer) *IconThemeClass {
	err := iconThemeClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconThemeClass{native: native}

	return instance
}

/*
CastToIconThemeClass down casts any arbitrary Object to IconThemeClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconThemeClass.
*/
func CastToIconThemeClass(object *gobject.Object) *IconThemeClass {
	return IconThemeClassNewFromNative(object.Native())
}

// Equals compares this IconThemeClass with another IconThemeClass, and returns true if they represent the same Object.
func (recv *IconThemeClass) Equals(other *IconThemeClass) bool {
	return other.Native() == recv.Native()
}

func (recv *IconThemeClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *IconThemeClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(iconThemeClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *IconThemeClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(iconThemeClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// IconThemeClassStruct creates an uninitialised IconThemeClass.
func IconThemeClassStruct() *IconThemeClass {
	err := iconThemeClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconThemeClassNewFromNative(iconThemeClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconThemeClass)
	return structGo
}
func finalizeIconThemeClass(obj *IconThemeClass) {
	iconThemeClassStruct.Free(obj.Native())
}

var iconThemePrivateStruct *gi.Struct
var iconThemePrivateStruct_Once sync.Once

func iconThemePrivateStruct_Set() error {
	var err error
	iconThemePrivateStruct_Once.Do(func() {
		iconThemePrivateStruct, err = gi.StructNew("Gtk", "IconThemePrivate")
	})
	return err
}

type IconThemePrivate struct {
	native unsafe.Pointer
}

func IconThemePrivateNewFromNative(native unsafe.Pointer) *IconThemePrivate {
	err := iconThemePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconThemePrivate{native: native}

	return instance
}

/*
CastToIconThemePrivate down casts any arbitrary Object to IconThemePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconThemePrivate.
*/
func CastToIconThemePrivate(object *gobject.Object) *IconThemePrivate {
	return IconThemePrivateNewFromNative(object.Native())
}

// Equals compares this IconThemePrivate with another IconThemePrivate, and returns true if they represent the same Object.
func (recv *IconThemePrivate) Equals(other *IconThemePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *IconThemePrivate) Native() unsafe.Pointer {
	return recv.native
}

// IconThemePrivateStruct creates an uninitialised IconThemePrivate.
func IconThemePrivateStruct() *IconThemePrivate {
	err := iconThemePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconThemePrivateNewFromNative(iconThemePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconThemePrivate)
	return structGo
}
func finalizeIconThemePrivate(obj *IconThemePrivate) {
	iconThemePrivateStruct.Free(obj.Native())
}

var iconViewAccessibleClassStruct *gi.Struct
var iconViewAccessibleClassStruct_Once sync.Once

func iconViewAccessibleClassStruct_Set() error {
	var err error
	iconViewAccessibleClassStruct_Once.Do(func() {
		iconViewAccessibleClassStruct, err = gi.StructNew("Gtk", "IconViewAccessibleClass")
	})
	return err
}

type IconViewAccessibleClass struct {
	native unsafe.Pointer
}

func IconViewAccessibleClassNewFromNative(native unsafe.Pointer) *IconViewAccessibleClass {
	err := iconViewAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconViewAccessibleClass{native: native}

	return instance
}

/*
CastToIconViewAccessibleClass down casts any arbitrary Object to IconViewAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconViewAccessibleClass.
*/
func CastToIconViewAccessibleClass(object *gobject.Object) *IconViewAccessibleClass {
	return IconViewAccessibleClassNewFromNative(object.Native())
}

// Equals compares this IconViewAccessibleClass with another IconViewAccessibleClass, and returns true if they represent the same Object.
func (recv *IconViewAccessibleClass) Equals(other *IconViewAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *IconViewAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *IconViewAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(iconViewAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *IconViewAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(iconViewAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// IconViewAccessibleClassStruct creates an uninitialised IconViewAccessibleClass.
func IconViewAccessibleClassStruct() *IconViewAccessibleClass {
	err := iconViewAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconViewAccessibleClassNewFromNative(iconViewAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconViewAccessibleClass)
	return structGo
}
func finalizeIconViewAccessibleClass(obj *IconViewAccessibleClass) {
	iconViewAccessibleClassStruct.Free(obj.Native())
}

var iconViewAccessiblePrivateStruct *gi.Struct
var iconViewAccessiblePrivateStruct_Once sync.Once

func iconViewAccessiblePrivateStruct_Set() error {
	var err error
	iconViewAccessiblePrivateStruct_Once.Do(func() {
		iconViewAccessiblePrivateStruct, err = gi.StructNew("Gtk", "IconViewAccessiblePrivate")
	})
	return err
}

type IconViewAccessiblePrivate struct {
	native unsafe.Pointer
}

func IconViewAccessiblePrivateNewFromNative(native unsafe.Pointer) *IconViewAccessiblePrivate {
	err := iconViewAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconViewAccessiblePrivate{native: native}

	return instance
}

/*
CastToIconViewAccessiblePrivate down casts any arbitrary Object to IconViewAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconViewAccessiblePrivate.
*/
func CastToIconViewAccessiblePrivate(object *gobject.Object) *IconViewAccessiblePrivate {
	return IconViewAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this IconViewAccessiblePrivate with another IconViewAccessiblePrivate, and returns true if they represent the same Object.
func (recv *IconViewAccessiblePrivate) Equals(other *IconViewAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *IconViewAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// IconViewAccessiblePrivateStruct creates an uninitialised IconViewAccessiblePrivate.
func IconViewAccessiblePrivateStruct() *IconViewAccessiblePrivate {
	err := iconViewAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconViewAccessiblePrivateNewFromNative(iconViewAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconViewAccessiblePrivate)
	return structGo
}
func finalizeIconViewAccessiblePrivate(obj *IconViewAccessiblePrivate) {
	iconViewAccessiblePrivateStruct.Free(obj.Native())
}

var iconViewClassStruct *gi.Struct
var iconViewClassStruct_Once sync.Once

func iconViewClassStruct_Set() error {
	var err error
	iconViewClassStruct_Once.Do(func() {
		iconViewClassStruct, err = gi.StructNew("Gtk", "IconViewClass")
	})
	return err
}

type IconViewClass struct {
	native unsafe.Pointer
}

func IconViewClassNewFromNative(native unsafe.Pointer) *IconViewClass {
	err := iconViewClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconViewClass{native: native}

	return instance
}

/*
CastToIconViewClass down casts any arbitrary Object to IconViewClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconViewClass.
*/
func CastToIconViewClass(object *gobject.Object) *IconViewClass {
	return IconViewClassNewFromNative(object.Native())
}

// Equals compares this IconViewClass with another IconViewClass, and returns true if they represent the same Object.
func (recv *IconViewClass) Equals(other *IconViewClass) bool {
	return other.Native() == recv.Native()
}

func (recv *IconViewClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *IconViewClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(iconViewClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *IconViewClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(iconViewClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'item_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'item_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'selection_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'selection_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'select_all' : for field getter : missing Type

// UNSUPPORTED : C value 'select_all' : for field setter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field getter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field setter : missing Type

// UNSUPPORTED : C value 'select_cursor_item' : for field getter : missing Type

// UNSUPPORTED : C value 'select_cursor_item' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_cursor_item' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_cursor_item' : for field setter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'activate_cursor_item' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_cursor_item' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// IconViewClassStruct creates an uninitialised IconViewClass.
func IconViewClassStruct() *IconViewClass {
	err := iconViewClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconViewClassNewFromNative(iconViewClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconViewClass)
	return structGo
}
func finalizeIconViewClass(obj *IconViewClass) {
	iconViewClassStruct.Free(obj.Native())
}

var iconViewPrivateStruct *gi.Struct
var iconViewPrivateStruct_Once sync.Once

func iconViewPrivateStruct_Set() error {
	var err error
	iconViewPrivateStruct_Once.Do(func() {
		iconViewPrivateStruct, err = gi.StructNew("Gtk", "IconViewPrivate")
	})
	return err
}

type IconViewPrivate struct {
	native unsafe.Pointer
}

func IconViewPrivateNewFromNative(native unsafe.Pointer) *IconViewPrivate {
	err := iconViewPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &IconViewPrivate{native: native}

	return instance
}

/*
CastToIconViewPrivate down casts any arbitrary Object to IconViewPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a IconViewPrivate.
*/
func CastToIconViewPrivate(object *gobject.Object) *IconViewPrivate {
	return IconViewPrivateNewFromNative(object.Native())
}

// Equals compares this IconViewPrivate with another IconViewPrivate, and returns true if they represent the same Object.
func (recv *IconViewPrivate) Equals(other *IconViewPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *IconViewPrivate) Native() unsafe.Pointer {
	return recv.native
}

// IconViewPrivateStruct creates an uninitialised IconViewPrivate.
func IconViewPrivateStruct() *IconViewPrivate {
	err := iconViewPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := IconViewPrivateNewFromNative(iconViewPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeIconViewPrivate)
	return structGo
}
func finalizeIconViewPrivate(obj *IconViewPrivate) {
	iconViewPrivateStruct.Free(obj.Native())
}

var imageAccessibleClassStruct *gi.Struct
var imageAccessibleClassStruct_Once sync.Once

func imageAccessibleClassStruct_Set() error {
	var err error
	imageAccessibleClassStruct_Once.Do(func() {
		imageAccessibleClassStruct, err = gi.StructNew("Gtk", "ImageAccessibleClass")
	})
	return err
}

type ImageAccessibleClass struct {
	native unsafe.Pointer
}

func ImageAccessibleClassNewFromNative(native unsafe.Pointer) *ImageAccessibleClass {
	err := imageAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ImageAccessibleClass{native: native}

	return instance
}

/*
CastToImageAccessibleClass down casts any arbitrary Object to ImageAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ImageAccessibleClass.
*/
func CastToImageAccessibleClass(object *gobject.Object) *ImageAccessibleClass {
	return ImageAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ImageAccessibleClass with another ImageAccessibleClass, and returns true if they represent the same Object.
func (recv *ImageAccessibleClass) Equals(other *ImageAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ImageAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ImageAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(imageAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ImageAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(imageAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ImageAccessibleClassStruct creates an uninitialised ImageAccessibleClass.
func ImageAccessibleClassStruct() *ImageAccessibleClass {
	err := imageAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ImageAccessibleClassNewFromNative(imageAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeImageAccessibleClass)
	return structGo
}
func finalizeImageAccessibleClass(obj *ImageAccessibleClass) {
	imageAccessibleClassStruct.Free(obj.Native())
}

var imageAccessiblePrivateStruct *gi.Struct
var imageAccessiblePrivateStruct_Once sync.Once

func imageAccessiblePrivateStruct_Set() error {
	var err error
	imageAccessiblePrivateStruct_Once.Do(func() {
		imageAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ImageAccessiblePrivate")
	})
	return err
}

type ImageAccessiblePrivate struct {
	native unsafe.Pointer
}

func ImageAccessiblePrivateNewFromNative(native unsafe.Pointer) *ImageAccessiblePrivate {
	err := imageAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ImageAccessiblePrivate{native: native}

	return instance
}

/*
CastToImageAccessiblePrivate down casts any arbitrary Object to ImageAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ImageAccessiblePrivate.
*/
func CastToImageAccessiblePrivate(object *gobject.Object) *ImageAccessiblePrivate {
	return ImageAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ImageAccessiblePrivate with another ImageAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ImageAccessiblePrivate) Equals(other *ImageAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ImageAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ImageAccessiblePrivateStruct creates an uninitialised ImageAccessiblePrivate.
func ImageAccessiblePrivateStruct() *ImageAccessiblePrivate {
	err := imageAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ImageAccessiblePrivateNewFromNative(imageAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeImageAccessiblePrivate)
	return structGo
}
func finalizeImageAccessiblePrivate(obj *ImageAccessiblePrivate) {
	imageAccessiblePrivateStruct.Free(obj.Native())
}

var imageCellAccessibleClassStruct *gi.Struct
var imageCellAccessibleClassStruct_Once sync.Once

func imageCellAccessibleClassStruct_Set() error {
	var err error
	imageCellAccessibleClassStruct_Once.Do(func() {
		imageCellAccessibleClassStruct, err = gi.StructNew("Gtk", "ImageCellAccessibleClass")
	})
	return err
}

type ImageCellAccessibleClass struct {
	native unsafe.Pointer
}

func ImageCellAccessibleClassNewFromNative(native unsafe.Pointer) *ImageCellAccessibleClass {
	err := imageCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ImageCellAccessibleClass{native: native}

	return instance
}

/*
CastToImageCellAccessibleClass down casts any arbitrary Object to ImageCellAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ImageCellAccessibleClass.
*/
func CastToImageCellAccessibleClass(object *gobject.Object) *ImageCellAccessibleClass {
	return ImageCellAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ImageCellAccessibleClass with another ImageCellAccessibleClass, and returns true if they represent the same Object.
func (recv *ImageCellAccessibleClass) Equals(other *ImageCellAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ImageCellAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ImageCellAccessibleClass) FieldParentClass() *RendererCellAccessibleClass {
	argValue := gi.StructFieldGet(imageCellAccessibleClassStruct, recv.Native(), "parent_class")
	value := RendererCellAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ImageCellAccessibleClass) SetFieldParentClass(value *RendererCellAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(imageCellAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ImageCellAccessibleClassStruct creates an uninitialised ImageCellAccessibleClass.
func ImageCellAccessibleClassStruct() *ImageCellAccessibleClass {
	err := imageCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ImageCellAccessibleClassNewFromNative(imageCellAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeImageCellAccessibleClass)
	return structGo
}
func finalizeImageCellAccessibleClass(obj *ImageCellAccessibleClass) {
	imageCellAccessibleClassStruct.Free(obj.Native())
}

var imageCellAccessiblePrivateStruct *gi.Struct
var imageCellAccessiblePrivateStruct_Once sync.Once

func imageCellAccessiblePrivateStruct_Set() error {
	var err error
	imageCellAccessiblePrivateStruct_Once.Do(func() {
		imageCellAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ImageCellAccessiblePrivate")
	})
	return err
}

type ImageCellAccessiblePrivate struct {
	native unsafe.Pointer
}

func ImageCellAccessiblePrivateNewFromNative(native unsafe.Pointer) *ImageCellAccessiblePrivate {
	err := imageCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ImageCellAccessiblePrivate{native: native}

	return instance
}

/*
CastToImageCellAccessiblePrivate down casts any arbitrary Object to ImageCellAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ImageCellAccessiblePrivate.
*/
func CastToImageCellAccessiblePrivate(object *gobject.Object) *ImageCellAccessiblePrivate {
	return ImageCellAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ImageCellAccessiblePrivate with another ImageCellAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ImageCellAccessiblePrivate) Equals(other *ImageCellAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ImageCellAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ImageCellAccessiblePrivateStruct creates an uninitialised ImageCellAccessiblePrivate.
func ImageCellAccessiblePrivateStruct() *ImageCellAccessiblePrivate {
	err := imageCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ImageCellAccessiblePrivateNewFromNative(imageCellAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeImageCellAccessiblePrivate)
	return structGo
}
func finalizeImageCellAccessiblePrivate(obj *ImageCellAccessiblePrivate) {
	imageCellAccessiblePrivateStruct.Free(obj.Native())
}

var imageClassStruct *gi.Struct
var imageClassStruct_Once sync.Once

func imageClassStruct_Set() error {
	var err error
	imageClassStruct_Once.Do(func() {
		imageClassStruct, err = gi.StructNew("Gtk", "ImageClass")
	})
	return err
}

type ImageClass struct {
	native unsafe.Pointer
}

func ImageClassNewFromNative(native unsafe.Pointer) *ImageClass {
	err := imageClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ImageClass{native: native}

	return instance
}

/*
CastToImageClass down casts any arbitrary Object to ImageClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ImageClass.
*/
func CastToImageClass(object *gobject.Object) *ImageClass {
	return ImageClassNewFromNative(object.Native())
}

// Equals compares this ImageClass with another ImageClass, and returns true if they represent the same Object.
func (recv *ImageClass) Equals(other *ImageClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ImageClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ImageClass) FieldParentClass() *MiscClass {
	argValue := gi.StructFieldGet(imageClassStruct, recv.Native(), "parent_class")
	value := MiscClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ImageClass) SetFieldParentClass(value *MiscClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(imageClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ImageClassStruct creates an uninitialised ImageClass.
func ImageClassStruct() *ImageClass {
	err := imageClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ImageClassNewFromNative(imageClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeImageClass)
	return structGo
}
func finalizeImageClass(obj *ImageClass) {
	imageClassStruct.Free(obj.Native())
}

var imageMenuItemClassStruct *gi.Struct
var imageMenuItemClassStruct_Once sync.Once

func imageMenuItemClassStruct_Set() error {
	var err error
	imageMenuItemClassStruct_Once.Do(func() {
		imageMenuItemClassStruct, err = gi.StructNew("Gtk", "ImageMenuItemClass")
	})
	return err
}

type ImageMenuItemClass struct {
	native unsafe.Pointer
}

func ImageMenuItemClassNewFromNative(native unsafe.Pointer) *ImageMenuItemClass {
	err := imageMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ImageMenuItemClass{native: native}

	return instance
}

/*
CastToImageMenuItemClass down casts any arbitrary Object to ImageMenuItemClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ImageMenuItemClass.
*/
func CastToImageMenuItemClass(object *gobject.Object) *ImageMenuItemClass {
	return ImageMenuItemClassNewFromNative(object.Native())
}

// Equals compares this ImageMenuItemClass with another ImageMenuItemClass, and returns true if they represent the same Object.
func (recv *ImageMenuItemClass) Equals(other *ImageMenuItemClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ImageMenuItemClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ImageMenuItemClass) FieldParentClass() *MenuItemClass {
	argValue := gi.StructFieldGet(imageMenuItemClassStruct, recv.Native(), "parent_class")
	value := MenuItemClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ImageMenuItemClass) SetFieldParentClass(value *MenuItemClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(imageMenuItemClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ImageMenuItemClassStruct creates an uninitialised ImageMenuItemClass.
func ImageMenuItemClassStruct() *ImageMenuItemClass {
	err := imageMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ImageMenuItemClassNewFromNative(imageMenuItemClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeImageMenuItemClass)
	return structGo
}
func finalizeImageMenuItemClass(obj *ImageMenuItemClass) {
	imageMenuItemClassStruct.Free(obj.Native())
}

var imageMenuItemPrivateStruct *gi.Struct
var imageMenuItemPrivateStruct_Once sync.Once

func imageMenuItemPrivateStruct_Set() error {
	var err error
	imageMenuItemPrivateStruct_Once.Do(func() {
		imageMenuItemPrivateStruct, err = gi.StructNew("Gtk", "ImageMenuItemPrivate")
	})
	return err
}

type ImageMenuItemPrivate struct {
	native unsafe.Pointer
}

func ImageMenuItemPrivateNewFromNative(native unsafe.Pointer) *ImageMenuItemPrivate {
	err := imageMenuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ImageMenuItemPrivate{native: native}

	return instance
}

/*
CastToImageMenuItemPrivate down casts any arbitrary Object to ImageMenuItemPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ImageMenuItemPrivate.
*/
func CastToImageMenuItemPrivate(object *gobject.Object) *ImageMenuItemPrivate {
	return ImageMenuItemPrivateNewFromNative(object.Native())
}

// Equals compares this ImageMenuItemPrivate with another ImageMenuItemPrivate, and returns true if they represent the same Object.
func (recv *ImageMenuItemPrivate) Equals(other *ImageMenuItemPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ImageMenuItemPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ImageMenuItemPrivateStruct creates an uninitialised ImageMenuItemPrivate.
func ImageMenuItemPrivateStruct() *ImageMenuItemPrivate {
	err := imageMenuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ImageMenuItemPrivateNewFromNative(imageMenuItemPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeImageMenuItemPrivate)
	return structGo
}
func finalizeImageMenuItemPrivate(obj *ImageMenuItemPrivate) {
	imageMenuItemPrivateStruct.Free(obj.Native())
}

var imagePrivateStruct *gi.Struct
var imagePrivateStruct_Once sync.Once

func imagePrivateStruct_Set() error {
	var err error
	imagePrivateStruct_Once.Do(func() {
		imagePrivateStruct, err = gi.StructNew("Gtk", "ImagePrivate")
	})
	return err
}

type ImagePrivate struct {
	native unsafe.Pointer
}

func ImagePrivateNewFromNative(native unsafe.Pointer) *ImagePrivate {
	err := imagePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ImagePrivate{native: native}

	return instance
}

/*
CastToImagePrivate down casts any arbitrary Object to ImagePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ImagePrivate.
*/
func CastToImagePrivate(object *gobject.Object) *ImagePrivate {
	return ImagePrivateNewFromNative(object.Native())
}

// Equals compares this ImagePrivate with another ImagePrivate, and returns true if they represent the same Object.
func (recv *ImagePrivate) Equals(other *ImagePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ImagePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ImagePrivateStruct creates an uninitialised ImagePrivate.
func ImagePrivateStruct() *ImagePrivate {
	err := imagePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ImagePrivateNewFromNative(imagePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeImagePrivate)
	return structGo
}
func finalizeImagePrivate(obj *ImagePrivate) {
	imagePrivateStruct.Free(obj.Native())
}

var infoBarClassStruct *gi.Struct
var infoBarClassStruct_Once sync.Once

func infoBarClassStruct_Set() error {
	var err error
	infoBarClassStruct_Once.Do(func() {
		infoBarClassStruct, err = gi.StructNew("Gtk", "InfoBarClass")
	})
	return err
}

type InfoBarClass struct {
	native unsafe.Pointer
}

func InfoBarClassNewFromNative(native unsafe.Pointer) *InfoBarClass {
	err := infoBarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &InfoBarClass{native: native}

	return instance
}

/*
CastToInfoBarClass down casts any arbitrary Object to InfoBarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a InfoBarClass.
*/
func CastToInfoBarClass(object *gobject.Object) *InfoBarClass {
	return InfoBarClassNewFromNative(object.Native())
}

// Equals compares this InfoBarClass with another InfoBarClass, and returns true if they represent the same Object.
func (recv *InfoBarClass) Equals(other *InfoBarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *InfoBarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *InfoBarClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(infoBarClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *InfoBarClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(infoBarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'response' : for field getter : missing Type

// UNSUPPORTED : C value 'response' : for field setter : missing Type

// UNSUPPORTED : C value 'close' : for field getter : missing Type

// UNSUPPORTED : C value 'close' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// InfoBarClassStruct creates an uninitialised InfoBarClass.
func InfoBarClassStruct() *InfoBarClass {
	err := infoBarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := InfoBarClassNewFromNative(infoBarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeInfoBarClass)
	return structGo
}
func finalizeInfoBarClass(obj *InfoBarClass) {
	infoBarClassStruct.Free(obj.Native())
}

var infoBarPrivateStruct *gi.Struct
var infoBarPrivateStruct_Once sync.Once

func infoBarPrivateStruct_Set() error {
	var err error
	infoBarPrivateStruct_Once.Do(func() {
		infoBarPrivateStruct, err = gi.StructNew("Gtk", "InfoBarPrivate")
	})
	return err
}

type InfoBarPrivate struct {
	native unsafe.Pointer
}

func InfoBarPrivateNewFromNative(native unsafe.Pointer) *InfoBarPrivate {
	err := infoBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &InfoBarPrivate{native: native}

	return instance
}

/*
CastToInfoBarPrivate down casts any arbitrary Object to InfoBarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a InfoBarPrivate.
*/
func CastToInfoBarPrivate(object *gobject.Object) *InfoBarPrivate {
	return InfoBarPrivateNewFromNative(object.Native())
}

// Equals compares this InfoBarPrivate with another InfoBarPrivate, and returns true if they represent the same Object.
func (recv *InfoBarPrivate) Equals(other *InfoBarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *InfoBarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// InfoBarPrivateStruct creates an uninitialised InfoBarPrivate.
func InfoBarPrivateStruct() *InfoBarPrivate {
	err := infoBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := InfoBarPrivateNewFromNative(infoBarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeInfoBarPrivate)
	return structGo
}
func finalizeInfoBarPrivate(obj *InfoBarPrivate) {
	infoBarPrivateStruct.Free(obj.Native())
}

var invisibleClassStruct *gi.Struct
var invisibleClassStruct_Once sync.Once

func invisibleClassStruct_Set() error {
	var err error
	invisibleClassStruct_Once.Do(func() {
		invisibleClassStruct, err = gi.StructNew("Gtk", "InvisibleClass")
	})
	return err
}

type InvisibleClass struct {
	native unsafe.Pointer
}

func InvisibleClassNewFromNative(native unsafe.Pointer) *InvisibleClass {
	err := invisibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &InvisibleClass{native: native}

	return instance
}

/*
CastToInvisibleClass down casts any arbitrary Object to InvisibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a InvisibleClass.
*/
func CastToInvisibleClass(object *gobject.Object) *InvisibleClass {
	return InvisibleClassNewFromNative(object.Native())
}

// Equals compares this InvisibleClass with another InvisibleClass, and returns true if they represent the same Object.
func (recv *InvisibleClass) Equals(other *InvisibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *InvisibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *InvisibleClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(invisibleClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *InvisibleClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(invisibleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// InvisibleClassStruct creates an uninitialised InvisibleClass.
func InvisibleClassStruct() *InvisibleClass {
	err := invisibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := InvisibleClassNewFromNative(invisibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeInvisibleClass)
	return structGo
}
func finalizeInvisibleClass(obj *InvisibleClass) {
	invisibleClassStruct.Free(obj.Native())
}

var invisiblePrivateStruct *gi.Struct
var invisiblePrivateStruct_Once sync.Once

func invisiblePrivateStruct_Set() error {
	var err error
	invisiblePrivateStruct_Once.Do(func() {
		invisiblePrivateStruct, err = gi.StructNew("Gtk", "InvisiblePrivate")
	})
	return err
}

type InvisiblePrivate struct {
	native unsafe.Pointer
}

func InvisiblePrivateNewFromNative(native unsafe.Pointer) *InvisiblePrivate {
	err := invisiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &InvisiblePrivate{native: native}

	return instance
}

/*
CastToInvisiblePrivate down casts any arbitrary Object to InvisiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a InvisiblePrivate.
*/
func CastToInvisiblePrivate(object *gobject.Object) *InvisiblePrivate {
	return InvisiblePrivateNewFromNative(object.Native())
}

// Equals compares this InvisiblePrivate with another InvisiblePrivate, and returns true if they represent the same Object.
func (recv *InvisiblePrivate) Equals(other *InvisiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *InvisiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// InvisiblePrivateStruct creates an uninitialised InvisiblePrivate.
func InvisiblePrivateStruct() *InvisiblePrivate {
	err := invisiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := InvisiblePrivateNewFromNative(invisiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeInvisiblePrivate)
	return structGo
}
func finalizeInvisiblePrivate(obj *InvisiblePrivate) {
	invisiblePrivateStruct.Free(obj.Native())
}

var labelAccessibleClassStruct *gi.Struct
var labelAccessibleClassStruct_Once sync.Once

func labelAccessibleClassStruct_Set() error {
	var err error
	labelAccessibleClassStruct_Once.Do(func() {
		labelAccessibleClassStruct, err = gi.StructNew("Gtk", "LabelAccessibleClass")
	})
	return err
}

type LabelAccessibleClass struct {
	native unsafe.Pointer
}

func LabelAccessibleClassNewFromNative(native unsafe.Pointer) *LabelAccessibleClass {
	err := labelAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LabelAccessibleClass{native: native}

	return instance
}

/*
CastToLabelAccessibleClass down casts any arbitrary Object to LabelAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LabelAccessibleClass.
*/
func CastToLabelAccessibleClass(object *gobject.Object) *LabelAccessibleClass {
	return LabelAccessibleClassNewFromNative(object.Native())
}

// Equals compares this LabelAccessibleClass with another LabelAccessibleClass, and returns true if they represent the same Object.
func (recv *LabelAccessibleClass) Equals(other *LabelAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LabelAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *LabelAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(labelAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *LabelAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(labelAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// LabelAccessibleClassStruct creates an uninitialised LabelAccessibleClass.
func LabelAccessibleClassStruct() *LabelAccessibleClass {
	err := labelAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LabelAccessibleClassNewFromNative(labelAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLabelAccessibleClass)
	return structGo
}
func finalizeLabelAccessibleClass(obj *LabelAccessibleClass) {
	labelAccessibleClassStruct.Free(obj.Native())
}

var labelAccessiblePrivateStruct *gi.Struct
var labelAccessiblePrivateStruct_Once sync.Once

func labelAccessiblePrivateStruct_Set() error {
	var err error
	labelAccessiblePrivateStruct_Once.Do(func() {
		labelAccessiblePrivateStruct, err = gi.StructNew("Gtk", "LabelAccessiblePrivate")
	})
	return err
}

type LabelAccessiblePrivate struct {
	native unsafe.Pointer
}

func LabelAccessiblePrivateNewFromNative(native unsafe.Pointer) *LabelAccessiblePrivate {
	err := labelAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LabelAccessiblePrivate{native: native}

	return instance
}

/*
CastToLabelAccessiblePrivate down casts any arbitrary Object to LabelAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LabelAccessiblePrivate.
*/
func CastToLabelAccessiblePrivate(object *gobject.Object) *LabelAccessiblePrivate {
	return LabelAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this LabelAccessiblePrivate with another LabelAccessiblePrivate, and returns true if they represent the same Object.
func (recv *LabelAccessiblePrivate) Equals(other *LabelAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LabelAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// LabelAccessiblePrivateStruct creates an uninitialised LabelAccessiblePrivate.
func LabelAccessiblePrivateStruct() *LabelAccessiblePrivate {
	err := labelAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LabelAccessiblePrivateNewFromNative(labelAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLabelAccessiblePrivate)
	return structGo
}
func finalizeLabelAccessiblePrivate(obj *LabelAccessiblePrivate) {
	labelAccessiblePrivateStruct.Free(obj.Native())
}

var labelClassStruct *gi.Struct
var labelClassStruct_Once sync.Once

func labelClassStruct_Set() error {
	var err error
	labelClassStruct_Once.Do(func() {
		labelClassStruct, err = gi.StructNew("Gtk", "LabelClass")
	})
	return err
}

type LabelClass struct {
	native unsafe.Pointer
}

func LabelClassNewFromNative(native unsafe.Pointer) *LabelClass {
	err := labelClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LabelClass{native: native}

	return instance
}

/*
CastToLabelClass down casts any arbitrary Object to LabelClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LabelClass.
*/
func CastToLabelClass(object *gobject.Object) *LabelClass {
	return LabelClassNewFromNative(object.Native())
}

// Equals compares this LabelClass with another LabelClass, and returns true if they represent the same Object.
func (recv *LabelClass) Equals(other *LabelClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LabelClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *LabelClass) FieldParentClass() *MiscClass {
	argValue := gi.StructFieldGet(labelClassStruct, recv.Native(), "parent_class")
	value := MiscClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *LabelClass) SetFieldParentClass(value *MiscClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(labelClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'move_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'copy_clipboard' : for field getter : missing Type

// UNSUPPORTED : C value 'copy_clipboard' : for field setter : missing Type

// UNSUPPORTED : C value 'populate_popup' : for field getter : missing Type

// UNSUPPORTED : C value 'populate_popup' : for field setter : missing Type

// UNSUPPORTED : C value 'activate_link' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_link' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// LabelClassStruct creates an uninitialised LabelClass.
func LabelClassStruct() *LabelClass {
	err := labelClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LabelClassNewFromNative(labelClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLabelClass)
	return structGo
}
func finalizeLabelClass(obj *LabelClass) {
	labelClassStruct.Free(obj.Native())
}

var labelPrivateStruct *gi.Struct
var labelPrivateStruct_Once sync.Once

func labelPrivateStruct_Set() error {
	var err error
	labelPrivateStruct_Once.Do(func() {
		labelPrivateStruct, err = gi.StructNew("Gtk", "LabelPrivate")
	})
	return err
}

type LabelPrivate struct {
	native unsafe.Pointer
}

func LabelPrivateNewFromNative(native unsafe.Pointer) *LabelPrivate {
	err := labelPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LabelPrivate{native: native}

	return instance
}

/*
CastToLabelPrivate down casts any arbitrary Object to LabelPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LabelPrivate.
*/
func CastToLabelPrivate(object *gobject.Object) *LabelPrivate {
	return LabelPrivateNewFromNative(object.Native())
}

// Equals compares this LabelPrivate with another LabelPrivate, and returns true if they represent the same Object.
func (recv *LabelPrivate) Equals(other *LabelPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LabelPrivate) Native() unsafe.Pointer {
	return recv.native
}

// LabelPrivateStruct creates an uninitialised LabelPrivate.
func LabelPrivateStruct() *LabelPrivate {
	err := labelPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LabelPrivateNewFromNative(labelPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLabelPrivate)
	return structGo
}
func finalizeLabelPrivate(obj *LabelPrivate) {
	labelPrivateStruct.Free(obj.Native())
}

var labelSelectionInfoStruct *gi.Struct
var labelSelectionInfoStruct_Once sync.Once

func labelSelectionInfoStruct_Set() error {
	var err error
	labelSelectionInfoStruct_Once.Do(func() {
		labelSelectionInfoStruct, err = gi.StructNew("Gtk", "LabelSelectionInfo")
	})
	return err
}

type LabelSelectionInfo struct {
	native unsafe.Pointer
}

func LabelSelectionInfoNewFromNative(native unsafe.Pointer) *LabelSelectionInfo {
	err := labelSelectionInfoStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LabelSelectionInfo{native: native}

	return instance
}

/*
CastToLabelSelectionInfo down casts any arbitrary Object to LabelSelectionInfo.
Exercise care, as this is a potentially dangerous function
if the Object is not a LabelSelectionInfo.
*/
func CastToLabelSelectionInfo(object *gobject.Object) *LabelSelectionInfo {
	return LabelSelectionInfoNewFromNative(object.Native())
}

// Equals compares this LabelSelectionInfo with another LabelSelectionInfo, and returns true if they represent the same Object.
func (recv *LabelSelectionInfo) Equals(other *LabelSelectionInfo) bool {
	return other.Native() == recv.Native()
}

func (recv *LabelSelectionInfo) Native() unsafe.Pointer {
	return recv.native
}

// LabelSelectionInfoStruct creates an uninitialised LabelSelectionInfo.
func LabelSelectionInfoStruct() *LabelSelectionInfo {
	err := labelSelectionInfoStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LabelSelectionInfoNewFromNative(labelSelectionInfoStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLabelSelectionInfo)
	return structGo
}
func finalizeLabelSelectionInfo(obj *LabelSelectionInfo) {
	labelSelectionInfoStruct.Free(obj.Native())
}

var layoutClassStruct *gi.Struct
var layoutClassStruct_Once sync.Once

func layoutClassStruct_Set() error {
	var err error
	layoutClassStruct_Once.Do(func() {
		layoutClassStruct, err = gi.StructNew("Gtk", "LayoutClass")
	})
	return err
}

type LayoutClass struct {
	native unsafe.Pointer
}

func LayoutClassNewFromNative(native unsafe.Pointer) *LayoutClass {
	err := layoutClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LayoutClass{native: native}

	return instance
}

/*
CastToLayoutClass down casts any arbitrary Object to LayoutClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LayoutClass.
*/
func CastToLayoutClass(object *gobject.Object) *LayoutClass {
	return LayoutClassNewFromNative(object.Native())
}

// Equals compares this LayoutClass with another LayoutClass, and returns true if they represent the same Object.
func (recv *LayoutClass) Equals(other *LayoutClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LayoutClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *LayoutClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(layoutClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *LayoutClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(layoutClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// LayoutClassStruct creates an uninitialised LayoutClass.
func LayoutClassStruct() *LayoutClass {
	err := layoutClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LayoutClassNewFromNative(layoutClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLayoutClass)
	return structGo
}
func finalizeLayoutClass(obj *LayoutClass) {
	layoutClassStruct.Free(obj.Native())
}

var layoutPrivateStruct *gi.Struct
var layoutPrivateStruct_Once sync.Once

func layoutPrivateStruct_Set() error {
	var err error
	layoutPrivateStruct_Once.Do(func() {
		layoutPrivateStruct, err = gi.StructNew("Gtk", "LayoutPrivate")
	})
	return err
}

type LayoutPrivate struct {
	native unsafe.Pointer
}

func LayoutPrivateNewFromNative(native unsafe.Pointer) *LayoutPrivate {
	err := layoutPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LayoutPrivate{native: native}

	return instance
}

/*
CastToLayoutPrivate down casts any arbitrary Object to LayoutPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LayoutPrivate.
*/
func CastToLayoutPrivate(object *gobject.Object) *LayoutPrivate {
	return LayoutPrivateNewFromNative(object.Native())
}

// Equals compares this LayoutPrivate with another LayoutPrivate, and returns true if they represent the same Object.
func (recv *LayoutPrivate) Equals(other *LayoutPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LayoutPrivate) Native() unsafe.Pointer {
	return recv.native
}

// LayoutPrivateStruct creates an uninitialised LayoutPrivate.
func LayoutPrivateStruct() *LayoutPrivate {
	err := layoutPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LayoutPrivateNewFromNative(layoutPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLayoutPrivate)
	return structGo
}
func finalizeLayoutPrivate(obj *LayoutPrivate) {
	layoutPrivateStruct.Free(obj.Native())
}

var levelBarAccessibleClassStruct *gi.Struct
var levelBarAccessibleClassStruct_Once sync.Once

func levelBarAccessibleClassStruct_Set() error {
	var err error
	levelBarAccessibleClassStruct_Once.Do(func() {
		levelBarAccessibleClassStruct, err = gi.StructNew("Gtk", "LevelBarAccessibleClass")
	})
	return err
}

type LevelBarAccessibleClass struct {
	native unsafe.Pointer
}

func LevelBarAccessibleClassNewFromNative(native unsafe.Pointer) *LevelBarAccessibleClass {
	err := levelBarAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LevelBarAccessibleClass{native: native}

	return instance
}

/*
CastToLevelBarAccessibleClass down casts any arbitrary Object to LevelBarAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LevelBarAccessibleClass.
*/
func CastToLevelBarAccessibleClass(object *gobject.Object) *LevelBarAccessibleClass {
	return LevelBarAccessibleClassNewFromNative(object.Native())
}

// Equals compares this LevelBarAccessibleClass with another LevelBarAccessibleClass, and returns true if they represent the same Object.
func (recv *LevelBarAccessibleClass) Equals(other *LevelBarAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LevelBarAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *LevelBarAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(levelBarAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *LevelBarAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(levelBarAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// LevelBarAccessibleClassStruct creates an uninitialised LevelBarAccessibleClass.
func LevelBarAccessibleClassStruct() *LevelBarAccessibleClass {
	err := levelBarAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LevelBarAccessibleClassNewFromNative(levelBarAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLevelBarAccessibleClass)
	return structGo
}
func finalizeLevelBarAccessibleClass(obj *LevelBarAccessibleClass) {
	levelBarAccessibleClassStruct.Free(obj.Native())
}

var levelBarAccessiblePrivateStruct *gi.Struct
var levelBarAccessiblePrivateStruct_Once sync.Once

func levelBarAccessiblePrivateStruct_Set() error {
	var err error
	levelBarAccessiblePrivateStruct_Once.Do(func() {
		levelBarAccessiblePrivateStruct, err = gi.StructNew("Gtk", "LevelBarAccessiblePrivate")
	})
	return err
}

type LevelBarAccessiblePrivate struct {
	native unsafe.Pointer
}

func LevelBarAccessiblePrivateNewFromNative(native unsafe.Pointer) *LevelBarAccessiblePrivate {
	err := levelBarAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LevelBarAccessiblePrivate{native: native}

	return instance
}

/*
CastToLevelBarAccessiblePrivate down casts any arbitrary Object to LevelBarAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LevelBarAccessiblePrivate.
*/
func CastToLevelBarAccessiblePrivate(object *gobject.Object) *LevelBarAccessiblePrivate {
	return LevelBarAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this LevelBarAccessiblePrivate with another LevelBarAccessiblePrivate, and returns true if they represent the same Object.
func (recv *LevelBarAccessiblePrivate) Equals(other *LevelBarAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LevelBarAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// LevelBarAccessiblePrivateStruct creates an uninitialised LevelBarAccessiblePrivate.
func LevelBarAccessiblePrivateStruct() *LevelBarAccessiblePrivate {
	err := levelBarAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LevelBarAccessiblePrivateNewFromNative(levelBarAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLevelBarAccessiblePrivate)
	return structGo
}
func finalizeLevelBarAccessiblePrivate(obj *LevelBarAccessiblePrivate) {
	levelBarAccessiblePrivateStruct.Free(obj.Native())
}

var levelBarClassStruct *gi.Struct
var levelBarClassStruct_Once sync.Once

func levelBarClassStruct_Set() error {
	var err error
	levelBarClassStruct_Once.Do(func() {
		levelBarClassStruct, err = gi.StructNew("Gtk", "LevelBarClass")
	})
	return err
}

type LevelBarClass struct {
	native unsafe.Pointer
}

func LevelBarClassNewFromNative(native unsafe.Pointer) *LevelBarClass {
	err := levelBarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LevelBarClass{native: native}

	return instance
}

/*
CastToLevelBarClass down casts any arbitrary Object to LevelBarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LevelBarClass.
*/
func CastToLevelBarClass(object *gobject.Object) *LevelBarClass {
	return LevelBarClassNewFromNative(object.Native())
}

// Equals compares this LevelBarClass with another LevelBarClass, and returns true if they represent the same Object.
func (recv *LevelBarClass) Equals(other *LevelBarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LevelBarClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'offset_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'offset_changed' : for field setter : missing Type

// LevelBarClassStruct creates an uninitialised LevelBarClass.
func LevelBarClassStruct() *LevelBarClass {
	err := levelBarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LevelBarClassNewFromNative(levelBarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLevelBarClass)
	return structGo
}
func finalizeLevelBarClass(obj *LevelBarClass) {
	levelBarClassStruct.Free(obj.Native())
}

var levelBarPrivateStruct *gi.Struct
var levelBarPrivateStruct_Once sync.Once

func levelBarPrivateStruct_Set() error {
	var err error
	levelBarPrivateStruct_Once.Do(func() {
		levelBarPrivateStruct, err = gi.StructNew("Gtk", "LevelBarPrivate")
	})
	return err
}

type LevelBarPrivate struct {
	native unsafe.Pointer
}

func LevelBarPrivateNewFromNative(native unsafe.Pointer) *LevelBarPrivate {
	err := levelBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LevelBarPrivate{native: native}

	return instance
}

/*
CastToLevelBarPrivate down casts any arbitrary Object to LevelBarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LevelBarPrivate.
*/
func CastToLevelBarPrivate(object *gobject.Object) *LevelBarPrivate {
	return LevelBarPrivateNewFromNative(object.Native())
}

// Equals compares this LevelBarPrivate with another LevelBarPrivate, and returns true if they represent the same Object.
func (recv *LevelBarPrivate) Equals(other *LevelBarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LevelBarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// LevelBarPrivateStruct creates an uninitialised LevelBarPrivate.
func LevelBarPrivateStruct() *LevelBarPrivate {
	err := levelBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LevelBarPrivateNewFromNative(levelBarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLevelBarPrivate)
	return structGo
}
func finalizeLevelBarPrivate(obj *LevelBarPrivate) {
	levelBarPrivateStruct.Free(obj.Native())
}

var linkButtonAccessibleClassStruct *gi.Struct
var linkButtonAccessibleClassStruct_Once sync.Once

func linkButtonAccessibleClassStruct_Set() error {
	var err error
	linkButtonAccessibleClassStruct_Once.Do(func() {
		linkButtonAccessibleClassStruct, err = gi.StructNew("Gtk", "LinkButtonAccessibleClass")
	})
	return err
}

type LinkButtonAccessibleClass struct {
	native unsafe.Pointer
}

func LinkButtonAccessibleClassNewFromNative(native unsafe.Pointer) *LinkButtonAccessibleClass {
	err := linkButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LinkButtonAccessibleClass{native: native}

	return instance
}

/*
CastToLinkButtonAccessibleClass down casts any arbitrary Object to LinkButtonAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LinkButtonAccessibleClass.
*/
func CastToLinkButtonAccessibleClass(object *gobject.Object) *LinkButtonAccessibleClass {
	return LinkButtonAccessibleClassNewFromNative(object.Native())
}

// Equals compares this LinkButtonAccessibleClass with another LinkButtonAccessibleClass, and returns true if they represent the same Object.
func (recv *LinkButtonAccessibleClass) Equals(other *LinkButtonAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LinkButtonAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *LinkButtonAccessibleClass) FieldParentClass() *ButtonAccessibleClass {
	argValue := gi.StructFieldGet(linkButtonAccessibleClassStruct, recv.Native(), "parent_class")
	value := ButtonAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *LinkButtonAccessibleClass) SetFieldParentClass(value *ButtonAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(linkButtonAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// LinkButtonAccessibleClassStruct creates an uninitialised LinkButtonAccessibleClass.
func LinkButtonAccessibleClassStruct() *LinkButtonAccessibleClass {
	err := linkButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LinkButtonAccessibleClassNewFromNative(linkButtonAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLinkButtonAccessibleClass)
	return structGo
}
func finalizeLinkButtonAccessibleClass(obj *LinkButtonAccessibleClass) {
	linkButtonAccessibleClassStruct.Free(obj.Native())
}

var linkButtonAccessiblePrivateStruct *gi.Struct
var linkButtonAccessiblePrivateStruct_Once sync.Once

func linkButtonAccessiblePrivateStruct_Set() error {
	var err error
	linkButtonAccessiblePrivateStruct_Once.Do(func() {
		linkButtonAccessiblePrivateStruct, err = gi.StructNew("Gtk", "LinkButtonAccessiblePrivate")
	})
	return err
}

type LinkButtonAccessiblePrivate struct {
	native unsafe.Pointer
}

func LinkButtonAccessiblePrivateNewFromNative(native unsafe.Pointer) *LinkButtonAccessiblePrivate {
	err := linkButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LinkButtonAccessiblePrivate{native: native}

	return instance
}

/*
CastToLinkButtonAccessiblePrivate down casts any arbitrary Object to LinkButtonAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LinkButtonAccessiblePrivate.
*/
func CastToLinkButtonAccessiblePrivate(object *gobject.Object) *LinkButtonAccessiblePrivate {
	return LinkButtonAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this LinkButtonAccessiblePrivate with another LinkButtonAccessiblePrivate, and returns true if they represent the same Object.
func (recv *LinkButtonAccessiblePrivate) Equals(other *LinkButtonAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LinkButtonAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// LinkButtonAccessiblePrivateStruct creates an uninitialised LinkButtonAccessiblePrivate.
func LinkButtonAccessiblePrivateStruct() *LinkButtonAccessiblePrivate {
	err := linkButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LinkButtonAccessiblePrivateNewFromNative(linkButtonAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLinkButtonAccessiblePrivate)
	return structGo
}
func finalizeLinkButtonAccessiblePrivate(obj *LinkButtonAccessiblePrivate) {
	linkButtonAccessiblePrivateStruct.Free(obj.Native())
}

var linkButtonClassStruct *gi.Struct
var linkButtonClassStruct_Once sync.Once

func linkButtonClassStruct_Set() error {
	var err error
	linkButtonClassStruct_Once.Do(func() {
		linkButtonClassStruct, err = gi.StructNew("Gtk", "LinkButtonClass")
	})
	return err
}

type LinkButtonClass struct {
	native unsafe.Pointer
}

func LinkButtonClassNewFromNative(native unsafe.Pointer) *LinkButtonClass {
	err := linkButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LinkButtonClass{native: native}

	return instance
}

/*
CastToLinkButtonClass down casts any arbitrary Object to LinkButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LinkButtonClass.
*/
func CastToLinkButtonClass(object *gobject.Object) *LinkButtonClass {
	return LinkButtonClassNewFromNative(object.Native())
}

// Equals compares this LinkButtonClass with another LinkButtonClass, and returns true if they represent the same Object.
func (recv *LinkButtonClass) Equals(other *LinkButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LinkButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'activate_link' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_link' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_padding1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_padding1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_padding2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_padding2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_padding3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_padding3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_padding4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_padding4' : for field setter : missing Type

// LinkButtonClassStruct creates an uninitialised LinkButtonClass.
func LinkButtonClassStruct() *LinkButtonClass {
	err := linkButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LinkButtonClassNewFromNative(linkButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLinkButtonClass)
	return structGo
}
func finalizeLinkButtonClass(obj *LinkButtonClass) {
	linkButtonClassStruct.Free(obj.Native())
}

var linkButtonPrivateStruct *gi.Struct
var linkButtonPrivateStruct_Once sync.Once

func linkButtonPrivateStruct_Set() error {
	var err error
	linkButtonPrivateStruct_Once.Do(func() {
		linkButtonPrivateStruct, err = gi.StructNew("Gtk", "LinkButtonPrivate")
	})
	return err
}

type LinkButtonPrivate struct {
	native unsafe.Pointer
}

func LinkButtonPrivateNewFromNative(native unsafe.Pointer) *LinkButtonPrivate {
	err := linkButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LinkButtonPrivate{native: native}

	return instance
}

/*
CastToLinkButtonPrivate down casts any arbitrary Object to LinkButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LinkButtonPrivate.
*/
func CastToLinkButtonPrivate(object *gobject.Object) *LinkButtonPrivate {
	return LinkButtonPrivateNewFromNative(object.Native())
}

// Equals compares this LinkButtonPrivate with another LinkButtonPrivate, and returns true if they represent the same Object.
func (recv *LinkButtonPrivate) Equals(other *LinkButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LinkButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// LinkButtonPrivateStruct creates an uninitialised LinkButtonPrivate.
func LinkButtonPrivateStruct() *LinkButtonPrivate {
	err := linkButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LinkButtonPrivateNewFromNative(linkButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLinkButtonPrivate)
	return structGo
}
func finalizeLinkButtonPrivate(obj *LinkButtonPrivate) {
	linkButtonPrivateStruct.Free(obj.Native())
}

var listBoxAccessibleClassStruct *gi.Struct
var listBoxAccessibleClassStruct_Once sync.Once

func listBoxAccessibleClassStruct_Set() error {
	var err error
	listBoxAccessibleClassStruct_Once.Do(func() {
		listBoxAccessibleClassStruct, err = gi.StructNew("Gtk", "ListBoxAccessibleClass")
	})
	return err
}

type ListBoxAccessibleClass struct {
	native unsafe.Pointer
}

func ListBoxAccessibleClassNewFromNative(native unsafe.Pointer) *ListBoxAccessibleClass {
	err := listBoxAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ListBoxAccessibleClass{native: native}

	return instance
}

/*
CastToListBoxAccessibleClass down casts any arbitrary Object to ListBoxAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ListBoxAccessibleClass.
*/
func CastToListBoxAccessibleClass(object *gobject.Object) *ListBoxAccessibleClass {
	return ListBoxAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ListBoxAccessibleClass with another ListBoxAccessibleClass, and returns true if they represent the same Object.
func (recv *ListBoxAccessibleClass) Equals(other *ListBoxAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ListBoxAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ListBoxAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(listBoxAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ListBoxAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(listBoxAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ListBoxAccessibleClassStruct creates an uninitialised ListBoxAccessibleClass.
func ListBoxAccessibleClassStruct() *ListBoxAccessibleClass {
	err := listBoxAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ListBoxAccessibleClassNewFromNative(listBoxAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeListBoxAccessibleClass)
	return structGo
}
func finalizeListBoxAccessibleClass(obj *ListBoxAccessibleClass) {
	listBoxAccessibleClassStruct.Free(obj.Native())
}

var listBoxAccessiblePrivateStruct *gi.Struct
var listBoxAccessiblePrivateStruct_Once sync.Once

func listBoxAccessiblePrivateStruct_Set() error {
	var err error
	listBoxAccessiblePrivateStruct_Once.Do(func() {
		listBoxAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ListBoxAccessiblePrivate")
	})
	return err
}

type ListBoxAccessiblePrivate struct {
	native unsafe.Pointer
}

func ListBoxAccessiblePrivateNewFromNative(native unsafe.Pointer) *ListBoxAccessiblePrivate {
	err := listBoxAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ListBoxAccessiblePrivate{native: native}

	return instance
}

/*
CastToListBoxAccessiblePrivate down casts any arbitrary Object to ListBoxAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ListBoxAccessiblePrivate.
*/
func CastToListBoxAccessiblePrivate(object *gobject.Object) *ListBoxAccessiblePrivate {
	return ListBoxAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ListBoxAccessiblePrivate with another ListBoxAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ListBoxAccessiblePrivate) Equals(other *ListBoxAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ListBoxAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ListBoxAccessiblePrivateStruct creates an uninitialised ListBoxAccessiblePrivate.
func ListBoxAccessiblePrivateStruct() *ListBoxAccessiblePrivate {
	err := listBoxAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ListBoxAccessiblePrivateNewFromNative(listBoxAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeListBoxAccessiblePrivate)
	return structGo
}
func finalizeListBoxAccessiblePrivate(obj *ListBoxAccessiblePrivate) {
	listBoxAccessiblePrivateStruct.Free(obj.Native())
}

var listBoxClassStruct *gi.Struct
var listBoxClassStruct_Once sync.Once

func listBoxClassStruct_Set() error {
	var err error
	listBoxClassStruct_Once.Do(func() {
		listBoxClassStruct, err = gi.StructNew("Gtk", "ListBoxClass")
	})
	return err
}

type ListBoxClass struct {
	native unsafe.Pointer
}

func ListBoxClassNewFromNative(native unsafe.Pointer) *ListBoxClass {
	err := listBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ListBoxClass{native: native}

	return instance
}

/*
CastToListBoxClass down casts any arbitrary Object to ListBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ListBoxClass.
*/
func CastToListBoxClass(object *gobject.Object) *ListBoxClass {
	return ListBoxClassNewFromNative(object.Native())
}

// Equals compares this ListBoxClass with another ListBoxClass, and returns true if they represent the same Object.
func (recv *ListBoxClass) Equals(other *ListBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ListBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ListBoxClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(listBoxClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ListBoxClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(listBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'row_selected' : for field getter : missing Type

// UNSUPPORTED : C value 'row_selected' : for field setter : missing Type

// UNSUPPORTED : C value 'row_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'row_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'activate_cursor_row' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_cursor_row' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_cursor_row' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_cursor_row' : for field setter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'selected_rows_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'selected_rows_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'select_all' : for field getter : missing Type

// UNSUPPORTED : C value 'select_all' : for field setter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field getter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// ListBoxClassStruct creates an uninitialised ListBoxClass.
func ListBoxClassStruct() *ListBoxClass {
	err := listBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ListBoxClassNewFromNative(listBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeListBoxClass)
	return structGo
}
func finalizeListBoxClass(obj *ListBoxClass) {
	listBoxClassStruct.Free(obj.Native())
}

var listBoxRowAccessibleClassStruct *gi.Struct
var listBoxRowAccessibleClassStruct_Once sync.Once

func listBoxRowAccessibleClassStruct_Set() error {
	var err error
	listBoxRowAccessibleClassStruct_Once.Do(func() {
		listBoxRowAccessibleClassStruct, err = gi.StructNew("Gtk", "ListBoxRowAccessibleClass")
	})
	return err
}

type ListBoxRowAccessibleClass struct {
	native unsafe.Pointer
}

func ListBoxRowAccessibleClassNewFromNative(native unsafe.Pointer) *ListBoxRowAccessibleClass {
	err := listBoxRowAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ListBoxRowAccessibleClass{native: native}

	return instance
}

/*
CastToListBoxRowAccessibleClass down casts any arbitrary Object to ListBoxRowAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ListBoxRowAccessibleClass.
*/
func CastToListBoxRowAccessibleClass(object *gobject.Object) *ListBoxRowAccessibleClass {
	return ListBoxRowAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ListBoxRowAccessibleClass with another ListBoxRowAccessibleClass, and returns true if they represent the same Object.
func (recv *ListBoxRowAccessibleClass) Equals(other *ListBoxRowAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ListBoxRowAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ListBoxRowAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(listBoxRowAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ListBoxRowAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(listBoxRowAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ListBoxRowAccessibleClassStruct creates an uninitialised ListBoxRowAccessibleClass.
func ListBoxRowAccessibleClassStruct() *ListBoxRowAccessibleClass {
	err := listBoxRowAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ListBoxRowAccessibleClassNewFromNative(listBoxRowAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeListBoxRowAccessibleClass)
	return structGo
}
func finalizeListBoxRowAccessibleClass(obj *ListBoxRowAccessibleClass) {
	listBoxRowAccessibleClassStruct.Free(obj.Native())
}

var listBoxRowClassStruct *gi.Struct
var listBoxRowClassStruct_Once sync.Once

func listBoxRowClassStruct_Set() error {
	var err error
	listBoxRowClassStruct_Once.Do(func() {
		listBoxRowClassStruct, err = gi.StructNew("Gtk", "ListBoxRowClass")
	})
	return err
}

type ListBoxRowClass struct {
	native unsafe.Pointer
}

func ListBoxRowClassNewFromNative(native unsafe.Pointer) *ListBoxRowClass {
	err := listBoxRowClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ListBoxRowClass{native: native}

	return instance
}

/*
CastToListBoxRowClass down casts any arbitrary Object to ListBoxRowClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ListBoxRowClass.
*/
func CastToListBoxRowClass(object *gobject.Object) *ListBoxRowClass {
	return ListBoxRowClassNewFromNative(object.Native())
}

// Equals compares this ListBoxRowClass with another ListBoxRowClass, and returns true if they represent the same Object.
func (recv *ListBoxRowClass) Equals(other *ListBoxRowClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ListBoxRowClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ListBoxRowClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(listBoxRowClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ListBoxRowClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(listBoxRowClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// ListBoxRowClassStruct creates an uninitialised ListBoxRowClass.
func ListBoxRowClassStruct() *ListBoxRowClass {
	err := listBoxRowClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ListBoxRowClassNewFromNative(listBoxRowClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeListBoxRowClass)
	return structGo
}
func finalizeListBoxRowClass(obj *ListBoxRowClass) {
	listBoxRowClassStruct.Free(obj.Native())
}

var listStoreClassStruct *gi.Struct
var listStoreClassStruct_Once sync.Once

func listStoreClassStruct_Set() error {
	var err error
	listStoreClassStruct_Once.Do(func() {
		listStoreClassStruct, err = gi.StructNew("Gtk", "ListStoreClass")
	})
	return err
}

type ListStoreClass struct {
	native unsafe.Pointer
}

func ListStoreClassNewFromNative(native unsafe.Pointer) *ListStoreClass {
	err := listStoreClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ListStoreClass{native: native}

	return instance
}

/*
CastToListStoreClass down casts any arbitrary Object to ListStoreClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ListStoreClass.
*/
func CastToListStoreClass(object *gobject.Object) *ListStoreClass {
	return ListStoreClassNewFromNative(object.Native())
}

// Equals compares this ListStoreClass with another ListStoreClass, and returns true if they represent the same Object.
func (recv *ListStoreClass) Equals(other *ListStoreClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ListStoreClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ListStoreClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(listStoreClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ListStoreClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(listStoreClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ListStoreClassStruct creates an uninitialised ListStoreClass.
func ListStoreClassStruct() *ListStoreClass {
	err := listStoreClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ListStoreClassNewFromNative(listStoreClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeListStoreClass)
	return structGo
}
func finalizeListStoreClass(obj *ListStoreClass) {
	listStoreClassStruct.Free(obj.Native())
}

var listStorePrivateStruct *gi.Struct
var listStorePrivateStruct_Once sync.Once

func listStorePrivateStruct_Set() error {
	var err error
	listStorePrivateStruct_Once.Do(func() {
		listStorePrivateStruct, err = gi.StructNew("Gtk", "ListStorePrivate")
	})
	return err
}

type ListStorePrivate struct {
	native unsafe.Pointer
}

func ListStorePrivateNewFromNative(native unsafe.Pointer) *ListStorePrivate {
	err := listStorePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ListStorePrivate{native: native}

	return instance
}

/*
CastToListStorePrivate down casts any arbitrary Object to ListStorePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ListStorePrivate.
*/
func CastToListStorePrivate(object *gobject.Object) *ListStorePrivate {
	return ListStorePrivateNewFromNative(object.Native())
}

// Equals compares this ListStorePrivate with another ListStorePrivate, and returns true if they represent the same Object.
func (recv *ListStorePrivate) Equals(other *ListStorePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ListStorePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ListStorePrivateStruct creates an uninitialised ListStorePrivate.
func ListStorePrivateStruct() *ListStorePrivate {
	err := listStorePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ListStorePrivateNewFromNative(listStorePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeListStorePrivate)
	return structGo
}
func finalizeListStorePrivate(obj *ListStorePrivate) {
	listStorePrivateStruct.Free(obj.Native())
}

var lockButtonAccessibleClassStruct *gi.Struct
var lockButtonAccessibleClassStruct_Once sync.Once

func lockButtonAccessibleClassStruct_Set() error {
	var err error
	lockButtonAccessibleClassStruct_Once.Do(func() {
		lockButtonAccessibleClassStruct, err = gi.StructNew("Gtk", "LockButtonAccessibleClass")
	})
	return err
}

type LockButtonAccessibleClass struct {
	native unsafe.Pointer
}

func LockButtonAccessibleClassNewFromNative(native unsafe.Pointer) *LockButtonAccessibleClass {
	err := lockButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LockButtonAccessibleClass{native: native}

	return instance
}

/*
CastToLockButtonAccessibleClass down casts any arbitrary Object to LockButtonAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LockButtonAccessibleClass.
*/
func CastToLockButtonAccessibleClass(object *gobject.Object) *LockButtonAccessibleClass {
	return LockButtonAccessibleClassNewFromNative(object.Native())
}

// Equals compares this LockButtonAccessibleClass with another LockButtonAccessibleClass, and returns true if they represent the same Object.
func (recv *LockButtonAccessibleClass) Equals(other *LockButtonAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LockButtonAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *LockButtonAccessibleClass) FieldParentClass() *ButtonAccessibleClass {
	argValue := gi.StructFieldGet(lockButtonAccessibleClassStruct, recv.Native(), "parent_class")
	value := ButtonAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *LockButtonAccessibleClass) SetFieldParentClass(value *ButtonAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(lockButtonAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// LockButtonAccessibleClassStruct creates an uninitialised LockButtonAccessibleClass.
func LockButtonAccessibleClassStruct() *LockButtonAccessibleClass {
	err := lockButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LockButtonAccessibleClassNewFromNative(lockButtonAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLockButtonAccessibleClass)
	return structGo
}
func finalizeLockButtonAccessibleClass(obj *LockButtonAccessibleClass) {
	lockButtonAccessibleClassStruct.Free(obj.Native())
}

var lockButtonAccessiblePrivateStruct *gi.Struct
var lockButtonAccessiblePrivateStruct_Once sync.Once

func lockButtonAccessiblePrivateStruct_Set() error {
	var err error
	lockButtonAccessiblePrivateStruct_Once.Do(func() {
		lockButtonAccessiblePrivateStruct, err = gi.StructNew("Gtk", "LockButtonAccessiblePrivate")
	})
	return err
}

type LockButtonAccessiblePrivate struct {
	native unsafe.Pointer
}

func LockButtonAccessiblePrivateNewFromNative(native unsafe.Pointer) *LockButtonAccessiblePrivate {
	err := lockButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LockButtonAccessiblePrivate{native: native}

	return instance
}

/*
CastToLockButtonAccessiblePrivate down casts any arbitrary Object to LockButtonAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LockButtonAccessiblePrivate.
*/
func CastToLockButtonAccessiblePrivate(object *gobject.Object) *LockButtonAccessiblePrivate {
	return LockButtonAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this LockButtonAccessiblePrivate with another LockButtonAccessiblePrivate, and returns true if they represent the same Object.
func (recv *LockButtonAccessiblePrivate) Equals(other *LockButtonAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LockButtonAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// LockButtonAccessiblePrivateStruct creates an uninitialised LockButtonAccessiblePrivate.
func LockButtonAccessiblePrivateStruct() *LockButtonAccessiblePrivate {
	err := lockButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LockButtonAccessiblePrivateNewFromNative(lockButtonAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLockButtonAccessiblePrivate)
	return structGo
}
func finalizeLockButtonAccessiblePrivate(obj *LockButtonAccessiblePrivate) {
	lockButtonAccessiblePrivateStruct.Free(obj.Native())
}

var lockButtonClassStruct *gi.Struct
var lockButtonClassStruct_Once sync.Once

func lockButtonClassStruct_Set() error {
	var err error
	lockButtonClassStruct_Once.Do(func() {
		lockButtonClassStruct, err = gi.StructNew("Gtk", "LockButtonClass")
	})
	return err
}

type LockButtonClass struct {
	native unsafe.Pointer
}

func LockButtonClassNewFromNative(native unsafe.Pointer) *LockButtonClass {
	err := lockButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LockButtonClass{native: native}

	return instance
}

/*
CastToLockButtonClass down casts any arbitrary Object to LockButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a LockButtonClass.
*/
func CastToLockButtonClass(object *gobject.Object) *LockButtonClass {
	return LockButtonClassNewFromNative(object.Native())
}

// Equals compares this LockButtonClass with another LockButtonClass, and returns true if they represent the same Object.
func (recv *LockButtonClass) Equals(other *LockButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *LockButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *LockButtonClass) FieldParentClass() *ButtonClass {
	argValue := gi.StructFieldGet(lockButtonClassStruct, recv.Native(), "parent_class")
	value := ButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *LockButtonClass) SetFieldParentClass(value *ButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(lockButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'reserved0' : for field getter : missing Type

// UNSUPPORTED : C value 'reserved0' : for field setter : missing Type

// UNSUPPORTED : C value 'reserved1' : for field getter : missing Type

// UNSUPPORTED : C value 'reserved1' : for field setter : missing Type

// UNSUPPORTED : C value 'reserved2' : for field getter : missing Type

// UNSUPPORTED : C value 'reserved2' : for field setter : missing Type

// UNSUPPORTED : C value 'reserved3' : for field getter : missing Type

// UNSUPPORTED : C value 'reserved3' : for field setter : missing Type

// UNSUPPORTED : C value 'reserved4' : for field getter : missing Type

// UNSUPPORTED : C value 'reserved4' : for field setter : missing Type

// UNSUPPORTED : C value 'reserved5' : for field getter : missing Type

// UNSUPPORTED : C value 'reserved5' : for field setter : missing Type

// UNSUPPORTED : C value 'reserved6' : for field getter : missing Type

// UNSUPPORTED : C value 'reserved6' : for field setter : missing Type

// UNSUPPORTED : C value 'reserved7' : for field getter : missing Type

// UNSUPPORTED : C value 'reserved7' : for field setter : missing Type

// LockButtonClassStruct creates an uninitialised LockButtonClass.
func LockButtonClassStruct() *LockButtonClass {
	err := lockButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LockButtonClassNewFromNative(lockButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLockButtonClass)
	return structGo
}
func finalizeLockButtonClass(obj *LockButtonClass) {
	lockButtonClassStruct.Free(obj.Native())
}

var lockButtonPrivateStruct *gi.Struct
var lockButtonPrivateStruct_Once sync.Once

func lockButtonPrivateStruct_Set() error {
	var err error
	lockButtonPrivateStruct_Once.Do(func() {
		lockButtonPrivateStruct, err = gi.StructNew("Gtk", "LockButtonPrivate")
	})
	return err
}

type LockButtonPrivate struct {
	native unsafe.Pointer
}

func LockButtonPrivateNewFromNative(native unsafe.Pointer) *LockButtonPrivate {
	err := lockButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &LockButtonPrivate{native: native}

	return instance
}

/*
CastToLockButtonPrivate down casts any arbitrary Object to LockButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a LockButtonPrivate.
*/
func CastToLockButtonPrivate(object *gobject.Object) *LockButtonPrivate {
	return LockButtonPrivateNewFromNative(object.Native())
}

// Equals compares this LockButtonPrivate with another LockButtonPrivate, and returns true if they represent the same Object.
func (recv *LockButtonPrivate) Equals(other *LockButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *LockButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// LockButtonPrivateStruct creates an uninitialised LockButtonPrivate.
func LockButtonPrivateStruct() *LockButtonPrivate {
	err := lockButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := LockButtonPrivateNewFromNative(lockButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeLockButtonPrivate)
	return structGo
}
func finalizeLockButtonPrivate(obj *LockButtonPrivate) {
	lockButtonPrivateStruct.Free(obj.Native())
}

var menuAccessibleClassStruct *gi.Struct
var menuAccessibleClassStruct_Once sync.Once

func menuAccessibleClassStruct_Set() error {
	var err error
	menuAccessibleClassStruct_Once.Do(func() {
		menuAccessibleClassStruct, err = gi.StructNew("Gtk", "MenuAccessibleClass")
	})
	return err
}

type MenuAccessibleClass struct {
	native unsafe.Pointer
}

func MenuAccessibleClassNewFromNative(native unsafe.Pointer) *MenuAccessibleClass {
	err := menuAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuAccessibleClass{native: native}

	return instance
}

/*
CastToMenuAccessibleClass down casts any arbitrary Object to MenuAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuAccessibleClass.
*/
func CastToMenuAccessibleClass(object *gobject.Object) *MenuAccessibleClass {
	return MenuAccessibleClassNewFromNative(object.Native())
}

// Equals compares this MenuAccessibleClass with another MenuAccessibleClass, and returns true if they represent the same Object.
func (recv *MenuAccessibleClass) Equals(other *MenuAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuAccessibleClass) FieldParentClass() *MenuShellAccessibleClass {
	argValue := gi.StructFieldGet(menuAccessibleClassStruct, recv.Native(), "parent_class")
	value := MenuShellAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuAccessibleClass) SetFieldParentClass(value *MenuShellAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// MenuAccessibleClassStruct creates an uninitialised MenuAccessibleClass.
func MenuAccessibleClassStruct() *MenuAccessibleClass {
	err := menuAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuAccessibleClassNewFromNative(menuAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuAccessibleClass)
	return structGo
}
func finalizeMenuAccessibleClass(obj *MenuAccessibleClass) {
	menuAccessibleClassStruct.Free(obj.Native())
}

var menuAccessiblePrivateStruct *gi.Struct
var menuAccessiblePrivateStruct_Once sync.Once

func menuAccessiblePrivateStruct_Set() error {
	var err error
	menuAccessiblePrivateStruct_Once.Do(func() {
		menuAccessiblePrivateStruct, err = gi.StructNew("Gtk", "MenuAccessiblePrivate")
	})
	return err
}

type MenuAccessiblePrivate struct {
	native unsafe.Pointer
}

func MenuAccessiblePrivateNewFromNative(native unsafe.Pointer) *MenuAccessiblePrivate {
	err := menuAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuAccessiblePrivate{native: native}

	return instance
}

/*
CastToMenuAccessiblePrivate down casts any arbitrary Object to MenuAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuAccessiblePrivate.
*/
func CastToMenuAccessiblePrivate(object *gobject.Object) *MenuAccessiblePrivate {
	return MenuAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this MenuAccessiblePrivate with another MenuAccessiblePrivate, and returns true if they represent the same Object.
func (recv *MenuAccessiblePrivate) Equals(other *MenuAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuAccessiblePrivateStruct creates an uninitialised MenuAccessiblePrivate.
func MenuAccessiblePrivateStruct() *MenuAccessiblePrivate {
	err := menuAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuAccessiblePrivateNewFromNative(menuAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuAccessiblePrivate)
	return structGo
}
func finalizeMenuAccessiblePrivate(obj *MenuAccessiblePrivate) {
	menuAccessiblePrivateStruct.Free(obj.Native())
}

var menuBarClassStruct *gi.Struct
var menuBarClassStruct_Once sync.Once

func menuBarClassStruct_Set() error {
	var err error
	menuBarClassStruct_Once.Do(func() {
		menuBarClassStruct, err = gi.StructNew("Gtk", "MenuBarClass")
	})
	return err
}

type MenuBarClass struct {
	native unsafe.Pointer
}

func MenuBarClassNewFromNative(native unsafe.Pointer) *MenuBarClass {
	err := menuBarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuBarClass{native: native}

	return instance
}

/*
CastToMenuBarClass down casts any arbitrary Object to MenuBarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuBarClass.
*/
func CastToMenuBarClass(object *gobject.Object) *MenuBarClass {
	return MenuBarClassNewFromNative(object.Native())
}

// Equals compares this MenuBarClass with another MenuBarClass, and returns true if they represent the same Object.
func (recv *MenuBarClass) Equals(other *MenuBarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuBarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuBarClass) FieldParentClass() *MenuShellClass {
	argValue := gi.StructFieldGet(menuBarClassStruct, recv.Native(), "parent_class")
	value := MenuShellClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuBarClass) SetFieldParentClass(value *MenuShellClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuBarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MenuBarClassStruct creates an uninitialised MenuBarClass.
func MenuBarClassStruct() *MenuBarClass {
	err := menuBarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuBarClassNewFromNative(menuBarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuBarClass)
	return structGo
}
func finalizeMenuBarClass(obj *MenuBarClass) {
	menuBarClassStruct.Free(obj.Native())
}

var menuBarPrivateStruct *gi.Struct
var menuBarPrivateStruct_Once sync.Once

func menuBarPrivateStruct_Set() error {
	var err error
	menuBarPrivateStruct_Once.Do(func() {
		menuBarPrivateStruct, err = gi.StructNew("Gtk", "MenuBarPrivate")
	})
	return err
}

type MenuBarPrivate struct {
	native unsafe.Pointer
}

func MenuBarPrivateNewFromNative(native unsafe.Pointer) *MenuBarPrivate {
	err := menuBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuBarPrivate{native: native}

	return instance
}

/*
CastToMenuBarPrivate down casts any arbitrary Object to MenuBarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuBarPrivate.
*/
func CastToMenuBarPrivate(object *gobject.Object) *MenuBarPrivate {
	return MenuBarPrivateNewFromNative(object.Native())
}

// Equals compares this MenuBarPrivate with another MenuBarPrivate, and returns true if they represent the same Object.
func (recv *MenuBarPrivate) Equals(other *MenuBarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuBarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuBarPrivateStruct creates an uninitialised MenuBarPrivate.
func MenuBarPrivateStruct() *MenuBarPrivate {
	err := menuBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuBarPrivateNewFromNative(menuBarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuBarPrivate)
	return structGo
}
func finalizeMenuBarPrivate(obj *MenuBarPrivate) {
	menuBarPrivateStruct.Free(obj.Native())
}

var menuButtonAccessibleClassStruct *gi.Struct
var menuButtonAccessibleClassStruct_Once sync.Once

func menuButtonAccessibleClassStruct_Set() error {
	var err error
	menuButtonAccessibleClassStruct_Once.Do(func() {
		menuButtonAccessibleClassStruct, err = gi.StructNew("Gtk", "MenuButtonAccessibleClass")
	})
	return err
}

type MenuButtonAccessibleClass struct {
	native unsafe.Pointer
}

func MenuButtonAccessibleClassNewFromNative(native unsafe.Pointer) *MenuButtonAccessibleClass {
	err := menuButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuButtonAccessibleClass{native: native}

	return instance
}

/*
CastToMenuButtonAccessibleClass down casts any arbitrary Object to MenuButtonAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuButtonAccessibleClass.
*/
func CastToMenuButtonAccessibleClass(object *gobject.Object) *MenuButtonAccessibleClass {
	return MenuButtonAccessibleClassNewFromNative(object.Native())
}

// Equals compares this MenuButtonAccessibleClass with another MenuButtonAccessibleClass, and returns true if they represent the same Object.
func (recv *MenuButtonAccessibleClass) Equals(other *MenuButtonAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuButtonAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuButtonAccessibleClass) FieldParentClass() *ToggleButtonAccessibleClass {
	argValue := gi.StructFieldGet(menuButtonAccessibleClassStruct, recv.Native(), "parent_class")
	value := ToggleButtonAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuButtonAccessibleClass) SetFieldParentClass(value *ToggleButtonAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuButtonAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// MenuButtonAccessibleClassStruct creates an uninitialised MenuButtonAccessibleClass.
func MenuButtonAccessibleClassStruct() *MenuButtonAccessibleClass {
	err := menuButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuButtonAccessibleClassNewFromNative(menuButtonAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuButtonAccessibleClass)
	return structGo
}
func finalizeMenuButtonAccessibleClass(obj *MenuButtonAccessibleClass) {
	menuButtonAccessibleClassStruct.Free(obj.Native())
}

var menuButtonAccessiblePrivateStruct *gi.Struct
var menuButtonAccessiblePrivateStruct_Once sync.Once

func menuButtonAccessiblePrivateStruct_Set() error {
	var err error
	menuButtonAccessiblePrivateStruct_Once.Do(func() {
		menuButtonAccessiblePrivateStruct, err = gi.StructNew("Gtk", "MenuButtonAccessiblePrivate")
	})
	return err
}

type MenuButtonAccessiblePrivate struct {
	native unsafe.Pointer
}

func MenuButtonAccessiblePrivateNewFromNative(native unsafe.Pointer) *MenuButtonAccessiblePrivate {
	err := menuButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuButtonAccessiblePrivate{native: native}

	return instance
}

/*
CastToMenuButtonAccessiblePrivate down casts any arbitrary Object to MenuButtonAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuButtonAccessiblePrivate.
*/
func CastToMenuButtonAccessiblePrivate(object *gobject.Object) *MenuButtonAccessiblePrivate {
	return MenuButtonAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this MenuButtonAccessiblePrivate with another MenuButtonAccessiblePrivate, and returns true if they represent the same Object.
func (recv *MenuButtonAccessiblePrivate) Equals(other *MenuButtonAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuButtonAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuButtonAccessiblePrivateStruct creates an uninitialised MenuButtonAccessiblePrivate.
func MenuButtonAccessiblePrivateStruct() *MenuButtonAccessiblePrivate {
	err := menuButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuButtonAccessiblePrivateNewFromNative(menuButtonAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuButtonAccessiblePrivate)
	return structGo
}
func finalizeMenuButtonAccessiblePrivate(obj *MenuButtonAccessiblePrivate) {
	menuButtonAccessiblePrivateStruct.Free(obj.Native())
}

var menuButtonClassStruct *gi.Struct
var menuButtonClassStruct_Once sync.Once

func menuButtonClassStruct_Set() error {
	var err error
	menuButtonClassStruct_Once.Do(func() {
		menuButtonClassStruct, err = gi.StructNew("Gtk", "MenuButtonClass")
	})
	return err
}

type MenuButtonClass struct {
	native unsafe.Pointer
}

func MenuButtonClassNewFromNative(native unsafe.Pointer) *MenuButtonClass {
	err := menuButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuButtonClass{native: native}

	return instance
}

/*
CastToMenuButtonClass down casts any arbitrary Object to MenuButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuButtonClass.
*/
func CastToMenuButtonClass(object *gobject.Object) *MenuButtonClass {
	return MenuButtonClassNewFromNative(object.Native())
}

// Equals compares this MenuButtonClass with another MenuButtonClass, and returns true if they represent the same Object.
func (recv *MenuButtonClass) Equals(other *MenuButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuButtonClass) FieldParentClass() *ToggleButtonClass {
	argValue := gi.StructFieldGet(menuButtonClassStruct, recv.Native(), "parent_class")
	value := ToggleButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuButtonClass) SetFieldParentClass(value *ToggleButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MenuButtonClassStruct creates an uninitialised MenuButtonClass.
func MenuButtonClassStruct() *MenuButtonClass {
	err := menuButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuButtonClassNewFromNative(menuButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuButtonClass)
	return structGo
}
func finalizeMenuButtonClass(obj *MenuButtonClass) {
	menuButtonClassStruct.Free(obj.Native())
}

var menuButtonPrivateStruct *gi.Struct
var menuButtonPrivateStruct_Once sync.Once

func menuButtonPrivateStruct_Set() error {
	var err error
	menuButtonPrivateStruct_Once.Do(func() {
		menuButtonPrivateStruct, err = gi.StructNew("Gtk", "MenuButtonPrivate")
	})
	return err
}

type MenuButtonPrivate struct {
	native unsafe.Pointer
}

func MenuButtonPrivateNewFromNative(native unsafe.Pointer) *MenuButtonPrivate {
	err := menuButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuButtonPrivate{native: native}

	return instance
}

/*
CastToMenuButtonPrivate down casts any arbitrary Object to MenuButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuButtonPrivate.
*/
func CastToMenuButtonPrivate(object *gobject.Object) *MenuButtonPrivate {
	return MenuButtonPrivateNewFromNative(object.Native())
}

// Equals compares this MenuButtonPrivate with another MenuButtonPrivate, and returns true if they represent the same Object.
func (recv *MenuButtonPrivate) Equals(other *MenuButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuButtonPrivateStruct creates an uninitialised MenuButtonPrivate.
func MenuButtonPrivateStruct() *MenuButtonPrivate {
	err := menuButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuButtonPrivateNewFromNative(menuButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuButtonPrivate)
	return structGo
}
func finalizeMenuButtonPrivate(obj *MenuButtonPrivate) {
	menuButtonPrivateStruct.Free(obj.Native())
}

var menuClassStruct *gi.Struct
var menuClassStruct_Once sync.Once

func menuClassStruct_Set() error {
	var err error
	menuClassStruct_Once.Do(func() {
		menuClassStruct, err = gi.StructNew("Gtk", "MenuClass")
	})
	return err
}

type MenuClass struct {
	native unsafe.Pointer
}

func MenuClassNewFromNative(native unsafe.Pointer) *MenuClass {
	err := menuClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuClass{native: native}

	return instance
}

/*
CastToMenuClass down casts any arbitrary Object to MenuClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuClass.
*/
func CastToMenuClass(object *gobject.Object) *MenuClass {
	return MenuClassNewFromNative(object.Native())
}

// Equals compares this MenuClass with another MenuClass, and returns true if they represent the same Object.
func (recv *MenuClass) Equals(other *MenuClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuClass) FieldParentClass() *MenuShellClass {
	argValue := gi.StructFieldGet(menuClassStruct, recv.Native(), "parent_class")
	value := MenuShellClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuClass) SetFieldParentClass(value *MenuShellClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MenuClassStruct creates an uninitialised MenuClass.
func MenuClassStruct() *MenuClass {
	err := menuClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuClassNewFromNative(menuClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuClass)
	return structGo
}
func finalizeMenuClass(obj *MenuClass) {
	menuClassStruct.Free(obj.Native())
}

var menuItemAccessibleClassStruct *gi.Struct
var menuItemAccessibleClassStruct_Once sync.Once

func menuItemAccessibleClassStruct_Set() error {
	var err error
	menuItemAccessibleClassStruct_Once.Do(func() {
		menuItemAccessibleClassStruct, err = gi.StructNew("Gtk", "MenuItemAccessibleClass")
	})
	return err
}

type MenuItemAccessibleClass struct {
	native unsafe.Pointer
}

func MenuItemAccessibleClassNewFromNative(native unsafe.Pointer) *MenuItemAccessibleClass {
	err := menuItemAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuItemAccessibleClass{native: native}

	return instance
}

/*
CastToMenuItemAccessibleClass down casts any arbitrary Object to MenuItemAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuItemAccessibleClass.
*/
func CastToMenuItemAccessibleClass(object *gobject.Object) *MenuItemAccessibleClass {
	return MenuItemAccessibleClassNewFromNative(object.Native())
}

// Equals compares this MenuItemAccessibleClass with another MenuItemAccessibleClass, and returns true if they represent the same Object.
func (recv *MenuItemAccessibleClass) Equals(other *MenuItemAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuItemAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuItemAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(menuItemAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuItemAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuItemAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// MenuItemAccessibleClassStruct creates an uninitialised MenuItemAccessibleClass.
func MenuItemAccessibleClassStruct() *MenuItemAccessibleClass {
	err := menuItemAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuItemAccessibleClassNewFromNative(menuItemAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuItemAccessibleClass)
	return structGo
}
func finalizeMenuItemAccessibleClass(obj *MenuItemAccessibleClass) {
	menuItemAccessibleClassStruct.Free(obj.Native())
}

var menuItemAccessiblePrivateStruct *gi.Struct
var menuItemAccessiblePrivateStruct_Once sync.Once

func menuItemAccessiblePrivateStruct_Set() error {
	var err error
	menuItemAccessiblePrivateStruct_Once.Do(func() {
		menuItemAccessiblePrivateStruct, err = gi.StructNew("Gtk", "MenuItemAccessiblePrivate")
	})
	return err
}

type MenuItemAccessiblePrivate struct {
	native unsafe.Pointer
}

func MenuItemAccessiblePrivateNewFromNative(native unsafe.Pointer) *MenuItemAccessiblePrivate {
	err := menuItemAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuItemAccessiblePrivate{native: native}

	return instance
}

/*
CastToMenuItemAccessiblePrivate down casts any arbitrary Object to MenuItemAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuItemAccessiblePrivate.
*/
func CastToMenuItemAccessiblePrivate(object *gobject.Object) *MenuItemAccessiblePrivate {
	return MenuItemAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this MenuItemAccessiblePrivate with another MenuItemAccessiblePrivate, and returns true if they represent the same Object.
func (recv *MenuItemAccessiblePrivate) Equals(other *MenuItemAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuItemAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuItemAccessiblePrivateStruct creates an uninitialised MenuItemAccessiblePrivate.
func MenuItemAccessiblePrivateStruct() *MenuItemAccessiblePrivate {
	err := menuItemAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuItemAccessiblePrivateNewFromNative(menuItemAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuItemAccessiblePrivate)
	return structGo
}
func finalizeMenuItemAccessiblePrivate(obj *MenuItemAccessiblePrivate) {
	menuItemAccessiblePrivateStruct.Free(obj.Native())
}

var menuItemClassStruct *gi.Struct
var menuItemClassStruct_Once sync.Once

func menuItemClassStruct_Set() error {
	var err error
	menuItemClassStruct_Once.Do(func() {
		menuItemClassStruct, err = gi.StructNew("Gtk", "MenuItemClass")
	})
	return err
}

type MenuItemClass struct {
	native unsafe.Pointer
}

func MenuItemClassNewFromNative(native unsafe.Pointer) *MenuItemClass {
	err := menuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuItemClass{native: native}

	return instance
}

/*
CastToMenuItemClass down casts any arbitrary Object to MenuItemClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuItemClass.
*/
func CastToMenuItemClass(object *gobject.Object) *MenuItemClass {
	return MenuItemClassNewFromNative(object.Native())
}

// Equals compares this MenuItemClass with another MenuItemClass, and returns true if they represent the same Object.
func (recv *MenuItemClass) Equals(other *MenuItemClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuItemClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuItemClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(menuItemClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuItemClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuItemClassStruct, recv.Native(), "parent_class", argValue)
}

// FieldHideOnActivate returns the C field 'hide_on_activate'.
func (recv *MenuItemClass) FieldHideOnActivate() uint32 {
	argValue := gi.StructFieldGet(menuItemClassStruct, recv.Native(), "hide_on_activate")
	value := argValue.Uint32()
	return value
}

// SetFieldHideOnActivate sets the value of the C field 'hide_on_activate'.
func (recv *MenuItemClass) SetFieldHideOnActivate(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(menuItemClassStruct, recv.Native(), "hide_on_activate", argValue)
}

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value 'activate_item' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_item' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_size_request' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_size_request' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_size_allocate' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_size_allocate' : for field setter : missing Type

// UNSUPPORTED : C value 'set_label' : for field getter : missing Type

// UNSUPPORTED : C value 'set_label' : for field setter : missing Type

// UNSUPPORTED : C value 'get_label' : for field getter : missing Type

// UNSUPPORTED : C value 'get_label' : for field setter : missing Type

// UNSUPPORTED : C value 'select' : for field getter : missing Type

// UNSUPPORTED : C value 'select' : for field setter : missing Type

// UNSUPPORTED : C value 'deselect' : for field getter : missing Type

// UNSUPPORTED : C value 'deselect' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MenuItemClassStruct creates an uninitialised MenuItemClass.
func MenuItemClassStruct() *MenuItemClass {
	err := menuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuItemClassNewFromNative(menuItemClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuItemClass)
	return structGo
}
func finalizeMenuItemClass(obj *MenuItemClass) {
	menuItemClassStruct.Free(obj.Native())
}

var menuItemPrivateStruct *gi.Struct
var menuItemPrivateStruct_Once sync.Once

func menuItemPrivateStruct_Set() error {
	var err error
	menuItemPrivateStruct_Once.Do(func() {
		menuItemPrivateStruct, err = gi.StructNew("Gtk", "MenuItemPrivate")
	})
	return err
}

type MenuItemPrivate struct {
	native unsafe.Pointer
}

func MenuItemPrivateNewFromNative(native unsafe.Pointer) *MenuItemPrivate {
	err := menuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuItemPrivate{native: native}

	return instance
}

/*
CastToMenuItemPrivate down casts any arbitrary Object to MenuItemPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuItemPrivate.
*/
func CastToMenuItemPrivate(object *gobject.Object) *MenuItemPrivate {
	return MenuItemPrivateNewFromNative(object.Native())
}

// Equals compares this MenuItemPrivate with another MenuItemPrivate, and returns true if they represent the same Object.
func (recv *MenuItemPrivate) Equals(other *MenuItemPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuItemPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuItemPrivateStruct creates an uninitialised MenuItemPrivate.
func MenuItemPrivateStruct() *MenuItemPrivate {
	err := menuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuItemPrivateNewFromNative(menuItemPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuItemPrivate)
	return structGo
}
func finalizeMenuItemPrivate(obj *MenuItemPrivate) {
	menuItemPrivateStruct.Free(obj.Native())
}

var menuPrivateStruct *gi.Struct
var menuPrivateStruct_Once sync.Once

func menuPrivateStruct_Set() error {
	var err error
	menuPrivateStruct_Once.Do(func() {
		menuPrivateStruct, err = gi.StructNew("Gtk", "MenuPrivate")
	})
	return err
}

type MenuPrivate struct {
	native unsafe.Pointer
}

func MenuPrivateNewFromNative(native unsafe.Pointer) *MenuPrivate {
	err := menuPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuPrivate{native: native}

	return instance
}

/*
CastToMenuPrivate down casts any arbitrary Object to MenuPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuPrivate.
*/
func CastToMenuPrivate(object *gobject.Object) *MenuPrivate {
	return MenuPrivateNewFromNative(object.Native())
}

// Equals compares this MenuPrivate with another MenuPrivate, and returns true if they represent the same Object.
func (recv *MenuPrivate) Equals(other *MenuPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuPrivateStruct creates an uninitialised MenuPrivate.
func MenuPrivateStruct() *MenuPrivate {
	err := menuPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuPrivateNewFromNative(menuPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuPrivate)
	return structGo
}
func finalizeMenuPrivate(obj *MenuPrivate) {
	menuPrivateStruct.Free(obj.Native())
}

var menuShellAccessibleClassStruct *gi.Struct
var menuShellAccessibleClassStruct_Once sync.Once

func menuShellAccessibleClassStruct_Set() error {
	var err error
	menuShellAccessibleClassStruct_Once.Do(func() {
		menuShellAccessibleClassStruct, err = gi.StructNew("Gtk", "MenuShellAccessibleClass")
	})
	return err
}

type MenuShellAccessibleClass struct {
	native unsafe.Pointer
}

func MenuShellAccessibleClassNewFromNative(native unsafe.Pointer) *MenuShellAccessibleClass {
	err := menuShellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuShellAccessibleClass{native: native}

	return instance
}

/*
CastToMenuShellAccessibleClass down casts any arbitrary Object to MenuShellAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuShellAccessibleClass.
*/
func CastToMenuShellAccessibleClass(object *gobject.Object) *MenuShellAccessibleClass {
	return MenuShellAccessibleClassNewFromNative(object.Native())
}

// Equals compares this MenuShellAccessibleClass with another MenuShellAccessibleClass, and returns true if they represent the same Object.
func (recv *MenuShellAccessibleClass) Equals(other *MenuShellAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuShellAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuShellAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(menuShellAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuShellAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuShellAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// MenuShellAccessibleClassStruct creates an uninitialised MenuShellAccessibleClass.
func MenuShellAccessibleClassStruct() *MenuShellAccessibleClass {
	err := menuShellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuShellAccessibleClassNewFromNative(menuShellAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuShellAccessibleClass)
	return structGo
}
func finalizeMenuShellAccessibleClass(obj *MenuShellAccessibleClass) {
	menuShellAccessibleClassStruct.Free(obj.Native())
}

var menuShellAccessiblePrivateStruct *gi.Struct
var menuShellAccessiblePrivateStruct_Once sync.Once

func menuShellAccessiblePrivateStruct_Set() error {
	var err error
	menuShellAccessiblePrivateStruct_Once.Do(func() {
		menuShellAccessiblePrivateStruct, err = gi.StructNew("Gtk", "MenuShellAccessiblePrivate")
	})
	return err
}

type MenuShellAccessiblePrivate struct {
	native unsafe.Pointer
}

func MenuShellAccessiblePrivateNewFromNative(native unsafe.Pointer) *MenuShellAccessiblePrivate {
	err := menuShellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuShellAccessiblePrivate{native: native}

	return instance
}

/*
CastToMenuShellAccessiblePrivate down casts any arbitrary Object to MenuShellAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuShellAccessiblePrivate.
*/
func CastToMenuShellAccessiblePrivate(object *gobject.Object) *MenuShellAccessiblePrivate {
	return MenuShellAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this MenuShellAccessiblePrivate with another MenuShellAccessiblePrivate, and returns true if they represent the same Object.
func (recv *MenuShellAccessiblePrivate) Equals(other *MenuShellAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuShellAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuShellAccessiblePrivateStruct creates an uninitialised MenuShellAccessiblePrivate.
func MenuShellAccessiblePrivateStruct() *MenuShellAccessiblePrivate {
	err := menuShellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuShellAccessiblePrivateNewFromNative(menuShellAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuShellAccessiblePrivate)
	return structGo
}
func finalizeMenuShellAccessiblePrivate(obj *MenuShellAccessiblePrivate) {
	menuShellAccessiblePrivateStruct.Free(obj.Native())
}

var menuShellClassStruct *gi.Struct
var menuShellClassStruct_Once sync.Once

func menuShellClassStruct_Set() error {
	var err error
	menuShellClassStruct_Once.Do(func() {
		menuShellClassStruct, err = gi.StructNew("Gtk", "MenuShellClass")
	})
	return err
}

type MenuShellClass struct {
	native unsafe.Pointer
}

func MenuShellClassNewFromNative(native unsafe.Pointer) *MenuShellClass {
	err := menuShellClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuShellClass{native: native}

	return instance
}

/*
CastToMenuShellClass down casts any arbitrary Object to MenuShellClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuShellClass.
*/
func CastToMenuShellClass(object *gobject.Object) *MenuShellClass {
	return MenuShellClassNewFromNative(object.Native())
}

// Equals compares this MenuShellClass with another MenuShellClass, and returns true if they represent the same Object.
func (recv *MenuShellClass) Equals(other *MenuShellClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuShellClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuShellClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(menuShellClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuShellClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuShellClassStruct, recv.Native(), "parent_class", argValue)
}

// FieldSubmenuPlacement returns the C field 'submenu_placement'.
func (recv *MenuShellClass) FieldSubmenuPlacement() uint32 {
	argValue := gi.StructFieldGet(menuShellClassStruct, recv.Native(), "submenu_placement")
	value := argValue.Uint32()
	return value
}

// SetFieldSubmenuPlacement sets the value of the C field 'submenu_placement'.
func (recv *MenuShellClass) SetFieldSubmenuPlacement(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(menuShellClassStruct, recv.Native(), "submenu_placement", argValue)
}

// UNSUPPORTED : C value 'deactivate' : for field getter : missing Type

// UNSUPPORTED : C value 'deactivate' : for field setter : missing Type

// UNSUPPORTED : C value 'selection_done' : for field getter : missing Type

// UNSUPPORTED : C value 'selection_done' : for field setter : missing Type

// UNSUPPORTED : C value 'move_current' : for field getter : missing Type

// UNSUPPORTED : C value 'move_current' : for field setter : missing Type

// UNSUPPORTED : C value 'activate_current' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_current' : for field setter : missing Type

// UNSUPPORTED : C value 'cancel' : for field getter : missing Type

// UNSUPPORTED : C value 'cancel' : for field setter : missing Type

// UNSUPPORTED : C value 'select_item' : for field getter : missing Type

// UNSUPPORTED : C value 'select_item' : for field setter : missing Type

// UNSUPPORTED : C value 'insert' : for field getter : missing Type

// UNSUPPORTED : C value 'insert' : for field setter : missing Type

// UNSUPPORTED : C value 'get_popup_delay' : for field getter : missing Type

// UNSUPPORTED : C value 'get_popup_delay' : for field setter : missing Type

// UNSUPPORTED : C value 'move_selected' : for field getter : missing Type

// UNSUPPORTED : C value 'move_selected' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MenuShellClassStruct creates an uninitialised MenuShellClass.
func MenuShellClassStruct() *MenuShellClass {
	err := menuShellClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuShellClassNewFromNative(menuShellClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuShellClass)
	return structGo
}
func finalizeMenuShellClass(obj *MenuShellClass) {
	menuShellClassStruct.Free(obj.Native())
}

var menuShellPrivateStruct *gi.Struct
var menuShellPrivateStruct_Once sync.Once

func menuShellPrivateStruct_Set() error {
	var err error
	menuShellPrivateStruct_Once.Do(func() {
		menuShellPrivateStruct, err = gi.StructNew("Gtk", "MenuShellPrivate")
	})
	return err
}

type MenuShellPrivate struct {
	native unsafe.Pointer
}

func MenuShellPrivateNewFromNative(native unsafe.Pointer) *MenuShellPrivate {
	err := menuShellPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuShellPrivate{native: native}

	return instance
}

/*
CastToMenuShellPrivate down casts any arbitrary Object to MenuShellPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuShellPrivate.
*/
func CastToMenuShellPrivate(object *gobject.Object) *MenuShellPrivate {
	return MenuShellPrivateNewFromNative(object.Native())
}

// Equals compares this MenuShellPrivate with another MenuShellPrivate, and returns true if they represent the same Object.
func (recv *MenuShellPrivate) Equals(other *MenuShellPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuShellPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuShellPrivateStruct creates an uninitialised MenuShellPrivate.
func MenuShellPrivateStruct() *MenuShellPrivate {
	err := menuShellPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuShellPrivateNewFromNative(menuShellPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuShellPrivate)
	return structGo
}
func finalizeMenuShellPrivate(obj *MenuShellPrivate) {
	menuShellPrivateStruct.Free(obj.Native())
}

var menuToolButtonClassStruct *gi.Struct
var menuToolButtonClassStruct_Once sync.Once

func menuToolButtonClassStruct_Set() error {
	var err error
	menuToolButtonClassStruct_Once.Do(func() {
		menuToolButtonClassStruct, err = gi.StructNew("Gtk", "MenuToolButtonClass")
	})
	return err
}

type MenuToolButtonClass struct {
	native unsafe.Pointer
}

func MenuToolButtonClassNewFromNative(native unsafe.Pointer) *MenuToolButtonClass {
	err := menuToolButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuToolButtonClass{native: native}

	return instance
}

/*
CastToMenuToolButtonClass down casts any arbitrary Object to MenuToolButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuToolButtonClass.
*/
func CastToMenuToolButtonClass(object *gobject.Object) *MenuToolButtonClass {
	return MenuToolButtonClassNewFromNative(object.Native())
}

// Equals compares this MenuToolButtonClass with another MenuToolButtonClass, and returns true if they represent the same Object.
func (recv *MenuToolButtonClass) Equals(other *MenuToolButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuToolButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MenuToolButtonClass) FieldParentClass() *ToolButtonClass {
	argValue := gi.StructFieldGet(menuToolButtonClassStruct, recv.Native(), "parent_class")
	value := ToolButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MenuToolButtonClass) SetFieldParentClass(value *ToolButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(menuToolButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'show_menu' : for field getter : missing Type

// UNSUPPORTED : C value 'show_menu' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MenuToolButtonClassStruct creates an uninitialised MenuToolButtonClass.
func MenuToolButtonClassStruct() *MenuToolButtonClass {
	err := menuToolButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuToolButtonClassNewFromNative(menuToolButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuToolButtonClass)
	return structGo
}
func finalizeMenuToolButtonClass(obj *MenuToolButtonClass) {
	menuToolButtonClassStruct.Free(obj.Native())
}

var menuToolButtonPrivateStruct *gi.Struct
var menuToolButtonPrivateStruct_Once sync.Once

func menuToolButtonPrivateStruct_Set() error {
	var err error
	menuToolButtonPrivateStruct_Once.Do(func() {
		menuToolButtonPrivateStruct, err = gi.StructNew("Gtk", "MenuToolButtonPrivate")
	})
	return err
}

type MenuToolButtonPrivate struct {
	native unsafe.Pointer
}

func MenuToolButtonPrivateNewFromNative(native unsafe.Pointer) *MenuToolButtonPrivate {
	err := menuToolButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MenuToolButtonPrivate{native: native}

	return instance
}

/*
CastToMenuToolButtonPrivate down casts any arbitrary Object to MenuToolButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MenuToolButtonPrivate.
*/
func CastToMenuToolButtonPrivate(object *gobject.Object) *MenuToolButtonPrivate {
	return MenuToolButtonPrivateNewFromNative(object.Native())
}

// Equals compares this MenuToolButtonPrivate with another MenuToolButtonPrivate, and returns true if they represent the same Object.
func (recv *MenuToolButtonPrivate) Equals(other *MenuToolButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MenuToolButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MenuToolButtonPrivateStruct creates an uninitialised MenuToolButtonPrivate.
func MenuToolButtonPrivateStruct() *MenuToolButtonPrivate {
	err := menuToolButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MenuToolButtonPrivateNewFromNative(menuToolButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMenuToolButtonPrivate)
	return structGo
}
func finalizeMenuToolButtonPrivate(obj *MenuToolButtonPrivate) {
	menuToolButtonPrivateStruct.Free(obj.Native())
}

var messageDialogClassStruct *gi.Struct
var messageDialogClassStruct_Once sync.Once

func messageDialogClassStruct_Set() error {
	var err error
	messageDialogClassStruct_Once.Do(func() {
		messageDialogClassStruct, err = gi.StructNew("Gtk", "MessageDialogClass")
	})
	return err
}

type MessageDialogClass struct {
	native unsafe.Pointer
}

func MessageDialogClassNewFromNative(native unsafe.Pointer) *MessageDialogClass {
	err := messageDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MessageDialogClass{native: native}

	return instance
}

/*
CastToMessageDialogClass down casts any arbitrary Object to MessageDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MessageDialogClass.
*/
func CastToMessageDialogClass(object *gobject.Object) *MessageDialogClass {
	return MessageDialogClassNewFromNative(object.Native())
}

// Equals compares this MessageDialogClass with another MessageDialogClass, and returns true if they represent the same Object.
func (recv *MessageDialogClass) Equals(other *MessageDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MessageDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MessageDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(messageDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MessageDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(messageDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MessageDialogClassStruct creates an uninitialised MessageDialogClass.
func MessageDialogClassStruct() *MessageDialogClass {
	err := messageDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MessageDialogClassNewFromNative(messageDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMessageDialogClass)
	return structGo
}
func finalizeMessageDialogClass(obj *MessageDialogClass) {
	messageDialogClassStruct.Free(obj.Native())
}

var messageDialogPrivateStruct *gi.Struct
var messageDialogPrivateStruct_Once sync.Once

func messageDialogPrivateStruct_Set() error {
	var err error
	messageDialogPrivateStruct_Once.Do(func() {
		messageDialogPrivateStruct, err = gi.StructNew("Gtk", "MessageDialogPrivate")
	})
	return err
}

type MessageDialogPrivate struct {
	native unsafe.Pointer
}

func MessageDialogPrivateNewFromNative(native unsafe.Pointer) *MessageDialogPrivate {
	err := messageDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MessageDialogPrivate{native: native}

	return instance
}

/*
CastToMessageDialogPrivate down casts any arbitrary Object to MessageDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MessageDialogPrivate.
*/
func CastToMessageDialogPrivate(object *gobject.Object) *MessageDialogPrivate {
	return MessageDialogPrivateNewFromNative(object.Native())
}

// Equals compares this MessageDialogPrivate with another MessageDialogPrivate, and returns true if they represent the same Object.
func (recv *MessageDialogPrivate) Equals(other *MessageDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MessageDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MessageDialogPrivateStruct creates an uninitialised MessageDialogPrivate.
func MessageDialogPrivateStruct() *MessageDialogPrivate {
	err := messageDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MessageDialogPrivateNewFromNative(messageDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMessageDialogPrivate)
	return structGo
}
func finalizeMessageDialogPrivate(obj *MessageDialogPrivate) {
	messageDialogPrivateStruct.Free(obj.Native())
}

var miscClassStruct *gi.Struct
var miscClassStruct_Once sync.Once

func miscClassStruct_Set() error {
	var err error
	miscClassStruct_Once.Do(func() {
		miscClassStruct, err = gi.StructNew("Gtk", "MiscClass")
	})
	return err
}

type MiscClass struct {
	native unsafe.Pointer
}

func MiscClassNewFromNative(native unsafe.Pointer) *MiscClass {
	err := miscClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MiscClass{native: native}

	return instance
}

/*
CastToMiscClass down casts any arbitrary Object to MiscClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MiscClass.
*/
func CastToMiscClass(object *gobject.Object) *MiscClass {
	return MiscClassNewFromNative(object.Native())
}

// Equals compares this MiscClass with another MiscClass, and returns true if they represent the same Object.
func (recv *MiscClass) Equals(other *MiscClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MiscClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MiscClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(miscClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MiscClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(miscClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MiscClassStruct creates an uninitialised MiscClass.
func MiscClassStruct() *MiscClass {
	err := miscClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MiscClassNewFromNative(miscClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMiscClass)
	return structGo
}
func finalizeMiscClass(obj *MiscClass) {
	miscClassStruct.Free(obj.Native())
}

var miscPrivateStruct *gi.Struct
var miscPrivateStruct_Once sync.Once

func miscPrivateStruct_Set() error {
	var err error
	miscPrivateStruct_Once.Do(func() {
		miscPrivateStruct, err = gi.StructNew("Gtk", "MiscPrivate")
	})
	return err
}

type MiscPrivate struct {
	native unsafe.Pointer
}

func MiscPrivateNewFromNative(native unsafe.Pointer) *MiscPrivate {
	err := miscPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MiscPrivate{native: native}

	return instance
}

/*
CastToMiscPrivate down casts any arbitrary Object to MiscPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MiscPrivate.
*/
func CastToMiscPrivate(object *gobject.Object) *MiscPrivate {
	return MiscPrivateNewFromNative(object.Native())
}

// Equals compares this MiscPrivate with another MiscPrivate, and returns true if they represent the same Object.
func (recv *MiscPrivate) Equals(other *MiscPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MiscPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MiscPrivateStruct creates an uninitialised MiscPrivate.
func MiscPrivateStruct() *MiscPrivate {
	err := miscPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MiscPrivateNewFromNative(miscPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMiscPrivate)
	return structGo
}
func finalizeMiscPrivate(obj *MiscPrivate) {
	miscPrivateStruct.Free(obj.Native())
}

var mountOperationClassStruct *gi.Struct
var mountOperationClassStruct_Once sync.Once

func mountOperationClassStruct_Set() error {
	var err error
	mountOperationClassStruct_Once.Do(func() {
		mountOperationClassStruct, err = gi.StructNew("Gtk", "MountOperationClass")
	})
	return err
}

type MountOperationClass struct {
	native unsafe.Pointer
}

func MountOperationClassNewFromNative(native unsafe.Pointer) *MountOperationClass {
	err := mountOperationClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MountOperationClass{native: native}

	return instance
}

/*
CastToMountOperationClass down casts any arbitrary Object to MountOperationClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a MountOperationClass.
*/
func CastToMountOperationClass(object *gobject.Object) *MountOperationClass {
	return MountOperationClassNewFromNative(object.Native())
}

// Equals compares this MountOperationClass with another MountOperationClass, and returns true if they represent the same Object.
func (recv *MountOperationClass) Equals(other *MountOperationClass) bool {
	return other.Native() == recv.Native()
}

func (recv *MountOperationClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *MountOperationClass) FieldParentClass() *gio.MountOperationClass {
	argValue := gi.StructFieldGet(mountOperationClassStruct, recv.Native(), "parent_class")
	value := gio.MountOperationClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *MountOperationClass) SetFieldParentClass(value *gio.MountOperationClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(mountOperationClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// MountOperationClassStruct creates an uninitialised MountOperationClass.
func MountOperationClassStruct() *MountOperationClass {
	err := mountOperationClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MountOperationClassNewFromNative(mountOperationClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMountOperationClass)
	return structGo
}
func finalizeMountOperationClass(obj *MountOperationClass) {
	mountOperationClassStruct.Free(obj.Native())
}

var mountOperationPrivateStruct *gi.Struct
var mountOperationPrivateStruct_Once sync.Once

func mountOperationPrivateStruct_Set() error {
	var err error
	mountOperationPrivateStruct_Once.Do(func() {
		mountOperationPrivateStruct, err = gi.StructNew("Gtk", "MountOperationPrivate")
	})
	return err
}

type MountOperationPrivate struct {
	native unsafe.Pointer
}

func MountOperationPrivateNewFromNative(native unsafe.Pointer) *MountOperationPrivate {
	err := mountOperationPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &MountOperationPrivate{native: native}

	return instance
}

/*
CastToMountOperationPrivate down casts any arbitrary Object to MountOperationPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a MountOperationPrivate.
*/
func CastToMountOperationPrivate(object *gobject.Object) *MountOperationPrivate {
	return MountOperationPrivateNewFromNative(object.Native())
}

// Equals compares this MountOperationPrivate with another MountOperationPrivate, and returns true if they represent the same Object.
func (recv *MountOperationPrivate) Equals(other *MountOperationPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *MountOperationPrivate) Native() unsafe.Pointer {
	return recv.native
}

// MountOperationPrivateStruct creates an uninitialised MountOperationPrivate.
func MountOperationPrivateStruct() *MountOperationPrivate {
	err := mountOperationPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := MountOperationPrivateNewFromNative(mountOperationPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeMountOperationPrivate)
	return structGo
}
func finalizeMountOperationPrivate(obj *MountOperationPrivate) {
	mountOperationPrivateStruct.Free(obj.Native())
}

var nativeDialogClassStruct *gi.Struct
var nativeDialogClassStruct_Once sync.Once

func nativeDialogClassStruct_Set() error {
	var err error
	nativeDialogClassStruct_Once.Do(func() {
		nativeDialogClassStruct, err = gi.StructNew("Gtk", "NativeDialogClass")
	})
	return err
}

type NativeDialogClass struct {
	native unsafe.Pointer
}

func NativeDialogClassNewFromNative(native unsafe.Pointer) *NativeDialogClass {
	err := nativeDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NativeDialogClass{native: native}

	return instance
}

/*
CastToNativeDialogClass down casts any arbitrary Object to NativeDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a NativeDialogClass.
*/
func CastToNativeDialogClass(object *gobject.Object) *NativeDialogClass {
	return NativeDialogClassNewFromNative(object.Native())
}

// Equals compares this NativeDialogClass with another NativeDialogClass, and returns true if they represent the same Object.
func (recv *NativeDialogClass) Equals(other *NativeDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *NativeDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *NativeDialogClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(nativeDialogClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *NativeDialogClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(nativeDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'response' : for field getter : missing Type

// UNSUPPORTED : C value 'response' : for field setter : missing Type

// UNSUPPORTED : C value 'show' : for field getter : missing Type

// UNSUPPORTED : C value 'show' : for field setter : missing Type

// UNSUPPORTED : C value 'hide' : for field getter : missing Type

// UNSUPPORTED : C value 'hide' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// NativeDialogClassStruct creates an uninitialised NativeDialogClass.
func NativeDialogClassStruct() *NativeDialogClass {
	err := nativeDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NativeDialogClassNewFromNative(nativeDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNativeDialogClass)
	return structGo
}
func finalizeNativeDialogClass(obj *NativeDialogClass) {
	nativeDialogClassStruct.Free(obj.Native())
}

var notebookAccessibleClassStruct *gi.Struct
var notebookAccessibleClassStruct_Once sync.Once

func notebookAccessibleClassStruct_Set() error {
	var err error
	notebookAccessibleClassStruct_Once.Do(func() {
		notebookAccessibleClassStruct, err = gi.StructNew("Gtk", "NotebookAccessibleClass")
	})
	return err
}

type NotebookAccessibleClass struct {
	native unsafe.Pointer
}

func NotebookAccessibleClassNewFromNative(native unsafe.Pointer) *NotebookAccessibleClass {
	err := notebookAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NotebookAccessibleClass{native: native}

	return instance
}

/*
CastToNotebookAccessibleClass down casts any arbitrary Object to NotebookAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a NotebookAccessibleClass.
*/
func CastToNotebookAccessibleClass(object *gobject.Object) *NotebookAccessibleClass {
	return NotebookAccessibleClassNewFromNative(object.Native())
}

// Equals compares this NotebookAccessibleClass with another NotebookAccessibleClass, and returns true if they represent the same Object.
func (recv *NotebookAccessibleClass) Equals(other *NotebookAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *NotebookAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *NotebookAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(notebookAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *NotebookAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(notebookAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// NotebookAccessibleClassStruct creates an uninitialised NotebookAccessibleClass.
func NotebookAccessibleClassStruct() *NotebookAccessibleClass {
	err := notebookAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NotebookAccessibleClassNewFromNative(notebookAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNotebookAccessibleClass)
	return structGo
}
func finalizeNotebookAccessibleClass(obj *NotebookAccessibleClass) {
	notebookAccessibleClassStruct.Free(obj.Native())
}

var notebookAccessiblePrivateStruct *gi.Struct
var notebookAccessiblePrivateStruct_Once sync.Once

func notebookAccessiblePrivateStruct_Set() error {
	var err error
	notebookAccessiblePrivateStruct_Once.Do(func() {
		notebookAccessiblePrivateStruct, err = gi.StructNew("Gtk", "NotebookAccessiblePrivate")
	})
	return err
}

type NotebookAccessiblePrivate struct {
	native unsafe.Pointer
}

func NotebookAccessiblePrivateNewFromNative(native unsafe.Pointer) *NotebookAccessiblePrivate {
	err := notebookAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NotebookAccessiblePrivate{native: native}

	return instance
}

/*
CastToNotebookAccessiblePrivate down casts any arbitrary Object to NotebookAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a NotebookAccessiblePrivate.
*/
func CastToNotebookAccessiblePrivate(object *gobject.Object) *NotebookAccessiblePrivate {
	return NotebookAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this NotebookAccessiblePrivate with another NotebookAccessiblePrivate, and returns true if they represent the same Object.
func (recv *NotebookAccessiblePrivate) Equals(other *NotebookAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *NotebookAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// NotebookAccessiblePrivateStruct creates an uninitialised NotebookAccessiblePrivate.
func NotebookAccessiblePrivateStruct() *NotebookAccessiblePrivate {
	err := notebookAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NotebookAccessiblePrivateNewFromNative(notebookAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNotebookAccessiblePrivate)
	return structGo
}
func finalizeNotebookAccessiblePrivate(obj *NotebookAccessiblePrivate) {
	notebookAccessiblePrivateStruct.Free(obj.Native())
}

var notebookClassStruct *gi.Struct
var notebookClassStruct_Once sync.Once

func notebookClassStruct_Set() error {
	var err error
	notebookClassStruct_Once.Do(func() {
		notebookClassStruct, err = gi.StructNew("Gtk", "NotebookClass")
	})
	return err
}

type NotebookClass struct {
	native unsafe.Pointer
}

func NotebookClassNewFromNative(native unsafe.Pointer) *NotebookClass {
	err := notebookClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NotebookClass{native: native}

	return instance
}

/*
CastToNotebookClass down casts any arbitrary Object to NotebookClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a NotebookClass.
*/
func CastToNotebookClass(object *gobject.Object) *NotebookClass {
	return NotebookClassNewFromNative(object.Native())
}

// Equals compares this NotebookClass with another NotebookClass, and returns true if they represent the same Object.
func (recv *NotebookClass) Equals(other *NotebookClass) bool {
	return other.Native() == recv.Native()
}

func (recv *NotebookClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *NotebookClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(notebookClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *NotebookClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(notebookClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'switch_page' : for field getter : missing Type

// UNSUPPORTED : C value 'switch_page' : for field setter : missing Type

// UNSUPPORTED : C value 'select_page' : for field getter : missing Type

// UNSUPPORTED : C value 'select_page' : for field setter : missing Type

// UNSUPPORTED : C value 'focus_tab' : for field getter : missing Type

// UNSUPPORTED : C value 'focus_tab' : for field setter : missing Type

// UNSUPPORTED : C value 'change_current_page' : for field getter : missing Type

// UNSUPPORTED : C value 'change_current_page' : for field setter : missing Type

// UNSUPPORTED : C value 'move_focus_out' : for field getter : missing Type

// UNSUPPORTED : C value 'move_focus_out' : for field setter : missing Type

// UNSUPPORTED : C value 'reorder_tab' : for field getter : missing Type

// UNSUPPORTED : C value 'reorder_tab' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_page' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_page' : for field setter : missing Type

// UNSUPPORTED : C value 'create_window' : for field getter : missing Type

// UNSUPPORTED : C value 'create_window' : for field setter : missing Type

// UNSUPPORTED : C value 'page_reordered' : for field getter : missing Type

// UNSUPPORTED : C value 'page_reordered' : for field setter : missing Type

// UNSUPPORTED : C value 'page_removed' : for field getter : missing Type

// UNSUPPORTED : C value 'page_removed' : for field setter : missing Type

// UNSUPPORTED : C value 'page_added' : for field getter : missing Type

// UNSUPPORTED : C value 'page_added' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// NotebookClassStruct creates an uninitialised NotebookClass.
func NotebookClassStruct() *NotebookClass {
	err := notebookClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NotebookClassNewFromNative(notebookClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNotebookClass)
	return structGo
}
func finalizeNotebookClass(obj *NotebookClass) {
	notebookClassStruct.Free(obj.Native())
}

var notebookPageAccessibleClassStruct *gi.Struct
var notebookPageAccessibleClassStruct_Once sync.Once

func notebookPageAccessibleClassStruct_Set() error {
	var err error
	notebookPageAccessibleClassStruct_Once.Do(func() {
		notebookPageAccessibleClassStruct, err = gi.StructNew("Gtk", "NotebookPageAccessibleClass")
	})
	return err
}

type NotebookPageAccessibleClass struct {
	native unsafe.Pointer
}

func NotebookPageAccessibleClassNewFromNative(native unsafe.Pointer) *NotebookPageAccessibleClass {
	err := notebookPageAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NotebookPageAccessibleClass{native: native}

	return instance
}

/*
CastToNotebookPageAccessibleClass down casts any arbitrary Object to NotebookPageAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a NotebookPageAccessibleClass.
*/
func CastToNotebookPageAccessibleClass(object *gobject.Object) *NotebookPageAccessibleClass {
	return NotebookPageAccessibleClassNewFromNative(object.Native())
}

// Equals compares this NotebookPageAccessibleClass with another NotebookPageAccessibleClass, and returns true if they represent the same Object.
func (recv *NotebookPageAccessibleClass) Equals(other *NotebookPageAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *NotebookPageAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *NotebookPageAccessibleClass) FieldParentClass() *atk.ObjectClass {
	argValue := gi.StructFieldGet(notebookPageAccessibleClassStruct, recv.Native(), "parent_class")
	value := atk.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *NotebookPageAccessibleClass) SetFieldParentClass(value *atk.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(notebookPageAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// NotebookPageAccessibleClassStruct creates an uninitialised NotebookPageAccessibleClass.
func NotebookPageAccessibleClassStruct() *NotebookPageAccessibleClass {
	err := notebookPageAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NotebookPageAccessibleClassNewFromNative(notebookPageAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNotebookPageAccessibleClass)
	return structGo
}
func finalizeNotebookPageAccessibleClass(obj *NotebookPageAccessibleClass) {
	notebookPageAccessibleClassStruct.Free(obj.Native())
}

var notebookPageAccessiblePrivateStruct *gi.Struct
var notebookPageAccessiblePrivateStruct_Once sync.Once

func notebookPageAccessiblePrivateStruct_Set() error {
	var err error
	notebookPageAccessiblePrivateStruct_Once.Do(func() {
		notebookPageAccessiblePrivateStruct, err = gi.StructNew("Gtk", "NotebookPageAccessiblePrivate")
	})
	return err
}

type NotebookPageAccessiblePrivate struct {
	native unsafe.Pointer
}

func NotebookPageAccessiblePrivateNewFromNative(native unsafe.Pointer) *NotebookPageAccessiblePrivate {
	err := notebookPageAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NotebookPageAccessiblePrivate{native: native}

	return instance
}

/*
CastToNotebookPageAccessiblePrivate down casts any arbitrary Object to NotebookPageAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a NotebookPageAccessiblePrivate.
*/
func CastToNotebookPageAccessiblePrivate(object *gobject.Object) *NotebookPageAccessiblePrivate {
	return NotebookPageAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this NotebookPageAccessiblePrivate with another NotebookPageAccessiblePrivate, and returns true if they represent the same Object.
func (recv *NotebookPageAccessiblePrivate) Equals(other *NotebookPageAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *NotebookPageAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// NotebookPageAccessiblePrivateStruct creates an uninitialised NotebookPageAccessiblePrivate.
func NotebookPageAccessiblePrivateStruct() *NotebookPageAccessiblePrivate {
	err := notebookPageAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NotebookPageAccessiblePrivateNewFromNative(notebookPageAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNotebookPageAccessiblePrivate)
	return structGo
}
func finalizeNotebookPageAccessiblePrivate(obj *NotebookPageAccessiblePrivate) {
	notebookPageAccessiblePrivateStruct.Free(obj.Native())
}

var notebookPrivateStruct *gi.Struct
var notebookPrivateStruct_Once sync.Once

func notebookPrivateStruct_Set() error {
	var err error
	notebookPrivateStruct_Once.Do(func() {
		notebookPrivateStruct, err = gi.StructNew("Gtk", "NotebookPrivate")
	})
	return err
}

type NotebookPrivate struct {
	native unsafe.Pointer
}

func NotebookPrivateNewFromNative(native unsafe.Pointer) *NotebookPrivate {
	err := notebookPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NotebookPrivate{native: native}

	return instance
}

/*
CastToNotebookPrivate down casts any arbitrary Object to NotebookPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a NotebookPrivate.
*/
func CastToNotebookPrivate(object *gobject.Object) *NotebookPrivate {
	return NotebookPrivateNewFromNative(object.Native())
}

// Equals compares this NotebookPrivate with another NotebookPrivate, and returns true if they represent the same Object.
func (recv *NotebookPrivate) Equals(other *NotebookPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *NotebookPrivate) Native() unsafe.Pointer {
	return recv.native
}

// NotebookPrivateStruct creates an uninitialised NotebookPrivate.
func NotebookPrivateStruct() *NotebookPrivate {
	err := notebookPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NotebookPrivateNewFromNative(notebookPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNotebookPrivate)
	return structGo
}
func finalizeNotebookPrivate(obj *NotebookPrivate) {
	notebookPrivateStruct.Free(obj.Native())
}

var numerableIconClassStruct *gi.Struct
var numerableIconClassStruct_Once sync.Once

func numerableIconClassStruct_Set() error {
	var err error
	numerableIconClassStruct_Once.Do(func() {
		numerableIconClassStruct, err = gi.StructNew("Gtk", "NumerableIconClass")
	})
	return err
}

type NumerableIconClass struct {
	native unsafe.Pointer
}

func NumerableIconClassNewFromNative(native unsafe.Pointer) *NumerableIconClass {
	err := numerableIconClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NumerableIconClass{native: native}

	return instance
}

/*
CastToNumerableIconClass down casts any arbitrary Object to NumerableIconClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a NumerableIconClass.
*/
func CastToNumerableIconClass(object *gobject.Object) *NumerableIconClass {
	return NumerableIconClassNewFromNative(object.Native())
}

// Equals compares this NumerableIconClass with another NumerableIconClass, and returns true if they represent the same Object.
func (recv *NumerableIconClass) Equals(other *NumerableIconClass) bool {
	return other.Native() == recv.Native()
}

func (recv *NumerableIconClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *NumerableIconClass) FieldParentClass() *gio.EmblemedIconClass {
	argValue := gi.StructFieldGet(numerableIconClassStruct, recv.Native(), "parent_class")
	value := gio.EmblemedIconClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *NumerableIconClass) SetFieldParentClass(value *gio.EmblemedIconClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(numerableIconClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'padding' : for field getter : missing Type

// UNSUPPORTED : C value 'padding' : for field setter : missing Type

// NumerableIconClassStruct creates an uninitialised NumerableIconClass.
func NumerableIconClassStruct() *NumerableIconClass {
	err := numerableIconClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NumerableIconClassNewFromNative(numerableIconClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNumerableIconClass)
	return structGo
}
func finalizeNumerableIconClass(obj *NumerableIconClass) {
	numerableIconClassStruct.Free(obj.Native())
}

var numerableIconPrivateStruct *gi.Struct
var numerableIconPrivateStruct_Once sync.Once

func numerableIconPrivateStruct_Set() error {
	var err error
	numerableIconPrivateStruct_Once.Do(func() {
		numerableIconPrivateStruct, err = gi.StructNew("Gtk", "NumerableIconPrivate")
	})
	return err
}

type NumerableIconPrivate struct {
	native unsafe.Pointer
}

func NumerableIconPrivateNewFromNative(native unsafe.Pointer) *NumerableIconPrivate {
	err := numerableIconPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &NumerableIconPrivate{native: native}

	return instance
}

/*
CastToNumerableIconPrivate down casts any arbitrary Object to NumerableIconPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a NumerableIconPrivate.
*/
func CastToNumerableIconPrivate(object *gobject.Object) *NumerableIconPrivate {
	return NumerableIconPrivateNewFromNative(object.Native())
}

// Equals compares this NumerableIconPrivate with another NumerableIconPrivate, and returns true if they represent the same Object.
func (recv *NumerableIconPrivate) Equals(other *NumerableIconPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *NumerableIconPrivate) Native() unsafe.Pointer {
	return recv.native
}

// NumerableIconPrivateStruct creates an uninitialised NumerableIconPrivate.
func NumerableIconPrivateStruct() *NumerableIconPrivate {
	err := numerableIconPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := NumerableIconPrivateNewFromNative(numerableIconPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeNumerableIconPrivate)
	return structGo
}
func finalizeNumerableIconPrivate(obj *NumerableIconPrivate) {
	numerableIconPrivateStruct.Free(obj.Native())
}

var offscreenWindowClassStruct *gi.Struct
var offscreenWindowClassStruct_Once sync.Once

func offscreenWindowClassStruct_Set() error {
	var err error
	offscreenWindowClassStruct_Once.Do(func() {
		offscreenWindowClassStruct, err = gi.StructNew("Gtk", "OffscreenWindowClass")
	})
	return err
}

type OffscreenWindowClass struct {
	native unsafe.Pointer
}

func OffscreenWindowClassNewFromNative(native unsafe.Pointer) *OffscreenWindowClass {
	err := offscreenWindowClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &OffscreenWindowClass{native: native}

	return instance
}

/*
CastToOffscreenWindowClass down casts any arbitrary Object to OffscreenWindowClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a OffscreenWindowClass.
*/
func CastToOffscreenWindowClass(object *gobject.Object) *OffscreenWindowClass {
	return OffscreenWindowClassNewFromNative(object.Native())
}

// Equals compares this OffscreenWindowClass with another OffscreenWindowClass, and returns true if they represent the same Object.
func (recv *OffscreenWindowClass) Equals(other *OffscreenWindowClass) bool {
	return other.Native() == recv.Native()
}

func (recv *OffscreenWindowClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *OffscreenWindowClass) FieldParentClass() *WindowClass {
	argValue := gi.StructFieldGet(offscreenWindowClassStruct, recv.Native(), "parent_class")
	value := WindowClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *OffscreenWindowClass) SetFieldParentClass(value *WindowClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(offscreenWindowClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// OffscreenWindowClassStruct creates an uninitialised OffscreenWindowClass.
func OffscreenWindowClassStruct() *OffscreenWindowClass {
	err := offscreenWindowClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := OffscreenWindowClassNewFromNative(offscreenWindowClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeOffscreenWindowClass)
	return structGo
}
func finalizeOffscreenWindowClass(obj *OffscreenWindowClass) {
	offscreenWindowClassStruct.Free(obj.Native())
}

var orientableIfaceStruct *gi.Struct
var orientableIfaceStruct_Once sync.Once

func orientableIfaceStruct_Set() error {
	var err error
	orientableIfaceStruct_Once.Do(func() {
		orientableIfaceStruct, err = gi.StructNew("Gtk", "OrientableIface")
	})
	return err
}

type OrientableIface struct {
	native unsafe.Pointer
}

func OrientableIfaceNewFromNative(native unsafe.Pointer) *OrientableIface {
	err := orientableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &OrientableIface{native: native}

	return instance
}

/*
CastToOrientableIface down casts any arbitrary Object to OrientableIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a OrientableIface.
*/
func CastToOrientableIface(object *gobject.Object) *OrientableIface {
	return OrientableIfaceNewFromNative(object.Native())
}

// Equals compares this OrientableIface with another OrientableIface, and returns true if they represent the same Object.
func (recv *OrientableIface) Equals(other *OrientableIface) bool {
	return other.Native() == recv.Native()
}

func (recv *OrientableIface) Native() unsafe.Pointer {
	return recv.native
}

// FieldBaseIface returns the C field 'base_iface'.
func (recv *OrientableIface) FieldBaseIface() *gobject.TypeInterface {
	argValue := gi.StructFieldGet(orientableIfaceStruct, recv.Native(), "base_iface")
	value := gobject.TypeInterfaceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldBaseIface sets the value of the C field 'base_iface'.
func (recv *OrientableIface) SetFieldBaseIface(value *gobject.TypeInterface) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(orientableIfaceStruct, recv.Native(), "base_iface", argValue)
}

// OrientableIfaceStruct creates an uninitialised OrientableIface.
func OrientableIfaceStruct() *OrientableIface {
	err := orientableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := OrientableIfaceNewFromNative(orientableIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeOrientableIface)
	return structGo
}
func finalizeOrientableIface(obj *OrientableIface) {
	orientableIfaceStruct.Free(obj.Native())
}

var overlayClassStruct *gi.Struct
var overlayClassStruct_Once sync.Once

func overlayClassStruct_Set() error {
	var err error
	overlayClassStruct_Once.Do(func() {
		overlayClassStruct, err = gi.StructNew("Gtk", "OverlayClass")
	})
	return err
}

type OverlayClass struct {
	native unsafe.Pointer
}

func OverlayClassNewFromNative(native unsafe.Pointer) *OverlayClass {
	err := overlayClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &OverlayClass{native: native}

	return instance
}

/*
CastToOverlayClass down casts any arbitrary Object to OverlayClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a OverlayClass.
*/
func CastToOverlayClass(object *gobject.Object) *OverlayClass {
	return OverlayClassNewFromNative(object.Native())
}

// Equals compares this OverlayClass with another OverlayClass, and returns true if they represent the same Object.
func (recv *OverlayClass) Equals(other *OverlayClass) bool {
	return other.Native() == recv.Native()
}

func (recv *OverlayClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *OverlayClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(overlayClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *OverlayClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(overlayClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'get_child_position' : for field getter : missing Type

// UNSUPPORTED : C value 'get_child_position' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// OverlayClassStruct creates an uninitialised OverlayClass.
func OverlayClassStruct() *OverlayClass {
	err := overlayClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := OverlayClassNewFromNative(overlayClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeOverlayClass)
	return structGo
}
func finalizeOverlayClass(obj *OverlayClass) {
	overlayClassStruct.Free(obj.Native())
}

var overlayPrivateStruct *gi.Struct
var overlayPrivateStruct_Once sync.Once

func overlayPrivateStruct_Set() error {
	var err error
	overlayPrivateStruct_Once.Do(func() {
		overlayPrivateStruct, err = gi.StructNew("Gtk", "OverlayPrivate")
	})
	return err
}

type OverlayPrivate struct {
	native unsafe.Pointer
}

func OverlayPrivateNewFromNative(native unsafe.Pointer) *OverlayPrivate {
	err := overlayPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &OverlayPrivate{native: native}

	return instance
}

/*
CastToOverlayPrivate down casts any arbitrary Object to OverlayPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a OverlayPrivate.
*/
func CastToOverlayPrivate(object *gobject.Object) *OverlayPrivate {
	return OverlayPrivateNewFromNative(object.Native())
}

// Equals compares this OverlayPrivate with another OverlayPrivate, and returns true if they represent the same Object.
func (recv *OverlayPrivate) Equals(other *OverlayPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *OverlayPrivate) Native() unsafe.Pointer {
	return recv.native
}

// OverlayPrivateStruct creates an uninitialised OverlayPrivate.
func OverlayPrivateStruct() *OverlayPrivate {
	err := overlayPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := OverlayPrivateNewFromNative(overlayPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeOverlayPrivate)
	return structGo
}
func finalizeOverlayPrivate(obj *OverlayPrivate) {
	overlayPrivateStruct.Free(obj.Native())
}

var padActionEntryStruct *gi.Struct
var padActionEntryStruct_Once sync.Once

func padActionEntryStruct_Set() error {
	var err error
	padActionEntryStruct_Once.Do(func() {
		padActionEntryStruct, err = gi.StructNew("Gtk", "PadActionEntry")
	})
	return err
}

type PadActionEntry struct {
	native unsafe.Pointer
}

func PadActionEntryNewFromNative(native unsafe.Pointer) *PadActionEntry {
	err := padActionEntryStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PadActionEntry{native: native}

	return instance
}

/*
CastToPadActionEntry down casts any arbitrary Object to PadActionEntry.
Exercise care, as this is a potentially dangerous function
if the Object is not a PadActionEntry.
*/
func CastToPadActionEntry(object *gobject.Object) *PadActionEntry {
	return PadActionEntryNewFromNative(object.Native())
}

// Equals compares this PadActionEntry with another PadActionEntry, and returns true if they represent the same Object.
func (recv *PadActionEntry) Equals(other *PadActionEntry) bool {
	return other.Native() == recv.Native()
}

func (recv *PadActionEntry) Native() unsafe.Pointer {
	return recv.native
}

// FieldType returns the C field 'type'.
func (recv *PadActionEntry) FieldType() PadActionType {
	argValue := gi.StructFieldGet(padActionEntryStruct, recv.Native(), "type")
	value := PadActionType(argValue.Int32())
	return value
}

// SetFieldType sets the value of the C field 'type'.
func (recv *PadActionEntry) SetFieldType(value PadActionType) {
	var argValue gi.Argument
	argValue.SetInt32(int32(value))
	gi.StructFieldSet(padActionEntryStruct, recv.Native(), "type", argValue)
}

// FieldIndex returns the C field 'index'.
func (recv *PadActionEntry) FieldIndex() int32 {
	argValue := gi.StructFieldGet(padActionEntryStruct, recv.Native(), "index")
	value := argValue.Int32()
	return value
}

// SetFieldIndex sets the value of the C field 'index'.
func (recv *PadActionEntry) SetFieldIndex(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(padActionEntryStruct, recv.Native(), "index", argValue)
}

// FieldMode returns the C field 'mode'.
func (recv *PadActionEntry) FieldMode() int32 {
	argValue := gi.StructFieldGet(padActionEntryStruct, recv.Native(), "mode")
	value := argValue.Int32()
	return value
}

// SetFieldMode sets the value of the C field 'mode'.
func (recv *PadActionEntry) SetFieldMode(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(padActionEntryStruct, recv.Native(), "mode", argValue)
}

// FieldLabel returns the C field 'label'.
func (recv *PadActionEntry) FieldLabel() string {
	argValue := gi.StructFieldGet(padActionEntryStruct, recv.Native(), "label")
	value := argValue.String(false)
	return value
}

// SetFieldLabel sets the value of the C field 'label'.
func (recv *PadActionEntry) SetFieldLabel(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(padActionEntryStruct, recv.Native(), "label", argValue)
}

// FieldActionName returns the C field 'action_name'.
func (recv *PadActionEntry) FieldActionName() string {
	argValue := gi.StructFieldGet(padActionEntryStruct, recv.Native(), "action_name")
	value := argValue.String(false)
	return value
}

// SetFieldActionName sets the value of the C field 'action_name'.
func (recv *PadActionEntry) SetFieldActionName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(padActionEntryStruct, recv.Native(), "action_name", argValue)
}

// PadActionEntryStruct creates an uninitialised PadActionEntry.
func PadActionEntryStruct() *PadActionEntry {
	err := padActionEntryStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PadActionEntryNewFromNative(padActionEntryStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePadActionEntry)
	return structGo
}
func finalizePadActionEntry(obj *PadActionEntry) {
	padActionEntryStruct.Free(obj.Native())
}

var padControllerClassStruct *gi.Struct
var padControllerClassStruct_Once sync.Once

func padControllerClassStruct_Set() error {
	var err error
	padControllerClassStruct_Once.Do(func() {
		padControllerClassStruct, err = gi.StructNew("Gtk", "PadControllerClass")
	})
	return err
}

type PadControllerClass struct {
	native unsafe.Pointer
}

func PadControllerClassNewFromNative(native unsafe.Pointer) *PadControllerClass {
	err := padControllerClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PadControllerClass{native: native}

	return instance
}

/*
CastToPadControllerClass down casts any arbitrary Object to PadControllerClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PadControllerClass.
*/
func CastToPadControllerClass(object *gobject.Object) *PadControllerClass {
	return PadControllerClassNewFromNative(object.Native())
}

// Equals compares this PadControllerClass with another PadControllerClass, and returns true if they represent the same Object.
func (recv *PadControllerClass) Equals(other *PadControllerClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PadControllerClass) Native() unsafe.Pointer {
	return recv.native
}

// PadControllerClassStruct creates an uninitialised PadControllerClass.
func PadControllerClassStruct() *PadControllerClass {
	err := padControllerClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PadControllerClassNewFromNative(padControllerClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePadControllerClass)
	return structGo
}
func finalizePadControllerClass(obj *PadControllerClass) {
	padControllerClassStruct.Free(obj.Native())
}

var pageRangeStruct *gi.Struct
var pageRangeStruct_Once sync.Once

func pageRangeStruct_Set() error {
	var err error
	pageRangeStruct_Once.Do(func() {
		pageRangeStruct, err = gi.StructNew("Gtk", "PageRange")
	})
	return err
}

type PageRange struct {
	native unsafe.Pointer
}

func PageRangeNewFromNative(native unsafe.Pointer) *PageRange {
	err := pageRangeStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PageRange{native: native}

	return instance
}

/*
CastToPageRange down casts any arbitrary Object to PageRange.
Exercise care, as this is a potentially dangerous function
if the Object is not a PageRange.
*/
func CastToPageRange(object *gobject.Object) *PageRange {
	return PageRangeNewFromNative(object.Native())
}

// Equals compares this PageRange with another PageRange, and returns true if they represent the same Object.
func (recv *PageRange) Equals(other *PageRange) bool {
	return other.Native() == recv.Native()
}

func (recv *PageRange) Native() unsafe.Pointer {
	return recv.native
}

// FieldStart returns the C field 'start'.
func (recv *PageRange) FieldStart() int32 {
	argValue := gi.StructFieldGet(pageRangeStruct, recv.Native(), "start")
	value := argValue.Int32()
	return value
}

// SetFieldStart sets the value of the C field 'start'.
func (recv *PageRange) SetFieldStart(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(pageRangeStruct, recv.Native(), "start", argValue)
}

// FieldEnd returns the C field 'end'.
func (recv *PageRange) FieldEnd() int32 {
	argValue := gi.StructFieldGet(pageRangeStruct, recv.Native(), "end")
	value := argValue.Int32()
	return value
}

// SetFieldEnd sets the value of the C field 'end'.
func (recv *PageRange) SetFieldEnd(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(pageRangeStruct, recv.Native(), "end", argValue)
}

// PageRangeStruct creates an uninitialised PageRange.
func PageRangeStruct() *PageRange {
	err := pageRangeStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PageRangeNewFromNative(pageRangeStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePageRange)
	return structGo
}
func finalizePageRange(obj *PageRange) {
	pageRangeStruct.Free(obj.Native())
}

var panedAccessibleClassStruct *gi.Struct
var panedAccessibleClassStruct_Once sync.Once

func panedAccessibleClassStruct_Set() error {
	var err error
	panedAccessibleClassStruct_Once.Do(func() {
		panedAccessibleClassStruct, err = gi.StructNew("Gtk", "PanedAccessibleClass")
	})
	return err
}

type PanedAccessibleClass struct {
	native unsafe.Pointer
}

func PanedAccessibleClassNewFromNative(native unsafe.Pointer) *PanedAccessibleClass {
	err := panedAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PanedAccessibleClass{native: native}

	return instance
}

/*
CastToPanedAccessibleClass down casts any arbitrary Object to PanedAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PanedAccessibleClass.
*/
func CastToPanedAccessibleClass(object *gobject.Object) *PanedAccessibleClass {
	return PanedAccessibleClassNewFromNative(object.Native())
}

// Equals compares this PanedAccessibleClass with another PanedAccessibleClass, and returns true if they represent the same Object.
func (recv *PanedAccessibleClass) Equals(other *PanedAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PanedAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *PanedAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(panedAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *PanedAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(panedAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// PanedAccessibleClassStruct creates an uninitialised PanedAccessibleClass.
func PanedAccessibleClassStruct() *PanedAccessibleClass {
	err := panedAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PanedAccessibleClassNewFromNative(panedAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePanedAccessibleClass)
	return structGo
}
func finalizePanedAccessibleClass(obj *PanedAccessibleClass) {
	panedAccessibleClassStruct.Free(obj.Native())
}

var panedAccessiblePrivateStruct *gi.Struct
var panedAccessiblePrivateStruct_Once sync.Once

func panedAccessiblePrivateStruct_Set() error {
	var err error
	panedAccessiblePrivateStruct_Once.Do(func() {
		panedAccessiblePrivateStruct, err = gi.StructNew("Gtk", "PanedAccessiblePrivate")
	})
	return err
}

type PanedAccessiblePrivate struct {
	native unsafe.Pointer
}

func PanedAccessiblePrivateNewFromNative(native unsafe.Pointer) *PanedAccessiblePrivate {
	err := panedAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PanedAccessiblePrivate{native: native}

	return instance
}

/*
CastToPanedAccessiblePrivate down casts any arbitrary Object to PanedAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a PanedAccessiblePrivate.
*/
func CastToPanedAccessiblePrivate(object *gobject.Object) *PanedAccessiblePrivate {
	return PanedAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this PanedAccessiblePrivate with another PanedAccessiblePrivate, and returns true if they represent the same Object.
func (recv *PanedAccessiblePrivate) Equals(other *PanedAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *PanedAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// PanedAccessiblePrivateStruct creates an uninitialised PanedAccessiblePrivate.
func PanedAccessiblePrivateStruct() *PanedAccessiblePrivate {
	err := panedAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PanedAccessiblePrivateNewFromNative(panedAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePanedAccessiblePrivate)
	return structGo
}
func finalizePanedAccessiblePrivate(obj *PanedAccessiblePrivate) {
	panedAccessiblePrivateStruct.Free(obj.Native())
}

var panedClassStruct *gi.Struct
var panedClassStruct_Once sync.Once

func panedClassStruct_Set() error {
	var err error
	panedClassStruct_Once.Do(func() {
		panedClassStruct, err = gi.StructNew("Gtk", "PanedClass")
	})
	return err
}

type PanedClass struct {
	native unsafe.Pointer
}

func PanedClassNewFromNative(native unsafe.Pointer) *PanedClass {
	err := panedClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PanedClass{native: native}

	return instance
}

/*
CastToPanedClass down casts any arbitrary Object to PanedClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PanedClass.
*/
func CastToPanedClass(object *gobject.Object) *PanedClass {
	return PanedClassNewFromNative(object.Native())
}

// Equals compares this PanedClass with another PanedClass, and returns true if they represent the same Object.
func (recv *PanedClass) Equals(other *PanedClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PanedClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *PanedClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(panedClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *PanedClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(panedClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'cycle_child_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'cycle_child_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_handle_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_handle_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'move_handle' : for field getter : missing Type

// UNSUPPORTED : C value 'move_handle' : for field setter : missing Type

// UNSUPPORTED : C value 'cycle_handle_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'cycle_handle_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'accept_position' : for field getter : missing Type

// UNSUPPORTED : C value 'accept_position' : for field setter : missing Type

// UNSUPPORTED : C value 'cancel_position' : for field getter : missing Type

// UNSUPPORTED : C value 'cancel_position' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// PanedClassStruct creates an uninitialised PanedClass.
func PanedClassStruct() *PanedClass {
	err := panedClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PanedClassNewFromNative(panedClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePanedClass)
	return structGo
}
func finalizePanedClass(obj *PanedClass) {
	panedClassStruct.Free(obj.Native())
}

var panedPrivateStruct *gi.Struct
var panedPrivateStruct_Once sync.Once

func panedPrivateStruct_Set() error {
	var err error
	panedPrivateStruct_Once.Do(func() {
		panedPrivateStruct, err = gi.StructNew("Gtk", "PanedPrivate")
	})
	return err
}

type PanedPrivate struct {
	native unsafe.Pointer
}

func PanedPrivateNewFromNative(native unsafe.Pointer) *PanedPrivate {
	err := panedPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PanedPrivate{native: native}

	return instance
}

/*
CastToPanedPrivate down casts any arbitrary Object to PanedPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a PanedPrivate.
*/
func CastToPanedPrivate(object *gobject.Object) *PanedPrivate {
	return PanedPrivateNewFromNative(object.Native())
}

// Equals compares this PanedPrivate with another PanedPrivate, and returns true if they represent the same Object.
func (recv *PanedPrivate) Equals(other *PanedPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *PanedPrivate) Native() unsafe.Pointer {
	return recv.native
}

// PanedPrivateStruct creates an uninitialised PanedPrivate.
func PanedPrivateStruct() *PanedPrivate {
	err := panedPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PanedPrivateNewFromNative(panedPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePanedPrivate)
	return structGo
}
func finalizePanedPrivate(obj *PanedPrivate) {
	panedPrivateStruct.Free(obj.Native())
}

var paperSizeStruct *gi.Struct
var paperSizeStruct_Once sync.Once

func paperSizeStruct_Set() error {
	var err error
	paperSizeStruct_Once.Do(func() {
		paperSizeStruct, err = gi.StructNew("Gtk", "PaperSize")
	})
	return err
}

type PaperSize struct {
	native unsafe.Pointer
}

func PaperSizeNewFromNative(native unsafe.Pointer) *PaperSize {
	err := paperSizeStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PaperSize{native: native}

	return instance
}

/*
CastToPaperSize down casts any arbitrary Object to PaperSize.
Exercise care, as this is a potentially dangerous function
if the Object is not a PaperSize.
*/
func CastToPaperSize(object *gobject.Object) *PaperSize {
	return PaperSizeNewFromNative(object.Native())
}

// Equals compares this PaperSize with another PaperSize, and returns true if they represent the same Object.
func (recv *PaperSize) Equals(other *PaperSize) bool {
	return other.Native() == recv.Native()
}

func (recv *PaperSize) Native() unsafe.Pointer {
	return recv.native
}

var paperSizeNewFunction *gi.Function
var paperSizeNewFunction_Once sync.Once

func paperSizeNewFunction_Set() error {
	var err error
	paperSizeNewFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeNewFunction, err = paperSizeStruct.InvokerNew("new")
	})
	return err
}

// PaperSizeNew is a representation of the C type gtk_paper_size_new.
func PaperSizeNew(name string) *PaperSize {
	var inArgs [1]gi.Argument
	inArgs[0].SetString(name)

	var ret gi.Argument

	err := paperSizeNewFunction_Set()
	if err == nil {
		ret = paperSizeNewFunction.Invoke(inArgs[:], nil)
	}

	retGo := PaperSizeNewFromNative(ret.Pointer())

	return retGo
}

var paperSizeNewCustomFunction *gi.Function
var paperSizeNewCustomFunction_Once sync.Once

func paperSizeNewCustomFunction_Set() error {
	var err error
	paperSizeNewCustomFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeNewCustomFunction, err = paperSizeStruct.InvokerNew("new_custom")
	})
	return err
}

// PaperSizeNewCustom is a representation of the C type gtk_paper_size_new_custom.
func PaperSizeNewCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
	var inArgs [5]gi.Argument
	inArgs[0].SetString(name)
	inArgs[1].SetString(displayName)
	inArgs[2].SetFloat64(width)
	inArgs[3].SetFloat64(height)
	inArgs[4].SetInt32(int32(unit))

	var ret gi.Argument

	err := paperSizeNewCustomFunction_Set()
	if err == nil {
		ret = paperSizeNewCustomFunction.Invoke(inArgs[:], nil)
	}

	retGo := PaperSizeNewFromNative(ret.Pointer())

	return retGo
}

var paperSizeNewFromGvariantFunction *gi.Function
var paperSizeNewFromGvariantFunction_Once sync.Once

func paperSizeNewFromGvariantFunction_Set() error {
	var err error
	paperSizeNewFromGvariantFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeNewFromGvariantFunction, err = paperSizeStruct.InvokerNew("new_from_gvariant")
	})
	return err
}

// PaperSizeNewFromGvariant is a representation of the C type gtk_paper_size_new_from_gvariant.
func PaperSizeNewFromGvariant(variant *glib.Variant) *PaperSize {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(variant.Native())

	var ret gi.Argument

	err := paperSizeNewFromGvariantFunction_Set()
	if err == nil {
		ret = paperSizeNewFromGvariantFunction.Invoke(inArgs[:], nil)
	}

	retGo := PaperSizeNewFromNative(ret.Pointer())

	return retGo
}

var paperSizeNewFromIppFunction *gi.Function
var paperSizeNewFromIppFunction_Once sync.Once

func paperSizeNewFromIppFunction_Set() error {
	var err error
	paperSizeNewFromIppFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeNewFromIppFunction, err = paperSizeStruct.InvokerNew("new_from_ipp")
	})
	return err
}

// PaperSizeNewFromIpp is a representation of the C type gtk_paper_size_new_from_ipp.
func PaperSizeNewFromIpp(ippName string, width float64, height float64) *PaperSize {
	var inArgs [3]gi.Argument
	inArgs[0].SetString(ippName)
	inArgs[1].SetFloat64(width)
	inArgs[2].SetFloat64(height)

	var ret gi.Argument

	err := paperSizeNewFromIppFunction_Set()
	if err == nil {
		ret = paperSizeNewFromIppFunction.Invoke(inArgs[:], nil)
	}

	retGo := PaperSizeNewFromNative(ret.Pointer())

	return retGo
}

var paperSizeNewFromKeyFileFunction *gi.Function
var paperSizeNewFromKeyFileFunction_Once sync.Once

func paperSizeNewFromKeyFileFunction_Set() error {
	var err error
	paperSizeNewFromKeyFileFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeNewFromKeyFileFunction, err = paperSizeStruct.InvokerNew("new_from_key_file")
	})
	return err
}

// PaperSizeNewFromKeyFile is a representation of the C type gtk_paper_size_new_from_key_file.
func PaperSizeNewFromKeyFile(keyFile *glib.KeyFile, groupName string) *PaperSize {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(keyFile.Native())
	inArgs[1].SetString(groupName)

	var ret gi.Argument

	err := paperSizeNewFromKeyFileFunction_Set()
	if err == nil {
		ret = paperSizeNewFromKeyFileFunction.Invoke(inArgs[:], nil)
	}

	retGo := PaperSizeNewFromNative(ret.Pointer())

	return retGo
}

var paperSizeNewFromPpdFunction *gi.Function
var paperSizeNewFromPpdFunction_Once sync.Once

func paperSizeNewFromPpdFunction_Set() error {
	var err error
	paperSizeNewFromPpdFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeNewFromPpdFunction, err = paperSizeStruct.InvokerNew("new_from_ppd")
	})
	return err
}

// PaperSizeNewFromPpd is a representation of the C type gtk_paper_size_new_from_ppd.
func PaperSizeNewFromPpd(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
	var inArgs [4]gi.Argument
	inArgs[0].SetString(ppdName)
	inArgs[1].SetString(ppdDisplayName)
	inArgs[2].SetFloat64(width)
	inArgs[3].SetFloat64(height)

	var ret gi.Argument

	err := paperSizeNewFromPpdFunction_Set()
	if err == nil {
		ret = paperSizeNewFromPpdFunction.Invoke(inArgs[:], nil)
	}

	retGo := PaperSizeNewFromNative(ret.Pointer())

	return retGo
}

var paperSizeCopyFunction *gi.Function
var paperSizeCopyFunction_Once sync.Once

func paperSizeCopyFunction_Set() error {
	var err error
	paperSizeCopyFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeCopyFunction, err = paperSizeStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_paper_size_copy.
func (recv *PaperSize) Copy() *PaperSize {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := paperSizeCopyFunction_Set()
	if err == nil {
		ret = paperSizeCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := PaperSizeNewFromNative(ret.Pointer())

	return retGo
}

var paperSizeFreeFunction *gi.Function
var paperSizeFreeFunction_Once sync.Once

func paperSizeFreeFunction_Set() error {
	var err error
	paperSizeFreeFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeFreeFunction, err = paperSizeStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_paper_size_free.
func (recv *PaperSize) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := paperSizeFreeFunction_Set()
	if err == nil {
		paperSizeFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var paperSizeGetDefaultBottomMarginFunction *gi.Function
var paperSizeGetDefaultBottomMarginFunction_Once sync.Once

func paperSizeGetDefaultBottomMarginFunction_Set() error {
	var err error
	paperSizeGetDefaultBottomMarginFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetDefaultBottomMarginFunction, err = paperSizeStruct.InvokerNew("get_default_bottom_margin")
	})
	return err
}

// GetDefaultBottomMargin is a representation of the C type gtk_paper_size_get_default_bottom_margin.
func (recv *PaperSize) GetDefaultBottomMargin(unit Unit) float64 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(unit))

	var ret gi.Argument

	err := paperSizeGetDefaultBottomMarginFunction_Set()
	if err == nil {
		ret = paperSizeGetDefaultBottomMarginFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Float64()

	return retGo
}

var paperSizeGetDefaultLeftMarginFunction *gi.Function
var paperSizeGetDefaultLeftMarginFunction_Once sync.Once

func paperSizeGetDefaultLeftMarginFunction_Set() error {
	var err error
	paperSizeGetDefaultLeftMarginFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetDefaultLeftMarginFunction, err = paperSizeStruct.InvokerNew("get_default_left_margin")
	})
	return err
}

// GetDefaultLeftMargin is a representation of the C type gtk_paper_size_get_default_left_margin.
func (recv *PaperSize) GetDefaultLeftMargin(unit Unit) float64 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(unit))

	var ret gi.Argument

	err := paperSizeGetDefaultLeftMarginFunction_Set()
	if err == nil {
		ret = paperSizeGetDefaultLeftMarginFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Float64()

	return retGo
}

var paperSizeGetDefaultRightMarginFunction *gi.Function
var paperSizeGetDefaultRightMarginFunction_Once sync.Once

func paperSizeGetDefaultRightMarginFunction_Set() error {
	var err error
	paperSizeGetDefaultRightMarginFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetDefaultRightMarginFunction, err = paperSizeStruct.InvokerNew("get_default_right_margin")
	})
	return err
}

// GetDefaultRightMargin is a representation of the C type gtk_paper_size_get_default_right_margin.
func (recv *PaperSize) GetDefaultRightMargin(unit Unit) float64 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(unit))

	var ret gi.Argument

	err := paperSizeGetDefaultRightMarginFunction_Set()
	if err == nil {
		ret = paperSizeGetDefaultRightMarginFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Float64()

	return retGo
}

var paperSizeGetDefaultTopMarginFunction *gi.Function
var paperSizeGetDefaultTopMarginFunction_Once sync.Once

func paperSizeGetDefaultTopMarginFunction_Set() error {
	var err error
	paperSizeGetDefaultTopMarginFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetDefaultTopMarginFunction, err = paperSizeStruct.InvokerNew("get_default_top_margin")
	})
	return err
}

// GetDefaultTopMargin is a representation of the C type gtk_paper_size_get_default_top_margin.
func (recv *PaperSize) GetDefaultTopMargin(unit Unit) float64 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(unit))

	var ret gi.Argument

	err := paperSizeGetDefaultTopMarginFunction_Set()
	if err == nil {
		ret = paperSizeGetDefaultTopMarginFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Float64()

	return retGo
}

var paperSizeGetDisplayNameFunction *gi.Function
var paperSizeGetDisplayNameFunction_Once sync.Once

func paperSizeGetDisplayNameFunction_Set() error {
	var err error
	paperSizeGetDisplayNameFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetDisplayNameFunction, err = paperSizeStruct.InvokerNew("get_display_name")
	})
	return err
}

// GetDisplayName is a representation of the C type gtk_paper_size_get_display_name.
func (recv *PaperSize) GetDisplayName() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := paperSizeGetDisplayNameFunction_Set()
	if err == nil {
		ret = paperSizeGetDisplayNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var paperSizeGetHeightFunction *gi.Function
var paperSizeGetHeightFunction_Once sync.Once

func paperSizeGetHeightFunction_Set() error {
	var err error
	paperSizeGetHeightFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetHeightFunction, err = paperSizeStruct.InvokerNew("get_height")
	})
	return err
}

// GetHeight is a representation of the C type gtk_paper_size_get_height.
func (recv *PaperSize) GetHeight(unit Unit) float64 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(unit))

	var ret gi.Argument

	err := paperSizeGetHeightFunction_Set()
	if err == nil {
		ret = paperSizeGetHeightFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Float64()

	return retGo
}

var paperSizeGetNameFunction *gi.Function
var paperSizeGetNameFunction_Once sync.Once

func paperSizeGetNameFunction_Set() error {
	var err error
	paperSizeGetNameFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetNameFunction, err = paperSizeStruct.InvokerNew("get_name")
	})
	return err
}

// GetName is a representation of the C type gtk_paper_size_get_name.
func (recv *PaperSize) GetName() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := paperSizeGetNameFunction_Set()
	if err == nil {
		ret = paperSizeGetNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var paperSizeGetPpdNameFunction *gi.Function
var paperSizeGetPpdNameFunction_Once sync.Once

func paperSizeGetPpdNameFunction_Set() error {
	var err error
	paperSizeGetPpdNameFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetPpdNameFunction, err = paperSizeStruct.InvokerNew("get_ppd_name")
	})
	return err
}

// GetPpdName is a representation of the C type gtk_paper_size_get_ppd_name.
func (recv *PaperSize) GetPpdName() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := paperSizeGetPpdNameFunction_Set()
	if err == nil {
		ret = paperSizeGetPpdNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var paperSizeGetWidthFunction *gi.Function
var paperSizeGetWidthFunction_Once sync.Once

func paperSizeGetWidthFunction_Set() error {
	var err error
	paperSizeGetWidthFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeGetWidthFunction, err = paperSizeStruct.InvokerNew("get_width")
	})
	return err
}

// GetWidth is a representation of the C type gtk_paper_size_get_width.
func (recv *PaperSize) GetWidth(unit Unit) float64 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(int32(unit))

	var ret gi.Argument

	err := paperSizeGetWidthFunction_Set()
	if err == nil {
		ret = paperSizeGetWidthFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Float64()

	return retGo
}

var paperSizeIsCustomFunction *gi.Function
var paperSizeIsCustomFunction_Once sync.Once

func paperSizeIsCustomFunction_Set() error {
	var err error
	paperSizeIsCustomFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeIsCustomFunction, err = paperSizeStruct.InvokerNew("is_custom")
	})
	return err
}

// IsCustom is a representation of the C type gtk_paper_size_is_custom.
func (recv *PaperSize) IsCustom() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := paperSizeIsCustomFunction_Set()
	if err == nil {
		ret = paperSizeIsCustomFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var paperSizeIsEqualFunction *gi.Function
var paperSizeIsEqualFunction_Once sync.Once

func paperSizeIsEqualFunction_Set() error {
	var err error
	paperSizeIsEqualFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeIsEqualFunction, err = paperSizeStruct.InvokerNew("is_equal")
	})
	return err
}

// IsEqual is a representation of the C type gtk_paper_size_is_equal.
func (recv *PaperSize) IsEqual(size2 *PaperSize) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(size2.Native())

	var ret gi.Argument

	err := paperSizeIsEqualFunction_Set()
	if err == nil {
		ret = paperSizeIsEqualFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var paperSizeIsIppFunction *gi.Function
var paperSizeIsIppFunction_Once sync.Once

func paperSizeIsIppFunction_Set() error {
	var err error
	paperSizeIsIppFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeIsIppFunction, err = paperSizeStruct.InvokerNew("is_ipp")
	})
	return err
}

// IsIpp is a representation of the C type gtk_paper_size_is_ipp.
func (recv *PaperSize) IsIpp() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := paperSizeIsIppFunction_Set()
	if err == nil {
		ret = paperSizeIsIppFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var paperSizeSetSizeFunction *gi.Function
var paperSizeSetSizeFunction_Once sync.Once

func paperSizeSetSizeFunction_Set() error {
	var err error
	paperSizeSetSizeFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeSetSizeFunction, err = paperSizeStruct.InvokerNew("set_size")
	})
	return err
}

// SetSize is a representation of the C type gtk_paper_size_set_size.
func (recv *PaperSize) SetSize(width float64, height float64, unit Unit) {
	var inArgs [4]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetFloat64(width)
	inArgs[2].SetFloat64(height)
	inArgs[3].SetInt32(int32(unit))

	err := paperSizeSetSizeFunction_Set()
	if err == nil {
		paperSizeSetSizeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var paperSizeToGvariantFunction *gi.Function
var paperSizeToGvariantFunction_Once sync.Once

func paperSizeToGvariantFunction_Set() error {
	var err error
	paperSizeToGvariantFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeToGvariantFunction, err = paperSizeStruct.InvokerNew("to_gvariant")
	})
	return err
}

// ToGvariant is a representation of the C type gtk_paper_size_to_gvariant.
func (recv *PaperSize) ToGvariant() *glib.Variant {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := paperSizeToGvariantFunction_Set()
	if err == nil {
		ret = paperSizeToGvariantFunction.Invoke(inArgs[:], nil)
	}

	retGo := glib.VariantNewFromNative(ret.Pointer())

	return retGo
}

var paperSizeToKeyFileFunction *gi.Function
var paperSizeToKeyFileFunction_Once sync.Once

func paperSizeToKeyFileFunction_Set() error {
	var err error
	paperSizeToKeyFileFunction_Once.Do(func() {
		err = paperSizeStruct_Set()
		if err != nil {
			return
		}
		paperSizeToKeyFileFunction, err = paperSizeStruct.InvokerNew("to_key_file")
	})
	return err
}

// ToKeyFile is a representation of the C type gtk_paper_size_to_key_file.
func (recv *PaperSize) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(keyFile.Native())
	inArgs[2].SetString(groupName)

	err := paperSizeToKeyFileFunction_Set()
	if err == nil {
		paperSizeToKeyFileFunction.Invoke(inArgs[:], nil)
	}

	return
}

var placesSidebarClassStruct *gi.Struct
var placesSidebarClassStruct_Once sync.Once

func placesSidebarClassStruct_Set() error {
	var err error
	placesSidebarClassStruct_Once.Do(func() {
		placesSidebarClassStruct, err = gi.StructNew("Gtk", "PlacesSidebarClass")
	})
	return err
}

type PlacesSidebarClass struct {
	native unsafe.Pointer
}

func PlacesSidebarClassNewFromNative(native unsafe.Pointer) *PlacesSidebarClass {
	err := placesSidebarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PlacesSidebarClass{native: native}

	return instance
}

/*
CastToPlacesSidebarClass down casts any arbitrary Object to PlacesSidebarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PlacesSidebarClass.
*/
func CastToPlacesSidebarClass(object *gobject.Object) *PlacesSidebarClass {
	return PlacesSidebarClassNewFromNative(object.Native())
}

// Equals compares this PlacesSidebarClass with another PlacesSidebarClass, and returns true if they represent the same Object.
func (recv *PlacesSidebarClass) Equals(other *PlacesSidebarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PlacesSidebarClass) Native() unsafe.Pointer {
	return recv.native
}

// PlacesSidebarClassStruct creates an uninitialised PlacesSidebarClass.
func PlacesSidebarClassStruct() *PlacesSidebarClass {
	err := placesSidebarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PlacesSidebarClassNewFromNative(placesSidebarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePlacesSidebarClass)
	return structGo
}
func finalizePlacesSidebarClass(obj *PlacesSidebarClass) {
	placesSidebarClassStruct.Free(obj.Native())
}

var plugClassStruct *gi.Struct
var plugClassStruct_Once sync.Once

func plugClassStruct_Set() error {
	var err error
	plugClassStruct_Once.Do(func() {
		plugClassStruct, err = gi.StructNew("Gtk", "PlugClass")
	})
	return err
}

type PlugClass struct {
	native unsafe.Pointer
}

func PlugClassNewFromNative(native unsafe.Pointer) *PlugClass {
	err := plugClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PlugClass{native: native}

	return instance
}

/*
CastToPlugClass down casts any arbitrary Object to PlugClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PlugClass.
*/
func CastToPlugClass(object *gobject.Object) *PlugClass {
	return PlugClassNewFromNative(object.Native())
}

// Equals compares this PlugClass with another PlugClass, and returns true if they represent the same Object.
func (recv *PlugClass) Equals(other *PlugClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PlugClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *PlugClass) FieldParentClass() *WindowClass {
	argValue := gi.StructFieldGet(plugClassStruct, recv.Native(), "parent_class")
	value := WindowClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *PlugClass) SetFieldParentClass(value *WindowClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(plugClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'embedded' : for field getter : missing Type

// UNSUPPORTED : C value 'embedded' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// PlugClassStruct creates an uninitialised PlugClass.
func PlugClassStruct() *PlugClass {
	err := plugClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PlugClassNewFromNative(plugClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePlugClass)
	return structGo
}
func finalizePlugClass(obj *PlugClass) {
	plugClassStruct.Free(obj.Native())
}

var plugPrivateStruct *gi.Struct
var plugPrivateStruct_Once sync.Once

func plugPrivateStruct_Set() error {
	var err error
	plugPrivateStruct_Once.Do(func() {
		plugPrivateStruct, err = gi.StructNew("Gtk", "PlugPrivate")
	})
	return err
}

type PlugPrivate struct {
	native unsafe.Pointer
}

func PlugPrivateNewFromNative(native unsafe.Pointer) *PlugPrivate {
	err := plugPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PlugPrivate{native: native}

	return instance
}

/*
CastToPlugPrivate down casts any arbitrary Object to PlugPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a PlugPrivate.
*/
func CastToPlugPrivate(object *gobject.Object) *PlugPrivate {
	return PlugPrivateNewFromNative(object.Native())
}

// Equals compares this PlugPrivate with another PlugPrivate, and returns true if they represent the same Object.
func (recv *PlugPrivate) Equals(other *PlugPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *PlugPrivate) Native() unsafe.Pointer {
	return recv.native
}

// PlugPrivateStruct creates an uninitialised PlugPrivate.
func PlugPrivateStruct() *PlugPrivate {
	err := plugPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PlugPrivateNewFromNative(plugPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePlugPrivate)
	return structGo
}
func finalizePlugPrivate(obj *PlugPrivate) {
	plugPrivateStruct.Free(obj.Native())
}

var popoverAccessibleClassStruct *gi.Struct
var popoverAccessibleClassStruct_Once sync.Once

func popoverAccessibleClassStruct_Set() error {
	var err error
	popoverAccessibleClassStruct_Once.Do(func() {
		popoverAccessibleClassStruct, err = gi.StructNew("Gtk", "PopoverAccessibleClass")
	})
	return err
}

type PopoverAccessibleClass struct {
	native unsafe.Pointer
}

func PopoverAccessibleClassNewFromNative(native unsafe.Pointer) *PopoverAccessibleClass {
	err := popoverAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PopoverAccessibleClass{native: native}

	return instance
}

/*
CastToPopoverAccessibleClass down casts any arbitrary Object to PopoverAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PopoverAccessibleClass.
*/
func CastToPopoverAccessibleClass(object *gobject.Object) *PopoverAccessibleClass {
	return PopoverAccessibleClassNewFromNative(object.Native())
}

// Equals compares this PopoverAccessibleClass with another PopoverAccessibleClass, and returns true if they represent the same Object.
func (recv *PopoverAccessibleClass) Equals(other *PopoverAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PopoverAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *PopoverAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(popoverAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *PopoverAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(popoverAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// PopoverAccessibleClassStruct creates an uninitialised PopoverAccessibleClass.
func PopoverAccessibleClassStruct() *PopoverAccessibleClass {
	err := popoverAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PopoverAccessibleClassNewFromNative(popoverAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePopoverAccessibleClass)
	return structGo
}
func finalizePopoverAccessibleClass(obj *PopoverAccessibleClass) {
	popoverAccessibleClassStruct.Free(obj.Native())
}

var popoverClassStruct *gi.Struct
var popoverClassStruct_Once sync.Once

func popoverClassStruct_Set() error {
	var err error
	popoverClassStruct_Once.Do(func() {
		popoverClassStruct, err = gi.StructNew("Gtk", "PopoverClass")
	})
	return err
}

type PopoverClass struct {
	native unsafe.Pointer
}

func PopoverClassNewFromNative(native unsafe.Pointer) *PopoverClass {
	err := popoverClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PopoverClass{native: native}

	return instance
}

/*
CastToPopoverClass down casts any arbitrary Object to PopoverClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PopoverClass.
*/
func CastToPopoverClass(object *gobject.Object) *PopoverClass {
	return PopoverClassNewFromNative(object.Native())
}

// Equals compares this PopoverClass with another PopoverClass, and returns true if they represent the same Object.
func (recv *PopoverClass) Equals(other *PopoverClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PopoverClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *PopoverClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(popoverClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *PopoverClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(popoverClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'closed' : for field getter : missing Type

// UNSUPPORTED : C value 'closed' : for field setter : missing Type

// PopoverClassStruct creates an uninitialised PopoverClass.
func PopoverClassStruct() *PopoverClass {
	err := popoverClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PopoverClassNewFromNative(popoverClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePopoverClass)
	return structGo
}
func finalizePopoverClass(obj *PopoverClass) {
	popoverClassStruct.Free(obj.Native())
}

var popoverMenuClassStruct *gi.Struct
var popoverMenuClassStruct_Once sync.Once

func popoverMenuClassStruct_Set() error {
	var err error
	popoverMenuClassStruct_Once.Do(func() {
		popoverMenuClassStruct, err = gi.StructNew("Gtk", "PopoverMenuClass")
	})
	return err
}

type PopoverMenuClass struct {
	native unsafe.Pointer
}

func PopoverMenuClassNewFromNative(native unsafe.Pointer) *PopoverMenuClass {
	err := popoverMenuClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PopoverMenuClass{native: native}

	return instance
}

/*
CastToPopoverMenuClass down casts any arbitrary Object to PopoverMenuClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PopoverMenuClass.
*/
func CastToPopoverMenuClass(object *gobject.Object) *PopoverMenuClass {
	return PopoverMenuClassNewFromNative(object.Native())
}

// Equals compares this PopoverMenuClass with another PopoverMenuClass, and returns true if they represent the same Object.
func (recv *PopoverMenuClass) Equals(other *PopoverMenuClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PopoverMenuClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *PopoverMenuClass) FieldParentClass() *PopoverClass {
	argValue := gi.StructFieldGet(popoverMenuClassStruct, recv.Native(), "parent_class")
	value := PopoverClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *PopoverMenuClass) SetFieldParentClass(value *PopoverClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(popoverMenuClassStruct, recv.Native(), "parent_class", argValue)
}

// PopoverMenuClassStruct creates an uninitialised PopoverMenuClass.
func PopoverMenuClassStruct() *PopoverMenuClass {
	err := popoverMenuClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PopoverMenuClassNewFromNative(popoverMenuClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePopoverMenuClass)
	return structGo
}
func finalizePopoverMenuClass(obj *PopoverMenuClass) {
	popoverMenuClassStruct.Free(obj.Native())
}

var popoverPrivateStruct *gi.Struct
var popoverPrivateStruct_Once sync.Once

func popoverPrivateStruct_Set() error {
	var err error
	popoverPrivateStruct_Once.Do(func() {
		popoverPrivateStruct, err = gi.StructNew("Gtk", "PopoverPrivate")
	})
	return err
}

type PopoverPrivate struct {
	native unsafe.Pointer
}

func PopoverPrivateNewFromNative(native unsafe.Pointer) *PopoverPrivate {
	err := popoverPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PopoverPrivate{native: native}

	return instance
}

/*
CastToPopoverPrivate down casts any arbitrary Object to PopoverPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a PopoverPrivate.
*/
func CastToPopoverPrivate(object *gobject.Object) *PopoverPrivate {
	return PopoverPrivateNewFromNative(object.Native())
}

// Equals compares this PopoverPrivate with another PopoverPrivate, and returns true if they represent the same Object.
func (recv *PopoverPrivate) Equals(other *PopoverPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *PopoverPrivate) Native() unsafe.Pointer {
	return recv.native
}

// PopoverPrivateStruct creates an uninitialised PopoverPrivate.
func PopoverPrivateStruct() *PopoverPrivate {
	err := popoverPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PopoverPrivateNewFromNative(popoverPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePopoverPrivate)
	return structGo
}
func finalizePopoverPrivate(obj *PopoverPrivate) {
	popoverPrivateStruct.Free(obj.Native())
}

var printOperationClassStruct *gi.Struct
var printOperationClassStruct_Once sync.Once

func printOperationClassStruct_Set() error {
	var err error
	printOperationClassStruct_Once.Do(func() {
		printOperationClassStruct, err = gi.StructNew("Gtk", "PrintOperationClass")
	})
	return err
}

type PrintOperationClass struct {
	native unsafe.Pointer
}

func PrintOperationClassNewFromNative(native unsafe.Pointer) *PrintOperationClass {
	err := printOperationClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PrintOperationClass{native: native}

	return instance
}

/*
CastToPrintOperationClass down casts any arbitrary Object to PrintOperationClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a PrintOperationClass.
*/
func CastToPrintOperationClass(object *gobject.Object) *PrintOperationClass {
	return PrintOperationClassNewFromNative(object.Native())
}

// Equals compares this PrintOperationClass with another PrintOperationClass, and returns true if they represent the same Object.
func (recv *PrintOperationClass) Equals(other *PrintOperationClass) bool {
	return other.Native() == recv.Native()
}

func (recv *PrintOperationClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *PrintOperationClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(printOperationClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *PrintOperationClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(printOperationClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'done' : for field getter : missing Type

// UNSUPPORTED : C value 'done' : for field setter : missing Type

// UNSUPPORTED : C value 'begin_print' : for field getter : missing Type

// UNSUPPORTED : C value 'begin_print' : for field setter : missing Type

// UNSUPPORTED : C value 'paginate' : for field getter : missing Type

// UNSUPPORTED : C value 'paginate' : for field setter : missing Type

// UNSUPPORTED : C value 'request_page_setup' : for field getter : missing Type

// UNSUPPORTED : C value 'request_page_setup' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_page' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_page' : for field setter : missing Type

// UNSUPPORTED : C value 'end_print' : for field getter : missing Type

// UNSUPPORTED : C value 'end_print' : for field setter : missing Type

// UNSUPPORTED : C value 'status_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'status_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'create_custom_widget' : for field getter : missing Type

// UNSUPPORTED : C value 'create_custom_widget' : for field setter : missing Type

// UNSUPPORTED : C value 'custom_widget_apply' : for field getter : missing Type

// UNSUPPORTED : C value 'custom_widget_apply' : for field setter : missing Type

// UNSUPPORTED : C value 'preview' : for field getter : missing Type

// UNSUPPORTED : C value 'preview' : for field setter : missing Type

// UNSUPPORTED : C value 'update_custom_widget' : for field getter : missing Type

// UNSUPPORTED : C value 'update_custom_widget' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// PrintOperationClassStruct creates an uninitialised PrintOperationClass.
func PrintOperationClassStruct() *PrintOperationClass {
	err := printOperationClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PrintOperationClassNewFromNative(printOperationClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePrintOperationClass)
	return structGo
}
func finalizePrintOperationClass(obj *PrintOperationClass) {
	printOperationClassStruct.Free(obj.Native())
}

var printOperationPreviewIfaceStruct *gi.Struct
var printOperationPreviewIfaceStruct_Once sync.Once

func printOperationPreviewIfaceStruct_Set() error {
	var err error
	printOperationPreviewIfaceStruct_Once.Do(func() {
		printOperationPreviewIfaceStruct, err = gi.StructNew("Gtk", "PrintOperationPreviewIface")
	})
	return err
}

type PrintOperationPreviewIface struct {
	native unsafe.Pointer
}

func PrintOperationPreviewIfaceNewFromNative(native unsafe.Pointer) *PrintOperationPreviewIface {
	err := printOperationPreviewIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PrintOperationPreviewIface{native: native}

	return instance
}

/*
CastToPrintOperationPreviewIface down casts any arbitrary Object to PrintOperationPreviewIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a PrintOperationPreviewIface.
*/
func CastToPrintOperationPreviewIface(object *gobject.Object) *PrintOperationPreviewIface {
	return PrintOperationPreviewIfaceNewFromNative(object.Native())
}

// Equals compares this PrintOperationPreviewIface with another PrintOperationPreviewIface, and returns true if they represent the same Object.
func (recv *PrintOperationPreviewIface) Equals(other *PrintOperationPreviewIface) bool {
	return other.Native() == recv.Native()
}

func (recv *PrintOperationPreviewIface) Native() unsafe.Pointer {
	return recv.native
}

// FieldGIface returns the C field 'g_iface'.
func (recv *PrintOperationPreviewIface) FieldGIface() *gobject.TypeInterface {
	argValue := gi.StructFieldGet(printOperationPreviewIfaceStruct, recv.Native(), "g_iface")
	value := gobject.TypeInterfaceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldGIface sets the value of the C field 'g_iface'.
func (recv *PrintOperationPreviewIface) SetFieldGIface(value *gobject.TypeInterface) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(printOperationPreviewIfaceStruct, recv.Native(), "g_iface", argValue)
}

// UNSUPPORTED : C value 'ready' : for field getter : missing Type

// UNSUPPORTED : C value 'ready' : for field setter : missing Type

// UNSUPPORTED : C value 'got_page_size' : for field getter : missing Type

// UNSUPPORTED : C value 'got_page_size' : for field setter : missing Type

// UNSUPPORTED : C value 'render_page' : for field getter : missing Type

// UNSUPPORTED : C value 'render_page' : for field setter : missing Type

// UNSUPPORTED : C value 'is_selected' : for field getter : missing Type

// UNSUPPORTED : C value 'is_selected' : for field setter : missing Type

// UNSUPPORTED : C value 'end_preview' : for field getter : missing Type

// UNSUPPORTED : C value 'end_preview' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// PrintOperationPreviewIfaceStruct creates an uninitialised PrintOperationPreviewIface.
func PrintOperationPreviewIfaceStruct() *PrintOperationPreviewIface {
	err := printOperationPreviewIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PrintOperationPreviewIfaceNewFromNative(printOperationPreviewIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePrintOperationPreviewIface)
	return structGo
}
func finalizePrintOperationPreviewIface(obj *PrintOperationPreviewIface) {
	printOperationPreviewIfaceStruct.Free(obj.Native())
}

var printOperationPrivateStruct *gi.Struct
var printOperationPrivateStruct_Once sync.Once

func printOperationPrivateStruct_Set() error {
	var err error
	printOperationPrivateStruct_Once.Do(func() {
		printOperationPrivateStruct, err = gi.StructNew("Gtk", "PrintOperationPrivate")
	})
	return err
}

type PrintOperationPrivate struct {
	native unsafe.Pointer
}

func PrintOperationPrivateNewFromNative(native unsafe.Pointer) *PrintOperationPrivate {
	err := printOperationPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &PrintOperationPrivate{native: native}

	return instance
}

/*
CastToPrintOperationPrivate down casts any arbitrary Object to PrintOperationPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a PrintOperationPrivate.
*/
func CastToPrintOperationPrivate(object *gobject.Object) *PrintOperationPrivate {
	return PrintOperationPrivateNewFromNative(object.Native())
}

// Equals compares this PrintOperationPrivate with another PrintOperationPrivate, and returns true if they represent the same Object.
func (recv *PrintOperationPrivate) Equals(other *PrintOperationPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *PrintOperationPrivate) Native() unsafe.Pointer {
	return recv.native
}

// PrintOperationPrivateStruct creates an uninitialised PrintOperationPrivate.
func PrintOperationPrivateStruct() *PrintOperationPrivate {
	err := printOperationPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := PrintOperationPrivateNewFromNative(printOperationPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizePrintOperationPrivate)
	return structGo
}
func finalizePrintOperationPrivate(obj *PrintOperationPrivate) {
	printOperationPrivateStruct.Free(obj.Native())
}

var progressBarAccessibleClassStruct *gi.Struct
var progressBarAccessibleClassStruct_Once sync.Once

func progressBarAccessibleClassStruct_Set() error {
	var err error
	progressBarAccessibleClassStruct_Once.Do(func() {
		progressBarAccessibleClassStruct, err = gi.StructNew("Gtk", "ProgressBarAccessibleClass")
	})
	return err
}

type ProgressBarAccessibleClass struct {
	native unsafe.Pointer
}

func ProgressBarAccessibleClassNewFromNative(native unsafe.Pointer) *ProgressBarAccessibleClass {
	err := progressBarAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ProgressBarAccessibleClass{native: native}

	return instance
}

/*
CastToProgressBarAccessibleClass down casts any arbitrary Object to ProgressBarAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ProgressBarAccessibleClass.
*/
func CastToProgressBarAccessibleClass(object *gobject.Object) *ProgressBarAccessibleClass {
	return ProgressBarAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ProgressBarAccessibleClass with another ProgressBarAccessibleClass, and returns true if they represent the same Object.
func (recv *ProgressBarAccessibleClass) Equals(other *ProgressBarAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ProgressBarAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ProgressBarAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(progressBarAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ProgressBarAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(progressBarAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ProgressBarAccessibleClassStruct creates an uninitialised ProgressBarAccessibleClass.
func ProgressBarAccessibleClassStruct() *ProgressBarAccessibleClass {
	err := progressBarAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ProgressBarAccessibleClassNewFromNative(progressBarAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeProgressBarAccessibleClass)
	return structGo
}
func finalizeProgressBarAccessibleClass(obj *ProgressBarAccessibleClass) {
	progressBarAccessibleClassStruct.Free(obj.Native())
}

var progressBarAccessiblePrivateStruct *gi.Struct
var progressBarAccessiblePrivateStruct_Once sync.Once

func progressBarAccessiblePrivateStruct_Set() error {
	var err error
	progressBarAccessiblePrivateStruct_Once.Do(func() {
		progressBarAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ProgressBarAccessiblePrivate")
	})
	return err
}

type ProgressBarAccessiblePrivate struct {
	native unsafe.Pointer
}

func ProgressBarAccessiblePrivateNewFromNative(native unsafe.Pointer) *ProgressBarAccessiblePrivate {
	err := progressBarAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ProgressBarAccessiblePrivate{native: native}

	return instance
}

/*
CastToProgressBarAccessiblePrivate down casts any arbitrary Object to ProgressBarAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ProgressBarAccessiblePrivate.
*/
func CastToProgressBarAccessiblePrivate(object *gobject.Object) *ProgressBarAccessiblePrivate {
	return ProgressBarAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ProgressBarAccessiblePrivate with another ProgressBarAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ProgressBarAccessiblePrivate) Equals(other *ProgressBarAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ProgressBarAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ProgressBarAccessiblePrivateStruct creates an uninitialised ProgressBarAccessiblePrivate.
func ProgressBarAccessiblePrivateStruct() *ProgressBarAccessiblePrivate {
	err := progressBarAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ProgressBarAccessiblePrivateNewFromNative(progressBarAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeProgressBarAccessiblePrivate)
	return structGo
}
func finalizeProgressBarAccessiblePrivate(obj *ProgressBarAccessiblePrivate) {
	progressBarAccessiblePrivateStruct.Free(obj.Native())
}

var progressBarClassStruct *gi.Struct
var progressBarClassStruct_Once sync.Once

func progressBarClassStruct_Set() error {
	var err error
	progressBarClassStruct_Once.Do(func() {
		progressBarClassStruct, err = gi.StructNew("Gtk", "ProgressBarClass")
	})
	return err
}

type ProgressBarClass struct {
	native unsafe.Pointer
}

func ProgressBarClassNewFromNative(native unsafe.Pointer) *ProgressBarClass {
	err := progressBarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ProgressBarClass{native: native}

	return instance
}

/*
CastToProgressBarClass down casts any arbitrary Object to ProgressBarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ProgressBarClass.
*/
func CastToProgressBarClass(object *gobject.Object) *ProgressBarClass {
	return ProgressBarClassNewFromNative(object.Native())
}

// Equals compares this ProgressBarClass with another ProgressBarClass, and returns true if they represent the same Object.
func (recv *ProgressBarClass) Equals(other *ProgressBarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ProgressBarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ProgressBarClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(progressBarClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ProgressBarClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(progressBarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ProgressBarClassStruct creates an uninitialised ProgressBarClass.
func ProgressBarClassStruct() *ProgressBarClass {
	err := progressBarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ProgressBarClassNewFromNative(progressBarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeProgressBarClass)
	return structGo
}
func finalizeProgressBarClass(obj *ProgressBarClass) {
	progressBarClassStruct.Free(obj.Native())
}

var progressBarPrivateStruct *gi.Struct
var progressBarPrivateStruct_Once sync.Once

func progressBarPrivateStruct_Set() error {
	var err error
	progressBarPrivateStruct_Once.Do(func() {
		progressBarPrivateStruct, err = gi.StructNew("Gtk", "ProgressBarPrivate")
	})
	return err
}

type ProgressBarPrivate struct {
	native unsafe.Pointer
}

func ProgressBarPrivateNewFromNative(native unsafe.Pointer) *ProgressBarPrivate {
	err := progressBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ProgressBarPrivate{native: native}

	return instance
}

/*
CastToProgressBarPrivate down casts any arbitrary Object to ProgressBarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ProgressBarPrivate.
*/
func CastToProgressBarPrivate(object *gobject.Object) *ProgressBarPrivate {
	return ProgressBarPrivateNewFromNative(object.Native())
}

// Equals compares this ProgressBarPrivate with another ProgressBarPrivate, and returns true if they represent the same Object.
func (recv *ProgressBarPrivate) Equals(other *ProgressBarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ProgressBarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ProgressBarPrivateStruct creates an uninitialised ProgressBarPrivate.
func ProgressBarPrivateStruct() *ProgressBarPrivate {
	err := progressBarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ProgressBarPrivateNewFromNative(progressBarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeProgressBarPrivate)
	return structGo
}
func finalizeProgressBarPrivate(obj *ProgressBarPrivate) {
	progressBarPrivateStruct.Free(obj.Native())
}

var radioActionClassStruct *gi.Struct
var radioActionClassStruct_Once sync.Once

func radioActionClassStruct_Set() error {
	var err error
	radioActionClassStruct_Once.Do(func() {
		radioActionClassStruct, err = gi.StructNew("Gtk", "RadioActionClass")
	})
	return err
}

type RadioActionClass struct {
	native unsafe.Pointer
}

func RadioActionClassNewFromNative(native unsafe.Pointer) *RadioActionClass {
	err := radioActionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioActionClass{native: native}

	return instance
}

/*
CastToRadioActionClass down casts any arbitrary Object to RadioActionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioActionClass.
*/
func CastToRadioActionClass(object *gobject.Object) *RadioActionClass {
	return RadioActionClassNewFromNative(object.Native())
}

// Equals compares this RadioActionClass with another RadioActionClass, and returns true if they represent the same Object.
func (recv *RadioActionClass) Equals(other *RadioActionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioActionClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RadioActionClass) FieldParentClass() *ToggleActionClass {
	argValue := gi.StructFieldGet(radioActionClassStruct, recv.Native(), "parent_class")
	value := ToggleActionClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RadioActionClass) SetFieldParentClass(value *ToggleActionClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(radioActionClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// RadioActionClassStruct creates an uninitialised RadioActionClass.
func RadioActionClassStruct() *RadioActionClass {
	err := radioActionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioActionClassNewFromNative(radioActionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioActionClass)
	return structGo
}
func finalizeRadioActionClass(obj *RadioActionClass) {
	radioActionClassStruct.Free(obj.Native())
}

var radioActionEntryStruct *gi.Struct
var radioActionEntryStruct_Once sync.Once

func radioActionEntryStruct_Set() error {
	var err error
	radioActionEntryStruct_Once.Do(func() {
		radioActionEntryStruct, err = gi.StructNew("Gtk", "RadioActionEntry")
	})
	return err
}

type RadioActionEntry struct {
	native unsafe.Pointer
}

func RadioActionEntryNewFromNative(native unsafe.Pointer) *RadioActionEntry {
	err := radioActionEntryStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioActionEntry{native: native}

	return instance
}

/*
CastToRadioActionEntry down casts any arbitrary Object to RadioActionEntry.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioActionEntry.
*/
func CastToRadioActionEntry(object *gobject.Object) *RadioActionEntry {
	return RadioActionEntryNewFromNative(object.Native())
}

// Equals compares this RadioActionEntry with another RadioActionEntry, and returns true if they represent the same Object.
func (recv *RadioActionEntry) Equals(other *RadioActionEntry) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioActionEntry) Native() unsafe.Pointer {
	return recv.native
}

// FieldName returns the C field 'name'.
func (recv *RadioActionEntry) FieldName() string {
	argValue := gi.StructFieldGet(radioActionEntryStruct, recv.Native(), "name")
	value := argValue.String(false)
	return value
}

// SetFieldName sets the value of the C field 'name'.
func (recv *RadioActionEntry) SetFieldName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(radioActionEntryStruct, recv.Native(), "name", argValue)
}

// FieldStockId returns the C field 'stock_id'.
func (recv *RadioActionEntry) FieldStockId() string {
	argValue := gi.StructFieldGet(radioActionEntryStruct, recv.Native(), "stock_id")
	value := argValue.String(false)
	return value
}

// SetFieldStockId sets the value of the C field 'stock_id'.
func (recv *RadioActionEntry) SetFieldStockId(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(radioActionEntryStruct, recv.Native(), "stock_id", argValue)
}

// FieldLabel returns the C field 'label'.
func (recv *RadioActionEntry) FieldLabel() string {
	argValue := gi.StructFieldGet(radioActionEntryStruct, recv.Native(), "label")
	value := argValue.String(false)
	return value
}

// SetFieldLabel sets the value of the C field 'label'.
func (recv *RadioActionEntry) SetFieldLabel(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(radioActionEntryStruct, recv.Native(), "label", argValue)
}

// FieldAccelerator returns the C field 'accelerator'.
func (recv *RadioActionEntry) FieldAccelerator() string {
	argValue := gi.StructFieldGet(radioActionEntryStruct, recv.Native(), "accelerator")
	value := argValue.String(false)
	return value
}

// SetFieldAccelerator sets the value of the C field 'accelerator'.
func (recv *RadioActionEntry) SetFieldAccelerator(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(radioActionEntryStruct, recv.Native(), "accelerator", argValue)
}

// FieldTooltip returns the C field 'tooltip'.
func (recv *RadioActionEntry) FieldTooltip() string {
	argValue := gi.StructFieldGet(radioActionEntryStruct, recv.Native(), "tooltip")
	value := argValue.String(false)
	return value
}

// SetFieldTooltip sets the value of the C field 'tooltip'.
func (recv *RadioActionEntry) SetFieldTooltip(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(radioActionEntryStruct, recv.Native(), "tooltip", argValue)
}

// FieldValue returns the C field 'value'.
func (recv *RadioActionEntry) FieldValue() int32 {
	argValue := gi.StructFieldGet(radioActionEntryStruct, recv.Native(), "value")
	value := argValue.Int32()
	return value
}

// SetFieldValue sets the value of the C field 'value'.
func (recv *RadioActionEntry) SetFieldValue(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(radioActionEntryStruct, recv.Native(), "value", argValue)
}

// RadioActionEntryStruct creates an uninitialised RadioActionEntry.
func RadioActionEntryStruct() *RadioActionEntry {
	err := radioActionEntryStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioActionEntryNewFromNative(radioActionEntryStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioActionEntry)
	return structGo
}
func finalizeRadioActionEntry(obj *RadioActionEntry) {
	radioActionEntryStruct.Free(obj.Native())
}

var radioActionPrivateStruct *gi.Struct
var radioActionPrivateStruct_Once sync.Once

func radioActionPrivateStruct_Set() error {
	var err error
	radioActionPrivateStruct_Once.Do(func() {
		radioActionPrivateStruct, err = gi.StructNew("Gtk", "RadioActionPrivate")
	})
	return err
}

type RadioActionPrivate struct {
	native unsafe.Pointer
}

func RadioActionPrivateNewFromNative(native unsafe.Pointer) *RadioActionPrivate {
	err := radioActionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioActionPrivate{native: native}

	return instance
}

/*
CastToRadioActionPrivate down casts any arbitrary Object to RadioActionPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioActionPrivate.
*/
func CastToRadioActionPrivate(object *gobject.Object) *RadioActionPrivate {
	return RadioActionPrivateNewFromNative(object.Native())
}

// Equals compares this RadioActionPrivate with another RadioActionPrivate, and returns true if they represent the same Object.
func (recv *RadioActionPrivate) Equals(other *RadioActionPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioActionPrivate) Native() unsafe.Pointer {
	return recv.native
}

// RadioActionPrivateStruct creates an uninitialised RadioActionPrivate.
func RadioActionPrivateStruct() *RadioActionPrivate {
	err := radioActionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioActionPrivateNewFromNative(radioActionPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioActionPrivate)
	return structGo
}
func finalizeRadioActionPrivate(obj *RadioActionPrivate) {
	radioActionPrivateStruct.Free(obj.Native())
}

var radioButtonAccessibleClassStruct *gi.Struct
var radioButtonAccessibleClassStruct_Once sync.Once

func radioButtonAccessibleClassStruct_Set() error {
	var err error
	radioButtonAccessibleClassStruct_Once.Do(func() {
		radioButtonAccessibleClassStruct, err = gi.StructNew("Gtk", "RadioButtonAccessibleClass")
	})
	return err
}

type RadioButtonAccessibleClass struct {
	native unsafe.Pointer
}

func RadioButtonAccessibleClassNewFromNative(native unsafe.Pointer) *RadioButtonAccessibleClass {
	err := radioButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioButtonAccessibleClass{native: native}

	return instance
}

/*
CastToRadioButtonAccessibleClass down casts any arbitrary Object to RadioButtonAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioButtonAccessibleClass.
*/
func CastToRadioButtonAccessibleClass(object *gobject.Object) *RadioButtonAccessibleClass {
	return RadioButtonAccessibleClassNewFromNative(object.Native())
}

// Equals compares this RadioButtonAccessibleClass with another RadioButtonAccessibleClass, and returns true if they represent the same Object.
func (recv *RadioButtonAccessibleClass) Equals(other *RadioButtonAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioButtonAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RadioButtonAccessibleClass) FieldParentClass() *ToggleButtonAccessibleClass {
	argValue := gi.StructFieldGet(radioButtonAccessibleClassStruct, recv.Native(), "parent_class")
	value := ToggleButtonAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RadioButtonAccessibleClass) SetFieldParentClass(value *ToggleButtonAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(radioButtonAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// RadioButtonAccessibleClassStruct creates an uninitialised RadioButtonAccessibleClass.
func RadioButtonAccessibleClassStruct() *RadioButtonAccessibleClass {
	err := radioButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioButtonAccessibleClassNewFromNative(radioButtonAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioButtonAccessibleClass)
	return structGo
}
func finalizeRadioButtonAccessibleClass(obj *RadioButtonAccessibleClass) {
	radioButtonAccessibleClassStruct.Free(obj.Native())
}

var radioButtonAccessiblePrivateStruct *gi.Struct
var radioButtonAccessiblePrivateStruct_Once sync.Once

func radioButtonAccessiblePrivateStruct_Set() error {
	var err error
	radioButtonAccessiblePrivateStruct_Once.Do(func() {
		radioButtonAccessiblePrivateStruct, err = gi.StructNew("Gtk", "RadioButtonAccessiblePrivate")
	})
	return err
}

type RadioButtonAccessiblePrivate struct {
	native unsafe.Pointer
}

func RadioButtonAccessiblePrivateNewFromNative(native unsafe.Pointer) *RadioButtonAccessiblePrivate {
	err := radioButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioButtonAccessiblePrivate{native: native}

	return instance
}

/*
CastToRadioButtonAccessiblePrivate down casts any arbitrary Object to RadioButtonAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioButtonAccessiblePrivate.
*/
func CastToRadioButtonAccessiblePrivate(object *gobject.Object) *RadioButtonAccessiblePrivate {
	return RadioButtonAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this RadioButtonAccessiblePrivate with another RadioButtonAccessiblePrivate, and returns true if they represent the same Object.
func (recv *RadioButtonAccessiblePrivate) Equals(other *RadioButtonAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioButtonAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// RadioButtonAccessiblePrivateStruct creates an uninitialised RadioButtonAccessiblePrivate.
func RadioButtonAccessiblePrivateStruct() *RadioButtonAccessiblePrivate {
	err := radioButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioButtonAccessiblePrivateNewFromNative(radioButtonAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioButtonAccessiblePrivate)
	return structGo
}
func finalizeRadioButtonAccessiblePrivate(obj *RadioButtonAccessiblePrivate) {
	radioButtonAccessiblePrivateStruct.Free(obj.Native())
}

var radioButtonClassStruct *gi.Struct
var radioButtonClassStruct_Once sync.Once

func radioButtonClassStruct_Set() error {
	var err error
	radioButtonClassStruct_Once.Do(func() {
		radioButtonClassStruct, err = gi.StructNew("Gtk", "RadioButtonClass")
	})
	return err
}

type RadioButtonClass struct {
	native unsafe.Pointer
}

func RadioButtonClassNewFromNative(native unsafe.Pointer) *RadioButtonClass {
	err := radioButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioButtonClass{native: native}

	return instance
}

/*
CastToRadioButtonClass down casts any arbitrary Object to RadioButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioButtonClass.
*/
func CastToRadioButtonClass(object *gobject.Object) *RadioButtonClass {
	return RadioButtonClassNewFromNative(object.Native())
}

// Equals compares this RadioButtonClass with another RadioButtonClass, and returns true if they represent the same Object.
func (recv *RadioButtonClass) Equals(other *RadioButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RadioButtonClass) FieldParentClass() *CheckButtonClass {
	argValue := gi.StructFieldGet(radioButtonClassStruct, recv.Native(), "parent_class")
	value := CheckButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RadioButtonClass) SetFieldParentClass(value *CheckButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(radioButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'group_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'group_changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// RadioButtonClassStruct creates an uninitialised RadioButtonClass.
func RadioButtonClassStruct() *RadioButtonClass {
	err := radioButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioButtonClassNewFromNative(radioButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioButtonClass)
	return structGo
}
func finalizeRadioButtonClass(obj *RadioButtonClass) {
	radioButtonClassStruct.Free(obj.Native())
}

var radioButtonPrivateStruct *gi.Struct
var radioButtonPrivateStruct_Once sync.Once

func radioButtonPrivateStruct_Set() error {
	var err error
	radioButtonPrivateStruct_Once.Do(func() {
		radioButtonPrivateStruct, err = gi.StructNew("Gtk", "RadioButtonPrivate")
	})
	return err
}

type RadioButtonPrivate struct {
	native unsafe.Pointer
}

func RadioButtonPrivateNewFromNative(native unsafe.Pointer) *RadioButtonPrivate {
	err := radioButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioButtonPrivate{native: native}

	return instance
}

/*
CastToRadioButtonPrivate down casts any arbitrary Object to RadioButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioButtonPrivate.
*/
func CastToRadioButtonPrivate(object *gobject.Object) *RadioButtonPrivate {
	return RadioButtonPrivateNewFromNative(object.Native())
}

// Equals compares this RadioButtonPrivate with another RadioButtonPrivate, and returns true if they represent the same Object.
func (recv *RadioButtonPrivate) Equals(other *RadioButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// RadioButtonPrivateStruct creates an uninitialised RadioButtonPrivate.
func RadioButtonPrivateStruct() *RadioButtonPrivate {
	err := radioButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioButtonPrivateNewFromNative(radioButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioButtonPrivate)
	return structGo
}
func finalizeRadioButtonPrivate(obj *RadioButtonPrivate) {
	radioButtonPrivateStruct.Free(obj.Native())
}

var radioMenuItemAccessibleClassStruct *gi.Struct
var radioMenuItemAccessibleClassStruct_Once sync.Once

func radioMenuItemAccessibleClassStruct_Set() error {
	var err error
	radioMenuItemAccessibleClassStruct_Once.Do(func() {
		radioMenuItemAccessibleClassStruct, err = gi.StructNew("Gtk", "RadioMenuItemAccessibleClass")
	})
	return err
}

type RadioMenuItemAccessibleClass struct {
	native unsafe.Pointer
}

func RadioMenuItemAccessibleClassNewFromNative(native unsafe.Pointer) *RadioMenuItemAccessibleClass {
	err := radioMenuItemAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioMenuItemAccessibleClass{native: native}

	return instance
}

/*
CastToRadioMenuItemAccessibleClass down casts any arbitrary Object to RadioMenuItemAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioMenuItemAccessibleClass.
*/
func CastToRadioMenuItemAccessibleClass(object *gobject.Object) *RadioMenuItemAccessibleClass {
	return RadioMenuItemAccessibleClassNewFromNative(object.Native())
}

// Equals compares this RadioMenuItemAccessibleClass with another RadioMenuItemAccessibleClass, and returns true if they represent the same Object.
func (recv *RadioMenuItemAccessibleClass) Equals(other *RadioMenuItemAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioMenuItemAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RadioMenuItemAccessibleClass) FieldParentClass() *CheckMenuItemAccessibleClass {
	argValue := gi.StructFieldGet(radioMenuItemAccessibleClassStruct, recv.Native(), "parent_class")
	value := CheckMenuItemAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RadioMenuItemAccessibleClass) SetFieldParentClass(value *CheckMenuItemAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(radioMenuItemAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// RadioMenuItemAccessibleClassStruct creates an uninitialised RadioMenuItemAccessibleClass.
func RadioMenuItemAccessibleClassStruct() *RadioMenuItemAccessibleClass {
	err := radioMenuItemAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioMenuItemAccessibleClassNewFromNative(radioMenuItemAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioMenuItemAccessibleClass)
	return structGo
}
func finalizeRadioMenuItemAccessibleClass(obj *RadioMenuItemAccessibleClass) {
	radioMenuItemAccessibleClassStruct.Free(obj.Native())
}

var radioMenuItemAccessiblePrivateStruct *gi.Struct
var radioMenuItemAccessiblePrivateStruct_Once sync.Once

func radioMenuItemAccessiblePrivateStruct_Set() error {
	var err error
	radioMenuItemAccessiblePrivateStruct_Once.Do(func() {
		radioMenuItemAccessiblePrivateStruct, err = gi.StructNew("Gtk", "RadioMenuItemAccessiblePrivate")
	})
	return err
}

type RadioMenuItemAccessiblePrivate struct {
	native unsafe.Pointer
}

func RadioMenuItemAccessiblePrivateNewFromNative(native unsafe.Pointer) *RadioMenuItemAccessiblePrivate {
	err := radioMenuItemAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioMenuItemAccessiblePrivate{native: native}

	return instance
}

/*
CastToRadioMenuItemAccessiblePrivate down casts any arbitrary Object to RadioMenuItemAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioMenuItemAccessiblePrivate.
*/
func CastToRadioMenuItemAccessiblePrivate(object *gobject.Object) *RadioMenuItemAccessiblePrivate {
	return RadioMenuItemAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this RadioMenuItemAccessiblePrivate with another RadioMenuItemAccessiblePrivate, and returns true if they represent the same Object.
func (recv *RadioMenuItemAccessiblePrivate) Equals(other *RadioMenuItemAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioMenuItemAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// RadioMenuItemAccessiblePrivateStruct creates an uninitialised RadioMenuItemAccessiblePrivate.
func RadioMenuItemAccessiblePrivateStruct() *RadioMenuItemAccessiblePrivate {
	err := radioMenuItemAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioMenuItemAccessiblePrivateNewFromNative(radioMenuItemAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioMenuItemAccessiblePrivate)
	return structGo
}
func finalizeRadioMenuItemAccessiblePrivate(obj *RadioMenuItemAccessiblePrivate) {
	radioMenuItemAccessiblePrivateStruct.Free(obj.Native())
}

var radioMenuItemClassStruct *gi.Struct
var radioMenuItemClassStruct_Once sync.Once

func radioMenuItemClassStruct_Set() error {
	var err error
	radioMenuItemClassStruct_Once.Do(func() {
		radioMenuItemClassStruct, err = gi.StructNew("Gtk", "RadioMenuItemClass")
	})
	return err
}

type RadioMenuItemClass struct {
	native unsafe.Pointer
}

func RadioMenuItemClassNewFromNative(native unsafe.Pointer) *RadioMenuItemClass {
	err := radioMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioMenuItemClass{native: native}

	return instance
}

/*
CastToRadioMenuItemClass down casts any arbitrary Object to RadioMenuItemClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioMenuItemClass.
*/
func CastToRadioMenuItemClass(object *gobject.Object) *RadioMenuItemClass {
	return RadioMenuItemClassNewFromNative(object.Native())
}

// Equals compares this RadioMenuItemClass with another RadioMenuItemClass, and returns true if they represent the same Object.
func (recv *RadioMenuItemClass) Equals(other *RadioMenuItemClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioMenuItemClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RadioMenuItemClass) FieldParentClass() *CheckMenuItemClass {
	argValue := gi.StructFieldGet(radioMenuItemClassStruct, recv.Native(), "parent_class")
	value := CheckMenuItemClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RadioMenuItemClass) SetFieldParentClass(value *CheckMenuItemClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(radioMenuItemClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'group_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'group_changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// RadioMenuItemClassStruct creates an uninitialised RadioMenuItemClass.
func RadioMenuItemClassStruct() *RadioMenuItemClass {
	err := radioMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioMenuItemClassNewFromNative(radioMenuItemClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioMenuItemClass)
	return structGo
}
func finalizeRadioMenuItemClass(obj *RadioMenuItemClass) {
	radioMenuItemClassStruct.Free(obj.Native())
}

var radioMenuItemPrivateStruct *gi.Struct
var radioMenuItemPrivateStruct_Once sync.Once

func radioMenuItemPrivateStruct_Set() error {
	var err error
	radioMenuItemPrivateStruct_Once.Do(func() {
		radioMenuItemPrivateStruct, err = gi.StructNew("Gtk", "RadioMenuItemPrivate")
	})
	return err
}

type RadioMenuItemPrivate struct {
	native unsafe.Pointer
}

func RadioMenuItemPrivateNewFromNative(native unsafe.Pointer) *RadioMenuItemPrivate {
	err := radioMenuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioMenuItemPrivate{native: native}

	return instance
}

/*
CastToRadioMenuItemPrivate down casts any arbitrary Object to RadioMenuItemPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioMenuItemPrivate.
*/
func CastToRadioMenuItemPrivate(object *gobject.Object) *RadioMenuItemPrivate {
	return RadioMenuItemPrivateNewFromNative(object.Native())
}

// Equals compares this RadioMenuItemPrivate with another RadioMenuItemPrivate, and returns true if they represent the same Object.
func (recv *RadioMenuItemPrivate) Equals(other *RadioMenuItemPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioMenuItemPrivate) Native() unsafe.Pointer {
	return recv.native
}

// RadioMenuItemPrivateStruct creates an uninitialised RadioMenuItemPrivate.
func RadioMenuItemPrivateStruct() *RadioMenuItemPrivate {
	err := radioMenuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioMenuItemPrivateNewFromNative(radioMenuItemPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioMenuItemPrivate)
	return structGo
}
func finalizeRadioMenuItemPrivate(obj *RadioMenuItemPrivate) {
	radioMenuItemPrivateStruct.Free(obj.Native())
}

var radioToolButtonClassStruct *gi.Struct
var radioToolButtonClassStruct_Once sync.Once

func radioToolButtonClassStruct_Set() error {
	var err error
	radioToolButtonClassStruct_Once.Do(func() {
		radioToolButtonClassStruct, err = gi.StructNew("Gtk", "RadioToolButtonClass")
	})
	return err
}

type RadioToolButtonClass struct {
	native unsafe.Pointer
}

func RadioToolButtonClassNewFromNative(native unsafe.Pointer) *RadioToolButtonClass {
	err := radioToolButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RadioToolButtonClass{native: native}

	return instance
}

/*
CastToRadioToolButtonClass down casts any arbitrary Object to RadioToolButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RadioToolButtonClass.
*/
func CastToRadioToolButtonClass(object *gobject.Object) *RadioToolButtonClass {
	return RadioToolButtonClassNewFromNative(object.Native())
}

// Equals compares this RadioToolButtonClass with another RadioToolButtonClass, and returns true if they represent the same Object.
func (recv *RadioToolButtonClass) Equals(other *RadioToolButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RadioToolButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RadioToolButtonClass) FieldParentClass() *ToggleToolButtonClass {
	argValue := gi.StructFieldGet(radioToolButtonClassStruct, recv.Native(), "parent_class")
	value := ToggleToolButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RadioToolButtonClass) SetFieldParentClass(value *ToggleToolButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(radioToolButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// RadioToolButtonClassStruct creates an uninitialised RadioToolButtonClass.
func RadioToolButtonClassStruct() *RadioToolButtonClass {
	err := radioToolButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RadioToolButtonClassNewFromNative(radioToolButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRadioToolButtonClass)
	return structGo
}
func finalizeRadioToolButtonClass(obj *RadioToolButtonClass) {
	radioToolButtonClassStruct.Free(obj.Native())
}

var rangeAccessibleClassStruct *gi.Struct
var rangeAccessibleClassStruct_Once sync.Once

func rangeAccessibleClassStruct_Set() error {
	var err error
	rangeAccessibleClassStruct_Once.Do(func() {
		rangeAccessibleClassStruct, err = gi.StructNew("Gtk", "RangeAccessibleClass")
	})
	return err
}

type RangeAccessibleClass struct {
	native unsafe.Pointer
}

func RangeAccessibleClassNewFromNative(native unsafe.Pointer) *RangeAccessibleClass {
	err := rangeAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RangeAccessibleClass{native: native}

	return instance
}

/*
CastToRangeAccessibleClass down casts any arbitrary Object to RangeAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RangeAccessibleClass.
*/
func CastToRangeAccessibleClass(object *gobject.Object) *RangeAccessibleClass {
	return RangeAccessibleClassNewFromNative(object.Native())
}

// Equals compares this RangeAccessibleClass with another RangeAccessibleClass, and returns true if they represent the same Object.
func (recv *RangeAccessibleClass) Equals(other *RangeAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RangeAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RangeAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(rangeAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RangeAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(rangeAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// RangeAccessibleClassStruct creates an uninitialised RangeAccessibleClass.
func RangeAccessibleClassStruct() *RangeAccessibleClass {
	err := rangeAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RangeAccessibleClassNewFromNative(rangeAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRangeAccessibleClass)
	return structGo
}
func finalizeRangeAccessibleClass(obj *RangeAccessibleClass) {
	rangeAccessibleClassStruct.Free(obj.Native())
}

var rangeAccessiblePrivateStruct *gi.Struct
var rangeAccessiblePrivateStruct_Once sync.Once

func rangeAccessiblePrivateStruct_Set() error {
	var err error
	rangeAccessiblePrivateStruct_Once.Do(func() {
		rangeAccessiblePrivateStruct, err = gi.StructNew("Gtk", "RangeAccessiblePrivate")
	})
	return err
}

type RangeAccessiblePrivate struct {
	native unsafe.Pointer
}

func RangeAccessiblePrivateNewFromNative(native unsafe.Pointer) *RangeAccessiblePrivate {
	err := rangeAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RangeAccessiblePrivate{native: native}

	return instance
}

/*
CastToRangeAccessiblePrivate down casts any arbitrary Object to RangeAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RangeAccessiblePrivate.
*/
func CastToRangeAccessiblePrivate(object *gobject.Object) *RangeAccessiblePrivate {
	return RangeAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this RangeAccessiblePrivate with another RangeAccessiblePrivate, and returns true if they represent the same Object.
func (recv *RangeAccessiblePrivate) Equals(other *RangeAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RangeAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// RangeAccessiblePrivateStruct creates an uninitialised RangeAccessiblePrivate.
func RangeAccessiblePrivateStruct() *RangeAccessiblePrivate {
	err := rangeAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RangeAccessiblePrivateNewFromNative(rangeAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRangeAccessiblePrivate)
	return structGo
}
func finalizeRangeAccessiblePrivate(obj *RangeAccessiblePrivate) {
	rangeAccessiblePrivateStruct.Free(obj.Native())
}

var rangeClassStruct *gi.Struct
var rangeClassStruct_Once sync.Once

func rangeClassStruct_Set() error {
	var err error
	rangeClassStruct_Once.Do(func() {
		rangeClassStruct, err = gi.StructNew("Gtk", "RangeClass")
	})
	return err
}

type RangeClass struct {
	native unsafe.Pointer
}

func RangeClassNewFromNative(native unsafe.Pointer) *RangeClass {
	err := rangeClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RangeClass{native: native}

	return instance
}

/*
CastToRangeClass down casts any arbitrary Object to RangeClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RangeClass.
*/
func CastToRangeClass(object *gobject.Object) *RangeClass {
	return RangeClassNewFromNative(object.Native())
}

// Equals compares this RangeClass with another RangeClass, and returns true if they represent the same Object.
func (recv *RangeClass) Equals(other *RangeClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RangeClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RangeClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(rangeClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RangeClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(rangeClassStruct, recv.Native(), "parent_class", argValue)
}

// FieldSliderDetail returns the C field 'slider_detail'.
func (recv *RangeClass) FieldSliderDetail() string {
	argValue := gi.StructFieldGet(rangeClassStruct, recv.Native(), "slider_detail")
	value := argValue.String(false)
	return value
}

// SetFieldSliderDetail sets the value of the C field 'slider_detail'.
func (recv *RangeClass) SetFieldSliderDetail(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(rangeClassStruct, recv.Native(), "slider_detail", argValue)
}

// FieldStepperDetail returns the C field 'stepper_detail'.
func (recv *RangeClass) FieldStepperDetail() string {
	argValue := gi.StructFieldGet(rangeClassStruct, recv.Native(), "stepper_detail")
	value := argValue.String(false)
	return value
}

// SetFieldStepperDetail sets the value of the C field 'stepper_detail'.
func (recv *RangeClass) SetFieldStepperDetail(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(rangeClassStruct, recv.Native(), "stepper_detail", argValue)
}

// UNSUPPORTED : C value 'value_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'value_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'adjust_bounds' : for field getter : missing Type

// UNSUPPORTED : C value 'adjust_bounds' : for field setter : missing Type

// UNSUPPORTED : C value 'move_slider' : for field getter : missing Type

// UNSUPPORTED : C value 'move_slider' : for field setter : missing Type

// UNSUPPORTED : C value 'get_range_border' : for field getter : missing Type

// UNSUPPORTED : C value 'get_range_border' : for field setter : missing Type

// UNSUPPORTED : C value 'change_value' : for field getter : missing Type

// UNSUPPORTED : C value 'change_value' : for field setter : missing Type

// UNSUPPORTED : C value 'get_range_size_request' : for field getter : missing Type

// UNSUPPORTED : C value 'get_range_size_request' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// RangeClassStruct creates an uninitialised RangeClass.
func RangeClassStruct() *RangeClass {
	err := rangeClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RangeClassNewFromNative(rangeClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRangeClass)
	return structGo
}
func finalizeRangeClass(obj *RangeClass) {
	rangeClassStruct.Free(obj.Native())
}

var rangePrivateStruct *gi.Struct
var rangePrivateStruct_Once sync.Once

func rangePrivateStruct_Set() error {
	var err error
	rangePrivateStruct_Once.Do(func() {
		rangePrivateStruct, err = gi.StructNew("Gtk", "RangePrivate")
	})
	return err
}

type RangePrivate struct {
	native unsafe.Pointer
}

func RangePrivateNewFromNative(native unsafe.Pointer) *RangePrivate {
	err := rangePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RangePrivate{native: native}

	return instance
}

/*
CastToRangePrivate down casts any arbitrary Object to RangePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RangePrivate.
*/
func CastToRangePrivate(object *gobject.Object) *RangePrivate {
	return RangePrivateNewFromNative(object.Native())
}

// Equals compares this RangePrivate with another RangePrivate, and returns true if they represent the same Object.
func (recv *RangePrivate) Equals(other *RangePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RangePrivate) Native() unsafe.Pointer {
	return recv.native
}

// RangePrivateStruct creates an uninitialised RangePrivate.
func RangePrivateStruct() *RangePrivate {
	err := rangePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RangePrivateNewFromNative(rangePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRangePrivate)
	return structGo
}
func finalizeRangePrivate(obj *RangePrivate) {
	rangePrivateStruct.Free(obj.Native())
}

var rcContextStruct *gi.Struct
var rcContextStruct_Once sync.Once

func rcContextStruct_Set() error {
	var err error
	rcContextStruct_Once.Do(func() {
		rcContextStruct, err = gi.StructNew("Gtk", "RcContext")
	})
	return err
}

type RcContext struct {
	native unsafe.Pointer
}

func RcContextNewFromNative(native unsafe.Pointer) *RcContext {
	err := rcContextStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RcContext{native: native}

	return instance
}

/*
CastToRcContext down casts any arbitrary Object to RcContext.
Exercise care, as this is a potentially dangerous function
if the Object is not a RcContext.
*/
func CastToRcContext(object *gobject.Object) *RcContext {
	return RcContextNewFromNative(object.Native())
}

// Equals compares this RcContext with another RcContext, and returns true if they represent the same Object.
func (recv *RcContext) Equals(other *RcContext) bool {
	return other.Native() == recv.Native()
}

func (recv *RcContext) Native() unsafe.Pointer {
	return recv.native
}

// RcContextStruct creates an uninitialised RcContext.
func RcContextStruct() *RcContext {
	err := rcContextStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RcContextNewFromNative(rcContextStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRcContext)
	return structGo
}
func finalizeRcContext(obj *RcContext) {
	rcContextStruct.Free(obj.Native())
}

var rcPropertyStruct *gi.Struct
var rcPropertyStruct_Once sync.Once

func rcPropertyStruct_Set() error {
	var err error
	rcPropertyStruct_Once.Do(func() {
		rcPropertyStruct, err = gi.StructNew("Gtk", "RcProperty")
	})
	return err
}

type RcProperty struct {
	native unsafe.Pointer
}

func RcPropertyNewFromNative(native unsafe.Pointer) *RcProperty {
	err := rcPropertyStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RcProperty{native: native}

	return instance
}

/*
CastToRcProperty down casts any arbitrary Object to RcProperty.
Exercise care, as this is a potentially dangerous function
if the Object is not a RcProperty.
*/
func CastToRcProperty(object *gobject.Object) *RcProperty {
	return RcPropertyNewFromNative(object.Native())
}

// Equals compares this RcProperty with another RcProperty, and returns true if they represent the same Object.
func (recv *RcProperty) Equals(other *RcProperty) bool {
	return other.Native() == recv.Native()
}

func (recv *RcProperty) Native() unsafe.Pointer {
	return recv.native
}

// FieldTypeName returns the C field 'type_name'.
func (recv *RcProperty) FieldTypeName() glib.Quark {
	argValue := gi.StructFieldGet(rcPropertyStruct, recv.Native(), "type_name")
	value := glib.Quark(argValue.Uint32())
	return value
}

// SetFieldTypeName sets the value of the C field 'type_name'.
func (recv *RcProperty) SetFieldTypeName(value glib.Quark) {
	var argValue gi.Argument
	argValue.SetUint32(uint32(value))
	gi.StructFieldSet(rcPropertyStruct, recv.Native(), "type_name", argValue)
}

// FieldPropertyName returns the C field 'property_name'.
func (recv *RcProperty) FieldPropertyName() glib.Quark {
	argValue := gi.StructFieldGet(rcPropertyStruct, recv.Native(), "property_name")
	value := glib.Quark(argValue.Uint32())
	return value
}

// SetFieldPropertyName sets the value of the C field 'property_name'.
func (recv *RcProperty) SetFieldPropertyName(value glib.Quark) {
	var argValue gi.Argument
	argValue.SetUint32(uint32(value))
	gi.StructFieldSet(rcPropertyStruct, recv.Native(), "property_name", argValue)
}

// FieldOrigin returns the C field 'origin'.
func (recv *RcProperty) FieldOrigin() string {
	argValue := gi.StructFieldGet(rcPropertyStruct, recv.Native(), "origin")
	value := argValue.String(false)
	return value
}

// SetFieldOrigin sets the value of the C field 'origin'.
func (recv *RcProperty) SetFieldOrigin(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(rcPropertyStruct, recv.Native(), "origin", argValue)
}

// FieldValue returns the C field 'value'.
func (recv *RcProperty) FieldValue() *gobject.Value {
	argValue := gi.StructFieldGet(rcPropertyStruct, recv.Native(), "value")
	value := gobject.ValueNewFromNative(argValue.Pointer())
	return value
}

// SetFieldValue sets the value of the C field 'value'.
func (recv *RcProperty) SetFieldValue(value *gobject.Value) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(rcPropertyStruct, recv.Native(), "value", argValue)
}

// RcPropertyStruct creates an uninitialised RcProperty.
func RcPropertyStruct() *RcProperty {
	err := rcPropertyStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RcPropertyNewFromNative(rcPropertyStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRcProperty)
	return structGo
}
func finalizeRcProperty(obj *RcProperty) {
	rcPropertyStruct.Free(obj.Native())
}

var rcStyleClassStruct *gi.Struct
var rcStyleClassStruct_Once sync.Once

func rcStyleClassStruct_Set() error {
	var err error
	rcStyleClassStruct_Once.Do(func() {
		rcStyleClassStruct, err = gi.StructNew("Gtk", "RcStyleClass")
	})
	return err
}

type RcStyleClass struct {
	native unsafe.Pointer
}

func RcStyleClassNewFromNative(native unsafe.Pointer) *RcStyleClass {
	err := rcStyleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RcStyleClass{native: native}

	return instance
}

/*
CastToRcStyleClass down casts any arbitrary Object to RcStyleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RcStyleClass.
*/
func CastToRcStyleClass(object *gobject.Object) *RcStyleClass {
	return RcStyleClassNewFromNative(object.Native())
}

// Equals compares this RcStyleClass with another RcStyleClass, and returns true if they represent the same Object.
func (recv *RcStyleClass) Equals(other *RcStyleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RcStyleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RcStyleClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(rcStyleClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RcStyleClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(rcStyleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'create_rc_style' : for field getter : missing Type

// UNSUPPORTED : C value 'create_rc_style' : for field setter : missing Type

// UNSUPPORTED : C value 'parse' : for field getter : missing Type

// UNSUPPORTED : C value 'parse' : for field setter : missing Type

// UNSUPPORTED : C value 'merge' : for field getter : missing Type

// UNSUPPORTED : C value 'merge' : for field setter : missing Type

// UNSUPPORTED : C value 'create_style' : for field getter : missing Type

// UNSUPPORTED : C value 'create_style' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// RcStyleClassStruct creates an uninitialised RcStyleClass.
func RcStyleClassStruct() *RcStyleClass {
	err := rcStyleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RcStyleClassNewFromNative(rcStyleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRcStyleClass)
	return structGo
}
func finalizeRcStyleClass(obj *RcStyleClass) {
	rcStyleClassStruct.Free(obj.Native())
}

var recentActionClassStruct *gi.Struct
var recentActionClassStruct_Once sync.Once

func recentActionClassStruct_Set() error {
	var err error
	recentActionClassStruct_Once.Do(func() {
		recentActionClassStruct, err = gi.StructNew("Gtk", "RecentActionClass")
	})
	return err
}

type RecentActionClass struct {
	native unsafe.Pointer
}

func RecentActionClassNewFromNative(native unsafe.Pointer) *RecentActionClass {
	err := recentActionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentActionClass{native: native}

	return instance
}

/*
CastToRecentActionClass down casts any arbitrary Object to RecentActionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentActionClass.
*/
func CastToRecentActionClass(object *gobject.Object) *RecentActionClass {
	return RecentActionClassNewFromNative(object.Native())
}

// Equals compares this RecentActionClass with another RecentActionClass, and returns true if they represent the same Object.
func (recv *RecentActionClass) Equals(other *RecentActionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentActionClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RecentActionClass) FieldParentClass() *ActionClass {
	argValue := gi.StructFieldGet(recentActionClassStruct, recv.Native(), "parent_class")
	value := ActionClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RecentActionClass) SetFieldParentClass(value *ActionClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(recentActionClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// RecentActionClassStruct creates an uninitialised RecentActionClass.
func RecentActionClassStruct() *RecentActionClass {
	err := recentActionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentActionClassNewFromNative(recentActionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentActionClass)
	return structGo
}
func finalizeRecentActionClass(obj *RecentActionClass) {
	recentActionClassStruct.Free(obj.Native())
}

var recentActionPrivateStruct *gi.Struct
var recentActionPrivateStruct_Once sync.Once

func recentActionPrivateStruct_Set() error {
	var err error
	recentActionPrivateStruct_Once.Do(func() {
		recentActionPrivateStruct, err = gi.StructNew("Gtk", "RecentActionPrivate")
	})
	return err
}

type RecentActionPrivate struct {
	native unsafe.Pointer
}

func RecentActionPrivateNewFromNative(native unsafe.Pointer) *RecentActionPrivate {
	err := recentActionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentActionPrivate{native: native}

	return instance
}

/*
CastToRecentActionPrivate down casts any arbitrary Object to RecentActionPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentActionPrivate.
*/
func CastToRecentActionPrivate(object *gobject.Object) *RecentActionPrivate {
	return RecentActionPrivateNewFromNative(object.Native())
}

// Equals compares this RecentActionPrivate with another RecentActionPrivate, and returns true if they represent the same Object.
func (recv *RecentActionPrivate) Equals(other *RecentActionPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentActionPrivate) Native() unsafe.Pointer {
	return recv.native
}

// RecentActionPrivateStruct creates an uninitialised RecentActionPrivate.
func RecentActionPrivateStruct() *RecentActionPrivate {
	err := recentActionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentActionPrivateNewFromNative(recentActionPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentActionPrivate)
	return structGo
}
func finalizeRecentActionPrivate(obj *RecentActionPrivate) {
	recentActionPrivateStruct.Free(obj.Native())
}

var recentChooserDialogClassStruct *gi.Struct
var recentChooserDialogClassStruct_Once sync.Once

func recentChooserDialogClassStruct_Set() error {
	var err error
	recentChooserDialogClassStruct_Once.Do(func() {
		recentChooserDialogClassStruct, err = gi.StructNew("Gtk", "RecentChooserDialogClass")
	})
	return err
}

type RecentChooserDialogClass struct {
	native unsafe.Pointer
}

func RecentChooserDialogClassNewFromNative(native unsafe.Pointer) *RecentChooserDialogClass {
	err := recentChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentChooserDialogClass{native: native}

	return instance
}

/*
CastToRecentChooserDialogClass down casts any arbitrary Object to RecentChooserDialogClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentChooserDialogClass.
*/
func CastToRecentChooserDialogClass(object *gobject.Object) *RecentChooserDialogClass {
	return RecentChooserDialogClassNewFromNative(object.Native())
}

// Equals compares this RecentChooserDialogClass with another RecentChooserDialogClass, and returns true if they represent the same Object.
func (recv *RecentChooserDialogClass) Equals(other *RecentChooserDialogClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentChooserDialogClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RecentChooserDialogClass) FieldParentClass() *DialogClass {
	argValue := gi.StructFieldGet(recentChooserDialogClassStruct, recv.Native(), "parent_class")
	value := DialogClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RecentChooserDialogClass) SetFieldParentClass(value *DialogClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(recentChooserDialogClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// RecentChooserDialogClassStruct creates an uninitialised RecentChooserDialogClass.
func RecentChooserDialogClassStruct() *RecentChooserDialogClass {
	err := recentChooserDialogClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentChooserDialogClassNewFromNative(recentChooserDialogClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentChooserDialogClass)
	return structGo
}
func finalizeRecentChooserDialogClass(obj *RecentChooserDialogClass) {
	recentChooserDialogClassStruct.Free(obj.Native())
}

var recentChooserDialogPrivateStruct *gi.Struct
var recentChooserDialogPrivateStruct_Once sync.Once

func recentChooserDialogPrivateStruct_Set() error {
	var err error
	recentChooserDialogPrivateStruct_Once.Do(func() {
		recentChooserDialogPrivateStruct, err = gi.StructNew("Gtk", "RecentChooserDialogPrivate")
	})
	return err
}

type RecentChooserDialogPrivate struct {
	native unsafe.Pointer
}

func RecentChooserDialogPrivateNewFromNative(native unsafe.Pointer) *RecentChooserDialogPrivate {
	err := recentChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentChooserDialogPrivate{native: native}

	return instance
}

/*
CastToRecentChooserDialogPrivate down casts any arbitrary Object to RecentChooserDialogPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentChooserDialogPrivate.
*/
func CastToRecentChooserDialogPrivate(object *gobject.Object) *RecentChooserDialogPrivate {
	return RecentChooserDialogPrivateNewFromNative(object.Native())
}

// Equals compares this RecentChooserDialogPrivate with another RecentChooserDialogPrivate, and returns true if they represent the same Object.
func (recv *RecentChooserDialogPrivate) Equals(other *RecentChooserDialogPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentChooserDialogPrivate) Native() unsafe.Pointer {
	return recv.native
}

// RecentChooserDialogPrivateStruct creates an uninitialised RecentChooserDialogPrivate.
func RecentChooserDialogPrivateStruct() *RecentChooserDialogPrivate {
	err := recentChooserDialogPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentChooserDialogPrivateNewFromNative(recentChooserDialogPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentChooserDialogPrivate)
	return structGo
}
func finalizeRecentChooserDialogPrivate(obj *RecentChooserDialogPrivate) {
	recentChooserDialogPrivateStruct.Free(obj.Native())
}

var recentChooserIfaceStruct *gi.Struct
var recentChooserIfaceStruct_Once sync.Once

func recentChooserIfaceStruct_Set() error {
	var err error
	recentChooserIfaceStruct_Once.Do(func() {
		recentChooserIfaceStruct, err = gi.StructNew("Gtk", "RecentChooserIface")
	})
	return err
}

type RecentChooserIface struct {
	native unsafe.Pointer
}

func RecentChooserIfaceNewFromNative(native unsafe.Pointer) *RecentChooserIface {
	err := recentChooserIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentChooserIface{native: native}

	return instance
}

/*
CastToRecentChooserIface down casts any arbitrary Object to RecentChooserIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentChooserIface.
*/
func CastToRecentChooserIface(object *gobject.Object) *RecentChooserIface {
	return RecentChooserIfaceNewFromNative(object.Native())
}

// Equals compares this RecentChooserIface with another RecentChooserIface, and returns true if they represent the same Object.
func (recv *RecentChooserIface) Equals(other *RecentChooserIface) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentChooserIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'set_current_uri' : for field getter : missing Type

// UNSUPPORTED : C value 'set_current_uri' : for field setter : missing Type

// UNSUPPORTED : C value 'get_current_uri' : for field getter : missing Type

// UNSUPPORTED : C value 'get_current_uri' : for field setter : missing Type

// UNSUPPORTED : C value 'select_uri' : for field getter : missing Type

// UNSUPPORTED : C value 'select_uri' : for field setter : missing Type

// UNSUPPORTED : C value 'unselect_uri' : for field getter : missing Type

// UNSUPPORTED : C value 'unselect_uri' : for field setter : missing Type

// UNSUPPORTED : C value 'select_all' : for field getter : missing Type

// UNSUPPORTED : C value 'select_all' : for field setter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field getter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field setter : missing Type

// UNSUPPORTED : C value 'get_items' : for field getter : missing Type

// UNSUPPORTED : C value 'get_items' : for field setter : missing Type

// UNSUPPORTED : C value 'get_recent_manager' : for field getter : missing Type

// UNSUPPORTED : C value 'get_recent_manager' : for field setter : missing Type

// UNSUPPORTED : C value 'add_filter' : for field getter : missing Type

// UNSUPPORTED : C value 'add_filter' : for field setter : missing Type

// UNSUPPORTED : C value 'remove_filter' : for field getter : missing Type

// UNSUPPORTED : C value 'remove_filter' : for field setter : missing Type

// UNSUPPORTED : C value 'list_filters' : for field getter : missing Type

// UNSUPPORTED : C value 'list_filters' : for field setter : missing Type

// UNSUPPORTED : C value 'set_sort_func' : for field getter : missing Type

// UNSUPPORTED : C value 'set_sort_func' : for field setter : missing Type

// UNSUPPORTED : C value 'item_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'item_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'selection_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'selection_changed' : for field setter : missing Type

// RecentChooserIfaceStruct creates an uninitialised RecentChooserIface.
func RecentChooserIfaceStruct() *RecentChooserIface {
	err := recentChooserIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentChooserIfaceNewFromNative(recentChooserIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentChooserIface)
	return structGo
}
func finalizeRecentChooserIface(obj *RecentChooserIface) {
	recentChooserIfaceStruct.Free(obj.Native())
}

var recentChooserMenuClassStruct *gi.Struct
var recentChooserMenuClassStruct_Once sync.Once

func recentChooserMenuClassStruct_Set() error {
	var err error
	recentChooserMenuClassStruct_Once.Do(func() {
		recentChooserMenuClassStruct, err = gi.StructNew("Gtk", "RecentChooserMenuClass")
	})
	return err
}

type RecentChooserMenuClass struct {
	native unsafe.Pointer
}

func RecentChooserMenuClassNewFromNative(native unsafe.Pointer) *RecentChooserMenuClass {
	err := recentChooserMenuClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentChooserMenuClass{native: native}

	return instance
}

/*
CastToRecentChooserMenuClass down casts any arbitrary Object to RecentChooserMenuClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentChooserMenuClass.
*/
func CastToRecentChooserMenuClass(object *gobject.Object) *RecentChooserMenuClass {
	return RecentChooserMenuClassNewFromNative(object.Native())
}

// Equals compares this RecentChooserMenuClass with another RecentChooserMenuClass, and returns true if they represent the same Object.
func (recv *RecentChooserMenuClass) Equals(other *RecentChooserMenuClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentChooserMenuClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RecentChooserMenuClass) FieldParentClass() *MenuClass {
	argValue := gi.StructFieldGet(recentChooserMenuClassStruct, recv.Native(), "parent_class")
	value := MenuClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RecentChooserMenuClass) SetFieldParentClass(value *MenuClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(recentChooserMenuClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'gtk_recent1' : for field getter : missing Type

// UNSUPPORTED : C value 'gtk_recent1' : for field setter : missing Type

// UNSUPPORTED : C value 'gtk_recent2' : for field getter : missing Type

// UNSUPPORTED : C value 'gtk_recent2' : for field setter : missing Type

// UNSUPPORTED : C value 'gtk_recent3' : for field getter : missing Type

// UNSUPPORTED : C value 'gtk_recent3' : for field setter : missing Type

// UNSUPPORTED : C value 'gtk_recent4' : for field getter : missing Type

// UNSUPPORTED : C value 'gtk_recent4' : for field setter : missing Type

// RecentChooserMenuClassStruct creates an uninitialised RecentChooserMenuClass.
func RecentChooserMenuClassStruct() *RecentChooserMenuClass {
	err := recentChooserMenuClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentChooserMenuClassNewFromNative(recentChooserMenuClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentChooserMenuClass)
	return structGo
}
func finalizeRecentChooserMenuClass(obj *RecentChooserMenuClass) {
	recentChooserMenuClassStruct.Free(obj.Native())
}

var recentChooserMenuPrivateStruct *gi.Struct
var recentChooserMenuPrivateStruct_Once sync.Once

func recentChooserMenuPrivateStruct_Set() error {
	var err error
	recentChooserMenuPrivateStruct_Once.Do(func() {
		recentChooserMenuPrivateStruct, err = gi.StructNew("Gtk", "RecentChooserMenuPrivate")
	})
	return err
}

type RecentChooserMenuPrivate struct {
	native unsafe.Pointer
}

func RecentChooserMenuPrivateNewFromNative(native unsafe.Pointer) *RecentChooserMenuPrivate {
	err := recentChooserMenuPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentChooserMenuPrivate{native: native}

	return instance
}

/*
CastToRecentChooserMenuPrivate down casts any arbitrary Object to RecentChooserMenuPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentChooserMenuPrivate.
*/
func CastToRecentChooserMenuPrivate(object *gobject.Object) *RecentChooserMenuPrivate {
	return RecentChooserMenuPrivateNewFromNative(object.Native())
}

// Equals compares this RecentChooserMenuPrivate with another RecentChooserMenuPrivate, and returns true if they represent the same Object.
func (recv *RecentChooserMenuPrivate) Equals(other *RecentChooserMenuPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentChooserMenuPrivate) Native() unsafe.Pointer {
	return recv.native
}

// RecentChooserMenuPrivateStruct creates an uninitialised RecentChooserMenuPrivate.
func RecentChooserMenuPrivateStruct() *RecentChooserMenuPrivate {
	err := recentChooserMenuPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentChooserMenuPrivateNewFromNative(recentChooserMenuPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentChooserMenuPrivate)
	return structGo
}
func finalizeRecentChooserMenuPrivate(obj *RecentChooserMenuPrivate) {
	recentChooserMenuPrivateStruct.Free(obj.Native())
}

var recentChooserWidgetClassStruct *gi.Struct
var recentChooserWidgetClassStruct_Once sync.Once

func recentChooserWidgetClassStruct_Set() error {
	var err error
	recentChooserWidgetClassStruct_Once.Do(func() {
		recentChooserWidgetClassStruct, err = gi.StructNew("Gtk", "RecentChooserWidgetClass")
	})
	return err
}

type RecentChooserWidgetClass struct {
	native unsafe.Pointer
}

func RecentChooserWidgetClassNewFromNative(native unsafe.Pointer) *RecentChooserWidgetClass {
	err := recentChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentChooserWidgetClass{native: native}

	return instance
}

/*
CastToRecentChooserWidgetClass down casts any arbitrary Object to RecentChooserWidgetClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentChooserWidgetClass.
*/
func CastToRecentChooserWidgetClass(object *gobject.Object) *RecentChooserWidgetClass {
	return RecentChooserWidgetClassNewFromNative(object.Native())
}

// Equals compares this RecentChooserWidgetClass with another RecentChooserWidgetClass, and returns true if they represent the same Object.
func (recv *RecentChooserWidgetClass) Equals(other *RecentChooserWidgetClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentChooserWidgetClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RecentChooserWidgetClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(recentChooserWidgetClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RecentChooserWidgetClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(recentChooserWidgetClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// RecentChooserWidgetClassStruct creates an uninitialised RecentChooserWidgetClass.
func RecentChooserWidgetClassStruct() *RecentChooserWidgetClass {
	err := recentChooserWidgetClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentChooserWidgetClassNewFromNative(recentChooserWidgetClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentChooserWidgetClass)
	return structGo
}
func finalizeRecentChooserWidgetClass(obj *RecentChooserWidgetClass) {
	recentChooserWidgetClassStruct.Free(obj.Native())
}

var recentChooserWidgetPrivateStruct *gi.Struct
var recentChooserWidgetPrivateStruct_Once sync.Once

func recentChooserWidgetPrivateStruct_Set() error {
	var err error
	recentChooserWidgetPrivateStruct_Once.Do(func() {
		recentChooserWidgetPrivateStruct, err = gi.StructNew("Gtk", "RecentChooserWidgetPrivate")
	})
	return err
}

type RecentChooserWidgetPrivate struct {
	native unsafe.Pointer
}

func RecentChooserWidgetPrivateNewFromNative(native unsafe.Pointer) *RecentChooserWidgetPrivate {
	err := recentChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentChooserWidgetPrivate{native: native}

	return instance
}

/*
CastToRecentChooserWidgetPrivate down casts any arbitrary Object to RecentChooserWidgetPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentChooserWidgetPrivate.
*/
func CastToRecentChooserWidgetPrivate(object *gobject.Object) *RecentChooserWidgetPrivate {
	return RecentChooserWidgetPrivateNewFromNative(object.Native())
}

// Equals compares this RecentChooserWidgetPrivate with another RecentChooserWidgetPrivate, and returns true if they represent the same Object.
func (recv *RecentChooserWidgetPrivate) Equals(other *RecentChooserWidgetPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentChooserWidgetPrivate) Native() unsafe.Pointer {
	return recv.native
}

// RecentChooserWidgetPrivateStruct creates an uninitialised RecentChooserWidgetPrivate.
func RecentChooserWidgetPrivateStruct() *RecentChooserWidgetPrivate {
	err := recentChooserWidgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentChooserWidgetPrivateNewFromNative(recentChooserWidgetPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentChooserWidgetPrivate)
	return structGo
}
func finalizeRecentChooserWidgetPrivate(obj *RecentChooserWidgetPrivate) {
	recentChooserWidgetPrivateStruct.Free(obj.Native())
}

var recentDataStruct *gi.Struct
var recentDataStruct_Once sync.Once

func recentDataStruct_Set() error {
	var err error
	recentDataStruct_Once.Do(func() {
		recentDataStruct, err = gi.StructNew("Gtk", "RecentData")
	})
	return err
}

type RecentData struct {
	native unsafe.Pointer
}

func RecentDataNewFromNative(native unsafe.Pointer) *RecentData {
	err := recentDataStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentData{native: native}

	return instance
}

/*
CastToRecentData down casts any arbitrary Object to RecentData.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentData.
*/
func CastToRecentData(object *gobject.Object) *RecentData {
	return RecentDataNewFromNative(object.Native())
}

// Equals compares this RecentData with another RecentData, and returns true if they represent the same Object.
func (recv *RecentData) Equals(other *RecentData) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentData) Native() unsafe.Pointer {
	return recv.native
}

// FieldDisplayName returns the C field 'display_name'.
func (recv *RecentData) FieldDisplayName() string {
	argValue := gi.StructFieldGet(recentDataStruct, recv.Native(), "display_name")
	value := argValue.String(false)
	return value
}

// SetFieldDisplayName sets the value of the C field 'display_name'.
func (recv *RecentData) SetFieldDisplayName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(recentDataStruct, recv.Native(), "display_name", argValue)
}

// FieldDescription returns the C field 'description'.
func (recv *RecentData) FieldDescription() string {
	argValue := gi.StructFieldGet(recentDataStruct, recv.Native(), "description")
	value := argValue.String(false)
	return value
}

// SetFieldDescription sets the value of the C field 'description'.
func (recv *RecentData) SetFieldDescription(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(recentDataStruct, recv.Native(), "description", argValue)
}

// FieldMimeType returns the C field 'mime_type'.
func (recv *RecentData) FieldMimeType() string {
	argValue := gi.StructFieldGet(recentDataStruct, recv.Native(), "mime_type")
	value := argValue.String(false)
	return value
}

// SetFieldMimeType sets the value of the C field 'mime_type'.
func (recv *RecentData) SetFieldMimeType(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(recentDataStruct, recv.Native(), "mime_type", argValue)
}

// FieldAppName returns the C field 'app_name'.
func (recv *RecentData) FieldAppName() string {
	argValue := gi.StructFieldGet(recentDataStruct, recv.Native(), "app_name")
	value := argValue.String(false)
	return value
}

// SetFieldAppName sets the value of the C field 'app_name'.
func (recv *RecentData) SetFieldAppName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(recentDataStruct, recv.Native(), "app_name", argValue)
}

// FieldAppExec returns the C field 'app_exec'.
func (recv *RecentData) FieldAppExec() string {
	argValue := gi.StructFieldGet(recentDataStruct, recv.Native(), "app_exec")
	value := argValue.String(false)
	return value
}

// SetFieldAppExec sets the value of the C field 'app_exec'.
func (recv *RecentData) SetFieldAppExec(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(recentDataStruct, recv.Native(), "app_exec", argValue)
}

// UNSUPPORTED : C value 'groups' : for field getter : missing Type

// UNSUPPORTED : C value 'groups' : for field setter : missing Type

// FieldIsPrivate returns the C field 'is_private'.
func (recv *RecentData) FieldIsPrivate() bool {
	argValue := gi.StructFieldGet(recentDataStruct, recv.Native(), "is_private")
	value := argValue.Boolean()
	return value
}

// SetFieldIsPrivate sets the value of the C field 'is_private'.
func (recv *RecentData) SetFieldIsPrivate(value bool) {
	var argValue gi.Argument
	argValue.SetBoolean(value)
	gi.StructFieldSet(recentDataStruct, recv.Native(), "is_private", argValue)
}

// RecentDataStruct creates an uninitialised RecentData.
func RecentDataStruct() *RecentData {
	err := recentDataStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentDataNewFromNative(recentDataStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentData)
	return structGo
}
func finalizeRecentData(obj *RecentData) {
	recentDataStruct.Free(obj.Native())
}

var recentFilterInfoStruct *gi.Struct
var recentFilterInfoStruct_Once sync.Once

func recentFilterInfoStruct_Set() error {
	var err error
	recentFilterInfoStruct_Once.Do(func() {
		recentFilterInfoStruct, err = gi.StructNew("Gtk", "RecentFilterInfo")
	})
	return err
}

type RecentFilterInfo struct {
	native unsafe.Pointer
}

func RecentFilterInfoNewFromNative(native unsafe.Pointer) *RecentFilterInfo {
	err := recentFilterInfoStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentFilterInfo{native: native}

	return instance
}

/*
CastToRecentFilterInfo down casts any arbitrary Object to RecentFilterInfo.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentFilterInfo.
*/
func CastToRecentFilterInfo(object *gobject.Object) *RecentFilterInfo {
	return RecentFilterInfoNewFromNative(object.Native())
}

// Equals compares this RecentFilterInfo with another RecentFilterInfo, and returns true if they represent the same Object.
func (recv *RecentFilterInfo) Equals(other *RecentFilterInfo) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentFilterInfo) Native() unsafe.Pointer {
	return recv.native
}

// FieldContains returns the C field 'contains'.
func (recv *RecentFilterInfo) FieldContains() RecentFilterFlags {
	argValue := gi.StructFieldGet(recentFilterInfoStruct, recv.Native(), "contains")
	value := RecentFilterFlags(argValue.Int32())
	return value
}

// SetFieldContains sets the value of the C field 'contains'.
func (recv *RecentFilterInfo) SetFieldContains(value RecentFilterFlags) {
	var argValue gi.Argument
	argValue.SetInt32(int32(value))
	gi.StructFieldSet(recentFilterInfoStruct, recv.Native(), "contains", argValue)
}

// FieldUri returns the C field 'uri'.
func (recv *RecentFilterInfo) FieldUri() string {
	argValue := gi.StructFieldGet(recentFilterInfoStruct, recv.Native(), "uri")
	value := argValue.String(false)
	return value
}

// SetFieldUri sets the value of the C field 'uri'.
func (recv *RecentFilterInfo) SetFieldUri(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(recentFilterInfoStruct, recv.Native(), "uri", argValue)
}

// FieldDisplayName returns the C field 'display_name'.
func (recv *RecentFilterInfo) FieldDisplayName() string {
	argValue := gi.StructFieldGet(recentFilterInfoStruct, recv.Native(), "display_name")
	value := argValue.String(false)
	return value
}

// SetFieldDisplayName sets the value of the C field 'display_name'.
func (recv *RecentFilterInfo) SetFieldDisplayName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(recentFilterInfoStruct, recv.Native(), "display_name", argValue)
}

// FieldMimeType returns the C field 'mime_type'.
func (recv *RecentFilterInfo) FieldMimeType() string {
	argValue := gi.StructFieldGet(recentFilterInfoStruct, recv.Native(), "mime_type")
	value := argValue.String(false)
	return value
}

// SetFieldMimeType sets the value of the C field 'mime_type'.
func (recv *RecentFilterInfo) SetFieldMimeType(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(recentFilterInfoStruct, recv.Native(), "mime_type", argValue)
}

// UNSUPPORTED : C value 'applications' : for field getter : missing Type

// UNSUPPORTED : C value 'applications' : for field setter : missing Type

// UNSUPPORTED : C value 'groups' : for field getter : missing Type

// UNSUPPORTED : C value 'groups' : for field setter : missing Type

// FieldAge returns the C field 'age'.
func (recv *RecentFilterInfo) FieldAge() int32 {
	argValue := gi.StructFieldGet(recentFilterInfoStruct, recv.Native(), "age")
	value := argValue.Int32()
	return value
}

// SetFieldAge sets the value of the C field 'age'.
func (recv *RecentFilterInfo) SetFieldAge(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(recentFilterInfoStruct, recv.Native(), "age", argValue)
}

// RecentFilterInfoStruct creates an uninitialised RecentFilterInfo.
func RecentFilterInfoStruct() *RecentFilterInfo {
	err := recentFilterInfoStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentFilterInfoNewFromNative(recentFilterInfoStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentFilterInfo)
	return structGo
}
func finalizeRecentFilterInfo(obj *RecentFilterInfo) {
	recentFilterInfoStruct.Free(obj.Native())
}

var recentInfoStruct *gi.Struct
var recentInfoStruct_Once sync.Once

func recentInfoStruct_Set() error {
	var err error
	recentInfoStruct_Once.Do(func() {
		recentInfoStruct, err = gi.StructNew("Gtk", "RecentInfo")
	})
	return err
}

type RecentInfo struct {
	native unsafe.Pointer
}

func RecentInfoNewFromNative(native unsafe.Pointer) *RecentInfo {
	err := recentInfoStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentInfo{native: native}

	return instance
}

/*
CastToRecentInfo down casts any arbitrary Object to RecentInfo.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentInfo.
*/
func CastToRecentInfo(object *gobject.Object) *RecentInfo {
	return RecentInfoNewFromNative(object.Native())
}

// Equals compares this RecentInfo with another RecentInfo, and returns true if they represent the same Object.
func (recv *RecentInfo) Equals(other *RecentInfo) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentInfo) Native() unsafe.Pointer {
	return recv.native
}

var recentInfoCreateAppInfoFunction *gi.Function
var recentInfoCreateAppInfoFunction_Once sync.Once

func recentInfoCreateAppInfoFunction_Set() error {
	var err error
	recentInfoCreateAppInfoFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoCreateAppInfoFunction, err = recentInfoStruct.InvokerNew("create_app_info")
	})
	return err
}

// CreateAppInfo is a representation of the C type gtk_recent_info_create_app_info.
func (recv *RecentInfo) CreateAppInfo(appName string) *gio.AppInfo {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(appName)

	var ret gi.Argument

	err := recentInfoCreateAppInfoFunction_Set()
	if err == nil {
		ret = recentInfoCreateAppInfoFunction.Invoke(inArgs[:], nil)
	}

	retGo := gio.AppInfoNewFromNative(ret.Pointer())

	return retGo
}

var recentInfoExistsFunction *gi.Function
var recentInfoExistsFunction_Once sync.Once

func recentInfoExistsFunction_Set() error {
	var err error
	recentInfoExistsFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoExistsFunction, err = recentInfoStruct.InvokerNew("exists")
	})
	return err
}

// Exists is a representation of the C type gtk_recent_info_exists.
func (recv *RecentInfo) Exists() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoExistsFunction_Set()
	if err == nil {
		ret = recentInfoExistsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var recentInfoGetAddedFunction *gi.Function
var recentInfoGetAddedFunction_Once sync.Once

func recentInfoGetAddedFunction_Set() error {
	var err error
	recentInfoGetAddedFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetAddedFunction, err = recentInfoStruct.InvokerNew("get_added")
	})
	return err
}

// GetAdded is a representation of the C type gtk_recent_info_get_added.
func (recv *RecentInfo) GetAdded() int64 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetAddedFunction_Set()
	if err == nil {
		ret = recentInfoGetAddedFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int64()

	return retGo
}

var recentInfoGetAgeFunction *gi.Function
var recentInfoGetAgeFunction_Once sync.Once

func recentInfoGetAgeFunction_Set() error {
	var err error
	recentInfoGetAgeFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetAgeFunction, err = recentInfoStruct.InvokerNew("get_age")
	})
	return err
}

// GetAge is a representation of the C type gtk_recent_info_get_age.
func (recv *RecentInfo) GetAge() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetAgeFunction_Set()
	if err == nil {
		ret = recentInfoGetAgeFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var recentInfoGetApplicationInfoFunction *gi.Function
var recentInfoGetApplicationInfoFunction_Once sync.Once

func recentInfoGetApplicationInfoFunction_Set() error {
	var err error
	recentInfoGetApplicationInfoFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetApplicationInfoFunction, err = recentInfoStruct.InvokerNew("get_application_info")
	})
	return err
}

// GetApplicationInfo is a representation of the C type gtk_recent_info_get_application_info.
func (recv *RecentInfo) GetApplicationInfo(appName string) (bool, string, uint32, int64) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(appName)

	var outArgs [3]gi.Argument
	var ret gi.Argument

	err := recentInfoGetApplicationInfoFunction_Set()
	if err == nil {
		ret = recentInfoGetApplicationInfoFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := outArgs[0].String(false)
	out1 := outArgs[1].Uint32()
	out2 := outArgs[2].Int64()

	return retGo, out0, out1, out2
}

var recentInfoGetApplicationsFunction *gi.Function
var recentInfoGetApplicationsFunction_Once sync.Once

func recentInfoGetApplicationsFunction_Set() error {
	var err error
	recentInfoGetApplicationsFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetApplicationsFunction, err = recentInfoStruct.InvokerNew("get_applications")
	})
	return err
}

// GetApplications is a representation of the C type gtk_recent_info_get_applications.
func (recv *RecentInfo) GetApplications() uint64 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var outArgs [1]gi.Argument

	err := recentInfoGetApplicationsFunction_Set()
	if err == nil {
		recentInfoGetApplicationsFunction.Invoke(inArgs[:], outArgs[:])
	}

	out0 := outArgs[0].Uint64()

	return out0
}

var recentInfoGetDescriptionFunction *gi.Function
var recentInfoGetDescriptionFunction_Once sync.Once

func recentInfoGetDescriptionFunction_Set() error {
	var err error
	recentInfoGetDescriptionFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetDescriptionFunction, err = recentInfoStruct.InvokerNew("get_description")
	})
	return err
}

// GetDescription is a representation of the C type gtk_recent_info_get_description.
func (recv *RecentInfo) GetDescription() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetDescriptionFunction_Set()
	if err == nil {
		ret = recentInfoGetDescriptionFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var recentInfoGetDisplayNameFunction *gi.Function
var recentInfoGetDisplayNameFunction_Once sync.Once

func recentInfoGetDisplayNameFunction_Set() error {
	var err error
	recentInfoGetDisplayNameFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetDisplayNameFunction, err = recentInfoStruct.InvokerNew("get_display_name")
	})
	return err
}

// GetDisplayName is a representation of the C type gtk_recent_info_get_display_name.
func (recv *RecentInfo) GetDisplayName() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetDisplayNameFunction_Set()
	if err == nil {
		ret = recentInfoGetDisplayNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var recentInfoGetGiconFunction *gi.Function
var recentInfoGetGiconFunction_Once sync.Once

func recentInfoGetGiconFunction_Set() error {
	var err error
	recentInfoGetGiconFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetGiconFunction, err = recentInfoStruct.InvokerNew("get_gicon")
	})
	return err
}

// GetGicon is a representation of the C type gtk_recent_info_get_gicon.
func (recv *RecentInfo) GetGicon() *gio.Icon {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetGiconFunction_Set()
	if err == nil {
		ret = recentInfoGetGiconFunction.Invoke(inArgs[:], nil)
	}

	retGo := gio.IconNewFromNative(ret.Pointer())

	return retGo
}

var recentInfoGetGroupsFunction *gi.Function
var recentInfoGetGroupsFunction_Once sync.Once

func recentInfoGetGroupsFunction_Set() error {
	var err error
	recentInfoGetGroupsFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetGroupsFunction, err = recentInfoStruct.InvokerNew("get_groups")
	})
	return err
}

// GetGroups is a representation of the C type gtk_recent_info_get_groups.
func (recv *RecentInfo) GetGroups() uint64 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var outArgs [1]gi.Argument

	err := recentInfoGetGroupsFunction_Set()
	if err == nil {
		recentInfoGetGroupsFunction.Invoke(inArgs[:], outArgs[:])
	}

	out0 := outArgs[0].Uint64()

	return out0
}

var recentInfoGetIconFunction *gi.Function
var recentInfoGetIconFunction_Once sync.Once

func recentInfoGetIconFunction_Set() error {
	var err error
	recentInfoGetIconFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetIconFunction, err = recentInfoStruct.InvokerNew("get_icon")
	})
	return err
}

// GetIcon is a representation of the C type gtk_recent_info_get_icon.
func (recv *RecentInfo) GetIcon(size int32) *gdkpixbuf.Pixbuf {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(size)

	var ret gi.Argument

	err := recentInfoGetIconFunction_Set()
	if err == nil {
		ret = recentInfoGetIconFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdkpixbuf.PixbufNewFromNative(ret.Pointer())

	return retGo
}

var recentInfoGetMimeTypeFunction *gi.Function
var recentInfoGetMimeTypeFunction_Once sync.Once

func recentInfoGetMimeTypeFunction_Set() error {
	var err error
	recentInfoGetMimeTypeFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetMimeTypeFunction, err = recentInfoStruct.InvokerNew("get_mime_type")
	})
	return err
}

// GetMimeType is a representation of the C type gtk_recent_info_get_mime_type.
func (recv *RecentInfo) GetMimeType() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetMimeTypeFunction_Set()
	if err == nil {
		ret = recentInfoGetMimeTypeFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var recentInfoGetModifiedFunction *gi.Function
var recentInfoGetModifiedFunction_Once sync.Once

func recentInfoGetModifiedFunction_Set() error {
	var err error
	recentInfoGetModifiedFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetModifiedFunction, err = recentInfoStruct.InvokerNew("get_modified")
	})
	return err
}

// GetModified is a representation of the C type gtk_recent_info_get_modified.
func (recv *RecentInfo) GetModified() int64 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetModifiedFunction_Set()
	if err == nil {
		ret = recentInfoGetModifiedFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int64()

	return retGo
}

var recentInfoGetPrivateHintFunction *gi.Function
var recentInfoGetPrivateHintFunction_Once sync.Once

func recentInfoGetPrivateHintFunction_Set() error {
	var err error
	recentInfoGetPrivateHintFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetPrivateHintFunction, err = recentInfoStruct.InvokerNew("get_private_hint")
	})
	return err
}

// GetPrivateHint is a representation of the C type gtk_recent_info_get_private_hint.
func (recv *RecentInfo) GetPrivateHint() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetPrivateHintFunction_Set()
	if err == nil {
		ret = recentInfoGetPrivateHintFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var recentInfoGetShortNameFunction *gi.Function
var recentInfoGetShortNameFunction_Once sync.Once

func recentInfoGetShortNameFunction_Set() error {
	var err error
	recentInfoGetShortNameFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetShortNameFunction, err = recentInfoStruct.InvokerNew("get_short_name")
	})
	return err
}

// GetShortName is a representation of the C type gtk_recent_info_get_short_name.
func (recv *RecentInfo) GetShortName() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetShortNameFunction_Set()
	if err == nil {
		ret = recentInfoGetShortNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var recentInfoGetUriFunction *gi.Function
var recentInfoGetUriFunction_Once sync.Once

func recentInfoGetUriFunction_Set() error {
	var err error
	recentInfoGetUriFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetUriFunction, err = recentInfoStruct.InvokerNew("get_uri")
	})
	return err
}

// GetUri is a representation of the C type gtk_recent_info_get_uri.
func (recv *RecentInfo) GetUri() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetUriFunction_Set()
	if err == nil {
		ret = recentInfoGetUriFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var recentInfoGetUriDisplayFunction *gi.Function
var recentInfoGetUriDisplayFunction_Once sync.Once

func recentInfoGetUriDisplayFunction_Set() error {
	var err error
	recentInfoGetUriDisplayFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetUriDisplayFunction, err = recentInfoStruct.InvokerNew("get_uri_display")
	})
	return err
}

// GetUriDisplay is a representation of the C type gtk_recent_info_get_uri_display.
func (recv *RecentInfo) GetUriDisplay() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetUriDisplayFunction_Set()
	if err == nil {
		ret = recentInfoGetUriDisplayFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var recentInfoGetVisitedFunction *gi.Function
var recentInfoGetVisitedFunction_Once sync.Once

func recentInfoGetVisitedFunction_Set() error {
	var err error
	recentInfoGetVisitedFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoGetVisitedFunction, err = recentInfoStruct.InvokerNew("get_visited")
	})
	return err
}

// GetVisited is a representation of the C type gtk_recent_info_get_visited.
func (recv *RecentInfo) GetVisited() int64 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoGetVisitedFunction_Set()
	if err == nil {
		ret = recentInfoGetVisitedFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int64()

	return retGo
}

var recentInfoHasApplicationFunction *gi.Function
var recentInfoHasApplicationFunction_Once sync.Once

func recentInfoHasApplicationFunction_Set() error {
	var err error
	recentInfoHasApplicationFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoHasApplicationFunction, err = recentInfoStruct.InvokerNew("has_application")
	})
	return err
}

// HasApplication is a representation of the C type gtk_recent_info_has_application.
func (recv *RecentInfo) HasApplication(appName string) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(appName)

	var ret gi.Argument

	err := recentInfoHasApplicationFunction_Set()
	if err == nil {
		ret = recentInfoHasApplicationFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var recentInfoHasGroupFunction *gi.Function
var recentInfoHasGroupFunction_Once sync.Once

func recentInfoHasGroupFunction_Set() error {
	var err error
	recentInfoHasGroupFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoHasGroupFunction, err = recentInfoStruct.InvokerNew("has_group")
	})
	return err
}

// HasGroup is a representation of the C type gtk_recent_info_has_group.
func (recv *RecentInfo) HasGroup(groupName string) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(groupName)

	var ret gi.Argument

	err := recentInfoHasGroupFunction_Set()
	if err == nil {
		ret = recentInfoHasGroupFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var recentInfoIsLocalFunction *gi.Function
var recentInfoIsLocalFunction_Once sync.Once

func recentInfoIsLocalFunction_Set() error {
	var err error
	recentInfoIsLocalFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoIsLocalFunction, err = recentInfoStruct.InvokerNew("is_local")
	})
	return err
}

// IsLocal is a representation of the C type gtk_recent_info_is_local.
func (recv *RecentInfo) IsLocal() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoIsLocalFunction_Set()
	if err == nil {
		ret = recentInfoIsLocalFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var recentInfoLastApplicationFunction *gi.Function
var recentInfoLastApplicationFunction_Once sync.Once

func recentInfoLastApplicationFunction_Set() error {
	var err error
	recentInfoLastApplicationFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoLastApplicationFunction, err = recentInfoStruct.InvokerNew("last_application")
	})
	return err
}

// LastApplication is a representation of the C type gtk_recent_info_last_application.
func (recv *RecentInfo) LastApplication() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoLastApplicationFunction_Set()
	if err == nil {
		ret = recentInfoLastApplicationFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var recentInfoMatchFunction *gi.Function
var recentInfoMatchFunction_Once sync.Once

func recentInfoMatchFunction_Set() error {
	var err error
	recentInfoMatchFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoMatchFunction, err = recentInfoStruct.InvokerNew("match")
	})
	return err
}

// Match is a representation of the C type gtk_recent_info_match.
func (recv *RecentInfo) Match(infoB *RecentInfo) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(infoB.Native())

	var ret gi.Argument

	err := recentInfoMatchFunction_Set()
	if err == nil {
		ret = recentInfoMatchFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var recentInfoRefFunction *gi.Function
var recentInfoRefFunction_Once sync.Once

func recentInfoRefFunction_Set() error {
	var err error
	recentInfoRefFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoRefFunction, err = recentInfoStruct.InvokerNew("ref")
	})
	return err
}

// Ref is a representation of the C type gtk_recent_info_ref.
func (recv *RecentInfo) Ref() *RecentInfo {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := recentInfoRefFunction_Set()
	if err == nil {
		ret = recentInfoRefFunction.Invoke(inArgs[:], nil)
	}

	retGo := RecentInfoNewFromNative(ret.Pointer())

	return retGo
}

var recentInfoUnrefFunction *gi.Function
var recentInfoUnrefFunction_Once sync.Once

func recentInfoUnrefFunction_Set() error {
	var err error
	recentInfoUnrefFunction_Once.Do(func() {
		err = recentInfoStruct_Set()
		if err != nil {
			return
		}
		recentInfoUnrefFunction, err = recentInfoStruct.InvokerNew("unref")
	})
	return err
}

// Unref is a representation of the C type gtk_recent_info_unref.
func (recv *RecentInfo) Unref() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := recentInfoUnrefFunction_Set()
	if err == nil {
		recentInfoUnrefFunction.Invoke(inArgs[:], nil)
	}

	return
}

// RecentInfoStruct creates an uninitialised RecentInfo.
func RecentInfoStruct() *RecentInfo {
	err := recentInfoStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentInfoNewFromNative(recentInfoStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentInfo)
	return structGo
}
func finalizeRecentInfo(obj *RecentInfo) {
	recentInfoStruct.Free(obj.Native())
}

var recentManagerClassStruct *gi.Struct
var recentManagerClassStruct_Once sync.Once

func recentManagerClassStruct_Set() error {
	var err error
	recentManagerClassStruct_Once.Do(func() {
		recentManagerClassStruct, err = gi.StructNew("Gtk", "RecentManagerClass")
	})
	return err
}

type RecentManagerClass struct {
	native unsafe.Pointer
}

func RecentManagerClassNewFromNative(native unsafe.Pointer) *RecentManagerClass {
	err := recentManagerClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentManagerClass{native: native}

	return instance
}

/*
CastToRecentManagerClass down casts any arbitrary Object to RecentManagerClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentManagerClass.
*/
func CastToRecentManagerClass(object *gobject.Object) *RecentManagerClass {
	return RecentManagerClassNewFromNative(object.Native())
}

// Equals compares this RecentManagerClass with another RecentManagerClass, and returns true if they represent the same Object.
func (recv *RecentManagerClass) Equals(other *RecentManagerClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentManagerClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_recent1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_recent1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_recent2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_recent2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_recent3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_recent3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_recent4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_recent4' : for field setter : missing Type

// RecentManagerClassStruct creates an uninitialised RecentManagerClass.
func RecentManagerClassStruct() *RecentManagerClass {
	err := recentManagerClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentManagerClassNewFromNative(recentManagerClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentManagerClass)
	return structGo
}
func finalizeRecentManagerClass(obj *RecentManagerClass) {
	recentManagerClassStruct.Free(obj.Native())
}

var recentManagerPrivateStruct *gi.Struct
var recentManagerPrivateStruct_Once sync.Once

func recentManagerPrivateStruct_Set() error {
	var err error
	recentManagerPrivateStruct_Once.Do(func() {
		recentManagerPrivateStruct, err = gi.StructNew("Gtk", "RecentManagerPrivate")
	})
	return err
}

type RecentManagerPrivate struct {
	native unsafe.Pointer
}

func RecentManagerPrivateNewFromNative(native unsafe.Pointer) *RecentManagerPrivate {
	err := recentManagerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RecentManagerPrivate{native: native}

	return instance
}

/*
CastToRecentManagerPrivate down casts any arbitrary Object to RecentManagerPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RecentManagerPrivate.
*/
func CastToRecentManagerPrivate(object *gobject.Object) *RecentManagerPrivate {
	return RecentManagerPrivateNewFromNative(object.Native())
}

// Equals compares this RecentManagerPrivate with another RecentManagerPrivate, and returns true if they represent the same Object.
func (recv *RecentManagerPrivate) Equals(other *RecentManagerPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RecentManagerPrivate) Native() unsafe.Pointer {
	return recv.native
}

// RecentManagerPrivateStruct creates an uninitialised RecentManagerPrivate.
func RecentManagerPrivateStruct() *RecentManagerPrivate {
	err := recentManagerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RecentManagerPrivateNewFromNative(recentManagerPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRecentManagerPrivate)
	return structGo
}
func finalizeRecentManagerPrivate(obj *RecentManagerPrivate) {
	recentManagerPrivateStruct.Free(obj.Native())
}

var rendererCellAccessibleClassStruct *gi.Struct
var rendererCellAccessibleClassStruct_Once sync.Once

func rendererCellAccessibleClassStruct_Set() error {
	var err error
	rendererCellAccessibleClassStruct_Once.Do(func() {
		rendererCellAccessibleClassStruct, err = gi.StructNew("Gtk", "RendererCellAccessibleClass")
	})
	return err
}

type RendererCellAccessibleClass struct {
	native unsafe.Pointer
}

func RendererCellAccessibleClassNewFromNative(native unsafe.Pointer) *RendererCellAccessibleClass {
	err := rendererCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RendererCellAccessibleClass{native: native}

	return instance
}

/*
CastToRendererCellAccessibleClass down casts any arbitrary Object to RendererCellAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RendererCellAccessibleClass.
*/
func CastToRendererCellAccessibleClass(object *gobject.Object) *RendererCellAccessibleClass {
	return RendererCellAccessibleClassNewFromNative(object.Native())
}

// Equals compares this RendererCellAccessibleClass with another RendererCellAccessibleClass, and returns true if they represent the same Object.
func (recv *RendererCellAccessibleClass) Equals(other *RendererCellAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RendererCellAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RendererCellAccessibleClass) FieldParentClass() *CellAccessibleClass {
	argValue := gi.StructFieldGet(rendererCellAccessibleClassStruct, recv.Native(), "parent_class")
	value := CellAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RendererCellAccessibleClass) SetFieldParentClass(value *CellAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(rendererCellAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// RendererCellAccessibleClassStruct creates an uninitialised RendererCellAccessibleClass.
func RendererCellAccessibleClassStruct() *RendererCellAccessibleClass {
	err := rendererCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RendererCellAccessibleClassNewFromNative(rendererCellAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRendererCellAccessibleClass)
	return structGo
}
func finalizeRendererCellAccessibleClass(obj *RendererCellAccessibleClass) {
	rendererCellAccessibleClassStruct.Free(obj.Native())
}

var rendererCellAccessiblePrivateStruct *gi.Struct
var rendererCellAccessiblePrivateStruct_Once sync.Once

func rendererCellAccessiblePrivateStruct_Set() error {
	var err error
	rendererCellAccessiblePrivateStruct_Once.Do(func() {
		rendererCellAccessiblePrivateStruct, err = gi.StructNew("Gtk", "RendererCellAccessiblePrivate")
	})
	return err
}

type RendererCellAccessiblePrivate struct {
	native unsafe.Pointer
}

func RendererCellAccessiblePrivateNewFromNative(native unsafe.Pointer) *RendererCellAccessiblePrivate {
	err := rendererCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RendererCellAccessiblePrivate{native: native}

	return instance
}

/*
CastToRendererCellAccessiblePrivate down casts any arbitrary Object to RendererCellAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a RendererCellAccessiblePrivate.
*/
func CastToRendererCellAccessiblePrivate(object *gobject.Object) *RendererCellAccessiblePrivate {
	return RendererCellAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this RendererCellAccessiblePrivate with another RendererCellAccessiblePrivate, and returns true if they represent the same Object.
func (recv *RendererCellAccessiblePrivate) Equals(other *RendererCellAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *RendererCellAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// RendererCellAccessiblePrivateStruct creates an uninitialised RendererCellAccessiblePrivate.
func RendererCellAccessiblePrivateStruct() *RendererCellAccessiblePrivate {
	err := rendererCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RendererCellAccessiblePrivateNewFromNative(rendererCellAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRendererCellAccessiblePrivate)
	return structGo
}
func finalizeRendererCellAccessiblePrivate(obj *RendererCellAccessiblePrivate) {
	rendererCellAccessiblePrivateStruct.Free(obj.Native())
}

var requestedSizeStruct *gi.Struct
var requestedSizeStruct_Once sync.Once

func requestedSizeStruct_Set() error {
	var err error
	requestedSizeStruct_Once.Do(func() {
		requestedSizeStruct, err = gi.StructNew("Gtk", "RequestedSize")
	})
	return err
}

type RequestedSize struct {
	native unsafe.Pointer
}

func RequestedSizeNewFromNative(native unsafe.Pointer) *RequestedSize {
	err := requestedSizeStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RequestedSize{native: native}

	return instance
}

/*
CastToRequestedSize down casts any arbitrary Object to RequestedSize.
Exercise care, as this is a potentially dangerous function
if the Object is not a RequestedSize.
*/
func CastToRequestedSize(object *gobject.Object) *RequestedSize {
	return RequestedSizeNewFromNative(object.Native())
}

// Equals compares this RequestedSize with another RequestedSize, and returns true if they represent the same Object.
func (recv *RequestedSize) Equals(other *RequestedSize) bool {
	return other.Native() == recv.Native()
}

func (recv *RequestedSize) Native() unsafe.Pointer {
	return recv.native
}

// FieldData returns the C field 'data'.
func (recv *RequestedSize) FieldData() unsafe.Pointer {
	argValue := gi.StructFieldGet(requestedSizeStruct, recv.Native(), "data")
	value := argValue.Pointer()
	return value
}

// SetFieldData sets the value of the C field 'data'.
func (recv *RequestedSize) SetFieldData(value unsafe.Pointer) {
	var argValue gi.Argument
	argValue.SetPointer(value)
	gi.StructFieldSet(requestedSizeStruct, recv.Native(), "data", argValue)
}

// FieldMinimumSize returns the C field 'minimum_size'.
func (recv *RequestedSize) FieldMinimumSize() int32 {
	argValue := gi.StructFieldGet(requestedSizeStruct, recv.Native(), "minimum_size")
	value := argValue.Int32()
	return value
}

// SetFieldMinimumSize sets the value of the C field 'minimum_size'.
func (recv *RequestedSize) SetFieldMinimumSize(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(requestedSizeStruct, recv.Native(), "minimum_size", argValue)
}

// FieldNaturalSize returns the C field 'natural_size'.
func (recv *RequestedSize) FieldNaturalSize() int32 {
	argValue := gi.StructFieldGet(requestedSizeStruct, recv.Native(), "natural_size")
	value := argValue.Int32()
	return value
}

// SetFieldNaturalSize sets the value of the C field 'natural_size'.
func (recv *RequestedSize) SetFieldNaturalSize(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(requestedSizeStruct, recv.Native(), "natural_size", argValue)
}

// RequestedSizeStruct creates an uninitialised RequestedSize.
func RequestedSizeStruct() *RequestedSize {
	err := requestedSizeStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RequestedSizeNewFromNative(requestedSizeStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRequestedSize)
	return structGo
}
func finalizeRequestedSize(obj *RequestedSize) {
	requestedSizeStruct.Free(obj.Native())
}

var requisitionStruct *gi.Struct
var requisitionStruct_Once sync.Once

func requisitionStruct_Set() error {
	var err error
	requisitionStruct_Once.Do(func() {
		requisitionStruct, err = gi.StructNew("Gtk", "Requisition")
	})
	return err
}

type Requisition struct {
	native unsafe.Pointer
}

func RequisitionNewFromNative(native unsafe.Pointer) *Requisition {
	err := requisitionStruct_Set()
	if err != nil {
		return nil
	}

	instance := &Requisition{native: native}

	return instance
}

/*
CastToRequisition down casts any arbitrary Object to Requisition.
Exercise care, as this is a potentially dangerous function
if the Object is not a Requisition.
*/
func CastToRequisition(object *gobject.Object) *Requisition {
	return RequisitionNewFromNative(object.Native())
}

// Equals compares this Requisition with another Requisition, and returns true if they represent the same Object.
func (recv *Requisition) Equals(other *Requisition) bool {
	return other.Native() == recv.Native()
}

func (recv *Requisition) Native() unsafe.Pointer {
	return recv.native
}

// FieldWidth returns the C field 'width'.
func (recv *Requisition) FieldWidth() int32 {
	argValue := gi.StructFieldGet(requisitionStruct, recv.Native(), "width")
	value := argValue.Int32()
	return value
}

// SetFieldWidth sets the value of the C field 'width'.
func (recv *Requisition) SetFieldWidth(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(requisitionStruct, recv.Native(), "width", argValue)
}

// FieldHeight returns the C field 'height'.
func (recv *Requisition) FieldHeight() int32 {
	argValue := gi.StructFieldGet(requisitionStruct, recv.Native(), "height")
	value := argValue.Int32()
	return value
}

// SetFieldHeight sets the value of the C field 'height'.
func (recv *Requisition) SetFieldHeight(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(requisitionStruct, recv.Native(), "height", argValue)
}

var requisitionNewFunction *gi.Function
var requisitionNewFunction_Once sync.Once

func requisitionNewFunction_Set() error {
	var err error
	requisitionNewFunction_Once.Do(func() {
		err = requisitionStruct_Set()
		if err != nil {
			return
		}
		requisitionNewFunction, err = requisitionStruct.InvokerNew("new")
	})
	return err
}

// RequisitionNew is a representation of the C type gtk_requisition_new.
func RequisitionNew() *Requisition {

	var ret gi.Argument

	err := requisitionNewFunction_Set()
	if err == nil {
		ret = requisitionNewFunction.Invoke(nil, nil)
	}

	retGo := RequisitionNewFromNative(ret.Pointer())

	return retGo
}

var requisitionCopyFunction *gi.Function
var requisitionCopyFunction_Once sync.Once

func requisitionCopyFunction_Set() error {
	var err error
	requisitionCopyFunction_Once.Do(func() {
		err = requisitionStruct_Set()
		if err != nil {
			return
		}
		requisitionCopyFunction, err = requisitionStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_requisition_copy.
func (recv *Requisition) Copy() *Requisition {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := requisitionCopyFunction_Set()
	if err == nil {
		ret = requisitionCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := RequisitionNewFromNative(ret.Pointer())

	return retGo
}

var requisitionFreeFunction *gi.Function
var requisitionFreeFunction_Once sync.Once

func requisitionFreeFunction_Set() error {
	var err error
	requisitionFreeFunction_Once.Do(func() {
		err = requisitionStruct_Set()
		if err != nil {
			return
		}
		requisitionFreeFunction, err = requisitionStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_requisition_free.
func (recv *Requisition) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := requisitionFreeFunction_Set()
	if err == nil {
		requisitionFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var revealerClassStruct *gi.Struct
var revealerClassStruct_Once sync.Once

func revealerClassStruct_Set() error {
	var err error
	revealerClassStruct_Once.Do(func() {
		revealerClassStruct, err = gi.StructNew("Gtk", "RevealerClass")
	})
	return err
}

type RevealerClass struct {
	native unsafe.Pointer
}

func RevealerClassNewFromNative(native unsafe.Pointer) *RevealerClass {
	err := revealerClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &RevealerClass{native: native}

	return instance
}

/*
CastToRevealerClass down casts any arbitrary Object to RevealerClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a RevealerClass.
*/
func CastToRevealerClass(object *gobject.Object) *RevealerClass {
	return RevealerClassNewFromNative(object.Native())
}

// Equals compares this RevealerClass with another RevealerClass, and returns true if they represent the same Object.
func (recv *RevealerClass) Equals(other *RevealerClass) bool {
	return other.Native() == recv.Native()
}

func (recv *RevealerClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *RevealerClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(revealerClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *RevealerClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(revealerClassStruct, recv.Native(), "parent_class", argValue)
}

// RevealerClassStruct creates an uninitialised RevealerClass.
func RevealerClassStruct() *RevealerClass {
	err := revealerClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := RevealerClassNewFromNative(revealerClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeRevealerClass)
	return structGo
}
func finalizeRevealerClass(obj *RevealerClass) {
	revealerClassStruct.Free(obj.Native())
}

var scaleAccessibleClassStruct *gi.Struct
var scaleAccessibleClassStruct_Once sync.Once

func scaleAccessibleClassStruct_Set() error {
	var err error
	scaleAccessibleClassStruct_Once.Do(func() {
		scaleAccessibleClassStruct, err = gi.StructNew("Gtk", "ScaleAccessibleClass")
	})
	return err
}

type ScaleAccessibleClass struct {
	native unsafe.Pointer
}

func ScaleAccessibleClassNewFromNative(native unsafe.Pointer) *ScaleAccessibleClass {
	err := scaleAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScaleAccessibleClass{native: native}

	return instance
}

/*
CastToScaleAccessibleClass down casts any arbitrary Object to ScaleAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScaleAccessibleClass.
*/
func CastToScaleAccessibleClass(object *gobject.Object) *ScaleAccessibleClass {
	return ScaleAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ScaleAccessibleClass with another ScaleAccessibleClass, and returns true if they represent the same Object.
func (recv *ScaleAccessibleClass) Equals(other *ScaleAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ScaleAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ScaleAccessibleClass) FieldParentClass() *RangeAccessibleClass {
	argValue := gi.StructFieldGet(scaleAccessibleClassStruct, recv.Native(), "parent_class")
	value := RangeAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ScaleAccessibleClass) SetFieldParentClass(value *RangeAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(scaleAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ScaleAccessibleClassStruct creates an uninitialised ScaleAccessibleClass.
func ScaleAccessibleClassStruct() *ScaleAccessibleClass {
	err := scaleAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScaleAccessibleClassNewFromNative(scaleAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScaleAccessibleClass)
	return structGo
}
func finalizeScaleAccessibleClass(obj *ScaleAccessibleClass) {
	scaleAccessibleClassStruct.Free(obj.Native())
}

var scaleAccessiblePrivateStruct *gi.Struct
var scaleAccessiblePrivateStruct_Once sync.Once

func scaleAccessiblePrivateStruct_Set() error {
	var err error
	scaleAccessiblePrivateStruct_Once.Do(func() {
		scaleAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ScaleAccessiblePrivate")
	})
	return err
}

type ScaleAccessiblePrivate struct {
	native unsafe.Pointer
}

func ScaleAccessiblePrivateNewFromNative(native unsafe.Pointer) *ScaleAccessiblePrivate {
	err := scaleAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScaleAccessiblePrivate{native: native}

	return instance
}

/*
CastToScaleAccessiblePrivate down casts any arbitrary Object to ScaleAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScaleAccessiblePrivate.
*/
func CastToScaleAccessiblePrivate(object *gobject.Object) *ScaleAccessiblePrivate {
	return ScaleAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ScaleAccessiblePrivate with another ScaleAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ScaleAccessiblePrivate) Equals(other *ScaleAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ScaleAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ScaleAccessiblePrivateStruct creates an uninitialised ScaleAccessiblePrivate.
func ScaleAccessiblePrivateStruct() *ScaleAccessiblePrivate {
	err := scaleAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScaleAccessiblePrivateNewFromNative(scaleAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScaleAccessiblePrivate)
	return structGo
}
func finalizeScaleAccessiblePrivate(obj *ScaleAccessiblePrivate) {
	scaleAccessiblePrivateStruct.Free(obj.Native())
}

var scaleButtonAccessibleClassStruct *gi.Struct
var scaleButtonAccessibleClassStruct_Once sync.Once

func scaleButtonAccessibleClassStruct_Set() error {
	var err error
	scaleButtonAccessibleClassStruct_Once.Do(func() {
		scaleButtonAccessibleClassStruct, err = gi.StructNew("Gtk", "ScaleButtonAccessibleClass")
	})
	return err
}

type ScaleButtonAccessibleClass struct {
	native unsafe.Pointer
}

func ScaleButtonAccessibleClassNewFromNative(native unsafe.Pointer) *ScaleButtonAccessibleClass {
	err := scaleButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScaleButtonAccessibleClass{native: native}

	return instance
}

/*
CastToScaleButtonAccessibleClass down casts any arbitrary Object to ScaleButtonAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScaleButtonAccessibleClass.
*/
func CastToScaleButtonAccessibleClass(object *gobject.Object) *ScaleButtonAccessibleClass {
	return ScaleButtonAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ScaleButtonAccessibleClass with another ScaleButtonAccessibleClass, and returns true if they represent the same Object.
func (recv *ScaleButtonAccessibleClass) Equals(other *ScaleButtonAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ScaleButtonAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ScaleButtonAccessibleClass) FieldParentClass() *ButtonAccessibleClass {
	argValue := gi.StructFieldGet(scaleButtonAccessibleClassStruct, recv.Native(), "parent_class")
	value := ButtonAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ScaleButtonAccessibleClass) SetFieldParentClass(value *ButtonAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(scaleButtonAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ScaleButtonAccessibleClassStruct creates an uninitialised ScaleButtonAccessibleClass.
func ScaleButtonAccessibleClassStruct() *ScaleButtonAccessibleClass {
	err := scaleButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScaleButtonAccessibleClassNewFromNative(scaleButtonAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScaleButtonAccessibleClass)
	return structGo
}
func finalizeScaleButtonAccessibleClass(obj *ScaleButtonAccessibleClass) {
	scaleButtonAccessibleClassStruct.Free(obj.Native())
}

var scaleButtonAccessiblePrivateStruct *gi.Struct
var scaleButtonAccessiblePrivateStruct_Once sync.Once

func scaleButtonAccessiblePrivateStruct_Set() error {
	var err error
	scaleButtonAccessiblePrivateStruct_Once.Do(func() {
		scaleButtonAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ScaleButtonAccessiblePrivate")
	})
	return err
}

type ScaleButtonAccessiblePrivate struct {
	native unsafe.Pointer
}

func ScaleButtonAccessiblePrivateNewFromNative(native unsafe.Pointer) *ScaleButtonAccessiblePrivate {
	err := scaleButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScaleButtonAccessiblePrivate{native: native}

	return instance
}

/*
CastToScaleButtonAccessiblePrivate down casts any arbitrary Object to ScaleButtonAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScaleButtonAccessiblePrivate.
*/
func CastToScaleButtonAccessiblePrivate(object *gobject.Object) *ScaleButtonAccessiblePrivate {
	return ScaleButtonAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ScaleButtonAccessiblePrivate with another ScaleButtonAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ScaleButtonAccessiblePrivate) Equals(other *ScaleButtonAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ScaleButtonAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ScaleButtonAccessiblePrivateStruct creates an uninitialised ScaleButtonAccessiblePrivate.
func ScaleButtonAccessiblePrivateStruct() *ScaleButtonAccessiblePrivate {
	err := scaleButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScaleButtonAccessiblePrivateNewFromNative(scaleButtonAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScaleButtonAccessiblePrivate)
	return structGo
}
func finalizeScaleButtonAccessiblePrivate(obj *ScaleButtonAccessiblePrivate) {
	scaleButtonAccessiblePrivateStruct.Free(obj.Native())
}

var scaleButtonClassStruct *gi.Struct
var scaleButtonClassStruct_Once sync.Once

func scaleButtonClassStruct_Set() error {
	var err error
	scaleButtonClassStruct_Once.Do(func() {
		scaleButtonClassStruct, err = gi.StructNew("Gtk", "ScaleButtonClass")
	})
	return err
}

type ScaleButtonClass struct {
	native unsafe.Pointer
}

func ScaleButtonClassNewFromNative(native unsafe.Pointer) *ScaleButtonClass {
	err := scaleButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScaleButtonClass{native: native}

	return instance
}

/*
CastToScaleButtonClass down casts any arbitrary Object to ScaleButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScaleButtonClass.
*/
func CastToScaleButtonClass(object *gobject.Object) *ScaleButtonClass {
	return ScaleButtonClassNewFromNative(object.Native())
}

// Equals compares this ScaleButtonClass with another ScaleButtonClass, and returns true if they represent the same Object.
func (recv *ScaleButtonClass) Equals(other *ScaleButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ScaleButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ScaleButtonClass) FieldParentClass() *ButtonClass {
	argValue := gi.StructFieldGet(scaleButtonClassStruct, recv.Native(), "parent_class")
	value := ButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ScaleButtonClass) SetFieldParentClass(value *ButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(scaleButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'value_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'value_changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ScaleButtonClassStruct creates an uninitialised ScaleButtonClass.
func ScaleButtonClassStruct() *ScaleButtonClass {
	err := scaleButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScaleButtonClassNewFromNative(scaleButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScaleButtonClass)
	return structGo
}
func finalizeScaleButtonClass(obj *ScaleButtonClass) {
	scaleButtonClassStruct.Free(obj.Native())
}

var scaleButtonPrivateStruct *gi.Struct
var scaleButtonPrivateStruct_Once sync.Once

func scaleButtonPrivateStruct_Set() error {
	var err error
	scaleButtonPrivateStruct_Once.Do(func() {
		scaleButtonPrivateStruct, err = gi.StructNew("Gtk", "ScaleButtonPrivate")
	})
	return err
}

type ScaleButtonPrivate struct {
	native unsafe.Pointer
}

func ScaleButtonPrivateNewFromNative(native unsafe.Pointer) *ScaleButtonPrivate {
	err := scaleButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScaleButtonPrivate{native: native}

	return instance
}

/*
CastToScaleButtonPrivate down casts any arbitrary Object to ScaleButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScaleButtonPrivate.
*/
func CastToScaleButtonPrivate(object *gobject.Object) *ScaleButtonPrivate {
	return ScaleButtonPrivateNewFromNative(object.Native())
}

// Equals compares this ScaleButtonPrivate with another ScaleButtonPrivate, and returns true if they represent the same Object.
func (recv *ScaleButtonPrivate) Equals(other *ScaleButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ScaleButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ScaleButtonPrivateStruct creates an uninitialised ScaleButtonPrivate.
func ScaleButtonPrivateStruct() *ScaleButtonPrivate {
	err := scaleButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScaleButtonPrivateNewFromNative(scaleButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScaleButtonPrivate)
	return structGo
}
func finalizeScaleButtonPrivate(obj *ScaleButtonPrivate) {
	scaleButtonPrivateStruct.Free(obj.Native())
}

var scaleClassStruct *gi.Struct
var scaleClassStruct_Once sync.Once

func scaleClassStruct_Set() error {
	var err error
	scaleClassStruct_Once.Do(func() {
		scaleClassStruct, err = gi.StructNew("Gtk", "ScaleClass")
	})
	return err
}

type ScaleClass struct {
	native unsafe.Pointer
}

func ScaleClassNewFromNative(native unsafe.Pointer) *ScaleClass {
	err := scaleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScaleClass{native: native}

	return instance
}

/*
CastToScaleClass down casts any arbitrary Object to ScaleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScaleClass.
*/
func CastToScaleClass(object *gobject.Object) *ScaleClass {
	return ScaleClassNewFromNative(object.Native())
}

// Equals compares this ScaleClass with another ScaleClass, and returns true if they represent the same Object.
func (recv *ScaleClass) Equals(other *ScaleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ScaleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ScaleClass) FieldParentClass() *RangeClass {
	argValue := gi.StructFieldGet(scaleClassStruct, recv.Native(), "parent_class")
	value := RangeClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ScaleClass) SetFieldParentClass(value *RangeClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(scaleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'format_value' : for field getter : missing Type

// UNSUPPORTED : C value 'format_value' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_value' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_value' : for field setter : missing Type

// UNSUPPORTED : C value 'get_layout_offsets' : for field getter : missing Type

// UNSUPPORTED : C value 'get_layout_offsets' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ScaleClassStruct creates an uninitialised ScaleClass.
func ScaleClassStruct() *ScaleClass {
	err := scaleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScaleClassNewFromNative(scaleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScaleClass)
	return structGo
}
func finalizeScaleClass(obj *ScaleClass) {
	scaleClassStruct.Free(obj.Native())
}

var scalePrivateStruct *gi.Struct
var scalePrivateStruct_Once sync.Once

func scalePrivateStruct_Set() error {
	var err error
	scalePrivateStruct_Once.Do(func() {
		scalePrivateStruct, err = gi.StructNew("Gtk", "ScalePrivate")
	})
	return err
}

type ScalePrivate struct {
	native unsafe.Pointer
}

func ScalePrivateNewFromNative(native unsafe.Pointer) *ScalePrivate {
	err := scalePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScalePrivate{native: native}

	return instance
}

/*
CastToScalePrivate down casts any arbitrary Object to ScalePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScalePrivate.
*/
func CastToScalePrivate(object *gobject.Object) *ScalePrivate {
	return ScalePrivateNewFromNative(object.Native())
}

// Equals compares this ScalePrivate with another ScalePrivate, and returns true if they represent the same Object.
func (recv *ScalePrivate) Equals(other *ScalePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ScalePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ScalePrivateStruct creates an uninitialised ScalePrivate.
func ScalePrivateStruct() *ScalePrivate {
	err := scalePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScalePrivateNewFromNative(scalePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScalePrivate)
	return structGo
}
func finalizeScalePrivate(obj *ScalePrivate) {
	scalePrivateStruct.Free(obj.Native())
}

var scrollableInterfaceStruct *gi.Struct
var scrollableInterfaceStruct_Once sync.Once

func scrollableInterfaceStruct_Set() error {
	var err error
	scrollableInterfaceStruct_Once.Do(func() {
		scrollableInterfaceStruct, err = gi.StructNew("Gtk", "ScrollableInterface")
	})
	return err
}

type ScrollableInterface struct {
	native unsafe.Pointer
}

func ScrollableInterfaceNewFromNative(native unsafe.Pointer) *ScrollableInterface {
	err := scrollableInterfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScrollableInterface{native: native}

	return instance
}

/*
CastToScrollableInterface down casts any arbitrary Object to ScrollableInterface.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScrollableInterface.
*/
func CastToScrollableInterface(object *gobject.Object) *ScrollableInterface {
	return ScrollableInterfaceNewFromNative(object.Native())
}

// Equals compares this ScrollableInterface with another ScrollableInterface, and returns true if they represent the same Object.
func (recv *ScrollableInterface) Equals(other *ScrollableInterface) bool {
	return other.Native() == recv.Native()
}

func (recv *ScrollableInterface) Native() unsafe.Pointer {
	return recv.native
}

// FieldBaseIface returns the C field 'base_iface'.
func (recv *ScrollableInterface) FieldBaseIface() *gobject.TypeInterface {
	argValue := gi.StructFieldGet(scrollableInterfaceStruct, recv.Native(), "base_iface")
	value := gobject.TypeInterfaceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldBaseIface sets the value of the C field 'base_iface'.
func (recv *ScrollableInterface) SetFieldBaseIface(value *gobject.TypeInterface) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(scrollableInterfaceStruct, recv.Native(), "base_iface", argValue)
}

// UNSUPPORTED : C value 'get_border' : for field getter : missing Type

// UNSUPPORTED : C value 'get_border' : for field setter : missing Type

// ScrollableInterfaceStruct creates an uninitialised ScrollableInterface.
func ScrollableInterfaceStruct() *ScrollableInterface {
	err := scrollableInterfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScrollableInterfaceNewFromNative(scrollableInterfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScrollableInterface)
	return structGo
}
func finalizeScrollableInterface(obj *ScrollableInterface) {
	scrollableInterfaceStruct.Free(obj.Native())
}

var scrollbarClassStruct *gi.Struct
var scrollbarClassStruct_Once sync.Once

func scrollbarClassStruct_Set() error {
	var err error
	scrollbarClassStruct_Once.Do(func() {
		scrollbarClassStruct, err = gi.StructNew("Gtk", "ScrollbarClass")
	})
	return err
}

type ScrollbarClass struct {
	native unsafe.Pointer
}

func ScrollbarClassNewFromNative(native unsafe.Pointer) *ScrollbarClass {
	err := scrollbarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScrollbarClass{native: native}

	return instance
}

/*
CastToScrollbarClass down casts any arbitrary Object to ScrollbarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScrollbarClass.
*/
func CastToScrollbarClass(object *gobject.Object) *ScrollbarClass {
	return ScrollbarClassNewFromNative(object.Native())
}

// Equals compares this ScrollbarClass with another ScrollbarClass, and returns true if they represent the same Object.
func (recv *ScrollbarClass) Equals(other *ScrollbarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ScrollbarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ScrollbarClass) FieldParentClass() *RangeClass {
	argValue := gi.StructFieldGet(scrollbarClassStruct, recv.Native(), "parent_class")
	value := RangeClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ScrollbarClass) SetFieldParentClass(value *RangeClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(scrollbarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ScrollbarClassStruct creates an uninitialised ScrollbarClass.
func ScrollbarClassStruct() *ScrollbarClass {
	err := scrollbarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScrollbarClassNewFromNative(scrollbarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScrollbarClass)
	return structGo
}
func finalizeScrollbarClass(obj *ScrollbarClass) {
	scrollbarClassStruct.Free(obj.Native())
}

var scrolledWindowAccessibleClassStruct *gi.Struct
var scrolledWindowAccessibleClassStruct_Once sync.Once

func scrolledWindowAccessibleClassStruct_Set() error {
	var err error
	scrolledWindowAccessibleClassStruct_Once.Do(func() {
		scrolledWindowAccessibleClassStruct, err = gi.StructNew("Gtk", "ScrolledWindowAccessibleClass")
	})
	return err
}

type ScrolledWindowAccessibleClass struct {
	native unsafe.Pointer
}

func ScrolledWindowAccessibleClassNewFromNative(native unsafe.Pointer) *ScrolledWindowAccessibleClass {
	err := scrolledWindowAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScrolledWindowAccessibleClass{native: native}

	return instance
}

/*
CastToScrolledWindowAccessibleClass down casts any arbitrary Object to ScrolledWindowAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScrolledWindowAccessibleClass.
*/
func CastToScrolledWindowAccessibleClass(object *gobject.Object) *ScrolledWindowAccessibleClass {
	return ScrolledWindowAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ScrolledWindowAccessibleClass with another ScrolledWindowAccessibleClass, and returns true if they represent the same Object.
func (recv *ScrolledWindowAccessibleClass) Equals(other *ScrolledWindowAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ScrolledWindowAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ScrolledWindowAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(scrolledWindowAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ScrolledWindowAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(scrolledWindowAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ScrolledWindowAccessibleClassStruct creates an uninitialised ScrolledWindowAccessibleClass.
func ScrolledWindowAccessibleClassStruct() *ScrolledWindowAccessibleClass {
	err := scrolledWindowAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScrolledWindowAccessibleClassNewFromNative(scrolledWindowAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScrolledWindowAccessibleClass)
	return structGo
}
func finalizeScrolledWindowAccessibleClass(obj *ScrolledWindowAccessibleClass) {
	scrolledWindowAccessibleClassStruct.Free(obj.Native())
}

var scrolledWindowAccessiblePrivateStruct *gi.Struct
var scrolledWindowAccessiblePrivateStruct_Once sync.Once

func scrolledWindowAccessiblePrivateStruct_Set() error {
	var err error
	scrolledWindowAccessiblePrivateStruct_Once.Do(func() {
		scrolledWindowAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ScrolledWindowAccessiblePrivate")
	})
	return err
}

type ScrolledWindowAccessiblePrivate struct {
	native unsafe.Pointer
}

func ScrolledWindowAccessiblePrivateNewFromNative(native unsafe.Pointer) *ScrolledWindowAccessiblePrivate {
	err := scrolledWindowAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScrolledWindowAccessiblePrivate{native: native}

	return instance
}

/*
CastToScrolledWindowAccessiblePrivate down casts any arbitrary Object to ScrolledWindowAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScrolledWindowAccessiblePrivate.
*/
func CastToScrolledWindowAccessiblePrivate(object *gobject.Object) *ScrolledWindowAccessiblePrivate {
	return ScrolledWindowAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ScrolledWindowAccessiblePrivate with another ScrolledWindowAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ScrolledWindowAccessiblePrivate) Equals(other *ScrolledWindowAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ScrolledWindowAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ScrolledWindowAccessiblePrivateStruct creates an uninitialised ScrolledWindowAccessiblePrivate.
func ScrolledWindowAccessiblePrivateStruct() *ScrolledWindowAccessiblePrivate {
	err := scrolledWindowAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScrolledWindowAccessiblePrivateNewFromNative(scrolledWindowAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScrolledWindowAccessiblePrivate)
	return structGo
}
func finalizeScrolledWindowAccessiblePrivate(obj *ScrolledWindowAccessiblePrivate) {
	scrolledWindowAccessiblePrivateStruct.Free(obj.Native())
}

var scrolledWindowClassStruct *gi.Struct
var scrolledWindowClassStruct_Once sync.Once

func scrolledWindowClassStruct_Set() error {
	var err error
	scrolledWindowClassStruct_Once.Do(func() {
		scrolledWindowClassStruct, err = gi.StructNew("Gtk", "ScrolledWindowClass")
	})
	return err
}

type ScrolledWindowClass struct {
	native unsafe.Pointer
}

func ScrolledWindowClassNewFromNative(native unsafe.Pointer) *ScrolledWindowClass {
	err := scrolledWindowClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScrolledWindowClass{native: native}

	return instance
}

/*
CastToScrolledWindowClass down casts any arbitrary Object to ScrolledWindowClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScrolledWindowClass.
*/
func CastToScrolledWindowClass(object *gobject.Object) *ScrolledWindowClass {
	return ScrolledWindowClassNewFromNative(object.Native())
}

// Equals compares this ScrolledWindowClass with another ScrolledWindowClass, and returns true if they represent the same Object.
func (recv *ScrolledWindowClass) Equals(other *ScrolledWindowClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ScrolledWindowClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ScrolledWindowClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(scrolledWindowClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ScrolledWindowClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(scrolledWindowClassStruct, recv.Native(), "parent_class", argValue)
}

// FieldScrollbarSpacing returns the C field 'scrollbar_spacing'.
func (recv *ScrolledWindowClass) FieldScrollbarSpacing() int32 {
	argValue := gi.StructFieldGet(scrolledWindowClassStruct, recv.Native(), "scrollbar_spacing")
	value := argValue.Int32()
	return value
}

// SetFieldScrollbarSpacing sets the value of the C field 'scrollbar_spacing'.
func (recv *ScrolledWindowClass) SetFieldScrollbarSpacing(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(scrolledWindowClassStruct, recv.Native(), "scrollbar_spacing", argValue)
}

// UNSUPPORTED : C value 'scroll_child' : for field getter : missing Type

// UNSUPPORTED : C value 'scroll_child' : for field setter : missing Type

// UNSUPPORTED : C value 'move_focus_out' : for field getter : missing Type

// UNSUPPORTED : C value 'move_focus_out' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ScrolledWindowClassStruct creates an uninitialised ScrolledWindowClass.
func ScrolledWindowClassStruct() *ScrolledWindowClass {
	err := scrolledWindowClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScrolledWindowClassNewFromNative(scrolledWindowClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScrolledWindowClass)
	return structGo
}
func finalizeScrolledWindowClass(obj *ScrolledWindowClass) {
	scrolledWindowClassStruct.Free(obj.Native())
}

var scrolledWindowPrivateStruct *gi.Struct
var scrolledWindowPrivateStruct_Once sync.Once

func scrolledWindowPrivateStruct_Set() error {
	var err error
	scrolledWindowPrivateStruct_Once.Do(func() {
		scrolledWindowPrivateStruct, err = gi.StructNew("Gtk", "ScrolledWindowPrivate")
	})
	return err
}

type ScrolledWindowPrivate struct {
	native unsafe.Pointer
}

func ScrolledWindowPrivateNewFromNative(native unsafe.Pointer) *ScrolledWindowPrivate {
	err := scrolledWindowPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ScrolledWindowPrivate{native: native}

	return instance
}

/*
CastToScrolledWindowPrivate down casts any arbitrary Object to ScrolledWindowPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ScrolledWindowPrivate.
*/
func CastToScrolledWindowPrivate(object *gobject.Object) *ScrolledWindowPrivate {
	return ScrolledWindowPrivateNewFromNative(object.Native())
}

// Equals compares this ScrolledWindowPrivate with another ScrolledWindowPrivate, and returns true if they represent the same Object.
func (recv *ScrolledWindowPrivate) Equals(other *ScrolledWindowPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ScrolledWindowPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ScrolledWindowPrivateStruct creates an uninitialised ScrolledWindowPrivate.
func ScrolledWindowPrivateStruct() *ScrolledWindowPrivate {
	err := scrolledWindowPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ScrolledWindowPrivateNewFromNative(scrolledWindowPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeScrolledWindowPrivate)
	return structGo
}
func finalizeScrolledWindowPrivate(obj *ScrolledWindowPrivate) {
	scrolledWindowPrivateStruct.Free(obj.Native())
}

var searchBarClassStruct *gi.Struct
var searchBarClassStruct_Once sync.Once

func searchBarClassStruct_Set() error {
	var err error
	searchBarClassStruct_Once.Do(func() {
		searchBarClassStruct, err = gi.StructNew("Gtk", "SearchBarClass")
	})
	return err
}

type SearchBarClass struct {
	native unsafe.Pointer
}

func SearchBarClassNewFromNative(native unsafe.Pointer) *SearchBarClass {
	err := searchBarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SearchBarClass{native: native}

	return instance
}

/*
CastToSearchBarClass down casts any arbitrary Object to SearchBarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SearchBarClass.
*/
func CastToSearchBarClass(object *gobject.Object) *SearchBarClass {
	return SearchBarClassNewFromNative(object.Native())
}

// Equals compares this SearchBarClass with another SearchBarClass, and returns true if they represent the same Object.
func (recv *SearchBarClass) Equals(other *SearchBarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SearchBarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SearchBarClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(searchBarClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SearchBarClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(searchBarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SearchBarClassStruct creates an uninitialised SearchBarClass.
func SearchBarClassStruct() *SearchBarClass {
	err := searchBarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SearchBarClassNewFromNative(searchBarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSearchBarClass)
	return structGo
}
func finalizeSearchBarClass(obj *SearchBarClass) {
	searchBarClassStruct.Free(obj.Native())
}

var searchEntryClassStruct *gi.Struct
var searchEntryClassStruct_Once sync.Once

func searchEntryClassStruct_Set() error {
	var err error
	searchEntryClassStruct_Once.Do(func() {
		searchEntryClassStruct, err = gi.StructNew("Gtk", "SearchEntryClass")
	})
	return err
}

type SearchEntryClass struct {
	native unsafe.Pointer
}

func SearchEntryClassNewFromNative(native unsafe.Pointer) *SearchEntryClass {
	err := searchEntryClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SearchEntryClass{native: native}

	return instance
}

/*
CastToSearchEntryClass down casts any arbitrary Object to SearchEntryClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SearchEntryClass.
*/
func CastToSearchEntryClass(object *gobject.Object) *SearchEntryClass {
	return SearchEntryClassNewFromNative(object.Native())
}

// Equals compares this SearchEntryClass with another SearchEntryClass, and returns true if they represent the same Object.
func (recv *SearchEntryClass) Equals(other *SearchEntryClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SearchEntryClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SearchEntryClass) FieldParentClass() *EntryClass {
	argValue := gi.StructFieldGet(searchEntryClassStruct, recv.Native(), "parent_class")
	value := EntryClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SearchEntryClass) SetFieldParentClass(value *EntryClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(searchEntryClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'search_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'search_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'next_match' : for field getter : missing Type

// UNSUPPORTED : C value 'next_match' : for field setter : missing Type

// UNSUPPORTED : C value 'previous_match' : for field getter : missing Type

// UNSUPPORTED : C value 'previous_match' : for field setter : missing Type

// UNSUPPORTED : C value 'stop_search' : for field getter : missing Type

// UNSUPPORTED : C value 'stop_search' : for field setter : missing Type

// SearchEntryClassStruct creates an uninitialised SearchEntryClass.
func SearchEntryClassStruct() *SearchEntryClass {
	err := searchEntryClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SearchEntryClassNewFromNative(searchEntryClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSearchEntryClass)
	return structGo
}
func finalizeSearchEntryClass(obj *SearchEntryClass) {
	searchEntryClassStruct.Free(obj.Native())
}

var selectionDataStruct *gi.Struct
var selectionDataStruct_Once sync.Once

func selectionDataStruct_Set() error {
	var err error
	selectionDataStruct_Once.Do(func() {
		selectionDataStruct, err = gi.StructNew("Gtk", "SelectionData")
	})
	return err
}

type SelectionData struct {
	native unsafe.Pointer
}

func SelectionDataNewFromNative(native unsafe.Pointer) *SelectionData {
	err := selectionDataStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SelectionData{native: native}

	return instance
}

/*
CastToSelectionData down casts any arbitrary Object to SelectionData.
Exercise care, as this is a potentially dangerous function
if the Object is not a SelectionData.
*/
func CastToSelectionData(object *gobject.Object) *SelectionData {
	return SelectionDataNewFromNative(object.Native())
}

// Equals compares this SelectionData with another SelectionData, and returns true if they represent the same Object.
func (recv *SelectionData) Equals(other *SelectionData) bool {
	return other.Native() == recv.Native()
}

func (recv *SelectionData) Native() unsafe.Pointer {
	return recv.native
}

var selectionDataCopyFunction *gi.Function
var selectionDataCopyFunction_Once sync.Once

func selectionDataCopyFunction_Set() error {
	var err error
	selectionDataCopyFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataCopyFunction, err = selectionDataStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_selection_data_copy.
func (recv *SelectionData) Copy() *SelectionData {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataCopyFunction_Set()
	if err == nil {
		ret = selectionDataCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := SelectionDataNewFromNative(ret.Pointer())

	return retGo
}

var selectionDataFreeFunction *gi.Function
var selectionDataFreeFunction_Once sync.Once

func selectionDataFreeFunction_Set() error {
	var err error
	selectionDataFreeFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataFreeFunction, err = selectionDataStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_selection_data_free.
func (recv *SelectionData) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := selectionDataFreeFunction_Set()
	if err == nil {
		selectionDataFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var selectionDataGetDataFunction *gi.Function
var selectionDataGetDataFunction_Once sync.Once

func selectionDataGetDataFunction_Set() error {
	var err error
	selectionDataGetDataFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetDataFunction, err = selectionDataStruct.InvokerNew("get_data")
	})
	return err
}

// GetData is a representation of the C type gtk_selection_data_get_data.
func (recv *SelectionData) GetData() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := selectionDataGetDataFunction_Set()
	if err == nil {
		selectionDataGetDataFunction.Invoke(inArgs[:], nil)
	}

	return
}

var selectionDataGetDataTypeFunction *gi.Function
var selectionDataGetDataTypeFunction_Once sync.Once

func selectionDataGetDataTypeFunction_Set() error {
	var err error
	selectionDataGetDataTypeFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetDataTypeFunction, err = selectionDataStruct.InvokerNew("get_data_type")
	})
	return err
}

// GetDataType is a representation of the C type gtk_selection_data_get_data_type.
func (recv *SelectionData) GetDataType() *gdk.Atom {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataGetDataTypeFunction_Set()
	if err == nil {
		ret = selectionDataGetDataTypeFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdk.AtomNewFromNative(ret.Pointer())

	return retGo
}

var selectionDataGetDataWithLengthFunction *gi.Function
var selectionDataGetDataWithLengthFunction_Once sync.Once

func selectionDataGetDataWithLengthFunction_Set() error {
	var err error
	selectionDataGetDataWithLengthFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetDataWithLengthFunction, err = selectionDataStruct.InvokerNew("get_data_with_length")
	})
	return err
}

// GetDataWithLength is a representation of the C type gtk_selection_data_get_data_with_length.
func (recv *SelectionData) GetDataWithLength() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var outArgs [1]gi.Argument

	err := selectionDataGetDataWithLengthFunction_Set()
	if err == nil {
		selectionDataGetDataWithLengthFunction.Invoke(inArgs[:], outArgs[:])
	}

	out0 := outArgs[0].Int32()

	return out0
}

var selectionDataGetDisplayFunction *gi.Function
var selectionDataGetDisplayFunction_Once sync.Once

func selectionDataGetDisplayFunction_Set() error {
	var err error
	selectionDataGetDisplayFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetDisplayFunction, err = selectionDataStruct.InvokerNew("get_display")
	})
	return err
}

// GetDisplay is a representation of the C type gtk_selection_data_get_display.
func (recv *SelectionData) GetDisplay() *gdk.Display {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataGetDisplayFunction_Set()
	if err == nil {
		ret = selectionDataGetDisplayFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdk.DisplayNewFromNative(ret.Pointer())

	return retGo
}

var selectionDataGetFormatFunction *gi.Function
var selectionDataGetFormatFunction_Once sync.Once

func selectionDataGetFormatFunction_Set() error {
	var err error
	selectionDataGetFormatFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetFormatFunction, err = selectionDataStruct.InvokerNew("get_format")
	})
	return err
}

// GetFormat is a representation of the C type gtk_selection_data_get_format.
func (recv *SelectionData) GetFormat() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataGetFormatFunction_Set()
	if err == nil {
		ret = selectionDataGetFormatFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var selectionDataGetLengthFunction *gi.Function
var selectionDataGetLengthFunction_Once sync.Once

func selectionDataGetLengthFunction_Set() error {
	var err error
	selectionDataGetLengthFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetLengthFunction, err = selectionDataStruct.InvokerNew("get_length")
	})
	return err
}

// GetLength is a representation of the C type gtk_selection_data_get_length.
func (recv *SelectionData) GetLength() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataGetLengthFunction_Set()
	if err == nil {
		ret = selectionDataGetLengthFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var selectionDataGetPixbufFunction *gi.Function
var selectionDataGetPixbufFunction_Once sync.Once

func selectionDataGetPixbufFunction_Set() error {
	var err error
	selectionDataGetPixbufFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetPixbufFunction, err = selectionDataStruct.InvokerNew("get_pixbuf")
	})
	return err
}

// GetPixbuf is a representation of the C type gtk_selection_data_get_pixbuf.
func (recv *SelectionData) GetPixbuf() *gdkpixbuf.Pixbuf {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataGetPixbufFunction_Set()
	if err == nil {
		ret = selectionDataGetPixbufFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdkpixbuf.PixbufNewFromNative(ret.Pointer())

	return retGo
}

var selectionDataGetSelectionFunction *gi.Function
var selectionDataGetSelectionFunction_Once sync.Once

func selectionDataGetSelectionFunction_Set() error {
	var err error
	selectionDataGetSelectionFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetSelectionFunction, err = selectionDataStruct.InvokerNew("get_selection")
	})
	return err
}

// GetSelection is a representation of the C type gtk_selection_data_get_selection.
func (recv *SelectionData) GetSelection() *gdk.Atom {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataGetSelectionFunction_Set()
	if err == nil {
		ret = selectionDataGetSelectionFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdk.AtomNewFromNative(ret.Pointer())

	return retGo
}

var selectionDataGetTargetFunction *gi.Function
var selectionDataGetTargetFunction_Once sync.Once

func selectionDataGetTargetFunction_Set() error {
	var err error
	selectionDataGetTargetFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetTargetFunction, err = selectionDataStruct.InvokerNew("get_target")
	})
	return err
}

// GetTarget is a representation of the C type gtk_selection_data_get_target.
func (recv *SelectionData) GetTarget() *gdk.Atom {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataGetTargetFunction_Set()
	if err == nil {
		ret = selectionDataGetTargetFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdk.AtomNewFromNative(ret.Pointer())

	return retGo
}

// UNSUPPORTED : C value 'gtk_selection_data_get_targets' : array parameter 'targets'

var selectionDataGetTextFunction *gi.Function
var selectionDataGetTextFunction_Once sync.Once

func selectionDataGetTextFunction_Set() error {
	var err error
	selectionDataGetTextFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetTextFunction, err = selectionDataStruct.InvokerNew("get_text")
	})
	return err
}

// GetText is a representation of the C type gtk_selection_data_get_text.
func (recv *SelectionData) GetText() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataGetTextFunction_Set()
	if err == nil {
		ret = selectionDataGetTextFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var selectionDataGetUrisFunction *gi.Function
var selectionDataGetUrisFunction_Once sync.Once

func selectionDataGetUrisFunction_Set() error {
	var err error
	selectionDataGetUrisFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataGetUrisFunction, err = selectionDataStruct.InvokerNew("get_uris")
	})
	return err
}

// GetUris is a representation of the C type gtk_selection_data_get_uris.
func (recv *SelectionData) GetUris() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := selectionDataGetUrisFunction_Set()
	if err == nil {
		selectionDataGetUrisFunction.Invoke(inArgs[:], nil)
	}

	return
}

// UNSUPPORTED : C value 'gtk_selection_data_set' : array parameter 'data'

var selectionDataSetPixbufFunction *gi.Function
var selectionDataSetPixbufFunction_Once sync.Once

func selectionDataSetPixbufFunction_Set() error {
	var err error
	selectionDataSetPixbufFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataSetPixbufFunction, err = selectionDataStruct.InvokerNew("set_pixbuf")
	})
	return err
}

// SetPixbuf is a representation of the C type gtk_selection_data_set_pixbuf.
func (recv *SelectionData) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(pixbuf.Native())

	var ret gi.Argument

	err := selectionDataSetPixbufFunction_Set()
	if err == nil {
		ret = selectionDataSetPixbufFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var selectionDataSetTextFunction *gi.Function
var selectionDataSetTextFunction_Once sync.Once

func selectionDataSetTextFunction_Set() error {
	var err error
	selectionDataSetTextFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataSetTextFunction, err = selectionDataStruct.InvokerNew("set_text")
	})
	return err
}

// SetText is a representation of the C type gtk_selection_data_set_text.
func (recv *SelectionData) SetText(str string, len int32) bool {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(str)
	inArgs[2].SetInt32(len)

	var ret gi.Argument

	err := selectionDataSetTextFunction_Set()
	if err == nil {
		ret = selectionDataSetTextFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

// UNSUPPORTED : C value 'gtk_selection_data_set_uris' : array parameter 'uris'

var selectionDataTargetsIncludeImageFunction *gi.Function
var selectionDataTargetsIncludeImageFunction_Once sync.Once

func selectionDataTargetsIncludeImageFunction_Set() error {
	var err error
	selectionDataTargetsIncludeImageFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataTargetsIncludeImageFunction, err = selectionDataStruct.InvokerNew("targets_include_image")
	})
	return err
}

// TargetsIncludeImage is a representation of the C type gtk_selection_data_targets_include_image.
func (recv *SelectionData) TargetsIncludeImage(writable bool) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetBoolean(writable)

	var ret gi.Argument

	err := selectionDataTargetsIncludeImageFunction_Set()
	if err == nil {
		ret = selectionDataTargetsIncludeImageFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var selectionDataTargetsIncludeRichTextFunction *gi.Function
var selectionDataTargetsIncludeRichTextFunction_Once sync.Once

func selectionDataTargetsIncludeRichTextFunction_Set() error {
	var err error
	selectionDataTargetsIncludeRichTextFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataTargetsIncludeRichTextFunction, err = selectionDataStruct.InvokerNew("targets_include_rich_text")
	})
	return err
}

// TargetsIncludeRichText is a representation of the C type gtk_selection_data_targets_include_rich_text.
func (recv *SelectionData) TargetsIncludeRichText(buffer *TextBuffer) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(buffer.Native())

	var ret gi.Argument

	err := selectionDataTargetsIncludeRichTextFunction_Set()
	if err == nil {
		ret = selectionDataTargetsIncludeRichTextFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var selectionDataTargetsIncludeTextFunction *gi.Function
var selectionDataTargetsIncludeTextFunction_Once sync.Once

func selectionDataTargetsIncludeTextFunction_Set() error {
	var err error
	selectionDataTargetsIncludeTextFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataTargetsIncludeTextFunction, err = selectionDataStruct.InvokerNew("targets_include_text")
	})
	return err
}

// TargetsIncludeText is a representation of the C type gtk_selection_data_targets_include_text.
func (recv *SelectionData) TargetsIncludeText() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataTargetsIncludeTextFunction_Set()
	if err == nil {
		ret = selectionDataTargetsIncludeTextFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var selectionDataTargetsIncludeUriFunction *gi.Function
var selectionDataTargetsIncludeUriFunction_Once sync.Once

func selectionDataTargetsIncludeUriFunction_Set() error {
	var err error
	selectionDataTargetsIncludeUriFunction_Once.Do(func() {
		err = selectionDataStruct_Set()
		if err != nil {
			return
		}
		selectionDataTargetsIncludeUriFunction, err = selectionDataStruct.InvokerNew("targets_include_uri")
	})
	return err
}

// TargetsIncludeUri is a representation of the C type gtk_selection_data_targets_include_uri.
func (recv *SelectionData) TargetsIncludeUri() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := selectionDataTargetsIncludeUriFunction_Set()
	if err == nil {
		ret = selectionDataTargetsIncludeUriFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

// SelectionDataStruct creates an uninitialised SelectionData.
func SelectionDataStruct() *SelectionData {
	err := selectionDataStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SelectionDataNewFromNative(selectionDataStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSelectionData)
	return structGo
}
func finalizeSelectionData(obj *SelectionData) {
	selectionDataStruct.Free(obj.Native())
}

var separatorClassStruct *gi.Struct
var separatorClassStruct_Once sync.Once

func separatorClassStruct_Set() error {
	var err error
	separatorClassStruct_Once.Do(func() {
		separatorClassStruct, err = gi.StructNew("Gtk", "SeparatorClass")
	})
	return err
}

type SeparatorClass struct {
	native unsafe.Pointer
}

func SeparatorClassNewFromNative(native unsafe.Pointer) *SeparatorClass {
	err := separatorClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SeparatorClass{native: native}

	return instance
}

/*
CastToSeparatorClass down casts any arbitrary Object to SeparatorClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SeparatorClass.
*/
func CastToSeparatorClass(object *gobject.Object) *SeparatorClass {
	return SeparatorClassNewFromNative(object.Native())
}

// Equals compares this SeparatorClass with another SeparatorClass, and returns true if they represent the same Object.
func (recv *SeparatorClass) Equals(other *SeparatorClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SeparatorClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SeparatorClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(separatorClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SeparatorClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(separatorClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SeparatorClassStruct creates an uninitialised SeparatorClass.
func SeparatorClassStruct() *SeparatorClass {
	err := separatorClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SeparatorClassNewFromNative(separatorClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSeparatorClass)
	return structGo
}
func finalizeSeparatorClass(obj *SeparatorClass) {
	separatorClassStruct.Free(obj.Native())
}

var separatorMenuItemClassStruct *gi.Struct
var separatorMenuItemClassStruct_Once sync.Once

func separatorMenuItemClassStruct_Set() error {
	var err error
	separatorMenuItemClassStruct_Once.Do(func() {
		separatorMenuItemClassStruct, err = gi.StructNew("Gtk", "SeparatorMenuItemClass")
	})
	return err
}

type SeparatorMenuItemClass struct {
	native unsafe.Pointer
}

func SeparatorMenuItemClassNewFromNative(native unsafe.Pointer) *SeparatorMenuItemClass {
	err := separatorMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SeparatorMenuItemClass{native: native}

	return instance
}

/*
CastToSeparatorMenuItemClass down casts any arbitrary Object to SeparatorMenuItemClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SeparatorMenuItemClass.
*/
func CastToSeparatorMenuItemClass(object *gobject.Object) *SeparatorMenuItemClass {
	return SeparatorMenuItemClassNewFromNative(object.Native())
}

// Equals compares this SeparatorMenuItemClass with another SeparatorMenuItemClass, and returns true if they represent the same Object.
func (recv *SeparatorMenuItemClass) Equals(other *SeparatorMenuItemClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SeparatorMenuItemClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SeparatorMenuItemClass) FieldParentClass() *MenuItemClass {
	argValue := gi.StructFieldGet(separatorMenuItemClassStruct, recv.Native(), "parent_class")
	value := MenuItemClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SeparatorMenuItemClass) SetFieldParentClass(value *MenuItemClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(separatorMenuItemClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SeparatorMenuItemClassStruct creates an uninitialised SeparatorMenuItemClass.
func SeparatorMenuItemClassStruct() *SeparatorMenuItemClass {
	err := separatorMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SeparatorMenuItemClassNewFromNative(separatorMenuItemClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSeparatorMenuItemClass)
	return structGo
}
func finalizeSeparatorMenuItemClass(obj *SeparatorMenuItemClass) {
	separatorMenuItemClassStruct.Free(obj.Native())
}

var separatorPrivateStruct *gi.Struct
var separatorPrivateStruct_Once sync.Once

func separatorPrivateStruct_Set() error {
	var err error
	separatorPrivateStruct_Once.Do(func() {
		separatorPrivateStruct, err = gi.StructNew("Gtk", "SeparatorPrivate")
	})
	return err
}

type SeparatorPrivate struct {
	native unsafe.Pointer
}

func SeparatorPrivateNewFromNative(native unsafe.Pointer) *SeparatorPrivate {
	err := separatorPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SeparatorPrivate{native: native}

	return instance
}

/*
CastToSeparatorPrivate down casts any arbitrary Object to SeparatorPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SeparatorPrivate.
*/
func CastToSeparatorPrivate(object *gobject.Object) *SeparatorPrivate {
	return SeparatorPrivateNewFromNative(object.Native())
}

// Equals compares this SeparatorPrivate with another SeparatorPrivate, and returns true if they represent the same Object.
func (recv *SeparatorPrivate) Equals(other *SeparatorPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SeparatorPrivate) Native() unsafe.Pointer {
	return recv.native
}

// SeparatorPrivateStruct creates an uninitialised SeparatorPrivate.
func SeparatorPrivateStruct() *SeparatorPrivate {
	err := separatorPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SeparatorPrivateNewFromNative(separatorPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSeparatorPrivate)
	return structGo
}
func finalizeSeparatorPrivate(obj *SeparatorPrivate) {
	separatorPrivateStruct.Free(obj.Native())
}

var separatorToolItemClassStruct *gi.Struct
var separatorToolItemClassStruct_Once sync.Once

func separatorToolItemClassStruct_Set() error {
	var err error
	separatorToolItemClassStruct_Once.Do(func() {
		separatorToolItemClassStruct, err = gi.StructNew("Gtk", "SeparatorToolItemClass")
	})
	return err
}

type SeparatorToolItemClass struct {
	native unsafe.Pointer
}

func SeparatorToolItemClassNewFromNative(native unsafe.Pointer) *SeparatorToolItemClass {
	err := separatorToolItemClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SeparatorToolItemClass{native: native}

	return instance
}

/*
CastToSeparatorToolItemClass down casts any arbitrary Object to SeparatorToolItemClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SeparatorToolItemClass.
*/
func CastToSeparatorToolItemClass(object *gobject.Object) *SeparatorToolItemClass {
	return SeparatorToolItemClassNewFromNative(object.Native())
}

// Equals compares this SeparatorToolItemClass with another SeparatorToolItemClass, and returns true if they represent the same Object.
func (recv *SeparatorToolItemClass) Equals(other *SeparatorToolItemClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SeparatorToolItemClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SeparatorToolItemClass) FieldParentClass() *ToolItemClass {
	argValue := gi.StructFieldGet(separatorToolItemClassStruct, recv.Native(), "parent_class")
	value := ToolItemClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SeparatorToolItemClass) SetFieldParentClass(value *ToolItemClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(separatorToolItemClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SeparatorToolItemClassStruct creates an uninitialised SeparatorToolItemClass.
func SeparatorToolItemClassStruct() *SeparatorToolItemClass {
	err := separatorToolItemClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SeparatorToolItemClassNewFromNative(separatorToolItemClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSeparatorToolItemClass)
	return structGo
}
func finalizeSeparatorToolItemClass(obj *SeparatorToolItemClass) {
	separatorToolItemClassStruct.Free(obj.Native())
}

var separatorToolItemPrivateStruct *gi.Struct
var separatorToolItemPrivateStruct_Once sync.Once

func separatorToolItemPrivateStruct_Set() error {
	var err error
	separatorToolItemPrivateStruct_Once.Do(func() {
		separatorToolItemPrivateStruct, err = gi.StructNew("Gtk", "SeparatorToolItemPrivate")
	})
	return err
}

type SeparatorToolItemPrivate struct {
	native unsafe.Pointer
}

func SeparatorToolItemPrivateNewFromNative(native unsafe.Pointer) *SeparatorToolItemPrivate {
	err := separatorToolItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SeparatorToolItemPrivate{native: native}

	return instance
}

/*
CastToSeparatorToolItemPrivate down casts any arbitrary Object to SeparatorToolItemPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SeparatorToolItemPrivate.
*/
func CastToSeparatorToolItemPrivate(object *gobject.Object) *SeparatorToolItemPrivate {
	return SeparatorToolItemPrivateNewFromNative(object.Native())
}

// Equals compares this SeparatorToolItemPrivate with another SeparatorToolItemPrivate, and returns true if they represent the same Object.
func (recv *SeparatorToolItemPrivate) Equals(other *SeparatorToolItemPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SeparatorToolItemPrivate) Native() unsafe.Pointer {
	return recv.native
}

// SeparatorToolItemPrivateStruct creates an uninitialised SeparatorToolItemPrivate.
func SeparatorToolItemPrivateStruct() *SeparatorToolItemPrivate {
	err := separatorToolItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SeparatorToolItemPrivateNewFromNative(separatorToolItemPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSeparatorToolItemPrivate)
	return structGo
}
func finalizeSeparatorToolItemPrivate(obj *SeparatorToolItemPrivate) {
	separatorToolItemPrivateStruct.Free(obj.Native())
}

var settingsClassStruct *gi.Struct
var settingsClassStruct_Once sync.Once

func settingsClassStruct_Set() error {
	var err error
	settingsClassStruct_Once.Do(func() {
		settingsClassStruct, err = gi.StructNew("Gtk", "SettingsClass")
	})
	return err
}

type SettingsClass struct {
	native unsafe.Pointer
}

func SettingsClassNewFromNative(native unsafe.Pointer) *SettingsClass {
	err := settingsClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SettingsClass{native: native}

	return instance
}

/*
CastToSettingsClass down casts any arbitrary Object to SettingsClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SettingsClass.
*/
func CastToSettingsClass(object *gobject.Object) *SettingsClass {
	return SettingsClassNewFromNative(object.Native())
}

// Equals compares this SettingsClass with another SettingsClass, and returns true if they represent the same Object.
func (recv *SettingsClass) Equals(other *SettingsClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SettingsClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SettingsClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(settingsClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SettingsClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(settingsClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SettingsClassStruct creates an uninitialised SettingsClass.
func SettingsClassStruct() *SettingsClass {
	err := settingsClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SettingsClassNewFromNative(settingsClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSettingsClass)
	return structGo
}
func finalizeSettingsClass(obj *SettingsClass) {
	settingsClassStruct.Free(obj.Native())
}

var settingsPrivateStruct *gi.Struct
var settingsPrivateStruct_Once sync.Once

func settingsPrivateStruct_Set() error {
	var err error
	settingsPrivateStruct_Once.Do(func() {
		settingsPrivateStruct, err = gi.StructNew("Gtk", "SettingsPrivate")
	})
	return err
}

type SettingsPrivate struct {
	native unsafe.Pointer
}

func SettingsPrivateNewFromNative(native unsafe.Pointer) *SettingsPrivate {
	err := settingsPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SettingsPrivate{native: native}

	return instance
}

/*
CastToSettingsPrivate down casts any arbitrary Object to SettingsPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SettingsPrivate.
*/
func CastToSettingsPrivate(object *gobject.Object) *SettingsPrivate {
	return SettingsPrivateNewFromNative(object.Native())
}

// Equals compares this SettingsPrivate with another SettingsPrivate, and returns true if they represent the same Object.
func (recv *SettingsPrivate) Equals(other *SettingsPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SettingsPrivate) Native() unsafe.Pointer {
	return recv.native
}

// SettingsPrivateStruct creates an uninitialised SettingsPrivate.
func SettingsPrivateStruct() *SettingsPrivate {
	err := settingsPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SettingsPrivateNewFromNative(settingsPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSettingsPrivate)
	return structGo
}
func finalizeSettingsPrivate(obj *SettingsPrivate) {
	settingsPrivateStruct.Free(obj.Native())
}

var settingsValueStruct *gi.Struct
var settingsValueStruct_Once sync.Once

func settingsValueStruct_Set() error {
	var err error
	settingsValueStruct_Once.Do(func() {
		settingsValueStruct, err = gi.StructNew("Gtk", "SettingsValue")
	})
	return err
}

type SettingsValue struct {
	native unsafe.Pointer
}

func SettingsValueNewFromNative(native unsafe.Pointer) *SettingsValue {
	err := settingsValueStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SettingsValue{native: native}

	return instance
}

/*
CastToSettingsValue down casts any arbitrary Object to SettingsValue.
Exercise care, as this is a potentially dangerous function
if the Object is not a SettingsValue.
*/
func CastToSettingsValue(object *gobject.Object) *SettingsValue {
	return SettingsValueNewFromNative(object.Native())
}

// Equals compares this SettingsValue with another SettingsValue, and returns true if they represent the same Object.
func (recv *SettingsValue) Equals(other *SettingsValue) bool {
	return other.Native() == recv.Native()
}

func (recv *SettingsValue) Native() unsafe.Pointer {
	return recv.native
}

// FieldOrigin returns the C field 'origin'.
func (recv *SettingsValue) FieldOrigin() string {
	argValue := gi.StructFieldGet(settingsValueStruct, recv.Native(), "origin")
	value := argValue.String(false)
	return value
}

// SetFieldOrigin sets the value of the C field 'origin'.
func (recv *SettingsValue) SetFieldOrigin(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(settingsValueStruct, recv.Native(), "origin", argValue)
}

// FieldValue returns the C field 'value'.
func (recv *SettingsValue) FieldValue() *gobject.Value {
	argValue := gi.StructFieldGet(settingsValueStruct, recv.Native(), "value")
	value := gobject.ValueNewFromNative(argValue.Pointer())
	return value
}

// SetFieldValue sets the value of the C field 'value'.
func (recv *SettingsValue) SetFieldValue(value *gobject.Value) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(settingsValueStruct, recv.Native(), "value", argValue)
}

// SettingsValueStruct creates an uninitialised SettingsValue.
func SettingsValueStruct() *SettingsValue {
	err := settingsValueStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SettingsValueNewFromNative(settingsValueStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSettingsValue)
	return structGo
}
func finalizeSettingsValue(obj *SettingsValue) {
	settingsValueStruct.Free(obj.Native())
}

var shortcutLabelClassStruct *gi.Struct
var shortcutLabelClassStruct_Once sync.Once

func shortcutLabelClassStruct_Set() error {
	var err error
	shortcutLabelClassStruct_Once.Do(func() {
		shortcutLabelClassStruct, err = gi.StructNew("Gtk", "ShortcutLabelClass")
	})
	return err
}

type ShortcutLabelClass struct {
	native unsafe.Pointer
}

func ShortcutLabelClassNewFromNative(native unsafe.Pointer) *ShortcutLabelClass {
	err := shortcutLabelClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ShortcutLabelClass{native: native}

	return instance
}

/*
CastToShortcutLabelClass down casts any arbitrary Object to ShortcutLabelClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ShortcutLabelClass.
*/
func CastToShortcutLabelClass(object *gobject.Object) *ShortcutLabelClass {
	return ShortcutLabelClassNewFromNative(object.Native())
}

// Equals compares this ShortcutLabelClass with another ShortcutLabelClass, and returns true if they represent the same Object.
func (recv *ShortcutLabelClass) Equals(other *ShortcutLabelClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ShortcutLabelClass) Native() unsafe.Pointer {
	return recv.native
}

// ShortcutLabelClassStruct creates an uninitialised ShortcutLabelClass.
func ShortcutLabelClassStruct() *ShortcutLabelClass {
	err := shortcutLabelClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ShortcutLabelClassNewFromNative(shortcutLabelClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeShortcutLabelClass)
	return structGo
}
func finalizeShortcutLabelClass(obj *ShortcutLabelClass) {
	shortcutLabelClassStruct.Free(obj.Native())
}

var shortcutsGroupClassStruct *gi.Struct
var shortcutsGroupClassStruct_Once sync.Once

func shortcutsGroupClassStruct_Set() error {
	var err error
	shortcutsGroupClassStruct_Once.Do(func() {
		shortcutsGroupClassStruct, err = gi.StructNew("Gtk", "ShortcutsGroupClass")
	})
	return err
}

type ShortcutsGroupClass struct {
	native unsafe.Pointer
}

func ShortcutsGroupClassNewFromNative(native unsafe.Pointer) *ShortcutsGroupClass {
	err := shortcutsGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ShortcutsGroupClass{native: native}

	return instance
}

/*
CastToShortcutsGroupClass down casts any arbitrary Object to ShortcutsGroupClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ShortcutsGroupClass.
*/
func CastToShortcutsGroupClass(object *gobject.Object) *ShortcutsGroupClass {
	return ShortcutsGroupClassNewFromNative(object.Native())
}

// Equals compares this ShortcutsGroupClass with another ShortcutsGroupClass, and returns true if they represent the same Object.
func (recv *ShortcutsGroupClass) Equals(other *ShortcutsGroupClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ShortcutsGroupClass) Native() unsafe.Pointer {
	return recv.native
}

// ShortcutsGroupClassStruct creates an uninitialised ShortcutsGroupClass.
func ShortcutsGroupClassStruct() *ShortcutsGroupClass {
	err := shortcutsGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ShortcutsGroupClassNewFromNative(shortcutsGroupClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeShortcutsGroupClass)
	return structGo
}
func finalizeShortcutsGroupClass(obj *ShortcutsGroupClass) {
	shortcutsGroupClassStruct.Free(obj.Native())
}

var shortcutsSectionClassStruct *gi.Struct
var shortcutsSectionClassStruct_Once sync.Once

func shortcutsSectionClassStruct_Set() error {
	var err error
	shortcutsSectionClassStruct_Once.Do(func() {
		shortcutsSectionClassStruct, err = gi.StructNew("Gtk", "ShortcutsSectionClass")
	})
	return err
}

type ShortcutsSectionClass struct {
	native unsafe.Pointer
}

func ShortcutsSectionClassNewFromNative(native unsafe.Pointer) *ShortcutsSectionClass {
	err := shortcutsSectionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ShortcutsSectionClass{native: native}

	return instance
}

/*
CastToShortcutsSectionClass down casts any arbitrary Object to ShortcutsSectionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ShortcutsSectionClass.
*/
func CastToShortcutsSectionClass(object *gobject.Object) *ShortcutsSectionClass {
	return ShortcutsSectionClassNewFromNative(object.Native())
}

// Equals compares this ShortcutsSectionClass with another ShortcutsSectionClass, and returns true if they represent the same Object.
func (recv *ShortcutsSectionClass) Equals(other *ShortcutsSectionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ShortcutsSectionClass) Native() unsafe.Pointer {
	return recv.native
}

// ShortcutsSectionClassStruct creates an uninitialised ShortcutsSectionClass.
func ShortcutsSectionClassStruct() *ShortcutsSectionClass {
	err := shortcutsSectionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ShortcutsSectionClassNewFromNative(shortcutsSectionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeShortcutsSectionClass)
	return structGo
}
func finalizeShortcutsSectionClass(obj *ShortcutsSectionClass) {
	shortcutsSectionClassStruct.Free(obj.Native())
}

var shortcutsShortcutClassStruct *gi.Struct
var shortcutsShortcutClassStruct_Once sync.Once

func shortcutsShortcutClassStruct_Set() error {
	var err error
	shortcutsShortcutClassStruct_Once.Do(func() {
		shortcutsShortcutClassStruct, err = gi.StructNew("Gtk", "ShortcutsShortcutClass")
	})
	return err
}

type ShortcutsShortcutClass struct {
	native unsafe.Pointer
}

func ShortcutsShortcutClassNewFromNative(native unsafe.Pointer) *ShortcutsShortcutClass {
	err := shortcutsShortcutClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ShortcutsShortcutClass{native: native}

	return instance
}

/*
CastToShortcutsShortcutClass down casts any arbitrary Object to ShortcutsShortcutClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ShortcutsShortcutClass.
*/
func CastToShortcutsShortcutClass(object *gobject.Object) *ShortcutsShortcutClass {
	return ShortcutsShortcutClassNewFromNative(object.Native())
}

// Equals compares this ShortcutsShortcutClass with another ShortcutsShortcutClass, and returns true if they represent the same Object.
func (recv *ShortcutsShortcutClass) Equals(other *ShortcutsShortcutClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ShortcutsShortcutClass) Native() unsafe.Pointer {
	return recv.native
}

// ShortcutsShortcutClassStruct creates an uninitialised ShortcutsShortcutClass.
func ShortcutsShortcutClassStruct() *ShortcutsShortcutClass {
	err := shortcutsShortcutClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ShortcutsShortcutClassNewFromNative(shortcutsShortcutClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeShortcutsShortcutClass)
	return structGo
}
func finalizeShortcutsShortcutClass(obj *ShortcutsShortcutClass) {
	shortcutsShortcutClassStruct.Free(obj.Native())
}

var shortcutsWindowClassStruct *gi.Struct
var shortcutsWindowClassStruct_Once sync.Once

func shortcutsWindowClassStruct_Set() error {
	var err error
	shortcutsWindowClassStruct_Once.Do(func() {
		shortcutsWindowClassStruct, err = gi.StructNew("Gtk", "ShortcutsWindowClass")
	})
	return err
}

type ShortcutsWindowClass struct {
	native unsafe.Pointer
}

func ShortcutsWindowClassNewFromNative(native unsafe.Pointer) *ShortcutsWindowClass {
	err := shortcutsWindowClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ShortcutsWindowClass{native: native}

	return instance
}

/*
CastToShortcutsWindowClass down casts any arbitrary Object to ShortcutsWindowClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ShortcutsWindowClass.
*/
func CastToShortcutsWindowClass(object *gobject.Object) *ShortcutsWindowClass {
	return ShortcutsWindowClassNewFromNative(object.Native())
}

// Equals compares this ShortcutsWindowClass with another ShortcutsWindowClass, and returns true if they represent the same Object.
func (recv *ShortcutsWindowClass) Equals(other *ShortcutsWindowClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ShortcutsWindowClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ShortcutsWindowClass) FieldParentClass() *WindowClass {
	argValue := gi.StructFieldGet(shortcutsWindowClassStruct, recv.Native(), "parent_class")
	value := WindowClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ShortcutsWindowClass) SetFieldParentClass(value *WindowClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(shortcutsWindowClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'close' : for field getter : missing Type

// UNSUPPORTED : C value 'close' : for field setter : missing Type

// UNSUPPORTED : C value 'search' : for field getter : missing Type

// UNSUPPORTED : C value 'search' : for field setter : missing Type

// ShortcutsWindowClassStruct creates an uninitialised ShortcutsWindowClass.
func ShortcutsWindowClassStruct() *ShortcutsWindowClass {
	err := shortcutsWindowClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ShortcutsWindowClassNewFromNative(shortcutsWindowClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeShortcutsWindowClass)
	return structGo
}
func finalizeShortcutsWindowClass(obj *ShortcutsWindowClass) {
	shortcutsWindowClassStruct.Free(obj.Native())
}

var sizeGroupClassStruct *gi.Struct
var sizeGroupClassStruct_Once sync.Once

func sizeGroupClassStruct_Set() error {
	var err error
	sizeGroupClassStruct_Once.Do(func() {
		sizeGroupClassStruct, err = gi.StructNew("Gtk", "SizeGroupClass")
	})
	return err
}

type SizeGroupClass struct {
	native unsafe.Pointer
}

func SizeGroupClassNewFromNative(native unsafe.Pointer) *SizeGroupClass {
	err := sizeGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SizeGroupClass{native: native}

	return instance
}

/*
CastToSizeGroupClass down casts any arbitrary Object to SizeGroupClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SizeGroupClass.
*/
func CastToSizeGroupClass(object *gobject.Object) *SizeGroupClass {
	return SizeGroupClassNewFromNative(object.Native())
}

// Equals compares this SizeGroupClass with another SizeGroupClass, and returns true if they represent the same Object.
func (recv *SizeGroupClass) Equals(other *SizeGroupClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SizeGroupClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SizeGroupClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(sizeGroupClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SizeGroupClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(sizeGroupClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SizeGroupClassStruct creates an uninitialised SizeGroupClass.
func SizeGroupClassStruct() *SizeGroupClass {
	err := sizeGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SizeGroupClassNewFromNative(sizeGroupClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSizeGroupClass)
	return structGo
}
func finalizeSizeGroupClass(obj *SizeGroupClass) {
	sizeGroupClassStruct.Free(obj.Native())
}

var sizeGroupPrivateStruct *gi.Struct
var sizeGroupPrivateStruct_Once sync.Once

func sizeGroupPrivateStruct_Set() error {
	var err error
	sizeGroupPrivateStruct_Once.Do(func() {
		sizeGroupPrivateStruct, err = gi.StructNew("Gtk", "SizeGroupPrivate")
	})
	return err
}

type SizeGroupPrivate struct {
	native unsafe.Pointer
}

func SizeGroupPrivateNewFromNative(native unsafe.Pointer) *SizeGroupPrivate {
	err := sizeGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SizeGroupPrivate{native: native}

	return instance
}

/*
CastToSizeGroupPrivate down casts any arbitrary Object to SizeGroupPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SizeGroupPrivate.
*/
func CastToSizeGroupPrivate(object *gobject.Object) *SizeGroupPrivate {
	return SizeGroupPrivateNewFromNative(object.Native())
}

// Equals compares this SizeGroupPrivate with another SizeGroupPrivate, and returns true if they represent the same Object.
func (recv *SizeGroupPrivate) Equals(other *SizeGroupPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SizeGroupPrivate) Native() unsafe.Pointer {
	return recv.native
}

// SizeGroupPrivateStruct creates an uninitialised SizeGroupPrivate.
func SizeGroupPrivateStruct() *SizeGroupPrivate {
	err := sizeGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SizeGroupPrivateNewFromNative(sizeGroupPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSizeGroupPrivate)
	return structGo
}
func finalizeSizeGroupPrivate(obj *SizeGroupPrivate) {
	sizeGroupPrivateStruct.Free(obj.Native())
}

var socketClassStruct *gi.Struct
var socketClassStruct_Once sync.Once

func socketClassStruct_Set() error {
	var err error
	socketClassStruct_Once.Do(func() {
		socketClassStruct, err = gi.StructNew("Gtk", "SocketClass")
	})
	return err
}

type SocketClass struct {
	native unsafe.Pointer
}

func SocketClassNewFromNative(native unsafe.Pointer) *SocketClass {
	err := socketClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SocketClass{native: native}

	return instance
}

/*
CastToSocketClass down casts any arbitrary Object to SocketClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SocketClass.
*/
func CastToSocketClass(object *gobject.Object) *SocketClass {
	return SocketClassNewFromNative(object.Native())
}

// Equals compares this SocketClass with another SocketClass, and returns true if they represent the same Object.
func (recv *SocketClass) Equals(other *SocketClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SocketClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SocketClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(socketClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SocketClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(socketClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'plug_added' : for field getter : missing Type

// UNSUPPORTED : C value 'plug_added' : for field setter : missing Type

// UNSUPPORTED : C value 'plug_removed' : for field getter : missing Type

// UNSUPPORTED : C value 'plug_removed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SocketClassStruct creates an uninitialised SocketClass.
func SocketClassStruct() *SocketClass {
	err := socketClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SocketClassNewFromNative(socketClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSocketClass)
	return structGo
}
func finalizeSocketClass(obj *SocketClass) {
	socketClassStruct.Free(obj.Native())
}

var socketPrivateStruct *gi.Struct
var socketPrivateStruct_Once sync.Once

func socketPrivateStruct_Set() error {
	var err error
	socketPrivateStruct_Once.Do(func() {
		socketPrivateStruct, err = gi.StructNew("Gtk", "SocketPrivate")
	})
	return err
}

type SocketPrivate struct {
	native unsafe.Pointer
}

func SocketPrivateNewFromNative(native unsafe.Pointer) *SocketPrivate {
	err := socketPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SocketPrivate{native: native}

	return instance
}

/*
CastToSocketPrivate down casts any arbitrary Object to SocketPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SocketPrivate.
*/
func CastToSocketPrivate(object *gobject.Object) *SocketPrivate {
	return SocketPrivateNewFromNative(object.Native())
}

// Equals compares this SocketPrivate with another SocketPrivate, and returns true if they represent the same Object.
func (recv *SocketPrivate) Equals(other *SocketPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SocketPrivate) Native() unsafe.Pointer {
	return recv.native
}

// SocketPrivateStruct creates an uninitialised SocketPrivate.
func SocketPrivateStruct() *SocketPrivate {
	err := socketPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SocketPrivateNewFromNative(socketPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSocketPrivate)
	return structGo
}
func finalizeSocketPrivate(obj *SocketPrivate) {
	socketPrivateStruct.Free(obj.Native())
}

var spinButtonAccessibleClassStruct *gi.Struct
var spinButtonAccessibleClassStruct_Once sync.Once

func spinButtonAccessibleClassStruct_Set() error {
	var err error
	spinButtonAccessibleClassStruct_Once.Do(func() {
		spinButtonAccessibleClassStruct, err = gi.StructNew("Gtk", "SpinButtonAccessibleClass")
	})
	return err
}

type SpinButtonAccessibleClass struct {
	native unsafe.Pointer
}

func SpinButtonAccessibleClassNewFromNative(native unsafe.Pointer) *SpinButtonAccessibleClass {
	err := spinButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SpinButtonAccessibleClass{native: native}

	return instance
}

/*
CastToSpinButtonAccessibleClass down casts any arbitrary Object to SpinButtonAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SpinButtonAccessibleClass.
*/
func CastToSpinButtonAccessibleClass(object *gobject.Object) *SpinButtonAccessibleClass {
	return SpinButtonAccessibleClassNewFromNative(object.Native())
}

// Equals compares this SpinButtonAccessibleClass with another SpinButtonAccessibleClass, and returns true if they represent the same Object.
func (recv *SpinButtonAccessibleClass) Equals(other *SpinButtonAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SpinButtonAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SpinButtonAccessibleClass) FieldParentClass() *EntryAccessibleClass {
	argValue := gi.StructFieldGet(spinButtonAccessibleClassStruct, recv.Native(), "parent_class")
	value := EntryAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SpinButtonAccessibleClass) SetFieldParentClass(value *EntryAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(spinButtonAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// SpinButtonAccessibleClassStruct creates an uninitialised SpinButtonAccessibleClass.
func SpinButtonAccessibleClassStruct() *SpinButtonAccessibleClass {
	err := spinButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SpinButtonAccessibleClassNewFromNative(spinButtonAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSpinButtonAccessibleClass)
	return structGo
}
func finalizeSpinButtonAccessibleClass(obj *SpinButtonAccessibleClass) {
	spinButtonAccessibleClassStruct.Free(obj.Native())
}

var spinButtonAccessiblePrivateStruct *gi.Struct
var spinButtonAccessiblePrivateStruct_Once sync.Once

func spinButtonAccessiblePrivateStruct_Set() error {
	var err error
	spinButtonAccessiblePrivateStruct_Once.Do(func() {
		spinButtonAccessiblePrivateStruct, err = gi.StructNew("Gtk", "SpinButtonAccessiblePrivate")
	})
	return err
}

type SpinButtonAccessiblePrivate struct {
	native unsafe.Pointer
}

func SpinButtonAccessiblePrivateNewFromNative(native unsafe.Pointer) *SpinButtonAccessiblePrivate {
	err := spinButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SpinButtonAccessiblePrivate{native: native}

	return instance
}

/*
CastToSpinButtonAccessiblePrivate down casts any arbitrary Object to SpinButtonAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SpinButtonAccessiblePrivate.
*/
func CastToSpinButtonAccessiblePrivate(object *gobject.Object) *SpinButtonAccessiblePrivate {
	return SpinButtonAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this SpinButtonAccessiblePrivate with another SpinButtonAccessiblePrivate, and returns true if they represent the same Object.
func (recv *SpinButtonAccessiblePrivate) Equals(other *SpinButtonAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SpinButtonAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// SpinButtonAccessiblePrivateStruct creates an uninitialised SpinButtonAccessiblePrivate.
func SpinButtonAccessiblePrivateStruct() *SpinButtonAccessiblePrivate {
	err := spinButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SpinButtonAccessiblePrivateNewFromNative(spinButtonAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSpinButtonAccessiblePrivate)
	return structGo
}
func finalizeSpinButtonAccessiblePrivate(obj *SpinButtonAccessiblePrivate) {
	spinButtonAccessiblePrivateStruct.Free(obj.Native())
}

var spinButtonClassStruct *gi.Struct
var spinButtonClassStruct_Once sync.Once

func spinButtonClassStruct_Set() error {
	var err error
	spinButtonClassStruct_Once.Do(func() {
		spinButtonClassStruct, err = gi.StructNew("Gtk", "SpinButtonClass")
	})
	return err
}

type SpinButtonClass struct {
	native unsafe.Pointer
}

func SpinButtonClassNewFromNative(native unsafe.Pointer) *SpinButtonClass {
	err := spinButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SpinButtonClass{native: native}

	return instance
}

/*
CastToSpinButtonClass down casts any arbitrary Object to SpinButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SpinButtonClass.
*/
func CastToSpinButtonClass(object *gobject.Object) *SpinButtonClass {
	return SpinButtonClassNewFromNative(object.Native())
}

// Equals compares this SpinButtonClass with another SpinButtonClass, and returns true if they represent the same Object.
func (recv *SpinButtonClass) Equals(other *SpinButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SpinButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SpinButtonClass) FieldParentClass() *EntryClass {
	argValue := gi.StructFieldGet(spinButtonClassStruct, recv.Native(), "parent_class")
	value := EntryClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SpinButtonClass) SetFieldParentClass(value *EntryClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(spinButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'input' : for field getter : missing Type

// UNSUPPORTED : C value 'input' : for field setter : missing Type

// UNSUPPORTED : C value 'output' : for field getter : missing Type

// UNSUPPORTED : C value 'output' : for field setter : missing Type

// UNSUPPORTED : C value 'value_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'value_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'change_value' : for field getter : missing Type

// UNSUPPORTED : C value 'change_value' : for field setter : missing Type

// UNSUPPORTED : C value 'wrapped' : for field getter : missing Type

// UNSUPPORTED : C value 'wrapped' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SpinButtonClassStruct creates an uninitialised SpinButtonClass.
func SpinButtonClassStruct() *SpinButtonClass {
	err := spinButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SpinButtonClassNewFromNative(spinButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSpinButtonClass)
	return structGo
}
func finalizeSpinButtonClass(obj *SpinButtonClass) {
	spinButtonClassStruct.Free(obj.Native())
}

var spinButtonPrivateStruct *gi.Struct
var spinButtonPrivateStruct_Once sync.Once

func spinButtonPrivateStruct_Set() error {
	var err error
	spinButtonPrivateStruct_Once.Do(func() {
		spinButtonPrivateStruct, err = gi.StructNew("Gtk", "SpinButtonPrivate")
	})
	return err
}

type SpinButtonPrivate struct {
	native unsafe.Pointer
}

func SpinButtonPrivateNewFromNative(native unsafe.Pointer) *SpinButtonPrivate {
	err := spinButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SpinButtonPrivate{native: native}

	return instance
}

/*
CastToSpinButtonPrivate down casts any arbitrary Object to SpinButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SpinButtonPrivate.
*/
func CastToSpinButtonPrivate(object *gobject.Object) *SpinButtonPrivate {
	return SpinButtonPrivateNewFromNative(object.Native())
}

// Equals compares this SpinButtonPrivate with another SpinButtonPrivate, and returns true if they represent the same Object.
func (recv *SpinButtonPrivate) Equals(other *SpinButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SpinButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// SpinButtonPrivateStruct creates an uninitialised SpinButtonPrivate.
func SpinButtonPrivateStruct() *SpinButtonPrivate {
	err := spinButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SpinButtonPrivateNewFromNative(spinButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSpinButtonPrivate)
	return structGo
}
func finalizeSpinButtonPrivate(obj *SpinButtonPrivate) {
	spinButtonPrivateStruct.Free(obj.Native())
}

var spinnerAccessibleClassStruct *gi.Struct
var spinnerAccessibleClassStruct_Once sync.Once

func spinnerAccessibleClassStruct_Set() error {
	var err error
	spinnerAccessibleClassStruct_Once.Do(func() {
		spinnerAccessibleClassStruct, err = gi.StructNew("Gtk", "SpinnerAccessibleClass")
	})
	return err
}

type SpinnerAccessibleClass struct {
	native unsafe.Pointer
}

func SpinnerAccessibleClassNewFromNative(native unsafe.Pointer) *SpinnerAccessibleClass {
	err := spinnerAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SpinnerAccessibleClass{native: native}

	return instance
}

/*
CastToSpinnerAccessibleClass down casts any arbitrary Object to SpinnerAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SpinnerAccessibleClass.
*/
func CastToSpinnerAccessibleClass(object *gobject.Object) *SpinnerAccessibleClass {
	return SpinnerAccessibleClassNewFromNative(object.Native())
}

// Equals compares this SpinnerAccessibleClass with another SpinnerAccessibleClass, and returns true if they represent the same Object.
func (recv *SpinnerAccessibleClass) Equals(other *SpinnerAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SpinnerAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SpinnerAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(spinnerAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SpinnerAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(spinnerAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// SpinnerAccessibleClassStruct creates an uninitialised SpinnerAccessibleClass.
func SpinnerAccessibleClassStruct() *SpinnerAccessibleClass {
	err := spinnerAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SpinnerAccessibleClassNewFromNative(spinnerAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSpinnerAccessibleClass)
	return structGo
}
func finalizeSpinnerAccessibleClass(obj *SpinnerAccessibleClass) {
	spinnerAccessibleClassStruct.Free(obj.Native())
}

var spinnerAccessiblePrivateStruct *gi.Struct
var spinnerAccessiblePrivateStruct_Once sync.Once

func spinnerAccessiblePrivateStruct_Set() error {
	var err error
	spinnerAccessiblePrivateStruct_Once.Do(func() {
		spinnerAccessiblePrivateStruct, err = gi.StructNew("Gtk", "SpinnerAccessiblePrivate")
	})
	return err
}

type SpinnerAccessiblePrivate struct {
	native unsafe.Pointer
}

func SpinnerAccessiblePrivateNewFromNative(native unsafe.Pointer) *SpinnerAccessiblePrivate {
	err := spinnerAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SpinnerAccessiblePrivate{native: native}

	return instance
}

/*
CastToSpinnerAccessiblePrivate down casts any arbitrary Object to SpinnerAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SpinnerAccessiblePrivate.
*/
func CastToSpinnerAccessiblePrivate(object *gobject.Object) *SpinnerAccessiblePrivate {
	return SpinnerAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this SpinnerAccessiblePrivate with another SpinnerAccessiblePrivate, and returns true if they represent the same Object.
func (recv *SpinnerAccessiblePrivate) Equals(other *SpinnerAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SpinnerAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// SpinnerAccessiblePrivateStruct creates an uninitialised SpinnerAccessiblePrivate.
func SpinnerAccessiblePrivateStruct() *SpinnerAccessiblePrivate {
	err := spinnerAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SpinnerAccessiblePrivateNewFromNative(spinnerAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSpinnerAccessiblePrivate)
	return structGo
}
func finalizeSpinnerAccessiblePrivate(obj *SpinnerAccessiblePrivate) {
	spinnerAccessiblePrivateStruct.Free(obj.Native())
}

var spinnerClassStruct *gi.Struct
var spinnerClassStruct_Once sync.Once

func spinnerClassStruct_Set() error {
	var err error
	spinnerClassStruct_Once.Do(func() {
		spinnerClassStruct, err = gi.StructNew("Gtk", "SpinnerClass")
	})
	return err
}

type SpinnerClass struct {
	native unsafe.Pointer
}

func SpinnerClassNewFromNative(native unsafe.Pointer) *SpinnerClass {
	err := spinnerClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SpinnerClass{native: native}

	return instance
}

/*
CastToSpinnerClass down casts any arbitrary Object to SpinnerClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SpinnerClass.
*/
func CastToSpinnerClass(object *gobject.Object) *SpinnerClass {
	return SpinnerClassNewFromNative(object.Native())
}

// Equals compares this SpinnerClass with another SpinnerClass, and returns true if they represent the same Object.
func (recv *SpinnerClass) Equals(other *SpinnerClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SpinnerClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SpinnerClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(spinnerClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SpinnerClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(spinnerClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// SpinnerClassStruct creates an uninitialised SpinnerClass.
func SpinnerClassStruct() *SpinnerClass {
	err := spinnerClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SpinnerClassNewFromNative(spinnerClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSpinnerClass)
	return structGo
}
func finalizeSpinnerClass(obj *SpinnerClass) {
	spinnerClassStruct.Free(obj.Native())
}

var spinnerPrivateStruct *gi.Struct
var spinnerPrivateStruct_Once sync.Once

func spinnerPrivateStruct_Set() error {
	var err error
	spinnerPrivateStruct_Once.Do(func() {
		spinnerPrivateStruct, err = gi.StructNew("Gtk", "SpinnerPrivate")
	})
	return err
}

type SpinnerPrivate struct {
	native unsafe.Pointer
}

func SpinnerPrivateNewFromNative(native unsafe.Pointer) *SpinnerPrivate {
	err := spinnerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SpinnerPrivate{native: native}

	return instance
}

/*
CastToSpinnerPrivate down casts any arbitrary Object to SpinnerPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SpinnerPrivate.
*/
func CastToSpinnerPrivate(object *gobject.Object) *SpinnerPrivate {
	return SpinnerPrivateNewFromNative(object.Native())
}

// Equals compares this SpinnerPrivate with another SpinnerPrivate, and returns true if they represent the same Object.
func (recv *SpinnerPrivate) Equals(other *SpinnerPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SpinnerPrivate) Native() unsafe.Pointer {
	return recv.native
}

// SpinnerPrivateStruct creates an uninitialised SpinnerPrivate.
func SpinnerPrivateStruct() *SpinnerPrivate {
	err := spinnerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SpinnerPrivateNewFromNative(spinnerPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSpinnerPrivate)
	return structGo
}
func finalizeSpinnerPrivate(obj *SpinnerPrivate) {
	spinnerPrivateStruct.Free(obj.Native())
}

var stackAccessibleClassStruct *gi.Struct
var stackAccessibleClassStruct_Once sync.Once

func stackAccessibleClassStruct_Set() error {
	var err error
	stackAccessibleClassStruct_Once.Do(func() {
		stackAccessibleClassStruct, err = gi.StructNew("Gtk", "StackAccessibleClass")
	})
	return err
}

type StackAccessibleClass struct {
	native unsafe.Pointer
}

func StackAccessibleClassNewFromNative(native unsafe.Pointer) *StackAccessibleClass {
	err := stackAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StackAccessibleClass{native: native}

	return instance
}

/*
CastToStackAccessibleClass down casts any arbitrary Object to StackAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StackAccessibleClass.
*/
func CastToStackAccessibleClass(object *gobject.Object) *StackAccessibleClass {
	return StackAccessibleClassNewFromNative(object.Native())
}

// Equals compares this StackAccessibleClass with another StackAccessibleClass, and returns true if they represent the same Object.
func (recv *StackAccessibleClass) Equals(other *StackAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StackAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StackAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(stackAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StackAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(stackAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// StackAccessibleClassStruct creates an uninitialised StackAccessibleClass.
func StackAccessibleClassStruct() *StackAccessibleClass {
	err := stackAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StackAccessibleClassNewFromNative(stackAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStackAccessibleClass)
	return structGo
}
func finalizeStackAccessibleClass(obj *StackAccessibleClass) {
	stackAccessibleClassStruct.Free(obj.Native())
}

var stackClassStruct *gi.Struct
var stackClassStruct_Once sync.Once

func stackClassStruct_Set() error {
	var err error
	stackClassStruct_Once.Do(func() {
		stackClassStruct, err = gi.StructNew("Gtk", "StackClass")
	})
	return err
}

type StackClass struct {
	native unsafe.Pointer
}

func StackClassNewFromNative(native unsafe.Pointer) *StackClass {
	err := stackClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StackClass{native: native}

	return instance
}

/*
CastToStackClass down casts any arbitrary Object to StackClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StackClass.
*/
func CastToStackClass(object *gobject.Object) *StackClass {
	return StackClassNewFromNative(object.Native())
}

// Equals compares this StackClass with another StackClass, and returns true if they represent the same Object.
func (recv *StackClass) Equals(other *StackClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StackClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StackClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(stackClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StackClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(stackClassStruct, recv.Native(), "parent_class", argValue)
}

// StackClassStruct creates an uninitialised StackClass.
func StackClassStruct() *StackClass {
	err := stackClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StackClassNewFromNative(stackClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStackClass)
	return structGo
}
func finalizeStackClass(obj *StackClass) {
	stackClassStruct.Free(obj.Native())
}

var stackSidebarClassStruct *gi.Struct
var stackSidebarClassStruct_Once sync.Once

func stackSidebarClassStruct_Set() error {
	var err error
	stackSidebarClassStruct_Once.Do(func() {
		stackSidebarClassStruct, err = gi.StructNew("Gtk", "StackSidebarClass")
	})
	return err
}

type StackSidebarClass struct {
	native unsafe.Pointer
}

func StackSidebarClassNewFromNative(native unsafe.Pointer) *StackSidebarClass {
	err := stackSidebarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StackSidebarClass{native: native}

	return instance
}

/*
CastToStackSidebarClass down casts any arbitrary Object to StackSidebarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StackSidebarClass.
*/
func CastToStackSidebarClass(object *gobject.Object) *StackSidebarClass {
	return StackSidebarClassNewFromNative(object.Native())
}

// Equals compares this StackSidebarClass with another StackSidebarClass, and returns true if they represent the same Object.
func (recv *StackSidebarClass) Equals(other *StackSidebarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StackSidebarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StackSidebarClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(stackSidebarClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StackSidebarClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(stackSidebarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// StackSidebarClassStruct creates an uninitialised StackSidebarClass.
func StackSidebarClassStruct() *StackSidebarClass {
	err := stackSidebarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StackSidebarClassNewFromNative(stackSidebarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStackSidebarClass)
	return structGo
}
func finalizeStackSidebarClass(obj *StackSidebarClass) {
	stackSidebarClassStruct.Free(obj.Native())
}

var stackSidebarPrivateStruct *gi.Struct
var stackSidebarPrivateStruct_Once sync.Once

func stackSidebarPrivateStruct_Set() error {
	var err error
	stackSidebarPrivateStruct_Once.Do(func() {
		stackSidebarPrivateStruct, err = gi.StructNew("Gtk", "StackSidebarPrivate")
	})
	return err
}

type StackSidebarPrivate struct {
	native unsafe.Pointer
}

func StackSidebarPrivateNewFromNative(native unsafe.Pointer) *StackSidebarPrivate {
	err := stackSidebarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StackSidebarPrivate{native: native}

	return instance
}

/*
CastToStackSidebarPrivate down casts any arbitrary Object to StackSidebarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a StackSidebarPrivate.
*/
func CastToStackSidebarPrivate(object *gobject.Object) *StackSidebarPrivate {
	return StackSidebarPrivateNewFromNative(object.Native())
}

// Equals compares this StackSidebarPrivate with another StackSidebarPrivate, and returns true if they represent the same Object.
func (recv *StackSidebarPrivate) Equals(other *StackSidebarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *StackSidebarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// StackSidebarPrivateStruct creates an uninitialised StackSidebarPrivate.
func StackSidebarPrivateStruct() *StackSidebarPrivate {
	err := stackSidebarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StackSidebarPrivateNewFromNative(stackSidebarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStackSidebarPrivate)
	return structGo
}
func finalizeStackSidebarPrivate(obj *StackSidebarPrivate) {
	stackSidebarPrivateStruct.Free(obj.Native())
}

var stackSwitcherClassStruct *gi.Struct
var stackSwitcherClassStruct_Once sync.Once

func stackSwitcherClassStruct_Set() error {
	var err error
	stackSwitcherClassStruct_Once.Do(func() {
		stackSwitcherClassStruct, err = gi.StructNew("Gtk", "StackSwitcherClass")
	})
	return err
}

type StackSwitcherClass struct {
	native unsafe.Pointer
}

func StackSwitcherClassNewFromNative(native unsafe.Pointer) *StackSwitcherClass {
	err := stackSwitcherClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StackSwitcherClass{native: native}

	return instance
}

/*
CastToStackSwitcherClass down casts any arbitrary Object to StackSwitcherClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StackSwitcherClass.
*/
func CastToStackSwitcherClass(object *gobject.Object) *StackSwitcherClass {
	return StackSwitcherClassNewFromNative(object.Native())
}

// Equals compares this StackSwitcherClass with another StackSwitcherClass, and returns true if they represent the same Object.
func (recv *StackSwitcherClass) Equals(other *StackSwitcherClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StackSwitcherClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StackSwitcherClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(stackSwitcherClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StackSwitcherClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(stackSwitcherClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// StackSwitcherClassStruct creates an uninitialised StackSwitcherClass.
func StackSwitcherClassStruct() *StackSwitcherClass {
	err := stackSwitcherClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StackSwitcherClassNewFromNative(stackSwitcherClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStackSwitcherClass)
	return structGo
}
func finalizeStackSwitcherClass(obj *StackSwitcherClass) {
	stackSwitcherClassStruct.Free(obj.Native())
}

var statusIconClassStruct *gi.Struct
var statusIconClassStruct_Once sync.Once

func statusIconClassStruct_Set() error {
	var err error
	statusIconClassStruct_Once.Do(func() {
		statusIconClassStruct, err = gi.StructNew("Gtk", "StatusIconClass")
	})
	return err
}

type StatusIconClass struct {
	native unsafe.Pointer
}

func StatusIconClassNewFromNative(native unsafe.Pointer) *StatusIconClass {
	err := statusIconClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StatusIconClass{native: native}

	return instance
}

/*
CastToStatusIconClass down casts any arbitrary Object to StatusIconClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StatusIconClass.
*/
func CastToStatusIconClass(object *gobject.Object) *StatusIconClass {
	return StatusIconClassNewFromNative(object.Native())
}

// Equals compares this StatusIconClass with another StatusIconClass, and returns true if they represent the same Object.
func (recv *StatusIconClass) Equals(other *StatusIconClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StatusIconClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StatusIconClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(statusIconClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StatusIconClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(statusIconClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value 'popup_menu' : for field getter : missing Type

// UNSUPPORTED : C value 'popup_menu' : for field setter : missing Type

// UNSUPPORTED : C value 'size_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'size_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'button_press_event' : for field getter : missing Type

// UNSUPPORTED : C value 'button_press_event' : for field setter : missing Type

// UNSUPPORTED : C value 'button_release_event' : for field getter : missing Type

// UNSUPPORTED : C value 'button_release_event' : for field setter : missing Type

// UNSUPPORTED : C value 'scroll_event' : for field getter : missing Type

// UNSUPPORTED : C value 'scroll_event' : for field setter : missing Type

// UNSUPPORTED : C value 'query_tooltip' : for field getter : missing Type

// UNSUPPORTED : C value 'query_tooltip' : for field setter : missing Type

// UNSUPPORTED : C value '__gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '__gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '__gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '__gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '__gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '__gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '__gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '__gtk_reserved4' : for field setter : missing Type

// StatusIconClassStruct creates an uninitialised StatusIconClass.
func StatusIconClassStruct() *StatusIconClass {
	err := statusIconClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StatusIconClassNewFromNative(statusIconClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStatusIconClass)
	return structGo
}
func finalizeStatusIconClass(obj *StatusIconClass) {
	statusIconClassStruct.Free(obj.Native())
}

var statusIconPrivateStruct *gi.Struct
var statusIconPrivateStruct_Once sync.Once

func statusIconPrivateStruct_Set() error {
	var err error
	statusIconPrivateStruct_Once.Do(func() {
		statusIconPrivateStruct, err = gi.StructNew("Gtk", "StatusIconPrivate")
	})
	return err
}

type StatusIconPrivate struct {
	native unsafe.Pointer
}

func StatusIconPrivateNewFromNative(native unsafe.Pointer) *StatusIconPrivate {
	err := statusIconPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StatusIconPrivate{native: native}

	return instance
}

/*
CastToStatusIconPrivate down casts any arbitrary Object to StatusIconPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a StatusIconPrivate.
*/
func CastToStatusIconPrivate(object *gobject.Object) *StatusIconPrivate {
	return StatusIconPrivateNewFromNative(object.Native())
}

// Equals compares this StatusIconPrivate with another StatusIconPrivate, and returns true if they represent the same Object.
func (recv *StatusIconPrivate) Equals(other *StatusIconPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *StatusIconPrivate) Native() unsafe.Pointer {
	return recv.native
}

// StatusIconPrivateStruct creates an uninitialised StatusIconPrivate.
func StatusIconPrivateStruct() *StatusIconPrivate {
	err := statusIconPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StatusIconPrivateNewFromNative(statusIconPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStatusIconPrivate)
	return structGo
}
func finalizeStatusIconPrivate(obj *StatusIconPrivate) {
	statusIconPrivateStruct.Free(obj.Native())
}

var statusbarAccessibleClassStruct *gi.Struct
var statusbarAccessibleClassStruct_Once sync.Once

func statusbarAccessibleClassStruct_Set() error {
	var err error
	statusbarAccessibleClassStruct_Once.Do(func() {
		statusbarAccessibleClassStruct, err = gi.StructNew("Gtk", "StatusbarAccessibleClass")
	})
	return err
}

type StatusbarAccessibleClass struct {
	native unsafe.Pointer
}

func StatusbarAccessibleClassNewFromNative(native unsafe.Pointer) *StatusbarAccessibleClass {
	err := statusbarAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StatusbarAccessibleClass{native: native}

	return instance
}

/*
CastToStatusbarAccessibleClass down casts any arbitrary Object to StatusbarAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StatusbarAccessibleClass.
*/
func CastToStatusbarAccessibleClass(object *gobject.Object) *StatusbarAccessibleClass {
	return StatusbarAccessibleClassNewFromNative(object.Native())
}

// Equals compares this StatusbarAccessibleClass with another StatusbarAccessibleClass, and returns true if they represent the same Object.
func (recv *StatusbarAccessibleClass) Equals(other *StatusbarAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StatusbarAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StatusbarAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(statusbarAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StatusbarAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(statusbarAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// StatusbarAccessibleClassStruct creates an uninitialised StatusbarAccessibleClass.
func StatusbarAccessibleClassStruct() *StatusbarAccessibleClass {
	err := statusbarAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StatusbarAccessibleClassNewFromNative(statusbarAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStatusbarAccessibleClass)
	return structGo
}
func finalizeStatusbarAccessibleClass(obj *StatusbarAccessibleClass) {
	statusbarAccessibleClassStruct.Free(obj.Native())
}

var statusbarAccessiblePrivateStruct *gi.Struct
var statusbarAccessiblePrivateStruct_Once sync.Once

func statusbarAccessiblePrivateStruct_Set() error {
	var err error
	statusbarAccessiblePrivateStruct_Once.Do(func() {
		statusbarAccessiblePrivateStruct, err = gi.StructNew("Gtk", "StatusbarAccessiblePrivate")
	})
	return err
}

type StatusbarAccessiblePrivate struct {
	native unsafe.Pointer
}

func StatusbarAccessiblePrivateNewFromNative(native unsafe.Pointer) *StatusbarAccessiblePrivate {
	err := statusbarAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StatusbarAccessiblePrivate{native: native}

	return instance
}

/*
CastToStatusbarAccessiblePrivate down casts any arbitrary Object to StatusbarAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a StatusbarAccessiblePrivate.
*/
func CastToStatusbarAccessiblePrivate(object *gobject.Object) *StatusbarAccessiblePrivate {
	return StatusbarAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this StatusbarAccessiblePrivate with another StatusbarAccessiblePrivate, and returns true if they represent the same Object.
func (recv *StatusbarAccessiblePrivate) Equals(other *StatusbarAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *StatusbarAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// StatusbarAccessiblePrivateStruct creates an uninitialised StatusbarAccessiblePrivate.
func StatusbarAccessiblePrivateStruct() *StatusbarAccessiblePrivate {
	err := statusbarAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StatusbarAccessiblePrivateNewFromNative(statusbarAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStatusbarAccessiblePrivate)
	return structGo
}
func finalizeStatusbarAccessiblePrivate(obj *StatusbarAccessiblePrivate) {
	statusbarAccessiblePrivateStruct.Free(obj.Native())
}

var statusbarClassStruct *gi.Struct
var statusbarClassStruct_Once sync.Once

func statusbarClassStruct_Set() error {
	var err error
	statusbarClassStruct_Once.Do(func() {
		statusbarClassStruct, err = gi.StructNew("Gtk", "StatusbarClass")
	})
	return err
}

type StatusbarClass struct {
	native unsafe.Pointer
}

func StatusbarClassNewFromNative(native unsafe.Pointer) *StatusbarClass {
	err := statusbarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StatusbarClass{native: native}

	return instance
}

/*
CastToStatusbarClass down casts any arbitrary Object to StatusbarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StatusbarClass.
*/
func CastToStatusbarClass(object *gobject.Object) *StatusbarClass {
	return StatusbarClassNewFromNative(object.Native())
}

// Equals compares this StatusbarClass with another StatusbarClass, and returns true if they represent the same Object.
func (recv *StatusbarClass) Equals(other *StatusbarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StatusbarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StatusbarClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(statusbarClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StatusbarClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(statusbarClassStruct, recv.Native(), "parent_class", argValue)
}

// FieldReserved returns the C field 'reserved'.
func (recv *StatusbarClass) FieldReserved() unsafe.Pointer {
	argValue := gi.StructFieldGet(statusbarClassStruct, recv.Native(), "reserved")
	value := argValue.Pointer()
	return value
}

// SetFieldReserved sets the value of the C field 'reserved'.
func (recv *StatusbarClass) SetFieldReserved(value unsafe.Pointer) {
	var argValue gi.Argument
	argValue.SetPointer(value)
	gi.StructFieldSet(statusbarClassStruct, recv.Native(), "reserved", argValue)
}

// UNSUPPORTED : C value 'text_pushed' : for field getter : missing Type

// UNSUPPORTED : C value 'text_pushed' : for field setter : missing Type

// UNSUPPORTED : C value 'text_popped' : for field getter : missing Type

// UNSUPPORTED : C value 'text_popped' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// StatusbarClassStruct creates an uninitialised StatusbarClass.
func StatusbarClassStruct() *StatusbarClass {
	err := statusbarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StatusbarClassNewFromNative(statusbarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStatusbarClass)
	return structGo
}
func finalizeStatusbarClass(obj *StatusbarClass) {
	statusbarClassStruct.Free(obj.Native())
}

var statusbarPrivateStruct *gi.Struct
var statusbarPrivateStruct_Once sync.Once

func statusbarPrivateStruct_Set() error {
	var err error
	statusbarPrivateStruct_Once.Do(func() {
		statusbarPrivateStruct, err = gi.StructNew("Gtk", "StatusbarPrivate")
	})
	return err
}

type StatusbarPrivate struct {
	native unsafe.Pointer
}

func StatusbarPrivateNewFromNative(native unsafe.Pointer) *StatusbarPrivate {
	err := statusbarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StatusbarPrivate{native: native}

	return instance
}

/*
CastToStatusbarPrivate down casts any arbitrary Object to StatusbarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a StatusbarPrivate.
*/
func CastToStatusbarPrivate(object *gobject.Object) *StatusbarPrivate {
	return StatusbarPrivateNewFromNative(object.Native())
}

// Equals compares this StatusbarPrivate with another StatusbarPrivate, and returns true if they represent the same Object.
func (recv *StatusbarPrivate) Equals(other *StatusbarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *StatusbarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// StatusbarPrivateStruct creates an uninitialised StatusbarPrivate.
func StatusbarPrivateStruct() *StatusbarPrivate {
	err := statusbarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StatusbarPrivateNewFromNative(statusbarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStatusbarPrivate)
	return structGo
}
func finalizeStatusbarPrivate(obj *StatusbarPrivate) {
	statusbarPrivateStruct.Free(obj.Native())
}

var stockItemStruct *gi.Struct
var stockItemStruct_Once sync.Once

func stockItemStruct_Set() error {
	var err error
	stockItemStruct_Once.Do(func() {
		stockItemStruct, err = gi.StructNew("Gtk", "StockItem")
	})
	return err
}

type StockItem struct {
	native unsafe.Pointer
}

func StockItemNewFromNative(native unsafe.Pointer) *StockItem {
	err := stockItemStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StockItem{native: native}

	return instance
}

/*
CastToStockItem down casts any arbitrary Object to StockItem.
Exercise care, as this is a potentially dangerous function
if the Object is not a StockItem.
*/
func CastToStockItem(object *gobject.Object) *StockItem {
	return StockItemNewFromNative(object.Native())
}

// Equals compares this StockItem with another StockItem, and returns true if they represent the same Object.
func (recv *StockItem) Equals(other *StockItem) bool {
	return other.Native() == recv.Native()
}

func (recv *StockItem) Native() unsafe.Pointer {
	return recv.native
}

// FieldStockId returns the C field 'stock_id'.
func (recv *StockItem) FieldStockId() string {
	argValue := gi.StructFieldGet(stockItemStruct, recv.Native(), "stock_id")
	value := argValue.String(false)
	return value
}

// SetFieldStockId sets the value of the C field 'stock_id'.
func (recv *StockItem) SetFieldStockId(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(stockItemStruct, recv.Native(), "stock_id", argValue)
}

// FieldLabel returns the C field 'label'.
func (recv *StockItem) FieldLabel() string {
	argValue := gi.StructFieldGet(stockItemStruct, recv.Native(), "label")
	value := argValue.String(false)
	return value
}

// SetFieldLabel sets the value of the C field 'label'.
func (recv *StockItem) SetFieldLabel(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(stockItemStruct, recv.Native(), "label", argValue)
}

// UNSUPPORTED : C value 'modifier' : for field getter : no Go type for 'Gdk.ModifierType'

// UNSUPPORTED : C value 'modifier' : for field setter : no Go type for 'Gdk.ModifierType'

// FieldKeyval returns the C field 'keyval'.
func (recv *StockItem) FieldKeyval() uint32 {
	argValue := gi.StructFieldGet(stockItemStruct, recv.Native(), "keyval")
	value := argValue.Uint32()
	return value
}

// SetFieldKeyval sets the value of the C field 'keyval'.
func (recv *StockItem) SetFieldKeyval(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(stockItemStruct, recv.Native(), "keyval", argValue)
}

// FieldTranslationDomain returns the C field 'translation_domain'.
func (recv *StockItem) FieldTranslationDomain() string {
	argValue := gi.StructFieldGet(stockItemStruct, recv.Native(), "translation_domain")
	value := argValue.String(false)
	return value
}

// SetFieldTranslationDomain sets the value of the C field 'translation_domain'.
func (recv *StockItem) SetFieldTranslationDomain(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(stockItemStruct, recv.Native(), "translation_domain", argValue)
}

var stockItemCopyFunction *gi.Function
var stockItemCopyFunction_Once sync.Once

func stockItemCopyFunction_Set() error {
	var err error
	stockItemCopyFunction_Once.Do(func() {
		err = stockItemStruct_Set()
		if err != nil {
			return
		}
		stockItemCopyFunction, err = stockItemStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_stock_item_copy.
func (recv *StockItem) Copy() *StockItem {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := stockItemCopyFunction_Set()
	if err == nil {
		ret = stockItemCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := StockItemNewFromNative(ret.Pointer())

	return retGo
}

var stockItemFreeFunction *gi.Function
var stockItemFreeFunction_Once sync.Once

func stockItemFreeFunction_Set() error {
	var err error
	stockItemFreeFunction_Once.Do(func() {
		err = stockItemStruct_Set()
		if err != nil {
			return
		}
		stockItemFreeFunction, err = stockItemStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_stock_item_free.
func (recv *StockItem) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := stockItemFreeFunction_Set()
	if err == nil {
		stockItemFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

// StockItemStruct creates an uninitialised StockItem.
func StockItemStruct() *StockItem {
	err := stockItemStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StockItemNewFromNative(stockItemStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStockItem)
	return structGo
}
func finalizeStockItem(obj *StockItem) {
	stockItemStruct.Free(obj.Native())
}

var styleClassStruct *gi.Struct
var styleClassStruct_Once sync.Once

func styleClassStruct_Set() error {
	var err error
	styleClassStruct_Once.Do(func() {
		styleClassStruct, err = gi.StructNew("Gtk", "StyleClass")
	})
	return err
}

type StyleClass struct {
	native unsafe.Pointer
}

func StyleClassNewFromNative(native unsafe.Pointer) *StyleClass {
	err := styleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StyleClass{native: native}

	return instance
}

/*
CastToStyleClass down casts any arbitrary Object to StyleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StyleClass.
*/
func CastToStyleClass(object *gobject.Object) *StyleClass {
	return StyleClassNewFromNative(object.Native())
}

// Equals compares this StyleClass with another StyleClass, and returns true if they represent the same Object.
func (recv *StyleClass) Equals(other *StyleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StyleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StyleClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(styleClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StyleClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(styleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'realize' : for field getter : missing Type

// UNSUPPORTED : C value 'realize' : for field setter : missing Type

// UNSUPPORTED : C value 'unrealize' : for field getter : missing Type

// UNSUPPORTED : C value 'unrealize' : for field setter : missing Type

// UNSUPPORTED : C value 'copy' : for field getter : missing Type

// UNSUPPORTED : C value 'copy' : for field setter : missing Type

// UNSUPPORTED : C value 'clone' : for field getter : missing Type

// UNSUPPORTED : C value 'clone' : for field setter : missing Type

// UNSUPPORTED : C value 'init_from_rc' : for field getter : missing Type

// UNSUPPORTED : C value 'init_from_rc' : for field setter : missing Type

// UNSUPPORTED : C value 'set_background' : for field getter : missing Type

// UNSUPPORTED : C value 'set_background' : for field setter : missing Type

// UNSUPPORTED : C value 'render_icon' : for field getter : missing Type

// UNSUPPORTED : C value 'render_icon' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_hline' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_hline' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_vline' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_vline' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_shadow' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_shadow' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_arrow' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_arrow' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_diamond' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_diamond' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_box' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_box' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_flat_box' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_flat_box' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_check' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_check' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_option' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_option' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_tab' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_tab' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_shadow_gap' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_shadow_gap' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_box_gap' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_box_gap' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_extension' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_extension' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_slider' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_slider' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_handle' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_handle' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_expander' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_expander' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_layout' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_layout' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_resize_grip' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_resize_grip' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_spinner' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_spinner' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved9' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved9' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved10' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved10' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved11' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved11' : for field setter : missing Type

// StyleClassStruct creates an uninitialised StyleClass.
func StyleClassStruct() *StyleClass {
	err := styleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StyleClassNewFromNative(styleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStyleClass)
	return structGo
}
func finalizeStyleClass(obj *StyleClass) {
	styleClassStruct.Free(obj.Native())
}

var styleContextClassStruct *gi.Struct
var styleContextClassStruct_Once sync.Once

func styleContextClassStruct_Set() error {
	var err error
	styleContextClassStruct_Once.Do(func() {
		styleContextClassStruct, err = gi.StructNew("Gtk", "StyleContextClass")
	})
	return err
}

type StyleContextClass struct {
	native unsafe.Pointer
}

func StyleContextClassNewFromNative(native unsafe.Pointer) *StyleContextClass {
	err := styleContextClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StyleContextClass{native: native}

	return instance
}

/*
CastToStyleContextClass down casts any arbitrary Object to StyleContextClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StyleContextClass.
*/
func CastToStyleContextClass(object *gobject.Object) *StyleContextClass {
	return StyleContextClassNewFromNative(object.Native())
}

// Equals compares this StyleContextClass with another StyleContextClass, and returns true if they represent the same Object.
func (recv *StyleContextClass) Equals(other *StyleContextClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StyleContextClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *StyleContextClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(styleContextClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *StyleContextClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(styleContextClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// StyleContextClassStruct creates an uninitialised StyleContextClass.
func StyleContextClassStruct() *StyleContextClass {
	err := styleContextClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StyleContextClassNewFromNative(styleContextClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStyleContextClass)
	return structGo
}
func finalizeStyleContextClass(obj *StyleContextClass) {
	styleContextClassStruct.Free(obj.Native())
}

var styleContextPrivateStruct *gi.Struct
var styleContextPrivateStruct_Once sync.Once

func styleContextPrivateStruct_Set() error {
	var err error
	styleContextPrivateStruct_Once.Do(func() {
		styleContextPrivateStruct, err = gi.StructNew("Gtk", "StyleContextPrivate")
	})
	return err
}

type StyleContextPrivate struct {
	native unsafe.Pointer
}

func StyleContextPrivateNewFromNative(native unsafe.Pointer) *StyleContextPrivate {
	err := styleContextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StyleContextPrivate{native: native}

	return instance
}

/*
CastToStyleContextPrivate down casts any arbitrary Object to StyleContextPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a StyleContextPrivate.
*/
func CastToStyleContextPrivate(object *gobject.Object) *StyleContextPrivate {
	return StyleContextPrivateNewFromNative(object.Native())
}

// Equals compares this StyleContextPrivate with another StyleContextPrivate, and returns true if they represent the same Object.
func (recv *StyleContextPrivate) Equals(other *StyleContextPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *StyleContextPrivate) Native() unsafe.Pointer {
	return recv.native
}

// StyleContextPrivateStruct creates an uninitialised StyleContextPrivate.
func StyleContextPrivateStruct() *StyleContextPrivate {
	err := styleContextPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StyleContextPrivateNewFromNative(styleContextPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStyleContextPrivate)
	return structGo
}
func finalizeStyleContextPrivate(obj *StyleContextPrivate) {
	styleContextPrivateStruct.Free(obj.Native())
}

var stylePropertiesClassStruct *gi.Struct
var stylePropertiesClassStruct_Once sync.Once

func stylePropertiesClassStruct_Set() error {
	var err error
	stylePropertiesClassStruct_Once.Do(func() {
		stylePropertiesClassStruct, err = gi.StructNew("Gtk", "StylePropertiesClass")
	})
	return err
}

type StylePropertiesClass struct {
	native unsafe.Pointer
}

func StylePropertiesClassNewFromNative(native unsafe.Pointer) *StylePropertiesClass {
	err := stylePropertiesClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StylePropertiesClass{native: native}

	return instance
}

/*
CastToStylePropertiesClass down casts any arbitrary Object to StylePropertiesClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a StylePropertiesClass.
*/
func CastToStylePropertiesClass(object *gobject.Object) *StylePropertiesClass {
	return StylePropertiesClassNewFromNative(object.Native())
}

// Equals compares this StylePropertiesClass with another StylePropertiesClass, and returns true if they represent the same Object.
func (recv *StylePropertiesClass) Equals(other *StylePropertiesClass) bool {
	return other.Native() == recv.Native()
}

func (recv *StylePropertiesClass) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// StylePropertiesClassStruct creates an uninitialised StylePropertiesClass.
func StylePropertiesClassStruct() *StylePropertiesClass {
	err := stylePropertiesClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StylePropertiesClassNewFromNative(stylePropertiesClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStylePropertiesClass)
	return structGo
}
func finalizeStylePropertiesClass(obj *StylePropertiesClass) {
	stylePropertiesClassStruct.Free(obj.Native())
}

var stylePropertiesPrivateStruct *gi.Struct
var stylePropertiesPrivateStruct_Once sync.Once

func stylePropertiesPrivateStruct_Set() error {
	var err error
	stylePropertiesPrivateStruct_Once.Do(func() {
		stylePropertiesPrivateStruct, err = gi.StructNew("Gtk", "StylePropertiesPrivate")
	})
	return err
}

type StylePropertiesPrivate struct {
	native unsafe.Pointer
}

func StylePropertiesPrivateNewFromNative(native unsafe.Pointer) *StylePropertiesPrivate {
	err := stylePropertiesPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StylePropertiesPrivate{native: native}

	return instance
}

/*
CastToStylePropertiesPrivate down casts any arbitrary Object to StylePropertiesPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a StylePropertiesPrivate.
*/
func CastToStylePropertiesPrivate(object *gobject.Object) *StylePropertiesPrivate {
	return StylePropertiesPrivateNewFromNative(object.Native())
}

// Equals compares this StylePropertiesPrivate with another StylePropertiesPrivate, and returns true if they represent the same Object.
func (recv *StylePropertiesPrivate) Equals(other *StylePropertiesPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *StylePropertiesPrivate) Native() unsafe.Pointer {
	return recv.native
}

// StylePropertiesPrivateStruct creates an uninitialised StylePropertiesPrivate.
func StylePropertiesPrivateStruct() *StylePropertiesPrivate {
	err := stylePropertiesPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StylePropertiesPrivateNewFromNative(stylePropertiesPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStylePropertiesPrivate)
	return structGo
}
func finalizeStylePropertiesPrivate(obj *StylePropertiesPrivate) {
	stylePropertiesPrivateStruct.Free(obj.Native())
}

var styleProviderIfaceStruct *gi.Struct
var styleProviderIfaceStruct_Once sync.Once

func styleProviderIfaceStruct_Set() error {
	var err error
	styleProviderIfaceStruct_Once.Do(func() {
		styleProviderIfaceStruct, err = gi.StructNew("Gtk", "StyleProviderIface")
	})
	return err
}

type StyleProviderIface struct {
	native unsafe.Pointer
}

func StyleProviderIfaceNewFromNative(native unsafe.Pointer) *StyleProviderIface {
	err := styleProviderIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &StyleProviderIface{native: native}

	return instance
}

/*
CastToStyleProviderIface down casts any arbitrary Object to StyleProviderIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a StyleProviderIface.
*/
func CastToStyleProviderIface(object *gobject.Object) *StyleProviderIface {
	return StyleProviderIfaceNewFromNative(object.Native())
}

// Equals compares this StyleProviderIface with another StyleProviderIface, and returns true if they represent the same Object.
func (recv *StyleProviderIface) Equals(other *StyleProviderIface) bool {
	return other.Native() == recv.Native()
}

func (recv *StyleProviderIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'get_style' : for field getter : missing Type

// UNSUPPORTED : C value 'get_style' : for field setter : missing Type

// UNSUPPORTED : C value 'get_style_property' : for field getter : missing Type

// UNSUPPORTED : C value 'get_style_property' : for field setter : missing Type

// UNSUPPORTED : C value 'get_icon_factory' : for field getter : missing Type

// UNSUPPORTED : C value 'get_icon_factory' : for field setter : missing Type

// StyleProviderIfaceStruct creates an uninitialised StyleProviderIface.
func StyleProviderIfaceStruct() *StyleProviderIface {
	err := styleProviderIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := StyleProviderIfaceNewFromNative(styleProviderIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeStyleProviderIface)
	return structGo
}
func finalizeStyleProviderIface(obj *StyleProviderIface) {
	styleProviderIfaceStruct.Free(obj.Native())
}

var switchAccessibleClassStruct *gi.Struct
var switchAccessibleClassStruct_Once sync.Once

func switchAccessibleClassStruct_Set() error {
	var err error
	switchAccessibleClassStruct_Once.Do(func() {
		switchAccessibleClassStruct, err = gi.StructNew("Gtk", "SwitchAccessibleClass")
	})
	return err
}

type SwitchAccessibleClass struct {
	native unsafe.Pointer
}

func SwitchAccessibleClassNewFromNative(native unsafe.Pointer) *SwitchAccessibleClass {
	err := switchAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SwitchAccessibleClass{native: native}

	return instance
}

/*
CastToSwitchAccessibleClass down casts any arbitrary Object to SwitchAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SwitchAccessibleClass.
*/
func CastToSwitchAccessibleClass(object *gobject.Object) *SwitchAccessibleClass {
	return SwitchAccessibleClassNewFromNative(object.Native())
}

// Equals compares this SwitchAccessibleClass with another SwitchAccessibleClass, and returns true if they represent the same Object.
func (recv *SwitchAccessibleClass) Equals(other *SwitchAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SwitchAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SwitchAccessibleClass) FieldParentClass() *WidgetAccessibleClass {
	argValue := gi.StructFieldGet(switchAccessibleClassStruct, recv.Native(), "parent_class")
	value := WidgetAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SwitchAccessibleClass) SetFieldParentClass(value *WidgetAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(switchAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// SwitchAccessibleClassStruct creates an uninitialised SwitchAccessibleClass.
func SwitchAccessibleClassStruct() *SwitchAccessibleClass {
	err := switchAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SwitchAccessibleClassNewFromNative(switchAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSwitchAccessibleClass)
	return structGo
}
func finalizeSwitchAccessibleClass(obj *SwitchAccessibleClass) {
	switchAccessibleClassStruct.Free(obj.Native())
}

var switchAccessiblePrivateStruct *gi.Struct
var switchAccessiblePrivateStruct_Once sync.Once

func switchAccessiblePrivateStruct_Set() error {
	var err error
	switchAccessiblePrivateStruct_Once.Do(func() {
		switchAccessiblePrivateStruct, err = gi.StructNew("Gtk", "SwitchAccessiblePrivate")
	})
	return err
}

type SwitchAccessiblePrivate struct {
	native unsafe.Pointer
}

func SwitchAccessiblePrivateNewFromNative(native unsafe.Pointer) *SwitchAccessiblePrivate {
	err := switchAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SwitchAccessiblePrivate{native: native}

	return instance
}

/*
CastToSwitchAccessiblePrivate down casts any arbitrary Object to SwitchAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SwitchAccessiblePrivate.
*/
func CastToSwitchAccessiblePrivate(object *gobject.Object) *SwitchAccessiblePrivate {
	return SwitchAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this SwitchAccessiblePrivate with another SwitchAccessiblePrivate, and returns true if they represent the same Object.
func (recv *SwitchAccessiblePrivate) Equals(other *SwitchAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SwitchAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// SwitchAccessiblePrivateStruct creates an uninitialised SwitchAccessiblePrivate.
func SwitchAccessiblePrivateStruct() *SwitchAccessiblePrivate {
	err := switchAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SwitchAccessiblePrivateNewFromNative(switchAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSwitchAccessiblePrivate)
	return structGo
}
func finalizeSwitchAccessiblePrivate(obj *SwitchAccessiblePrivate) {
	switchAccessiblePrivateStruct.Free(obj.Native())
}

var switchClassStruct *gi.Struct
var switchClassStruct_Once sync.Once

func switchClassStruct_Set() error {
	var err error
	switchClassStruct_Once.Do(func() {
		switchClassStruct, err = gi.StructNew("Gtk", "SwitchClass")
	})
	return err
}

type SwitchClass struct {
	native unsafe.Pointer
}

func SwitchClassNewFromNative(native unsafe.Pointer) *SwitchClass {
	err := switchClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SwitchClass{native: native}

	return instance
}

/*
CastToSwitchClass down casts any arbitrary Object to SwitchClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a SwitchClass.
*/
func CastToSwitchClass(object *gobject.Object) *SwitchClass {
	return SwitchClassNewFromNative(object.Native())
}

// Equals compares this SwitchClass with another SwitchClass, and returns true if they represent the same Object.
func (recv *SwitchClass) Equals(other *SwitchClass) bool {
	return other.Native() == recv.Native()
}

func (recv *SwitchClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *SwitchClass) FieldParentClass() *WidgetClass {
	argValue := gi.StructFieldGet(switchClassStruct, recv.Native(), "parent_class")
	value := WidgetClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *SwitchClass) SetFieldParentClass(value *WidgetClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(switchClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'activate' : for field getter : missing Type

// UNSUPPORTED : C value 'activate' : for field setter : missing Type

// UNSUPPORTED : C value 'state_set' : for field getter : missing Type

// UNSUPPORTED : C value 'state_set' : for field setter : missing Type

// UNSUPPORTED : C value '_switch_padding_1' : for field getter : missing Type

// UNSUPPORTED : C value '_switch_padding_1' : for field setter : missing Type

// UNSUPPORTED : C value '_switch_padding_2' : for field getter : missing Type

// UNSUPPORTED : C value '_switch_padding_2' : for field setter : missing Type

// UNSUPPORTED : C value '_switch_padding_3' : for field getter : missing Type

// UNSUPPORTED : C value '_switch_padding_3' : for field setter : missing Type

// UNSUPPORTED : C value '_switch_padding_4' : for field getter : missing Type

// UNSUPPORTED : C value '_switch_padding_4' : for field setter : missing Type

// UNSUPPORTED : C value '_switch_padding_5' : for field getter : missing Type

// UNSUPPORTED : C value '_switch_padding_5' : for field setter : missing Type

// SwitchClassStruct creates an uninitialised SwitchClass.
func SwitchClassStruct() *SwitchClass {
	err := switchClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SwitchClassNewFromNative(switchClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSwitchClass)
	return structGo
}
func finalizeSwitchClass(obj *SwitchClass) {
	switchClassStruct.Free(obj.Native())
}

var switchPrivateStruct *gi.Struct
var switchPrivateStruct_Once sync.Once

func switchPrivateStruct_Set() error {
	var err error
	switchPrivateStruct_Once.Do(func() {
		switchPrivateStruct, err = gi.StructNew("Gtk", "SwitchPrivate")
	})
	return err
}

type SwitchPrivate struct {
	native unsafe.Pointer
}

func SwitchPrivateNewFromNative(native unsafe.Pointer) *SwitchPrivate {
	err := switchPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SwitchPrivate{native: native}

	return instance
}

/*
CastToSwitchPrivate down casts any arbitrary Object to SwitchPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a SwitchPrivate.
*/
func CastToSwitchPrivate(object *gobject.Object) *SwitchPrivate {
	return SwitchPrivateNewFromNative(object.Native())
}

// Equals compares this SwitchPrivate with another SwitchPrivate, and returns true if they represent the same Object.
func (recv *SwitchPrivate) Equals(other *SwitchPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *SwitchPrivate) Native() unsafe.Pointer {
	return recv.native
}

// SwitchPrivateStruct creates an uninitialised SwitchPrivate.
func SwitchPrivateStruct() *SwitchPrivate {
	err := switchPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := SwitchPrivateNewFromNative(switchPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeSwitchPrivate)
	return structGo
}
func finalizeSwitchPrivate(obj *SwitchPrivate) {
	switchPrivateStruct.Free(obj.Native())
}

var symbolicColorStruct *gi.Struct
var symbolicColorStruct_Once sync.Once

func symbolicColorStruct_Set() error {
	var err error
	symbolicColorStruct_Once.Do(func() {
		symbolicColorStruct, err = gi.StructNew("Gtk", "SymbolicColor")
	})
	return err
}

type SymbolicColor struct {
	native unsafe.Pointer
}

func SymbolicColorNewFromNative(native unsafe.Pointer) *SymbolicColor {
	err := symbolicColorStruct_Set()
	if err != nil {
		return nil
	}

	instance := &SymbolicColor{native: native}

	return instance
}

/*
CastToSymbolicColor down casts any arbitrary Object to SymbolicColor.
Exercise care, as this is a potentially dangerous function
if the Object is not a SymbolicColor.
*/
func CastToSymbolicColor(object *gobject.Object) *SymbolicColor {
	return SymbolicColorNewFromNative(object.Native())
}

// Equals compares this SymbolicColor with another SymbolicColor, and returns true if they represent the same Object.
func (recv *SymbolicColor) Equals(other *SymbolicColor) bool {
	return other.Native() == recv.Native()
}

func (recv *SymbolicColor) Native() unsafe.Pointer {
	return recv.native
}

var symbolicColorNewAlphaFunction *gi.Function
var symbolicColorNewAlphaFunction_Once sync.Once

func symbolicColorNewAlphaFunction_Set() error {
	var err error
	symbolicColorNewAlphaFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorNewAlphaFunction, err = symbolicColorStruct.InvokerNew("new_alpha")
	})
	return err
}

// SymbolicColorNewAlpha is a representation of the C type gtk_symbolic_color_new_alpha.
func SymbolicColorNewAlpha(color *SymbolicColor, factor float64) *SymbolicColor {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(color.Native())
	inArgs[1].SetFloat64(factor)

	var ret gi.Argument

	err := symbolicColorNewAlphaFunction_Set()
	if err == nil {
		ret = symbolicColorNewAlphaFunction.Invoke(inArgs[:], nil)
	}

	retGo := SymbolicColorNewFromNative(ret.Pointer())

	return retGo
}

var symbolicColorNewLiteralFunction *gi.Function
var symbolicColorNewLiteralFunction_Once sync.Once

func symbolicColorNewLiteralFunction_Set() error {
	var err error
	symbolicColorNewLiteralFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorNewLiteralFunction, err = symbolicColorStruct.InvokerNew("new_literal")
	})
	return err
}

// SymbolicColorNewLiteral is a representation of the C type gtk_symbolic_color_new_literal.
func SymbolicColorNewLiteral(color *gdk.RGBA) *SymbolicColor {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(color.Native())

	var ret gi.Argument

	err := symbolicColorNewLiteralFunction_Set()
	if err == nil {
		ret = symbolicColorNewLiteralFunction.Invoke(inArgs[:], nil)
	}

	retGo := SymbolicColorNewFromNative(ret.Pointer())

	return retGo
}

var symbolicColorNewMixFunction *gi.Function
var symbolicColorNewMixFunction_Once sync.Once

func symbolicColorNewMixFunction_Set() error {
	var err error
	symbolicColorNewMixFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorNewMixFunction, err = symbolicColorStruct.InvokerNew("new_mix")
	})
	return err
}

// SymbolicColorNewMix is a representation of the C type gtk_symbolic_color_new_mix.
func SymbolicColorNewMix(color1 *SymbolicColor, color2 *SymbolicColor, factor float64) *SymbolicColor {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(color1.Native())
	inArgs[1].SetPointer(color2.Native())
	inArgs[2].SetFloat64(factor)

	var ret gi.Argument

	err := symbolicColorNewMixFunction_Set()
	if err == nil {
		ret = symbolicColorNewMixFunction.Invoke(inArgs[:], nil)
	}

	retGo := SymbolicColorNewFromNative(ret.Pointer())

	return retGo
}

var symbolicColorNewNameFunction *gi.Function
var symbolicColorNewNameFunction_Once sync.Once

func symbolicColorNewNameFunction_Set() error {
	var err error
	symbolicColorNewNameFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorNewNameFunction, err = symbolicColorStruct.InvokerNew("new_name")
	})
	return err
}

// SymbolicColorNewName is a representation of the C type gtk_symbolic_color_new_name.
func SymbolicColorNewName(name string) *SymbolicColor {
	var inArgs [1]gi.Argument
	inArgs[0].SetString(name)

	var ret gi.Argument

	err := symbolicColorNewNameFunction_Set()
	if err == nil {
		ret = symbolicColorNewNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := SymbolicColorNewFromNative(ret.Pointer())

	return retGo
}

var symbolicColorNewShadeFunction *gi.Function
var symbolicColorNewShadeFunction_Once sync.Once

func symbolicColorNewShadeFunction_Set() error {
	var err error
	symbolicColorNewShadeFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorNewShadeFunction, err = symbolicColorStruct.InvokerNew("new_shade")
	})
	return err
}

// SymbolicColorNewShade is a representation of the C type gtk_symbolic_color_new_shade.
func SymbolicColorNewShade(color *SymbolicColor, factor float64) *SymbolicColor {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(color.Native())
	inArgs[1].SetFloat64(factor)

	var ret gi.Argument

	err := symbolicColorNewShadeFunction_Set()
	if err == nil {
		ret = symbolicColorNewShadeFunction.Invoke(inArgs[:], nil)
	}

	retGo := SymbolicColorNewFromNative(ret.Pointer())

	return retGo
}

var symbolicColorNewWin32Function *gi.Function
var symbolicColorNewWin32Function_Once sync.Once

func symbolicColorNewWin32Function_Set() error {
	var err error
	symbolicColorNewWin32Function_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorNewWin32Function, err = symbolicColorStruct.InvokerNew("new_win32")
	})
	return err
}

// SymbolicColorNewWin32 is a representation of the C type gtk_symbolic_color_new_win32.
func SymbolicColorNewWin32(themeClass string, id int32) *SymbolicColor {
	var inArgs [2]gi.Argument
	inArgs[0].SetString(themeClass)
	inArgs[1].SetInt32(id)

	var ret gi.Argument

	err := symbolicColorNewWin32Function_Set()
	if err == nil {
		ret = symbolicColorNewWin32Function.Invoke(inArgs[:], nil)
	}

	retGo := SymbolicColorNewFromNative(ret.Pointer())

	return retGo
}

var symbolicColorRefFunction *gi.Function
var symbolicColorRefFunction_Once sync.Once

func symbolicColorRefFunction_Set() error {
	var err error
	symbolicColorRefFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorRefFunction, err = symbolicColorStruct.InvokerNew("ref")
	})
	return err
}

// Ref is a representation of the C type gtk_symbolic_color_ref.
func (recv *SymbolicColor) Ref() *SymbolicColor {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := symbolicColorRefFunction_Set()
	if err == nil {
		ret = symbolicColorRefFunction.Invoke(inArgs[:], nil)
	}

	retGo := SymbolicColorNewFromNative(ret.Pointer())

	return retGo
}

var symbolicColorResolveFunction *gi.Function
var symbolicColorResolveFunction_Once sync.Once

func symbolicColorResolveFunction_Set() error {
	var err error
	symbolicColorResolveFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorResolveFunction, err = symbolicColorStruct.InvokerNew("resolve")
	})
	return err
}

// Resolve is a representation of the C type gtk_symbolic_color_resolve.
func (recv *SymbolicColor) Resolve(props *StyleProperties) (bool, *gdk.RGBA) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(props.Native())

	var outArgs [1]gi.Argument
	var ret gi.Argument

	err := symbolicColorResolveFunction_Set()
	if err == nil {
		ret = symbolicColorResolveFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := gdk.RGBANewFromNative(outArgs[0].Pointer())

	return retGo, out0
}

var symbolicColorToStringFunction *gi.Function
var symbolicColorToStringFunction_Once sync.Once

func symbolicColorToStringFunction_Set() error {
	var err error
	symbolicColorToStringFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorToStringFunction, err = symbolicColorStruct.InvokerNew("to_string")
	})
	return err
}

// ToString is a representation of the C type gtk_symbolic_color_to_string.
func (recv *SymbolicColor) ToString() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := symbolicColorToStringFunction_Set()
	if err == nil {
		ret = symbolicColorToStringFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var symbolicColorUnrefFunction *gi.Function
var symbolicColorUnrefFunction_Once sync.Once

func symbolicColorUnrefFunction_Set() error {
	var err error
	symbolicColorUnrefFunction_Once.Do(func() {
		err = symbolicColorStruct_Set()
		if err != nil {
			return
		}
		symbolicColorUnrefFunction, err = symbolicColorStruct.InvokerNew("unref")
	})
	return err
}

// Unref is a representation of the C type gtk_symbolic_color_unref.
func (recv *SymbolicColor) Unref() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := symbolicColorUnrefFunction_Set()
	if err == nil {
		symbolicColorUnrefFunction.Invoke(inArgs[:], nil)
	}

	return
}

var tableChildStruct *gi.Struct
var tableChildStruct_Once sync.Once

func tableChildStruct_Set() error {
	var err error
	tableChildStruct_Once.Do(func() {
		tableChildStruct, err = gi.StructNew("Gtk", "TableChild")
	})
	return err
}

type TableChild struct {
	native unsafe.Pointer
}

func TableChildNewFromNative(native unsafe.Pointer) *TableChild {
	err := tableChildStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TableChild{native: native}

	return instance
}

/*
CastToTableChild down casts any arbitrary Object to TableChild.
Exercise care, as this is a potentially dangerous function
if the Object is not a TableChild.
*/
func CastToTableChild(object *gobject.Object) *TableChild {
	return TableChildNewFromNative(object.Native())
}

// Equals compares this TableChild with another TableChild, and returns true if they represent the same Object.
func (recv *TableChild) Equals(other *TableChild) bool {
	return other.Native() == recv.Native()
}

func (recv *TableChild) Native() unsafe.Pointer {
	return recv.native
}

// FieldWidget returns the C field 'widget'.
func (recv *TableChild) FieldWidget() *Widget {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "widget")
	value := WidgetNewFromNative(argValue.Pointer())
	return value
}

// SetFieldWidget sets the value of the C field 'widget'.
func (recv *TableChild) SetFieldWidget(value *Widget) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(tableChildStruct, recv.Native(), "widget", argValue)
}

// FieldLeftAttach returns the C field 'left_attach'.
func (recv *TableChild) FieldLeftAttach() uint16 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "left_attach")
	value := argValue.Uint16()
	return value
}

// SetFieldLeftAttach sets the value of the C field 'left_attach'.
func (recv *TableChild) SetFieldLeftAttach(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "left_attach", argValue)
}

// FieldRightAttach returns the C field 'right_attach'.
func (recv *TableChild) FieldRightAttach() uint16 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "right_attach")
	value := argValue.Uint16()
	return value
}

// SetFieldRightAttach sets the value of the C field 'right_attach'.
func (recv *TableChild) SetFieldRightAttach(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "right_attach", argValue)
}

// FieldTopAttach returns the C field 'top_attach'.
func (recv *TableChild) FieldTopAttach() uint16 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "top_attach")
	value := argValue.Uint16()
	return value
}

// SetFieldTopAttach sets the value of the C field 'top_attach'.
func (recv *TableChild) SetFieldTopAttach(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "top_attach", argValue)
}

// FieldBottomAttach returns the C field 'bottom_attach'.
func (recv *TableChild) FieldBottomAttach() uint16 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "bottom_attach")
	value := argValue.Uint16()
	return value
}

// SetFieldBottomAttach sets the value of the C field 'bottom_attach'.
func (recv *TableChild) SetFieldBottomAttach(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "bottom_attach", argValue)
}

// FieldXpadding returns the C field 'xpadding'.
func (recv *TableChild) FieldXpadding() uint16 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "xpadding")
	value := argValue.Uint16()
	return value
}

// SetFieldXpadding sets the value of the C field 'xpadding'.
func (recv *TableChild) SetFieldXpadding(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "xpadding", argValue)
}

// FieldYpadding returns the C field 'ypadding'.
func (recv *TableChild) FieldYpadding() uint16 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "ypadding")
	value := argValue.Uint16()
	return value
}

// SetFieldYpadding sets the value of the C field 'ypadding'.
func (recv *TableChild) SetFieldYpadding(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "ypadding", argValue)
}

// FieldXexpand returns the C field 'xexpand'.
func (recv *TableChild) FieldXexpand() uint32 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "xexpand")
	value := argValue.Uint32()
	return value
}

// SetFieldXexpand sets the value of the C field 'xexpand'.
func (recv *TableChild) SetFieldXexpand(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "xexpand", argValue)
}

// FieldYexpand returns the C field 'yexpand'.
func (recv *TableChild) FieldYexpand() uint32 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "yexpand")
	value := argValue.Uint32()
	return value
}

// SetFieldYexpand sets the value of the C field 'yexpand'.
func (recv *TableChild) SetFieldYexpand(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "yexpand", argValue)
}

// FieldXshrink returns the C field 'xshrink'.
func (recv *TableChild) FieldXshrink() uint32 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "xshrink")
	value := argValue.Uint32()
	return value
}

// SetFieldXshrink sets the value of the C field 'xshrink'.
func (recv *TableChild) SetFieldXshrink(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "xshrink", argValue)
}

// FieldYshrink returns the C field 'yshrink'.
func (recv *TableChild) FieldYshrink() uint32 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "yshrink")
	value := argValue.Uint32()
	return value
}

// SetFieldYshrink sets the value of the C field 'yshrink'.
func (recv *TableChild) SetFieldYshrink(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "yshrink", argValue)
}

// FieldXfill returns the C field 'xfill'.
func (recv *TableChild) FieldXfill() uint32 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "xfill")
	value := argValue.Uint32()
	return value
}

// SetFieldXfill sets the value of the C field 'xfill'.
func (recv *TableChild) SetFieldXfill(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "xfill", argValue)
}

// FieldYfill returns the C field 'yfill'.
func (recv *TableChild) FieldYfill() uint32 {
	argValue := gi.StructFieldGet(tableChildStruct, recv.Native(), "yfill")
	value := argValue.Uint32()
	return value
}

// SetFieldYfill sets the value of the C field 'yfill'.
func (recv *TableChild) SetFieldYfill(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableChildStruct, recv.Native(), "yfill", argValue)
}

// TableChildStruct creates an uninitialised TableChild.
func TableChildStruct() *TableChild {
	err := tableChildStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TableChildNewFromNative(tableChildStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTableChild)
	return structGo
}
func finalizeTableChild(obj *TableChild) {
	tableChildStruct.Free(obj.Native())
}

var tableClassStruct *gi.Struct
var tableClassStruct_Once sync.Once

func tableClassStruct_Set() error {
	var err error
	tableClassStruct_Once.Do(func() {
		tableClassStruct, err = gi.StructNew("Gtk", "TableClass")
	})
	return err
}

type TableClass struct {
	native unsafe.Pointer
}

func TableClassNewFromNative(native unsafe.Pointer) *TableClass {
	err := tableClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TableClass{native: native}

	return instance
}

/*
CastToTableClass down casts any arbitrary Object to TableClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TableClass.
*/
func CastToTableClass(object *gobject.Object) *TableClass {
	return TableClassNewFromNative(object.Native())
}

// Equals compares this TableClass with another TableClass, and returns true if they represent the same Object.
func (recv *TableClass) Equals(other *TableClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TableClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TableClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(tableClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TableClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(tableClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TableClassStruct creates an uninitialised TableClass.
func TableClassStruct() *TableClass {
	err := tableClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TableClassNewFromNative(tableClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTableClass)
	return structGo
}
func finalizeTableClass(obj *TableClass) {
	tableClassStruct.Free(obj.Native())
}

var tablePrivateStruct *gi.Struct
var tablePrivateStruct_Once sync.Once

func tablePrivateStruct_Set() error {
	var err error
	tablePrivateStruct_Once.Do(func() {
		tablePrivateStruct, err = gi.StructNew("Gtk", "TablePrivate")
	})
	return err
}

type TablePrivate struct {
	native unsafe.Pointer
}

func TablePrivateNewFromNative(native unsafe.Pointer) *TablePrivate {
	err := tablePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TablePrivate{native: native}

	return instance
}

/*
CastToTablePrivate down casts any arbitrary Object to TablePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TablePrivate.
*/
func CastToTablePrivate(object *gobject.Object) *TablePrivate {
	return TablePrivateNewFromNative(object.Native())
}

// Equals compares this TablePrivate with another TablePrivate, and returns true if they represent the same Object.
func (recv *TablePrivate) Equals(other *TablePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TablePrivate) Native() unsafe.Pointer {
	return recv.native
}

// TablePrivateStruct creates an uninitialised TablePrivate.
func TablePrivateStruct() *TablePrivate {
	err := tablePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TablePrivateNewFromNative(tablePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTablePrivate)
	return structGo
}
func finalizeTablePrivate(obj *TablePrivate) {
	tablePrivateStruct.Free(obj.Native())
}

var tableRowColStruct *gi.Struct
var tableRowColStruct_Once sync.Once

func tableRowColStruct_Set() error {
	var err error
	tableRowColStruct_Once.Do(func() {
		tableRowColStruct, err = gi.StructNew("Gtk", "TableRowCol")
	})
	return err
}

type TableRowCol struct {
	native unsafe.Pointer
}

func TableRowColNewFromNative(native unsafe.Pointer) *TableRowCol {
	err := tableRowColStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TableRowCol{native: native}

	return instance
}

/*
CastToTableRowCol down casts any arbitrary Object to TableRowCol.
Exercise care, as this is a potentially dangerous function
if the Object is not a TableRowCol.
*/
func CastToTableRowCol(object *gobject.Object) *TableRowCol {
	return TableRowColNewFromNative(object.Native())
}

// Equals compares this TableRowCol with another TableRowCol, and returns true if they represent the same Object.
func (recv *TableRowCol) Equals(other *TableRowCol) bool {
	return other.Native() == recv.Native()
}

func (recv *TableRowCol) Native() unsafe.Pointer {
	return recv.native
}

// FieldRequisition returns the C field 'requisition'.
func (recv *TableRowCol) FieldRequisition() uint16 {
	argValue := gi.StructFieldGet(tableRowColStruct, recv.Native(), "requisition")
	value := argValue.Uint16()
	return value
}

// SetFieldRequisition sets the value of the C field 'requisition'.
func (recv *TableRowCol) SetFieldRequisition(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableRowColStruct, recv.Native(), "requisition", argValue)
}

// FieldAllocation returns the C field 'allocation'.
func (recv *TableRowCol) FieldAllocation() uint16 {
	argValue := gi.StructFieldGet(tableRowColStruct, recv.Native(), "allocation")
	value := argValue.Uint16()
	return value
}

// SetFieldAllocation sets the value of the C field 'allocation'.
func (recv *TableRowCol) SetFieldAllocation(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableRowColStruct, recv.Native(), "allocation", argValue)
}

// FieldSpacing returns the C field 'spacing'.
func (recv *TableRowCol) FieldSpacing() uint16 {
	argValue := gi.StructFieldGet(tableRowColStruct, recv.Native(), "spacing")
	value := argValue.Uint16()
	return value
}

// SetFieldSpacing sets the value of the C field 'spacing'.
func (recv *TableRowCol) SetFieldSpacing(value uint16) {
	var argValue gi.Argument
	argValue.SetUint16(value)
	gi.StructFieldSet(tableRowColStruct, recv.Native(), "spacing", argValue)
}

// FieldNeedExpand returns the C field 'need_expand'.
func (recv *TableRowCol) FieldNeedExpand() uint32 {
	argValue := gi.StructFieldGet(tableRowColStruct, recv.Native(), "need_expand")
	value := argValue.Uint32()
	return value
}

// SetFieldNeedExpand sets the value of the C field 'need_expand'.
func (recv *TableRowCol) SetFieldNeedExpand(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableRowColStruct, recv.Native(), "need_expand", argValue)
}

// FieldNeedShrink returns the C field 'need_shrink'.
func (recv *TableRowCol) FieldNeedShrink() uint32 {
	argValue := gi.StructFieldGet(tableRowColStruct, recv.Native(), "need_shrink")
	value := argValue.Uint32()
	return value
}

// SetFieldNeedShrink sets the value of the C field 'need_shrink'.
func (recv *TableRowCol) SetFieldNeedShrink(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableRowColStruct, recv.Native(), "need_shrink", argValue)
}

// FieldExpand returns the C field 'expand'.
func (recv *TableRowCol) FieldExpand() uint32 {
	argValue := gi.StructFieldGet(tableRowColStruct, recv.Native(), "expand")
	value := argValue.Uint32()
	return value
}

// SetFieldExpand sets the value of the C field 'expand'.
func (recv *TableRowCol) SetFieldExpand(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableRowColStruct, recv.Native(), "expand", argValue)
}

// FieldShrink returns the C field 'shrink'.
func (recv *TableRowCol) FieldShrink() uint32 {
	argValue := gi.StructFieldGet(tableRowColStruct, recv.Native(), "shrink")
	value := argValue.Uint32()
	return value
}

// SetFieldShrink sets the value of the C field 'shrink'.
func (recv *TableRowCol) SetFieldShrink(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableRowColStruct, recv.Native(), "shrink", argValue)
}

// FieldEmpty returns the C field 'empty'.
func (recv *TableRowCol) FieldEmpty() uint32 {
	argValue := gi.StructFieldGet(tableRowColStruct, recv.Native(), "empty")
	value := argValue.Uint32()
	return value
}

// SetFieldEmpty sets the value of the C field 'empty'.
func (recv *TableRowCol) SetFieldEmpty(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(tableRowColStruct, recv.Native(), "empty", argValue)
}

// TableRowColStruct creates an uninitialised TableRowCol.
func TableRowColStruct() *TableRowCol {
	err := tableRowColStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TableRowColNewFromNative(tableRowColStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTableRowCol)
	return structGo
}
func finalizeTableRowCol(obj *TableRowCol) {
	tableRowColStruct.Free(obj.Native())
}

var targetEntryStruct *gi.Struct
var targetEntryStruct_Once sync.Once

func targetEntryStruct_Set() error {
	var err error
	targetEntryStruct_Once.Do(func() {
		targetEntryStruct, err = gi.StructNew("Gtk", "TargetEntry")
	})
	return err
}

type TargetEntry struct {
	native unsafe.Pointer
}

func TargetEntryNewFromNative(native unsafe.Pointer) *TargetEntry {
	err := targetEntryStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TargetEntry{native: native}

	return instance
}

/*
CastToTargetEntry down casts any arbitrary Object to TargetEntry.
Exercise care, as this is a potentially dangerous function
if the Object is not a TargetEntry.
*/
func CastToTargetEntry(object *gobject.Object) *TargetEntry {
	return TargetEntryNewFromNative(object.Native())
}

// Equals compares this TargetEntry with another TargetEntry, and returns true if they represent the same Object.
func (recv *TargetEntry) Equals(other *TargetEntry) bool {
	return other.Native() == recv.Native()
}

func (recv *TargetEntry) Native() unsafe.Pointer {
	return recv.native
}

// FieldTarget returns the C field 'target'.
func (recv *TargetEntry) FieldTarget() string {
	argValue := gi.StructFieldGet(targetEntryStruct, recv.Native(), "target")
	value := argValue.String(false)
	return value
}

// SetFieldTarget sets the value of the C field 'target'.
func (recv *TargetEntry) SetFieldTarget(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(targetEntryStruct, recv.Native(), "target", argValue)
}

// FieldFlags returns the C field 'flags'.
func (recv *TargetEntry) FieldFlags() uint32 {
	argValue := gi.StructFieldGet(targetEntryStruct, recv.Native(), "flags")
	value := argValue.Uint32()
	return value
}

// SetFieldFlags sets the value of the C field 'flags'.
func (recv *TargetEntry) SetFieldFlags(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(targetEntryStruct, recv.Native(), "flags", argValue)
}

// FieldInfo returns the C field 'info'.
func (recv *TargetEntry) FieldInfo() uint32 {
	argValue := gi.StructFieldGet(targetEntryStruct, recv.Native(), "info")
	value := argValue.Uint32()
	return value
}

// SetFieldInfo sets the value of the C field 'info'.
func (recv *TargetEntry) SetFieldInfo(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(targetEntryStruct, recv.Native(), "info", argValue)
}

var targetEntryNewFunction *gi.Function
var targetEntryNewFunction_Once sync.Once

func targetEntryNewFunction_Set() error {
	var err error
	targetEntryNewFunction_Once.Do(func() {
		err = targetEntryStruct_Set()
		if err != nil {
			return
		}
		targetEntryNewFunction, err = targetEntryStruct.InvokerNew("new")
	})
	return err
}

// TargetEntryNew is a representation of the C type gtk_target_entry_new.
func TargetEntryNew(target string, flags uint32, info uint32) *TargetEntry {
	var inArgs [3]gi.Argument
	inArgs[0].SetString(target)
	inArgs[1].SetUint32(flags)
	inArgs[2].SetUint32(info)

	var ret gi.Argument

	err := targetEntryNewFunction_Set()
	if err == nil {
		ret = targetEntryNewFunction.Invoke(inArgs[:], nil)
	}

	retGo := TargetEntryNewFromNative(ret.Pointer())

	return retGo
}

var targetEntryCopyFunction *gi.Function
var targetEntryCopyFunction_Once sync.Once

func targetEntryCopyFunction_Set() error {
	var err error
	targetEntryCopyFunction_Once.Do(func() {
		err = targetEntryStruct_Set()
		if err != nil {
			return
		}
		targetEntryCopyFunction, err = targetEntryStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_target_entry_copy.
func (recv *TargetEntry) Copy() *TargetEntry {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := targetEntryCopyFunction_Set()
	if err == nil {
		ret = targetEntryCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := TargetEntryNewFromNative(ret.Pointer())

	return retGo
}

var targetEntryFreeFunction *gi.Function
var targetEntryFreeFunction_Once sync.Once

func targetEntryFreeFunction_Set() error {
	var err error
	targetEntryFreeFunction_Once.Do(func() {
		err = targetEntryStruct_Set()
		if err != nil {
			return
		}
		targetEntryFreeFunction, err = targetEntryStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_target_entry_free.
func (recv *TargetEntry) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := targetEntryFreeFunction_Set()
	if err == nil {
		targetEntryFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var targetListStruct *gi.Struct
var targetListStruct_Once sync.Once

func targetListStruct_Set() error {
	var err error
	targetListStruct_Once.Do(func() {
		targetListStruct, err = gi.StructNew("Gtk", "TargetList")
	})
	return err
}

type TargetList struct {
	native unsafe.Pointer
}

func TargetListNewFromNative(native unsafe.Pointer) *TargetList {
	err := targetListStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TargetList{native: native}

	return instance
}

/*
CastToTargetList down casts any arbitrary Object to TargetList.
Exercise care, as this is a potentially dangerous function
if the Object is not a TargetList.
*/
func CastToTargetList(object *gobject.Object) *TargetList {
	return TargetListNewFromNative(object.Native())
}

// Equals compares this TargetList with another TargetList, and returns true if they represent the same Object.
func (recv *TargetList) Equals(other *TargetList) bool {
	return other.Native() == recv.Native()
}

func (recv *TargetList) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'gtk_target_list_new' : array parameter 'targets'

var targetListAddFunction *gi.Function
var targetListAddFunction_Once sync.Once

func targetListAddFunction_Set() error {
	var err error
	targetListAddFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListAddFunction, err = targetListStruct.InvokerNew("add")
	})
	return err
}

// Add is a representation of the C type gtk_target_list_add.
func (recv *TargetList) Add(target *gdk.Atom, flags uint32, info uint32) {
	var inArgs [4]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(target.Native())
	inArgs[2].SetUint32(flags)
	inArgs[3].SetUint32(info)

	err := targetListAddFunction_Set()
	if err == nil {
		targetListAddFunction.Invoke(inArgs[:], nil)
	}

	return
}

var targetListAddImageTargetsFunction *gi.Function
var targetListAddImageTargetsFunction_Once sync.Once

func targetListAddImageTargetsFunction_Set() error {
	var err error
	targetListAddImageTargetsFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListAddImageTargetsFunction, err = targetListStruct.InvokerNew("add_image_targets")
	})
	return err
}

// AddImageTargets is a representation of the C type gtk_target_list_add_image_targets.
func (recv *TargetList) AddImageTargets(info uint32, writable bool) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetUint32(info)
	inArgs[2].SetBoolean(writable)

	err := targetListAddImageTargetsFunction_Set()
	if err == nil {
		targetListAddImageTargetsFunction.Invoke(inArgs[:], nil)
	}

	return
}

var targetListAddRichTextTargetsFunction *gi.Function
var targetListAddRichTextTargetsFunction_Once sync.Once

func targetListAddRichTextTargetsFunction_Set() error {
	var err error
	targetListAddRichTextTargetsFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListAddRichTextTargetsFunction, err = targetListStruct.InvokerNew("add_rich_text_targets")
	})
	return err
}

// AddRichTextTargets is a representation of the C type gtk_target_list_add_rich_text_targets.
func (recv *TargetList) AddRichTextTargets(info uint32, deserializable bool, buffer *TextBuffer) {
	var inArgs [4]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetUint32(info)
	inArgs[2].SetBoolean(deserializable)
	inArgs[3].SetPointer(buffer.Native())

	err := targetListAddRichTextTargetsFunction_Set()
	if err == nil {
		targetListAddRichTextTargetsFunction.Invoke(inArgs[:], nil)
	}

	return
}

// UNSUPPORTED : C value 'gtk_target_list_add_table' : array parameter 'targets'

var targetListAddTextTargetsFunction *gi.Function
var targetListAddTextTargetsFunction_Once sync.Once

func targetListAddTextTargetsFunction_Set() error {
	var err error
	targetListAddTextTargetsFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListAddTextTargetsFunction, err = targetListStruct.InvokerNew("add_text_targets")
	})
	return err
}

// AddTextTargets is a representation of the C type gtk_target_list_add_text_targets.
func (recv *TargetList) AddTextTargets(info uint32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetUint32(info)

	err := targetListAddTextTargetsFunction_Set()
	if err == nil {
		targetListAddTextTargetsFunction.Invoke(inArgs[:], nil)
	}

	return
}

var targetListAddUriTargetsFunction *gi.Function
var targetListAddUriTargetsFunction_Once sync.Once

func targetListAddUriTargetsFunction_Set() error {
	var err error
	targetListAddUriTargetsFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListAddUriTargetsFunction, err = targetListStruct.InvokerNew("add_uri_targets")
	})
	return err
}

// AddUriTargets is a representation of the C type gtk_target_list_add_uri_targets.
func (recv *TargetList) AddUriTargets(info uint32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetUint32(info)

	err := targetListAddUriTargetsFunction_Set()
	if err == nil {
		targetListAddUriTargetsFunction.Invoke(inArgs[:], nil)
	}

	return
}

var targetListFindFunction *gi.Function
var targetListFindFunction_Once sync.Once

func targetListFindFunction_Set() error {
	var err error
	targetListFindFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListFindFunction, err = targetListStruct.InvokerNew("find")
	})
	return err
}

// Find is a representation of the C type gtk_target_list_find.
func (recv *TargetList) Find(target *gdk.Atom) (bool, uint32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(target.Native())

	var outArgs [1]gi.Argument
	var ret gi.Argument

	err := targetListFindFunction_Set()
	if err == nil {
		ret = targetListFindFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := outArgs[0].Uint32()

	return retGo, out0
}

var targetListRefFunction *gi.Function
var targetListRefFunction_Once sync.Once

func targetListRefFunction_Set() error {
	var err error
	targetListRefFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListRefFunction, err = targetListStruct.InvokerNew("ref")
	})
	return err
}

// Ref is a representation of the C type gtk_target_list_ref.
func (recv *TargetList) Ref() *TargetList {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := targetListRefFunction_Set()
	if err == nil {
		ret = targetListRefFunction.Invoke(inArgs[:], nil)
	}

	retGo := TargetListNewFromNative(ret.Pointer())

	return retGo
}

var targetListRemoveFunction *gi.Function
var targetListRemoveFunction_Once sync.Once

func targetListRemoveFunction_Set() error {
	var err error
	targetListRemoveFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListRemoveFunction, err = targetListStruct.InvokerNew("remove")
	})
	return err
}

// Remove is a representation of the C type gtk_target_list_remove.
func (recv *TargetList) Remove(target *gdk.Atom) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(target.Native())

	err := targetListRemoveFunction_Set()
	if err == nil {
		targetListRemoveFunction.Invoke(inArgs[:], nil)
	}

	return
}

var targetListUnrefFunction *gi.Function
var targetListUnrefFunction_Once sync.Once

func targetListUnrefFunction_Set() error {
	var err error
	targetListUnrefFunction_Once.Do(func() {
		err = targetListStruct_Set()
		if err != nil {
			return
		}
		targetListUnrefFunction, err = targetListStruct.InvokerNew("unref")
	})
	return err
}

// Unref is a representation of the C type gtk_target_list_unref.
func (recv *TargetList) Unref() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := targetListUnrefFunction_Set()
	if err == nil {
		targetListUnrefFunction.Invoke(inArgs[:], nil)
	}

	return
}

var targetPairStruct *gi.Struct
var targetPairStruct_Once sync.Once

func targetPairStruct_Set() error {
	var err error
	targetPairStruct_Once.Do(func() {
		targetPairStruct, err = gi.StructNew("Gtk", "TargetPair")
	})
	return err
}

type TargetPair struct {
	native unsafe.Pointer
}

func TargetPairNewFromNative(native unsafe.Pointer) *TargetPair {
	err := targetPairStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TargetPair{native: native}

	return instance
}

/*
CastToTargetPair down casts any arbitrary Object to TargetPair.
Exercise care, as this is a potentially dangerous function
if the Object is not a TargetPair.
*/
func CastToTargetPair(object *gobject.Object) *TargetPair {
	return TargetPairNewFromNative(object.Native())
}

// Equals compares this TargetPair with another TargetPair, and returns true if they represent the same Object.
func (recv *TargetPair) Equals(other *TargetPair) bool {
	return other.Native() == recv.Native()
}

func (recv *TargetPair) Native() unsafe.Pointer {
	return recv.native
}

// FieldTarget returns the C field 'target'.
func (recv *TargetPair) FieldTarget() *gdk.Atom {
	argValue := gi.StructFieldGet(targetPairStruct, recv.Native(), "target")
	value := gdk.AtomNewFromNative(argValue.Pointer())
	return value
}

// SetFieldTarget sets the value of the C field 'target'.
func (recv *TargetPair) SetFieldTarget(value *gdk.Atom) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(targetPairStruct, recv.Native(), "target", argValue)
}

// FieldFlags returns the C field 'flags'.
func (recv *TargetPair) FieldFlags() uint32 {
	argValue := gi.StructFieldGet(targetPairStruct, recv.Native(), "flags")
	value := argValue.Uint32()
	return value
}

// SetFieldFlags sets the value of the C field 'flags'.
func (recv *TargetPair) SetFieldFlags(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(targetPairStruct, recv.Native(), "flags", argValue)
}

// FieldInfo returns the C field 'info'.
func (recv *TargetPair) FieldInfo() uint32 {
	argValue := gi.StructFieldGet(targetPairStruct, recv.Native(), "info")
	value := argValue.Uint32()
	return value
}

// SetFieldInfo sets the value of the C field 'info'.
func (recv *TargetPair) SetFieldInfo(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(targetPairStruct, recv.Native(), "info", argValue)
}

// TargetPairStruct creates an uninitialised TargetPair.
func TargetPairStruct() *TargetPair {
	err := targetPairStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TargetPairNewFromNative(targetPairStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTargetPair)
	return structGo
}
func finalizeTargetPair(obj *TargetPair) {
	targetPairStruct.Free(obj.Native())
}

var tearoffMenuItemClassStruct *gi.Struct
var tearoffMenuItemClassStruct_Once sync.Once

func tearoffMenuItemClassStruct_Set() error {
	var err error
	tearoffMenuItemClassStruct_Once.Do(func() {
		tearoffMenuItemClassStruct, err = gi.StructNew("Gtk", "TearoffMenuItemClass")
	})
	return err
}

type TearoffMenuItemClass struct {
	native unsafe.Pointer
}

func TearoffMenuItemClassNewFromNative(native unsafe.Pointer) *TearoffMenuItemClass {
	err := tearoffMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TearoffMenuItemClass{native: native}

	return instance
}

/*
CastToTearoffMenuItemClass down casts any arbitrary Object to TearoffMenuItemClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TearoffMenuItemClass.
*/
func CastToTearoffMenuItemClass(object *gobject.Object) *TearoffMenuItemClass {
	return TearoffMenuItemClassNewFromNative(object.Native())
}

// Equals compares this TearoffMenuItemClass with another TearoffMenuItemClass, and returns true if they represent the same Object.
func (recv *TearoffMenuItemClass) Equals(other *TearoffMenuItemClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TearoffMenuItemClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TearoffMenuItemClass) FieldParentClass() *MenuItemClass {
	argValue := gi.StructFieldGet(tearoffMenuItemClassStruct, recv.Native(), "parent_class")
	value := MenuItemClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TearoffMenuItemClass) SetFieldParentClass(value *MenuItemClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(tearoffMenuItemClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TearoffMenuItemClassStruct creates an uninitialised TearoffMenuItemClass.
func TearoffMenuItemClassStruct() *TearoffMenuItemClass {
	err := tearoffMenuItemClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TearoffMenuItemClassNewFromNative(tearoffMenuItemClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTearoffMenuItemClass)
	return structGo
}
func finalizeTearoffMenuItemClass(obj *TearoffMenuItemClass) {
	tearoffMenuItemClassStruct.Free(obj.Native())
}

var tearoffMenuItemPrivateStruct *gi.Struct
var tearoffMenuItemPrivateStruct_Once sync.Once

func tearoffMenuItemPrivateStruct_Set() error {
	var err error
	tearoffMenuItemPrivateStruct_Once.Do(func() {
		tearoffMenuItemPrivateStruct, err = gi.StructNew("Gtk", "TearoffMenuItemPrivate")
	})
	return err
}

type TearoffMenuItemPrivate struct {
	native unsafe.Pointer
}

func TearoffMenuItemPrivateNewFromNative(native unsafe.Pointer) *TearoffMenuItemPrivate {
	err := tearoffMenuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TearoffMenuItemPrivate{native: native}

	return instance
}

/*
CastToTearoffMenuItemPrivate down casts any arbitrary Object to TearoffMenuItemPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TearoffMenuItemPrivate.
*/
func CastToTearoffMenuItemPrivate(object *gobject.Object) *TearoffMenuItemPrivate {
	return TearoffMenuItemPrivateNewFromNative(object.Native())
}

// Equals compares this TearoffMenuItemPrivate with another TearoffMenuItemPrivate, and returns true if they represent the same Object.
func (recv *TearoffMenuItemPrivate) Equals(other *TearoffMenuItemPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TearoffMenuItemPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TearoffMenuItemPrivateStruct creates an uninitialised TearoffMenuItemPrivate.
func TearoffMenuItemPrivateStruct() *TearoffMenuItemPrivate {
	err := tearoffMenuItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TearoffMenuItemPrivateNewFromNative(tearoffMenuItemPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTearoffMenuItemPrivate)
	return structGo
}
func finalizeTearoffMenuItemPrivate(obj *TearoffMenuItemPrivate) {
	tearoffMenuItemPrivateStruct.Free(obj.Native())
}

var textAppearanceStruct *gi.Struct
var textAppearanceStruct_Once sync.Once

func textAppearanceStruct_Set() error {
	var err error
	textAppearanceStruct_Once.Do(func() {
		textAppearanceStruct, err = gi.StructNew("Gtk", "TextAppearance")
	})
	return err
}

type TextAppearance struct {
	native unsafe.Pointer
}

func TextAppearanceNewFromNative(native unsafe.Pointer) *TextAppearance {
	err := textAppearanceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextAppearance{native: native}

	return instance
}

/*
CastToTextAppearance down casts any arbitrary Object to TextAppearance.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextAppearance.
*/
func CastToTextAppearance(object *gobject.Object) *TextAppearance {
	return TextAppearanceNewFromNative(object.Native())
}

// Equals compares this TextAppearance with another TextAppearance, and returns true if they represent the same Object.
func (recv *TextAppearance) Equals(other *TextAppearance) bool {
	return other.Native() == recv.Native()
}

func (recv *TextAppearance) Native() unsafe.Pointer {
	return recv.native
}

// FieldBgColor returns the C field 'bg_color'.
func (recv *TextAppearance) FieldBgColor() *gdk.Color {
	argValue := gi.StructFieldGet(textAppearanceStruct, recv.Native(), "bg_color")
	value := gdk.ColorNewFromNative(argValue.Pointer())
	return value
}

// SetFieldBgColor sets the value of the C field 'bg_color'.
func (recv *TextAppearance) SetFieldBgColor(value *gdk.Color) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textAppearanceStruct, recv.Native(), "bg_color", argValue)
}

// FieldFgColor returns the C field 'fg_color'.
func (recv *TextAppearance) FieldFgColor() *gdk.Color {
	argValue := gi.StructFieldGet(textAppearanceStruct, recv.Native(), "fg_color")
	value := gdk.ColorNewFromNative(argValue.Pointer())
	return value
}

// SetFieldFgColor sets the value of the C field 'fg_color'.
func (recv *TextAppearance) SetFieldFgColor(value *gdk.Color) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textAppearanceStruct, recv.Native(), "fg_color", argValue)
}

// FieldRise returns the C field 'rise'.
func (recv *TextAppearance) FieldRise() int32 {
	argValue := gi.StructFieldGet(textAppearanceStruct, recv.Native(), "rise")
	value := argValue.Int32()
	return value
}

// SetFieldRise sets the value of the C field 'rise'.
func (recv *TextAppearance) SetFieldRise(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(textAppearanceStruct, recv.Native(), "rise", argValue)
}

// FieldUnderline returns the C field 'underline'.
func (recv *TextAppearance) FieldUnderline() uint32 {
	argValue := gi.StructFieldGet(textAppearanceStruct, recv.Native(), "underline")
	value := argValue.Uint32()
	return value
}

// SetFieldUnderline sets the value of the C field 'underline'.
func (recv *TextAppearance) SetFieldUnderline(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAppearanceStruct, recv.Native(), "underline", argValue)
}

// FieldStrikethrough returns the C field 'strikethrough'.
func (recv *TextAppearance) FieldStrikethrough() uint32 {
	argValue := gi.StructFieldGet(textAppearanceStruct, recv.Native(), "strikethrough")
	value := argValue.Uint32()
	return value
}

// SetFieldStrikethrough sets the value of the C field 'strikethrough'.
func (recv *TextAppearance) SetFieldStrikethrough(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAppearanceStruct, recv.Native(), "strikethrough", argValue)
}

// FieldDrawBg returns the C field 'draw_bg'.
func (recv *TextAppearance) FieldDrawBg() uint32 {
	argValue := gi.StructFieldGet(textAppearanceStruct, recv.Native(), "draw_bg")
	value := argValue.Uint32()
	return value
}

// SetFieldDrawBg sets the value of the C field 'draw_bg'.
func (recv *TextAppearance) SetFieldDrawBg(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAppearanceStruct, recv.Native(), "draw_bg", argValue)
}

// FieldInsideSelection returns the C field 'inside_selection'.
func (recv *TextAppearance) FieldInsideSelection() uint32 {
	argValue := gi.StructFieldGet(textAppearanceStruct, recv.Native(), "inside_selection")
	value := argValue.Uint32()
	return value
}

// SetFieldInsideSelection sets the value of the C field 'inside_selection'.
func (recv *TextAppearance) SetFieldInsideSelection(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAppearanceStruct, recv.Native(), "inside_selection", argValue)
}

// FieldIsText returns the C field 'is_text'.
func (recv *TextAppearance) FieldIsText() uint32 {
	argValue := gi.StructFieldGet(textAppearanceStruct, recv.Native(), "is_text")
	value := argValue.Uint32()
	return value
}

// SetFieldIsText sets the value of the C field 'is_text'.
func (recv *TextAppearance) SetFieldIsText(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAppearanceStruct, recv.Native(), "is_text", argValue)
}

// TextAppearanceStruct creates an uninitialised TextAppearance.
func TextAppearanceStruct() *TextAppearance {
	err := textAppearanceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextAppearanceNewFromNative(textAppearanceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextAppearance)
	return structGo
}
func finalizeTextAppearance(obj *TextAppearance) {
	textAppearanceStruct.Free(obj.Native())
}

var textAttributesStruct *gi.Struct
var textAttributesStruct_Once sync.Once

func textAttributesStruct_Set() error {
	var err error
	textAttributesStruct_Once.Do(func() {
		textAttributesStruct, err = gi.StructNew("Gtk", "TextAttributes")
	})
	return err
}

type TextAttributes struct {
	native unsafe.Pointer
}

func TextAttributesNewFromNative(native unsafe.Pointer) *TextAttributes {
	err := textAttributesStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextAttributes{native: native}

	return instance
}

/*
CastToTextAttributes down casts any arbitrary Object to TextAttributes.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextAttributes.
*/
func CastToTextAttributes(object *gobject.Object) *TextAttributes {
	return TextAttributesNewFromNative(object.Native())
}

// Equals compares this TextAttributes with another TextAttributes, and returns true if they represent the same Object.
func (recv *TextAttributes) Equals(other *TextAttributes) bool {
	return other.Native() == recv.Native()
}

func (recv *TextAttributes) Native() unsafe.Pointer {
	return recv.native
}

// FieldAppearance returns the C field 'appearance'.
func (recv *TextAttributes) FieldAppearance() *TextAppearance {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "appearance")
	value := TextAppearanceNewFromNative(argValue.Pointer())
	return value
}

// SetFieldAppearance sets the value of the C field 'appearance'.
func (recv *TextAttributes) SetFieldAppearance(value *TextAppearance) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "appearance", argValue)
}

// FieldJustification returns the C field 'justification'.
func (recv *TextAttributes) FieldJustification() Justification {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "justification")
	value := Justification(argValue.Int32())
	return value
}

// SetFieldJustification sets the value of the C field 'justification'.
func (recv *TextAttributes) SetFieldJustification(value Justification) {
	var argValue gi.Argument
	argValue.SetInt32(int32(value))
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "justification", argValue)
}

// FieldDirection returns the C field 'direction'.
func (recv *TextAttributes) FieldDirection() TextDirection {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "direction")
	value := TextDirection(argValue.Int32())
	return value
}

// SetFieldDirection sets the value of the C field 'direction'.
func (recv *TextAttributes) SetFieldDirection(value TextDirection) {
	var argValue gi.Argument
	argValue.SetInt32(int32(value))
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "direction", argValue)
}

// FieldFont returns the C field 'font'.
func (recv *TextAttributes) FieldFont() *pango.FontDescription {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "font")
	value := pango.FontDescriptionNewFromNative(argValue.Pointer())
	return value
}

// SetFieldFont sets the value of the C field 'font'.
func (recv *TextAttributes) SetFieldFont(value *pango.FontDescription) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "font", argValue)
}

// FieldFontScale returns the C field 'font_scale'.
func (recv *TextAttributes) FieldFontScale() float64 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "font_scale")
	value := argValue.Float64()
	return value
}

// SetFieldFontScale sets the value of the C field 'font_scale'.
func (recv *TextAttributes) SetFieldFontScale(value float64) {
	var argValue gi.Argument
	argValue.SetFloat64(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "font_scale", argValue)
}

// FieldLeftMargin returns the C field 'left_margin'.
func (recv *TextAttributes) FieldLeftMargin() int32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "left_margin")
	value := argValue.Int32()
	return value
}

// SetFieldLeftMargin sets the value of the C field 'left_margin'.
func (recv *TextAttributes) SetFieldLeftMargin(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "left_margin", argValue)
}

// FieldRightMargin returns the C field 'right_margin'.
func (recv *TextAttributes) FieldRightMargin() int32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "right_margin")
	value := argValue.Int32()
	return value
}

// SetFieldRightMargin sets the value of the C field 'right_margin'.
func (recv *TextAttributes) SetFieldRightMargin(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "right_margin", argValue)
}

// FieldIndent returns the C field 'indent'.
func (recv *TextAttributes) FieldIndent() int32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "indent")
	value := argValue.Int32()
	return value
}

// SetFieldIndent sets the value of the C field 'indent'.
func (recv *TextAttributes) SetFieldIndent(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "indent", argValue)
}

// FieldPixelsAboveLines returns the C field 'pixels_above_lines'.
func (recv *TextAttributes) FieldPixelsAboveLines() int32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "pixels_above_lines")
	value := argValue.Int32()
	return value
}

// SetFieldPixelsAboveLines sets the value of the C field 'pixels_above_lines'.
func (recv *TextAttributes) SetFieldPixelsAboveLines(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "pixels_above_lines", argValue)
}

// FieldPixelsBelowLines returns the C field 'pixels_below_lines'.
func (recv *TextAttributes) FieldPixelsBelowLines() int32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "pixels_below_lines")
	value := argValue.Int32()
	return value
}

// SetFieldPixelsBelowLines sets the value of the C field 'pixels_below_lines'.
func (recv *TextAttributes) SetFieldPixelsBelowLines(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "pixels_below_lines", argValue)
}

// FieldPixelsInsideWrap returns the C field 'pixels_inside_wrap'.
func (recv *TextAttributes) FieldPixelsInsideWrap() int32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "pixels_inside_wrap")
	value := argValue.Int32()
	return value
}

// SetFieldPixelsInsideWrap sets the value of the C field 'pixels_inside_wrap'.
func (recv *TextAttributes) SetFieldPixelsInsideWrap(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "pixels_inside_wrap", argValue)
}

// FieldTabs returns the C field 'tabs'.
func (recv *TextAttributes) FieldTabs() *pango.TabArray {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "tabs")
	value := pango.TabArrayNewFromNative(argValue.Pointer())
	return value
}

// SetFieldTabs sets the value of the C field 'tabs'.
func (recv *TextAttributes) SetFieldTabs(value *pango.TabArray) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "tabs", argValue)
}

// FieldWrapMode returns the C field 'wrap_mode'.
func (recv *TextAttributes) FieldWrapMode() WrapMode {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "wrap_mode")
	value := WrapMode(argValue.Int32())
	return value
}

// SetFieldWrapMode sets the value of the C field 'wrap_mode'.
func (recv *TextAttributes) SetFieldWrapMode(value WrapMode) {
	var argValue gi.Argument
	argValue.SetInt32(int32(value))
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "wrap_mode", argValue)
}

// FieldLanguage returns the C field 'language'.
func (recv *TextAttributes) FieldLanguage() *pango.Language {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "language")
	value := pango.LanguageNewFromNative(argValue.Pointer())
	return value
}

// SetFieldLanguage sets the value of the C field 'language'.
func (recv *TextAttributes) SetFieldLanguage(value *pango.Language) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "language", argValue)
}

// FieldInvisible returns the C field 'invisible'.
func (recv *TextAttributes) FieldInvisible() uint32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "invisible")
	value := argValue.Uint32()
	return value
}

// SetFieldInvisible sets the value of the C field 'invisible'.
func (recv *TextAttributes) SetFieldInvisible(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "invisible", argValue)
}

// FieldBgFullHeight returns the C field 'bg_full_height'.
func (recv *TextAttributes) FieldBgFullHeight() uint32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "bg_full_height")
	value := argValue.Uint32()
	return value
}

// SetFieldBgFullHeight sets the value of the C field 'bg_full_height'.
func (recv *TextAttributes) SetFieldBgFullHeight(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "bg_full_height", argValue)
}

// FieldEditable returns the C field 'editable'.
func (recv *TextAttributes) FieldEditable() uint32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "editable")
	value := argValue.Uint32()
	return value
}

// SetFieldEditable sets the value of the C field 'editable'.
func (recv *TextAttributes) SetFieldEditable(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "editable", argValue)
}

// FieldNoFallback returns the C field 'no_fallback'.
func (recv *TextAttributes) FieldNoFallback() uint32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "no_fallback")
	value := argValue.Uint32()
	return value
}

// SetFieldNoFallback sets the value of the C field 'no_fallback'.
func (recv *TextAttributes) SetFieldNoFallback(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "no_fallback", argValue)
}

// FieldLetterSpacing returns the C field 'letter_spacing'.
func (recv *TextAttributes) FieldLetterSpacing() int32 {
	argValue := gi.StructFieldGet(textAttributesStruct, recv.Native(), "letter_spacing")
	value := argValue.Int32()
	return value
}

// SetFieldLetterSpacing sets the value of the C field 'letter_spacing'.
func (recv *TextAttributes) SetFieldLetterSpacing(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(textAttributesStruct, recv.Native(), "letter_spacing", argValue)
}

var textAttributesNewFunction *gi.Function
var textAttributesNewFunction_Once sync.Once

func textAttributesNewFunction_Set() error {
	var err error
	textAttributesNewFunction_Once.Do(func() {
		err = textAttributesStruct_Set()
		if err != nil {
			return
		}
		textAttributesNewFunction, err = textAttributesStruct.InvokerNew("new")
	})
	return err
}

// TextAttributesNew is a representation of the C type gtk_text_attributes_new.
func TextAttributesNew() *TextAttributes {

	var ret gi.Argument

	err := textAttributesNewFunction_Set()
	if err == nil {
		ret = textAttributesNewFunction.Invoke(nil, nil)
	}

	retGo := TextAttributesNewFromNative(ret.Pointer())

	return retGo
}

var textAttributesCopyFunction *gi.Function
var textAttributesCopyFunction_Once sync.Once

func textAttributesCopyFunction_Set() error {
	var err error
	textAttributesCopyFunction_Once.Do(func() {
		err = textAttributesStruct_Set()
		if err != nil {
			return
		}
		textAttributesCopyFunction, err = textAttributesStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_text_attributes_copy.
func (recv *TextAttributes) Copy() *TextAttributes {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textAttributesCopyFunction_Set()
	if err == nil {
		ret = textAttributesCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := TextAttributesNewFromNative(ret.Pointer())

	return retGo
}

var textAttributesCopyValuesFunction *gi.Function
var textAttributesCopyValuesFunction_Once sync.Once

func textAttributesCopyValuesFunction_Set() error {
	var err error
	textAttributesCopyValuesFunction_Once.Do(func() {
		err = textAttributesStruct_Set()
		if err != nil {
			return
		}
		textAttributesCopyValuesFunction, err = textAttributesStruct.InvokerNew("copy_values")
	})
	return err
}

// CopyValues is a representation of the C type gtk_text_attributes_copy_values.
func (recv *TextAttributes) CopyValues(dest *TextAttributes) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(dest.Native())

	err := textAttributesCopyValuesFunction_Set()
	if err == nil {
		textAttributesCopyValuesFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textAttributesRefFunction *gi.Function
var textAttributesRefFunction_Once sync.Once

func textAttributesRefFunction_Set() error {
	var err error
	textAttributesRefFunction_Once.Do(func() {
		err = textAttributesStruct_Set()
		if err != nil {
			return
		}
		textAttributesRefFunction, err = textAttributesStruct.InvokerNew("ref")
	})
	return err
}

// Ref is a representation of the C type gtk_text_attributes_ref.
func (recv *TextAttributes) Ref() *TextAttributes {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textAttributesRefFunction_Set()
	if err == nil {
		ret = textAttributesRefFunction.Invoke(inArgs[:], nil)
	}

	retGo := TextAttributesNewFromNative(ret.Pointer())

	return retGo
}

var textAttributesUnrefFunction *gi.Function
var textAttributesUnrefFunction_Once sync.Once

func textAttributesUnrefFunction_Set() error {
	var err error
	textAttributesUnrefFunction_Once.Do(func() {
		err = textAttributesStruct_Set()
		if err != nil {
			return
		}
		textAttributesUnrefFunction, err = textAttributesStruct.InvokerNew("unref")
	})
	return err
}

// Unref is a representation of the C type gtk_text_attributes_unref.
func (recv *TextAttributes) Unref() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := textAttributesUnrefFunction_Set()
	if err == nil {
		textAttributesUnrefFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textBTreeStruct *gi.Struct
var textBTreeStruct_Once sync.Once

func textBTreeStruct_Set() error {
	var err error
	textBTreeStruct_Once.Do(func() {
		textBTreeStruct, err = gi.StructNew("Gtk", "TextBTree")
	})
	return err
}

type TextBTree struct {
	native unsafe.Pointer
}

func TextBTreeNewFromNative(native unsafe.Pointer) *TextBTree {
	err := textBTreeStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextBTree{native: native}

	return instance
}

/*
CastToTextBTree down casts any arbitrary Object to TextBTree.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextBTree.
*/
func CastToTextBTree(object *gobject.Object) *TextBTree {
	return TextBTreeNewFromNative(object.Native())
}

// Equals compares this TextBTree with another TextBTree, and returns true if they represent the same Object.
func (recv *TextBTree) Equals(other *TextBTree) bool {
	return other.Native() == recv.Native()
}

func (recv *TextBTree) Native() unsafe.Pointer {
	return recv.native
}

// TextBTreeStruct creates an uninitialised TextBTree.
func TextBTreeStruct() *TextBTree {
	err := textBTreeStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextBTreeNewFromNative(textBTreeStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextBTree)
	return structGo
}
func finalizeTextBTree(obj *TextBTree) {
	textBTreeStruct.Free(obj.Native())
}

var textBufferClassStruct *gi.Struct
var textBufferClassStruct_Once sync.Once

func textBufferClassStruct_Set() error {
	var err error
	textBufferClassStruct_Once.Do(func() {
		textBufferClassStruct, err = gi.StructNew("Gtk", "TextBufferClass")
	})
	return err
}

type TextBufferClass struct {
	native unsafe.Pointer
}

func TextBufferClassNewFromNative(native unsafe.Pointer) *TextBufferClass {
	err := textBufferClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextBufferClass{native: native}

	return instance
}

/*
CastToTextBufferClass down casts any arbitrary Object to TextBufferClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextBufferClass.
*/
func CastToTextBufferClass(object *gobject.Object) *TextBufferClass {
	return TextBufferClassNewFromNative(object.Native())
}

// Equals compares this TextBufferClass with another TextBufferClass, and returns true if they represent the same Object.
func (recv *TextBufferClass) Equals(other *TextBufferClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TextBufferClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TextBufferClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(textBufferClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TextBufferClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textBufferClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'insert_text' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_text' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_pixbuf' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_pixbuf' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_child_anchor' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_child_anchor' : for field setter : missing Type

// UNSUPPORTED : C value 'delete_range' : for field getter : missing Type

// UNSUPPORTED : C value 'delete_range' : for field setter : missing Type

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value 'modified_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'modified_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'mark_set' : for field getter : missing Type

// UNSUPPORTED : C value 'mark_set' : for field setter : missing Type

// UNSUPPORTED : C value 'mark_deleted' : for field getter : missing Type

// UNSUPPORTED : C value 'mark_deleted' : for field setter : missing Type

// UNSUPPORTED : C value 'apply_tag' : for field getter : missing Type

// UNSUPPORTED : C value 'apply_tag' : for field setter : missing Type

// UNSUPPORTED : C value 'remove_tag' : for field getter : missing Type

// UNSUPPORTED : C value 'remove_tag' : for field setter : missing Type

// UNSUPPORTED : C value 'begin_user_action' : for field getter : missing Type

// UNSUPPORTED : C value 'begin_user_action' : for field setter : missing Type

// UNSUPPORTED : C value 'end_user_action' : for field getter : missing Type

// UNSUPPORTED : C value 'end_user_action' : for field setter : missing Type

// UNSUPPORTED : C value 'paste_done' : for field getter : missing Type

// UNSUPPORTED : C value 'paste_done' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TextBufferClassStruct creates an uninitialised TextBufferClass.
func TextBufferClassStruct() *TextBufferClass {
	err := textBufferClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextBufferClassNewFromNative(textBufferClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextBufferClass)
	return structGo
}
func finalizeTextBufferClass(obj *TextBufferClass) {
	textBufferClassStruct.Free(obj.Native())
}

var textBufferPrivateStruct *gi.Struct
var textBufferPrivateStruct_Once sync.Once

func textBufferPrivateStruct_Set() error {
	var err error
	textBufferPrivateStruct_Once.Do(func() {
		textBufferPrivateStruct, err = gi.StructNew("Gtk", "TextBufferPrivate")
	})
	return err
}

type TextBufferPrivate struct {
	native unsafe.Pointer
}

func TextBufferPrivateNewFromNative(native unsafe.Pointer) *TextBufferPrivate {
	err := textBufferPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextBufferPrivate{native: native}

	return instance
}

/*
CastToTextBufferPrivate down casts any arbitrary Object to TextBufferPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextBufferPrivate.
*/
func CastToTextBufferPrivate(object *gobject.Object) *TextBufferPrivate {
	return TextBufferPrivateNewFromNative(object.Native())
}

// Equals compares this TextBufferPrivate with another TextBufferPrivate, and returns true if they represent the same Object.
func (recv *TextBufferPrivate) Equals(other *TextBufferPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TextBufferPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TextBufferPrivateStruct creates an uninitialised TextBufferPrivate.
func TextBufferPrivateStruct() *TextBufferPrivate {
	err := textBufferPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextBufferPrivateNewFromNative(textBufferPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextBufferPrivate)
	return structGo
}
func finalizeTextBufferPrivate(obj *TextBufferPrivate) {
	textBufferPrivateStruct.Free(obj.Native())
}

var textCellAccessibleClassStruct *gi.Struct
var textCellAccessibleClassStruct_Once sync.Once

func textCellAccessibleClassStruct_Set() error {
	var err error
	textCellAccessibleClassStruct_Once.Do(func() {
		textCellAccessibleClassStruct, err = gi.StructNew("Gtk", "TextCellAccessibleClass")
	})
	return err
}

type TextCellAccessibleClass struct {
	native unsafe.Pointer
}

func TextCellAccessibleClassNewFromNative(native unsafe.Pointer) *TextCellAccessibleClass {
	err := textCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextCellAccessibleClass{native: native}

	return instance
}

/*
CastToTextCellAccessibleClass down casts any arbitrary Object to TextCellAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextCellAccessibleClass.
*/
func CastToTextCellAccessibleClass(object *gobject.Object) *TextCellAccessibleClass {
	return TextCellAccessibleClassNewFromNative(object.Native())
}

// Equals compares this TextCellAccessibleClass with another TextCellAccessibleClass, and returns true if they represent the same Object.
func (recv *TextCellAccessibleClass) Equals(other *TextCellAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TextCellAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TextCellAccessibleClass) FieldParentClass() *RendererCellAccessibleClass {
	argValue := gi.StructFieldGet(textCellAccessibleClassStruct, recv.Native(), "parent_class")
	value := RendererCellAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TextCellAccessibleClass) SetFieldParentClass(value *RendererCellAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textCellAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// TextCellAccessibleClassStruct creates an uninitialised TextCellAccessibleClass.
func TextCellAccessibleClassStruct() *TextCellAccessibleClass {
	err := textCellAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextCellAccessibleClassNewFromNative(textCellAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextCellAccessibleClass)
	return structGo
}
func finalizeTextCellAccessibleClass(obj *TextCellAccessibleClass) {
	textCellAccessibleClassStruct.Free(obj.Native())
}

var textCellAccessiblePrivateStruct *gi.Struct
var textCellAccessiblePrivateStruct_Once sync.Once

func textCellAccessiblePrivateStruct_Set() error {
	var err error
	textCellAccessiblePrivateStruct_Once.Do(func() {
		textCellAccessiblePrivateStruct, err = gi.StructNew("Gtk", "TextCellAccessiblePrivate")
	})
	return err
}

type TextCellAccessiblePrivate struct {
	native unsafe.Pointer
}

func TextCellAccessiblePrivateNewFromNative(native unsafe.Pointer) *TextCellAccessiblePrivate {
	err := textCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextCellAccessiblePrivate{native: native}

	return instance
}

/*
CastToTextCellAccessiblePrivate down casts any arbitrary Object to TextCellAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextCellAccessiblePrivate.
*/
func CastToTextCellAccessiblePrivate(object *gobject.Object) *TextCellAccessiblePrivate {
	return TextCellAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this TextCellAccessiblePrivate with another TextCellAccessiblePrivate, and returns true if they represent the same Object.
func (recv *TextCellAccessiblePrivate) Equals(other *TextCellAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TextCellAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// TextCellAccessiblePrivateStruct creates an uninitialised TextCellAccessiblePrivate.
func TextCellAccessiblePrivateStruct() *TextCellAccessiblePrivate {
	err := textCellAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextCellAccessiblePrivateNewFromNative(textCellAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextCellAccessiblePrivate)
	return structGo
}
func finalizeTextCellAccessiblePrivate(obj *TextCellAccessiblePrivate) {
	textCellAccessiblePrivateStruct.Free(obj.Native())
}

var textChildAnchorClassStruct *gi.Struct
var textChildAnchorClassStruct_Once sync.Once

func textChildAnchorClassStruct_Set() error {
	var err error
	textChildAnchorClassStruct_Once.Do(func() {
		textChildAnchorClassStruct, err = gi.StructNew("Gtk", "TextChildAnchorClass")
	})
	return err
}

type TextChildAnchorClass struct {
	native unsafe.Pointer
}

func TextChildAnchorClassNewFromNative(native unsafe.Pointer) *TextChildAnchorClass {
	err := textChildAnchorClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextChildAnchorClass{native: native}

	return instance
}

/*
CastToTextChildAnchorClass down casts any arbitrary Object to TextChildAnchorClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextChildAnchorClass.
*/
func CastToTextChildAnchorClass(object *gobject.Object) *TextChildAnchorClass {
	return TextChildAnchorClassNewFromNative(object.Native())
}

// Equals compares this TextChildAnchorClass with another TextChildAnchorClass, and returns true if they represent the same Object.
func (recv *TextChildAnchorClass) Equals(other *TextChildAnchorClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TextChildAnchorClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TextChildAnchorClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(textChildAnchorClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TextChildAnchorClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textChildAnchorClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TextChildAnchorClassStruct creates an uninitialised TextChildAnchorClass.
func TextChildAnchorClassStruct() *TextChildAnchorClass {
	err := textChildAnchorClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextChildAnchorClassNewFromNative(textChildAnchorClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextChildAnchorClass)
	return structGo
}
func finalizeTextChildAnchorClass(obj *TextChildAnchorClass) {
	textChildAnchorClassStruct.Free(obj.Native())
}

var textIterStruct *gi.Struct
var textIterStruct_Once sync.Once

func textIterStruct_Set() error {
	var err error
	textIterStruct_Once.Do(func() {
		textIterStruct, err = gi.StructNew("Gtk", "TextIter")
	})
	return err
}

type TextIter struct {
	native unsafe.Pointer
}

func TextIterNewFromNative(native unsafe.Pointer) *TextIter {
	err := textIterStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextIter{native: native}

	return instance
}

/*
CastToTextIter down casts any arbitrary Object to TextIter.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextIter.
*/
func CastToTextIter(object *gobject.Object) *TextIter {
	return TextIterNewFromNative(object.Native())
}

// Equals compares this TextIter with another TextIter, and returns true if they represent the same Object.
func (recv *TextIter) Equals(other *TextIter) bool {
	return other.Native() == recv.Native()
}

func (recv *TextIter) Native() unsafe.Pointer {
	return recv.native
}

var textIterAssignFunction *gi.Function
var textIterAssignFunction_Once sync.Once

func textIterAssignFunction_Set() error {
	var err error
	textIterAssignFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterAssignFunction, err = textIterStruct.InvokerNew("assign")
	})
	return err
}

// Assign is a representation of the C type gtk_text_iter_assign.
func (recv *TextIter) Assign(other *TextIter) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(other.Native())

	err := textIterAssignFunction_Set()
	if err == nil {
		textIterAssignFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterBackwardCharFunction *gi.Function
var textIterBackwardCharFunction_Once sync.Once

func textIterBackwardCharFunction_Set() error {
	var err error
	textIterBackwardCharFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardCharFunction, err = textIterStruct.InvokerNew("backward_char")
	})
	return err
}

// BackwardChar is a representation of the C type gtk_text_iter_backward_char.
func (recv *TextIter) BackwardChar() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterBackwardCharFunction_Set()
	if err == nil {
		ret = textIterBackwardCharFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardCharsFunction *gi.Function
var textIterBackwardCharsFunction_Once sync.Once

func textIterBackwardCharsFunction_Set() error {
	var err error
	textIterBackwardCharsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardCharsFunction, err = textIterStruct.InvokerNew("backward_chars")
	})
	return err
}

// BackwardChars is a representation of the C type gtk_text_iter_backward_chars.
func (recv *TextIter) BackwardChars(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterBackwardCharsFunction_Set()
	if err == nil {
		ret = textIterBackwardCharsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardCursorPositionFunction *gi.Function
var textIterBackwardCursorPositionFunction_Once sync.Once

func textIterBackwardCursorPositionFunction_Set() error {
	var err error
	textIterBackwardCursorPositionFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardCursorPositionFunction, err = textIterStruct.InvokerNew("backward_cursor_position")
	})
	return err
}

// BackwardCursorPosition is a representation of the C type gtk_text_iter_backward_cursor_position.
func (recv *TextIter) BackwardCursorPosition() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterBackwardCursorPositionFunction_Set()
	if err == nil {
		ret = textIterBackwardCursorPositionFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardCursorPositionsFunction *gi.Function
var textIterBackwardCursorPositionsFunction_Once sync.Once

func textIterBackwardCursorPositionsFunction_Set() error {
	var err error
	textIterBackwardCursorPositionsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardCursorPositionsFunction, err = textIterStruct.InvokerNew("backward_cursor_positions")
	})
	return err
}

// BackwardCursorPositions is a representation of the C type gtk_text_iter_backward_cursor_positions.
func (recv *TextIter) BackwardCursorPositions(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterBackwardCursorPositionsFunction_Set()
	if err == nil {
		ret = textIterBackwardCursorPositionsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

// UNSUPPORTED : C value 'gtk_text_iter_backward_find_char' : parameter 'pred' of type 'TextCharPredicate' not supported

var textIterBackwardLineFunction *gi.Function
var textIterBackwardLineFunction_Once sync.Once

func textIterBackwardLineFunction_Set() error {
	var err error
	textIterBackwardLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardLineFunction, err = textIterStruct.InvokerNew("backward_line")
	})
	return err
}

// BackwardLine is a representation of the C type gtk_text_iter_backward_line.
func (recv *TextIter) BackwardLine() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterBackwardLineFunction_Set()
	if err == nil {
		ret = textIterBackwardLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardLinesFunction *gi.Function
var textIterBackwardLinesFunction_Once sync.Once

func textIterBackwardLinesFunction_Set() error {
	var err error
	textIterBackwardLinesFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardLinesFunction, err = textIterStruct.InvokerNew("backward_lines")
	})
	return err
}

// BackwardLines is a representation of the C type gtk_text_iter_backward_lines.
func (recv *TextIter) BackwardLines(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterBackwardLinesFunction_Set()
	if err == nil {
		ret = textIterBackwardLinesFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardSearchFunction *gi.Function
var textIterBackwardSearchFunction_Once sync.Once

func textIterBackwardSearchFunction_Set() error {
	var err error
	textIterBackwardSearchFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardSearchFunction, err = textIterStruct.InvokerNew("backward_search")
	})
	return err
}

// BackwardSearch is a representation of the C type gtk_text_iter_backward_search.
func (recv *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (bool, *TextIter, *TextIter) {
	var inArgs [4]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(str)
	inArgs[2].SetInt32(int32(flags))
	inArgs[3].SetPointer(limit.Native())

	var outArgs [2]gi.Argument
	var ret gi.Argument

	err := textIterBackwardSearchFunction_Set()
	if err == nil {
		ret = textIterBackwardSearchFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := TextIterNewFromNative(outArgs[0].Pointer())
	out1 := TextIterNewFromNative(outArgs[1].Pointer())

	return retGo, out0, out1
}

var textIterBackwardSentenceStartFunction *gi.Function
var textIterBackwardSentenceStartFunction_Once sync.Once

func textIterBackwardSentenceStartFunction_Set() error {
	var err error
	textIterBackwardSentenceStartFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardSentenceStartFunction, err = textIterStruct.InvokerNew("backward_sentence_start")
	})
	return err
}

// BackwardSentenceStart is a representation of the C type gtk_text_iter_backward_sentence_start.
func (recv *TextIter) BackwardSentenceStart() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterBackwardSentenceStartFunction_Set()
	if err == nil {
		ret = textIterBackwardSentenceStartFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardSentenceStartsFunction *gi.Function
var textIterBackwardSentenceStartsFunction_Once sync.Once

func textIterBackwardSentenceStartsFunction_Set() error {
	var err error
	textIterBackwardSentenceStartsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardSentenceStartsFunction, err = textIterStruct.InvokerNew("backward_sentence_starts")
	})
	return err
}

// BackwardSentenceStarts is a representation of the C type gtk_text_iter_backward_sentence_starts.
func (recv *TextIter) BackwardSentenceStarts(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterBackwardSentenceStartsFunction_Set()
	if err == nil {
		ret = textIterBackwardSentenceStartsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardToTagToggleFunction *gi.Function
var textIterBackwardToTagToggleFunction_Once sync.Once

func textIterBackwardToTagToggleFunction_Set() error {
	var err error
	textIterBackwardToTagToggleFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardToTagToggleFunction, err = textIterStruct.InvokerNew("backward_to_tag_toggle")
	})
	return err
}

// BackwardToTagToggle is a representation of the C type gtk_text_iter_backward_to_tag_toggle.
func (recv *TextIter) BackwardToTagToggle(tag *TextTag) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(tag.Native())

	var ret gi.Argument

	err := textIterBackwardToTagToggleFunction_Set()
	if err == nil {
		ret = textIterBackwardToTagToggleFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardVisibleCursorPositionFunction *gi.Function
var textIterBackwardVisibleCursorPositionFunction_Once sync.Once

func textIterBackwardVisibleCursorPositionFunction_Set() error {
	var err error
	textIterBackwardVisibleCursorPositionFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardVisibleCursorPositionFunction, err = textIterStruct.InvokerNew("backward_visible_cursor_position")
	})
	return err
}

// BackwardVisibleCursorPosition is a representation of the C type gtk_text_iter_backward_visible_cursor_position.
func (recv *TextIter) BackwardVisibleCursorPosition() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterBackwardVisibleCursorPositionFunction_Set()
	if err == nil {
		ret = textIterBackwardVisibleCursorPositionFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardVisibleCursorPositionsFunction *gi.Function
var textIterBackwardVisibleCursorPositionsFunction_Once sync.Once

func textIterBackwardVisibleCursorPositionsFunction_Set() error {
	var err error
	textIterBackwardVisibleCursorPositionsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardVisibleCursorPositionsFunction, err = textIterStruct.InvokerNew("backward_visible_cursor_positions")
	})
	return err
}

// BackwardVisibleCursorPositions is a representation of the C type gtk_text_iter_backward_visible_cursor_positions.
func (recv *TextIter) BackwardVisibleCursorPositions(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterBackwardVisibleCursorPositionsFunction_Set()
	if err == nil {
		ret = textIterBackwardVisibleCursorPositionsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardVisibleLineFunction *gi.Function
var textIterBackwardVisibleLineFunction_Once sync.Once

func textIterBackwardVisibleLineFunction_Set() error {
	var err error
	textIterBackwardVisibleLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardVisibleLineFunction, err = textIterStruct.InvokerNew("backward_visible_line")
	})
	return err
}

// BackwardVisibleLine is a representation of the C type gtk_text_iter_backward_visible_line.
func (recv *TextIter) BackwardVisibleLine() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterBackwardVisibleLineFunction_Set()
	if err == nil {
		ret = textIterBackwardVisibleLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardVisibleLinesFunction *gi.Function
var textIterBackwardVisibleLinesFunction_Once sync.Once

func textIterBackwardVisibleLinesFunction_Set() error {
	var err error
	textIterBackwardVisibleLinesFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardVisibleLinesFunction, err = textIterStruct.InvokerNew("backward_visible_lines")
	})
	return err
}

// BackwardVisibleLines is a representation of the C type gtk_text_iter_backward_visible_lines.
func (recv *TextIter) BackwardVisibleLines(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterBackwardVisibleLinesFunction_Set()
	if err == nil {
		ret = textIterBackwardVisibleLinesFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardVisibleWordStartFunction *gi.Function
var textIterBackwardVisibleWordStartFunction_Once sync.Once

func textIterBackwardVisibleWordStartFunction_Set() error {
	var err error
	textIterBackwardVisibleWordStartFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardVisibleWordStartFunction, err = textIterStruct.InvokerNew("backward_visible_word_start")
	})
	return err
}

// BackwardVisibleWordStart is a representation of the C type gtk_text_iter_backward_visible_word_start.
func (recv *TextIter) BackwardVisibleWordStart() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterBackwardVisibleWordStartFunction_Set()
	if err == nil {
		ret = textIterBackwardVisibleWordStartFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardVisibleWordStartsFunction *gi.Function
var textIterBackwardVisibleWordStartsFunction_Once sync.Once

func textIterBackwardVisibleWordStartsFunction_Set() error {
	var err error
	textIterBackwardVisibleWordStartsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardVisibleWordStartsFunction, err = textIterStruct.InvokerNew("backward_visible_word_starts")
	})
	return err
}

// BackwardVisibleWordStarts is a representation of the C type gtk_text_iter_backward_visible_word_starts.
func (recv *TextIter) BackwardVisibleWordStarts(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterBackwardVisibleWordStartsFunction_Set()
	if err == nil {
		ret = textIterBackwardVisibleWordStartsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardWordStartFunction *gi.Function
var textIterBackwardWordStartFunction_Once sync.Once

func textIterBackwardWordStartFunction_Set() error {
	var err error
	textIterBackwardWordStartFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardWordStartFunction, err = textIterStruct.InvokerNew("backward_word_start")
	})
	return err
}

// BackwardWordStart is a representation of the C type gtk_text_iter_backward_word_start.
func (recv *TextIter) BackwardWordStart() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterBackwardWordStartFunction_Set()
	if err == nil {
		ret = textIterBackwardWordStartFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBackwardWordStartsFunction *gi.Function
var textIterBackwardWordStartsFunction_Once sync.Once

func textIterBackwardWordStartsFunction_Set() error {
	var err error
	textIterBackwardWordStartsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBackwardWordStartsFunction, err = textIterStruct.InvokerNew("backward_word_starts")
	})
	return err
}

// BackwardWordStarts is a representation of the C type gtk_text_iter_backward_word_starts.
func (recv *TextIter) BackwardWordStarts(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterBackwardWordStartsFunction_Set()
	if err == nil {
		ret = textIterBackwardWordStartsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterBeginsTagFunction *gi.Function
var textIterBeginsTagFunction_Once sync.Once

func textIterBeginsTagFunction_Set() error {
	var err error
	textIterBeginsTagFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterBeginsTagFunction, err = textIterStruct.InvokerNew("begins_tag")
	})
	return err
}

// BeginsTag is a representation of the C type gtk_text_iter_begins_tag.
func (recv *TextIter) BeginsTag(tag *TextTag) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(tag.Native())

	var ret gi.Argument

	err := textIterBeginsTagFunction_Set()
	if err == nil {
		ret = textIterBeginsTagFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterCanInsertFunction *gi.Function
var textIterCanInsertFunction_Once sync.Once

func textIterCanInsertFunction_Set() error {
	var err error
	textIterCanInsertFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterCanInsertFunction, err = textIterStruct.InvokerNew("can_insert")
	})
	return err
}

// CanInsert is a representation of the C type gtk_text_iter_can_insert.
func (recv *TextIter) CanInsert(defaultEditability bool) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetBoolean(defaultEditability)

	var ret gi.Argument

	err := textIterCanInsertFunction_Set()
	if err == nil {
		ret = textIterCanInsertFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterCompareFunction *gi.Function
var textIterCompareFunction_Once sync.Once

func textIterCompareFunction_Set() error {
	var err error
	textIterCompareFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterCompareFunction, err = textIterStruct.InvokerNew("compare")
	})
	return err
}

// Compare is a representation of the C type gtk_text_iter_compare.
func (recv *TextIter) Compare(rhs *TextIter) int32 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(rhs.Native())

	var ret gi.Argument

	err := textIterCompareFunction_Set()
	if err == nil {
		ret = textIterCompareFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var textIterCopyFunction *gi.Function
var textIterCopyFunction_Once sync.Once

func textIterCopyFunction_Set() error {
	var err error
	textIterCopyFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterCopyFunction, err = textIterStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_text_iter_copy.
func (recv *TextIter) Copy() *TextIter {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterCopyFunction_Set()
	if err == nil {
		ret = textIterCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := TextIterNewFromNative(ret.Pointer())

	return retGo
}

var textIterEditableFunction *gi.Function
var textIterEditableFunction_Once sync.Once

func textIterEditableFunction_Set() error {
	var err error
	textIterEditableFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterEditableFunction, err = textIterStruct.InvokerNew("editable")
	})
	return err
}

// Editable is a representation of the C type gtk_text_iter_editable.
func (recv *TextIter) Editable(defaultSetting bool) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetBoolean(defaultSetting)

	var ret gi.Argument

	err := textIterEditableFunction_Set()
	if err == nil {
		ret = textIterEditableFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterEndsLineFunction *gi.Function
var textIterEndsLineFunction_Once sync.Once

func textIterEndsLineFunction_Set() error {
	var err error
	textIterEndsLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterEndsLineFunction, err = textIterStruct.InvokerNew("ends_line")
	})
	return err
}

// EndsLine is a representation of the C type gtk_text_iter_ends_line.
func (recv *TextIter) EndsLine() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterEndsLineFunction_Set()
	if err == nil {
		ret = textIterEndsLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterEndsSentenceFunction *gi.Function
var textIterEndsSentenceFunction_Once sync.Once

func textIterEndsSentenceFunction_Set() error {
	var err error
	textIterEndsSentenceFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterEndsSentenceFunction, err = textIterStruct.InvokerNew("ends_sentence")
	})
	return err
}

// EndsSentence is a representation of the C type gtk_text_iter_ends_sentence.
func (recv *TextIter) EndsSentence() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterEndsSentenceFunction_Set()
	if err == nil {
		ret = textIterEndsSentenceFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterEndsTagFunction *gi.Function
var textIterEndsTagFunction_Once sync.Once

func textIterEndsTagFunction_Set() error {
	var err error
	textIterEndsTagFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterEndsTagFunction, err = textIterStruct.InvokerNew("ends_tag")
	})
	return err
}

// EndsTag is a representation of the C type gtk_text_iter_ends_tag.
func (recv *TextIter) EndsTag(tag *TextTag) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(tag.Native())

	var ret gi.Argument

	err := textIterEndsTagFunction_Set()
	if err == nil {
		ret = textIterEndsTagFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterEndsWordFunction *gi.Function
var textIterEndsWordFunction_Once sync.Once

func textIterEndsWordFunction_Set() error {
	var err error
	textIterEndsWordFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterEndsWordFunction, err = textIterStruct.InvokerNew("ends_word")
	})
	return err
}

// EndsWord is a representation of the C type gtk_text_iter_ends_word.
func (recv *TextIter) EndsWord() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterEndsWordFunction_Set()
	if err == nil {
		ret = textIterEndsWordFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterEqualFunction *gi.Function
var textIterEqualFunction_Once sync.Once

func textIterEqualFunction_Set() error {
	var err error
	textIterEqualFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterEqualFunction, err = textIterStruct.InvokerNew("equal")
	})
	return err
}

// Equal is a representation of the C type gtk_text_iter_equal.
func (recv *TextIter) Equal(rhs *TextIter) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(rhs.Native())

	var ret gi.Argument

	err := textIterEqualFunction_Set()
	if err == nil {
		ret = textIterEqualFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardCharFunction *gi.Function
var textIterForwardCharFunction_Once sync.Once

func textIterForwardCharFunction_Set() error {
	var err error
	textIterForwardCharFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardCharFunction, err = textIterStruct.InvokerNew("forward_char")
	})
	return err
}

// ForwardChar is a representation of the C type gtk_text_iter_forward_char.
func (recv *TextIter) ForwardChar() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardCharFunction_Set()
	if err == nil {
		ret = textIterForwardCharFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardCharsFunction *gi.Function
var textIterForwardCharsFunction_Once sync.Once

func textIterForwardCharsFunction_Set() error {
	var err error
	textIterForwardCharsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardCharsFunction, err = textIterStruct.InvokerNew("forward_chars")
	})
	return err
}

// ForwardChars is a representation of the C type gtk_text_iter_forward_chars.
func (recv *TextIter) ForwardChars(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterForwardCharsFunction_Set()
	if err == nil {
		ret = textIterForwardCharsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardCursorPositionFunction *gi.Function
var textIterForwardCursorPositionFunction_Once sync.Once

func textIterForwardCursorPositionFunction_Set() error {
	var err error
	textIterForwardCursorPositionFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardCursorPositionFunction, err = textIterStruct.InvokerNew("forward_cursor_position")
	})
	return err
}

// ForwardCursorPosition is a representation of the C type gtk_text_iter_forward_cursor_position.
func (recv *TextIter) ForwardCursorPosition() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardCursorPositionFunction_Set()
	if err == nil {
		ret = textIterForwardCursorPositionFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardCursorPositionsFunction *gi.Function
var textIterForwardCursorPositionsFunction_Once sync.Once

func textIterForwardCursorPositionsFunction_Set() error {
	var err error
	textIterForwardCursorPositionsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardCursorPositionsFunction, err = textIterStruct.InvokerNew("forward_cursor_positions")
	})
	return err
}

// ForwardCursorPositions is a representation of the C type gtk_text_iter_forward_cursor_positions.
func (recv *TextIter) ForwardCursorPositions(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterForwardCursorPositionsFunction_Set()
	if err == nil {
		ret = textIterForwardCursorPositionsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

// UNSUPPORTED : C value 'gtk_text_iter_forward_find_char' : parameter 'pred' of type 'TextCharPredicate' not supported

var textIterForwardLineFunction *gi.Function
var textIterForwardLineFunction_Once sync.Once

func textIterForwardLineFunction_Set() error {
	var err error
	textIterForwardLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardLineFunction, err = textIterStruct.InvokerNew("forward_line")
	})
	return err
}

// ForwardLine is a representation of the C type gtk_text_iter_forward_line.
func (recv *TextIter) ForwardLine() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardLineFunction_Set()
	if err == nil {
		ret = textIterForwardLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardLinesFunction *gi.Function
var textIterForwardLinesFunction_Once sync.Once

func textIterForwardLinesFunction_Set() error {
	var err error
	textIterForwardLinesFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardLinesFunction, err = textIterStruct.InvokerNew("forward_lines")
	})
	return err
}

// ForwardLines is a representation of the C type gtk_text_iter_forward_lines.
func (recv *TextIter) ForwardLines(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterForwardLinesFunction_Set()
	if err == nil {
		ret = textIterForwardLinesFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardSearchFunction *gi.Function
var textIterForwardSearchFunction_Once sync.Once

func textIterForwardSearchFunction_Set() error {
	var err error
	textIterForwardSearchFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardSearchFunction, err = textIterStruct.InvokerNew("forward_search")
	})
	return err
}

// ForwardSearch is a representation of the C type gtk_text_iter_forward_search.
func (recv *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (bool, *TextIter, *TextIter) {
	var inArgs [4]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(str)
	inArgs[2].SetInt32(int32(flags))
	inArgs[3].SetPointer(limit.Native())

	var outArgs [2]gi.Argument
	var ret gi.Argument

	err := textIterForwardSearchFunction_Set()
	if err == nil {
		ret = textIterForwardSearchFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := TextIterNewFromNative(outArgs[0].Pointer())
	out1 := TextIterNewFromNative(outArgs[1].Pointer())

	return retGo, out0, out1
}

var textIterForwardSentenceEndFunction *gi.Function
var textIterForwardSentenceEndFunction_Once sync.Once

func textIterForwardSentenceEndFunction_Set() error {
	var err error
	textIterForwardSentenceEndFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardSentenceEndFunction, err = textIterStruct.InvokerNew("forward_sentence_end")
	})
	return err
}

// ForwardSentenceEnd is a representation of the C type gtk_text_iter_forward_sentence_end.
func (recv *TextIter) ForwardSentenceEnd() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardSentenceEndFunction_Set()
	if err == nil {
		ret = textIterForwardSentenceEndFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardSentenceEndsFunction *gi.Function
var textIterForwardSentenceEndsFunction_Once sync.Once

func textIterForwardSentenceEndsFunction_Set() error {
	var err error
	textIterForwardSentenceEndsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardSentenceEndsFunction, err = textIterStruct.InvokerNew("forward_sentence_ends")
	})
	return err
}

// ForwardSentenceEnds is a representation of the C type gtk_text_iter_forward_sentence_ends.
func (recv *TextIter) ForwardSentenceEnds(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterForwardSentenceEndsFunction_Set()
	if err == nil {
		ret = textIterForwardSentenceEndsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardToEndFunction *gi.Function
var textIterForwardToEndFunction_Once sync.Once

func textIterForwardToEndFunction_Set() error {
	var err error
	textIterForwardToEndFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardToEndFunction, err = textIterStruct.InvokerNew("forward_to_end")
	})
	return err
}

// ForwardToEnd is a representation of the C type gtk_text_iter_forward_to_end.
func (recv *TextIter) ForwardToEnd() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := textIterForwardToEndFunction_Set()
	if err == nil {
		textIterForwardToEndFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterForwardToLineEndFunction *gi.Function
var textIterForwardToLineEndFunction_Once sync.Once

func textIterForwardToLineEndFunction_Set() error {
	var err error
	textIterForwardToLineEndFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardToLineEndFunction, err = textIterStruct.InvokerNew("forward_to_line_end")
	})
	return err
}

// ForwardToLineEnd is a representation of the C type gtk_text_iter_forward_to_line_end.
func (recv *TextIter) ForwardToLineEnd() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardToLineEndFunction_Set()
	if err == nil {
		ret = textIterForwardToLineEndFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardToTagToggleFunction *gi.Function
var textIterForwardToTagToggleFunction_Once sync.Once

func textIterForwardToTagToggleFunction_Set() error {
	var err error
	textIterForwardToTagToggleFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardToTagToggleFunction, err = textIterStruct.InvokerNew("forward_to_tag_toggle")
	})
	return err
}

// ForwardToTagToggle is a representation of the C type gtk_text_iter_forward_to_tag_toggle.
func (recv *TextIter) ForwardToTagToggle(tag *TextTag) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(tag.Native())

	var ret gi.Argument

	err := textIterForwardToTagToggleFunction_Set()
	if err == nil {
		ret = textIterForwardToTagToggleFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardVisibleCursorPositionFunction *gi.Function
var textIterForwardVisibleCursorPositionFunction_Once sync.Once

func textIterForwardVisibleCursorPositionFunction_Set() error {
	var err error
	textIterForwardVisibleCursorPositionFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardVisibleCursorPositionFunction, err = textIterStruct.InvokerNew("forward_visible_cursor_position")
	})
	return err
}

// ForwardVisibleCursorPosition is a representation of the C type gtk_text_iter_forward_visible_cursor_position.
func (recv *TextIter) ForwardVisibleCursorPosition() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardVisibleCursorPositionFunction_Set()
	if err == nil {
		ret = textIterForwardVisibleCursorPositionFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardVisibleCursorPositionsFunction *gi.Function
var textIterForwardVisibleCursorPositionsFunction_Once sync.Once

func textIterForwardVisibleCursorPositionsFunction_Set() error {
	var err error
	textIterForwardVisibleCursorPositionsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardVisibleCursorPositionsFunction, err = textIterStruct.InvokerNew("forward_visible_cursor_positions")
	})
	return err
}

// ForwardVisibleCursorPositions is a representation of the C type gtk_text_iter_forward_visible_cursor_positions.
func (recv *TextIter) ForwardVisibleCursorPositions(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterForwardVisibleCursorPositionsFunction_Set()
	if err == nil {
		ret = textIterForwardVisibleCursorPositionsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardVisibleLineFunction *gi.Function
var textIterForwardVisibleLineFunction_Once sync.Once

func textIterForwardVisibleLineFunction_Set() error {
	var err error
	textIterForwardVisibleLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardVisibleLineFunction, err = textIterStruct.InvokerNew("forward_visible_line")
	})
	return err
}

// ForwardVisibleLine is a representation of the C type gtk_text_iter_forward_visible_line.
func (recv *TextIter) ForwardVisibleLine() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardVisibleLineFunction_Set()
	if err == nil {
		ret = textIterForwardVisibleLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardVisibleLinesFunction *gi.Function
var textIterForwardVisibleLinesFunction_Once sync.Once

func textIterForwardVisibleLinesFunction_Set() error {
	var err error
	textIterForwardVisibleLinesFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardVisibleLinesFunction, err = textIterStruct.InvokerNew("forward_visible_lines")
	})
	return err
}

// ForwardVisibleLines is a representation of the C type gtk_text_iter_forward_visible_lines.
func (recv *TextIter) ForwardVisibleLines(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterForwardVisibleLinesFunction_Set()
	if err == nil {
		ret = textIterForwardVisibleLinesFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardVisibleWordEndFunction *gi.Function
var textIterForwardVisibleWordEndFunction_Once sync.Once

func textIterForwardVisibleWordEndFunction_Set() error {
	var err error
	textIterForwardVisibleWordEndFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardVisibleWordEndFunction, err = textIterStruct.InvokerNew("forward_visible_word_end")
	})
	return err
}

// ForwardVisibleWordEnd is a representation of the C type gtk_text_iter_forward_visible_word_end.
func (recv *TextIter) ForwardVisibleWordEnd() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardVisibleWordEndFunction_Set()
	if err == nil {
		ret = textIterForwardVisibleWordEndFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardVisibleWordEndsFunction *gi.Function
var textIterForwardVisibleWordEndsFunction_Once sync.Once

func textIterForwardVisibleWordEndsFunction_Set() error {
	var err error
	textIterForwardVisibleWordEndsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardVisibleWordEndsFunction, err = textIterStruct.InvokerNew("forward_visible_word_ends")
	})
	return err
}

// ForwardVisibleWordEnds is a representation of the C type gtk_text_iter_forward_visible_word_ends.
func (recv *TextIter) ForwardVisibleWordEnds(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterForwardVisibleWordEndsFunction_Set()
	if err == nil {
		ret = textIterForwardVisibleWordEndsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardWordEndFunction *gi.Function
var textIterForwardWordEndFunction_Once sync.Once

func textIterForwardWordEndFunction_Set() error {
	var err error
	textIterForwardWordEndFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardWordEndFunction, err = textIterStruct.InvokerNew("forward_word_end")
	})
	return err
}

// ForwardWordEnd is a representation of the C type gtk_text_iter_forward_word_end.
func (recv *TextIter) ForwardWordEnd() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterForwardWordEndFunction_Set()
	if err == nil {
		ret = textIterForwardWordEndFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterForwardWordEndsFunction *gi.Function
var textIterForwardWordEndsFunction_Once sync.Once

func textIterForwardWordEndsFunction_Set() error {
	var err error
	textIterForwardWordEndsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterForwardWordEndsFunction, err = textIterStruct.InvokerNew("forward_word_ends")
	})
	return err
}

// ForwardWordEnds is a representation of the C type gtk_text_iter_forward_word_ends.
func (recv *TextIter) ForwardWordEnds(count int32) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(count)

	var ret gi.Argument

	err := textIterForwardWordEndsFunction_Set()
	if err == nil {
		ret = textIterForwardWordEndsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterFreeFunction *gi.Function
var textIterFreeFunction_Once sync.Once

func textIterFreeFunction_Set() error {
	var err error
	textIterFreeFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterFreeFunction, err = textIterStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_text_iter_free.
func (recv *TextIter) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := textIterFreeFunction_Set()
	if err == nil {
		textIterFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterGetAttributesFunction *gi.Function
var textIterGetAttributesFunction_Once sync.Once

func textIterGetAttributesFunction_Set() error {
	var err error
	textIterGetAttributesFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetAttributesFunction, err = textIterStruct.InvokerNew("get_attributes")
	})
	return err
}

// GetAttributes is a representation of the C type gtk_text_iter_get_attributes.
func (recv *TextIter) GetAttributes() (bool, *TextAttributes) {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var outArgs [1]gi.Argument
	var ret gi.Argument

	err := textIterGetAttributesFunction_Set()
	if err == nil {
		ret = textIterGetAttributesFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := TextAttributesNewFromNative(outArgs[0].Pointer())

	return retGo, out0
}

var textIterGetBufferFunction *gi.Function
var textIterGetBufferFunction_Once sync.Once

func textIterGetBufferFunction_Set() error {
	var err error
	textIterGetBufferFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetBufferFunction, err = textIterStruct.InvokerNew("get_buffer")
	})
	return err
}

// GetBuffer is a representation of the C type gtk_text_iter_get_buffer.
func (recv *TextIter) GetBuffer() *TextBuffer {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetBufferFunction_Set()
	if err == nil {
		ret = textIterGetBufferFunction.Invoke(inArgs[:], nil)
	}

	retGo := TextBufferNewFromNative(ret.Pointer())

	return retGo
}

var textIterGetBytesInLineFunction *gi.Function
var textIterGetBytesInLineFunction_Once sync.Once

func textIterGetBytesInLineFunction_Set() error {
	var err error
	textIterGetBytesInLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetBytesInLineFunction, err = textIterStruct.InvokerNew("get_bytes_in_line")
	})
	return err
}

// GetBytesInLine is a representation of the C type gtk_text_iter_get_bytes_in_line.
func (recv *TextIter) GetBytesInLine() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetBytesInLineFunction_Set()
	if err == nil {
		ret = textIterGetBytesInLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

// UNSUPPORTED : C value 'gtk_text_iter_get_char' : return type 'gunichar' not supported

var textIterGetCharsInLineFunction *gi.Function
var textIterGetCharsInLineFunction_Once sync.Once

func textIterGetCharsInLineFunction_Set() error {
	var err error
	textIterGetCharsInLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetCharsInLineFunction, err = textIterStruct.InvokerNew("get_chars_in_line")
	})
	return err
}

// GetCharsInLine is a representation of the C type gtk_text_iter_get_chars_in_line.
func (recv *TextIter) GetCharsInLine() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetCharsInLineFunction_Set()
	if err == nil {
		ret = textIterGetCharsInLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var textIterGetChildAnchorFunction *gi.Function
var textIterGetChildAnchorFunction_Once sync.Once

func textIterGetChildAnchorFunction_Set() error {
	var err error
	textIterGetChildAnchorFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetChildAnchorFunction, err = textIterStruct.InvokerNew("get_child_anchor")
	})
	return err
}

// GetChildAnchor is a representation of the C type gtk_text_iter_get_child_anchor.
func (recv *TextIter) GetChildAnchor() *TextChildAnchor {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetChildAnchorFunction_Set()
	if err == nil {
		ret = textIterGetChildAnchorFunction.Invoke(inArgs[:], nil)
	}

	retGo := TextChildAnchorNewFromNative(ret.Pointer())

	return retGo
}

var textIterGetLanguageFunction *gi.Function
var textIterGetLanguageFunction_Once sync.Once

func textIterGetLanguageFunction_Set() error {
	var err error
	textIterGetLanguageFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetLanguageFunction, err = textIterStruct.InvokerNew("get_language")
	})
	return err
}

// GetLanguage is a representation of the C type gtk_text_iter_get_language.
func (recv *TextIter) GetLanguage() *pango.Language {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetLanguageFunction_Set()
	if err == nil {
		ret = textIterGetLanguageFunction.Invoke(inArgs[:], nil)
	}

	retGo := pango.LanguageNewFromNative(ret.Pointer())

	return retGo
}

var textIterGetLineFunction *gi.Function
var textIterGetLineFunction_Once sync.Once

func textIterGetLineFunction_Set() error {
	var err error
	textIterGetLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetLineFunction, err = textIterStruct.InvokerNew("get_line")
	})
	return err
}

// GetLine is a representation of the C type gtk_text_iter_get_line.
func (recv *TextIter) GetLine() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetLineFunction_Set()
	if err == nil {
		ret = textIterGetLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var textIterGetLineIndexFunction *gi.Function
var textIterGetLineIndexFunction_Once sync.Once

func textIterGetLineIndexFunction_Set() error {
	var err error
	textIterGetLineIndexFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetLineIndexFunction, err = textIterStruct.InvokerNew("get_line_index")
	})
	return err
}

// GetLineIndex is a representation of the C type gtk_text_iter_get_line_index.
func (recv *TextIter) GetLineIndex() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetLineIndexFunction_Set()
	if err == nil {
		ret = textIterGetLineIndexFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var textIterGetLineOffsetFunction *gi.Function
var textIterGetLineOffsetFunction_Once sync.Once

func textIterGetLineOffsetFunction_Set() error {
	var err error
	textIterGetLineOffsetFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetLineOffsetFunction, err = textIterStruct.InvokerNew("get_line_offset")
	})
	return err
}

// GetLineOffset is a representation of the C type gtk_text_iter_get_line_offset.
func (recv *TextIter) GetLineOffset() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetLineOffsetFunction_Set()
	if err == nil {
		ret = textIterGetLineOffsetFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var textIterGetMarksFunction *gi.Function
var textIterGetMarksFunction_Once sync.Once

func textIterGetMarksFunction_Set() error {
	var err error
	textIterGetMarksFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetMarksFunction, err = textIterStruct.InvokerNew("get_marks")
	})
	return err
}

// GetMarks is a representation of the C type gtk_text_iter_get_marks.
func (recv *TextIter) GetMarks() *glib.SList {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetMarksFunction_Set()
	if err == nil {
		ret = textIterGetMarksFunction.Invoke(inArgs[:], nil)
	}

	retGo := glib.SListNewFromNative(ret.Pointer())

	return retGo
}

var textIterGetOffsetFunction *gi.Function
var textIterGetOffsetFunction_Once sync.Once

func textIterGetOffsetFunction_Set() error {
	var err error
	textIterGetOffsetFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetOffsetFunction, err = textIterStruct.InvokerNew("get_offset")
	})
	return err
}

// GetOffset is a representation of the C type gtk_text_iter_get_offset.
func (recv *TextIter) GetOffset() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetOffsetFunction_Set()
	if err == nil {
		ret = textIterGetOffsetFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var textIterGetPixbufFunction *gi.Function
var textIterGetPixbufFunction_Once sync.Once

func textIterGetPixbufFunction_Set() error {
	var err error
	textIterGetPixbufFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetPixbufFunction, err = textIterStruct.InvokerNew("get_pixbuf")
	})
	return err
}

// GetPixbuf is a representation of the C type gtk_text_iter_get_pixbuf.
func (recv *TextIter) GetPixbuf() *gdkpixbuf.Pixbuf {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetPixbufFunction_Set()
	if err == nil {
		ret = textIterGetPixbufFunction.Invoke(inArgs[:], nil)
	}

	retGo := gdkpixbuf.PixbufNewFromNative(ret.Pointer())

	return retGo
}

var textIterGetSliceFunction *gi.Function
var textIterGetSliceFunction_Once sync.Once

func textIterGetSliceFunction_Set() error {
	var err error
	textIterGetSliceFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetSliceFunction, err = textIterStruct.InvokerNew("get_slice")
	})
	return err
}

// GetSlice is a representation of the C type gtk_text_iter_get_slice.
func (recv *TextIter) GetSlice(end *TextIter) string {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(end.Native())

	var ret gi.Argument

	err := textIterGetSliceFunction_Set()
	if err == nil {
		ret = textIterGetSliceFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var textIterGetTagsFunction *gi.Function
var textIterGetTagsFunction_Once sync.Once

func textIterGetTagsFunction_Set() error {
	var err error
	textIterGetTagsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetTagsFunction, err = textIterStruct.InvokerNew("get_tags")
	})
	return err
}

// GetTags is a representation of the C type gtk_text_iter_get_tags.
func (recv *TextIter) GetTags() *glib.SList {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetTagsFunction_Set()
	if err == nil {
		ret = textIterGetTagsFunction.Invoke(inArgs[:], nil)
	}

	retGo := glib.SListNewFromNative(ret.Pointer())

	return retGo
}

var textIterGetTextFunction *gi.Function
var textIterGetTextFunction_Once sync.Once

func textIterGetTextFunction_Set() error {
	var err error
	textIterGetTextFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetTextFunction, err = textIterStruct.InvokerNew("get_text")
	})
	return err
}

// GetText is a representation of the C type gtk_text_iter_get_text.
func (recv *TextIter) GetText(end *TextIter) string {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(end.Native())

	var ret gi.Argument

	err := textIterGetTextFunction_Set()
	if err == nil {
		ret = textIterGetTextFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var textIterGetToggledTagsFunction *gi.Function
var textIterGetToggledTagsFunction_Once sync.Once

func textIterGetToggledTagsFunction_Set() error {
	var err error
	textIterGetToggledTagsFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetToggledTagsFunction, err = textIterStruct.InvokerNew("get_toggled_tags")
	})
	return err
}

// GetToggledTags is a representation of the C type gtk_text_iter_get_toggled_tags.
func (recv *TextIter) GetToggledTags(toggledOn bool) *glib.SList {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetBoolean(toggledOn)

	var ret gi.Argument

	err := textIterGetToggledTagsFunction_Set()
	if err == nil {
		ret = textIterGetToggledTagsFunction.Invoke(inArgs[:], nil)
	}

	retGo := glib.SListNewFromNative(ret.Pointer())

	return retGo
}

var textIterGetVisibleLineIndexFunction *gi.Function
var textIterGetVisibleLineIndexFunction_Once sync.Once

func textIterGetVisibleLineIndexFunction_Set() error {
	var err error
	textIterGetVisibleLineIndexFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetVisibleLineIndexFunction, err = textIterStruct.InvokerNew("get_visible_line_index")
	})
	return err
}

// GetVisibleLineIndex is a representation of the C type gtk_text_iter_get_visible_line_index.
func (recv *TextIter) GetVisibleLineIndex() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetVisibleLineIndexFunction_Set()
	if err == nil {
		ret = textIterGetVisibleLineIndexFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var textIterGetVisibleLineOffsetFunction *gi.Function
var textIterGetVisibleLineOffsetFunction_Once sync.Once

func textIterGetVisibleLineOffsetFunction_Set() error {
	var err error
	textIterGetVisibleLineOffsetFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetVisibleLineOffsetFunction, err = textIterStruct.InvokerNew("get_visible_line_offset")
	})
	return err
}

// GetVisibleLineOffset is a representation of the C type gtk_text_iter_get_visible_line_offset.
func (recv *TextIter) GetVisibleLineOffset() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterGetVisibleLineOffsetFunction_Set()
	if err == nil {
		ret = textIterGetVisibleLineOffsetFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var textIterGetVisibleSliceFunction *gi.Function
var textIterGetVisibleSliceFunction_Once sync.Once

func textIterGetVisibleSliceFunction_Set() error {
	var err error
	textIterGetVisibleSliceFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetVisibleSliceFunction, err = textIterStruct.InvokerNew("get_visible_slice")
	})
	return err
}

// GetVisibleSlice is a representation of the C type gtk_text_iter_get_visible_slice.
func (recv *TextIter) GetVisibleSlice(end *TextIter) string {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(end.Native())

	var ret gi.Argument

	err := textIterGetVisibleSliceFunction_Set()
	if err == nil {
		ret = textIterGetVisibleSliceFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var textIterGetVisibleTextFunction *gi.Function
var textIterGetVisibleTextFunction_Once sync.Once

func textIterGetVisibleTextFunction_Set() error {
	var err error
	textIterGetVisibleTextFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterGetVisibleTextFunction, err = textIterStruct.InvokerNew("get_visible_text")
	})
	return err
}

// GetVisibleText is a representation of the C type gtk_text_iter_get_visible_text.
func (recv *TextIter) GetVisibleText(end *TextIter) string {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(end.Native())

	var ret gi.Argument

	err := textIterGetVisibleTextFunction_Set()
	if err == nil {
		ret = textIterGetVisibleTextFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var textIterHasTagFunction *gi.Function
var textIterHasTagFunction_Once sync.Once

func textIterHasTagFunction_Set() error {
	var err error
	textIterHasTagFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterHasTagFunction, err = textIterStruct.InvokerNew("has_tag")
	})
	return err
}

// HasTag is a representation of the C type gtk_text_iter_has_tag.
func (recv *TextIter) HasTag(tag *TextTag) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(tag.Native())

	var ret gi.Argument

	err := textIterHasTagFunction_Set()
	if err == nil {
		ret = textIterHasTagFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterInRangeFunction *gi.Function
var textIterInRangeFunction_Once sync.Once

func textIterInRangeFunction_Set() error {
	var err error
	textIterInRangeFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterInRangeFunction, err = textIterStruct.InvokerNew("in_range")
	})
	return err
}

// InRange is a representation of the C type gtk_text_iter_in_range.
func (recv *TextIter) InRange(start *TextIter, end *TextIter) bool {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(start.Native())
	inArgs[2].SetPointer(end.Native())

	var ret gi.Argument

	err := textIterInRangeFunction_Set()
	if err == nil {
		ret = textIterInRangeFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterInsideSentenceFunction *gi.Function
var textIterInsideSentenceFunction_Once sync.Once

func textIterInsideSentenceFunction_Set() error {
	var err error
	textIterInsideSentenceFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterInsideSentenceFunction, err = textIterStruct.InvokerNew("inside_sentence")
	})
	return err
}

// InsideSentence is a representation of the C type gtk_text_iter_inside_sentence.
func (recv *TextIter) InsideSentence() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterInsideSentenceFunction_Set()
	if err == nil {
		ret = textIterInsideSentenceFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterInsideWordFunction *gi.Function
var textIterInsideWordFunction_Once sync.Once

func textIterInsideWordFunction_Set() error {
	var err error
	textIterInsideWordFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterInsideWordFunction, err = textIterStruct.InvokerNew("inside_word")
	})
	return err
}

// InsideWord is a representation of the C type gtk_text_iter_inside_word.
func (recv *TextIter) InsideWord() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterInsideWordFunction_Set()
	if err == nil {
		ret = textIterInsideWordFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterIsCursorPositionFunction *gi.Function
var textIterIsCursorPositionFunction_Once sync.Once

func textIterIsCursorPositionFunction_Set() error {
	var err error
	textIterIsCursorPositionFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterIsCursorPositionFunction, err = textIterStruct.InvokerNew("is_cursor_position")
	})
	return err
}

// IsCursorPosition is a representation of the C type gtk_text_iter_is_cursor_position.
func (recv *TextIter) IsCursorPosition() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterIsCursorPositionFunction_Set()
	if err == nil {
		ret = textIterIsCursorPositionFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterIsEndFunction *gi.Function
var textIterIsEndFunction_Once sync.Once

func textIterIsEndFunction_Set() error {
	var err error
	textIterIsEndFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterIsEndFunction, err = textIterStruct.InvokerNew("is_end")
	})
	return err
}

// IsEnd is a representation of the C type gtk_text_iter_is_end.
func (recv *TextIter) IsEnd() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterIsEndFunction_Set()
	if err == nil {
		ret = textIterIsEndFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterIsStartFunction *gi.Function
var textIterIsStartFunction_Once sync.Once

func textIterIsStartFunction_Set() error {
	var err error
	textIterIsStartFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterIsStartFunction, err = textIterStruct.InvokerNew("is_start")
	})
	return err
}

// IsStart is a representation of the C type gtk_text_iter_is_start.
func (recv *TextIter) IsStart() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterIsStartFunction_Set()
	if err == nil {
		ret = textIterIsStartFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterOrderFunction *gi.Function
var textIterOrderFunction_Once sync.Once

func textIterOrderFunction_Set() error {
	var err error
	textIterOrderFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterOrderFunction, err = textIterStruct.InvokerNew("order")
	})
	return err
}

// Order is a representation of the C type gtk_text_iter_order.
func (recv *TextIter) Order(second *TextIter) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(second.Native())

	err := textIterOrderFunction_Set()
	if err == nil {
		textIterOrderFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterSetLineFunction *gi.Function
var textIterSetLineFunction_Once sync.Once

func textIterSetLineFunction_Set() error {
	var err error
	textIterSetLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterSetLineFunction, err = textIterStruct.InvokerNew("set_line")
	})
	return err
}

// SetLine is a representation of the C type gtk_text_iter_set_line.
func (recv *TextIter) SetLine(lineNumber int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(lineNumber)

	err := textIterSetLineFunction_Set()
	if err == nil {
		textIterSetLineFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterSetLineIndexFunction *gi.Function
var textIterSetLineIndexFunction_Once sync.Once

func textIterSetLineIndexFunction_Set() error {
	var err error
	textIterSetLineIndexFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterSetLineIndexFunction, err = textIterStruct.InvokerNew("set_line_index")
	})
	return err
}

// SetLineIndex is a representation of the C type gtk_text_iter_set_line_index.
func (recv *TextIter) SetLineIndex(byteOnLine int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(byteOnLine)

	err := textIterSetLineIndexFunction_Set()
	if err == nil {
		textIterSetLineIndexFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterSetLineOffsetFunction *gi.Function
var textIterSetLineOffsetFunction_Once sync.Once

func textIterSetLineOffsetFunction_Set() error {
	var err error
	textIterSetLineOffsetFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterSetLineOffsetFunction, err = textIterStruct.InvokerNew("set_line_offset")
	})
	return err
}

// SetLineOffset is a representation of the C type gtk_text_iter_set_line_offset.
func (recv *TextIter) SetLineOffset(charOnLine int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(charOnLine)

	err := textIterSetLineOffsetFunction_Set()
	if err == nil {
		textIterSetLineOffsetFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterSetOffsetFunction *gi.Function
var textIterSetOffsetFunction_Once sync.Once

func textIterSetOffsetFunction_Set() error {
	var err error
	textIterSetOffsetFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterSetOffsetFunction, err = textIterStruct.InvokerNew("set_offset")
	})
	return err
}

// SetOffset is a representation of the C type gtk_text_iter_set_offset.
func (recv *TextIter) SetOffset(charOffset int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(charOffset)

	err := textIterSetOffsetFunction_Set()
	if err == nil {
		textIterSetOffsetFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterSetVisibleLineIndexFunction *gi.Function
var textIterSetVisibleLineIndexFunction_Once sync.Once

func textIterSetVisibleLineIndexFunction_Set() error {
	var err error
	textIterSetVisibleLineIndexFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterSetVisibleLineIndexFunction, err = textIterStruct.InvokerNew("set_visible_line_index")
	})
	return err
}

// SetVisibleLineIndex is a representation of the C type gtk_text_iter_set_visible_line_index.
func (recv *TextIter) SetVisibleLineIndex(byteOnLine int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(byteOnLine)

	err := textIterSetVisibleLineIndexFunction_Set()
	if err == nil {
		textIterSetVisibleLineIndexFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterSetVisibleLineOffsetFunction *gi.Function
var textIterSetVisibleLineOffsetFunction_Once sync.Once

func textIterSetVisibleLineOffsetFunction_Set() error {
	var err error
	textIterSetVisibleLineOffsetFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterSetVisibleLineOffsetFunction, err = textIterStruct.InvokerNew("set_visible_line_offset")
	})
	return err
}

// SetVisibleLineOffset is a representation of the C type gtk_text_iter_set_visible_line_offset.
func (recv *TextIter) SetVisibleLineOffset(charOnLine int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(charOnLine)

	err := textIterSetVisibleLineOffsetFunction_Set()
	if err == nil {
		textIterSetVisibleLineOffsetFunction.Invoke(inArgs[:], nil)
	}

	return
}

var textIterStartsLineFunction *gi.Function
var textIterStartsLineFunction_Once sync.Once

func textIterStartsLineFunction_Set() error {
	var err error
	textIterStartsLineFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterStartsLineFunction, err = textIterStruct.InvokerNew("starts_line")
	})
	return err
}

// StartsLine is a representation of the C type gtk_text_iter_starts_line.
func (recv *TextIter) StartsLine() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterStartsLineFunction_Set()
	if err == nil {
		ret = textIterStartsLineFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterStartsSentenceFunction *gi.Function
var textIterStartsSentenceFunction_Once sync.Once

func textIterStartsSentenceFunction_Set() error {
	var err error
	textIterStartsSentenceFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterStartsSentenceFunction, err = textIterStruct.InvokerNew("starts_sentence")
	})
	return err
}

// StartsSentence is a representation of the C type gtk_text_iter_starts_sentence.
func (recv *TextIter) StartsSentence() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterStartsSentenceFunction_Set()
	if err == nil {
		ret = textIterStartsSentenceFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterStartsTagFunction *gi.Function
var textIterStartsTagFunction_Once sync.Once

func textIterStartsTagFunction_Set() error {
	var err error
	textIterStartsTagFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterStartsTagFunction, err = textIterStruct.InvokerNew("starts_tag")
	})
	return err
}

// StartsTag is a representation of the C type gtk_text_iter_starts_tag.
func (recv *TextIter) StartsTag(tag *TextTag) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(tag.Native())

	var ret gi.Argument

	err := textIterStartsTagFunction_Set()
	if err == nil {
		ret = textIterStartsTagFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterStartsWordFunction *gi.Function
var textIterStartsWordFunction_Once sync.Once

func textIterStartsWordFunction_Set() error {
	var err error
	textIterStartsWordFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterStartsWordFunction, err = textIterStruct.InvokerNew("starts_word")
	})
	return err
}

// StartsWord is a representation of the C type gtk_text_iter_starts_word.
func (recv *TextIter) StartsWord() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := textIterStartsWordFunction_Set()
	if err == nil {
		ret = textIterStartsWordFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var textIterTogglesTagFunction *gi.Function
var textIterTogglesTagFunction_Once sync.Once

func textIterTogglesTagFunction_Set() error {
	var err error
	textIterTogglesTagFunction_Once.Do(func() {
		err = textIterStruct_Set()
		if err != nil {
			return
		}
		textIterTogglesTagFunction, err = textIterStruct.InvokerNew("toggles_tag")
	})
	return err
}

// TogglesTag is a representation of the C type gtk_text_iter_toggles_tag.
func (recv *TextIter) TogglesTag(tag *TextTag) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(tag.Native())

	var ret gi.Argument

	err := textIterTogglesTagFunction_Set()
	if err == nil {
		ret = textIterTogglesTagFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

// TextIterStruct creates an uninitialised TextIter.
func TextIterStruct() *TextIter {
	err := textIterStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextIterNewFromNative(textIterStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextIter)
	return structGo
}
func finalizeTextIter(obj *TextIter) {
	textIterStruct.Free(obj.Native())
}

var textMarkClassStruct *gi.Struct
var textMarkClassStruct_Once sync.Once

func textMarkClassStruct_Set() error {
	var err error
	textMarkClassStruct_Once.Do(func() {
		textMarkClassStruct, err = gi.StructNew("Gtk", "TextMarkClass")
	})
	return err
}

type TextMarkClass struct {
	native unsafe.Pointer
}

func TextMarkClassNewFromNative(native unsafe.Pointer) *TextMarkClass {
	err := textMarkClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextMarkClass{native: native}

	return instance
}

/*
CastToTextMarkClass down casts any arbitrary Object to TextMarkClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextMarkClass.
*/
func CastToTextMarkClass(object *gobject.Object) *TextMarkClass {
	return TextMarkClassNewFromNative(object.Native())
}

// Equals compares this TextMarkClass with another TextMarkClass, and returns true if they represent the same Object.
func (recv *TextMarkClass) Equals(other *TextMarkClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TextMarkClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TextMarkClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(textMarkClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TextMarkClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textMarkClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TextMarkClassStruct creates an uninitialised TextMarkClass.
func TextMarkClassStruct() *TextMarkClass {
	err := textMarkClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextMarkClassNewFromNative(textMarkClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextMarkClass)
	return structGo
}
func finalizeTextMarkClass(obj *TextMarkClass) {
	textMarkClassStruct.Free(obj.Native())
}

var textTagClassStruct *gi.Struct
var textTagClassStruct_Once sync.Once

func textTagClassStruct_Set() error {
	var err error
	textTagClassStruct_Once.Do(func() {
		textTagClassStruct, err = gi.StructNew("Gtk", "TextTagClass")
	})
	return err
}

type TextTagClass struct {
	native unsafe.Pointer
}

func TextTagClassNewFromNative(native unsafe.Pointer) *TextTagClass {
	err := textTagClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextTagClass{native: native}

	return instance
}

/*
CastToTextTagClass down casts any arbitrary Object to TextTagClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextTagClass.
*/
func CastToTextTagClass(object *gobject.Object) *TextTagClass {
	return TextTagClassNewFromNative(object.Native())
}

// Equals compares this TextTagClass with another TextTagClass, and returns true if they represent the same Object.
func (recv *TextTagClass) Equals(other *TextTagClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TextTagClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TextTagClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(textTagClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TextTagClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textTagClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'event' : for field getter : missing Type

// UNSUPPORTED : C value 'event' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TextTagClassStruct creates an uninitialised TextTagClass.
func TextTagClassStruct() *TextTagClass {
	err := textTagClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextTagClassNewFromNative(textTagClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextTagClass)
	return structGo
}
func finalizeTextTagClass(obj *TextTagClass) {
	textTagClassStruct.Free(obj.Native())
}

var textTagPrivateStruct *gi.Struct
var textTagPrivateStruct_Once sync.Once

func textTagPrivateStruct_Set() error {
	var err error
	textTagPrivateStruct_Once.Do(func() {
		textTagPrivateStruct, err = gi.StructNew("Gtk", "TextTagPrivate")
	})
	return err
}

type TextTagPrivate struct {
	native unsafe.Pointer
}

func TextTagPrivateNewFromNative(native unsafe.Pointer) *TextTagPrivate {
	err := textTagPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextTagPrivate{native: native}

	return instance
}

/*
CastToTextTagPrivate down casts any arbitrary Object to TextTagPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextTagPrivate.
*/
func CastToTextTagPrivate(object *gobject.Object) *TextTagPrivate {
	return TextTagPrivateNewFromNative(object.Native())
}

// Equals compares this TextTagPrivate with another TextTagPrivate, and returns true if they represent the same Object.
func (recv *TextTagPrivate) Equals(other *TextTagPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TextTagPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TextTagPrivateStruct creates an uninitialised TextTagPrivate.
func TextTagPrivateStruct() *TextTagPrivate {
	err := textTagPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextTagPrivateNewFromNative(textTagPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextTagPrivate)
	return structGo
}
func finalizeTextTagPrivate(obj *TextTagPrivate) {
	textTagPrivateStruct.Free(obj.Native())
}

var textTagTableClassStruct *gi.Struct
var textTagTableClassStruct_Once sync.Once

func textTagTableClassStruct_Set() error {
	var err error
	textTagTableClassStruct_Once.Do(func() {
		textTagTableClassStruct, err = gi.StructNew("Gtk", "TextTagTableClass")
	})
	return err
}

type TextTagTableClass struct {
	native unsafe.Pointer
}

func TextTagTableClassNewFromNative(native unsafe.Pointer) *TextTagTableClass {
	err := textTagTableClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextTagTableClass{native: native}

	return instance
}

/*
CastToTextTagTableClass down casts any arbitrary Object to TextTagTableClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextTagTableClass.
*/
func CastToTextTagTableClass(object *gobject.Object) *TextTagTableClass {
	return TextTagTableClassNewFromNative(object.Native())
}

// Equals compares this TextTagTableClass with another TextTagTableClass, and returns true if they represent the same Object.
func (recv *TextTagTableClass) Equals(other *TextTagTableClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TextTagTableClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TextTagTableClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(textTagTableClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TextTagTableClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textTagTableClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'tag_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'tag_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'tag_added' : for field getter : missing Type

// UNSUPPORTED : C value 'tag_added' : for field setter : missing Type

// UNSUPPORTED : C value 'tag_removed' : for field getter : missing Type

// UNSUPPORTED : C value 'tag_removed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TextTagTableClassStruct creates an uninitialised TextTagTableClass.
func TextTagTableClassStruct() *TextTagTableClass {
	err := textTagTableClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextTagTableClassNewFromNative(textTagTableClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextTagTableClass)
	return structGo
}
func finalizeTextTagTableClass(obj *TextTagTableClass) {
	textTagTableClassStruct.Free(obj.Native())
}

var textTagTablePrivateStruct *gi.Struct
var textTagTablePrivateStruct_Once sync.Once

func textTagTablePrivateStruct_Set() error {
	var err error
	textTagTablePrivateStruct_Once.Do(func() {
		textTagTablePrivateStruct, err = gi.StructNew("Gtk", "TextTagTablePrivate")
	})
	return err
}

type TextTagTablePrivate struct {
	native unsafe.Pointer
}

func TextTagTablePrivateNewFromNative(native unsafe.Pointer) *TextTagTablePrivate {
	err := textTagTablePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextTagTablePrivate{native: native}

	return instance
}

/*
CastToTextTagTablePrivate down casts any arbitrary Object to TextTagTablePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextTagTablePrivate.
*/
func CastToTextTagTablePrivate(object *gobject.Object) *TextTagTablePrivate {
	return TextTagTablePrivateNewFromNative(object.Native())
}

// Equals compares this TextTagTablePrivate with another TextTagTablePrivate, and returns true if they represent the same Object.
func (recv *TextTagTablePrivate) Equals(other *TextTagTablePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TextTagTablePrivate) Native() unsafe.Pointer {
	return recv.native
}

// TextTagTablePrivateStruct creates an uninitialised TextTagTablePrivate.
func TextTagTablePrivateStruct() *TextTagTablePrivate {
	err := textTagTablePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextTagTablePrivateNewFromNative(textTagTablePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextTagTablePrivate)
	return structGo
}
func finalizeTextTagTablePrivate(obj *TextTagTablePrivate) {
	textTagTablePrivateStruct.Free(obj.Native())
}

var textViewAccessibleClassStruct *gi.Struct
var textViewAccessibleClassStruct_Once sync.Once

func textViewAccessibleClassStruct_Set() error {
	var err error
	textViewAccessibleClassStruct_Once.Do(func() {
		textViewAccessibleClassStruct, err = gi.StructNew("Gtk", "TextViewAccessibleClass")
	})
	return err
}

type TextViewAccessibleClass struct {
	native unsafe.Pointer
}

func TextViewAccessibleClassNewFromNative(native unsafe.Pointer) *TextViewAccessibleClass {
	err := textViewAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextViewAccessibleClass{native: native}

	return instance
}

/*
CastToTextViewAccessibleClass down casts any arbitrary Object to TextViewAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextViewAccessibleClass.
*/
func CastToTextViewAccessibleClass(object *gobject.Object) *TextViewAccessibleClass {
	return TextViewAccessibleClassNewFromNative(object.Native())
}

// Equals compares this TextViewAccessibleClass with another TextViewAccessibleClass, and returns true if they represent the same Object.
func (recv *TextViewAccessibleClass) Equals(other *TextViewAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TextViewAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TextViewAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(textViewAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TextViewAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textViewAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// TextViewAccessibleClassStruct creates an uninitialised TextViewAccessibleClass.
func TextViewAccessibleClassStruct() *TextViewAccessibleClass {
	err := textViewAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextViewAccessibleClassNewFromNative(textViewAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextViewAccessibleClass)
	return structGo
}
func finalizeTextViewAccessibleClass(obj *TextViewAccessibleClass) {
	textViewAccessibleClassStruct.Free(obj.Native())
}

var textViewAccessiblePrivateStruct *gi.Struct
var textViewAccessiblePrivateStruct_Once sync.Once

func textViewAccessiblePrivateStruct_Set() error {
	var err error
	textViewAccessiblePrivateStruct_Once.Do(func() {
		textViewAccessiblePrivateStruct, err = gi.StructNew("Gtk", "TextViewAccessiblePrivate")
	})
	return err
}

type TextViewAccessiblePrivate struct {
	native unsafe.Pointer
}

func TextViewAccessiblePrivateNewFromNative(native unsafe.Pointer) *TextViewAccessiblePrivate {
	err := textViewAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextViewAccessiblePrivate{native: native}

	return instance
}

/*
CastToTextViewAccessiblePrivate down casts any arbitrary Object to TextViewAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextViewAccessiblePrivate.
*/
func CastToTextViewAccessiblePrivate(object *gobject.Object) *TextViewAccessiblePrivate {
	return TextViewAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this TextViewAccessiblePrivate with another TextViewAccessiblePrivate, and returns true if they represent the same Object.
func (recv *TextViewAccessiblePrivate) Equals(other *TextViewAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TextViewAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// TextViewAccessiblePrivateStruct creates an uninitialised TextViewAccessiblePrivate.
func TextViewAccessiblePrivateStruct() *TextViewAccessiblePrivate {
	err := textViewAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextViewAccessiblePrivateNewFromNative(textViewAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextViewAccessiblePrivate)
	return structGo
}
func finalizeTextViewAccessiblePrivate(obj *TextViewAccessiblePrivate) {
	textViewAccessiblePrivateStruct.Free(obj.Native())
}

var textViewClassStruct *gi.Struct
var textViewClassStruct_Once sync.Once

func textViewClassStruct_Set() error {
	var err error
	textViewClassStruct_Once.Do(func() {
		textViewClassStruct, err = gi.StructNew("Gtk", "TextViewClass")
	})
	return err
}

type TextViewClass struct {
	native unsafe.Pointer
}

func TextViewClassNewFromNative(native unsafe.Pointer) *TextViewClass {
	err := textViewClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextViewClass{native: native}

	return instance
}

/*
CastToTextViewClass down casts any arbitrary Object to TextViewClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextViewClass.
*/
func CastToTextViewClass(object *gobject.Object) *TextViewClass {
	return TextViewClassNewFromNative(object.Native())
}

// Equals compares this TextViewClass with another TextViewClass, and returns true if they represent the same Object.
func (recv *TextViewClass) Equals(other *TextViewClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TextViewClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TextViewClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(textViewClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TextViewClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(textViewClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'populate_popup' : for field getter : missing Type

// UNSUPPORTED : C value 'populate_popup' : for field setter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'set_anchor' : for field getter : missing Type

// UNSUPPORTED : C value 'set_anchor' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_at_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_at_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'delete_from_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'delete_from_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'backspace' : for field getter : missing Type

// UNSUPPORTED : C value 'backspace' : for field setter : missing Type

// UNSUPPORTED : C value 'cut_clipboard' : for field getter : missing Type

// UNSUPPORTED : C value 'cut_clipboard' : for field setter : missing Type

// UNSUPPORTED : C value 'copy_clipboard' : for field getter : missing Type

// UNSUPPORTED : C value 'copy_clipboard' : for field setter : missing Type

// UNSUPPORTED : C value 'paste_clipboard' : for field getter : missing Type

// UNSUPPORTED : C value 'paste_clipboard' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_overwrite' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_overwrite' : for field setter : missing Type

// UNSUPPORTED : C value 'create_buffer' : for field getter : missing Type

// UNSUPPORTED : C value 'create_buffer' : for field setter : missing Type

// UNSUPPORTED : C value 'draw_layer' : for field getter : missing Type

// UNSUPPORTED : C value 'draw_layer' : for field setter : missing Type

// UNSUPPORTED : C value 'extend_selection' : for field getter : missing Type

// UNSUPPORTED : C value 'extend_selection' : for field setter : missing Type

// UNSUPPORTED : C value 'insert_emoji' : for field getter : missing Type

// UNSUPPORTED : C value 'insert_emoji' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TextViewClassStruct creates an uninitialised TextViewClass.
func TextViewClassStruct() *TextViewClass {
	err := textViewClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextViewClassNewFromNative(textViewClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextViewClass)
	return structGo
}
func finalizeTextViewClass(obj *TextViewClass) {
	textViewClassStruct.Free(obj.Native())
}

var textViewPrivateStruct *gi.Struct
var textViewPrivateStruct_Once sync.Once

func textViewPrivateStruct_Set() error {
	var err error
	textViewPrivateStruct_Once.Do(func() {
		textViewPrivateStruct, err = gi.StructNew("Gtk", "TextViewPrivate")
	})
	return err
}

type TextViewPrivate struct {
	native unsafe.Pointer
}

func TextViewPrivateNewFromNative(native unsafe.Pointer) *TextViewPrivate {
	err := textViewPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TextViewPrivate{native: native}

	return instance
}

/*
CastToTextViewPrivate down casts any arbitrary Object to TextViewPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TextViewPrivate.
*/
func CastToTextViewPrivate(object *gobject.Object) *TextViewPrivate {
	return TextViewPrivateNewFromNative(object.Native())
}

// Equals compares this TextViewPrivate with another TextViewPrivate, and returns true if they represent the same Object.
func (recv *TextViewPrivate) Equals(other *TextViewPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TextViewPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TextViewPrivateStruct creates an uninitialised TextViewPrivate.
func TextViewPrivateStruct() *TextViewPrivate {
	err := textViewPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TextViewPrivateNewFromNative(textViewPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTextViewPrivate)
	return structGo
}
func finalizeTextViewPrivate(obj *TextViewPrivate) {
	textViewPrivateStruct.Free(obj.Native())
}

var themeEngineStruct *gi.Struct
var themeEngineStruct_Once sync.Once

func themeEngineStruct_Set() error {
	var err error
	themeEngineStruct_Once.Do(func() {
		themeEngineStruct, err = gi.StructNew("Gtk", "ThemeEngine")
	})
	return err
}

type ThemeEngine struct {
	native unsafe.Pointer
}

func ThemeEngineNewFromNative(native unsafe.Pointer) *ThemeEngine {
	err := themeEngineStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ThemeEngine{native: native}

	return instance
}

/*
CastToThemeEngine down casts any arbitrary Object to ThemeEngine.
Exercise care, as this is a potentially dangerous function
if the Object is not a ThemeEngine.
*/
func CastToThemeEngine(object *gobject.Object) *ThemeEngine {
	return ThemeEngineNewFromNative(object.Native())
}

// Equals compares this ThemeEngine with another ThemeEngine, and returns true if they represent the same Object.
func (recv *ThemeEngine) Equals(other *ThemeEngine) bool {
	return other.Native() == recv.Native()
}

func (recv *ThemeEngine) Native() unsafe.Pointer {
	return recv.native
}

// ThemeEngineStruct creates an uninitialised ThemeEngine.
func ThemeEngineStruct() *ThemeEngine {
	err := themeEngineStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ThemeEngineNewFromNative(themeEngineStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeThemeEngine)
	return structGo
}
func finalizeThemeEngine(obj *ThemeEngine) {
	themeEngineStruct.Free(obj.Native())
}

var themingEngineClassStruct *gi.Struct
var themingEngineClassStruct_Once sync.Once

func themingEngineClassStruct_Set() error {
	var err error
	themingEngineClassStruct_Once.Do(func() {
		themingEngineClassStruct, err = gi.StructNew("Gtk", "ThemingEngineClass")
	})
	return err
}

type ThemingEngineClass struct {
	native unsafe.Pointer
}

func ThemingEngineClassNewFromNative(native unsafe.Pointer) *ThemingEngineClass {
	err := themingEngineClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ThemingEngineClass{native: native}

	return instance
}

/*
CastToThemingEngineClass down casts any arbitrary Object to ThemingEngineClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ThemingEngineClass.
*/
func CastToThemingEngineClass(object *gobject.Object) *ThemingEngineClass {
	return ThemingEngineClassNewFromNative(object.Native())
}

// Equals compares this ThemingEngineClass with another ThemingEngineClass, and returns true if they represent the same Object.
func (recv *ThemingEngineClass) Equals(other *ThemingEngineClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ThemingEngineClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ThemingEngineClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(themingEngineClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ThemingEngineClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(themingEngineClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'render_line' : for field getter : missing Type

// UNSUPPORTED : C value 'render_line' : for field setter : missing Type

// UNSUPPORTED : C value 'render_background' : for field getter : missing Type

// UNSUPPORTED : C value 'render_background' : for field setter : missing Type

// UNSUPPORTED : C value 'render_frame' : for field getter : missing Type

// UNSUPPORTED : C value 'render_frame' : for field setter : missing Type

// UNSUPPORTED : C value 'render_frame_gap' : for field getter : missing Type

// UNSUPPORTED : C value 'render_frame_gap' : for field setter : missing Type

// UNSUPPORTED : C value 'render_extension' : for field getter : missing Type

// UNSUPPORTED : C value 'render_extension' : for field setter : missing Type

// UNSUPPORTED : C value 'render_check' : for field getter : missing Type

// UNSUPPORTED : C value 'render_check' : for field setter : missing Type

// UNSUPPORTED : C value 'render_option' : for field getter : missing Type

// UNSUPPORTED : C value 'render_option' : for field setter : missing Type

// UNSUPPORTED : C value 'render_arrow' : for field getter : missing Type

// UNSUPPORTED : C value 'render_arrow' : for field setter : missing Type

// UNSUPPORTED : C value 'render_expander' : for field getter : missing Type

// UNSUPPORTED : C value 'render_expander' : for field setter : missing Type

// UNSUPPORTED : C value 'render_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'render_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'render_layout' : for field getter : missing Type

// UNSUPPORTED : C value 'render_layout' : for field setter : missing Type

// UNSUPPORTED : C value 'render_slider' : for field getter : missing Type

// UNSUPPORTED : C value 'render_slider' : for field setter : missing Type

// UNSUPPORTED : C value 'render_handle' : for field getter : missing Type

// UNSUPPORTED : C value 'render_handle' : for field setter : missing Type

// UNSUPPORTED : C value 'render_activity' : for field getter : missing Type

// UNSUPPORTED : C value 'render_activity' : for field setter : missing Type

// UNSUPPORTED : C value 'render_icon_pixbuf' : for field getter : missing Type

// UNSUPPORTED : C value 'render_icon_pixbuf' : for field setter : missing Type

// UNSUPPORTED : C value 'render_icon' : for field getter : missing Type

// UNSUPPORTED : C value 'render_icon' : for field setter : missing Type

// UNSUPPORTED : C value 'render_icon_surface' : for field getter : missing Type

// UNSUPPORTED : C value 'render_icon_surface' : for field setter : missing Type

// ThemingEngineClassStruct creates an uninitialised ThemingEngineClass.
func ThemingEngineClassStruct() *ThemingEngineClass {
	err := themingEngineClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ThemingEngineClassNewFromNative(themingEngineClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeThemingEngineClass)
	return structGo
}
func finalizeThemingEngineClass(obj *ThemingEngineClass) {
	themingEngineClassStruct.Free(obj.Native())
}

var themingEnginePrivateStruct *gi.Struct
var themingEnginePrivateStruct_Once sync.Once

func themingEnginePrivateStruct_Set() error {
	var err error
	themingEnginePrivateStruct_Once.Do(func() {
		themingEnginePrivateStruct, err = gi.StructNew("Gtk", "ThemingEnginePrivate")
	})
	return err
}

type ThemingEnginePrivate struct {
	native unsafe.Pointer
}

func ThemingEnginePrivateNewFromNative(native unsafe.Pointer) *ThemingEnginePrivate {
	err := themingEnginePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ThemingEnginePrivate{native: native}

	return instance
}

/*
CastToThemingEnginePrivate down casts any arbitrary Object to ThemingEnginePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ThemingEnginePrivate.
*/
func CastToThemingEnginePrivate(object *gobject.Object) *ThemingEnginePrivate {
	return ThemingEnginePrivateNewFromNative(object.Native())
}

// Equals compares this ThemingEnginePrivate with another ThemingEnginePrivate, and returns true if they represent the same Object.
func (recv *ThemingEnginePrivate) Equals(other *ThemingEnginePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ThemingEnginePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ThemingEnginePrivateStruct creates an uninitialised ThemingEnginePrivate.
func ThemingEnginePrivateStruct() *ThemingEnginePrivate {
	err := themingEnginePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ThemingEnginePrivateNewFromNative(themingEnginePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeThemingEnginePrivate)
	return structGo
}
func finalizeThemingEnginePrivate(obj *ThemingEnginePrivate) {
	themingEnginePrivateStruct.Free(obj.Native())
}

var toggleActionClassStruct *gi.Struct
var toggleActionClassStruct_Once sync.Once

func toggleActionClassStruct_Set() error {
	var err error
	toggleActionClassStruct_Once.Do(func() {
		toggleActionClassStruct, err = gi.StructNew("Gtk", "ToggleActionClass")
	})
	return err
}

type ToggleActionClass struct {
	native unsafe.Pointer
}

func ToggleActionClassNewFromNative(native unsafe.Pointer) *ToggleActionClass {
	err := toggleActionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleActionClass{native: native}

	return instance
}

/*
CastToToggleActionClass down casts any arbitrary Object to ToggleActionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleActionClass.
*/
func CastToToggleActionClass(object *gobject.Object) *ToggleActionClass {
	return ToggleActionClassNewFromNative(object.Native())
}

// Equals compares this ToggleActionClass with another ToggleActionClass, and returns true if they represent the same Object.
func (recv *ToggleActionClass) Equals(other *ToggleActionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleActionClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToggleActionClass) FieldParentClass() *ActionClass {
	argValue := gi.StructFieldGet(toggleActionClassStruct, recv.Native(), "parent_class")
	value := ActionClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToggleActionClass) SetFieldParentClass(value *ActionClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toggleActionClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'toggled' : for field getter : missing Type

// UNSUPPORTED : C value 'toggled' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ToggleActionClassStruct creates an uninitialised ToggleActionClass.
func ToggleActionClassStruct() *ToggleActionClass {
	err := toggleActionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleActionClassNewFromNative(toggleActionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleActionClass)
	return structGo
}
func finalizeToggleActionClass(obj *ToggleActionClass) {
	toggleActionClassStruct.Free(obj.Native())
}

var toggleActionEntryStruct *gi.Struct
var toggleActionEntryStruct_Once sync.Once

func toggleActionEntryStruct_Set() error {
	var err error
	toggleActionEntryStruct_Once.Do(func() {
		toggleActionEntryStruct, err = gi.StructNew("Gtk", "ToggleActionEntry")
	})
	return err
}

type ToggleActionEntry struct {
	native unsafe.Pointer
}

func ToggleActionEntryNewFromNative(native unsafe.Pointer) *ToggleActionEntry {
	err := toggleActionEntryStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleActionEntry{native: native}

	return instance
}

/*
CastToToggleActionEntry down casts any arbitrary Object to ToggleActionEntry.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleActionEntry.
*/
func CastToToggleActionEntry(object *gobject.Object) *ToggleActionEntry {
	return ToggleActionEntryNewFromNative(object.Native())
}

// Equals compares this ToggleActionEntry with another ToggleActionEntry, and returns true if they represent the same Object.
func (recv *ToggleActionEntry) Equals(other *ToggleActionEntry) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleActionEntry) Native() unsafe.Pointer {
	return recv.native
}

// FieldName returns the C field 'name'.
func (recv *ToggleActionEntry) FieldName() string {
	argValue := gi.StructFieldGet(toggleActionEntryStruct, recv.Native(), "name")
	value := argValue.String(false)
	return value
}

// SetFieldName sets the value of the C field 'name'.
func (recv *ToggleActionEntry) SetFieldName(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(toggleActionEntryStruct, recv.Native(), "name", argValue)
}

// FieldStockId returns the C field 'stock_id'.
func (recv *ToggleActionEntry) FieldStockId() string {
	argValue := gi.StructFieldGet(toggleActionEntryStruct, recv.Native(), "stock_id")
	value := argValue.String(false)
	return value
}

// SetFieldStockId sets the value of the C field 'stock_id'.
func (recv *ToggleActionEntry) SetFieldStockId(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(toggleActionEntryStruct, recv.Native(), "stock_id", argValue)
}

// FieldLabel returns the C field 'label'.
func (recv *ToggleActionEntry) FieldLabel() string {
	argValue := gi.StructFieldGet(toggleActionEntryStruct, recv.Native(), "label")
	value := argValue.String(false)
	return value
}

// SetFieldLabel sets the value of the C field 'label'.
func (recv *ToggleActionEntry) SetFieldLabel(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(toggleActionEntryStruct, recv.Native(), "label", argValue)
}

// FieldAccelerator returns the C field 'accelerator'.
func (recv *ToggleActionEntry) FieldAccelerator() string {
	argValue := gi.StructFieldGet(toggleActionEntryStruct, recv.Native(), "accelerator")
	value := argValue.String(false)
	return value
}

// SetFieldAccelerator sets the value of the C field 'accelerator'.
func (recv *ToggleActionEntry) SetFieldAccelerator(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(toggleActionEntryStruct, recv.Native(), "accelerator", argValue)
}

// FieldTooltip returns the C field 'tooltip'.
func (recv *ToggleActionEntry) FieldTooltip() string {
	argValue := gi.StructFieldGet(toggleActionEntryStruct, recv.Native(), "tooltip")
	value := argValue.String(false)
	return value
}

// SetFieldTooltip sets the value of the C field 'tooltip'.
func (recv *ToggleActionEntry) SetFieldTooltip(value string) {
	var argValue gi.Argument
	argValue.SetString(value)
	gi.StructFieldSet(toggleActionEntryStruct, recv.Native(), "tooltip", argValue)
}

// UNSUPPORTED : C value 'callback' : for field getter : no Go type for 'GObject.Callback'

// UNSUPPORTED : C value 'callback' : for field setter : no Go type for 'GObject.Callback'

// FieldIsActive returns the C field 'is_active'.
func (recv *ToggleActionEntry) FieldIsActive() bool {
	argValue := gi.StructFieldGet(toggleActionEntryStruct, recv.Native(), "is_active")
	value := argValue.Boolean()
	return value
}

// SetFieldIsActive sets the value of the C field 'is_active'.
func (recv *ToggleActionEntry) SetFieldIsActive(value bool) {
	var argValue gi.Argument
	argValue.SetBoolean(value)
	gi.StructFieldSet(toggleActionEntryStruct, recv.Native(), "is_active", argValue)
}

// ToggleActionEntryStruct creates an uninitialised ToggleActionEntry.
func ToggleActionEntryStruct() *ToggleActionEntry {
	err := toggleActionEntryStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleActionEntryNewFromNative(toggleActionEntryStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleActionEntry)
	return structGo
}
func finalizeToggleActionEntry(obj *ToggleActionEntry) {
	toggleActionEntryStruct.Free(obj.Native())
}

var toggleActionPrivateStruct *gi.Struct
var toggleActionPrivateStruct_Once sync.Once

func toggleActionPrivateStruct_Set() error {
	var err error
	toggleActionPrivateStruct_Once.Do(func() {
		toggleActionPrivateStruct, err = gi.StructNew("Gtk", "ToggleActionPrivate")
	})
	return err
}

type ToggleActionPrivate struct {
	native unsafe.Pointer
}

func ToggleActionPrivateNewFromNative(native unsafe.Pointer) *ToggleActionPrivate {
	err := toggleActionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleActionPrivate{native: native}

	return instance
}

/*
CastToToggleActionPrivate down casts any arbitrary Object to ToggleActionPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleActionPrivate.
*/
func CastToToggleActionPrivate(object *gobject.Object) *ToggleActionPrivate {
	return ToggleActionPrivateNewFromNative(object.Native())
}

// Equals compares this ToggleActionPrivate with another ToggleActionPrivate, and returns true if they represent the same Object.
func (recv *ToggleActionPrivate) Equals(other *ToggleActionPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleActionPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToggleActionPrivateStruct creates an uninitialised ToggleActionPrivate.
func ToggleActionPrivateStruct() *ToggleActionPrivate {
	err := toggleActionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleActionPrivateNewFromNative(toggleActionPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleActionPrivate)
	return structGo
}
func finalizeToggleActionPrivate(obj *ToggleActionPrivate) {
	toggleActionPrivateStruct.Free(obj.Native())
}

var toggleButtonAccessibleClassStruct *gi.Struct
var toggleButtonAccessibleClassStruct_Once sync.Once

func toggleButtonAccessibleClassStruct_Set() error {
	var err error
	toggleButtonAccessibleClassStruct_Once.Do(func() {
		toggleButtonAccessibleClassStruct, err = gi.StructNew("Gtk", "ToggleButtonAccessibleClass")
	})
	return err
}

type ToggleButtonAccessibleClass struct {
	native unsafe.Pointer
}

func ToggleButtonAccessibleClassNewFromNative(native unsafe.Pointer) *ToggleButtonAccessibleClass {
	err := toggleButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleButtonAccessibleClass{native: native}

	return instance
}

/*
CastToToggleButtonAccessibleClass down casts any arbitrary Object to ToggleButtonAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleButtonAccessibleClass.
*/
func CastToToggleButtonAccessibleClass(object *gobject.Object) *ToggleButtonAccessibleClass {
	return ToggleButtonAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ToggleButtonAccessibleClass with another ToggleButtonAccessibleClass, and returns true if they represent the same Object.
func (recv *ToggleButtonAccessibleClass) Equals(other *ToggleButtonAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleButtonAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToggleButtonAccessibleClass) FieldParentClass() *ButtonAccessibleClass {
	argValue := gi.StructFieldGet(toggleButtonAccessibleClassStruct, recv.Native(), "parent_class")
	value := ButtonAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToggleButtonAccessibleClass) SetFieldParentClass(value *ButtonAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toggleButtonAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ToggleButtonAccessibleClassStruct creates an uninitialised ToggleButtonAccessibleClass.
func ToggleButtonAccessibleClassStruct() *ToggleButtonAccessibleClass {
	err := toggleButtonAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleButtonAccessibleClassNewFromNative(toggleButtonAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleButtonAccessibleClass)
	return structGo
}
func finalizeToggleButtonAccessibleClass(obj *ToggleButtonAccessibleClass) {
	toggleButtonAccessibleClassStruct.Free(obj.Native())
}

var toggleButtonAccessiblePrivateStruct *gi.Struct
var toggleButtonAccessiblePrivateStruct_Once sync.Once

func toggleButtonAccessiblePrivateStruct_Set() error {
	var err error
	toggleButtonAccessiblePrivateStruct_Once.Do(func() {
		toggleButtonAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ToggleButtonAccessiblePrivate")
	})
	return err
}

type ToggleButtonAccessiblePrivate struct {
	native unsafe.Pointer
}

func ToggleButtonAccessiblePrivateNewFromNative(native unsafe.Pointer) *ToggleButtonAccessiblePrivate {
	err := toggleButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleButtonAccessiblePrivate{native: native}

	return instance
}

/*
CastToToggleButtonAccessiblePrivate down casts any arbitrary Object to ToggleButtonAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleButtonAccessiblePrivate.
*/
func CastToToggleButtonAccessiblePrivate(object *gobject.Object) *ToggleButtonAccessiblePrivate {
	return ToggleButtonAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ToggleButtonAccessiblePrivate with another ToggleButtonAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ToggleButtonAccessiblePrivate) Equals(other *ToggleButtonAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleButtonAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToggleButtonAccessiblePrivateStruct creates an uninitialised ToggleButtonAccessiblePrivate.
func ToggleButtonAccessiblePrivateStruct() *ToggleButtonAccessiblePrivate {
	err := toggleButtonAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleButtonAccessiblePrivateNewFromNative(toggleButtonAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleButtonAccessiblePrivate)
	return structGo
}
func finalizeToggleButtonAccessiblePrivate(obj *ToggleButtonAccessiblePrivate) {
	toggleButtonAccessiblePrivateStruct.Free(obj.Native())
}

var toggleButtonClassStruct *gi.Struct
var toggleButtonClassStruct_Once sync.Once

func toggleButtonClassStruct_Set() error {
	var err error
	toggleButtonClassStruct_Once.Do(func() {
		toggleButtonClassStruct, err = gi.StructNew("Gtk", "ToggleButtonClass")
	})
	return err
}

type ToggleButtonClass struct {
	native unsafe.Pointer
}

func ToggleButtonClassNewFromNative(native unsafe.Pointer) *ToggleButtonClass {
	err := toggleButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleButtonClass{native: native}

	return instance
}

/*
CastToToggleButtonClass down casts any arbitrary Object to ToggleButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleButtonClass.
*/
func CastToToggleButtonClass(object *gobject.Object) *ToggleButtonClass {
	return ToggleButtonClassNewFromNative(object.Native())
}

// Equals compares this ToggleButtonClass with another ToggleButtonClass, and returns true if they represent the same Object.
func (recv *ToggleButtonClass) Equals(other *ToggleButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToggleButtonClass) FieldParentClass() *ButtonClass {
	argValue := gi.StructFieldGet(toggleButtonClassStruct, recv.Native(), "parent_class")
	value := ButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToggleButtonClass) SetFieldParentClass(value *ButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toggleButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'toggled' : for field getter : missing Type

// UNSUPPORTED : C value 'toggled' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ToggleButtonClassStruct creates an uninitialised ToggleButtonClass.
func ToggleButtonClassStruct() *ToggleButtonClass {
	err := toggleButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleButtonClassNewFromNative(toggleButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleButtonClass)
	return structGo
}
func finalizeToggleButtonClass(obj *ToggleButtonClass) {
	toggleButtonClassStruct.Free(obj.Native())
}

var toggleButtonPrivateStruct *gi.Struct
var toggleButtonPrivateStruct_Once sync.Once

func toggleButtonPrivateStruct_Set() error {
	var err error
	toggleButtonPrivateStruct_Once.Do(func() {
		toggleButtonPrivateStruct, err = gi.StructNew("Gtk", "ToggleButtonPrivate")
	})
	return err
}

type ToggleButtonPrivate struct {
	native unsafe.Pointer
}

func ToggleButtonPrivateNewFromNative(native unsafe.Pointer) *ToggleButtonPrivate {
	err := toggleButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleButtonPrivate{native: native}

	return instance
}

/*
CastToToggleButtonPrivate down casts any arbitrary Object to ToggleButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleButtonPrivate.
*/
func CastToToggleButtonPrivate(object *gobject.Object) *ToggleButtonPrivate {
	return ToggleButtonPrivateNewFromNative(object.Native())
}

// Equals compares this ToggleButtonPrivate with another ToggleButtonPrivate, and returns true if they represent the same Object.
func (recv *ToggleButtonPrivate) Equals(other *ToggleButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToggleButtonPrivateStruct creates an uninitialised ToggleButtonPrivate.
func ToggleButtonPrivateStruct() *ToggleButtonPrivate {
	err := toggleButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleButtonPrivateNewFromNative(toggleButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleButtonPrivate)
	return structGo
}
func finalizeToggleButtonPrivate(obj *ToggleButtonPrivate) {
	toggleButtonPrivateStruct.Free(obj.Native())
}

var toggleToolButtonClassStruct *gi.Struct
var toggleToolButtonClassStruct_Once sync.Once

func toggleToolButtonClassStruct_Set() error {
	var err error
	toggleToolButtonClassStruct_Once.Do(func() {
		toggleToolButtonClassStruct, err = gi.StructNew("Gtk", "ToggleToolButtonClass")
	})
	return err
}

type ToggleToolButtonClass struct {
	native unsafe.Pointer
}

func ToggleToolButtonClassNewFromNative(native unsafe.Pointer) *ToggleToolButtonClass {
	err := toggleToolButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleToolButtonClass{native: native}

	return instance
}

/*
CastToToggleToolButtonClass down casts any arbitrary Object to ToggleToolButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleToolButtonClass.
*/
func CastToToggleToolButtonClass(object *gobject.Object) *ToggleToolButtonClass {
	return ToggleToolButtonClassNewFromNative(object.Native())
}

// Equals compares this ToggleToolButtonClass with another ToggleToolButtonClass, and returns true if they represent the same Object.
func (recv *ToggleToolButtonClass) Equals(other *ToggleToolButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleToolButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToggleToolButtonClass) FieldParentClass() *ToolButtonClass {
	argValue := gi.StructFieldGet(toggleToolButtonClassStruct, recv.Native(), "parent_class")
	value := ToolButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToggleToolButtonClass) SetFieldParentClass(value *ToolButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toggleToolButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'toggled' : for field getter : missing Type

// UNSUPPORTED : C value 'toggled' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ToggleToolButtonClassStruct creates an uninitialised ToggleToolButtonClass.
func ToggleToolButtonClassStruct() *ToggleToolButtonClass {
	err := toggleToolButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleToolButtonClassNewFromNative(toggleToolButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleToolButtonClass)
	return structGo
}
func finalizeToggleToolButtonClass(obj *ToggleToolButtonClass) {
	toggleToolButtonClassStruct.Free(obj.Native())
}

var toggleToolButtonPrivateStruct *gi.Struct
var toggleToolButtonPrivateStruct_Once sync.Once

func toggleToolButtonPrivateStruct_Set() error {
	var err error
	toggleToolButtonPrivateStruct_Once.Do(func() {
		toggleToolButtonPrivateStruct, err = gi.StructNew("Gtk", "ToggleToolButtonPrivate")
	})
	return err
}

type ToggleToolButtonPrivate struct {
	native unsafe.Pointer
}

func ToggleToolButtonPrivateNewFromNative(native unsafe.Pointer) *ToggleToolButtonPrivate {
	err := toggleToolButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToggleToolButtonPrivate{native: native}

	return instance
}

/*
CastToToggleToolButtonPrivate down casts any arbitrary Object to ToggleToolButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToggleToolButtonPrivate.
*/
func CastToToggleToolButtonPrivate(object *gobject.Object) *ToggleToolButtonPrivate {
	return ToggleToolButtonPrivateNewFromNative(object.Native())
}

// Equals compares this ToggleToolButtonPrivate with another ToggleToolButtonPrivate, and returns true if they represent the same Object.
func (recv *ToggleToolButtonPrivate) Equals(other *ToggleToolButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToggleToolButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToggleToolButtonPrivateStruct creates an uninitialised ToggleToolButtonPrivate.
func ToggleToolButtonPrivateStruct() *ToggleToolButtonPrivate {
	err := toggleToolButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToggleToolButtonPrivateNewFromNative(toggleToolButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToggleToolButtonPrivate)
	return structGo
}
func finalizeToggleToolButtonPrivate(obj *ToggleToolButtonPrivate) {
	toggleToolButtonPrivateStruct.Free(obj.Native())
}

var toolButtonClassStruct *gi.Struct
var toolButtonClassStruct_Once sync.Once

func toolButtonClassStruct_Set() error {
	var err error
	toolButtonClassStruct_Once.Do(func() {
		toolButtonClassStruct, err = gi.StructNew("Gtk", "ToolButtonClass")
	})
	return err
}

type ToolButtonClass struct {
	native unsafe.Pointer
}

func ToolButtonClassNewFromNative(native unsafe.Pointer) *ToolButtonClass {
	err := toolButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolButtonClass{native: native}

	return instance
}

/*
CastToToolButtonClass down casts any arbitrary Object to ToolButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolButtonClass.
*/
func CastToToolButtonClass(object *gobject.Object) *ToolButtonClass {
	return ToolButtonClassNewFromNative(object.Native())
}

// Equals compares this ToolButtonClass with another ToolButtonClass, and returns true if they represent the same Object.
func (recv *ToolButtonClass) Equals(other *ToolButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToolButtonClass) FieldParentClass() *ToolItemClass {
	argValue := gi.StructFieldGet(toolButtonClassStruct, recv.Native(), "parent_class")
	value := ToolItemClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToolButtonClass) SetFieldParentClass(value *ToolItemClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toolButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// FieldButtonType returns the C field 'button_type'.
func (recv *ToolButtonClass) FieldButtonType() int64 {
	argValue := gi.StructFieldGet(toolButtonClassStruct, recv.Native(), "button_type")
	value := argValue.Int64()
	return value
}

// SetFieldButtonType sets the value of the C field 'button_type'.
func (recv *ToolButtonClass) SetFieldButtonType(value int64) {
	var argValue gi.Argument
	argValue.SetInt64(value)
	gi.StructFieldSet(toolButtonClassStruct, recv.Native(), "button_type", argValue)
}

// UNSUPPORTED : C value 'clicked' : for field getter : missing Type

// UNSUPPORTED : C value 'clicked' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ToolButtonClassStruct creates an uninitialised ToolButtonClass.
func ToolButtonClassStruct() *ToolButtonClass {
	err := toolButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolButtonClassNewFromNative(toolButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolButtonClass)
	return structGo
}
func finalizeToolButtonClass(obj *ToolButtonClass) {
	toolButtonClassStruct.Free(obj.Native())
}

var toolButtonPrivateStruct *gi.Struct
var toolButtonPrivateStruct_Once sync.Once

func toolButtonPrivateStruct_Set() error {
	var err error
	toolButtonPrivateStruct_Once.Do(func() {
		toolButtonPrivateStruct, err = gi.StructNew("Gtk", "ToolButtonPrivate")
	})
	return err
}

type ToolButtonPrivate struct {
	native unsafe.Pointer
}

func ToolButtonPrivateNewFromNative(native unsafe.Pointer) *ToolButtonPrivate {
	err := toolButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolButtonPrivate{native: native}

	return instance
}

/*
CastToToolButtonPrivate down casts any arbitrary Object to ToolButtonPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolButtonPrivate.
*/
func CastToToolButtonPrivate(object *gobject.Object) *ToolButtonPrivate {
	return ToolButtonPrivateNewFromNative(object.Native())
}

// Equals compares this ToolButtonPrivate with another ToolButtonPrivate, and returns true if they represent the same Object.
func (recv *ToolButtonPrivate) Equals(other *ToolButtonPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolButtonPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToolButtonPrivateStruct creates an uninitialised ToolButtonPrivate.
func ToolButtonPrivateStruct() *ToolButtonPrivate {
	err := toolButtonPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolButtonPrivateNewFromNative(toolButtonPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolButtonPrivate)
	return structGo
}
func finalizeToolButtonPrivate(obj *ToolButtonPrivate) {
	toolButtonPrivateStruct.Free(obj.Native())
}

var toolItemClassStruct *gi.Struct
var toolItemClassStruct_Once sync.Once

func toolItemClassStruct_Set() error {
	var err error
	toolItemClassStruct_Once.Do(func() {
		toolItemClassStruct, err = gi.StructNew("Gtk", "ToolItemClass")
	})
	return err
}

type ToolItemClass struct {
	native unsafe.Pointer
}

func ToolItemClassNewFromNative(native unsafe.Pointer) *ToolItemClass {
	err := toolItemClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolItemClass{native: native}

	return instance
}

/*
CastToToolItemClass down casts any arbitrary Object to ToolItemClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolItemClass.
*/
func CastToToolItemClass(object *gobject.Object) *ToolItemClass {
	return ToolItemClassNewFromNative(object.Native())
}

// Equals compares this ToolItemClass with another ToolItemClass, and returns true if they represent the same Object.
func (recv *ToolItemClass) Equals(other *ToolItemClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolItemClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToolItemClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(toolItemClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToolItemClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toolItemClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'create_menu_proxy' : for field getter : missing Type

// UNSUPPORTED : C value 'create_menu_proxy' : for field setter : missing Type

// UNSUPPORTED : C value 'toolbar_reconfigured' : for field getter : missing Type

// UNSUPPORTED : C value 'toolbar_reconfigured' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ToolItemClassStruct creates an uninitialised ToolItemClass.
func ToolItemClassStruct() *ToolItemClass {
	err := toolItemClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolItemClassNewFromNative(toolItemClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolItemClass)
	return structGo
}
func finalizeToolItemClass(obj *ToolItemClass) {
	toolItemClassStruct.Free(obj.Native())
}

var toolItemGroupClassStruct *gi.Struct
var toolItemGroupClassStruct_Once sync.Once

func toolItemGroupClassStruct_Set() error {
	var err error
	toolItemGroupClassStruct_Once.Do(func() {
		toolItemGroupClassStruct, err = gi.StructNew("Gtk", "ToolItemGroupClass")
	})
	return err
}

type ToolItemGroupClass struct {
	native unsafe.Pointer
}

func ToolItemGroupClassNewFromNative(native unsafe.Pointer) *ToolItemGroupClass {
	err := toolItemGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolItemGroupClass{native: native}

	return instance
}

/*
CastToToolItemGroupClass down casts any arbitrary Object to ToolItemGroupClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolItemGroupClass.
*/
func CastToToolItemGroupClass(object *gobject.Object) *ToolItemGroupClass {
	return ToolItemGroupClassNewFromNative(object.Native())
}

// Equals compares this ToolItemGroupClass with another ToolItemGroupClass, and returns true if they represent the same Object.
func (recv *ToolItemGroupClass) Equals(other *ToolItemGroupClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolItemGroupClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToolItemGroupClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(toolItemGroupClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToolItemGroupClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toolItemGroupClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ToolItemGroupClassStruct creates an uninitialised ToolItemGroupClass.
func ToolItemGroupClassStruct() *ToolItemGroupClass {
	err := toolItemGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolItemGroupClassNewFromNative(toolItemGroupClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolItemGroupClass)
	return structGo
}
func finalizeToolItemGroupClass(obj *ToolItemGroupClass) {
	toolItemGroupClassStruct.Free(obj.Native())
}

var toolItemGroupPrivateStruct *gi.Struct
var toolItemGroupPrivateStruct_Once sync.Once

func toolItemGroupPrivateStruct_Set() error {
	var err error
	toolItemGroupPrivateStruct_Once.Do(func() {
		toolItemGroupPrivateStruct, err = gi.StructNew("Gtk", "ToolItemGroupPrivate")
	})
	return err
}

type ToolItemGroupPrivate struct {
	native unsafe.Pointer
}

func ToolItemGroupPrivateNewFromNative(native unsafe.Pointer) *ToolItemGroupPrivate {
	err := toolItemGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolItemGroupPrivate{native: native}

	return instance
}

/*
CastToToolItemGroupPrivate down casts any arbitrary Object to ToolItemGroupPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolItemGroupPrivate.
*/
func CastToToolItemGroupPrivate(object *gobject.Object) *ToolItemGroupPrivate {
	return ToolItemGroupPrivateNewFromNative(object.Native())
}

// Equals compares this ToolItemGroupPrivate with another ToolItemGroupPrivate, and returns true if they represent the same Object.
func (recv *ToolItemGroupPrivate) Equals(other *ToolItemGroupPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolItemGroupPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToolItemGroupPrivateStruct creates an uninitialised ToolItemGroupPrivate.
func ToolItemGroupPrivateStruct() *ToolItemGroupPrivate {
	err := toolItemGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolItemGroupPrivateNewFromNative(toolItemGroupPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolItemGroupPrivate)
	return structGo
}
func finalizeToolItemGroupPrivate(obj *ToolItemGroupPrivate) {
	toolItemGroupPrivateStruct.Free(obj.Native())
}

var toolItemPrivateStruct *gi.Struct
var toolItemPrivateStruct_Once sync.Once

func toolItemPrivateStruct_Set() error {
	var err error
	toolItemPrivateStruct_Once.Do(func() {
		toolItemPrivateStruct, err = gi.StructNew("Gtk", "ToolItemPrivate")
	})
	return err
}

type ToolItemPrivate struct {
	native unsafe.Pointer
}

func ToolItemPrivateNewFromNative(native unsafe.Pointer) *ToolItemPrivate {
	err := toolItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolItemPrivate{native: native}

	return instance
}

/*
CastToToolItemPrivate down casts any arbitrary Object to ToolItemPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolItemPrivate.
*/
func CastToToolItemPrivate(object *gobject.Object) *ToolItemPrivate {
	return ToolItemPrivateNewFromNative(object.Native())
}

// Equals compares this ToolItemPrivate with another ToolItemPrivate, and returns true if they represent the same Object.
func (recv *ToolItemPrivate) Equals(other *ToolItemPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolItemPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToolItemPrivateStruct creates an uninitialised ToolItemPrivate.
func ToolItemPrivateStruct() *ToolItemPrivate {
	err := toolItemPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolItemPrivateNewFromNative(toolItemPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolItemPrivate)
	return structGo
}
func finalizeToolItemPrivate(obj *ToolItemPrivate) {
	toolItemPrivateStruct.Free(obj.Native())
}

var toolPaletteClassStruct *gi.Struct
var toolPaletteClassStruct_Once sync.Once

func toolPaletteClassStruct_Set() error {
	var err error
	toolPaletteClassStruct_Once.Do(func() {
		toolPaletteClassStruct, err = gi.StructNew("Gtk", "ToolPaletteClass")
	})
	return err
}

type ToolPaletteClass struct {
	native unsafe.Pointer
}

func ToolPaletteClassNewFromNative(native unsafe.Pointer) *ToolPaletteClass {
	err := toolPaletteClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolPaletteClass{native: native}

	return instance
}

/*
CastToToolPaletteClass down casts any arbitrary Object to ToolPaletteClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolPaletteClass.
*/
func CastToToolPaletteClass(object *gobject.Object) *ToolPaletteClass {
	return ToolPaletteClassNewFromNative(object.Native())
}

// Equals compares this ToolPaletteClass with another ToolPaletteClass, and returns true if they represent the same Object.
func (recv *ToolPaletteClass) Equals(other *ToolPaletteClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolPaletteClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToolPaletteClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(toolPaletteClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToolPaletteClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toolPaletteClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ToolPaletteClassStruct creates an uninitialised ToolPaletteClass.
func ToolPaletteClassStruct() *ToolPaletteClass {
	err := toolPaletteClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolPaletteClassNewFromNative(toolPaletteClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolPaletteClass)
	return structGo
}
func finalizeToolPaletteClass(obj *ToolPaletteClass) {
	toolPaletteClassStruct.Free(obj.Native())
}

var toolPalettePrivateStruct *gi.Struct
var toolPalettePrivateStruct_Once sync.Once

func toolPalettePrivateStruct_Set() error {
	var err error
	toolPalettePrivateStruct_Once.Do(func() {
		toolPalettePrivateStruct, err = gi.StructNew("Gtk", "ToolPalettePrivate")
	})
	return err
}

type ToolPalettePrivate struct {
	native unsafe.Pointer
}

func ToolPalettePrivateNewFromNative(native unsafe.Pointer) *ToolPalettePrivate {
	err := toolPalettePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolPalettePrivate{native: native}

	return instance
}

/*
CastToToolPalettePrivate down casts any arbitrary Object to ToolPalettePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolPalettePrivate.
*/
func CastToToolPalettePrivate(object *gobject.Object) *ToolPalettePrivate {
	return ToolPalettePrivateNewFromNative(object.Native())
}

// Equals compares this ToolPalettePrivate with another ToolPalettePrivate, and returns true if they represent the same Object.
func (recv *ToolPalettePrivate) Equals(other *ToolPalettePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolPalettePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToolPalettePrivateStruct creates an uninitialised ToolPalettePrivate.
func ToolPalettePrivateStruct() *ToolPalettePrivate {
	err := toolPalettePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolPalettePrivateNewFromNative(toolPalettePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolPalettePrivate)
	return structGo
}
func finalizeToolPalettePrivate(obj *ToolPalettePrivate) {
	toolPalettePrivateStruct.Free(obj.Native())
}

var toolShellIfaceStruct *gi.Struct
var toolShellIfaceStruct_Once sync.Once

func toolShellIfaceStruct_Set() error {
	var err error
	toolShellIfaceStruct_Once.Do(func() {
		toolShellIfaceStruct, err = gi.StructNew("Gtk", "ToolShellIface")
	})
	return err
}

type ToolShellIface struct {
	native unsafe.Pointer
}

func ToolShellIfaceNewFromNative(native unsafe.Pointer) *ToolShellIface {
	err := toolShellIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolShellIface{native: native}

	return instance
}

/*
CastToToolShellIface down casts any arbitrary Object to ToolShellIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolShellIface.
*/
func CastToToolShellIface(object *gobject.Object) *ToolShellIface {
	return ToolShellIfaceNewFromNative(object.Native())
}

// Equals compares this ToolShellIface with another ToolShellIface, and returns true if they represent the same Object.
func (recv *ToolShellIface) Equals(other *ToolShellIface) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolShellIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'get_icon_size' : for field getter : missing Type

// UNSUPPORTED : C value 'get_icon_size' : for field setter : missing Type

// UNSUPPORTED : C value 'get_orientation' : for field getter : missing Type

// UNSUPPORTED : C value 'get_orientation' : for field setter : missing Type

// UNSUPPORTED : C value 'get_style' : for field getter : missing Type

// UNSUPPORTED : C value 'get_style' : for field setter : missing Type

// UNSUPPORTED : C value 'get_relief_style' : for field getter : missing Type

// UNSUPPORTED : C value 'get_relief_style' : for field setter : missing Type

// UNSUPPORTED : C value 'rebuild_menu' : for field getter : missing Type

// UNSUPPORTED : C value 'rebuild_menu' : for field setter : missing Type

// UNSUPPORTED : C value 'get_text_orientation' : for field getter : missing Type

// UNSUPPORTED : C value 'get_text_orientation' : for field setter : missing Type

// UNSUPPORTED : C value 'get_text_alignment' : for field getter : missing Type

// UNSUPPORTED : C value 'get_text_alignment' : for field setter : missing Type

// UNSUPPORTED : C value 'get_ellipsize_mode' : for field getter : missing Type

// UNSUPPORTED : C value 'get_ellipsize_mode' : for field setter : missing Type

// UNSUPPORTED : C value 'get_text_size_group' : for field getter : missing Type

// UNSUPPORTED : C value 'get_text_size_group' : for field setter : missing Type

// ToolShellIfaceStruct creates an uninitialised ToolShellIface.
func ToolShellIfaceStruct() *ToolShellIface {
	err := toolShellIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolShellIfaceNewFromNative(toolShellIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolShellIface)
	return structGo
}
func finalizeToolShellIface(obj *ToolShellIface) {
	toolShellIfaceStruct.Free(obj.Native())
}

var toolbarClassStruct *gi.Struct
var toolbarClassStruct_Once sync.Once

func toolbarClassStruct_Set() error {
	var err error
	toolbarClassStruct_Once.Do(func() {
		toolbarClassStruct, err = gi.StructNew("Gtk", "ToolbarClass")
	})
	return err
}

type ToolbarClass struct {
	native unsafe.Pointer
}

func ToolbarClassNewFromNative(native unsafe.Pointer) *ToolbarClass {
	err := toolbarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolbarClass{native: native}

	return instance
}

/*
CastToToolbarClass down casts any arbitrary Object to ToolbarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolbarClass.
*/
func CastToToolbarClass(object *gobject.Object) *ToolbarClass {
	return ToolbarClassNewFromNative(object.Native())
}

// Equals compares this ToolbarClass with another ToolbarClass, and returns true if they represent the same Object.
func (recv *ToolbarClass) Equals(other *ToolbarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolbarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToolbarClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(toolbarClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToolbarClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toolbarClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'orientation_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'orientation_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'style_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'style_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'popup_context_menu' : for field getter : missing Type

// UNSUPPORTED : C value 'popup_context_menu' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ToolbarClassStruct creates an uninitialised ToolbarClass.
func ToolbarClassStruct() *ToolbarClass {
	err := toolbarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolbarClassNewFromNative(toolbarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolbarClass)
	return structGo
}
func finalizeToolbarClass(obj *ToolbarClass) {
	toolbarClassStruct.Free(obj.Native())
}

var toolbarPrivateStruct *gi.Struct
var toolbarPrivateStruct_Once sync.Once

func toolbarPrivateStruct_Set() error {
	var err error
	toolbarPrivateStruct_Once.Do(func() {
		toolbarPrivateStruct, err = gi.StructNew("Gtk", "ToolbarPrivate")
	})
	return err
}

type ToolbarPrivate struct {
	native unsafe.Pointer
}

func ToolbarPrivateNewFromNative(native unsafe.Pointer) *ToolbarPrivate {
	err := toolbarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToolbarPrivate{native: native}

	return instance
}

/*
CastToToolbarPrivate down casts any arbitrary Object to ToolbarPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToolbarPrivate.
*/
func CastToToolbarPrivate(object *gobject.Object) *ToolbarPrivate {
	return ToolbarPrivateNewFromNative(object.Native())
}

// Equals compares this ToolbarPrivate with another ToolbarPrivate, and returns true if they represent the same Object.
func (recv *ToolbarPrivate) Equals(other *ToolbarPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToolbarPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToolbarPrivateStruct creates an uninitialised ToolbarPrivate.
func ToolbarPrivateStruct() *ToolbarPrivate {
	err := toolbarPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToolbarPrivateNewFromNative(toolbarPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToolbarPrivate)
	return structGo
}
func finalizeToolbarPrivate(obj *ToolbarPrivate) {
	toolbarPrivateStruct.Free(obj.Native())
}

var toplevelAccessibleClassStruct *gi.Struct
var toplevelAccessibleClassStruct_Once sync.Once

func toplevelAccessibleClassStruct_Set() error {
	var err error
	toplevelAccessibleClassStruct_Once.Do(func() {
		toplevelAccessibleClassStruct, err = gi.StructNew("Gtk", "ToplevelAccessibleClass")
	})
	return err
}

type ToplevelAccessibleClass struct {
	native unsafe.Pointer
}

func ToplevelAccessibleClassNewFromNative(native unsafe.Pointer) *ToplevelAccessibleClass {
	err := toplevelAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToplevelAccessibleClass{native: native}

	return instance
}

/*
CastToToplevelAccessibleClass down casts any arbitrary Object to ToplevelAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToplevelAccessibleClass.
*/
func CastToToplevelAccessibleClass(object *gobject.Object) *ToplevelAccessibleClass {
	return ToplevelAccessibleClassNewFromNative(object.Native())
}

// Equals compares this ToplevelAccessibleClass with another ToplevelAccessibleClass, and returns true if they represent the same Object.
func (recv *ToplevelAccessibleClass) Equals(other *ToplevelAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ToplevelAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ToplevelAccessibleClass) FieldParentClass() *atk.ObjectClass {
	argValue := gi.StructFieldGet(toplevelAccessibleClassStruct, recv.Native(), "parent_class")
	value := atk.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ToplevelAccessibleClass) SetFieldParentClass(value *atk.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(toplevelAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// ToplevelAccessibleClassStruct creates an uninitialised ToplevelAccessibleClass.
func ToplevelAccessibleClassStruct() *ToplevelAccessibleClass {
	err := toplevelAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToplevelAccessibleClassNewFromNative(toplevelAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToplevelAccessibleClass)
	return structGo
}
func finalizeToplevelAccessibleClass(obj *ToplevelAccessibleClass) {
	toplevelAccessibleClassStruct.Free(obj.Native())
}

var toplevelAccessiblePrivateStruct *gi.Struct
var toplevelAccessiblePrivateStruct_Once sync.Once

func toplevelAccessiblePrivateStruct_Set() error {
	var err error
	toplevelAccessiblePrivateStruct_Once.Do(func() {
		toplevelAccessiblePrivateStruct, err = gi.StructNew("Gtk", "ToplevelAccessiblePrivate")
	})
	return err
}

type ToplevelAccessiblePrivate struct {
	native unsafe.Pointer
}

func ToplevelAccessiblePrivateNewFromNative(native unsafe.Pointer) *ToplevelAccessiblePrivate {
	err := toplevelAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ToplevelAccessiblePrivate{native: native}

	return instance
}

/*
CastToToplevelAccessiblePrivate down casts any arbitrary Object to ToplevelAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ToplevelAccessiblePrivate.
*/
func CastToToplevelAccessiblePrivate(object *gobject.Object) *ToplevelAccessiblePrivate {
	return ToplevelAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this ToplevelAccessiblePrivate with another ToplevelAccessiblePrivate, and returns true if they represent the same Object.
func (recv *ToplevelAccessiblePrivate) Equals(other *ToplevelAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ToplevelAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// ToplevelAccessiblePrivateStruct creates an uninitialised ToplevelAccessiblePrivate.
func ToplevelAccessiblePrivateStruct() *ToplevelAccessiblePrivate {
	err := toplevelAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ToplevelAccessiblePrivateNewFromNative(toplevelAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeToplevelAccessiblePrivate)
	return structGo
}
func finalizeToplevelAccessiblePrivate(obj *ToplevelAccessiblePrivate) {
	toplevelAccessiblePrivateStruct.Free(obj.Native())
}

var treeDragDestIfaceStruct *gi.Struct
var treeDragDestIfaceStruct_Once sync.Once

func treeDragDestIfaceStruct_Set() error {
	var err error
	treeDragDestIfaceStruct_Once.Do(func() {
		treeDragDestIfaceStruct, err = gi.StructNew("Gtk", "TreeDragDestIface")
	})
	return err
}

type TreeDragDestIface struct {
	native unsafe.Pointer
}

func TreeDragDestIfaceNewFromNative(native unsafe.Pointer) *TreeDragDestIface {
	err := treeDragDestIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeDragDestIface{native: native}

	return instance
}

/*
CastToTreeDragDestIface down casts any arbitrary Object to TreeDragDestIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeDragDestIface.
*/
func CastToTreeDragDestIface(object *gobject.Object) *TreeDragDestIface {
	return TreeDragDestIfaceNewFromNative(object.Native())
}

// Equals compares this TreeDragDestIface with another TreeDragDestIface, and returns true if they represent the same Object.
func (recv *TreeDragDestIface) Equals(other *TreeDragDestIface) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeDragDestIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'drag_data_received' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_data_received' : for field setter : missing Type

// UNSUPPORTED : C value 'row_drop_possible' : for field getter : missing Type

// UNSUPPORTED : C value 'row_drop_possible' : for field setter : missing Type

// TreeDragDestIfaceStruct creates an uninitialised TreeDragDestIface.
func TreeDragDestIfaceStruct() *TreeDragDestIface {
	err := treeDragDestIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeDragDestIfaceNewFromNative(treeDragDestIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeDragDestIface)
	return structGo
}
func finalizeTreeDragDestIface(obj *TreeDragDestIface) {
	treeDragDestIfaceStruct.Free(obj.Native())
}

var treeDragSourceIfaceStruct *gi.Struct
var treeDragSourceIfaceStruct_Once sync.Once

func treeDragSourceIfaceStruct_Set() error {
	var err error
	treeDragSourceIfaceStruct_Once.Do(func() {
		treeDragSourceIfaceStruct, err = gi.StructNew("Gtk", "TreeDragSourceIface")
	})
	return err
}

type TreeDragSourceIface struct {
	native unsafe.Pointer
}

func TreeDragSourceIfaceNewFromNative(native unsafe.Pointer) *TreeDragSourceIface {
	err := treeDragSourceIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeDragSourceIface{native: native}

	return instance
}

/*
CastToTreeDragSourceIface down casts any arbitrary Object to TreeDragSourceIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeDragSourceIface.
*/
func CastToTreeDragSourceIface(object *gobject.Object) *TreeDragSourceIface {
	return TreeDragSourceIfaceNewFromNative(object.Native())
}

// Equals compares this TreeDragSourceIface with another TreeDragSourceIface, and returns true if they represent the same Object.
func (recv *TreeDragSourceIface) Equals(other *TreeDragSourceIface) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeDragSourceIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'row_draggable' : for field getter : missing Type

// UNSUPPORTED : C value 'row_draggable' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_data_get' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_data_get' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_data_delete' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_data_delete' : for field setter : missing Type

// TreeDragSourceIfaceStruct creates an uninitialised TreeDragSourceIface.
func TreeDragSourceIfaceStruct() *TreeDragSourceIface {
	err := treeDragSourceIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeDragSourceIfaceNewFromNative(treeDragSourceIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeDragSourceIface)
	return structGo
}
func finalizeTreeDragSourceIface(obj *TreeDragSourceIface) {
	treeDragSourceIfaceStruct.Free(obj.Native())
}

var treeIterStruct *gi.Struct
var treeIterStruct_Once sync.Once

func treeIterStruct_Set() error {
	var err error
	treeIterStruct_Once.Do(func() {
		treeIterStruct, err = gi.StructNew("Gtk", "TreeIter")
	})
	return err
}

type TreeIter struct {
	native unsafe.Pointer
}

func TreeIterNewFromNative(native unsafe.Pointer) *TreeIter {
	err := treeIterStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeIter{native: native}

	return instance
}

/*
CastToTreeIter down casts any arbitrary Object to TreeIter.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeIter.
*/
func CastToTreeIter(object *gobject.Object) *TreeIter {
	return TreeIterNewFromNative(object.Native())
}

// Equals compares this TreeIter with another TreeIter, and returns true if they represent the same Object.
func (recv *TreeIter) Equals(other *TreeIter) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeIter) Native() unsafe.Pointer {
	return recv.native
}

// FieldStamp returns the C field 'stamp'.
func (recv *TreeIter) FieldStamp() int32 {
	argValue := gi.StructFieldGet(treeIterStruct, recv.Native(), "stamp")
	value := argValue.Int32()
	return value
}

// SetFieldStamp sets the value of the C field 'stamp'.
func (recv *TreeIter) SetFieldStamp(value int32) {
	var argValue gi.Argument
	argValue.SetInt32(value)
	gi.StructFieldSet(treeIterStruct, recv.Native(), "stamp", argValue)
}

// FieldUserData returns the C field 'user_data'.
func (recv *TreeIter) FieldUserData() unsafe.Pointer {
	argValue := gi.StructFieldGet(treeIterStruct, recv.Native(), "user_data")
	value := argValue.Pointer()
	return value
}

// SetFieldUserData sets the value of the C field 'user_data'.
func (recv *TreeIter) SetFieldUserData(value unsafe.Pointer) {
	var argValue gi.Argument
	argValue.SetPointer(value)
	gi.StructFieldSet(treeIterStruct, recv.Native(), "user_data", argValue)
}

// FieldUserData2 returns the C field 'user_data2'.
func (recv *TreeIter) FieldUserData2() unsafe.Pointer {
	argValue := gi.StructFieldGet(treeIterStruct, recv.Native(), "user_data2")
	value := argValue.Pointer()
	return value
}

// SetFieldUserData2 sets the value of the C field 'user_data2'.
func (recv *TreeIter) SetFieldUserData2(value unsafe.Pointer) {
	var argValue gi.Argument
	argValue.SetPointer(value)
	gi.StructFieldSet(treeIterStruct, recv.Native(), "user_data2", argValue)
}

// FieldUserData3 returns the C field 'user_data3'.
func (recv *TreeIter) FieldUserData3() unsafe.Pointer {
	argValue := gi.StructFieldGet(treeIterStruct, recv.Native(), "user_data3")
	value := argValue.Pointer()
	return value
}

// SetFieldUserData3 sets the value of the C field 'user_data3'.
func (recv *TreeIter) SetFieldUserData3(value unsafe.Pointer) {
	var argValue gi.Argument
	argValue.SetPointer(value)
	gi.StructFieldSet(treeIterStruct, recv.Native(), "user_data3", argValue)
}

var treeIterCopyFunction *gi.Function
var treeIterCopyFunction_Once sync.Once

func treeIterCopyFunction_Set() error {
	var err error
	treeIterCopyFunction_Once.Do(func() {
		err = treeIterStruct_Set()
		if err != nil {
			return
		}
		treeIterCopyFunction, err = treeIterStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_tree_iter_copy.
func (recv *TreeIter) Copy() *TreeIter {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treeIterCopyFunction_Set()
	if err == nil {
		ret = treeIterCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := TreeIterNewFromNative(ret.Pointer())

	return retGo
}

var treeIterFreeFunction *gi.Function
var treeIterFreeFunction_Once sync.Once

func treeIterFreeFunction_Set() error {
	var err error
	treeIterFreeFunction_Once.Do(func() {
		err = treeIterStruct_Set()
		if err != nil {
			return
		}
		treeIterFreeFunction, err = treeIterStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_tree_iter_free.
func (recv *TreeIter) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := treeIterFreeFunction_Set()
	if err == nil {
		treeIterFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

// TreeIterStruct creates an uninitialised TreeIter.
func TreeIterStruct() *TreeIter {
	err := treeIterStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeIterNewFromNative(treeIterStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeIter)
	return structGo
}
func finalizeTreeIter(obj *TreeIter) {
	treeIterStruct.Free(obj.Native())
}

var treeModelFilterClassStruct *gi.Struct
var treeModelFilterClassStruct_Once sync.Once

func treeModelFilterClassStruct_Set() error {
	var err error
	treeModelFilterClassStruct_Once.Do(func() {
		treeModelFilterClassStruct, err = gi.StructNew("Gtk", "TreeModelFilterClass")
	})
	return err
}

type TreeModelFilterClass struct {
	native unsafe.Pointer
}

func TreeModelFilterClassNewFromNative(native unsafe.Pointer) *TreeModelFilterClass {
	err := treeModelFilterClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeModelFilterClass{native: native}

	return instance
}

/*
CastToTreeModelFilterClass down casts any arbitrary Object to TreeModelFilterClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeModelFilterClass.
*/
func CastToTreeModelFilterClass(object *gobject.Object) *TreeModelFilterClass {
	return TreeModelFilterClassNewFromNative(object.Native())
}

// Equals compares this TreeModelFilterClass with another TreeModelFilterClass, and returns true if they represent the same Object.
func (recv *TreeModelFilterClass) Equals(other *TreeModelFilterClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeModelFilterClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TreeModelFilterClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(treeModelFilterClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TreeModelFilterClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(treeModelFilterClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'visible' : for field getter : missing Type

// UNSUPPORTED : C value 'visible' : for field setter : missing Type

// UNSUPPORTED : C value 'modify' : for field getter : missing Type

// UNSUPPORTED : C value 'modify' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TreeModelFilterClassStruct creates an uninitialised TreeModelFilterClass.
func TreeModelFilterClassStruct() *TreeModelFilterClass {
	err := treeModelFilterClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeModelFilterClassNewFromNative(treeModelFilterClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeModelFilterClass)
	return structGo
}
func finalizeTreeModelFilterClass(obj *TreeModelFilterClass) {
	treeModelFilterClassStruct.Free(obj.Native())
}

var treeModelFilterPrivateStruct *gi.Struct
var treeModelFilterPrivateStruct_Once sync.Once

func treeModelFilterPrivateStruct_Set() error {
	var err error
	treeModelFilterPrivateStruct_Once.Do(func() {
		treeModelFilterPrivateStruct, err = gi.StructNew("Gtk", "TreeModelFilterPrivate")
	})
	return err
}

type TreeModelFilterPrivate struct {
	native unsafe.Pointer
}

func TreeModelFilterPrivateNewFromNative(native unsafe.Pointer) *TreeModelFilterPrivate {
	err := treeModelFilterPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeModelFilterPrivate{native: native}

	return instance
}

/*
CastToTreeModelFilterPrivate down casts any arbitrary Object to TreeModelFilterPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeModelFilterPrivate.
*/
func CastToTreeModelFilterPrivate(object *gobject.Object) *TreeModelFilterPrivate {
	return TreeModelFilterPrivateNewFromNative(object.Native())
}

// Equals compares this TreeModelFilterPrivate with another TreeModelFilterPrivate, and returns true if they represent the same Object.
func (recv *TreeModelFilterPrivate) Equals(other *TreeModelFilterPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeModelFilterPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TreeModelFilterPrivateStruct creates an uninitialised TreeModelFilterPrivate.
func TreeModelFilterPrivateStruct() *TreeModelFilterPrivate {
	err := treeModelFilterPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeModelFilterPrivateNewFromNative(treeModelFilterPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeModelFilterPrivate)
	return structGo
}
func finalizeTreeModelFilterPrivate(obj *TreeModelFilterPrivate) {
	treeModelFilterPrivateStruct.Free(obj.Native())
}

var treeModelIfaceStruct *gi.Struct
var treeModelIfaceStruct_Once sync.Once

func treeModelIfaceStruct_Set() error {
	var err error
	treeModelIfaceStruct_Once.Do(func() {
		treeModelIfaceStruct, err = gi.StructNew("Gtk", "TreeModelIface")
	})
	return err
}

type TreeModelIface struct {
	native unsafe.Pointer
}

func TreeModelIfaceNewFromNative(native unsafe.Pointer) *TreeModelIface {
	err := treeModelIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeModelIface{native: native}

	return instance
}

/*
CastToTreeModelIface down casts any arbitrary Object to TreeModelIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeModelIface.
*/
func CastToTreeModelIface(object *gobject.Object) *TreeModelIface {
	return TreeModelIfaceNewFromNative(object.Native())
}

// Equals compares this TreeModelIface with another TreeModelIface, and returns true if they represent the same Object.
func (recv *TreeModelIface) Equals(other *TreeModelIface) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeModelIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'row_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'row_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'row_inserted' : for field getter : missing Type

// UNSUPPORTED : C value 'row_inserted' : for field setter : missing Type

// UNSUPPORTED : C value 'row_has_child_toggled' : for field getter : missing Type

// UNSUPPORTED : C value 'row_has_child_toggled' : for field setter : missing Type

// UNSUPPORTED : C value 'row_deleted' : for field getter : missing Type

// UNSUPPORTED : C value 'row_deleted' : for field setter : missing Type

// UNSUPPORTED : C value 'rows_reordered' : for field getter : missing Type

// UNSUPPORTED : C value 'rows_reordered' : for field setter : missing Type

// UNSUPPORTED : C value 'get_flags' : for field getter : missing Type

// UNSUPPORTED : C value 'get_flags' : for field setter : missing Type

// UNSUPPORTED : C value 'get_n_columns' : for field getter : missing Type

// UNSUPPORTED : C value 'get_n_columns' : for field setter : missing Type

// UNSUPPORTED : C value 'get_column_type' : for field getter : missing Type

// UNSUPPORTED : C value 'get_column_type' : for field setter : missing Type

// UNSUPPORTED : C value 'get_iter' : for field getter : missing Type

// UNSUPPORTED : C value 'get_iter' : for field setter : missing Type

// UNSUPPORTED : C value 'get_path' : for field getter : missing Type

// UNSUPPORTED : C value 'get_path' : for field setter : missing Type

// UNSUPPORTED : C value 'get_value' : for field getter : missing Type

// UNSUPPORTED : C value 'get_value' : for field setter : missing Type

// UNSUPPORTED : C value 'iter_next' : for field getter : missing Type

// UNSUPPORTED : C value 'iter_next' : for field setter : missing Type

// UNSUPPORTED : C value 'iter_previous' : for field getter : missing Type

// UNSUPPORTED : C value 'iter_previous' : for field setter : missing Type

// UNSUPPORTED : C value 'iter_children' : for field getter : missing Type

// UNSUPPORTED : C value 'iter_children' : for field setter : missing Type

// UNSUPPORTED : C value 'iter_has_child' : for field getter : missing Type

// UNSUPPORTED : C value 'iter_has_child' : for field setter : missing Type

// UNSUPPORTED : C value 'iter_n_children' : for field getter : missing Type

// UNSUPPORTED : C value 'iter_n_children' : for field setter : missing Type

// UNSUPPORTED : C value 'iter_nth_child' : for field getter : missing Type

// UNSUPPORTED : C value 'iter_nth_child' : for field setter : missing Type

// UNSUPPORTED : C value 'iter_parent' : for field getter : missing Type

// UNSUPPORTED : C value 'iter_parent' : for field setter : missing Type

// UNSUPPORTED : C value 'ref_node' : for field getter : missing Type

// UNSUPPORTED : C value 'ref_node' : for field setter : missing Type

// UNSUPPORTED : C value 'unref_node' : for field getter : missing Type

// UNSUPPORTED : C value 'unref_node' : for field setter : missing Type

// TreeModelIfaceStruct creates an uninitialised TreeModelIface.
func TreeModelIfaceStruct() *TreeModelIface {
	err := treeModelIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeModelIfaceNewFromNative(treeModelIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeModelIface)
	return structGo
}
func finalizeTreeModelIface(obj *TreeModelIface) {
	treeModelIfaceStruct.Free(obj.Native())
}

var treeModelSortClassStruct *gi.Struct
var treeModelSortClassStruct_Once sync.Once

func treeModelSortClassStruct_Set() error {
	var err error
	treeModelSortClassStruct_Once.Do(func() {
		treeModelSortClassStruct, err = gi.StructNew("Gtk", "TreeModelSortClass")
	})
	return err
}

type TreeModelSortClass struct {
	native unsafe.Pointer
}

func TreeModelSortClassNewFromNative(native unsafe.Pointer) *TreeModelSortClass {
	err := treeModelSortClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeModelSortClass{native: native}

	return instance
}

/*
CastToTreeModelSortClass down casts any arbitrary Object to TreeModelSortClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeModelSortClass.
*/
func CastToTreeModelSortClass(object *gobject.Object) *TreeModelSortClass {
	return TreeModelSortClassNewFromNative(object.Native())
}

// Equals compares this TreeModelSortClass with another TreeModelSortClass, and returns true if they represent the same Object.
func (recv *TreeModelSortClass) Equals(other *TreeModelSortClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeModelSortClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TreeModelSortClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(treeModelSortClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TreeModelSortClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(treeModelSortClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TreeModelSortClassStruct creates an uninitialised TreeModelSortClass.
func TreeModelSortClassStruct() *TreeModelSortClass {
	err := treeModelSortClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeModelSortClassNewFromNative(treeModelSortClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeModelSortClass)
	return structGo
}
func finalizeTreeModelSortClass(obj *TreeModelSortClass) {
	treeModelSortClassStruct.Free(obj.Native())
}

var treeModelSortPrivateStruct *gi.Struct
var treeModelSortPrivateStruct_Once sync.Once

func treeModelSortPrivateStruct_Set() error {
	var err error
	treeModelSortPrivateStruct_Once.Do(func() {
		treeModelSortPrivateStruct, err = gi.StructNew("Gtk", "TreeModelSortPrivate")
	})
	return err
}

type TreeModelSortPrivate struct {
	native unsafe.Pointer
}

func TreeModelSortPrivateNewFromNative(native unsafe.Pointer) *TreeModelSortPrivate {
	err := treeModelSortPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeModelSortPrivate{native: native}

	return instance
}

/*
CastToTreeModelSortPrivate down casts any arbitrary Object to TreeModelSortPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeModelSortPrivate.
*/
func CastToTreeModelSortPrivate(object *gobject.Object) *TreeModelSortPrivate {
	return TreeModelSortPrivateNewFromNative(object.Native())
}

// Equals compares this TreeModelSortPrivate with another TreeModelSortPrivate, and returns true if they represent the same Object.
func (recv *TreeModelSortPrivate) Equals(other *TreeModelSortPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeModelSortPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TreeModelSortPrivateStruct creates an uninitialised TreeModelSortPrivate.
func TreeModelSortPrivateStruct() *TreeModelSortPrivate {
	err := treeModelSortPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeModelSortPrivateNewFromNative(treeModelSortPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeModelSortPrivate)
	return structGo
}
func finalizeTreeModelSortPrivate(obj *TreeModelSortPrivate) {
	treeModelSortPrivateStruct.Free(obj.Native())
}

var treePathStruct *gi.Struct
var treePathStruct_Once sync.Once

func treePathStruct_Set() error {
	var err error
	treePathStruct_Once.Do(func() {
		treePathStruct, err = gi.StructNew("Gtk", "TreePath")
	})
	return err
}

type TreePath struct {
	native unsafe.Pointer
}

func TreePathNewFromNative(native unsafe.Pointer) *TreePath {
	err := treePathStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreePath{native: native}

	return instance
}

/*
CastToTreePath down casts any arbitrary Object to TreePath.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreePath.
*/
func CastToTreePath(object *gobject.Object) *TreePath {
	return TreePathNewFromNative(object.Native())
}

// Equals compares this TreePath with another TreePath, and returns true if they represent the same Object.
func (recv *TreePath) Equals(other *TreePath) bool {
	return other.Native() == recv.Native()
}

func (recv *TreePath) Native() unsafe.Pointer {
	return recv.native
}

var treePathNewFunction *gi.Function
var treePathNewFunction_Once sync.Once

func treePathNewFunction_Set() error {
	var err error
	treePathNewFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathNewFunction, err = treePathStruct.InvokerNew("new")
	})
	return err
}

// TreePathNew is a representation of the C type gtk_tree_path_new.
func TreePathNew() *TreePath {

	var ret gi.Argument

	err := treePathNewFunction_Set()
	if err == nil {
		ret = treePathNewFunction.Invoke(nil, nil)
	}

	retGo := TreePathNewFromNative(ret.Pointer())

	return retGo
}

var treePathNewFirstFunction *gi.Function
var treePathNewFirstFunction_Once sync.Once

func treePathNewFirstFunction_Set() error {
	var err error
	treePathNewFirstFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathNewFirstFunction, err = treePathStruct.InvokerNew("new_first")
	})
	return err
}

// TreePathNewFirst is a representation of the C type gtk_tree_path_new_first.
func TreePathNewFirst() *TreePath {

	var ret gi.Argument

	err := treePathNewFirstFunction_Set()
	if err == nil {
		ret = treePathNewFirstFunction.Invoke(nil, nil)
	}

	retGo := TreePathNewFromNative(ret.Pointer())

	return retGo
}

// UNSUPPORTED : C value 'gtk_tree_path_new_from_indices' : parameter '...' of type 'nil' not supported

// UNSUPPORTED : C value 'gtk_tree_path_new_from_indicesv' : array parameter 'indices'

var treePathNewFromStringFunction *gi.Function
var treePathNewFromStringFunction_Once sync.Once

func treePathNewFromStringFunction_Set() error {
	var err error
	treePathNewFromStringFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathNewFromStringFunction, err = treePathStruct.InvokerNew("new_from_string")
	})
	return err
}

// TreePathNewFromString is a representation of the C type gtk_tree_path_new_from_string.
func TreePathNewFromString(path string) *TreePath {
	var inArgs [1]gi.Argument
	inArgs[0].SetString(path)

	var ret gi.Argument

	err := treePathNewFromStringFunction_Set()
	if err == nil {
		ret = treePathNewFromStringFunction.Invoke(inArgs[:], nil)
	}

	retGo := TreePathNewFromNative(ret.Pointer())

	return retGo
}

var treePathAppendIndexFunction *gi.Function
var treePathAppendIndexFunction_Once sync.Once

func treePathAppendIndexFunction_Set() error {
	var err error
	treePathAppendIndexFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathAppendIndexFunction, err = treePathStruct.InvokerNew("append_index")
	})
	return err
}

// AppendIndex is a representation of the C type gtk_tree_path_append_index.
func (recv *TreePath) AppendIndex(index int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(index)

	err := treePathAppendIndexFunction_Set()
	if err == nil {
		treePathAppendIndexFunction.Invoke(inArgs[:], nil)
	}

	return
}

var treePathCompareFunction *gi.Function
var treePathCompareFunction_Once sync.Once

func treePathCompareFunction_Set() error {
	var err error
	treePathCompareFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathCompareFunction, err = treePathStruct.InvokerNew("compare")
	})
	return err
}

// Compare is a representation of the C type gtk_tree_path_compare.
func (recv *TreePath) Compare(b *TreePath) int32 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(b.Native())

	var ret gi.Argument

	err := treePathCompareFunction_Set()
	if err == nil {
		ret = treePathCompareFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var treePathCopyFunction *gi.Function
var treePathCopyFunction_Once sync.Once

func treePathCopyFunction_Set() error {
	var err error
	treePathCopyFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathCopyFunction, err = treePathStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_tree_path_copy.
func (recv *TreePath) Copy() *TreePath {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treePathCopyFunction_Set()
	if err == nil {
		ret = treePathCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := TreePathNewFromNative(ret.Pointer())

	return retGo
}

var treePathDownFunction *gi.Function
var treePathDownFunction_Once sync.Once

func treePathDownFunction_Set() error {
	var err error
	treePathDownFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathDownFunction, err = treePathStruct.InvokerNew("down")
	})
	return err
}

// Down is a representation of the C type gtk_tree_path_down.
func (recv *TreePath) Down() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := treePathDownFunction_Set()
	if err == nil {
		treePathDownFunction.Invoke(inArgs[:], nil)
	}

	return
}

var treePathFreeFunction *gi.Function
var treePathFreeFunction_Once sync.Once

func treePathFreeFunction_Set() error {
	var err error
	treePathFreeFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathFreeFunction, err = treePathStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_tree_path_free.
func (recv *TreePath) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := treePathFreeFunction_Set()
	if err == nil {
		treePathFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var treePathGetDepthFunction *gi.Function
var treePathGetDepthFunction_Once sync.Once

func treePathGetDepthFunction_Set() error {
	var err error
	treePathGetDepthFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathGetDepthFunction, err = treePathStruct.InvokerNew("get_depth")
	})
	return err
}

// GetDepth is a representation of the C type gtk_tree_path_get_depth.
func (recv *TreePath) GetDepth() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treePathGetDepthFunction_Set()
	if err == nil {
		ret = treePathGetDepthFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var treePathGetIndicesFunction *gi.Function
var treePathGetIndicesFunction_Once sync.Once

func treePathGetIndicesFunction_Set() error {
	var err error
	treePathGetIndicesFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathGetIndicesFunction, err = treePathStruct.InvokerNew("get_indices")
	})
	return err
}

// GetIndices is a representation of the C type gtk_tree_path_get_indices.
func (recv *TreePath) GetIndices() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treePathGetIndicesFunction_Set()
	if err == nil {
		ret = treePathGetIndicesFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var treePathGetIndicesWithDepthFunction *gi.Function
var treePathGetIndicesWithDepthFunction_Once sync.Once

func treePathGetIndicesWithDepthFunction_Set() error {
	var err error
	treePathGetIndicesWithDepthFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathGetIndicesWithDepthFunction, err = treePathStruct.InvokerNew("get_indices_with_depth")
	})
	return err
}

// GetIndicesWithDepth is a representation of the C type gtk_tree_path_get_indices_with_depth.
func (recv *TreePath) GetIndicesWithDepth() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var outArgs [1]gi.Argument

	err := treePathGetIndicesWithDepthFunction_Set()
	if err == nil {
		treePathGetIndicesWithDepthFunction.Invoke(inArgs[:], outArgs[:])
	}

	out0 := outArgs[0].Int32()

	return out0
}

var treePathIsAncestorFunction *gi.Function
var treePathIsAncestorFunction_Once sync.Once

func treePathIsAncestorFunction_Set() error {
	var err error
	treePathIsAncestorFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathIsAncestorFunction, err = treePathStruct.InvokerNew("is_ancestor")
	})
	return err
}

// IsAncestor is a representation of the C type gtk_tree_path_is_ancestor.
func (recv *TreePath) IsAncestor(descendant *TreePath) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(descendant.Native())

	var ret gi.Argument

	err := treePathIsAncestorFunction_Set()
	if err == nil {
		ret = treePathIsAncestorFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var treePathIsDescendantFunction *gi.Function
var treePathIsDescendantFunction_Once sync.Once

func treePathIsDescendantFunction_Set() error {
	var err error
	treePathIsDescendantFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathIsDescendantFunction, err = treePathStruct.InvokerNew("is_descendant")
	})
	return err
}

// IsDescendant is a representation of the C type gtk_tree_path_is_descendant.
func (recv *TreePath) IsDescendant(ancestor *TreePath) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(ancestor.Native())

	var ret gi.Argument

	err := treePathIsDescendantFunction_Set()
	if err == nil {
		ret = treePathIsDescendantFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var treePathNextFunction *gi.Function
var treePathNextFunction_Once sync.Once

func treePathNextFunction_Set() error {
	var err error
	treePathNextFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathNextFunction, err = treePathStruct.InvokerNew("next")
	})
	return err
}

// Next is a representation of the C type gtk_tree_path_next.
func (recv *TreePath) Next() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := treePathNextFunction_Set()
	if err == nil {
		treePathNextFunction.Invoke(inArgs[:], nil)
	}

	return
}

var treePathPrependIndexFunction *gi.Function
var treePathPrependIndexFunction_Once sync.Once

func treePathPrependIndexFunction_Set() error {
	var err error
	treePathPrependIndexFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathPrependIndexFunction, err = treePathStruct.InvokerNew("prepend_index")
	})
	return err
}

// PrependIndex is a representation of the C type gtk_tree_path_prepend_index.
func (recv *TreePath) PrependIndex(index int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(index)

	err := treePathPrependIndexFunction_Set()
	if err == nil {
		treePathPrependIndexFunction.Invoke(inArgs[:], nil)
	}

	return
}

var treePathPrevFunction *gi.Function
var treePathPrevFunction_Once sync.Once

func treePathPrevFunction_Set() error {
	var err error
	treePathPrevFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathPrevFunction, err = treePathStruct.InvokerNew("prev")
	})
	return err
}

// Prev is a representation of the C type gtk_tree_path_prev.
func (recv *TreePath) Prev() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treePathPrevFunction_Set()
	if err == nil {
		ret = treePathPrevFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var treePathToStringFunction *gi.Function
var treePathToStringFunction_Once sync.Once

func treePathToStringFunction_Set() error {
	var err error
	treePathToStringFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathToStringFunction, err = treePathStruct.InvokerNew("to_string")
	})
	return err
}

// ToString is a representation of the C type gtk_tree_path_to_string.
func (recv *TreePath) ToString() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treePathToStringFunction_Set()
	if err == nil {
		ret = treePathToStringFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var treePathUpFunction *gi.Function
var treePathUpFunction_Once sync.Once

func treePathUpFunction_Set() error {
	var err error
	treePathUpFunction_Once.Do(func() {
		err = treePathStruct_Set()
		if err != nil {
			return
		}
		treePathUpFunction, err = treePathStruct.InvokerNew("up")
	})
	return err
}

// Up is a representation of the C type gtk_tree_path_up.
func (recv *TreePath) Up() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treePathUpFunction_Set()
	if err == nil {
		ret = treePathUpFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var treeRowReferenceStruct *gi.Struct
var treeRowReferenceStruct_Once sync.Once

func treeRowReferenceStruct_Set() error {
	var err error
	treeRowReferenceStruct_Once.Do(func() {
		treeRowReferenceStruct, err = gi.StructNew("Gtk", "TreeRowReference")
	})
	return err
}

type TreeRowReference struct {
	native unsafe.Pointer
}

func TreeRowReferenceNewFromNative(native unsafe.Pointer) *TreeRowReference {
	err := treeRowReferenceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeRowReference{native: native}

	return instance
}

/*
CastToTreeRowReference down casts any arbitrary Object to TreeRowReference.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeRowReference.
*/
func CastToTreeRowReference(object *gobject.Object) *TreeRowReference {
	return TreeRowReferenceNewFromNative(object.Native())
}

// Equals compares this TreeRowReference with another TreeRowReference, and returns true if they represent the same Object.
func (recv *TreeRowReference) Equals(other *TreeRowReference) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeRowReference) Native() unsafe.Pointer {
	return recv.native
}

var treeRowReferenceNewFunction *gi.Function
var treeRowReferenceNewFunction_Once sync.Once

func treeRowReferenceNewFunction_Set() error {
	var err error
	treeRowReferenceNewFunction_Once.Do(func() {
		err = treeRowReferenceStruct_Set()
		if err != nil {
			return
		}
		treeRowReferenceNewFunction, err = treeRowReferenceStruct.InvokerNew("new")
	})
	return err
}

// TreeRowReferenceNew is a representation of the C type gtk_tree_row_reference_new.
func TreeRowReferenceNew(model *TreeModel, path *TreePath) *TreeRowReference {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(model.Native())
	inArgs[1].SetPointer(path.Native())

	var ret gi.Argument

	err := treeRowReferenceNewFunction_Set()
	if err == nil {
		ret = treeRowReferenceNewFunction.Invoke(inArgs[:], nil)
	}

	retGo := TreeRowReferenceNewFromNative(ret.Pointer())

	return retGo
}

var treeRowReferenceNewProxyFunction *gi.Function
var treeRowReferenceNewProxyFunction_Once sync.Once

func treeRowReferenceNewProxyFunction_Set() error {
	var err error
	treeRowReferenceNewProxyFunction_Once.Do(func() {
		err = treeRowReferenceStruct_Set()
		if err != nil {
			return
		}
		treeRowReferenceNewProxyFunction, err = treeRowReferenceStruct.InvokerNew("new_proxy")
	})
	return err
}

// TreeRowReferenceNewProxy is a representation of the C type gtk_tree_row_reference_new_proxy.
func TreeRowReferenceNewProxy(proxy *gobject.Object, model *TreeModel, path *TreePath) *TreeRowReference {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(proxy.Native())
	inArgs[1].SetPointer(model.Native())
	inArgs[2].SetPointer(path.Native())

	var ret gi.Argument

	err := treeRowReferenceNewProxyFunction_Set()
	if err == nil {
		ret = treeRowReferenceNewProxyFunction.Invoke(inArgs[:], nil)
	}

	retGo := TreeRowReferenceNewFromNative(ret.Pointer())

	return retGo
}

var treeRowReferenceCopyFunction *gi.Function
var treeRowReferenceCopyFunction_Once sync.Once

func treeRowReferenceCopyFunction_Set() error {
	var err error
	treeRowReferenceCopyFunction_Once.Do(func() {
		err = treeRowReferenceStruct_Set()
		if err != nil {
			return
		}
		treeRowReferenceCopyFunction, err = treeRowReferenceStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_tree_row_reference_copy.
func (recv *TreeRowReference) Copy() *TreeRowReference {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treeRowReferenceCopyFunction_Set()
	if err == nil {
		ret = treeRowReferenceCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := TreeRowReferenceNewFromNative(ret.Pointer())

	return retGo
}

var treeRowReferenceFreeFunction *gi.Function
var treeRowReferenceFreeFunction_Once sync.Once

func treeRowReferenceFreeFunction_Set() error {
	var err error
	treeRowReferenceFreeFunction_Once.Do(func() {
		err = treeRowReferenceStruct_Set()
		if err != nil {
			return
		}
		treeRowReferenceFreeFunction, err = treeRowReferenceStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_tree_row_reference_free.
func (recv *TreeRowReference) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := treeRowReferenceFreeFunction_Set()
	if err == nil {
		treeRowReferenceFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var treeRowReferenceGetModelFunction *gi.Function
var treeRowReferenceGetModelFunction_Once sync.Once

func treeRowReferenceGetModelFunction_Set() error {
	var err error
	treeRowReferenceGetModelFunction_Once.Do(func() {
		err = treeRowReferenceStruct_Set()
		if err != nil {
			return
		}
		treeRowReferenceGetModelFunction, err = treeRowReferenceStruct.InvokerNew("get_model")
	})
	return err
}

// GetModel is a representation of the C type gtk_tree_row_reference_get_model.
func (recv *TreeRowReference) GetModel() *TreeModel {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treeRowReferenceGetModelFunction_Set()
	if err == nil {
		ret = treeRowReferenceGetModelFunction.Invoke(inArgs[:], nil)
	}

	retGo := TreeModelNewFromNative(ret.Pointer())

	return retGo
}

var treeRowReferenceGetPathFunction *gi.Function
var treeRowReferenceGetPathFunction_Once sync.Once

func treeRowReferenceGetPathFunction_Set() error {
	var err error
	treeRowReferenceGetPathFunction_Once.Do(func() {
		err = treeRowReferenceStruct_Set()
		if err != nil {
			return
		}
		treeRowReferenceGetPathFunction, err = treeRowReferenceStruct.InvokerNew("get_path")
	})
	return err
}

// GetPath is a representation of the C type gtk_tree_row_reference_get_path.
func (recv *TreeRowReference) GetPath() *TreePath {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treeRowReferenceGetPathFunction_Set()
	if err == nil {
		ret = treeRowReferenceGetPathFunction.Invoke(inArgs[:], nil)
	}

	retGo := TreePathNewFromNative(ret.Pointer())

	return retGo
}

var treeRowReferenceValidFunction *gi.Function
var treeRowReferenceValidFunction_Once sync.Once

func treeRowReferenceValidFunction_Set() error {
	var err error
	treeRowReferenceValidFunction_Once.Do(func() {
		err = treeRowReferenceStruct_Set()
		if err != nil {
			return
		}
		treeRowReferenceValidFunction, err = treeRowReferenceStruct.InvokerNew("valid")
	})
	return err
}

// Valid is a representation of the C type gtk_tree_row_reference_valid.
func (recv *TreeRowReference) Valid() bool {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := treeRowReferenceValidFunction_Set()
	if err == nil {
		ret = treeRowReferenceValidFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var treeSelectionClassStruct *gi.Struct
var treeSelectionClassStruct_Once sync.Once

func treeSelectionClassStruct_Set() error {
	var err error
	treeSelectionClassStruct_Once.Do(func() {
		treeSelectionClassStruct, err = gi.StructNew("Gtk", "TreeSelectionClass")
	})
	return err
}

type TreeSelectionClass struct {
	native unsafe.Pointer
}

func TreeSelectionClassNewFromNative(native unsafe.Pointer) *TreeSelectionClass {
	err := treeSelectionClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeSelectionClass{native: native}

	return instance
}

/*
CastToTreeSelectionClass down casts any arbitrary Object to TreeSelectionClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeSelectionClass.
*/
func CastToTreeSelectionClass(object *gobject.Object) *TreeSelectionClass {
	return TreeSelectionClassNewFromNative(object.Native())
}

// Equals compares this TreeSelectionClass with another TreeSelectionClass, and returns true if they represent the same Object.
func (recv *TreeSelectionClass) Equals(other *TreeSelectionClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeSelectionClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TreeSelectionClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(treeSelectionClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TreeSelectionClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(treeSelectionClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'changed' : for field getter : missing Type

// UNSUPPORTED : C value 'changed' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TreeSelectionClassStruct creates an uninitialised TreeSelectionClass.
func TreeSelectionClassStruct() *TreeSelectionClass {
	err := treeSelectionClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeSelectionClassNewFromNative(treeSelectionClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeSelectionClass)
	return structGo
}
func finalizeTreeSelectionClass(obj *TreeSelectionClass) {
	treeSelectionClassStruct.Free(obj.Native())
}

var treeSelectionPrivateStruct *gi.Struct
var treeSelectionPrivateStruct_Once sync.Once

func treeSelectionPrivateStruct_Set() error {
	var err error
	treeSelectionPrivateStruct_Once.Do(func() {
		treeSelectionPrivateStruct, err = gi.StructNew("Gtk", "TreeSelectionPrivate")
	})
	return err
}

type TreeSelectionPrivate struct {
	native unsafe.Pointer
}

func TreeSelectionPrivateNewFromNative(native unsafe.Pointer) *TreeSelectionPrivate {
	err := treeSelectionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeSelectionPrivate{native: native}

	return instance
}

/*
CastToTreeSelectionPrivate down casts any arbitrary Object to TreeSelectionPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeSelectionPrivate.
*/
func CastToTreeSelectionPrivate(object *gobject.Object) *TreeSelectionPrivate {
	return TreeSelectionPrivateNewFromNative(object.Native())
}

// Equals compares this TreeSelectionPrivate with another TreeSelectionPrivate, and returns true if they represent the same Object.
func (recv *TreeSelectionPrivate) Equals(other *TreeSelectionPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeSelectionPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TreeSelectionPrivateStruct creates an uninitialised TreeSelectionPrivate.
func TreeSelectionPrivateStruct() *TreeSelectionPrivate {
	err := treeSelectionPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeSelectionPrivateNewFromNative(treeSelectionPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeSelectionPrivate)
	return structGo
}
func finalizeTreeSelectionPrivate(obj *TreeSelectionPrivate) {
	treeSelectionPrivateStruct.Free(obj.Native())
}

var treeSortableIfaceStruct *gi.Struct
var treeSortableIfaceStruct_Once sync.Once

func treeSortableIfaceStruct_Set() error {
	var err error
	treeSortableIfaceStruct_Once.Do(func() {
		treeSortableIfaceStruct, err = gi.StructNew("Gtk", "TreeSortableIface")
	})
	return err
}

type TreeSortableIface struct {
	native unsafe.Pointer
}

func TreeSortableIfaceNewFromNative(native unsafe.Pointer) *TreeSortableIface {
	err := treeSortableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeSortableIface{native: native}

	return instance
}

/*
CastToTreeSortableIface down casts any arbitrary Object to TreeSortableIface.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeSortableIface.
*/
func CastToTreeSortableIface(object *gobject.Object) *TreeSortableIface {
	return TreeSortableIfaceNewFromNative(object.Native())
}

// Equals compares this TreeSortableIface with another TreeSortableIface, and returns true if they represent the same Object.
func (recv *TreeSortableIface) Equals(other *TreeSortableIface) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeSortableIface) Native() unsafe.Pointer {
	return recv.native
}

// UNSUPPORTED : C value 'sort_column_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'sort_column_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'get_sort_column_id' : for field getter : missing Type

// UNSUPPORTED : C value 'get_sort_column_id' : for field setter : missing Type

// UNSUPPORTED : C value 'set_sort_column_id' : for field getter : missing Type

// UNSUPPORTED : C value 'set_sort_column_id' : for field setter : missing Type

// UNSUPPORTED : C value 'set_sort_func' : for field getter : missing Type

// UNSUPPORTED : C value 'set_sort_func' : for field setter : missing Type

// UNSUPPORTED : C value 'set_default_sort_func' : for field getter : missing Type

// UNSUPPORTED : C value 'set_default_sort_func' : for field setter : missing Type

// UNSUPPORTED : C value 'has_default_sort_func' : for field getter : missing Type

// UNSUPPORTED : C value 'has_default_sort_func' : for field setter : missing Type

// TreeSortableIfaceStruct creates an uninitialised TreeSortableIface.
func TreeSortableIfaceStruct() *TreeSortableIface {
	err := treeSortableIfaceStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeSortableIfaceNewFromNative(treeSortableIfaceStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeSortableIface)
	return structGo
}
func finalizeTreeSortableIface(obj *TreeSortableIface) {
	treeSortableIfaceStruct.Free(obj.Native())
}

var treeStoreClassStruct *gi.Struct
var treeStoreClassStruct_Once sync.Once

func treeStoreClassStruct_Set() error {
	var err error
	treeStoreClassStruct_Once.Do(func() {
		treeStoreClassStruct, err = gi.StructNew("Gtk", "TreeStoreClass")
	})
	return err
}

type TreeStoreClass struct {
	native unsafe.Pointer
}

func TreeStoreClassNewFromNative(native unsafe.Pointer) *TreeStoreClass {
	err := treeStoreClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeStoreClass{native: native}

	return instance
}

/*
CastToTreeStoreClass down casts any arbitrary Object to TreeStoreClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeStoreClass.
*/
func CastToTreeStoreClass(object *gobject.Object) *TreeStoreClass {
	return TreeStoreClassNewFromNative(object.Native())
}

// Equals compares this TreeStoreClass with another TreeStoreClass, and returns true if they represent the same Object.
func (recv *TreeStoreClass) Equals(other *TreeStoreClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeStoreClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TreeStoreClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(treeStoreClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TreeStoreClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(treeStoreClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TreeStoreClassStruct creates an uninitialised TreeStoreClass.
func TreeStoreClassStruct() *TreeStoreClass {
	err := treeStoreClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeStoreClassNewFromNative(treeStoreClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeStoreClass)
	return structGo
}
func finalizeTreeStoreClass(obj *TreeStoreClass) {
	treeStoreClassStruct.Free(obj.Native())
}

var treeStorePrivateStruct *gi.Struct
var treeStorePrivateStruct_Once sync.Once

func treeStorePrivateStruct_Set() error {
	var err error
	treeStorePrivateStruct_Once.Do(func() {
		treeStorePrivateStruct, err = gi.StructNew("Gtk", "TreeStorePrivate")
	})
	return err
}

type TreeStorePrivate struct {
	native unsafe.Pointer
}

func TreeStorePrivateNewFromNative(native unsafe.Pointer) *TreeStorePrivate {
	err := treeStorePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeStorePrivate{native: native}

	return instance
}

/*
CastToTreeStorePrivate down casts any arbitrary Object to TreeStorePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeStorePrivate.
*/
func CastToTreeStorePrivate(object *gobject.Object) *TreeStorePrivate {
	return TreeStorePrivateNewFromNative(object.Native())
}

// Equals compares this TreeStorePrivate with another TreeStorePrivate, and returns true if they represent the same Object.
func (recv *TreeStorePrivate) Equals(other *TreeStorePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeStorePrivate) Native() unsafe.Pointer {
	return recv.native
}

// TreeStorePrivateStruct creates an uninitialised TreeStorePrivate.
func TreeStorePrivateStruct() *TreeStorePrivate {
	err := treeStorePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeStorePrivateNewFromNative(treeStorePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeStorePrivate)
	return structGo
}
func finalizeTreeStorePrivate(obj *TreeStorePrivate) {
	treeStorePrivateStruct.Free(obj.Native())
}

var treeViewAccessibleClassStruct *gi.Struct
var treeViewAccessibleClassStruct_Once sync.Once

func treeViewAccessibleClassStruct_Set() error {
	var err error
	treeViewAccessibleClassStruct_Once.Do(func() {
		treeViewAccessibleClassStruct, err = gi.StructNew("Gtk", "TreeViewAccessibleClass")
	})
	return err
}

type TreeViewAccessibleClass struct {
	native unsafe.Pointer
}

func TreeViewAccessibleClassNewFromNative(native unsafe.Pointer) *TreeViewAccessibleClass {
	err := treeViewAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeViewAccessibleClass{native: native}

	return instance
}

/*
CastToTreeViewAccessibleClass down casts any arbitrary Object to TreeViewAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeViewAccessibleClass.
*/
func CastToTreeViewAccessibleClass(object *gobject.Object) *TreeViewAccessibleClass {
	return TreeViewAccessibleClassNewFromNative(object.Native())
}

// Equals compares this TreeViewAccessibleClass with another TreeViewAccessibleClass, and returns true if they represent the same Object.
func (recv *TreeViewAccessibleClass) Equals(other *TreeViewAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeViewAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TreeViewAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(treeViewAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TreeViewAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(treeViewAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// TreeViewAccessibleClassStruct creates an uninitialised TreeViewAccessibleClass.
func TreeViewAccessibleClassStruct() *TreeViewAccessibleClass {
	err := treeViewAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeViewAccessibleClassNewFromNative(treeViewAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeViewAccessibleClass)
	return structGo
}
func finalizeTreeViewAccessibleClass(obj *TreeViewAccessibleClass) {
	treeViewAccessibleClassStruct.Free(obj.Native())
}

var treeViewAccessiblePrivateStruct *gi.Struct
var treeViewAccessiblePrivateStruct_Once sync.Once

func treeViewAccessiblePrivateStruct_Set() error {
	var err error
	treeViewAccessiblePrivateStruct_Once.Do(func() {
		treeViewAccessiblePrivateStruct, err = gi.StructNew("Gtk", "TreeViewAccessiblePrivate")
	})
	return err
}

type TreeViewAccessiblePrivate struct {
	native unsafe.Pointer
}

func TreeViewAccessiblePrivateNewFromNative(native unsafe.Pointer) *TreeViewAccessiblePrivate {
	err := treeViewAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeViewAccessiblePrivate{native: native}

	return instance
}

/*
CastToTreeViewAccessiblePrivate down casts any arbitrary Object to TreeViewAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeViewAccessiblePrivate.
*/
func CastToTreeViewAccessiblePrivate(object *gobject.Object) *TreeViewAccessiblePrivate {
	return TreeViewAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this TreeViewAccessiblePrivate with another TreeViewAccessiblePrivate, and returns true if they represent the same Object.
func (recv *TreeViewAccessiblePrivate) Equals(other *TreeViewAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeViewAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// TreeViewAccessiblePrivateStruct creates an uninitialised TreeViewAccessiblePrivate.
func TreeViewAccessiblePrivateStruct() *TreeViewAccessiblePrivate {
	err := treeViewAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeViewAccessiblePrivateNewFromNative(treeViewAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeViewAccessiblePrivate)
	return structGo
}
func finalizeTreeViewAccessiblePrivate(obj *TreeViewAccessiblePrivate) {
	treeViewAccessiblePrivateStruct.Free(obj.Native())
}

var treeViewClassStruct *gi.Struct
var treeViewClassStruct_Once sync.Once

func treeViewClassStruct_Set() error {
	var err error
	treeViewClassStruct_Once.Do(func() {
		treeViewClassStruct, err = gi.StructNew("Gtk", "TreeViewClass")
	})
	return err
}

type TreeViewClass struct {
	native unsafe.Pointer
}

func TreeViewClassNewFromNative(native unsafe.Pointer) *TreeViewClass {
	err := treeViewClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeViewClass{native: native}

	return instance
}

/*
CastToTreeViewClass down casts any arbitrary Object to TreeViewClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeViewClass.
*/
func CastToTreeViewClass(object *gobject.Object) *TreeViewClass {
	return TreeViewClassNewFromNative(object.Native())
}

// Equals compares this TreeViewClass with another TreeViewClass, and returns true if they represent the same Object.
func (recv *TreeViewClass) Equals(other *TreeViewClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeViewClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TreeViewClass) FieldParentClass() *ContainerClass {
	argValue := gi.StructFieldGet(treeViewClassStruct, recv.Native(), "parent_class")
	value := ContainerClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TreeViewClass) SetFieldParentClass(value *ContainerClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(treeViewClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'row_activated' : for field getter : missing Type

// UNSUPPORTED : C value 'row_activated' : for field setter : missing Type

// UNSUPPORTED : C value 'test_expand_row' : for field getter : missing Type

// UNSUPPORTED : C value 'test_expand_row' : for field setter : missing Type

// UNSUPPORTED : C value 'test_collapse_row' : for field getter : missing Type

// UNSUPPORTED : C value 'test_collapse_row' : for field setter : missing Type

// UNSUPPORTED : C value 'row_expanded' : for field getter : missing Type

// UNSUPPORTED : C value 'row_expanded' : for field setter : missing Type

// UNSUPPORTED : C value 'row_collapsed' : for field getter : missing Type

// UNSUPPORTED : C value 'row_collapsed' : for field setter : missing Type

// UNSUPPORTED : C value 'columns_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'columns_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'cursor_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'cursor_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field getter : missing Type

// UNSUPPORTED : C value 'move_cursor' : for field setter : missing Type

// UNSUPPORTED : C value 'select_all' : for field getter : missing Type

// UNSUPPORTED : C value 'select_all' : for field setter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field getter : missing Type

// UNSUPPORTED : C value 'unselect_all' : for field setter : missing Type

// UNSUPPORTED : C value 'select_cursor_row' : for field getter : missing Type

// UNSUPPORTED : C value 'select_cursor_row' : for field setter : missing Type

// UNSUPPORTED : C value 'toggle_cursor_row' : for field getter : missing Type

// UNSUPPORTED : C value 'toggle_cursor_row' : for field setter : missing Type

// UNSUPPORTED : C value 'expand_collapse_cursor_row' : for field getter : missing Type

// UNSUPPORTED : C value 'expand_collapse_cursor_row' : for field setter : missing Type

// UNSUPPORTED : C value 'select_cursor_parent' : for field getter : missing Type

// UNSUPPORTED : C value 'select_cursor_parent' : for field setter : missing Type

// UNSUPPORTED : C value 'start_interactive_search' : for field getter : missing Type

// UNSUPPORTED : C value 'start_interactive_search' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved5' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved8' : for field setter : missing Type

// TreeViewClassStruct creates an uninitialised TreeViewClass.
func TreeViewClassStruct() *TreeViewClass {
	err := treeViewClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeViewClassNewFromNative(treeViewClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeViewClass)
	return structGo
}
func finalizeTreeViewClass(obj *TreeViewClass) {
	treeViewClassStruct.Free(obj.Native())
}

var treeViewColumnClassStruct *gi.Struct
var treeViewColumnClassStruct_Once sync.Once

func treeViewColumnClassStruct_Set() error {
	var err error
	treeViewColumnClassStruct_Once.Do(func() {
		treeViewColumnClassStruct, err = gi.StructNew("Gtk", "TreeViewColumnClass")
	})
	return err
}

type TreeViewColumnClass struct {
	native unsafe.Pointer
}

func TreeViewColumnClassNewFromNative(native unsafe.Pointer) *TreeViewColumnClass {
	err := treeViewColumnClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeViewColumnClass{native: native}

	return instance
}

/*
CastToTreeViewColumnClass down casts any arbitrary Object to TreeViewColumnClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeViewColumnClass.
*/
func CastToTreeViewColumnClass(object *gobject.Object) *TreeViewColumnClass {
	return TreeViewColumnClassNewFromNative(object.Native())
}

// Equals compares this TreeViewColumnClass with another TreeViewColumnClass, and returns true if they represent the same Object.
func (recv *TreeViewColumnClass) Equals(other *TreeViewColumnClass) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeViewColumnClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *TreeViewColumnClass) FieldParentClass() *gobject.InitiallyUnownedClass {
	argValue := gi.StructFieldGet(treeViewColumnClassStruct, recv.Native(), "parent_class")
	value := gobject.InitiallyUnownedClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *TreeViewColumnClass) SetFieldParentClass(value *gobject.InitiallyUnownedClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(treeViewColumnClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'clicked' : for field getter : missing Type

// UNSUPPORTED : C value 'clicked' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// TreeViewColumnClassStruct creates an uninitialised TreeViewColumnClass.
func TreeViewColumnClassStruct() *TreeViewColumnClass {
	err := treeViewColumnClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeViewColumnClassNewFromNative(treeViewColumnClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeViewColumnClass)
	return structGo
}
func finalizeTreeViewColumnClass(obj *TreeViewColumnClass) {
	treeViewColumnClassStruct.Free(obj.Native())
}

var treeViewColumnPrivateStruct *gi.Struct
var treeViewColumnPrivateStruct_Once sync.Once

func treeViewColumnPrivateStruct_Set() error {
	var err error
	treeViewColumnPrivateStruct_Once.Do(func() {
		treeViewColumnPrivateStruct, err = gi.StructNew("Gtk", "TreeViewColumnPrivate")
	})
	return err
}

type TreeViewColumnPrivate struct {
	native unsafe.Pointer
}

func TreeViewColumnPrivateNewFromNative(native unsafe.Pointer) *TreeViewColumnPrivate {
	err := treeViewColumnPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeViewColumnPrivate{native: native}

	return instance
}

/*
CastToTreeViewColumnPrivate down casts any arbitrary Object to TreeViewColumnPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeViewColumnPrivate.
*/
func CastToTreeViewColumnPrivate(object *gobject.Object) *TreeViewColumnPrivate {
	return TreeViewColumnPrivateNewFromNative(object.Native())
}

// Equals compares this TreeViewColumnPrivate with another TreeViewColumnPrivate, and returns true if they represent the same Object.
func (recv *TreeViewColumnPrivate) Equals(other *TreeViewColumnPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeViewColumnPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TreeViewColumnPrivateStruct creates an uninitialised TreeViewColumnPrivate.
func TreeViewColumnPrivateStruct() *TreeViewColumnPrivate {
	err := treeViewColumnPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeViewColumnPrivateNewFromNative(treeViewColumnPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeViewColumnPrivate)
	return structGo
}
func finalizeTreeViewColumnPrivate(obj *TreeViewColumnPrivate) {
	treeViewColumnPrivateStruct.Free(obj.Native())
}

var treeViewPrivateStruct *gi.Struct
var treeViewPrivateStruct_Once sync.Once

func treeViewPrivateStruct_Set() error {
	var err error
	treeViewPrivateStruct_Once.Do(func() {
		treeViewPrivateStruct, err = gi.StructNew("Gtk", "TreeViewPrivate")
	})
	return err
}

type TreeViewPrivate struct {
	native unsafe.Pointer
}

func TreeViewPrivateNewFromNative(native unsafe.Pointer) *TreeViewPrivate {
	err := treeViewPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &TreeViewPrivate{native: native}

	return instance
}

/*
CastToTreeViewPrivate down casts any arbitrary Object to TreeViewPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a TreeViewPrivate.
*/
func CastToTreeViewPrivate(object *gobject.Object) *TreeViewPrivate {
	return TreeViewPrivateNewFromNative(object.Native())
}

// Equals compares this TreeViewPrivate with another TreeViewPrivate, and returns true if they represent the same Object.
func (recv *TreeViewPrivate) Equals(other *TreeViewPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *TreeViewPrivate) Native() unsafe.Pointer {
	return recv.native
}

// TreeViewPrivateStruct creates an uninitialised TreeViewPrivate.
func TreeViewPrivateStruct() *TreeViewPrivate {
	err := treeViewPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := TreeViewPrivateNewFromNative(treeViewPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeTreeViewPrivate)
	return structGo
}
func finalizeTreeViewPrivate(obj *TreeViewPrivate) {
	treeViewPrivateStruct.Free(obj.Native())
}

var uIManagerClassStruct *gi.Struct
var uIManagerClassStruct_Once sync.Once

func uIManagerClassStruct_Set() error {
	var err error
	uIManagerClassStruct_Once.Do(func() {
		uIManagerClassStruct, err = gi.StructNew("Gtk", "UIManagerClass")
	})
	return err
}

type UIManagerClass struct {
	native unsafe.Pointer
}

func UIManagerClassNewFromNative(native unsafe.Pointer) *UIManagerClass {
	err := uIManagerClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &UIManagerClass{native: native}

	return instance
}

/*
CastToUIManagerClass down casts any arbitrary Object to UIManagerClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a UIManagerClass.
*/
func CastToUIManagerClass(object *gobject.Object) *UIManagerClass {
	return UIManagerClassNewFromNative(object.Native())
}

// Equals compares this UIManagerClass with another UIManagerClass, and returns true if they represent the same Object.
func (recv *UIManagerClass) Equals(other *UIManagerClass) bool {
	return other.Native() == recv.Native()
}

func (recv *UIManagerClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *UIManagerClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(uIManagerClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *UIManagerClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(uIManagerClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'add_widget' : for field getter : missing Type

// UNSUPPORTED : C value 'add_widget' : for field setter : missing Type

// UNSUPPORTED : C value 'actions_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'actions_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'connect_proxy' : for field getter : missing Type

// UNSUPPORTED : C value 'connect_proxy' : for field setter : missing Type

// UNSUPPORTED : C value 'disconnect_proxy' : for field getter : missing Type

// UNSUPPORTED : C value 'disconnect_proxy' : for field setter : missing Type

// UNSUPPORTED : C value 'pre_activate' : for field getter : missing Type

// UNSUPPORTED : C value 'pre_activate' : for field setter : missing Type

// UNSUPPORTED : C value 'post_activate' : for field getter : missing Type

// UNSUPPORTED : C value 'post_activate' : for field setter : missing Type

// UNSUPPORTED : C value 'get_widget' : for field getter : missing Type

// UNSUPPORTED : C value 'get_widget' : for field setter : missing Type

// UNSUPPORTED : C value 'get_action' : for field getter : missing Type

// UNSUPPORTED : C value 'get_action' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// UIManagerClassStruct creates an uninitialised UIManagerClass.
func UIManagerClassStruct() *UIManagerClass {
	err := uIManagerClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := UIManagerClassNewFromNative(uIManagerClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeUIManagerClass)
	return structGo
}
func finalizeUIManagerClass(obj *UIManagerClass) {
	uIManagerClassStruct.Free(obj.Native())
}

var uIManagerPrivateStruct *gi.Struct
var uIManagerPrivateStruct_Once sync.Once

func uIManagerPrivateStruct_Set() error {
	var err error
	uIManagerPrivateStruct_Once.Do(func() {
		uIManagerPrivateStruct, err = gi.StructNew("Gtk", "UIManagerPrivate")
	})
	return err
}

type UIManagerPrivate struct {
	native unsafe.Pointer
}

func UIManagerPrivateNewFromNative(native unsafe.Pointer) *UIManagerPrivate {
	err := uIManagerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &UIManagerPrivate{native: native}

	return instance
}

/*
CastToUIManagerPrivate down casts any arbitrary Object to UIManagerPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a UIManagerPrivate.
*/
func CastToUIManagerPrivate(object *gobject.Object) *UIManagerPrivate {
	return UIManagerPrivateNewFromNative(object.Native())
}

// Equals compares this UIManagerPrivate with another UIManagerPrivate, and returns true if they represent the same Object.
func (recv *UIManagerPrivate) Equals(other *UIManagerPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *UIManagerPrivate) Native() unsafe.Pointer {
	return recv.native
}

// UIManagerPrivateStruct creates an uninitialised UIManagerPrivate.
func UIManagerPrivateStruct() *UIManagerPrivate {
	err := uIManagerPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := UIManagerPrivateNewFromNative(uIManagerPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeUIManagerPrivate)
	return structGo
}
func finalizeUIManagerPrivate(obj *UIManagerPrivate) {
	uIManagerPrivateStruct.Free(obj.Native())
}

var vBoxClassStruct *gi.Struct
var vBoxClassStruct_Once sync.Once

func vBoxClassStruct_Set() error {
	var err error
	vBoxClassStruct_Once.Do(func() {
		vBoxClassStruct, err = gi.StructNew("Gtk", "VBoxClass")
	})
	return err
}

type VBoxClass struct {
	native unsafe.Pointer
}

func VBoxClassNewFromNative(native unsafe.Pointer) *VBoxClass {
	err := vBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &VBoxClass{native: native}

	return instance
}

/*
CastToVBoxClass down casts any arbitrary Object to VBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a VBoxClass.
*/
func CastToVBoxClass(object *gobject.Object) *VBoxClass {
	return VBoxClassNewFromNative(object.Native())
}

// Equals compares this VBoxClass with another VBoxClass, and returns true if they represent the same Object.
func (recv *VBoxClass) Equals(other *VBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *VBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *VBoxClass) FieldParentClass() *BoxClass {
	argValue := gi.StructFieldGet(vBoxClassStruct, recv.Native(), "parent_class")
	value := BoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *VBoxClass) SetFieldParentClass(value *BoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(vBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// VBoxClassStruct creates an uninitialised VBoxClass.
func VBoxClassStruct() *VBoxClass {
	err := vBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := VBoxClassNewFromNative(vBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeVBoxClass)
	return structGo
}
func finalizeVBoxClass(obj *VBoxClass) {
	vBoxClassStruct.Free(obj.Native())
}

var vButtonBoxClassStruct *gi.Struct
var vButtonBoxClassStruct_Once sync.Once

func vButtonBoxClassStruct_Set() error {
	var err error
	vButtonBoxClassStruct_Once.Do(func() {
		vButtonBoxClassStruct, err = gi.StructNew("Gtk", "VButtonBoxClass")
	})
	return err
}

type VButtonBoxClass struct {
	native unsafe.Pointer
}

func VButtonBoxClassNewFromNative(native unsafe.Pointer) *VButtonBoxClass {
	err := vButtonBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &VButtonBoxClass{native: native}

	return instance
}

/*
CastToVButtonBoxClass down casts any arbitrary Object to VButtonBoxClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a VButtonBoxClass.
*/
func CastToVButtonBoxClass(object *gobject.Object) *VButtonBoxClass {
	return VButtonBoxClassNewFromNative(object.Native())
}

// Equals compares this VButtonBoxClass with another VButtonBoxClass, and returns true if they represent the same Object.
func (recv *VButtonBoxClass) Equals(other *VButtonBoxClass) bool {
	return other.Native() == recv.Native()
}

func (recv *VButtonBoxClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *VButtonBoxClass) FieldParentClass() *ButtonBoxClass {
	argValue := gi.StructFieldGet(vButtonBoxClassStruct, recv.Native(), "parent_class")
	value := ButtonBoxClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *VButtonBoxClass) SetFieldParentClass(value *ButtonBoxClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(vButtonBoxClassStruct, recv.Native(), "parent_class", argValue)
}

// VButtonBoxClassStruct creates an uninitialised VButtonBoxClass.
func VButtonBoxClassStruct() *VButtonBoxClass {
	err := vButtonBoxClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := VButtonBoxClassNewFromNative(vButtonBoxClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeVButtonBoxClass)
	return structGo
}
func finalizeVButtonBoxClass(obj *VButtonBoxClass) {
	vButtonBoxClassStruct.Free(obj.Native())
}

var vPanedClassStruct *gi.Struct
var vPanedClassStruct_Once sync.Once

func vPanedClassStruct_Set() error {
	var err error
	vPanedClassStruct_Once.Do(func() {
		vPanedClassStruct, err = gi.StructNew("Gtk", "VPanedClass")
	})
	return err
}

type VPanedClass struct {
	native unsafe.Pointer
}

func VPanedClassNewFromNative(native unsafe.Pointer) *VPanedClass {
	err := vPanedClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &VPanedClass{native: native}

	return instance
}

/*
CastToVPanedClass down casts any arbitrary Object to VPanedClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a VPanedClass.
*/
func CastToVPanedClass(object *gobject.Object) *VPanedClass {
	return VPanedClassNewFromNative(object.Native())
}

// Equals compares this VPanedClass with another VPanedClass, and returns true if they represent the same Object.
func (recv *VPanedClass) Equals(other *VPanedClass) bool {
	return other.Native() == recv.Native()
}

func (recv *VPanedClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *VPanedClass) FieldParentClass() *PanedClass {
	argValue := gi.StructFieldGet(vPanedClassStruct, recv.Native(), "parent_class")
	value := PanedClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *VPanedClass) SetFieldParentClass(value *PanedClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(vPanedClassStruct, recv.Native(), "parent_class", argValue)
}

// VPanedClassStruct creates an uninitialised VPanedClass.
func VPanedClassStruct() *VPanedClass {
	err := vPanedClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := VPanedClassNewFromNative(vPanedClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeVPanedClass)
	return structGo
}
func finalizeVPanedClass(obj *VPanedClass) {
	vPanedClassStruct.Free(obj.Native())
}

var vScaleClassStruct *gi.Struct
var vScaleClassStruct_Once sync.Once

func vScaleClassStruct_Set() error {
	var err error
	vScaleClassStruct_Once.Do(func() {
		vScaleClassStruct, err = gi.StructNew("Gtk", "VScaleClass")
	})
	return err
}

type VScaleClass struct {
	native unsafe.Pointer
}

func VScaleClassNewFromNative(native unsafe.Pointer) *VScaleClass {
	err := vScaleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &VScaleClass{native: native}

	return instance
}

/*
CastToVScaleClass down casts any arbitrary Object to VScaleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a VScaleClass.
*/
func CastToVScaleClass(object *gobject.Object) *VScaleClass {
	return VScaleClassNewFromNative(object.Native())
}

// Equals compares this VScaleClass with another VScaleClass, and returns true if they represent the same Object.
func (recv *VScaleClass) Equals(other *VScaleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *VScaleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *VScaleClass) FieldParentClass() *ScaleClass {
	argValue := gi.StructFieldGet(vScaleClassStruct, recv.Native(), "parent_class")
	value := ScaleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *VScaleClass) SetFieldParentClass(value *ScaleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(vScaleClassStruct, recv.Native(), "parent_class", argValue)
}

// VScaleClassStruct creates an uninitialised VScaleClass.
func VScaleClassStruct() *VScaleClass {
	err := vScaleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := VScaleClassNewFromNative(vScaleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeVScaleClass)
	return structGo
}
func finalizeVScaleClass(obj *VScaleClass) {
	vScaleClassStruct.Free(obj.Native())
}

var vScrollbarClassStruct *gi.Struct
var vScrollbarClassStruct_Once sync.Once

func vScrollbarClassStruct_Set() error {
	var err error
	vScrollbarClassStruct_Once.Do(func() {
		vScrollbarClassStruct, err = gi.StructNew("Gtk", "VScrollbarClass")
	})
	return err
}

type VScrollbarClass struct {
	native unsafe.Pointer
}

func VScrollbarClassNewFromNative(native unsafe.Pointer) *VScrollbarClass {
	err := vScrollbarClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &VScrollbarClass{native: native}

	return instance
}

/*
CastToVScrollbarClass down casts any arbitrary Object to VScrollbarClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a VScrollbarClass.
*/
func CastToVScrollbarClass(object *gobject.Object) *VScrollbarClass {
	return VScrollbarClassNewFromNative(object.Native())
}

// Equals compares this VScrollbarClass with another VScrollbarClass, and returns true if they represent the same Object.
func (recv *VScrollbarClass) Equals(other *VScrollbarClass) bool {
	return other.Native() == recv.Native()
}

func (recv *VScrollbarClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *VScrollbarClass) FieldParentClass() *ScrollbarClass {
	argValue := gi.StructFieldGet(vScrollbarClassStruct, recv.Native(), "parent_class")
	value := ScrollbarClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *VScrollbarClass) SetFieldParentClass(value *ScrollbarClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(vScrollbarClassStruct, recv.Native(), "parent_class", argValue)
}

// VScrollbarClassStruct creates an uninitialised VScrollbarClass.
func VScrollbarClassStruct() *VScrollbarClass {
	err := vScrollbarClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := VScrollbarClassNewFromNative(vScrollbarClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeVScrollbarClass)
	return structGo
}
func finalizeVScrollbarClass(obj *VScrollbarClass) {
	vScrollbarClassStruct.Free(obj.Native())
}

var vSeparatorClassStruct *gi.Struct
var vSeparatorClassStruct_Once sync.Once

func vSeparatorClassStruct_Set() error {
	var err error
	vSeparatorClassStruct_Once.Do(func() {
		vSeparatorClassStruct, err = gi.StructNew("Gtk", "VSeparatorClass")
	})
	return err
}

type VSeparatorClass struct {
	native unsafe.Pointer
}

func VSeparatorClassNewFromNative(native unsafe.Pointer) *VSeparatorClass {
	err := vSeparatorClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &VSeparatorClass{native: native}

	return instance
}

/*
CastToVSeparatorClass down casts any arbitrary Object to VSeparatorClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a VSeparatorClass.
*/
func CastToVSeparatorClass(object *gobject.Object) *VSeparatorClass {
	return VSeparatorClassNewFromNative(object.Native())
}

// Equals compares this VSeparatorClass with another VSeparatorClass, and returns true if they represent the same Object.
func (recv *VSeparatorClass) Equals(other *VSeparatorClass) bool {
	return other.Native() == recv.Native()
}

func (recv *VSeparatorClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *VSeparatorClass) FieldParentClass() *SeparatorClass {
	argValue := gi.StructFieldGet(vSeparatorClassStruct, recv.Native(), "parent_class")
	value := SeparatorClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *VSeparatorClass) SetFieldParentClass(value *SeparatorClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(vSeparatorClassStruct, recv.Native(), "parent_class", argValue)
}

// VSeparatorClassStruct creates an uninitialised VSeparatorClass.
func VSeparatorClassStruct() *VSeparatorClass {
	err := vSeparatorClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := VSeparatorClassNewFromNative(vSeparatorClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeVSeparatorClass)
	return structGo
}
func finalizeVSeparatorClass(obj *VSeparatorClass) {
	vSeparatorClassStruct.Free(obj.Native())
}

var viewportClassStruct *gi.Struct
var viewportClassStruct_Once sync.Once

func viewportClassStruct_Set() error {
	var err error
	viewportClassStruct_Once.Do(func() {
		viewportClassStruct, err = gi.StructNew("Gtk", "ViewportClass")
	})
	return err
}

type ViewportClass struct {
	native unsafe.Pointer
}

func ViewportClassNewFromNative(native unsafe.Pointer) *ViewportClass {
	err := viewportClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ViewportClass{native: native}

	return instance
}

/*
CastToViewportClass down casts any arbitrary Object to ViewportClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a ViewportClass.
*/
func CastToViewportClass(object *gobject.Object) *ViewportClass {
	return ViewportClassNewFromNative(object.Native())
}

// Equals compares this ViewportClass with another ViewportClass, and returns true if they represent the same Object.
func (recv *ViewportClass) Equals(other *ViewportClass) bool {
	return other.Native() == recv.Native()
}

func (recv *ViewportClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *ViewportClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(viewportClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *ViewportClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(viewportClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// ViewportClassStruct creates an uninitialised ViewportClass.
func ViewportClassStruct() *ViewportClass {
	err := viewportClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ViewportClassNewFromNative(viewportClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeViewportClass)
	return structGo
}
func finalizeViewportClass(obj *ViewportClass) {
	viewportClassStruct.Free(obj.Native())
}

var viewportPrivateStruct *gi.Struct
var viewportPrivateStruct_Once sync.Once

func viewportPrivateStruct_Set() error {
	var err error
	viewportPrivateStruct_Once.Do(func() {
		viewportPrivateStruct, err = gi.StructNew("Gtk", "ViewportPrivate")
	})
	return err
}

type ViewportPrivate struct {
	native unsafe.Pointer
}

func ViewportPrivateNewFromNative(native unsafe.Pointer) *ViewportPrivate {
	err := viewportPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &ViewportPrivate{native: native}

	return instance
}

/*
CastToViewportPrivate down casts any arbitrary Object to ViewportPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a ViewportPrivate.
*/
func CastToViewportPrivate(object *gobject.Object) *ViewportPrivate {
	return ViewportPrivateNewFromNative(object.Native())
}

// Equals compares this ViewportPrivate with another ViewportPrivate, and returns true if they represent the same Object.
func (recv *ViewportPrivate) Equals(other *ViewportPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *ViewportPrivate) Native() unsafe.Pointer {
	return recv.native
}

// ViewportPrivateStruct creates an uninitialised ViewportPrivate.
func ViewportPrivateStruct() *ViewportPrivate {
	err := viewportPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := ViewportPrivateNewFromNative(viewportPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeViewportPrivate)
	return structGo
}
func finalizeViewportPrivate(obj *ViewportPrivate) {
	viewportPrivateStruct.Free(obj.Native())
}

var volumeButtonClassStruct *gi.Struct
var volumeButtonClassStruct_Once sync.Once

func volumeButtonClassStruct_Set() error {
	var err error
	volumeButtonClassStruct_Once.Do(func() {
		volumeButtonClassStruct, err = gi.StructNew("Gtk", "VolumeButtonClass")
	})
	return err
}

type VolumeButtonClass struct {
	native unsafe.Pointer
}

func VolumeButtonClassNewFromNative(native unsafe.Pointer) *VolumeButtonClass {
	err := volumeButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &VolumeButtonClass{native: native}

	return instance
}

/*
CastToVolumeButtonClass down casts any arbitrary Object to VolumeButtonClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a VolumeButtonClass.
*/
func CastToVolumeButtonClass(object *gobject.Object) *VolumeButtonClass {
	return VolumeButtonClassNewFromNative(object.Native())
}

// Equals compares this VolumeButtonClass with another VolumeButtonClass, and returns true if they represent the same Object.
func (recv *VolumeButtonClass) Equals(other *VolumeButtonClass) bool {
	return other.Native() == recv.Native()
}

func (recv *VolumeButtonClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *VolumeButtonClass) FieldParentClass() *ScaleButtonClass {
	argValue := gi.StructFieldGet(volumeButtonClassStruct, recv.Native(), "parent_class")
	value := ScaleButtonClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *VolumeButtonClass) SetFieldParentClass(value *ScaleButtonClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(volumeButtonClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// VolumeButtonClassStruct creates an uninitialised VolumeButtonClass.
func VolumeButtonClassStruct() *VolumeButtonClass {
	err := volumeButtonClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := VolumeButtonClassNewFromNative(volumeButtonClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeVolumeButtonClass)
	return structGo
}
func finalizeVolumeButtonClass(obj *VolumeButtonClass) {
	volumeButtonClassStruct.Free(obj.Native())
}

var widgetAccessibleClassStruct *gi.Struct
var widgetAccessibleClassStruct_Once sync.Once

func widgetAccessibleClassStruct_Set() error {
	var err error
	widgetAccessibleClassStruct_Once.Do(func() {
		widgetAccessibleClassStruct, err = gi.StructNew("Gtk", "WidgetAccessibleClass")
	})
	return err
}

type WidgetAccessibleClass struct {
	native unsafe.Pointer
}

func WidgetAccessibleClassNewFromNative(native unsafe.Pointer) *WidgetAccessibleClass {
	err := widgetAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WidgetAccessibleClass{native: native}

	return instance
}

/*
CastToWidgetAccessibleClass down casts any arbitrary Object to WidgetAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a WidgetAccessibleClass.
*/
func CastToWidgetAccessibleClass(object *gobject.Object) *WidgetAccessibleClass {
	return WidgetAccessibleClassNewFromNative(object.Native())
}

// Equals compares this WidgetAccessibleClass with another WidgetAccessibleClass, and returns true if they represent the same Object.
func (recv *WidgetAccessibleClass) Equals(other *WidgetAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *WidgetAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *WidgetAccessibleClass) FieldParentClass() *AccessibleClass {
	argValue := gi.StructFieldGet(widgetAccessibleClassStruct, recv.Native(), "parent_class")
	value := AccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *WidgetAccessibleClass) SetFieldParentClass(value *AccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(widgetAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'notify_gtk' : for field getter : missing Type

// UNSUPPORTED : C value 'notify_gtk' : for field setter : missing Type

// WidgetAccessibleClassStruct creates an uninitialised WidgetAccessibleClass.
func WidgetAccessibleClassStruct() *WidgetAccessibleClass {
	err := widgetAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WidgetAccessibleClassNewFromNative(widgetAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWidgetAccessibleClass)
	return structGo
}
func finalizeWidgetAccessibleClass(obj *WidgetAccessibleClass) {
	widgetAccessibleClassStruct.Free(obj.Native())
}

var widgetAccessiblePrivateStruct *gi.Struct
var widgetAccessiblePrivateStruct_Once sync.Once

func widgetAccessiblePrivateStruct_Set() error {
	var err error
	widgetAccessiblePrivateStruct_Once.Do(func() {
		widgetAccessiblePrivateStruct, err = gi.StructNew("Gtk", "WidgetAccessiblePrivate")
	})
	return err
}

type WidgetAccessiblePrivate struct {
	native unsafe.Pointer
}

func WidgetAccessiblePrivateNewFromNative(native unsafe.Pointer) *WidgetAccessiblePrivate {
	err := widgetAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WidgetAccessiblePrivate{native: native}

	return instance
}

/*
CastToWidgetAccessiblePrivate down casts any arbitrary Object to WidgetAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a WidgetAccessiblePrivate.
*/
func CastToWidgetAccessiblePrivate(object *gobject.Object) *WidgetAccessiblePrivate {
	return WidgetAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this WidgetAccessiblePrivate with another WidgetAccessiblePrivate, and returns true if they represent the same Object.
func (recv *WidgetAccessiblePrivate) Equals(other *WidgetAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *WidgetAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// WidgetAccessiblePrivateStruct creates an uninitialised WidgetAccessiblePrivate.
func WidgetAccessiblePrivateStruct() *WidgetAccessiblePrivate {
	err := widgetAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WidgetAccessiblePrivateNewFromNative(widgetAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWidgetAccessiblePrivate)
	return structGo
}
func finalizeWidgetAccessiblePrivate(obj *WidgetAccessiblePrivate) {
	widgetAccessiblePrivateStruct.Free(obj.Native())
}

var widgetClassStruct *gi.Struct
var widgetClassStruct_Once sync.Once

func widgetClassStruct_Set() error {
	var err error
	widgetClassStruct_Once.Do(func() {
		widgetClassStruct, err = gi.StructNew("Gtk", "WidgetClass")
	})
	return err
}

type WidgetClass struct {
	native unsafe.Pointer
}

func WidgetClassNewFromNative(native unsafe.Pointer) *WidgetClass {
	err := widgetClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WidgetClass{native: native}

	return instance
}

/*
CastToWidgetClass down casts any arbitrary Object to WidgetClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a WidgetClass.
*/
func CastToWidgetClass(object *gobject.Object) *WidgetClass {
	return WidgetClassNewFromNative(object.Native())
}

// Equals compares this WidgetClass with another WidgetClass, and returns true if they represent the same Object.
func (recv *WidgetClass) Equals(other *WidgetClass) bool {
	return other.Native() == recv.Native()
}

func (recv *WidgetClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *WidgetClass) FieldParentClass() *gobject.InitiallyUnownedClass {
	argValue := gi.StructFieldGet(widgetClassStruct, recv.Native(), "parent_class")
	value := gobject.InitiallyUnownedClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *WidgetClass) SetFieldParentClass(value *gobject.InitiallyUnownedClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(widgetClassStruct, recv.Native(), "parent_class", argValue)
}

// FieldActivateSignal returns the C field 'activate_signal'.
func (recv *WidgetClass) FieldActivateSignal() uint32 {
	argValue := gi.StructFieldGet(widgetClassStruct, recv.Native(), "activate_signal")
	value := argValue.Uint32()
	return value
}

// SetFieldActivateSignal sets the value of the C field 'activate_signal'.
func (recv *WidgetClass) SetFieldActivateSignal(value uint32) {
	var argValue gi.Argument
	argValue.SetUint32(value)
	gi.StructFieldSet(widgetClassStruct, recv.Native(), "activate_signal", argValue)
}

// UNSUPPORTED : C value 'dispatch_child_properties_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'dispatch_child_properties_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'destroy' : for field getter : missing Type

// UNSUPPORTED : C value 'destroy' : for field setter : missing Type

// UNSUPPORTED : C value 'show' : for field getter : missing Type

// UNSUPPORTED : C value 'show' : for field setter : missing Type

// UNSUPPORTED : C value 'show_all' : for field getter : missing Type

// UNSUPPORTED : C value 'show_all' : for field setter : missing Type

// UNSUPPORTED : C value 'hide' : for field getter : missing Type

// UNSUPPORTED : C value 'hide' : for field setter : missing Type

// UNSUPPORTED : C value 'map' : for field getter : missing Type

// UNSUPPORTED : C value 'map' : for field setter : missing Type

// UNSUPPORTED : C value 'unmap' : for field getter : missing Type

// UNSUPPORTED : C value 'unmap' : for field setter : missing Type

// UNSUPPORTED : C value 'realize' : for field getter : missing Type

// UNSUPPORTED : C value 'realize' : for field setter : missing Type

// UNSUPPORTED : C value 'unrealize' : for field getter : missing Type

// UNSUPPORTED : C value 'unrealize' : for field setter : missing Type

// UNSUPPORTED : C value 'size_allocate' : for field getter : missing Type

// UNSUPPORTED : C value 'size_allocate' : for field setter : missing Type

// UNSUPPORTED : C value 'state_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'state_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'state_flags_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'state_flags_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'parent_set' : for field getter : missing Type

// UNSUPPORTED : C value 'parent_set' : for field setter : missing Type

// UNSUPPORTED : C value 'hierarchy_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'hierarchy_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'style_set' : for field getter : missing Type

// UNSUPPORTED : C value 'style_set' : for field setter : missing Type

// UNSUPPORTED : C value 'direction_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'direction_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'grab_notify' : for field getter : missing Type

// UNSUPPORTED : C value 'grab_notify' : for field setter : missing Type

// UNSUPPORTED : C value 'child_notify' : for field getter : missing Type

// UNSUPPORTED : C value 'child_notify' : for field setter : missing Type

// UNSUPPORTED : C value 'draw' : for field getter : missing Type

// UNSUPPORTED : C value 'draw' : for field setter : missing Type

// UNSUPPORTED : C value 'get_request_mode' : for field getter : missing Type

// UNSUPPORTED : C value 'get_request_mode' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_height' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_height' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_width_for_height' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_width_for_height' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_width' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_width' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_for_width' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_for_width' : for field setter : missing Type

// UNSUPPORTED : C value 'mnemonic_activate' : for field getter : missing Type

// UNSUPPORTED : C value 'mnemonic_activate' : for field setter : missing Type

// UNSUPPORTED : C value 'grab_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'grab_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'focus' : for field getter : missing Type

// UNSUPPORTED : C value 'focus' : for field setter : missing Type

// UNSUPPORTED : C value 'move_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'move_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'keynav_failed' : for field getter : missing Type

// UNSUPPORTED : C value 'keynav_failed' : for field setter : missing Type

// UNSUPPORTED : C value 'event' : for field getter : missing Type

// UNSUPPORTED : C value 'event' : for field setter : missing Type

// UNSUPPORTED : C value 'button_press_event' : for field getter : missing Type

// UNSUPPORTED : C value 'button_press_event' : for field setter : missing Type

// UNSUPPORTED : C value 'button_release_event' : for field getter : missing Type

// UNSUPPORTED : C value 'button_release_event' : for field setter : missing Type

// UNSUPPORTED : C value 'scroll_event' : for field getter : missing Type

// UNSUPPORTED : C value 'scroll_event' : for field setter : missing Type

// UNSUPPORTED : C value 'motion_notify_event' : for field getter : missing Type

// UNSUPPORTED : C value 'motion_notify_event' : for field setter : missing Type

// UNSUPPORTED : C value 'delete_event' : for field getter : missing Type

// UNSUPPORTED : C value 'delete_event' : for field setter : missing Type

// UNSUPPORTED : C value 'destroy_event' : for field getter : missing Type

// UNSUPPORTED : C value 'destroy_event' : for field setter : missing Type

// UNSUPPORTED : C value 'key_press_event' : for field getter : missing Type

// UNSUPPORTED : C value 'key_press_event' : for field setter : missing Type

// UNSUPPORTED : C value 'key_release_event' : for field getter : missing Type

// UNSUPPORTED : C value 'key_release_event' : for field setter : missing Type

// UNSUPPORTED : C value 'enter_notify_event' : for field getter : missing Type

// UNSUPPORTED : C value 'enter_notify_event' : for field setter : missing Type

// UNSUPPORTED : C value 'leave_notify_event' : for field getter : missing Type

// UNSUPPORTED : C value 'leave_notify_event' : for field setter : missing Type

// UNSUPPORTED : C value 'configure_event' : for field getter : missing Type

// UNSUPPORTED : C value 'configure_event' : for field setter : missing Type

// UNSUPPORTED : C value 'focus_in_event' : for field getter : missing Type

// UNSUPPORTED : C value 'focus_in_event' : for field setter : missing Type

// UNSUPPORTED : C value 'focus_out_event' : for field getter : missing Type

// UNSUPPORTED : C value 'focus_out_event' : for field setter : missing Type

// UNSUPPORTED : C value 'map_event' : for field getter : missing Type

// UNSUPPORTED : C value 'map_event' : for field setter : missing Type

// UNSUPPORTED : C value 'unmap_event' : for field getter : missing Type

// UNSUPPORTED : C value 'unmap_event' : for field setter : missing Type

// UNSUPPORTED : C value 'property_notify_event' : for field getter : missing Type

// UNSUPPORTED : C value 'property_notify_event' : for field setter : missing Type

// UNSUPPORTED : C value 'selection_clear_event' : for field getter : missing Type

// UNSUPPORTED : C value 'selection_clear_event' : for field setter : missing Type

// UNSUPPORTED : C value 'selection_request_event' : for field getter : missing Type

// UNSUPPORTED : C value 'selection_request_event' : for field setter : missing Type

// UNSUPPORTED : C value 'selection_notify_event' : for field getter : missing Type

// UNSUPPORTED : C value 'selection_notify_event' : for field setter : missing Type

// UNSUPPORTED : C value 'proximity_in_event' : for field getter : missing Type

// UNSUPPORTED : C value 'proximity_in_event' : for field setter : missing Type

// UNSUPPORTED : C value 'proximity_out_event' : for field getter : missing Type

// UNSUPPORTED : C value 'proximity_out_event' : for field setter : missing Type

// UNSUPPORTED : C value 'visibility_notify_event' : for field getter : missing Type

// UNSUPPORTED : C value 'visibility_notify_event' : for field setter : missing Type

// UNSUPPORTED : C value 'window_state_event' : for field getter : missing Type

// UNSUPPORTED : C value 'window_state_event' : for field setter : missing Type

// UNSUPPORTED : C value 'damage_event' : for field getter : missing Type

// UNSUPPORTED : C value 'damage_event' : for field setter : missing Type

// UNSUPPORTED : C value 'grab_broken_event' : for field getter : missing Type

// UNSUPPORTED : C value 'grab_broken_event' : for field setter : missing Type

// UNSUPPORTED : C value 'selection_get' : for field getter : missing Type

// UNSUPPORTED : C value 'selection_get' : for field setter : missing Type

// UNSUPPORTED : C value 'selection_received' : for field getter : missing Type

// UNSUPPORTED : C value 'selection_received' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_begin' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_begin' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_end' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_end' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_data_get' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_data_get' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_data_delete' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_data_delete' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_leave' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_leave' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_motion' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_motion' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_drop' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_drop' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_data_received' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_data_received' : for field setter : missing Type

// UNSUPPORTED : C value 'drag_failed' : for field getter : missing Type

// UNSUPPORTED : C value 'drag_failed' : for field setter : missing Type

// UNSUPPORTED : C value 'popup_menu' : for field getter : missing Type

// UNSUPPORTED : C value 'popup_menu' : for field setter : missing Type

// UNSUPPORTED : C value 'show_help' : for field getter : missing Type

// UNSUPPORTED : C value 'show_help' : for field setter : missing Type

// UNSUPPORTED : C value 'get_accessible' : for field getter : missing Type

// UNSUPPORTED : C value 'get_accessible' : for field setter : missing Type

// UNSUPPORTED : C value 'screen_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'screen_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'can_activate_accel' : for field getter : missing Type

// UNSUPPORTED : C value 'can_activate_accel' : for field setter : missing Type

// UNSUPPORTED : C value 'composited_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'composited_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'query_tooltip' : for field getter : missing Type

// UNSUPPORTED : C value 'query_tooltip' : for field setter : missing Type

// UNSUPPORTED : C value 'compute_expand' : for field getter : missing Type

// UNSUPPORTED : C value 'compute_expand' : for field setter : missing Type

// UNSUPPORTED : C value 'adjust_size_request' : for field getter : missing Type

// UNSUPPORTED : C value 'adjust_size_request' : for field setter : missing Type

// UNSUPPORTED : C value 'adjust_size_allocation' : for field getter : missing Type

// UNSUPPORTED : C value 'adjust_size_allocation' : for field setter : missing Type

// UNSUPPORTED : C value 'style_updated' : for field getter : missing Type

// UNSUPPORTED : C value 'style_updated' : for field setter : missing Type

// UNSUPPORTED : C value 'touch_event' : for field getter : missing Type

// UNSUPPORTED : C value 'touch_event' : for field setter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_and_baseline_for_width' : for field getter : missing Type

// UNSUPPORTED : C value 'get_preferred_height_and_baseline_for_width' : for field setter : missing Type

// UNSUPPORTED : C value 'adjust_baseline_request' : for field getter : missing Type

// UNSUPPORTED : C value 'adjust_baseline_request' : for field setter : missing Type

// UNSUPPORTED : C value 'adjust_baseline_allocation' : for field getter : missing Type

// UNSUPPORTED : C value 'adjust_baseline_allocation' : for field setter : missing Type

// UNSUPPORTED : C value 'queue_draw_region' : for field getter : missing Type

// UNSUPPORTED : C value 'queue_draw_region' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved6' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved7' : for field setter : missing Type

// UNSUPPORTED : C value 'gtk_widget_class_bind_template_callback_full' : parameter 'callback_symbol' of type 'GObject.Callback' not supported

var widgetClassBindTemplateChildFullFunction *gi.Function
var widgetClassBindTemplateChildFullFunction_Once sync.Once

func widgetClassBindTemplateChildFullFunction_Set() error {
	var err error
	widgetClassBindTemplateChildFullFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassBindTemplateChildFullFunction, err = widgetClassStruct.InvokerNew("bind_template_child_full")
	})
	return err
}

// BindTemplateChildFull is a representation of the C type gtk_widget_class_bind_template_child_full.
func (recv *WidgetClass) BindTemplateChildFull(name string, internalChild bool, structOffset int32) {
	var inArgs [4]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(name)
	inArgs[2].SetBoolean(internalChild)
	inArgs[3].SetInt32(structOffset)

	err := widgetClassBindTemplateChildFullFunction_Set()
	if err == nil {
		widgetClassBindTemplateChildFullFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetClassFindStylePropertyFunction *gi.Function
var widgetClassFindStylePropertyFunction_Once sync.Once

func widgetClassFindStylePropertyFunction_Set() error {
	var err error
	widgetClassFindStylePropertyFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassFindStylePropertyFunction, err = widgetClassStruct.InvokerNew("find_style_property")
	})
	return err
}

// FindStyleProperty is a representation of the C type gtk_widget_class_find_style_property.
func (recv *WidgetClass) FindStyleProperty(propertyName string) *gobject.ParamSpec {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(propertyName)

	var ret gi.Argument

	err := widgetClassFindStylePropertyFunction_Set()
	if err == nil {
		ret = widgetClassFindStylePropertyFunction.Invoke(inArgs[:], nil)
	}

	retGo := gobject.ParamSpecNewFromNative(ret.Pointer())

	return retGo
}

var widgetClassGetCssNameFunction *gi.Function
var widgetClassGetCssNameFunction_Once sync.Once

func widgetClassGetCssNameFunction_Set() error {
	var err error
	widgetClassGetCssNameFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassGetCssNameFunction, err = widgetClassStruct.InvokerNew("get_css_name")
	})
	return err
}

// GetCssName is a representation of the C type gtk_widget_class_get_css_name.
func (recv *WidgetClass) GetCssName() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := widgetClassGetCssNameFunction_Set()
	if err == nil {
		ret = widgetClassGetCssNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var widgetClassInstallStylePropertyFunction *gi.Function
var widgetClassInstallStylePropertyFunction_Once sync.Once

func widgetClassInstallStylePropertyFunction_Set() error {
	var err error
	widgetClassInstallStylePropertyFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassInstallStylePropertyFunction, err = widgetClassStruct.InvokerNew("install_style_property")
	})
	return err
}

// InstallStyleProperty is a representation of the C type gtk_widget_class_install_style_property.
func (recv *WidgetClass) InstallStyleProperty(pspec *gobject.ParamSpec) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(pspec.Native())

	err := widgetClassInstallStylePropertyFunction_Set()
	if err == nil {
		widgetClassInstallStylePropertyFunction.Invoke(inArgs[:], nil)
	}

	return
}

// UNSUPPORTED : C value 'gtk_widget_class_install_style_property_parser' : parameter 'parser' of type 'RcPropertyParser' not supported

var widgetClassListStylePropertiesFunction *gi.Function
var widgetClassListStylePropertiesFunction_Once sync.Once

func widgetClassListStylePropertiesFunction_Set() error {
	var err error
	widgetClassListStylePropertiesFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassListStylePropertiesFunction, err = widgetClassStruct.InvokerNew("list_style_properties")
	})
	return err
}

// ListStyleProperties is a representation of the C type gtk_widget_class_list_style_properties.
func (recv *WidgetClass) ListStyleProperties() uint32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var outArgs [1]gi.Argument

	err := widgetClassListStylePropertiesFunction_Set()
	if err == nil {
		widgetClassListStylePropertiesFunction.Invoke(inArgs[:], outArgs[:])
	}

	out0 := outArgs[0].Uint32()

	return out0
}

// UNSUPPORTED : C value 'gtk_widget_class_set_accessible_role' : parameter 'role' of type 'Atk.Role' not supported

var widgetClassSetAccessibleTypeFunction *gi.Function
var widgetClassSetAccessibleTypeFunction_Once sync.Once

func widgetClassSetAccessibleTypeFunction_Set() error {
	var err error
	widgetClassSetAccessibleTypeFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassSetAccessibleTypeFunction, err = widgetClassStruct.InvokerNew("set_accessible_type")
	})
	return err
}

// SetAccessibleType is a representation of the C type gtk_widget_class_set_accessible_type.
func (recv *WidgetClass) SetAccessibleType(type_ int64) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt64(type_)

	err := widgetClassSetAccessibleTypeFunction_Set()
	if err == nil {
		widgetClassSetAccessibleTypeFunction.Invoke(inArgs[:], nil)
	}

	return
}

// UNSUPPORTED : C value 'gtk_widget_class_set_connect_func' : parameter 'connect_func' of type 'BuilderConnectFunc' not supported

var widgetClassSetCssNameFunction *gi.Function
var widgetClassSetCssNameFunction_Once sync.Once

func widgetClassSetCssNameFunction_Set() error {
	var err error
	widgetClassSetCssNameFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassSetCssNameFunction, err = widgetClassStruct.InvokerNew("set_css_name")
	})
	return err
}

// SetCssName is a representation of the C type gtk_widget_class_set_css_name.
func (recv *WidgetClass) SetCssName(name string) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(name)

	err := widgetClassSetCssNameFunction_Set()
	if err == nil {
		widgetClassSetCssNameFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetClassSetTemplateFunction *gi.Function
var widgetClassSetTemplateFunction_Once sync.Once

func widgetClassSetTemplateFunction_Set() error {
	var err error
	widgetClassSetTemplateFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassSetTemplateFunction, err = widgetClassStruct.InvokerNew("set_template")
	})
	return err
}

// SetTemplate is a representation of the C type gtk_widget_class_set_template.
func (recv *WidgetClass) SetTemplate(templateBytes *glib.Bytes) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(templateBytes.Native())

	err := widgetClassSetTemplateFunction_Set()
	if err == nil {
		widgetClassSetTemplateFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetClassSetTemplateFromResourceFunction *gi.Function
var widgetClassSetTemplateFromResourceFunction_Once sync.Once

func widgetClassSetTemplateFromResourceFunction_Set() error {
	var err error
	widgetClassSetTemplateFromResourceFunction_Once.Do(func() {
		err = widgetClassStruct_Set()
		if err != nil {
			return
		}
		widgetClassSetTemplateFromResourceFunction, err = widgetClassStruct.InvokerNew("set_template_from_resource")
	})
	return err
}

// SetTemplateFromResource is a representation of the C type gtk_widget_class_set_template_from_resource.
func (recv *WidgetClass) SetTemplateFromResource(resourceName string) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetString(resourceName)

	err := widgetClassSetTemplateFromResourceFunction_Set()
	if err == nil {
		widgetClassSetTemplateFromResourceFunction.Invoke(inArgs[:], nil)
	}

	return
}

// WidgetClassStruct creates an uninitialised WidgetClass.
func WidgetClassStruct() *WidgetClass {
	err := widgetClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WidgetClassNewFromNative(widgetClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWidgetClass)
	return structGo
}
func finalizeWidgetClass(obj *WidgetClass) {
	widgetClassStruct.Free(obj.Native())
}

var widgetClassPrivateStruct *gi.Struct
var widgetClassPrivateStruct_Once sync.Once

func widgetClassPrivateStruct_Set() error {
	var err error
	widgetClassPrivateStruct_Once.Do(func() {
		widgetClassPrivateStruct, err = gi.StructNew("Gtk", "WidgetClassPrivate")
	})
	return err
}

type WidgetClassPrivate struct {
	native unsafe.Pointer
}

func WidgetClassPrivateNewFromNative(native unsafe.Pointer) *WidgetClassPrivate {
	err := widgetClassPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WidgetClassPrivate{native: native}

	return instance
}

/*
CastToWidgetClassPrivate down casts any arbitrary Object to WidgetClassPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a WidgetClassPrivate.
*/
func CastToWidgetClassPrivate(object *gobject.Object) *WidgetClassPrivate {
	return WidgetClassPrivateNewFromNative(object.Native())
}

// Equals compares this WidgetClassPrivate with another WidgetClassPrivate, and returns true if they represent the same Object.
func (recv *WidgetClassPrivate) Equals(other *WidgetClassPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *WidgetClassPrivate) Native() unsafe.Pointer {
	return recv.native
}

// WidgetClassPrivateStruct creates an uninitialised WidgetClassPrivate.
func WidgetClassPrivateStruct() *WidgetClassPrivate {
	err := widgetClassPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WidgetClassPrivateNewFromNative(widgetClassPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWidgetClassPrivate)
	return structGo
}
func finalizeWidgetClassPrivate(obj *WidgetClassPrivate) {
	widgetClassPrivateStruct.Free(obj.Native())
}

var widgetPathStruct *gi.Struct
var widgetPathStruct_Once sync.Once

func widgetPathStruct_Set() error {
	var err error
	widgetPathStruct_Once.Do(func() {
		widgetPathStruct, err = gi.StructNew("Gtk", "WidgetPath")
	})
	return err
}

type WidgetPath struct {
	native unsafe.Pointer
}

func WidgetPathNewFromNative(native unsafe.Pointer) *WidgetPath {
	err := widgetPathStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WidgetPath{native: native}

	return instance
}

/*
CastToWidgetPath down casts any arbitrary Object to WidgetPath.
Exercise care, as this is a potentially dangerous function
if the Object is not a WidgetPath.
*/
func CastToWidgetPath(object *gobject.Object) *WidgetPath {
	return WidgetPathNewFromNative(object.Native())
}

// Equals compares this WidgetPath with another WidgetPath, and returns true if they represent the same Object.
func (recv *WidgetPath) Equals(other *WidgetPath) bool {
	return other.Native() == recv.Native()
}

func (recv *WidgetPath) Native() unsafe.Pointer {
	return recv.native
}

var widgetPathNewFunction *gi.Function
var widgetPathNewFunction_Once sync.Once

func widgetPathNewFunction_Set() error {
	var err error
	widgetPathNewFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathNewFunction, err = widgetPathStruct.InvokerNew("new")
	})
	return err
}

// WidgetPathNew is a representation of the C type gtk_widget_path_new.
func WidgetPathNew() *WidgetPath {

	var ret gi.Argument

	err := widgetPathNewFunction_Set()
	if err == nil {
		ret = widgetPathNewFunction.Invoke(nil, nil)
	}

	retGo := WidgetPathNewFromNative(ret.Pointer())

	return retGo
}

var widgetPathAppendForWidgetFunction *gi.Function
var widgetPathAppendForWidgetFunction_Once sync.Once

func widgetPathAppendForWidgetFunction_Set() error {
	var err error
	widgetPathAppendForWidgetFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathAppendForWidgetFunction, err = widgetPathStruct.InvokerNew("append_for_widget")
	})
	return err
}

// AppendForWidget is a representation of the C type gtk_widget_path_append_for_widget.
func (recv *WidgetPath) AppendForWidget(widget *Widget) int32 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(widget.Native())

	var ret gi.Argument

	err := widgetPathAppendForWidgetFunction_Set()
	if err == nil {
		ret = widgetPathAppendForWidgetFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var widgetPathAppendTypeFunction *gi.Function
var widgetPathAppendTypeFunction_Once sync.Once

func widgetPathAppendTypeFunction_Set() error {
	var err error
	widgetPathAppendTypeFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathAppendTypeFunction, err = widgetPathStruct.InvokerNew("append_type")
	})
	return err
}

// AppendType is a representation of the C type gtk_widget_path_append_type.
func (recv *WidgetPath) AppendType(type_ int64) int32 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt64(type_)

	var ret gi.Argument

	err := widgetPathAppendTypeFunction_Set()
	if err == nil {
		ret = widgetPathAppendTypeFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var widgetPathAppendWithSiblingsFunction *gi.Function
var widgetPathAppendWithSiblingsFunction_Once sync.Once

func widgetPathAppendWithSiblingsFunction_Set() error {
	var err error
	widgetPathAppendWithSiblingsFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathAppendWithSiblingsFunction, err = widgetPathStruct.InvokerNew("append_with_siblings")
	})
	return err
}

// AppendWithSiblings is a representation of the C type gtk_widget_path_append_with_siblings.
func (recv *WidgetPath) AppendWithSiblings(siblings *WidgetPath, siblingIndex uint32) int32 {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetPointer(siblings.Native())
	inArgs[2].SetUint32(siblingIndex)

	var ret gi.Argument

	err := widgetPathAppendWithSiblingsFunction_Set()
	if err == nil {
		ret = widgetPathAppendWithSiblingsFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var widgetPathCopyFunction *gi.Function
var widgetPathCopyFunction_Once sync.Once

func widgetPathCopyFunction_Set() error {
	var err error
	widgetPathCopyFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathCopyFunction, err = widgetPathStruct.InvokerNew("copy")
	})
	return err
}

// Copy is a representation of the C type gtk_widget_path_copy.
func (recv *WidgetPath) Copy() *WidgetPath {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := widgetPathCopyFunction_Set()
	if err == nil {
		ret = widgetPathCopyFunction.Invoke(inArgs[:], nil)
	}

	retGo := WidgetPathNewFromNative(ret.Pointer())

	return retGo
}

var widgetPathFreeFunction *gi.Function
var widgetPathFreeFunction_Once sync.Once

func widgetPathFreeFunction_Set() error {
	var err error
	widgetPathFreeFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathFreeFunction, err = widgetPathStruct.InvokerNew("free")
	})
	return err
}

// Free is a representation of the C type gtk_widget_path_free.
func (recv *WidgetPath) Free() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := widgetPathFreeFunction_Set()
	if err == nil {
		widgetPathFreeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathGetObjectTypeFunction *gi.Function
var widgetPathGetObjectTypeFunction_Once sync.Once

func widgetPathGetObjectTypeFunction_Set() error {
	var err error
	widgetPathGetObjectTypeFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathGetObjectTypeFunction, err = widgetPathStruct.InvokerNew("get_object_type")
	})
	return err
}

// GetObjectType is a representation of the C type gtk_widget_path_get_object_type.
func (recv *WidgetPath) GetObjectType() int64 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := widgetPathGetObjectTypeFunction_Set()
	if err == nil {
		ret = widgetPathGetObjectTypeFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int64()

	return retGo
}

var widgetPathHasParentFunction *gi.Function
var widgetPathHasParentFunction_Once sync.Once

func widgetPathHasParentFunction_Set() error {
	var err error
	widgetPathHasParentFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathHasParentFunction, err = widgetPathStruct.InvokerNew("has_parent")
	})
	return err
}

// HasParent is a representation of the C type gtk_widget_path_has_parent.
func (recv *WidgetPath) HasParent(type_ int64) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt64(type_)

	var ret gi.Argument

	err := widgetPathHasParentFunction_Set()
	if err == nil {
		ret = widgetPathHasParentFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var widgetPathIsTypeFunction *gi.Function
var widgetPathIsTypeFunction_Once sync.Once

func widgetPathIsTypeFunction_Set() error {
	var err error
	widgetPathIsTypeFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIsTypeFunction, err = widgetPathStruct.InvokerNew("is_type")
	})
	return err
}

// IsType is a representation of the C type gtk_widget_path_is_type.
func (recv *WidgetPath) IsType(type_ int64) bool {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt64(type_)

	var ret gi.Argument

	err := widgetPathIsTypeFunction_Set()
	if err == nil {
		ret = widgetPathIsTypeFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var widgetPathIterAddClassFunction *gi.Function
var widgetPathIterAddClassFunction_Once sync.Once

func widgetPathIterAddClassFunction_Set() error {
	var err error
	widgetPathIterAddClassFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterAddClassFunction, err = widgetPathStruct.InvokerNew("iter_add_class")
	})
	return err
}

// IterAddClass is a representation of the C type gtk_widget_path_iter_add_class.
func (recv *WidgetPath) IterAddClass(pos int32, name string) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)

	err := widgetPathIterAddClassFunction_Set()
	if err == nil {
		widgetPathIterAddClassFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterAddRegionFunction *gi.Function
var widgetPathIterAddRegionFunction_Once sync.Once

func widgetPathIterAddRegionFunction_Set() error {
	var err error
	widgetPathIterAddRegionFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterAddRegionFunction, err = widgetPathStruct.InvokerNew("iter_add_region")
	})
	return err
}

// IterAddRegion is a representation of the C type gtk_widget_path_iter_add_region.
func (recv *WidgetPath) IterAddRegion(pos int32, name string, flags RegionFlags) {
	var inArgs [4]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)
	inArgs[3].SetInt32(int32(flags))

	err := widgetPathIterAddRegionFunction_Set()
	if err == nil {
		widgetPathIterAddRegionFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterClearClassesFunction *gi.Function
var widgetPathIterClearClassesFunction_Once sync.Once

func widgetPathIterClearClassesFunction_Set() error {
	var err error
	widgetPathIterClearClassesFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterClearClassesFunction, err = widgetPathStruct.InvokerNew("iter_clear_classes")
	})
	return err
}

// IterClearClasses is a representation of the C type gtk_widget_path_iter_clear_classes.
func (recv *WidgetPath) IterClearClasses(pos int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	err := widgetPathIterClearClassesFunction_Set()
	if err == nil {
		widgetPathIterClearClassesFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterClearRegionsFunction *gi.Function
var widgetPathIterClearRegionsFunction_Once sync.Once

func widgetPathIterClearRegionsFunction_Set() error {
	var err error
	widgetPathIterClearRegionsFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterClearRegionsFunction, err = widgetPathStruct.InvokerNew("iter_clear_regions")
	})
	return err
}

// IterClearRegions is a representation of the C type gtk_widget_path_iter_clear_regions.
func (recv *WidgetPath) IterClearRegions(pos int32) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	err := widgetPathIterClearRegionsFunction_Set()
	if err == nil {
		widgetPathIterClearRegionsFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterGetNameFunction *gi.Function
var widgetPathIterGetNameFunction_Once sync.Once

func widgetPathIterGetNameFunction_Set() error {
	var err error
	widgetPathIterGetNameFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterGetNameFunction, err = widgetPathStruct.InvokerNew("iter_get_name")
	})
	return err
}

// IterGetName is a representation of the C type gtk_widget_path_iter_get_name.
func (recv *WidgetPath) IterGetName(pos int32) string {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	var ret gi.Argument

	err := widgetPathIterGetNameFunction_Set()
	if err == nil {
		ret = widgetPathIterGetNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var widgetPathIterGetObjectNameFunction *gi.Function
var widgetPathIterGetObjectNameFunction_Once sync.Once

func widgetPathIterGetObjectNameFunction_Set() error {
	var err error
	widgetPathIterGetObjectNameFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterGetObjectNameFunction, err = widgetPathStruct.InvokerNew("iter_get_object_name")
	})
	return err
}

// IterGetObjectName is a representation of the C type gtk_widget_path_iter_get_object_name.
func (recv *WidgetPath) IterGetObjectName(pos int32) string {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	var ret gi.Argument

	err := widgetPathIterGetObjectNameFunction_Set()
	if err == nil {
		ret = widgetPathIterGetObjectNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(false)

	return retGo
}

var widgetPathIterGetObjectTypeFunction *gi.Function
var widgetPathIterGetObjectTypeFunction_Once sync.Once

func widgetPathIterGetObjectTypeFunction_Set() error {
	var err error
	widgetPathIterGetObjectTypeFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterGetObjectTypeFunction, err = widgetPathStruct.InvokerNew("iter_get_object_type")
	})
	return err
}

// IterGetObjectType is a representation of the C type gtk_widget_path_iter_get_object_type.
func (recv *WidgetPath) IterGetObjectType(pos int32) int64 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	var ret gi.Argument

	err := widgetPathIterGetObjectTypeFunction_Set()
	if err == nil {
		ret = widgetPathIterGetObjectTypeFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int64()

	return retGo
}

var widgetPathIterGetSiblingIndexFunction *gi.Function
var widgetPathIterGetSiblingIndexFunction_Once sync.Once

func widgetPathIterGetSiblingIndexFunction_Set() error {
	var err error
	widgetPathIterGetSiblingIndexFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterGetSiblingIndexFunction, err = widgetPathStruct.InvokerNew("iter_get_sibling_index")
	})
	return err
}

// IterGetSiblingIndex is a representation of the C type gtk_widget_path_iter_get_sibling_index.
func (recv *WidgetPath) IterGetSiblingIndex(pos int32) uint32 {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	var ret gi.Argument

	err := widgetPathIterGetSiblingIndexFunction_Set()
	if err == nil {
		ret = widgetPathIterGetSiblingIndexFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Uint32()

	return retGo
}

var widgetPathIterGetSiblingsFunction *gi.Function
var widgetPathIterGetSiblingsFunction_Once sync.Once

func widgetPathIterGetSiblingsFunction_Set() error {
	var err error
	widgetPathIterGetSiblingsFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterGetSiblingsFunction, err = widgetPathStruct.InvokerNew("iter_get_siblings")
	})
	return err
}

// IterGetSiblings is a representation of the C type gtk_widget_path_iter_get_siblings.
func (recv *WidgetPath) IterGetSiblings(pos int32) *WidgetPath {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	var ret gi.Argument

	err := widgetPathIterGetSiblingsFunction_Set()
	if err == nil {
		ret = widgetPathIterGetSiblingsFunction.Invoke(inArgs[:], nil)
	}

	retGo := WidgetPathNewFromNative(ret.Pointer())

	return retGo
}

var widgetPathIterGetStateFunction *gi.Function
var widgetPathIterGetStateFunction_Once sync.Once

func widgetPathIterGetStateFunction_Set() error {
	var err error
	widgetPathIterGetStateFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterGetStateFunction, err = widgetPathStruct.InvokerNew("iter_get_state")
	})
	return err
}

// IterGetState is a representation of the C type gtk_widget_path_iter_get_state.
func (recv *WidgetPath) IterGetState(pos int32) StateFlags {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	var ret gi.Argument

	err := widgetPathIterGetStateFunction_Set()
	if err == nil {
		ret = widgetPathIterGetStateFunction.Invoke(inArgs[:], nil)
	}

	retGo := StateFlags(ret.Int32())

	return retGo
}

var widgetPathIterHasClassFunction *gi.Function
var widgetPathIterHasClassFunction_Once sync.Once

func widgetPathIterHasClassFunction_Set() error {
	var err error
	widgetPathIterHasClassFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterHasClassFunction, err = widgetPathStruct.InvokerNew("iter_has_class")
	})
	return err
}

// IterHasClass is a representation of the C type gtk_widget_path_iter_has_class.
func (recv *WidgetPath) IterHasClass(pos int32, name string) bool {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)

	var ret gi.Argument

	err := widgetPathIterHasClassFunction_Set()
	if err == nil {
		ret = widgetPathIterHasClassFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var widgetPathIterHasNameFunction *gi.Function
var widgetPathIterHasNameFunction_Once sync.Once

func widgetPathIterHasNameFunction_Set() error {
	var err error
	widgetPathIterHasNameFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterHasNameFunction, err = widgetPathStruct.InvokerNew("iter_has_name")
	})
	return err
}

// IterHasName is a representation of the C type gtk_widget_path_iter_has_name.
func (recv *WidgetPath) IterHasName(pos int32, name string) bool {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)

	var ret gi.Argument

	err := widgetPathIterHasNameFunction_Set()
	if err == nil {
		ret = widgetPathIterHasNameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var widgetPathIterHasQclassFunction *gi.Function
var widgetPathIterHasQclassFunction_Once sync.Once

func widgetPathIterHasQclassFunction_Set() error {
	var err error
	widgetPathIterHasQclassFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterHasQclassFunction, err = widgetPathStruct.InvokerNew("iter_has_qclass")
	})
	return err
}

// IterHasQclass is a representation of the C type gtk_widget_path_iter_has_qclass.
func (recv *WidgetPath) IterHasQclass(pos int32, qname glib.Quark) bool {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetUint32(uint32(qname))

	var ret gi.Argument

	err := widgetPathIterHasQclassFunction_Set()
	if err == nil {
		ret = widgetPathIterHasQclassFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var widgetPathIterHasQnameFunction *gi.Function
var widgetPathIterHasQnameFunction_Once sync.Once

func widgetPathIterHasQnameFunction_Set() error {
	var err error
	widgetPathIterHasQnameFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterHasQnameFunction, err = widgetPathStruct.InvokerNew("iter_has_qname")
	})
	return err
}

// IterHasQname is a representation of the C type gtk_widget_path_iter_has_qname.
func (recv *WidgetPath) IterHasQname(pos int32, qname glib.Quark) bool {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetUint32(uint32(qname))

	var ret gi.Argument

	err := widgetPathIterHasQnameFunction_Set()
	if err == nil {
		ret = widgetPathIterHasQnameFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Boolean()

	return retGo
}

var widgetPathIterHasQregionFunction *gi.Function
var widgetPathIterHasQregionFunction_Once sync.Once

func widgetPathIterHasQregionFunction_Set() error {
	var err error
	widgetPathIterHasQregionFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterHasQregionFunction, err = widgetPathStruct.InvokerNew("iter_has_qregion")
	})
	return err
}

// IterHasQregion is a representation of the C type gtk_widget_path_iter_has_qregion.
func (recv *WidgetPath) IterHasQregion(pos int32, qname glib.Quark) (bool, RegionFlags) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetUint32(uint32(qname))

	var outArgs [1]gi.Argument
	var ret gi.Argument

	err := widgetPathIterHasQregionFunction_Set()
	if err == nil {
		ret = widgetPathIterHasQregionFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := RegionFlags(outArgs[0].Int32())

	return retGo, out0
}

var widgetPathIterHasRegionFunction *gi.Function
var widgetPathIterHasRegionFunction_Once sync.Once

func widgetPathIterHasRegionFunction_Set() error {
	var err error
	widgetPathIterHasRegionFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterHasRegionFunction, err = widgetPathStruct.InvokerNew("iter_has_region")
	})
	return err
}

// IterHasRegion is a representation of the C type gtk_widget_path_iter_has_region.
func (recv *WidgetPath) IterHasRegion(pos int32, name string) (bool, RegionFlags) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)

	var outArgs [1]gi.Argument
	var ret gi.Argument

	err := widgetPathIterHasRegionFunction_Set()
	if err == nil {
		ret = widgetPathIterHasRegionFunction.Invoke(inArgs[:], outArgs[:])
	}

	retGo := ret.Boolean()
	out0 := RegionFlags(outArgs[0].Int32())

	return retGo, out0
}

var widgetPathIterListClassesFunction *gi.Function
var widgetPathIterListClassesFunction_Once sync.Once

func widgetPathIterListClassesFunction_Set() error {
	var err error
	widgetPathIterListClassesFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterListClassesFunction, err = widgetPathStruct.InvokerNew("iter_list_classes")
	})
	return err
}

// IterListClasses is a representation of the C type gtk_widget_path_iter_list_classes.
func (recv *WidgetPath) IterListClasses(pos int32) *glib.SList {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	var ret gi.Argument

	err := widgetPathIterListClassesFunction_Set()
	if err == nil {
		ret = widgetPathIterListClassesFunction.Invoke(inArgs[:], nil)
	}

	retGo := glib.SListNewFromNative(ret.Pointer())

	return retGo
}

var widgetPathIterListRegionsFunction *gi.Function
var widgetPathIterListRegionsFunction_Once sync.Once

func widgetPathIterListRegionsFunction_Set() error {
	var err error
	widgetPathIterListRegionsFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterListRegionsFunction, err = widgetPathStruct.InvokerNew("iter_list_regions")
	})
	return err
}

// IterListRegions is a representation of the C type gtk_widget_path_iter_list_regions.
func (recv *WidgetPath) IterListRegions(pos int32) *glib.SList {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)

	var ret gi.Argument

	err := widgetPathIterListRegionsFunction_Set()
	if err == nil {
		ret = widgetPathIterListRegionsFunction.Invoke(inArgs[:], nil)
	}

	retGo := glib.SListNewFromNative(ret.Pointer())

	return retGo
}

var widgetPathIterRemoveClassFunction *gi.Function
var widgetPathIterRemoveClassFunction_Once sync.Once

func widgetPathIterRemoveClassFunction_Set() error {
	var err error
	widgetPathIterRemoveClassFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterRemoveClassFunction, err = widgetPathStruct.InvokerNew("iter_remove_class")
	})
	return err
}

// IterRemoveClass is a representation of the C type gtk_widget_path_iter_remove_class.
func (recv *WidgetPath) IterRemoveClass(pos int32, name string) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)

	err := widgetPathIterRemoveClassFunction_Set()
	if err == nil {
		widgetPathIterRemoveClassFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterRemoveRegionFunction *gi.Function
var widgetPathIterRemoveRegionFunction_Once sync.Once

func widgetPathIterRemoveRegionFunction_Set() error {
	var err error
	widgetPathIterRemoveRegionFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterRemoveRegionFunction, err = widgetPathStruct.InvokerNew("iter_remove_region")
	})
	return err
}

// IterRemoveRegion is a representation of the C type gtk_widget_path_iter_remove_region.
func (recv *WidgetPath) IterRemoveRegion(pos int32, name string) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)

	err := widgetPathIterRemoveRegionFunction_Set()
	if err == nil {
		widgetPathIterRemoveRegionFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterSetNameFunction *gi.Function
var widgetPathIterSetNameFunction_Once sync.Once

func widgetPathIterSetNameFunction_Set() error {
	var err error
	widgetPathIterSetNameFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterSetNameFunction, err = widgetPathStruct.InvokerNew("iter_set_name")
	})
	return err
}

// IterSetName is a representation of the C type gtk_widget_path_iter_set_name.
func (recv *WidgetPath) IterSetName(pos int32, name string) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)

	err := widgetPathIterSetNameFunction_Set()
	if err == nil {
		widgetPathIterSetNameFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterSetObjectNameFunction *gi.Function
var widgetPathIterSetObjectNameFunction_Once sync.Once

func widgetPathIterSetObjectNameFunction_Set() error {
	var err error
	widgetPathIterSetObjectNameFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterSetObjectNameFunction, err = widgetPathStruct.InvokerNew("iter_set_object_name")
	})
	return err
}

// IterSetObjectName is a representation of the C type gtk_widget_path_iter_set_object_name.
func (recv *WidgetPath) IterSetObjectName(pos int32, name string) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetString(name)

	err := widgetPathIterSetObjectNameFunction_Set()
	if err == nil {
		widgetPathIterSetObjectNameFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterSetObjectTypeFunction *gi.Function
var widgetPathIterSetObjectTypeFunction_Once sync.Once

func widgetPathIterSetObjectTypeFunction_Set() error {
	var err error
	widgetPathIterSetObjectTypeFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterSetObjectTypeFunction, err = widgetPathStruct.InvokerNew("iter_set_object_type")
	})
	return err
}

// IterSetObjectType is a representation of the C type gtk_widget_path_iter_set_object_type.
func (recv *WidgetPath) IterSetObjectType(pos int32, type_ int64) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetInt64(type_)

	err := widgetPathIterSetObjectTypeFunction_Set()
	if err == nil {
		widgetPathIterSetObjectTypeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathIterSetStateFunction *gi.Function
var widgetPathIterSetStateFunction_Once sync.Once

func widgetPathIterSetStateFunction_Set() error {
	var err error
	widgetPathIterSetStateFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathIterSetStateFunction, err = widgetPathStruct.InvokerNew("iter_set_state")
	})
	return err
}

// IterSetState is a representation of the C type gtk_widget_path_iter_set_state.
func (recv *WidgetPath) IterSetState(pos int32, state StateFlags) {
	var inArgs [3]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt32(pos)
	inArgs[2].SetInt32(int32(state))

	err := widgetPathIterSetStateFunction_Set()
	if err == nil {
		widgetPathIterSetStateFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathLengthFunction *gi.Function
var widgetPathLengthFunction_Once sync.Once

func widgetPathLengthFunction_Set() error {
	var err error
	widgetPathLengthFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathLengthFunction, err = widgetPathStruct.InvokerNew("length")
	})
	return err
}

// Length is a representation of the C type gtk_widget_path_length.
func (recv *WidgetPath) Length() int32 {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := widgetPathLengthFunction_Set()
	if err == nil {
		ret = widgetPathLengthFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.Int32()

	return retGo
}

var widgetPathPrependTypeFunction *gi.Function
var widgetPathPrependTypeFunction_Once sync.Once

func widgetPathPrependTypeFunction_Set() error {
	var err error
	widgetPathPrependTypeFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathPrependTypeFunction, err = widgetPathStruct.InvokerNew("prepend_type")
	})
	return err
}

// PrependType is a representation of the C type gtk_widget_path_prepend_type.
func (recv *WidgetPath) PrependType(type_ int64) {
	var inArgs [2]gi.Argument
	inArgs[0].SetPointer(recv.Native())
	inArgs[1].SetInt64(type_)

	err := widgetPathPrependTypeFunction_Set()
	if err == nil {
		widgetPathPrependTypeFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPathRefFunction *gi.Function
var widgetPathRefFunction_Once sync.Once

func widgetPathRefFunction_Set() error {
	var err error
	widgetPathRefFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathRefFunction, err = widgetPathStruct.InvokerNew("ref")
	})
	return err
}

// Ref is a representation of the C type gtk_widget_path_ref.
func (recv *WidgetPath) Ref() *WidgetPath {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := widgetPathRefFunction_Set()
	if err == nil {
		ret = widgetPathRefFunction.Invoke(inArgs[:], nil)
	}

	retGo := WidgetPathNewFromNative(ret.Pointer())

	return retGo
}

var widgetPathToStringFunction *gi.Function
var widgetPathToStringFunction_Once sync.Once

func widgetPathToStringFunction_Set() error {
	var err error
	widgetPathToStringFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathToStringFunction, err = widgetPathStruct.InvokerNew("to_string")
	})
	return err
}

// ToString is a representation of the C type gtk_widget_path_to_string.
func (recv *WidgetPath) ToString() string {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	var ret gi.Argument

	err := widgetPathToStringFunction_Set()
	if err == nil {
		ret = widgetPathToStringFunction.Invoke(inArgs[:], nil)
	}

	retGo := ret.String(true)

	return retGo
}

var widgetPathUnrefFunction *gi.Function
var widgetPathUnrefFunction_Once sync.Once

func widgetPathUnrefFunction_Set() error {
	var err error
	widgetPathUnrefFunction_Once.Do(func() {
		err = widgetPathStruct_Set()
		if err != nil {
			return
		}
		widgetPathUnrefFunction, err = widgetPathStruct.InvokerNew("unref")
	})
	return err
}

// Unref is a representation of the C type gtk_widget_path_unref.
func (recv *WidgetPath) Unref() {
	var inArgs [1]gi.Argument
	inArgs[0].SetPointer(recv.Native())

	err := widgetPathUnrefFunction_Set()
	if err == nil {
		widgetPathUnrefFunction.Invoke(inArgs[:], nil)
	}

	return
}

var widgetPrivateStruct *gi.Struct
var widgetPrivateStruct_Once sync.Once

func widgetPrivateStruct_Set() error {
	var err error
	widgetPrivateStruct_Once.Do(func() {
		widgetPrivateStruct, err = gi.StructNew("Gtk", "WidgetPrivate")
	})
	return err
}

type WidgetPrivate struct {
	native unsafe.Pointer
}

func WidgetPrivateNewFromNative(native unsafe.Pointer) *WidgetPrivate {
	err := widgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WidgetPrivate{native: native}

	return instance
}

/*
CastToWidgetPrivate down casts any arbitrary Object to WidgetPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a WidgetPrivate.
*/
func CastToWidgetPrivate(object *gobject.Object) *WidgetPrivate {
	return WidgetPrivateNewFromNative(object.Native())
}

// Equals compares this WidgetPrivate with another WidgetPrivate, and returns true if they represent the same Object.
func (recv *WidgetPrivate) Equals(other *WidgetPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *WidgetPrivate) Native() unsafe.Pointer {
	return recv.native
}

// WidgetPrivateStruct creates an uninitialised WidgetPrivate.
func WidgetPrivateStruct() *WidgetPrivate {
	err := widgetPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WidgetPrivateNewFromNative(widgetPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWidgetPrivate)
	return structGo
}
func finalizeWidgetPrivate(obj *WidgetPrivate) {
	widgetPrivateStruct.Free(obj.Native())
}

var windowAccessibleClassStruct *gi.Struct
var windowAccessibleClassStruct_Once sync.Once

func windowAccessibleClassStruct_Set() error {
	var err error
	windowAccessibleClassStruct_Once.Do(func() {
		windowAccessibleClassStruct, err = gi.StructNew("Gtk", "WindowAccessibleClass")
	})
	return err
}

type WindowAccessibleClass struct {
	native unsafe.Pointer
}

func WindowAccessibleClassNewFromNative(native unsafe.Pointer) *WindowAccessibleClass {
	err := windowAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WindowAccessibleClass{native: native}

	return instance
}

/*
CastToWindowAccessibleClass down casts any arbitrary Object to WindowAccessibleClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a WindowAccessibleClass.
*/
func CastToWindowAccessibleClass(object *gobject.Object) *WindowAccessibleClass {
	return WindowAccessibleClassNewFromNative(object.Native())
}

// Equals compares this WindowAccessibleClass with another WindowAccessibleClass, and returns true if they represent the same Object.
func (recv *WindowAccessibleClass) Equals(other *WindowAccessibleClass) bool {
	return other.Native() == recv.Native()
}

func (recv *WindowAccessibleClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *WindowAccessibleClass) FieldParentClass() *ContainerAccessibleClass {
	argValue := gi.StructFieldGet(windowAccessibleClassStruct, recv.Native(), "parent_class")
	value := ContainerAccessibleClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *WindowAccessibleClass) SetFieldParentClass(value *ContainerAccessibleClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(windowAccessibleClassStruct, recv.Native(), "parent_class", argValue)
}

// WindowAccessibleClassStruct creates an uninitialised WindowAccessibleClass.
func WindowAccessibleClassStruct() *WindowAccessibleClass {
	err := windowAccessibleClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WindowAccessibleClassNewFromNative(windowAccessibleClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWindowAccessibleClass)
	return structGo
}
func finalizeWindowAccessibleClass(obj *WindowAccessibleClass) {
	windowAccessibleClassStruct.Free(obj.Native())
}

var windowAccessiblePrivateStruct *gi.Struct
var windowAccessiblePrivateStruct_Once sync.Once

func windowAccessiblePrivateStruct_Set() error {
	var err error
	windowAccessiblePrivateStruct_Once.Do(func() {
		windowAccessiblePrivateStruct, err = gi.StructNew("Gtk", "WindowAccessiblePrivate")
	})
	return err
}

type WindowAccessiblePrivate struct {
	native unsafe.Pointer
}

func WindowAccessiblePrivateNewFromNative(native unsafe.Pointer) *WindowAccessiblePrivate {
	err := windowAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WindowAccessiblePrivate{native: native}

	return instance
}

/*
CastToWindowAccessiblePrivate down casts any arbitrary Object to WindowAccessiblePrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a WindowAccessiblePrivate.
*/
func CastToWindowAccessiblePrivate(object *gobject.Object) *WindowAccessiblePrivate {
	return WindowAccessiblePrivateNewFromNative(object.Native())
}

// Equals compares this WindowAccessiblePrivate with another WindowAccessiblePrivate, and returns true if they represent the same Object.
func (recv *WindowAccessiblePrivate) Equals(other *WindowAccessiblePrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *WindowAccessiblePrivate) Native() unsafe.Pointer {
	return recv.native
}

// WindowAccessiblePrivateStruct creates an uninitialised WindowAccessiblePrivate.
func WindowAccessiblePrivateStruct() *WindowAccessiblePrivate {
	err := windowAccessiblePrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WindowAccessiblePrivateNewFromNative(windowAccessiblePrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWindowAccessiblePrivate)
	return structGo
}
func finalizeWindowAccessiblePrivate(obj *WindowAccessiblePrivate) {
	windowAccessiblePrivateStruct.Free(obj.Native())
}

var windowClassStruct *gi.Struct
var windowClassStruct_Once sync.Once

func windowClassStruct_Set() error {
	var err error
	windowClassStruct_Once.Do(func() {
		windowClassStruct, err = gi.StructNew("Gtk", "WindowClass")
	})
	return err
}

type WindowClass struct {
	native unsafe.Pointer
}

func WindowClassNewFromNative(native unsafe.Pointer) *WindowClass {
	err := windowClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WindowClass{native: native}

	return instance
}

/*
CastToWindowClass down casts any arbitrary Object to WindowClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a WindowClass.
*/
func CastToWindowClass(object *gobject.Object) *WindowClass {
	return WindowClassNewFromNative(object.Native())
}

// Equals compares this WindowClass with another WindowClass, and returns true if they represent the same Object.
func (recv *WindowClass) Equals(other *WindowClass) bool {
	return other.Native() == recv.Native()
}

func (recv *WindowClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *WindowClass) FieldParentClass() *BinClass {
	argValue := gi.StructFieldGet(windowClassStruct, recv.Native(), "parent_class")
	value := BinClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *WindowClass) SetFieldParentClass(value *BinClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(windowClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value 'set_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'set_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'activate_focus' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_focus' : for field setter : missing Type

// UNSUPPORTED : C value 'activate_default' : for field getter : missing Type

// UNSUPPORTED : C value 'activate_default' : for field setter : missing Type

// UNSUPPORTED : C value 'keys_changed' : for field getter : missing Type

// UNSUPPORTED : C value 'keys_changed' : for field setter : missing Type

// UNSUPPORTED : C value 'enable_debugging' : for field getter : missing Type

// UNSUPPORTED : C value 'enable_debugging' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// WindowClassStruct creates an uninitialised WindowClass.
func WindowClassStruct() *WindowClass {
	err := windowClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WindowClassNewFromNative(windowClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWindowClass)
	return structGo
}
func finalizeWindowClass(obj *WindowClass) {
	windowClassStruct.Free(obj.Native())
}

var windowGeometryInfoStruct *gi.Struct
var windowGeometryInfoStruct_Once sync.Once

func windowGeometryInfoStruct_Set() error {
	var err error
	windowGeometryInfoStruct_Once.Do(func() {
		windowGeometryInfoStruct, err = gi.StructNew("Gtk", "WindowGeometryInfo")
	})
	return err
}

type WindowGeometryInfo struct {
	native unsafe.Pointer
}

func WindowGeometryInfoNewFromNative(native unsafe.Pointer) *WindowGeometryInfo {
	err := windowGeometryInfoStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WindowGeometryInfo{native: native}

	return instance
}

/*
CastToWindowGeometryInfo down casts any arbitrary Object to WindowGeometryInfo.
Exercise care, as this is a potentially dangerous function
if the Object is not a WindowGeometryInfo.
*/
func CastToWindowGeometryInfo(object *gobject.Object) *WindowGeometryInfo {
	return WindowGeometryInfoNewFromNative(object.Native())
}

// Equals compares this WindowGeometryInfo with another WindowGeometryInfo, and returns true if they represent the same Object.
func (recv *WindowGeometryInfo) Equals(other *WindowGeometryInfo) bool {
	return other.Native() == recv.Native()
}

func (recv *WindowGeometryInfo) Native() unsafe.Pointer {
	return recv.native
}

// WindowGeometryInfoStruct creates an uninitialised WindowGeometryInfo.
func WindowGeometryInfoStruct() *WindowGeometryInfo {
	err := windowGeometryInfoStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WindowGeometryInfoNewFromNative(windowGeometryInfoStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWindowGeometryInfo)
	return structGo
}
func finalizeWindowGeometryInfo(obj *WindowGeometryInfo) {
	windowGeometryInfoStruct.Free(obj.Native())
}

var windowGroupClassStruct *gi.Struct
var windowGroupClassStruct_Once sync.Once

func windowGroupClassStruct_Set() error {
	var err error
	windowGroupClassStruct_Once.Do(func() {
		windowGroupClassStruct, err = gi.StructNew("Gtk", "WindowGroupClass")
	})
	return err
}

type WindowGroupClass struct {
	native unsafe.Pointer
}

func WindowGroupClassNewFromNative(native unsafe.Pointer) *WindowGroupClass {
	err := windowGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WindowGroupClass{native: native}

	return instance
}

/*
CastToWindowGroupClass down casts any arbitrary Object to WindowGroupClass.
Exercise care, as this is a potentially dangerous function
if the Object is not a WindowGroupClass.
*/
func CastToWindowGroupClass(object *gobject.Object) *WindowGroupClass {
	return WindowGroupClassNewFromNative(object.Native())
}

// Equals compares this WindowGroupClass with another WindowGroupClass, and returns true if they represent the same Object.
func (recv *WindowGroupClass) Equals(other *WindowGroupClass) bool {
	return other.Native() == recv.Native()
}

func (recv *WindowGroupClass) Native() unsafe.Pointer {
	return recv.native
}

// FieldParentClass returns the C field 'parent_class'.
func (recv *WindowGroupClass) FieldParentClass() *gobject.ObjectClass {
	argValue := gi.StructFieldGet(windowGroupClassStruct, recv.Native(), "parent_class")
	value := gobject.ObjectClassNewFromNative(argValue.Pointer())
	return value
}

// SetFieldParentClass sets the value of the C field 'parent_class'.
func (recv *WindowGroupClass) SetFieldParentClass(value *gobject.ObjectClass) {
	var argValue gi.Argument
	argValue.SetPointer(value.Native())
	gi.StructFieldSet(windowGroupClassStruct, recv.Native(), "parent_class", argValue)
}

// UNSUPPORTED : C value '_gtk_reserved1' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved1' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved2' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved3' : for field setter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field getter : missing Type

// UNSUPPORTED : C value '_gtk_reserved4' : for field setter : missing Type

// WindowGroupClassStruct creates an uninitialised WindowGroupClass.
func WindowGroupClassStruct() *WindowGroupClass {
	err := windowGroupClassStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WindowGroupClassNewFromNative(windowGroupClassStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWindowGroupClass)
	return structGo
}
func finalizeWindowGroupClass(obj *WindowGroupClass) {
	windowGroupClassStruct.Free(obj.Native())
}

var windowGroupPrivateStruct *gi.Struct
var windowGroupPrivateStruct_Once sync.Once

func windowGroupPrivateStruct_Set() error {
	var err error
	windowGroupPrivateStruct_Once.Do(func() {
		windowGroupPrivateStruct, err = gi.StructNew("Gtk", "WindowGroupPrivate")
	})
	return err
}

type WindowGroupPrivate struct {
	native unsafe.Pointer
}

func WindowGroupPrivateNewFromNative(native unsafe.Pointer) *WindowGroupPrivate {
	err := windowGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WindowGroupPrivate{native: native}

	return instance
}

/*
CastToWindowGroupPrivate down casts any arbitrary Object to WindowGroupPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a WindowGroupPrivate.
*/
func CastToWindowGroupPrivate(object *gobject.Object) *WindowGroupPrivate {
	return WindowGroupPrivateNewFromNative(object.Native())
}

// Equals compares this WindowGroupPrivate with another WindowGroupPrivate, and returns true if they represent the same Object.
func (recv *WindowGroupPrivate) Equals(other *WindowGroupPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *WindowGroupPrivate) Native() unsafe.Pointer {
	return recv.native
}

// WindowGroupPrivateStruct creates an uninitialised WindowGroupPrivate.
func WindowGroupPrivateStruct() *WindowGroupPrivate {
	err := windowGroupPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WindowGroupPrivateNewFromNative(windowGroupPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWindowGroupPrivate)
	return structGo
}
func finalizeWindowGroupPrivate(obj *WindowGroupPrivate) {
	windowGroupPrivateStruct.Free(obj.Native())
}

var windowPrivateStruct *gi.Struct
var windowPrivateStruct_Once sync.Once

func windowPrivateStruct_Set() error {
	var err error
	windowPrivateStruct_Once.Do(func() {
		windowPrivateStruct, err = gi.StructNew("Gtk", "WindowPrivate")
	})
	return err
}

type WindowPrivate struct {
	native unsafe.Pointer
}

func WindowPrivateNewFromNative(native unsafe.Pointer) *WindowPrivate {
	err := windowPrivateStruct_Set()
	if err != nil {
		return nil
	}

	instance := &WindowPrivate{native: native}

	return instance
}

/*
CastToWindowPrivate down casts any arbitrary Object to WindowPrivate.
Exercise care, as this is a potentially dangerous function
if the Object is not a WindowPrivate.
*/
func CastToWindowPrivate(object *gobject.Object) *WindowPrivate {
	return WindowPrivateNewFromNative(object.Native())
}

// Equals compares this WindowPrivate with another WindowPrivate, and returns true if they represent the same Object.
func (recv *WindowPrivate) Equals(other *WindowPrivate) bool {
	return other.Native() == recv.Native()
}

func (recv *WindowPrivate) Native() unsafe.Pointer {
	return recv.native
}

// WindowPrivateStruct creates an uninitialised WindowPrivate.
func WindowPrivateStruct() *WindowPrivate {
	err := windowPrivateStruct_Set()
	if err != nil {
		return nil
	}

	structGo := WindowPrivateNewFromNative(windowPrivateStruct.Alloc())
	runtime.SetFinalizer(structGo, finalizeWindowPrivate)
	return structGo
}
func finalizeWindowPrivate(obj *WindowPrivate) {
	windowPrivateStruct.Free(obj.Native())
}
