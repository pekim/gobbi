// Code generated - DO NOT EDIT.
// +build gtk_2.12

package gtk

import (
	"fmt"
	atk "github.com/pekim/gobbi/lib/atk"
	cairo "github.com/pekim/gobbi/lib/cairo"
	gdk "github.com/pekim/gobbi/lib/gdk"
	gdkpixbuf "github.com/pekim/gobbi/lib/gdkpixbuf"
	gio "github.com/pekim/gobbi/lib/gio"
	glib "github.com/pekim/gobbi/lib/glib"
	gobject "github.com/pekim/gobbi/lib/gobject"
	pango "github.com/pekim/gobbi/lib/pango"
	"reflect"
	"runtime"
	"sync"
	"unsafe"
)

// #cgo CFLAGS: -Wno-deprecated-declarations
// #cgo CFLAGS: -Wno-format-security
// #cgo CFLAGS: -Wno-incompatible-pointer-types
// #include <gtk/gtk-a11y.h>
// #include <gtk/gtk.h>
// #include <gtk/gtkx.h>
// #include <../gdk/gdk_event.h>
// #include <stdlib.h>
/*

	gboolean accelgroup_accelActivateHandler(GObject *, GObject *, guint, guint, gpointer);

	static gulong AccelGroup_signal_connect_accel_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-activate", G_CALLBACK(accelgroup_accelActivateHandler), data);
	}

*/
/*

	void accelgroup_accelChangedHandler(GObject *, guint, guint, GClosure *, gpointer);

	static gulong AccelGroup_signal_connect_accel_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-changed", G_CALLBACK(accelgroup_accelChangedHandler), data);
	}

*/
/*

	void accelmap_changedHandler(GObject *, gchar*, guint, guint, gpointer);

	static gulong AccelMap_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(accelmap_changedHandler), data);
	}

*/
/*

	void action_activateHandler(GObject *, gpointer);

	static gulong Action_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(action_activateHandler), data);
	}

*/
/*

	void actiongroup_connectProxyHandler(GObject *, GtkAction *, GtkWidget *, gpointer);

	static gulong ActionGroup_signal_connect_connect_proxy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "connect-proxy", G_CALLBACK(actiongroup_connectProxyHandler), data);
	}

*/
/*

	void actiongroup_disconnectProxyHandler(GObject *, GtkAction *, GtkWidget *, gpointer);

	static gulong ActionGroup_signal_connect_disconnect_proxy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "disconnect-proxy", G_CALLBACK(actiongroup_disconnectProxyHandler), data);
	}

*/
/*

	void actiongroup_postActivateHandler(GObject *, GtkAction *, gpointer);

	static gulong ActionGroup_signal_connect_post_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "post-activate", G_CALLBACK(actiongroup_postActivateHandler), data);
	}

*/
/*

	void actiongroup_preActivateHandler(GObject *, GtkAction *, gpointer);

	static gulong ActionGroup_signal_connect_pre_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "pre-activate", G_CALLBACK(actiongroup_preActivateHandler), data);
	}

*/
/*

	void adjustment_changedHandler(GObject *, gpointer);

	static gulong Adjustment_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(adjustment_changedHandler), data);
	}

*/
/*

	void adjustment_valueChangedHandler(GObject *, gpointer);

	static gulong Adjustment_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(adjustment_valueChangedHandler), data);
	}

*/
/*

	void appchooserbutton_customItemActivatedHandler(GObject *, gchar*, gpointer);

	static gulong AppChooserButton_signal_connect_custom_item_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "custom-item-activated", G_CALLBACK(appchooserbutton_customItemActivatedHandler), data);
	}

*/
/*

	void appchooserwidget_applicationActivatedHandler(GObject *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_application_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "application-activated", G_CALLBACK(appchooserwidget_applicationActivatedHandler), data);
	}

*/
/*

	void appchooserwidget_applicationSelectedHandler(GObject *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_application_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "application-selected", G_CALLBACK(appchooserwidget_applicationSelectedHandler), data);
	}

*/
/*

	void appchooserwidget_populatePopupHandler(GObject *, GtkMenu *, GAppInfo *, gpointer);

	static gulong AppChooserWidget_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(appchooserwidget_populatePopupHandler), data);
	}

*/
/*

	void assistant_applyHandler(GObject *, gpointer);

	static gulong Assistant_signal_connect_apply(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "apply", G_CALLBACK(assistant_applyHandler), data);
	}

*/
/*

	void assistant_cancelHandler(GObject *, gpointer);

	static gulong Assistant_signal_connect_cancel(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cancel", G_CALLBACK(assistant_cancelHandler), data);
	}

*/
/*

	void assistant_closeHandler(GObject *, gpointer);

	static gulong Assistant_signal_connect_close(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "close", G_CALLBACK(assistant_closeHandler), data);
	}

*/
/*

	void assistant_escapeHandler(GObject *, gpointer);

	static gulong Assistant_signal_connect_escape(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "escape", G_CALLBACK(assistant_escapeHandler), data);
	}

*/
/*

	void assistant_prepareHandler(GObject *, GtkWidget *, gpointer);

	static gulong Assistant_signal_connect_prepare(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prepare", G_CALLBACK(assistant_prepareHandler), data);
	}

*/
/*

	void button_activateHandler(GObject *, gpointer);

	static gulong Button_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(button_activateHandler), data);
	}

*/
/*

	void button_clickedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(button_clickedHandler), data);
	}

*/
/*

	void button_enterHandler(GObject *, gpointer);

	static gulong Button_signal_connect_enter(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enter", G_CALLBACK(button_enterHandler), data);
	}

*/
/*

	void button_leaveHandler(GObject *, gpointer);

	static gulong Button_signal_connect_leave(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "leave", G_CALLBACK(button_leaveHandler), data);
	}

*/
/*

	void button_pressedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_pressed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "pressed", G_CALLBACK(button_pressedHandler), data);
	}

*/
/*

	void button_releasedHandler(GObject *, gpointer);

	static gulong Button_signal_connect_released(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "released", G_CALLBACK(button_releasedHandler), data);
	}

*/
/*

	void calendar_daySelectedHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_day_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "day-selected", G_CALLBACK(calendar_daySelectedHandler), data);
	}

*/
/*

	void calendar_daySelectedDoubleClickHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_day_selected_double_click(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "day-selected-double-click", G_CALLBACK(calendar_daySelectedDoubleClickHandler), data);
	}

*/
/*

	void calendar_monthChangedHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_month_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "month-changed", G_CALLBACK(calendar_monthChangedHandler), data);
	}

*/
/*

	void calendar_nextMonthHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_next_month(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "next-month", G_CALLBACK(calendar_nextMonthHandler), data);
	}

*/
/*

	void calendar_nextYearHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_next_year(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "next-year", G_CALLBACK(calendar_nextYearHandler), data);
	}

*/
/*

	void calendar_prevMonthHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_prev_month(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prev-month", G_CALLBACK(calendar_prevMonthHandler), data);
	}

*/
/*

	void calendar_prevYearHandler(GObject *, gpointer);

	static gulong Calendar_signal_connect_prev_year(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "prev-year", G_CALLBACK(calendar_prevYearHandler), data);
	}

*/
/*

	void cellrenderer_editingCanceledHandler(GObject *, gpointer);

	static gulong CellRenderer_signal_connect_editing_canceled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "editing-canceled", G_CALLBACK(cellrenderer_editingCanceledHandler), data);
	}

*/
/*

	void cellrenderer_editingStartedHandler(GObject *, GtkCellEditable *, gchar*, gpointer);

	static gulong CellRenderer_signal_connect_editing_started(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "editing-started", G_CALLBACK(cellrenderer_editingStartedHandler), data);
	}

*/
/*

	void cellrendereraccel_accelClearedHandler(GObject *, gchar*, gpointer);

	static gulong CellRendererAccel_signal_connect_accel_cleared(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-cleared", G_CALLBACK(cellrendereraccel_accelClearedHandler), data);
	}

*/
/*

	void cellrendereraccel_accelEditedHandler(GObject *, gchar*, guint, guint, guint, gpointer);

	static gulong CellRendererAccel_signal_connect_accel_edited(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-edited", G_CALLBACK(cellrendereraccel_accelEditedHandler), data);
	}

*/
/*

	void cellrenderertext_editedHandler(GObject *, gchar*, gchar*, gpointer);

	static gulong CellRendererText_signal_connect_edited(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "edited", G_CALLBACK(cellrenderertext_editedHandler), data);
	}

*/
/*

	void cellrenderertoggle_toggledHandler(GObject *, gchar*, gpointer);

	static gulong CellRendererToggle_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(cellrenderertoggle_toggledHandler), data);
	}

*/
/*

	void checkmenuitem_toggledHandler(GObject *, gpointer);

	static gulong CheckMenuItem_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(checkmenuitem_toggledHandler), data);
	}

*/
/*

	void clipboard_ownerChangeHandler(GObject *, GdkEventOwnerChange *, gpointer);

	static gulong Clipboard_signal_connect_owner_change(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "owner-change", G_CALLBACK(clipboard_ownerChangeHandler), data);
	}

*/
/*

	void colorbutton_colorSetHandler(GObject *, gpointer);

	static gulong ColorButton_signal_connect_color_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "color-set", G_CALLBACK(colorbutton_colorSetHandler), data);
	}

*/
/*

	void colorselection_colorChangedHandler(GObject *, gpointer);

	static gulong ColorSelection_signal_connect_color_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "color-changed", G_CALLBACK(colorselection_colorChangedHandler), data);
	}

*/
/*

	void combobox_changedHandler(GObject *, gpointer);

	static gulong ComboBox_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(combobox_changedHandler), data);
	}

*/
/*

	void combobox_moveActiveHandler(GObject *, GtkScrollType, gpointer);

	static gulong ComboBox_signal_connect_move_active(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-active", G_CALLBACK(combobox_moveActiveHandler), data);
	}

*/
/*

	gboolean combobox_popdownHandler(GObject *, gpointer);

	static gulong ComboBox_signal_connect_popdown(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popdown", G_CALLBACK(combobox_popdownHandler), data);
	}

*/
/*

	void combobox_popupHandler(GObject *, gpointer);

	static gulong ComboBox_signal_connect_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup", G_CALLBACK(combobox_popupHandler), data);
	}

*/
/*

	void container_addHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_add(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "add", G_CALLBACK(container_addHandler), data);
	}

*/
/*

	void container_checkResizeHandler(GObject *, gpointer);

	static gulong Container_signal_connect_check_resize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "check-resize", G_CALLBACK(container_checkResizeHandler), data);
	}

*/
/*

	void container_removeHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_remove(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove", G_CALLBACK(container_removeHandler), data);
	}

*/
/*

	void container_setFocusChildHandler(GObject *, GtkWidget *, gpointer);

	static gulong Container_signal_connect_set_focus_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-focus-child", G_CALLBACK(container_setFocusChildHandler), data);
	}

*/
/*

	void cssprovider_parsingErrorHandler(GObject *, GtkCssSection *, GError *, gpointer);

	static gulong CssProvider_signal_connect_parsing_error(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "parsing-error", G_CALLBACK(cssprovider_parsingErrorHandler), data);
	}

*/
/*

	void dialog_closeHandler(GObject *, gpointer);

	static gulong Dialog_signal_connect_close(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "close", G_CALLBACK(dialog_closeHandler), data);
	}

*/
/*

	void dialog_responseHandler(GObject *, gint, gpointer);

	static gulong Dialog_signal_connect_response(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "response", G_CALLBACK(dialog_responseHandler), data);
	}

*/
/*

	void entry_activateHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(entry_activateHandler), data);
	}

*/
/*

	void entry_backspaceHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_backspace(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "backspace", G_CALLBACK(entry_backspaceHandler), data);
	}

*/
/*

	void entry_copyClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(entry_copyClipboardHandler), data);
	}

*/
/*

	void entry_cutClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_cut_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cut-clipboard", G_CALLBACK(entry_cutClipboardHandler), data);
	}

*/
/*

	void entry_deleteFromCursorHandler(GObject *, GtkDeleteType, gint, gpointer);

	static gulong Entry_signal_connect_delete_from_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-from-cursor", G_CALLBACK(entry_deleteFromCursorHandler), data);
	}

*/
/*

	void entry_insertAtCursorHandler(GObject *, gchar*, gpointer);

	static gulong Entry_signal_connect_insert_at_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-at-cursor", G_CALLBACK(entry_insertAtCursorHandler), data);
	}

*/
/*

	void entry_moveCursorHandler(GObject *, GtkMovementStep, gint, gboolean, gpointer);

	static gulong Entry_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(entry_moveCursorHandler), data);
	}

*/
/*

	void entry_pasteClipboardHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_paste_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paste-clipboard", G_CALLBACK(entry_pasteClipboardHandler), data);
	}

*/
/*

	void entry_populatePopupHandler(GObject *, GtkWidget *, gpointer);

	static gulong Entry_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(entry_populatePopupHandler), data);
	}

*/
/*

	void entry_toggleOverwriteHandler(GObject *, gpointer);

	static gulong Entry_signal_connect_toggle_overwrite(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-overwrite", G_CALLBACK(entry_toggleOverwriteHandler), data);
	}

*/
/*

	void entrycompletion_actionActivatedHandler(GObject *, gint, gpointer);

	static gulong EntryCompletion_signal_connect_action_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "action-activated", G_CALLBACK(entrycompletion_actionActivatedHandler), data);
	}

*/
/*

	gboolean entrycompletion_cursorOnMatchHandler(GObject *, GtkTreeModel *, GtkTreeIter *, gpointer);

	static gulong EntryCompletion_signal_connect_cursor_on_match(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cursor-on-match", G_CALLBACK(entrycompletion_cursorOnMatchHandler), data);
	}

*/
/*

	gboolean entrycompletion_insertPrefixHandler(GObject *, gchar*, gpointer);

	static gulong EntryCompletion_signal_connect_insert_prefix(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-prefix", G_CALLBACK(entrycompletion_insertPrefixHandler), data);
	}

*/
/*

	gboolean entrycompletion_matchSelectedHandler(GObject *, GtkTreeModel *, GtkTreeIter *, gpointer);

	static gulong EntryCompletion_signal_connect_match_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "match-selected", G_CALLBACK(entrycompletion_matchSelectedHandler), data);
	}

*/
/*

	void expander_activateHandler(GObject *, gpointer);

	static gulong Expander_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(expander_activateHandler), data);
	}

*/
/*

	void filechooserbutton_fileSetHandler(GObject *, gpointer);

	static gulong FileChooserButton_signal_connect_file_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "file-set", G_CALLBACK(filechooserbutton_fileSetHandler), data);
	}

*/
/*

	void filechooserwidget_desktopFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_desktop_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "desktop-folder", G_CALLBACK(filechooserwidget_desktopFolderHandler), data);
	}

*/
/*

	void filechooserwidget_downFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_down_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "down-folder", G_CALLBACK(filechooserwidget_downFolderHandler), data);
	}

*/
/*

	void filechooserwidget_homeFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_home_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "home-folder", G_CALLBACK(filechooserwidget_homeFolderHandler), data);
	}

*/
/*

	void filechooserwidget_locationPopupHandler(GObject *, gchar*, gpointer);

	static gulong FileChooserWidget_signal_connect_location_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-popup", G_CALLBACK(filechooserwidget_locationPopupHandler), data);
	}

*/
/*

	void filechooserwidget_locationPopupOnPasteHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_location_popup_on_paste(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-popup-on-paste", G_CALLBACK(filechooserwidget_locationPopupOnPasteHandler), data);
	}

*/
/*

	void filechooserwidget_locationTogglePopupHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_location_toggle_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "location-toggle-popup", G_CALLBACK(filechooserwidget_locationTogglePopupHandler), data);
	}

*/
/*

	void filechooserwidget_placesShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_places_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "places-shortcut", G_CALLBACK(filechooserwidget_placesShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_quickBookmarkHandler(GObject *, gint, gpointer);

	static gulong FileChooserWidget_signal_connect_quick_bookmark(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "quick-bookmark", G_CALLBACK(filechooserwidget_quickBookmarkHandler), data);
	}

*/
/*

	void filechooserwidget_recentShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_recent_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "recent-shortcut", G_CALLBACK(filechooserwidget_recentShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_searchShortcutHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_search_shortcut(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "search-shortcut", G_CALLBACK(filechooserwidget_searchShortcutHandler), data);
	}

*/
/*

	void filechooserwidget_showHiddenHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_show_hidden(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-hidden", G_CALLBACK(filechooserwidget_showHiddenHandler), data);
	}

*/
/*

	void filechooserwidget_upFolderHandler(GObject *, gpointer);

	static gulong FileChooserWidget_signal_connect_up_folder(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "up-folder", G_CALLBACK(filechooserwidget_upFolderHandler), data);
	}

*/
/*

	void flowbox_activateCursorChildHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_activate_cursor_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-child", G_CALLBACK(flowbox_activateCursorChildHandler), data);
	}

*/
/*

	void flowbox_childActivatedHandler(GObject *, GtkFlowBoxChild *, gpointer);

	static gulong FlowBox_signal_connect_child_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-activated", G_CALLBACK(flowbox_childActivatedHandler), data);
	}

*/
/*

	gboolean flowbox_moveCursorHandler(GObject *, GtkMovementStep, gint, gpointer);

	static gulong FlowBox_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(flowbox_moveCursorHandler), data);
	}

*/
/*

	void flowbox_selectAllHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(flowbox_selectAllHandler), data);
	}

*/
/*

	void flowbox_selectedChildrenChangedHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_selected_children_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selected-children-changed", G_CALLBACK(flowbox_selectedChildrenChangedHandler), data);
	}

*/
/*

	void flowbox_toggleCursorChildHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_toggle_cursor_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-child", G_CALLBACK(flowbox_toggleCursorChildHandler), data);
	}

*/
/*

	void flowbox_unselectAllHandler(GObject *, gpointer);

	static gulong FlowBox_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(flowbox_unselectAllHandler), data);
	}

*/
/*

	void flowboxchild_activateHandler(GObject *, gpointer);

	static gulong FlowBoxChild_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(flowboxchild_activateHandler), data);
	}

*/
/*

	void fontbutton_fontSetHandler(GObject *, gpointer);

	static gulong FontButton_signal_connect_font_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "font-set", G_CALLBACK(fontbutton_fontSetHandler), data);
	}

*/
/*

	void hsv_changedHandler(GObject *, gpointer);

	static gulong HSV_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(hsv_changedHandler), data);
	}

*/
/*

	void hsv_moveHandler(GObject *, GtkDirectionType, gpointer);

	static gulong HSV_signal_connect_move(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move", G_CALLBACK(hsv_moveHandler), data);
	}

*/
/*

	void handlebox_childAttachedHandler(GObject *, GtkWidget *, gpointer);

	static gulong HandleBox_signal_connect_child_attached(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-attached", G_CALLBACK(handlebox_childAttachedHandler), data);
	}

*/
/*

	void handlebox_childDetachedHandler(GObject *, GtkWidget *, gpointer);

	static gulong HandleBox_signal_connect_child_detached(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-detached", G_CALLBACK(handlebox_childDetachedHandler), data);
	}

*/
/*

	void imcontext_commitHandler(GObject *, gchar*, gpointer);

	static gulong IMContext_signal_connect_commit(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "commit", G_CALLBACK(imcontext_commitHandler), data);
	}

*/
/*

	gboolean imcontext_deleteSurroundingHandler(GObject *, gint, gint, gpointer);

	static gulong IMContext_signal_connect_delete_surrounding(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-surrounding", G_CALLBACK(imcontext_deleteSurroundingHandler), data);
	}

*/
/*

	void imcontext_preeditChangedHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-changed", G_CALLBACK(imcontext_preeditChangedHandler), data);
	}

*/
/*

	void imcontext_preeditEndHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-end", G_CALLBACK(imcontext_preeditEndHandler), data);
	}

*/
/*

	void imcontext_preeditStartHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_preedit_start(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preedit-start", G_CALLBACK(imcontext_preeditStartHandler), data);
	}

*/
/*

	gboolean imcontext_retrieveSurroundingHandler(GObject *, gpointer);

	static gulong IMContext_signal_connect_retrieve_surrounding(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "retrieve-surrounding", G_CALLBACK(imcontext_retrieveSurroundingHandler), data);
	}

*/
/*

	void icontheme_changedHandler(GObject *, gpointer);

	static gulong IconTheme_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(icontheme_changedHandler), data);
	}

*/
/*

	gboolean iconview_activateCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_activate_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-item", G_CALLBACK(iconview_activateCursorItemHandler), data);
	}

*/
/*

	void iconview_itemActivatedHandler(GObject *, GtkTreePath *, gpointer);

	static gulong IconView_signal_connect_item_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "item-activated", G_CALLBACK(iconview_itemActivatedHandler), data);
	}

*/
/*

	gboolean iconview_moveCursorHandler(GObject *, GtkMovementStep, gint, gpointer);

	static gulong IconView_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(iconview_moveCursorHandler), data);
	}

*/
/*

	void iconview_selectAllHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(iconview_selectAllHandler), data);
	}

*/
/*

	void iconview_selectCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_select_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-item", G_CALLBACK(iconview_selectCursorItemHandler), data);
	}

*/
/*

	void iconview_selectionChangedHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_selection_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-changed", G_CALLBACK(iconview_selectionChangedHandler), data);
	}

*/
/*

	void iconview_toggleCursorItemHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_toggle_cursor_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-item", G_CALLBACK(iconview_toggleCursorItemHandler), data);
	}

*/
/*

	void iconview_unselectAllHandler(GObject *, gpointer);

	static gulong IconView_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(iconview_unselectAllHandler), data);
	}

*/
/*

	void label_copyClipboardHandler(GObject *, gpointer);

	static gulong Label_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(label_copyClipboardHandler), data);
	}

*/
/*

	void label_moveCursorHandler(GObject *, GtkMovementStep, gint, gboolean, gpointer);

	static gulong Label_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(label_moveCursorHandler), data);
	}

*/
/*

	void label_populatePopupHandler(GObject *, GtkMenu *, gpointer);

	static gulong Label_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(label_populatePopupHandler), data);
	}

*/
/*

	gboolean linkbutton_activateLinkHandler(GObject *, gpointer);

	static gulong LinkButton_signal_connect_activate_link(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-link", G_CALLBACK(linkbutton_activateLinkHandler), data);
	}

*/
/*

	void listbox_activateCursorRowHandler(GObject *, gpointer);

	static gulong ListBox_signal_connect_activate_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-cursor-row", G_CALLBACK(listbox_activateCursorRowHandler), data);
	}

*/
/*

	void listbox_moveCursorHandler(GObject *, GtkMovementStep, gint, gpointer);

	static gulong ListBox_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(listbox_moveCursorHandler), data);
	}

*/
/*

	void listbox_toggleCursorRowHandler(GObject *, gpointer);

	static gulong ListBox_signal_connect_toggle_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-row", G_CALLBACK(listbox_toggleCursorRowHandler), data);
	}

*/
/*

	void menu_moveScrollHandler(GObject *, GtkScrollType, gpointer);

	static gulong Menu_signal_connect_move_scroll(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-scroll", G_CALLBACK(menu_moveScrollHandler), data);
	}

*/
/*

	void menuitem_activateHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(menuitem_activateHandler), data);
	}

*/
/*

	void menuitem_activateItemHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_activate_item(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-item", G_CALLBACK(menuitem_activateItemHandler), data);
	}

*/
/*

	void menuitem_deselectHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_deselect(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "deselect", G_CALLBACK(menuitem_deselectHandler), data);
	}

*/
/*

	void menuitem_selectHandler(GObject *, gpointer);

	static gulong MenuItem_signal_connect_select(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select", G_CALLBACK(menuitem_selectHandler), data);
	}

*/
/*

	void menuitem_toggleSizeAllocateHandler(GObject *, gint, gpointer);

	static gulong MenuItem_signal_connect_toggle_size_allocate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-size-allocate", G_CALLBACK(menuitem_toggleSizeAllocateHandler), data);
	}

*/
/*

	void menushell_activateCurrentHandler(GObject *, gboolean, gpointer);

	static gulong MenuShell_signal_connect_activate_current(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-current", G_CALLBACK(menushell_activateCurrentHandler), data);
	}

*/
/*

	void menushell_cancelHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_cancel(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cancel", G_CALLBACK(menushell_cancelHandler), data);
	}

*/
/*

	void menushell_cycleFocusHandler(GObject *, GtkDirectionType, gpointer);

	static gulong MenuShell_signal_connect_cycle_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cycle-focus", G_CALLBACK(menushell_cycleFocusHandler), data);
	}

*/
/*

	void menushell_deactivateHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_deactivate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "deactivate", G_CALLBACK(menushell_deactivateHandler), data);
	}

*/
/*

	void menushell_moveCurrentHandler(GObject *, GtkMenuDirectionType, gpointer);

	static gulong MenuShell_signal_connect_move_current(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-current", G_CALLBACK(menushell_moveCurrentHandler), data);
	}

*/
/*

	gboolean menushell_moveSelectedHandler(GObject *, gint, gpointer);

	static gulong MenuShell_signal_connect_move_selected(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-selected", G_CALLBACK(menushell_moveSelectedHandler), data);
	}

*/
/*

	void menushell_selectionDoneHandler(GObject *, gpointer);

	static gulong MenuShell_signal_connect_selection_done(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-done", G_CALLBACK(menushell_selectionDoneHandler), data);
	}

*/
/*

	void menutoolbutton_showMenuHandler(GObject *, gpointer);

	static gulong MenuToolButton_signal_connect_show_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-menu", G_CALLBACK(menutoolbutton_showMenuHandler), data);
	}

*/
/*

	static GtkMessageDialog* _gtk_message_dialog_new(GtkWindow* parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, const gchar* message_format) {
		return gtk_message_dialog_new(parent, flags, type, buttons, message_format);
    }
*/
/*

	static GtkMessageDialog* _gtk_message_dialog_new_with_markup(GtkWindow* parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons, const gchar* message_format) {
		return gtk_message_dialog_new_with_markup(parent, flags, type, buttons, message_format);
    }
*/
/*

	static void _gtk_message_dialog_format_secondary_markup(GtkMessageDialog* message_dialog, const gchar* message_format) {
		return gtk_message_dialog_format_secondary_markup(message_dialog, message_format);
    }
*/
/*

	static void _gtk_message_dialog_format_secondary_text(GtkMessageDialog* message_dialog, const gchar* message_format) {
		return gtk_message_dialog_format_secondary_text(message_dialog, message_format);
    }
*/
/*

	gboolean notebook_changeCurrentPageHandler(GObject *, gint, gpointer);

	static gulong Notebook_signal_connect_change_current_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "change-current-page", G_CALLBACK(notebook_changeCurrentPageHandler), data);
	}

*/
/*

	GtkNotebook * notebook_createWindowHandler(GObject *, GtkWidget *, gint, gint, gpointer);

	static gulong Notebook_signal_connect_create_window(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "create-window", G_CALLBACK(notebook_createWindowHandler), data);
	}

*/
/*

	gboolean notebook_focusTabHandler(GObject *, GtkNotebookTab, gpointer);

	static gulong Notebook_signal_connect_focus_tab(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-tab", G_CALLBACK(notebook_focusTabHandler), data);
	}

*/
/*

	void notebook_moveFocusOutHandler(GObject *, GtkDirectionType, gpointer);

	static gulong Notebook_signal_connect_move_focus_out(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-focus-out", G_CALLBACK(notebook_moveFocusOutHandler), data);
	}

*/
/*

	void notebook_pageAddedHandler(GObject *, GtkWidget *, guint, gpointer);

	static gulong Notebook_signal_connect_page_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "page-added", G_CALLBACK(notebook_pageAddedHandler), data);
	}

*/
/*

	void notebook_pageRemovedHandler(GObject *, GtkWidget *, guint, gpointer);

	static gulong Notebook_signal_connect_page_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "page-removed", G_CALLBACK(notebook_pageRemovedHandler), data);
	}

*/
/*

	void notebook_pageReorderedHandler(GObject *, GtkWidget *, guint, gpointer);

	static gulong Notebook_signal_connect_page_reordered(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "page-reordered", G_CALLBACK(notebook_pageReorderedHandler), data);
	}

*/
/*

	gboolean notebook_reorderTabHandler(GObject *, GtkDirectionType, gboolean, gpointer);

	static gulong Notebook_signal_connect_reorder_tab(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "reorder-tab", G_CALLBACK(notebook_reorderTabHandler), data);
	}

*/
/*

	gboolean notebook_selectPageHandler(GObject *, gboolean, gpointer);

	static gulong Notebook_signal_connect_select_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-page", G_CALLBACK(notebook_selectPageHandler), data);
	}

*/
/*

	void notebook_switchPageHandler(GObject *, GtkWidget *, guint, gpointer);

	static gulong Notebook_signal_connect_switch_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "switch-page", G_CALLBACK(notebook_switchPageHandler), data);
	}

*/
/*

	gboolean paned_acceptPositionHandler(GObject *, gpointer);

	static gulong Paned_signal_connect_accept_position(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accept-position", G_CALLBACK(paned_acceptPositionHandler), data);
	}

*/
/*

	gboolean paned_cancelPositionHandler(GObject *, gpointer);

	static gulong Paned_signal_connect_cancel_position(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cancel-position", G_CALLBACK(paned_cancelPositionHandler), data);
	}

*/
/*

	gboolean paned_cycleChildFocusHandler(GObject *, gboolean, gpointer);

	static gulong Paned_signal_connect_cycle_child_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cycle-child-focus", G_CALLBACK(paned_cycleChildFocusHandler), data);
	}

*/
/*

	gboolean paned_cycleHandleFocusHandler(GObject *, gboolean, gpointer);

	static gulong Paned_signal_connect_cycle_handle_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cycle-handle-focus", G_CALLBACK(paned_cycleHandleFocusHandler), data);
	}

*/
/*

	gboolean paned_moveHandleHandler(GObject *, GtkScrollType, gpointer);

	static gulong Paned_signal_connect_move_handle(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-handle", G_CALLBACK(paned_moveHandleHandler), data);
	}

*/
/*

	gboolean paned_toggleHandleFocusHandler(GObject *, gpointer);

	static gulong Paned_signal_connect_toggle_handle_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-handle-focus", G_CALLBACK(paned_toggleHandleFocusHandler), data);
	}

*/
/*

	void placessidebar_showConnectToServerHandler(GObject *, gpointer);

	static gulong PlacesSidebar_signal_connect_show_connect_to_server(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-connect-to-server", G_CALLBACK(placessidebar_showConnectToServerHandler), data);
	}

*/
/*

	void popover_closedHandler(GObject *, gpointer);

	static gulong Popover_signal_connect_closed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "closed", G_CALLBACK(popover_closedHandler), data);
	}

*/
/*

	void printoperation_beginPrintHandler(GObject *, GtkPrintContext *, gpointer);

	static gulong PrintOperation_signal_connect_begin_print(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "begin-print", G_CALLBACK(printoperation_beginPrintHandler), data);
	}

*/
/*

	GObject * printoperation_createCustomWidgetHandler(GObject *, gpointer);

	static gulong PrintOperation_signal_connect_create_custom_widget(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "create-custom-widget", G_CALLBACK(printoperation_createCustomWidgetHandler), data);
	}

*/
/*

	void printoperation_customWidgetApplyHandler(GObject *, GtkWidget *, gpointer);

	static gulong PrintOperation_signal_connect_custom_widget_apply(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "custom-widget-apply", G_CALLBACK(printoperation_customWidgetApplyHandler), data);
	}

*/
/*

	void printoperation_doneHandler(GObject *, GtkPrintOperationResult, gpointer);

	static gulong PrintOperation_signal_connect_done(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "done", G_CALLBACK(printoperation_doneHandler), data);
	}

*/
/*

	void printoperation_drawPageHandler(GObject *, GtkPrintContext *, gint, gpointer);

	static gulong PrintOperation_signal_connect_draw_page(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "draw-page", G_CALLBACK(printoperation_drawPageHandler), data);
	}

*/
/*

	void printoperation_endPrintHandler(GObject *, GtkPrintContext *, gpointer);

	static gulong PrintOperation_signal_connect_end_print(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "end-print", G_CALLBACK(printoperation_endPrintHandler), data);
	}

*/
/*

	gboolean printoperation_paginateHandler(GObject *, GtkPrintContext *, gpointer);

	static gulong PrintOperation_signal_connect_paginate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paginate", G_CALLBACK(printoperation_paginateHandler), data);
	}

*/
/*

	gboolean printoperation_previewHandler(GObject *, GtkPrintOperationPreview *, GtkPrintContext *, GtkWindow *, gpointer);

	static gulong PrintOperation_signal_connect_preview(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "preview", G_CALLBACK(printoperation_previewHandler), data);
	}

*/
/*

	void printoperation_requestPageSetupHandler(GObject *, GtkPrintContext *, gint, GtkPageSetup *, gpointer);

	static gulong PrintOperation_signal_connect_request_page_setup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "request-page-setup", G_CALLBACK(printoperation_requestPageSetupHandler), data);
	}

*/
/*

	void printoperation_statusChangedHandler(GObject *, gpointer);

	static gulong PrintOperation_signal_connect_status_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "status-changed", G_CALLBACK(printoperation_statusChangedHandler), data);
	}

*/
/*

	void radioaction_changedHandler(GObject *, GtkRadioAction *, gpointer);

	static gulong RadioAction_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(radioaction_changedHandler), data);
	}

*/
/*

	void radiobutton_groupChangedHandler(GObject *, gpointer);

	static gulong RadioButton_signal_connect_group_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "group-changed", G_CALLBACK(radiobutton_groupChangedHandler), data);
	}

*/
/*

	void radiomenuitem_groupChangedHandler(GObject *, gpointer);

	static gulong RadioMenuItem_signal_connect_group_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "group-changed", G_CALLBACK(radiomenuitem_groupChangedHandler), data);
	}

*/
/*

	void range_adjustBoundsHandler(GObject *, gdouble, gpointer);

	static gulong Range_signal_connect_adjust_bounds(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "adjust-bounds", G_CALLBACK(range_adjustBoundsHandler), data);
	}

*/
/*

	gboolean range_changeValueHandler(GObject *, GtkScrollType, gdouble, gpointer);

	static gulong Range_signal_connect_change_value(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "change-value", G_CALLBACK(range_changeValueHandler), data);
	}

*/
/*

	void range_moveSliderHandler(GObject *, GtkScrollType, gpointer);

	static gulong Range_signal_connect_move_slider(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-slider", G_CALLBACK(range_moveSliderHandler), data);
	}

*/
/*

	void range_valueChangedHandler(GObject *, gpointer);

	static gulong Range_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(range_valueChangedHandler), data);
	}

*/
/*

	void recentmanager_changedHandler(GObject *, gpointer);

	static gulong RecentManager_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(recentmanager_changedHandler), data);
	}

*/
/*

	void scalebutton_popdownHandler(GObject *, gpointer);

	static gulong ScaleButton_signal_connect_popdown(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popdown", G_CALLBACK(scalebutton_popdownHandler), data);
	}

*/
/*

	void scalebutton_popupHandler(GObject *, gpointer);

	static gulong ScaleButton_signal_connect_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup", G_CALLBACK(scalebutton_popupHandler), data);
	}

*/
/*

	void scalebutton_valueChangedHandler(GObject *, gdouble, gpointer);

	static gulong ScaleButton_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(scalebutton_valueChangedHandler), data);
	}

*/
/*

	void scrolledwindow_moveFocusOutHandler(GObject *, GtkDirectionType, gpointer);

	static gulong ScrolledWindow_signal_connect_move_focus_out(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-focus-out", G_CALLBACK(scrolledwindow_moveFocusOutHandler), data);
	}

*/
/*

	gboolean scrolledwindow_scrollChildHandler(GObject *, GtkScrollType, gboolean, gpointer);

	static gulong ScrolledWindow_signal_connect_scroll_child(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "scroll-child", G_CALLBACK(scrolledwindow_scrollChildHandler), data);
	}

*/
/*

	void spinbutton_changeValueHandler(GObject *, GtkScrollType, gpointer);

	static gulong SpinButton_signal_connect_change_value(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "change-value", G_CALLBACK(spinbutton_changeValueHandler), data);
	}

*/
/*

	gboolean spinbutton_outputHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_output(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "output", G_CALLBACK(spinbutton_outputHandler), data);
	}

*/
/*

	void spinbutton_valueChangedHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_value_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "value-changed", G_CALLBACK(spinbutton_valueChangedHandler), data);
	}

*/
/*

	void spinbutton_wrappedHandler(GObject *, gpointer);

	static gulong SpinButton_signal_connect_wrapped(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "wrapped", G_CALLBACK(spinbutton_wrappedHandler), data);
	}

*/
/*

	void statusicon_activateHandler(GObject *, gpointer);

	static gulong StatusIcon_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(statusicon_activateHandler), data);
	}

*/
/*

	void statusicon_popupMenuHandler(GObject *, guint, guint, gpointer);

	static gulong StatusIcon_signal_connect_popup_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup-menu", G_CALLBACK(statusicon_popupMenuHandler), data);
	}

*/
/*

	gboolean statusicon_sizeChangedHandler(GObject *, gint, gpointer);

	static gulong StatusIcon_signal_connect_size_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "size-changed", G_CALLBACK(statusicon_sizeChangedHandler), data);
	}

*/
/*

	void statusbar_textPoppedHandler(GObject *, guint, gchar*, gpointer);

	static gulong Statusbar_signal_connect_text_popped(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "text-popped", G_CALLBACK(statusbar_textPoppedHandler), data);
	}

*/
/*

	void statusbar_textPushedHandler(GObject *, guint, gchar*, gpointer);

	static gulong Statusbar_signal_connect_text_pushed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "text-pushed", G_CALLBACK(statusbar_textPushedHandler), data);
	}

*/
/*

	void style_realizeHandler(GObject *, gpointer);

	static gulong Style_signal_connect_realize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "realize", G_CALLBACK(style_realizeHandler), data);
	}

*/
/*

	void style_unrealizeHandler(GObject *, gpointer);

	static gulong Style_signal_connect_unrealize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unrealize", G_CALLBACK(style_unrealizeHandler), data);
	}

*/
/*

	void switch_activateHandler(GObject *, gpointer);

	static gulong Switch_signal_connect_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate", G_CALLBACK(switch_activateHandler), data);
	}

*/
/*

	void textbuffer_applyTagHandler(GObject *, GtkTextTag *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_apply_tag(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "apply-tag", G_CALLBACK(textbuffer_applyTagHandler), data);
	}

*/
/*

	void textbuffer_beginUserActionHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_begin_user_action(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "begin-user-action", G_CALLBACK(textbuffer_beginUserActionHandler), data);
	}

*/
/*

	void textbuffer_changedHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(textbuffer_changedHandler), data);
	}

*/
/*

	void textbuffer_deleteRangeHandler(GObject *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_delete_range(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-range", G_CALLBACK(textbuffer_deleteRangeHandler), data);
	}

*/
/*

	void textbuffer_endUserActionHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_end_user_action(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "end-user-action", G_CALLBACK(textbuffer_endUserActionHandler), data);
	}

*/
/*

	void textbuffer_insertChildAnchorHandler(GObject *, GtkTextIter *, GtkTextChildAnchor *, gpointer);

	static gulong TextBuffer_signal_connect_insert_child_anchor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-child-anchor", G_CALLBACK(textbuffer_insertChildAnchorHandler), data);
	}

*/
/*

	void textbuffer_insertPixbufHandler(GObject *, GtkTextIter *, GdkPixbuf *, gpointer);

	static gulong TextBuffer_signal_connect_insert_pixbuf(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-pixbuf", G_CALLBACK(textbuffer_insertPixbufHandler), data);
	}

*/
/*

	void textbuffer_insertTextHandler(GObject *, GtkTextIter *, gchar*, gint, gpointer);

	static gulong TextBuffer_signal_connect_insert_text(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-text", G_CALLBACK(textbuffer_insertTextHandler), data);
	}

*/
/*

	void textbuffer_markDeletedHandler(GObject *, GtkTextMark *, gpointer);

	static gulong TextBuffer_signal_connect_mark_deleted(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mark-deleted", G_CALLBACK(textbuffer_markDeletedHandler), data);
	}

*/
/*

	void textbuffer_markSetHandler(GObject *, GtkTextIter *, GtkTextMark *, gpointer);

	static gulong TextBuffer_signal_connect_mark_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mark-set", G_CALLBACK(textbuffer_markSetHandler), data);
	}

*/
/*

	void textbuffer_modifiedChangedHandler(GObject *, gpointer);

	static gulong TextBuffer_signal_connect_modified_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "modified-changed", G_CALLBACK(textbuffer_modifiedChangedHandler), data);
	}

*/
/*

	void textbuffer_removeTagHandler(GObject *, GtkTextTag *, GtkTextIter *, GtkTextIter *, gpointer);

	static gulong TextBuffer_signal_connect_remove_tag(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove-tag", G_CALLBACK(textbuffer_removeTagHandler), data);
	}

*/
/*

	gboolean texttag_eventHandler(GObject *, GObject *, GdkEvent_ *, GtkTextIter *, gpointer);

	static gulong TextTag_signal_connect_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "event", G_CALLBACK(texttag_eventHandler), data);
	}

*/
/*

	void texttagtable_tagAddedHandler(GObject *, GtkTextTag *, gpointer);

	static gulong TextTagTable_signal_connect_tag_added(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-added", G_CALLBACK(texttagtable_tagAddedHandler), data);
	}

*/
/*

	void texttagtable_tagChangedHandler(GObject *, GtkTextTag *, gboolean, gpointer);

	static gulong TextTagTable_signal_connect_tag_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-changed", G_CALLBACK(texttagtable_tagChangedHandler), data);
	}

*/
/*

	void texttagtable_tagRemovedHandler(GObject *, GtkTextTag *, gpointer);

	static gulong TextTagTable_signal_connect_tag_removed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "tag-removed", G_CALLBACK(texttagtable_tagRemovedHandler), data);
	}

*/
/*

	void textview_backspaceHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_backspace(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "backspace", G_CALLBACK(textview_backspaceHandler), data);
	}

*/
/*

	void textview_copyClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_copy_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "copy-clipboard", G_CALLBACK(textview_copyClipboardHandler), data);
	}

*/
/*

	void textview_cutClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_cut_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cut-clipboard", G_CALLBACK(textview_cutClipboardHandler), data);
	}

*/
/*

	void textview_deleteFromCursorHandler(GObject *, GtkDeleteType, gint, gpointer);

	static gulong TextView_signal_connect_delete_from_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-from-cursor", G_CALLBACK(textview_deleteFromCursorHandler), data);
	}

*/
/*

	void textview_insertAtCursorHandler(GObject *, gchar*, gpointer);

	static gulong TextView_signal_connect_insert_at_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "insert-at-cursor", G_CALLBACK(textview_insertAtCursorHandler), data);
	}

*/
/*

	void textview_moveCursorHandler(GObject *, GtkMovementStep, gint, gboolean, gpointer);

	static gulong TextView_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(textview_moveCursorHandler), data);
	}

*/
/*

	void textview_moveViewportHandler(GObject *, GtkScrollStep, gint, gpointer);

	static gulong TextView_signal_connect_move_viewport(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-viewport", G_CALLBACK(textview_moveViewportHandler), data);
	}

*/
/*

	void textview_pasteClipboardHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_paste_clipboard(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "paste-clipboard", G_CALLBACK(textview_pasteClipboardHandler), data);
	}

*/
/*

	void textview_populatePopupHandler(GObject *, GtkWidget *, gpointer);

	static gulong TextView_signal_connect_populate_popup(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "populate-popup", G_CALLBACK(textview_populatePopupHandler), data);
	}

*/
/*

	void textview_selectAllHandler(GObject *, gboolean, gpointer);

	static gulong TextView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(textview_selectAllHandler), data);
	}

*/
/*

	void textview_setAnchorHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_set_anchor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-anchor", G_CALLBACK(textview_setAnchorHandler), data);
	}

*/
/*

	void textview_toggleCursorVisibleHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_toggle_cursor_visible(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-visible", G_CALLBACK(textview_toggleCursorVisibleHandler), data);
	}

*/
/*

	void textview_toggleOverwriteHandler(GObject *, gpointer);

	static gulong TextView_signal_connect_toggle_overwrite(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-overwrite", G_CALLBACK(textview_toggleOverwriteHandler), data);
	}

*/
/*

	void toggleaction_toggledHandler(GObject *, gpointer);

	static gulong ToggleAction_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(toggleaction_toggledHandler), data);
	}

*/
/*

	void togglebutton_toggledHandler(GObject *, gpointer);

	static gulong ToggleButton_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(togglebutton_toggledHandler), data);
	}

*/
/*

	void toggletoolbutton_toggledHandler(GObject *, gpointer);

	static gulong ToggleToolButton_signal_connect_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggled", G_CALLBACK(toggletoolbutton_toggledHandler), data);
	}

*/
/*

	void toolbutton_clickedHandler(GObject *, gpointer);

	static gulong ToolButton_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(toolbutton_clickedHandler), data);
	}

*/
/*

	gboolean toolitem_createMenuProxyHandler(GObject *, gpointer);

	static gulong ToolItem_signal_connect_create_menu_proxy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "create-menu-proxy", G_CALLBACK(toolitem_createMenuProxyHandler), data);
	}

*/
/*

	void toolitem_toolbarReconfiguredHandler(GObject *, gpointer);

	static gulong ToolItem_signal_connect_toolbar_reconfigured(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toolbar-reconfigured", G_CALLBACK(toolitem_toolbarReconfiguredHandler), data);
	}

*/
/*

	gboolean toolbar_focusHomeOrEndHandler(GObject *, gboolean, gpointer);

	static gulong Toolbar_signal_connect_focus_home_or_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-home-or-end", G_CALLBACK(toolbar_focusHomeOrEndHandler), data);
	}

*/
/*

	void toolbar_orientationChangedHandler(GObject *, GtkOrientation, gpointer);

	static gulong Toolbar_signal_connect_orientation_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "orientation-changed", G_CALLBACK(toolbar_orientationChangedHandler), data);
	}

*/
/*

	gboolean toolbar_popupContextMenuHandler(GObject *, gint, gint, gint, gpointer);

	static gulong Toolbar_signal_connect_popup_context_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup-context-menu", G_CALLBACK(toolbar_popupContextMenuHandler), data);
	}

*/
/*

	void toolbar_styleChangedHandler(GObject *, GtkToolbarStyle, gpointer);

	static gulong Toolbar_signal_connect_style_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "style-changed", G_CALLBACK(toolbar_styleChangedHandler), data);
	}

*/
/*

	void treeselection_changedHandler(GObject *, gpointer);

	static gulong TreeSelection_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(treeselection_changedHandler), data);
	}

*/
/*

	void treeview_columnsChangedHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_columns_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "columns-changed", G_CALLBACK(treeview_columnsChangedHandler), data);
	}

*/
/*

	void treeview_cursorChangedHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_cursor_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "cursor-changed", G_CALLBACK(treeview_cursorChangedHandler), data);
	}

*/
/*

	gboolean treeview_expandCollapseCursorRowHandler(GObject *, gboolean, gboolean, gboolean, gpointer);

	static gulong TreeView_signal_connect_expand_collapse_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "expand-collapse-cursor-row", G_CALLBACK(treeview_expandCollapseCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_moveCursorHandler(GObject *, GtkMovementStep, gint, gpointer);

	static gulong TreeView_signal_connect_move_cursor(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-cursor", G_CALLBACK(treeview_moveCursorHandler), data);
	}

*/
/*

	void treeview_rowActivatedHandler(GObject *, GtkTreePath *, GtkTreeViewColumn *, gpointer);

	static gulong TreeView_signal_connect_row_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-activated", G_CALLBACK(treeview_rowActivatedHandler), data);
	}

*/
/*

	void treeview_rowCollapsedHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_row_collapsed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-collapsed", G_CALLBACK(treeview_rowCollapsedHandler), data);
	}

*/
/*

	void treeview_rowExpandedHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_row_expanded(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-expanded", G_CALLBACK(treeview_rowExpandedHandler), data);
	}

*/
/*

	gboolean treeview_selectAllHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_select_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-all", G_CALLBACK(treeview_selectAllHandler), data);
	}

*/
/*

	gboolean treeview_selectCursorParentHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_select_cursor_parent(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-parent", G_CALLBACK(treeview_selectCursorParentHandler), data);
	}

*/
/*

	gboolean treeview_selectCursorRowHandler(GObject *, gboolean, gpointer);

	static gulong TreeView_signal_connect_select_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "select-cursor-row", G_CALLBACK(treeview_selectCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_startInteractiveSearchHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_start_interactive_search(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "start-interactive-search", G_CALLBACK(treeview_startInteractiveSearchHandler), data);
	}

*/
/*

	gboolean treeview_testCollapseRowHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_test_collapse_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "test-collapse-row", G_CALLBACK(treeview_testCollapseRowHandler), data);
	}

*/
/*

	gboolean treeview_testExpandRowHandler(GObject *, GtkTreeIter *, GtkTreePath *, gpointer);

	static gulong TreeView_signal_connect_test_expand_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "test-expand-row", G_CALLBACK(treeview_testExpandRowHandler), data);
	}

*/
/*

	gboolean treeview_toggleCursorRowHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_toggle_cursor_row(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "toggle-cursor-row", G_CALLBACK(treeview_toggleCursorRowHandler), data);
	}

*/
/*

	gboolean treeview_unselectAllHandler(GObject *, gpointer);

	static gulong TreeView_signal_connect_unselect_all(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unselect-all", G_CALLBACK(treeview_unselectAllHandler), data);
	}

*/
/*

	void treeviewcolumn_clickedHandler(GObject *, gpointer);

	static gulong TreeViewColumn_signal_connect_clicked(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "clicked", G_CALLBACK(treeviewcolumn_clickedHandler), data);
	}

*/
/*

	void uimanager_actionsChangedHandler(GObject *, gpointer);

	static gulong UIManager_signal_connect_actions_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "actions-changed", G_CALLBACK(uimanager_actionsChangedHandler), data);
	}

*/
/*

	void uimanager_addWidgetHandler(GObject *, GtkWidget *, gpointer);

	static gulong UIManager_signal_connect_add_widget(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "add-widget", G_CALLBACK(uimanager_addWidgetHandler), data);
	}

*/
/*

	void uimanager_connectProxyHandler(GObject *, GtkAction *, GtkWidget *, gpointer);

	static gulong UIManager_signal_connect_connect_proxy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "connect-proxy", G_CALLBACK(uimanager_connectProxyHandler), data);
	}

*/
/*

	void uimanager_disconnectProxyHandler(GObject *, GtkAction *, GtkWidget *, gpointer);

	static gulong UIManager_signal_connect_disconnect_proxy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "disconnect-proxy", G_CALLBACK(uimanager_disconnectProxyHandler), data);
	}

*/
/*

	void uimanager_postActivateHandler(GObject *, GtkAction *, gpointer);

	static gulong UIManager_signal_connect_post_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "post-activate", G_CALLBACK(uimanager_postActivateHandler), data);
	}

*/
/*

	void uimanager_preActivateHandler(GObject *, GtkAction *, gpointer);

	static gulong UIManager_signal_connect_pre_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "pre-activate", G_CALLBACK(uimanager_preActivateHandler), data);
	}

*/
/*

	void widget_accelClosuresChangedHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_accel_closures_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "accel-closures-changed", G_CALLBACK(widget_accelClosuresChangedHandler), data);
	}

*/
/*

	gboolean widget_buttonPressEventHandler(GObject *, GdkEventButton *, gpointer);

	static gulong Widget_signal_connect_button_press_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "button-press-event", G_CALLBACK(widget_buttonPressEventHandler), data);
	}

*/
/*

	gboolean widget_buttonReleaseEventHandler(GObject *, GdkEventButton *, gpointer);

	static gulong Widget_signal_connect_button_release_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "button-release-event", G_CALLBACK(widget_buttonReleaseEventHandler), data);
	}

*/
/*

	gboolean widget_canActivateAccelHandler(GObject *, guint, gpointer);

	static gulong Widget_signal_connect_can_activate_accel(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "can-activate-accel", G_CALLBACK(widget_canActivateAccelHandler), data);
	}

*/
/*

	void widget_childNotifyHandler(GObject *, GParamSpec *, gpointer);

	static gulong Widget_signal_connect_child_notify(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "child-notify", G_CALLBACK(widget_childNotifyHandler), data);
	}

*/
/*

	void widget_compositedChangedHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_composited_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "composited-changed", G_CALLBACK(widget_compositedChangedHandler), data);
	}

*/
/*

	gboolean widget_configureEventHandler(GObject *, GdkEventConfigure *, gpointer);

	static gulong Widget_signal_connect_configure_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "configure-event", G_CALLBACK(widget_configureEventHandler), data);
	}

*/
/*

	gboolean widget_deleteEventHandler(GObject *, GdkEvent_ *, gpointer);

	static gulong Widget_signal_connect_delete_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-event", G_CALLBACK(widget_deleteEventHandler), data);
	}

*/
/*

	void widget_destroyHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_destroy(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "destroy", G_CALLBACK(widget_destroyHandler), data);
	}

*/
/*

	gboolean widget_destroyEventHandler(GObject *, GdkEvent_ *, gpointer);

	static gulong Widget_signal_connect_destroy_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "destroy-event", G_CALLBACK(widget_destroyEventHandler), data);
	}

*/
/*

	void widget_directionChangedHandler(GObject *, GtkTextDirection, gpointer);

	static gulong Widget_signal_connect_direction_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "direction-changed", G_CALLBACK(widget_directionChangedHandler), data);
	}

*/
/*

	void widget_dragBeginHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_begin(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-begin", G_CALLBACK(widget_dragBeginHandler), data);
	}

*/
/*

	void widget_dragDataDeleteHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_data_delete(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-data-delete", G_CALLBACK(widget_dragDataDeleteHandler), data);
	}

*/
/*

	void widget_dragDataGetHandler(GObject *, GdkDragContext *, GtkSelectionData *, guint, guint, gpointer);

	static gulong Widget_signal_connect_drag_data_get(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-data-get", G_CALLBACK(widget_dragDataGetHandler), data);
	}

*/
/*

	void widget_dragDataReceivedHandler(GObject *, GdkDragContext *, gint, gint, GtkSelectionData *, guint, guint, gpointer);

	static gulong Widget_signal_connect_drag_data_received(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-data-received", G_CALLBACK(widget_dragDataReceivedHandler), data);
	}

*/
/*

	gboolean widget_dragDropHandler(GObject *, GdkDragContext *, gint, gint, guint, gpointer);

	static gulong Widget_signal_connect_drag_drop(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-drop", G_CALLBACK(widget_dragDropHandler), data);
	}

*/
/*

	void widget_dragEndHandler(GObject *, GdkDragContext *, gpointer);

	static gulong Widget_signal_connect_drag_end(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-end", G_CALLBACK(widget_dragEndHandler), data);
	}

*/
/*

	gboolean widget_dragFailedHandler(GObject *, GdkDragContext *, GtkDragResult, gpointer);

	static gulong Widget_signal_connect_drag_failed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-failed", G_CALLBACK(widget_dragFailedHandler), data);
	}

*/
/*

	void widget_dragLeaveHandler(GObject *, GdkDragContext *, guint, gpointer);

	static gulong Widget_signal_connect_drag_leave(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-leave", G_CALLBACK(widget_dragLeaveHandler), data);
	}

*/
/*

	gboolean widget_dragMotionHandler(GObject *, GdkDragContext *, gint, gint, guint, gpointer);

	static gulong Widget_signal_connect_drag_motion(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "drag-motion", G_CALLBACK(widget_dragMotionHandler), data);
	}

*/
/*

	gboolean widget_enterNotifyEventHandler(GObject *, GdkEventCrossing *, gpointer);

	static gulong Widget_signal_connect_enter_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enter-notify-event", G_CALLBACK(widget_enterNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_eventHandler(GObject *, GdkEvent_ *, gpointer);

	static gulong Widget_signal_connect_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "event", G_CALLBACK(widget_eventHandler), data);
	}

*/
/*

	void widget_eventAfterHandler(GObject *, GdkEvent_ *, gpointer);

	static gulong Widget_signal_connect_event_after(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "event-after", G_CALLBACK(widget_eventAfterHandler), data);
	}

*/
/*

	gboolean widget_focusHandler(GObject *, GtkDirectionType, gpointer);

	static gulong Widget_signal_connect_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus", G_CALLBACK(widget_focusHandler), data);
	}

*/
/*

	gboolean widget_focusInEventHandler(GObject *, GdkEventFocus *, gpointer);

	static gulong Widget_signal_connect_focus_in_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-in-event", G_CALLBACK(widget_focusInEventHandler), data);
	}

*/
/*

	gboolean widget_focusOutEventHandler(GObject *, GdkEventFocus *, gpointer);

	static gulong Widget_signal_connect_focus_out_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "focus-out-event", G_CALLBACK(widget_focusOutEventHandler), data);
	}

*/
/*

	gboolean widget_grabBrokenEventHandler(GObject *, GdkEventGrabBroken *, gpointer);

	static gulong Widget_signal_connect_grab_broken_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-broken-event", G_CALLBACK(widget_grabBrokenEventHandler), data);
	}

*/
/*

	void widget_grabFocusHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_grab_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-focus", G_CALLBACK(widget_grabFocusHandler), data);
	}

*/
/*

	void widget_grabNotifyHandler(GObject *, gboolean, gpointer);

	static gulong Widget_signal_connect_grab_notify(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "grab-notify", G_CALLBACK(widget_grabNotifyHandler), data);
	}

*/
/*

	void widget_hideHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_hide(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "hide", G_CALLBACK(widget_hideHandler), data);
	}

*/
/*

	void widget_hierarchyChangedHandler(GObject *, GtkWidget *, gpointer);

	static gulong Widget_signal_connect_hierarchy_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "hierarchy-changed", G_CALLBACK(widget_hierarchyChangedHandler), data);
	}

*/
/*

	gboolean widget_keyPressEventHandler(GObject *, GdkEventKey *, gpointer);

	static gulong Widget_signal_connect_key_press_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "key-press-event", G_CALLBACK(widget_keyPressEventHandler), data);
	}

*/
/*

	gboolean widget_keyReleaseEventHandler(GObject *, GdkEventKey *, gpointer);

	static gulong Widget_signal_connect_key_release_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "key-release-event", G_CALLBACK(widget_keyReleaseEventHandler), data);
	}

*/
/*

	gboolean widget_keynavFailedHandler(GObject *, GtkDirectionType, gpointer);

	static gulong Widget_signal_connect_keynav_failed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "keynav-failed", G_CALLBACK(widget_keynavFailedHandler), data);
	}

*/
/*

	gboolean widget_leaveNotifyEventHandler(GObject *, GdkEventCrossing *, gpointer);

	static gulong Widget_signal_connect_leave_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "leave-notify-event", G_CALLBACK(widget_leaveNotifyEventHandler), data);
	}

*/
/*

	void widget_mapHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_map(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "map", G_CALLBACK(widget_mapHandler), data);
	}

*/
/*

	gboolean widget_mapEventHandler(GObject *, GdkEventAny *, gpointer);

	static gulong Widget_signal_connect_map_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "map-event", G_CALLBACK(widget_mapEventHandler), data);
	}

*/
/*

	gboolean widget_mnemonicActivateHandler(GObject *, gboolean, gpointer);

	static gulong Widget_signal_connect_mnemonic_activate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "mnemonic-activate", G_CALLBACK(widget_mnemonicActivateHandler), data);
	}

*/
/*

	gboolean widget_motionNotifyEventHandler(GObject *, GdkEventMotion *, gpointer);

	static gulong Widget_signal_connect_motion_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "motion-notify-event", G_CALLBACK(widget_motionNotifyEventHandler), data);
	}

*/
/*

	void widget_moveFocusHandler(GObject *, GtkDirectionType, gpointer);

	static gulong Widget_signal_connect_move_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "move-focus", G_CALLBACK(widget_moveFocusHandler), data);
	}

*/
/*

	void widget_parentSetHandler(GObject *, GtkWidget *, gpointer);

	static gulong Widget_signal_connect_parent_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "parent-set", G_CALLBACK(widget_parentSetHandler), data);
	}

*/
/*

	gboolean widget_popupMenuHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_popup_menu(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "popup-menu", G_CALLBACK(widget_popupMenuHandler), data);
	}

*/
/*

	gboolean widget_propertyNotifyEventHandler(GObject *, GdkEventProperty *, gpointer);

	static gulong Widget_signal_connect_property_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "property-notify-event", G_CALLBACK(widget_propertyNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_proximityInEventHandler(GObject *, GdkEventProximity *, gpointer);

	static gulong Widget_signal_connect_proximity_in_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "proximity-in-event", G_CALLBACK(widget_proximityInEventHandler), data);
	}

*/
/*

	gboolean widget_proximityOutEventHandler(GObject *, GdkEventProximity *, gpointer);

	static gulong Widget_signal_connect_proximity_out_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "proximity-out-event", G_CALLBACK(widget_proximityOutEventHandler), data);
	}

*/
/*

	gboolean widget_queryTooltipHandler(GObject *, gint, gint, gboolean, GtkTooltip *, gpointer);

	static gulong Widget_signal_connect_query_tooltip(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "query-tooltip", G_CALLBACK(widget_queryTooltipHandler), data);
	}

*/
/*

	void widget_realizeHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_realize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "realize", G_CALLBACK(widget_realizeHandler), data);
	}

*/
/*

	void widget_screenChangedHandler(GObject *, GdkScreen *, gpointer);

	static gulong Widget_signal_connect_screen_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "screen-changed", G_CALLBACK(widget_screenChangedHandler), data);
	}

*/
/*

	gboolean widget_scrollEventHandler(GObject *, GdkEventScroll *, gpointer);

	static gulong Widget_signal_connect_scroll_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "scroll-event", G_CALLBACK(widget_scrollEventHandler), data);
	}

*/
/*

	gboolean widget_selectionClearEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_clear_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-clear-event", G_CALLBACK(widget_selectionClearEventHandler), data);
	}

*/
/*

	void widget_selectionGetHandler(GObject *, GtkSelectionData *, guint, guint, gpointer);

	static gulong Widget_signal_connect_selection_get(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-get", G_CALLBACK(widget_selectionGetHandler), data);
	}

*/
/*

	gboolean widget_selectionNotifyEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-notify-event", G_CALLBACK(widget_selectionNotifyEventHandler), data);
	}

*/
/*

	void widget_selectionReceivedHandler(GObject *, GtkSelectionData *, guint, gpointer);

	static gulong Widget_signal_connect_selection_received(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-received", G_CALLBACK(widget_selectionReceivedHandler), data);
	}

*/
/*

	gboolean widget_selectionRequestEventHandler(GObject *, GdkEventSelection *, gpointer);

	static gulong Widget_signal_connect_selection_request_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-request-event", G_CALLBACK(widget_selectionRequestEventHandler), data);
	}

*/
/*

	void widget_showHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_show(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show", G_CALLBACK(widget_showHandler), data);
	}

*/
/*

	gboolean widget_showHelpHandler(GObject *, GtkWidgetHelpType, gpointer);

	static gulong Widget_signal_connect_show_help(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "show-help", G_CALLBACK(widget_showHelpHandler), data);
	}

*/
/*

	void widget_sizeAllocateHandler(GObject *, GdkRectangle *, gpointer);

	static gulong Widget_signal_connect_size_allocate(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "size-allocate", G_CALLBACK(widget_sizeAllocateHandler), data);
	}

*/
/*

	void widget_stateChangedHandler(GObject *, GtkStateType, gpointer);

	static gulong Widget_signal_connect_state_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "state-changed", G_CALLBACK(widget_stateChangedHandler), data);
	}

*/
/*

	void widget_styleSetHandler(GObject *, GtkStyle *, gpointer);

	static gulong Widget_signal_connect_style_set(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "style-set", G_CALLBACK(widget_styleSetHandler), data);
	}

*/
/*

	gboolean widget_touchEventHandler(GObject *, GdkEvent_ *, gpointer);

	static gulong Widget_signal_connect_touch_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "touch-event", G_CALLBACK(widget_touchEventHandler), data);
	}

*/
/*

	void widget_unmapHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_unmap(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmap", G_CALLBACK(widget_unmapHandler), data);
	}

*/
/*

	gboolean widget_unmapEventHandler(GObject *, GdkEventAny *, gpointer);

	static gulong Widget_signal_connect_unmap_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unmap-event", G_CALLBACK(widget_unmapEventHandler), data);
	}

*/
/*

	void widget_unrealizeHandler(GObject *, gpointer);

	static gulong Widget_signal_connect_unrealize(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "unrealize", G_CALLBACK(widget_unrealizeHandler), data);
	}

*/
/*

	gboolean widget_visibilityNotifyEventHandler(GObject *, GdkEventVisibility *, gpointer);

	static gulong Widget_signal_connect_visibility_notify_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "visibility-notify-event", G_CALLBACK(widget_visibilityNotifyEventHandler), data);
	}

*/
/*

	gboolean widget_windowStateEventHandler(GObject *, GdkEventWindowState *, gpointer);

	static gulong Widget_signal_connect_window_state_event(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "window-state-event", G_CALLBACK(widget_windowStateEventHandler), data);
	}

*/
/*

	void window_activateDefaultHandler(GObject *, gpointer);

	static gulong Window_signal_connect_activate_default(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-default", G_CALLBACK(window_activateDefaultHandler), data);
	}

*/
/*

	void window_activateFocusHandler(GObject *, gpointer);

	static gulong Window_signal_connect_activate_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "activate-focus", G_CALLBACK(window_activateFocusHandler), data);
	}

*/
/*

	gboolean window_enableDebuggingHandler(GObject *, gboolean, gpointer);

	static gulong Window_signal_connect_enable_debugging(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "enable-debugging", G_CALLBACK(window_enableDebuggingHandler), data);
	}

*/
/*

	void window_keysChangedHandler(GObject *, gpointer);

	static gulong Window_signal_connect_keys_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "keys-changed", G_CALLBACK(window_keysChangedHandler), data);
	}

*/
/*

	void window_setFocusHandler(GObject *, GtkWidget *, gpointer);

	static gulong Window_signal_connect_set_focus(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "set-focus", G_CALLBACK(window_setFocusHandler), data);
	}

*/
/*

	void celleditable_editingDoneHandler(GObject *, gpointer);

	static gulong CellEditable_signal_connect_editing_done(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "editing-done", G_CALLBACK(celleditable_editingDoneHandler), data);
	}

*/
/*

	void celleditable_removeWidgetHandler(GObject *, gpointer);

	static gulong CellEditable_signal_connect_remove_widget(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "remove-widget", G_CALLBACK(celleditable_removeWidgetHandler), data);
	}

*/
/*

	void editable_changedHandler(GObject *, gpointer);

	static gulong Editable_signal_connect_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "changed", G_CALLBACK(editable_changedHandler), data);
	}

*/
/*

	void editable_deleteTextHandler(GObject *, gint, gint, gpointer);

	static gulong Editable_signal_connect_delete_text(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "delete-text", G_CALLBACK(editable_deleteTextHandler), data);
	}

*/
/*

	void filechooser_currentFolderChangedHandler(GObject *, gpointer);

	static gulong FileChooser_signal_connect_current_folder_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "current-folder-changed", G_CALLBACK(filechooser_currentFolderChangedHandler), data);
	}

*/
/*

	void filechooser_fileActivatedHandler(GObject *, gpointer);

	static gulong FileChooser_signal_connect_file_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "file-activated", G_CALLBACK(filechooser_fileActivatedHandler), data);
	}

*/
/*

	void filechooser_selectionChangedHandler(GObject *, gpointer);

	static gulong FileChooser_signal_connect_selection_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-changed", G_CALLBACK(filechooser_selectionChangedHandler), data);
	}

*/
/*

	void filechooser_updatePreviewHandler(GObject *, gpointer);

	static gulong FileChooser_signal_connect_update_preview(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "update-preview", G_CALLBACK(filechooser_updatePreviewHandler), data);
	}

*/
/*

	void fontchooser_fontActivatedHandler(GObject *, gchar*, gpointer);

	static gulong FontChooser_signal_connect_font_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "font-activated", G_CALLBACK(fontchooser_fontActivatedHandler), data);
	}

*/
/*

	void printoperationpreview_gotPageSizeHandler(GObject *, GtkPrintContext *, GtkPageSetup *, gpointer);

	static gulong PrintOperationPreview_signal_connect_got_page_size(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "got-page-size", G_CALLBACK(printoperationpreview_gotPageSizeHandler), data);
	}

*/
/*

	void printoperationpreview_readyHandler(GObject *, GtkPrintContext *, gpointer);

	static gulong PrintOperationPreview_signal_connect_ready(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "ready", G_CALLBACK(printoperationpreview_readyHandler), data);
	}

*/
/*

	void recentchooser_itemActivatedHandler(GObject *, gpointer);

	static gulong RecentChooser_signal_connect_item_activated(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "item-activated", G_CALLBACK(recentchooser_itemActivatedHandler), data);
	}

*/
/*

	void recentchooser_selectionChangedHandler(GObject *, gpointer);

	static gulong RecentChooser_signal_connect_selection_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "selection-changed", G_CALLBACK(recentchooser_selectionChangedHandler), data);
	}

*/
/*

	void treemodel_rowChangedHandler(GObject *, GtkTreePath *, GtkTreeIter *, gpointer);

	static gulong TreeModel_signal_connect_row_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-changed", G_CALLBACK(treemodel_rowChangedHandler), data);
	}

*/
/*

	void treemodel_rowDeletedHandler(GObject *, GtkTreePath *, gpointer);

	static gulong TreeModel_signal_connect_row_deleted(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-deleted", G_CALLBACK(treemodel_rowDeletedHandler), data);
	}

*/
/*

	void treemodel_rowHasChildToggledHandler(GObject *, GtkTreePath *, GtkTreeIter *, gpointer);

	static gulong TreeModel_signal_connect_row_has_child_toggled(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-has-child-toggled", G_CALLBACK(treemodel_rowHasChildToggledHandler), data);
	}

*/
/*

	void treemodel_rowInsertedHandler(GObject *, GtkTreePath *, GtkTreeIter *, gpointer);

	static gulong TreeModel_signal_connect_row_inserted(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "row-inserted", G_CALLBACK(treemodel_rowInsertedHandler), data);
	}

*/
/*

	void treesortable_sortColumnChangedHandler(GObject *, gpointer);

	static gulong TreeSortable_signal_connect_sort_column_changed(gpointer instance, gpointer data) {
		return g_signal_connect(instance, "sort-column-changed", G_CALLBACK(treesortable_sortColumnChangedHandler), data);
	}

*/
import "C"

var gobjectClassGoTypeMap = make(map[string]reflect.Type)

// Allocation is a representation of the C alias GtkAllocation.
type Allocation *gdk.Rectangle

// Stock is a representation of the C alias GtkStock.
type Stock string

type AccelFlags C.GtkAccelFlags

const (
	GTK_ACCEL_VISIBLE AccelFlags = 1
	GTK_ACCEL_LOCKED  AccelFlags = 2
	GTK_ACCEL_MASK    AccelFlags = 7
)

type AttachOptions C.GtkAttachOptions

const (
	GTK_EXPAND AttachOptions = 1
	GTK_SHRINK AttachOptions = 2
	GTK_FILL   AttachOptions = 4
)

type CalendarDisplayOptions C.GtkCalendarDisplayOptions

const (
	GTK_CALENDAR_SHOW_HEADING      CalendarDisplayOptions = 1
	GTK_CALENDAR_SHOW_DAY_NAMES    CalendarDisplayOptions = 2
	GTK_CALENDAR_NO_MONTH_CHANGE   CalendarDisplayOptions = 4
	GTK_CALENDAR_SHOW_WEEK_NUMBERS CalendarDisplayOptions = 8
	GTK_CALENDAR_SHOW_DETAILS      CalendarDisplayOptions = 32
)

type CellRendererState C.GtkCellRendererState

const (
	GTK_CELL_RENDERER_SELECTED    CellRendererState = 1
	GTK_CELL_RENDERER_PRELIT      CellRendererState = 2
	GTK_CELL_RENDERER_INSENSITIVE CellRendererState = 4
	GTK_CELL_RENDERER_SORTED      CellRendererState = 8
	GTK_CELL_RENDERER_FOCUSED     CellRendererState = 16
	GTK_CELL_RENDERER_EXPANDABLE  CellRendererState = 32
	GTK_CELL_RENDERER_EXPANDED    CellRendererState = 64
)

type DebugFlag C.GtkDebugFlag

const (
	GTK_DEBUG_MISC           DebugFlag = 1
	GTK_DEBUG_PLUGSOCKET     DebugFlag = 2
	GTK_DEBUG_TEXT           DebugFlag = 4
	GTK_DEBUG_TREE           DebugFlag = 8
	GTK_DEBUG_UPDATES        DebugFlag = 16
	GTK_DEBUG_KEYBINDINGS    DebugFlag = 32
	GTK_DEBUG_MULTIHEAD      DebugFlag = 64
	GTK_DEBUG_MODULES        DebugFlag = 128
	GTK_DEBUG_GEOMETRY       DebugFlag = 256
	GTK_DEBUG_ICONTHEME      DebugFlag = 512
	GTK_DEBUG_PRINTING       DebugFlag = 1024
	GTK_DEBUG_BUILDER        DebugFlag = 2048
	GTK_DEBUG_SIZE_REQUEST   DebugFlag = 4096
	GTK_DEBUG_NO_CSS_CACHE   DebugFlag = 8192
	GTK_DEBUG_BASELINES      DebugFlag = 16384
	GTK_DEBUG_PIXEL_CACHE    DebugFlag = 32768
	GTK_DEBUG_NO_PIXEL_CACHE DebugFlag = 65536
	GTK_DEBUG_INTERACTIVE    DebugFlag = 131072
	GTK_DEBUG_TOUCHSCREEN    DebugFlag = 262144
	GTK_DEBUG_ACTIONS        DebugFlag = 524288
	GTK_DEBUG_RESIZE         DebugFlag = 1048576
	GTK_DEBUG_LAYOUT         DebugFlag = 2097152
)

type DestDefaults C.GtkDestDefaults

const (
	GTK_DEST_DEFAULT_MOTION    DestDefaults = 1
	GTK_DEST_DEFAULT_HIGHLIGHT DestDefaults = 2
	GTK_DEST_DEFAULT_DROP      DestDefaults = 4
	GTK_DEST_DEFAULT_ALL       DestDefaults = 7
)

type DialogFlags C.GtkDialogFlags

const (
	GTK_DIALOG_MODAL               DialogFlags = 1
	GTK_DIALOG_DESTROY_WITH_PARENT DialogFlags = 2
	GTK_DIALOG_USE_HEADER_BAR      DialogFlags = 4
)

type FileFilterFlags C.GtkFileFilterFlags

const (
	GTK_FILE_FILTER_FILENAME     FileFilterFlags = 1
	GTK_FILE_FILTER_URI          FileFilterFlags = 2
	GTK_FILE_FILTER_DISPLAY_NAME FileFilterFlags = 4
	GTK_FILE_FILTER_MIME_TYPE    FileFilterFlags = 8
)

type IconLookupFlags C.GtkIconLookupFlags

const (
	GTK_ICON_LOOKUP_NO_SVG           IconLookupFlags = 1
	GTK_ICON_LOOKUP_FORCE_SVG        IconLookupFlags = 2
	GTK_ICON_LOOKUP_USE_BUILTIN      IconLookupFlags = 4
	GTK_ICON_LOOKUP_GENERIC_FALLBACK IconLookupFlags = 8
	GTK_ICON_LOOKUP_FORCE_SIZE       IconLookupFlags = 16
	GTK_ICON_LOOKUP_FORCE_REGULAR    IconLookupFlags = 32
	GTK_ICON_LOOKUP_FORCE_SYMBOLIC   IconLookupFlags = 64
	GTK_ICON_LOOKUP_DIR_LTR          IconLookupFlags = 128
	GTK_ICON_LOOKUP_DIR_RTL          IconLookupFlags = 256
)

type JunctionSides C.GtkJunctionSides

const (
	GTK_JUNCTION_NONE               JunctionSides = 0
	GTK_JUNCTION_CORNER_TOPLEFT     JunctionSides = 1
	GTK_JUNCTION_CORNER_TOPRIGHT    JunctionSides = 2
	GTK_JUNCTION_CORNER_BOTTOMLEFT  JunctionSides = 4
	GTK_JUNCTION_CORNER_BOTTOMRIGHT JunctionSides = 8
	GTK_JUNCTION_TOP                JunctionSides = 3
	GTK_JUNCTION_BOTTOM             JunctionSides = 12
	GTK_JUNCTION_LEFT               JunctionSides = 5
	GTK_JUNCTION_RIGHT              JunctionSides = 10
)

type PlacesOpenFlags C.GtkPlacesOpenFlags

const (
	GTK_PLACES_OPEN_NORMAL     PlacesOpenFlags = 1
	GTK_PLACES_OPEN_NEW_TAB    PlacesOpenFlags = 2
	GTK_PLACES_OPEN_NEW_WINDOW PlacesOpenFlags = 4
)

type RcFlags C.GtkRcFlags

const (
	GTK_RC_FG   RcFlags = 1
	GTK_RC_BG   RcFlags = 2
	GTK_RC_TEXT RcFlags = 4
	GTK_RC_BASE RcFlags = 8
)

type RecentFilterFlags C.GtkRecentFilterFlags

const (
	GTK_RECENT_FILTER_URI          RecentFilterFlags = 1
	GTK_RECENT_FILTER_DISPLAY_NAME RecentFilterFlags = 2
	GTK_RECENT_FILTER_MIME_TYPE    RecentFilterFlags = 4
	GTK_RECENT_FILTER_APPLICATION  RecentFilterFlags = 8
	GTK_RECENT_FILTER_GROUP        RecentFilterFlags = 16
	GTK_RECENT_FILTER_AGE          RecentFilterFlags = 32
)

type RegionFlags C.GtkRegionFlags

const (
	GTK_REGION_EVEN   RegionFlags = 1
	GTK_REGION_ODD    RegionFlags = 2
	GTK_REGION_FIRST  RegionFlags = 4
	GTK_REGION_LAST   RegionFlags = 8
	GTK_REGION_ONLY   RegionFlags = 16
	GTK_REGION_SORTED RegionFlags = 32
)

type StateFlags C.GtkStateFlags

const (
	GTK_STATE_FLAG_NORMAL       StateFlags = 0
	GTK_STATE_FLAG_ACTIVE       StateFlags = 1
	GTK_STATE_FLAG_PRELIGHT     StateFlags = 2
	GTK_STATE_FLAG_SELECTED     StateFlags = 4
	GTK_STATE_FLAG_INSENSITIVE  StateFlags = 8
	GTK_STATE_FLAG_INCONSISTENT StateFlags = 16
	GTK_STATE_FLAG_FOCUSED      StateFlags = 32
	GTK_STATE_FLAG_BACKDROP     StateFlags = 64
	GTK_STATE_FLAG_DIR_LTR      StateFlags = 128
	GTK_STATE_FLAG_DIR_RTL      StateFlags = 256
	GTK_STATE_FLAG_LINK         StateFlags = 512
	GTK_STATE_FLAG_VISITED      StateFlags = 1024
	GTK_STATE_FLAG_CHECKED      StateFlags = 2048
	GTK_STATE_FLAG_DROP_ACTIVE  StateFlags = 4096
)

type TargetFlags C.GtkTargetFlags

const (
	GTK_TARGET_SAME_APP     TargetFlags = 1
	GTK_TARGET_SAME_WIDGET  TargetFlags = 2
	GTK_TARGET_OTHER_APP    TargetFlags = 4
	GTK_TARGET_OTHER_WIDGET TargetFlags = 8
)

type TextSearchFlags C.GtkTextSearchFlags

const (
	GTK_TEXT_SEARCH_VISIBLE_ONLY     TextSearchFlags = 1
	GTK_TEXT_SEARCH_TEXT_ONLY        TextSearchFlags = 2
	GTK_TEXT_SEARCH_CASE_INSENSITIVE TextSearchFlags = 4
)

type ToolPaletteDragTargets C.GtkToolPaletteDragTargets

const (
	GTK_TOOL_PALETTE_DRAG_ITEMS  ToolPaletteDragTargets = 1
	GTK_TOOL_PALETTE_DRAG_GROUPS ToolPaletteDragTargets = 2
)

type TreeModelFlags C.GtkTreeModelFlags

const (
	GTK_TREE_MODEL_ITERS_PERSIST TreeModelFlags = 1
	GTK_TREE_MODEL_LIST_ONLY     TreeModelFlags = 2
)

type UIManagerItemType C.GtkUIManagerItemType

const (
	GTK_UI_MANAGER_AUTO              UIManagerItemType = 0
	GTK_UI_MANAGER_MENUBAR           UIManagerItemType = 1
	GTK_UI_MANAGER_MENU              UIManagerItemType = 2
	GTK_UI_MANAGER_TOOLBAR           UIManagerItemType = 4
	GTK_UI_MANAGER_PLACEHOLDER       UIManagerItemType = 8
	GTK_UI_MANAGER_POPUP             UIManagerItemType = 16
	GTK_UI_MANAGER_MENUITEM          UIManagerItemType = 32
	GTK_UI_MANAGER_TOOLITEM          UIManagerItemType = 64
	GTK_UI_MANAGER_SEPARATOR         UIManagerItemType = 128
	GTK_UI_MANAGER_ACCELERATOR       UIManagerItemType = 256
	GTK_UI_MANAGER_POPUP_WITH_ACCELS UIManagerItemType = 512
)

// AboutDialog is a wrapper around the C record GtkAboutDialog.
type AboutDialog struct {
	native *C.GtkAboutDialog
	// parent_instance : record
	// Private : priv
}

func AboutDialogNewFromC(u unsafe.Pointer) *AboutDialog {
	c := (*C.GtkAboutDialog)(u)
	if c == nil {
		return nil
	}

	g := &AboutDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AboutDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AboutDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AboutDialog with another AboutDialog, and returns true if they represent the same GObject.
func (recv *AboutDialog) Equals(other *AboutDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *AboutDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *AboutDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *AboutDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *AboutDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *AboutDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AboutDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AboutDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to AboutDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a AboutDialog.
func CastToAboutDialog(object *gobject.Object) *AboutDialog {
	return AboutDialogNewFromC(object.ToC())
}

// AboutDialogNew is a wrapper around the C function gtk_about_dialog_new.
func AboutDialogNew() *AboutDialog {
	retC := C.gtk_about_dialog_new()
	retGo := AboutDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetArtists is a wrapper around the C function gtk_about_dialog_get_artists.
func (recv *AboutDialog) GetArtists() []string {
	retC := C.gtk_about_dialog_get_artists((*C.GtkAboutDialog)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// GetAuthors is a wrapper around the C function gtk_about_dialog_get_authors.
func (recv *AboutDialog) GetAuthors() []string {
	retC := C.gtk_about_dialog_get_authors((*C.GtkAboutDialog)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// GetComments is a wrapper around the C function gtk_about_dialog_get_comments.
func (recv *AboutDialog) GetComments() string {
	retC := C.gtk_about_dialog_get_comments((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetCopyright is a wrapper around the C function gtk_about_dialog_get_copyright.
func (recv *AboutDialog) GetCopyright() string {
	retC := C.gtk_about_dialog_get_copyright((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDocumenters is a wrapper around the C function gtk_about_dialog_get_documenters.
func (recv *AboutDialog) GetDocumenters() []string {
	retC := C.gtk_about_dialog_get_documenters((*C.GtkAboutDialog)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// GetLicense is a wrapper around the C function gtk_about_dialog_get_license.
func (recv *AboutDialog) GetLicense() string {
	retC := C.gtk_about_dialog_get_license((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetLogo is a wrapper around the C function gtk_about_dialog_get_logo.
func (recv *AboutDialog) GetLogo() *gdkpixbuf.Pixbuf {
	retC := C.gtk_about_dialog_get_logo((*C.GtkAboutDialog)(recv.native))
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLogoIconName is a wrapper around the C function gtk_about_dialog_get_logo_icon_name.
func (recv *AboutDialog) GetLogoIconName() string {
	retC := C.gtk_about_dialog_get_logo_icon_name((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetProgramName is a wrapper around the C function gtk_about_dialog_get_program_name.
func (recv *AboutDialog) GetProgramName() string {
	retC := C.gtk_about_dialog_get_program_name((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetTranslatorCredits is a wrapper around the C function gtk_about_dialog_get_translator_credits.
func (recv *AboutDialog) GetTranslatorCredits() string {
	retC := C.gtk_about_dialog_get_translator_credits((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetVersion is a wrapper around the C function gtk_about_dialog_get_version.
func (recv *AboutDialog) GetVersion() string {
	retC := C.gtk_about_dialog_get_version((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetWebsite is a wrapper around the C function gtk_about_dialog_get_website.
func (recv *AboutDialog) GetWebsite() string {
	retC := C.gtk_about_dialog_get_website((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetWebsiteLabel is a wrapper around the C function gtk_about_dialog_get_website_label.
func (recv *AboutDialog) GetWebsiteLabel() string {
	retC := C.gtk_about_dialog_get_website_label((*C.GtkAboutDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetWrapLicense is a wrapper around the C function gtk_about_dialog_get_wrap_license.
func (recv *AboutDialog) GetWrapLicense() bool {
	retC := C.gtk_about_dialog_get_wrap_license((*C.GtkAboutDialog)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetArtists is a wrapper around the C function gtk_about_dialog_set_artists.
func (recv *AboutDialog) SetArtists(artists []string) {
	c_artists_array := make([]*C.gchar, len(artists)+1, len(artists)+1)
	for i, item := range artists {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_artists_array[i] = c
	}
	c_artists_array[len(artists)] = nil
	c_artists_arrayPtr := &c_artists_array[0]
	c_artists := (**C.gchar)(unsafe.Pointer(c_artists_arrayPtr))

	C.gtk_about_dialog_set_artists((*C.GtkAboutDialog)(recv.native), c_artists)

	return
}

// SetAuthors is a wrapper around the C function gtk_about_dialog_set_authors.
func (recv *AboutDialog) SetAuthors(authors []string) {
	c_authors_array := make([]*C.gchar, len(authors)+1, len(authors)+1)
	for i, item := range authors {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_authors_array[i] = c
	}
	c_authors_array[len(authors)] = nil
	c_authors_arrayPtr := &c_authors_array[0]
	c_authors := (**C.gchar)(unsafe.Pointer(c_authors_arrayPtr))

	C.gtk_about_dialog_set_authors((*C.GtkAboutDialog)(recv.native), c_authors)

	return
}

// SetComments is a wrapper around the C function gtk_about_dialog_set_comments.
func (recv *AboutDialog) SetComments(comments string) {
	c_comments := C.CString(comments)
	defer C.free(unsafe.Pointer(c_comments))

	C.gtk_about_dialog_set_comments((*C.GtkAboutDialog)(recv.native), c_comments)

	return
}

// SetCopyright is a wrapper around the C function gtk_about_dialog_set_copyright.
func (recv *AboutDialog) SetCopyright(copyright string) {
	c_copyright := C.CString(copyright)
	defer C.free(unsafe.Pointer(c_copyright))

	C.gtk_about_dialog_set_copyright((*C.GtkAboutDialog)(recv.native), c_copyright)

	return
}

// SetDocumenters is a wrapper around the C function gtk_about_dialog_set_documenters.
func (recv *AboutDialog) SetDocumenters(documenters []string) {
	c_documenters_array := make([]*C.gchar, len(documenters)+1, len(documenters)+1)
	for i, item := range documenters {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_documenters_array[i] = c
	}
	c_documenters_array[len(documenters)] = nil
	c_documenters_arrayPtr := &c_documenters_array[0]
	c_documenters := (**C.gchar)(unsafe.Pointer(c_documenters_arrayPtr))

	C.gtk_about_dialog_set_documenters((*C.GtkAboutDialog)(recv.native), c_documenters)

	return
}

// SetLicense is a wrapper around the C function gtk_about_dialog_set_license.
func (recv *AboutDialog) SetLicense(license string) {
	c_license := C.CString(license)
	defer C.free(unsafe.Pointer(c_license))

	C.gtk_about_dialog_set_license((*C.GtkAboutDialog)(recv.native), c_license)

	return
}

// SetLogo is a wrapper around the C function gtk_about_dialog_set_logo.
func (recv *AboutDialog) SetLogo(logo *gdkpixbuf.Pixbuf) {
	c_logo := (*C.GdkPixbuf)(C.NULL)
	if logo != nil {
		c_logo = (*C.GdkPixbuf)(logo.ToC())
	}

	C.gtk_about_dialog_set_logo((*C.GtkAboutDialog)(recv.native), c_logo)

	return
}

// SetLogoIconName is a wrapper around the C function gtk_about_dialog_set_logo_icon_name.
func (recv *AboutDialog) SetLogoIconName(iconName string) {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	C.gtk_about_dialog_set_logo_icon_name((*C.GtkAboutDialog)(recv.native), c_icon_name)

	return
}

// SetProgramName is a wrapper around the C function gtk_about_dialog_set_program_name.
func (recv *AboutDialog) SetProgramName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_about_dialog_set_program_name((*C.GtkAboutDialog)(recv.native), c_name)

	return
}

// SetTranslatorCredits is a wrapper around the C function gtk_about_dialog_set_translator_credits.
func (recv *AboutDialog) SetTranslatorCredits(translatorCredits string) {
	c_translator_credits := C.CString(translatorCredits)
	defer C.free(unsafe.Pointer(c_translator_credits))

	C.gtk_about_dialog_set_translator_credits((*C.GtkAboutDialog)(recv.native), c_translator_credits)

	return
}

// SetVersion is a wrapper around the C function gtk_about_dialog_set_version.
func (recv *AboutDialog) SetVersion(version string) {
	c_version := C.CString(version)
	defer C.free(unsafe.Pointer(c_version))

	C.gtk_about_dialog_set_version((*C.GtkAboutDialog)(recv.native), c_version)

	return
}

// SetWebsite is a wrapper around the C function gtk_about_dialog_set_website.
func (recv *AboutDialog) SetWebsite(website string) {
	c_website := C.CString(website)
	defer C.free(unsafe.Pointer(c_website))

	C.gtk_about_dialog_set_website((*C.GtkAboutDialog)(recv.native), c_website)

	return
}

// SetWebsiteLabel is a wrapper around the C function gtk_about_dialog_set_website_label.
func (recv *AboutDialog) SetWebsiteLabel(websiteLabel string) {
	c_website_label := C.CString(websiteLabel)
	defer C.free(unsafe.Pointer(c_website_label))

	C.gtk_about_dialog_set_website_label((*C.GtkAboutDialog)(recv.native), c_website_label)

	return
}

// SetWrapLicense is a wrapper around the C function gtk_about_dialog_set_wrap_license.
func (recv *AboutDialog) SetWrapLicense(wrapLicense bool) {
	c_wrap_license :=
		boolToGboolean(wrapLicense)

	C.gtk_about_dialog_set_wrap_license((*C.GtkAboutDialog)(recv.native), c_wrap_license)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AboutDialog
func (recv *AboutDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AboutDialog
func (recv *AboutDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AccelGroup is a wrapper around the C record GtkAccelGroup.
type AccelGroup struct {
	native *C.GtkAccelGroup
	// parent : record
	// priv : record
}

func AccelGroupNewFromC(u unsafe.Pointer) *AccelGroup {
	c := (*C.GtkAccelGroup)(u)
	if c == nil {
		return nil
	}

	g := &AccelGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AccelGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AccelGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelGroup with another AccelGroup, and returns true if they represent the same GObject.
func (recv *AccelGroup) Equals(other *AccelGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *AccelGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to AccelGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelGroup.
func CastToAccelGroup(object *gobject.Object) *AccelGroup {
	return AccelGroupNewFromC(object.ToC())
}

type signalAccelGroupAccelActivateDetail struct {
	callback  AccelGroupSignalAccelActivateCallback
	handlerID C.gulong
}

var signalAccelGroupAccelActivateId int
var signalAccelGroupAccelActivateMap = make(map[int]signalAccelGroupAccelActivateDetail)
var signalAccelGroupAccelActivateLock sync.RWMutex

// AccelGroupSignalAccelActivateCallback is a callback function for a 'accel-activate' signal emitted from a AccelGroup.
type AccelGroupSignalAccelActivateCallback func(acceleratable *gobject.Object, keyval uint32, modifier gdk.ModifierType) bool

/*
ConnectAccelActivate connects the callback to the 'accel-activate' signal for the AccelGroup.

The returned value represents the connection, and may be passed to DisconnectAccelActivate to remove it.
*/
func (recv *AccelGroup) ConnectAccelActivate(callback AccelGroupSignalAccelActivateCallback) int {
	signalAccelGroupAccelActivateLock.Lock()
	defer signalAccelGroupAccelActivateLock.Unlock()

	signalAccelGroupAccelActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.AccelGroup_signal_connect_accel_activate(instance, C.gpointer(uintptr(signalAccelGroupAccelActivateId)))

	detail := signalAccelGroupAccelActivateDetail{callback, handlerID}
	signalAccelGroupAccelActivateMap[signalAccelGroupAccelActivateId] = detail

	return signalAccelGroupAccelActivateId
}

/*
DisconnectAccelActivate disconnects a callback from the 'accel-activate' signal for the AccelGroup.

The connectionID should be a value returned from a call to ConnectAccelActivate.
*/
func (recv *AccelGroup) DisconnectAccelActivate(connectionID int) {
	signalAccelGroupAccelActivateLock.Lock()
	defer signalAccelGroupAccelActivateLock.Unlock()

	detail, exists := signalAccelGroupAccelActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAccelGroupAccelActivateMap, connectionID)
}

//export accelgroup_accelActivateHandler
func accelgroup_accelActivateHandler(_ *C.GObject, c_acceleratable *C.GObject, c_keyval C.guint, c_modifier C.guint, data C.gpointer) C.gboolean {
	signalAccelGroupAccelActivateLock.RLock()
	defer signalAccelGroupAccelActivateLock.RUnlock()

	acceleratable := gobject.ObjectNewFromC(unsafe.Pointer(c_acceleratable))

	keyval := uint32(c_keyval)

	modifier := gdk.ModifierType(c_modifier)

	index := int(uintptr(data))
	callback := signalAccelGroupAccelActivateMap[index].callback
	retGo := callback(acceleratable, keyval, modifier)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalAccelGroupAccelChangedDetail struct {
	callback  AccelGroupSignalAccelChangedCallback
	handlerID C.gulong
}

var signalAccelGroupAccelChangedId int
var signalAccelGroupAccelChangedMap = make(map[int]signalAccelGroupAccelChangedDetail)
var signalAccelGroupAccelChangedLock sync.RWMutex

// AccelGroupSignalAccelChangedCallback is a callback function for a 'accel-changed' signal emitted from a AccelGroup.
type AccelGroupSignalAccelChangedCallback func(keyval uint32, modifier gdk.ModifierType, accelClosure *gobject.Closure)

/*
ConnectAccelChanged connects the callback to the 'accel-changed' signal for the AccelGroup.

The returned value represents the connection, and may be passed to DisconnectAccelChanged to remove it.
*/
func (recv *AccelGroup) ConnectAccelChanged(callback AccelGroupSignalAccelChangedCallback) int {
	signalAccelGroupAccelChangedLock.Lock()
	defer signalAccelGroupAccelChangedLock.Unlock()

	signalAccelGroupAccelChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AccelGroup_signal_connect_accel_changed(instance, C.gpointer(uintptr(signalAccelGroupAccelChangedId)))

	detail := signalAccelGroupAccelChangedDetail{callback, handlerID}
	signalAccelGroupAccelChangedMap[signalAccelGroupAccelChangedId] = detail

	return signalAccelGroupAccelChangedId
}

/*
DisconnectAccelChanged disconnects a callback from the 'accel-changed' signal for the AccelGroup.

The connectionID should be a value returned from a call to ConnectAccelChanged.
*/
func (recv *AccelGroup) DisconnectAccelChanged(connectionID int) {
	signalAccelGroupAccelChangedLock.Lock()
	defer signalAccelGroupAccelChangedLock.Unlock()

	detail, exists := signalAccelGroupAccelChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAccelGroupAccelChangedMap, connectionID)
}

//export accelgroup_accelChangedHandler
func accelgroup_accelChangedHandler(_ *C.GObject, c_keyval C.guint, c_modifier C.guint, c_accel_closure *C.GClosure, data C.gpointer) {
	signalAccelGroupAccelChangedLock.RLock()
	defer signalAccelGroupAccelChangedLock.RUnlock()

	keyval := uint32(c_keyval)

	modifier := gdk.ModifierType(c_modifier)

	accelClosure := gobject.ClosureNewFromC(unsafe.Pointer(c_accel_closure))

	index := int(uintptr(data))
	callback := signalAccelGroupAccelChangedMap[index].callback
	callback(keyval, modifier, accelClosure)
}

// AccelGroupNew is a wrapper around the C function gtk_accel_group_new.
func AccelGroupNew() *AccelGroup {
	retC := C.gtk_accel_group_new()
	retGo := AccelGroupNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AccelGroupFromAccelClosure is a wrapper around the C function gtk_accel_group_from_accel_closure.
func AccelGroupFromAccelClosure(closure *gobject.Closure) *AccelGroup {
	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	retC := C.gtk_accel_group_from_accel_closure(c_closure)
	var retGo (*AccelGroup)
	if retC == nil {
		retGo = nil
	} else {
		retGo = AccelGroupNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Activate is a wrapper around the C function gtk_accel_group_activate.
func (recv *AccelGroup) Activate(accelQuark glib.Quark, acceleratable *gobject.Object, accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_quark := (C.GQuark)(accelQuark)

	c_acceleratable := (*C.GObject)(C.NULL)
	if acceleratable != nil {
		c_acceleratable = (*C.GObject)(acceleratable.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_accel_group_activate((*C.GtkAccelGroup)(recv.native), c_accel_quark, c_acceleratable, c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// Connect is a wrapper around the C function gtk_accel_group_connect.
func (recv *AccelGroup) Connect(accelKey uint32, accelMods gdk.ModifierType, accelFlags AccelFlags, closure *gobject.Closure) {
	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	c_accel_flags := (C.GtkAccelFlags)(accelFlags)

	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	C.gtk_accel_group_connect((*C.GtkAccelGroup)(recv.native), c_accel_key, c_accel_mods, c_accel_flags, c_closure)

	return
}

// ConnectByPath is a wrapper around the C function gtk_accel_group_connect_by_path.
func (recv *AccelGroup) ConnectByPath(accelPath string, closure *gobject.Closure) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	C.gtk_accel_group_connect_by_path((*C.GtkAccelGroup)(recv.native), c_accel_path, c_closure)

	return
}

// Disconnect is a wrapper around the C function gtk_accel_group_disconnect.
func (recv *AccelGroup) Disconnect(closure *gobject.Closure) bool {
	c_closure := (*C.GClosure)(C.NULL)
	if closure != nil {
		c_closure = (*C.GClosure)(closure.ToC())
	}

	retC := C.gtk_accel_group_disconnect((*C.GtkAccelGroup)(recv.native), c_closure)
	retGo := retC == C.TRUE

	return retGo
}

// DisconnectKey is a wrapper around the C function gtk_accel_group_disconnect_key.
func (recv *AccelGroup) DisconnectKey(accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_accel_group_disconnect_key((*C.GtkAccelGroup)(recv.native), c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_accel_group_find : unsupported parameter find_func : no type generator for AccelGroupFindFunc (GtkAccelGroupFindFunc) for param find_func

// Lock is a wrapper around the C function gtk_accel_group_lock.
func (recv *AccelGroup) Lock() {
	C.gtk_accel_group_lock((*C.GtkAccelGroup)(recv.native))

	return
}

// Unsupported : gtk_accel_group_query : array return type :

// Unlock is a wrapper around the C function gtk_accel_group_unlock.
func (recv *AccelGroup) Unlock() {
	C.gtk_accel_group_unlock((*C.GtkAccelGroup)(recv.native))

	return
}

// AccelLabel is a wrapper around the C record GtkAccelLabel.
type AccelLabel struct {
	native *C.GtkAccelLabel
	// label : record
	// priv : record
}

func AccelLabelNewFromC(u unsafe.Pointer) *AccelLabel {
	c := (*C.GtkAccelLabel)(u)
	if c == nil {
		return nil
	}

	g := &AccelLabel{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AccelLabel) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AccelLabel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelLabel with another AccelLabel, and returns true if they represent the same GObject.
func (recv *AccelLabel) Equals(other *AccelLabel) bool {
	return other.ToC() == recv.ToC()
}

// Label upcasts to *Label
func (recv *AccelLabel) Label() *Label {
	return LabelNewFromC(unsafe.Pointer(recv.native))
}

// Misc upcasts to *Misc
func (recv *AccelLabel) Misc() *Misc {
	return recv.Label().Misc()
}

// Widget upcasts to *Widget
func (recv *AccelLabel) Widget() *Widget {
	return recv.Label().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AccelLabel) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Label().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AccelLabel) Object() *gobject.Object {
	return recv.Label().Object()
}

// CastToWidget down casts any arbitrary Object to AccelLabel.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelLabel.
func CastToAccelLabel(object *gobject.Object) *AccelLabel {
	return AccelLabelNewFromC(object.ToC())
}

// AccelLabelNew is a wrapper around the C function gtk_accel_label_new.
func AccelLabelNew(string_ string) *AccelLabel {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.gtk_accel_label_new(c_string)
	retGo := AccelLabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAccelWidget is a wrapper around the C function gtk_accel_label_get_accel_widget.
func (recv *AccelLabel) GetAccelWidget() *Widget {
	retC := C.gtk_accel_label_get_accel_widget((*C.GtkAccelLabel)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetAccelWidth is a wrapper around the C function gtk_accel_label_get_accel_width.
func (recv *AccelLabel) GetAccelWidth() uint32 {
	retC := C.gtk_accel_label_get_accel_width((*C.GtkAccelLabel)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// Refetch is a wrapper around the C function gtk_accel_label_refetch.
func (recv *AccelLabel) Refetch() bool {
	retC := C.gtk_accel_label_refetch((*C.GtkAccelLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetAccelClosure is a wrapper around the C function gtk_accel_label_set_accel_closure.
func (recv *AccelLabel) SetAccelClosure(accelClosure *gobject.Closure) {
	c_accel_closure := (*C.GClosure)(C.NULL)
	if accelClosure != nil {
		c_accel_closure = (*C.GClosure)(accelClosure.ToC())
	}

	C.gtk_accel_label_set_accel_closure((*C.GtkAccelLabel)(recv.native), c_accel_closure)

	return
}

// SetAccelWidget is a wrapper around the C function gtk_accel_label_set_accel_widget.
func (recv *AccelLabel) SetAccelWidget(accelWidget *Widget) {
	c_accel_widget := (*C.GtkWidget)(C.NULL)
	if accelWidget != nil {
		c_accel_widget = (*C.GtkWidget)(accelWidget.ToC())
	}

	C.gtk_accel_label_set_accel_widget((*C.GtkAccelLabel)(recv.native), c_accel_widget)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AccelLabel
func (recv *AccelLabel) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AccelLabel
func (recv *AccelLabel) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AccelMap is a wrapper around the C record GtkAccelMap.
type AccelMap struct {
	native *C.GtkAccelMap
}

func AccelMapNewFromC(u unsafe.Pointer) *AccelMap {
	c := (*C.GtkAccelMap)(u)
	if c == nil {
		return nil
	}

	g := &AccelMap{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AccelMap) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AccelMap) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelMap with another AccelMap, and returns true if they represent the same GObject.
func (recv *AccelMap) Equals(other *AccelMap) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *AccelMap) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to AccelMap.
// Exercise care, as this is a potentially dangerous function if the Object is not a AccelMap.
func CastToAccelMap(object *gobject.Object) *AccelMap {
	return AccelMapNewFromC(object.ToC())
}

type signalAccelMapChangedDetail struct {
	callback  AccelMapSignalChangedCallback
	handlerID C.gulong
}

var signalAccelMapChangedId int
var signalAccelMapChangedMap = make(map[int]signalAccelMapChangedDetail)
var signalAccelMapChangedLock sync.RWMutex

// AccelMapSignalChangedCallback is a callback function for a 'changed' signal emitted from a AccelMap.
type AccelMapSignalChangedCallback func(accelPath string, accelKey uint32, accelMods gdk.ModifierType)

/*
ConnectChanged connects the callback to the 'changed' signal for the AccelMap.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *AccelMap) ConnectChanged(callback AccelMapSignalChangedCallback) int {
	signalAccelMapChangedLock.Lock()
	defer signalAccelMapChangedLock.Unlock()

	signalAccelMapChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AccelMap_signal_connect_changed(instance, C.gpointer(uintptr(signalAccelMapChangedId)))

	detail := signalAccelMapChangedDetail{callback, handlerID}
	signalAccelMapChangedMap[signalAccelMapChangedId] = detail

	return signalAccelMapChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the AccelMap.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *AccelMap) DisconnectChanged(connectionID int) {
	signalAccelMapChangedLock.Lock()
	defer signalAccelMapChangedLock.Unlock()

	detail, exists := signalAccelMapChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAccelMapChangedMap, connectionID)
}

//export accelmap_changedHandler
func accelmap_changedHandler(_ *C.GObject, c_accel_path *C.gchar, c_accel_key C.guint, c_accel_mods C.guint, data C.gpointer) {
	signalAccelMapChangedLock.RLock()
	defer signalAccelMapChangedLock.RUnlock()

	accelPath := C.GoString(c_accel_path)

	accelKey := uint32(c_accel_key)

	accelMods := gdk.ModifierType(c_accel_mods)

	index := int(uintptr(data))
	callback := signalAccelMapChangedMap[index].callback
	callback(accelPath, accelKey, accelMods)
}

// AccelMapAddEntry is a wrapper around the C function gtk_accel_map_add_entry.
func AccelMapAddEntry(accelPath string, accelKey uint32, accelMods gdk.ModifierType) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	C.gtk_accel_map_add_entry(c_accel_path, c_accel_key, c_accel_mods)

	return
}

// AccelMapAddFilter is a wrapper around the C function gtk_accel_map_add_filter.
func AccelMapAddFilter(filterPattern string) {
	c_filter_pattern := C.CString(filterPattern)
	defer C.free(unsafe.Pointer(c_filter_pattern))

	C.gtk_accel_map_add_filter(c_filter_pattern)

	return
}

// AccelMapChangeEntry is a wrapper around the C function gtk_accel_map_change_entry.
func AccelMapChangeEntry(accelPath string, accelKey uint32, accelMods gdk.ModifierType, replace bool) bool {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	c_replace :=
		boolToGboolean(replace)

	retC := C.gtk_accel_map_change_entry(c_accel_path, c_accel_key, c_accel_mods, c_replace)
	retGo := retC == C.TRUE

	return retGo
}

// gtk_accel_map_foreach : unsupported parameter foreach_func : no type generator for AccelMapForeach (GtkAccelMapForeach) for param foreach_func
// gtk_accel_map_foreach_unfiltered : unsupported parameter foreach_func : no type generator for AccelMapForeach (GtkAccelMapForeach) for param foreach_func
// AccelMapGet is a wrapper around the C function gtk_accel_map_get.
func AccelMapGet() *AccelMap {
	retC := C.gtk_accel_map_get()
	retGo := AccelMapNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AccelMapLoad is a wrapper around the C function gtk_accel_map_load.
func AccelMapLoad(fileName string) {
	c_file_name := C.CString(fileName)
	defer C.free(unsafe.Pointer(c_file_name))

	C.gtk_accel_map_load(c_file_name)

	return
}

// AccelMapLoadFd is a wrapper around the C function gtk_accel_map_load_fd.
func AccelMapLoadFd(fd int32) {
	c_fd := (C.gint)(fd)

	C.gtk_accel_map_load_fd(c_fd)

	return
}

// AccelMapLoadScanner is a wrapper around the C function gtk_accel_map_load_scanner.
func AccelMapLoadScanner(scanner *glib.Scanner) {
	c_scanner := (*C.GScanner)(C.NULL)
	if scanner != nil {
		c_scanner = (*C.GScanner)(scanner.ToC())
	}

	C.gtk_accel_map_load_scanner(c_scanner)

	return
}

// AccelMapLockPath is a wrapper around the C function gtk_accel_map_lock_path.
func AccelMapLockPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_accel_map_lock_path(c_accel_path)

	return
}

// AccelMapLookupEntry is a wrapper around the C function gtk_accel_map_lookup_entry.
func AccelMapLookupEntry(accelPath string) (bool, *AccelKey) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	var c_key C.GtkAccelKey

	retC := C.gtk_accel_map_lookup_entry(c_accel_path, &c_key)
	retGo := retC == C.TRUE

	key := AccelKeyNewFromC(unsafe.Pointer(&c_key))

	return retGo, key
}

// AccelMapSave is a wrapper around the C function gtk_accel_map_save.
func AccelMapSave(fileName string) {
	c_file_name := C.CString(fileName)
	defer C.free(unsafe.Pointer(c_file_name))

	C.gtk_accel_map_save(c_file_name)

	return
}

// AccelMapSaveFd is a wrapper around the C function gtk_accel_map_save_fd.
func AccelMapSaveFd(fd int32) {
	c_fd := (C.gint)(fd)

	C.gtk_accel_map_save_fd(c_fd)

	return
}

// AccelMapUnlockPath is a wrapper around the C function gtk_accel_map_unlock_path.
func AccelMapUnlockPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_accel_map_unlock_path(c_accel_path)

	return
}

// Accessible is a wrapper around the C record GtkAccessible.
type Accessible struct {
	native *C.GtkAccessible
	// parent : record
	// Private : priv
}

func AccessibleNewFromC(u unsafe.Pointer) *Accessible {
	c := (*C.GtkAccessible)(u)
	if c == nil {
		return nil
	}

	g := &Accessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Accessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Accessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Accessible with another Accessible, and returns true if they represent the same GObject.
func (recv *Accessible) Equals(other *Accessible) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Accessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Accessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a Accessible.
func CastToAccessible(object *gobject.Object) *Accessible {
	return AccessibleNewFromC(object.ToC())
}

// ConnectWidgetDestroyed is a wrapper around the C function gtk_accessible_connect_widget_destroyed.
func (recv *Accessible) ConnectWidgetDestroyed() {
	C.gtk_accessible_connect_widget_destroyed((*C.GtkAccessible)(recv.native))

	return
}

// Action is a wrapper around the C record GtkAction.
type Action struct {
	native *C.GtkAction
	// object : record
	// Private : private_data
}

func ActionNewFromC(u unsafe.Pointer) *Action {
	c := (*C.GtkAction)(u)
	if c == nil {
		return nil
	}

	g := &Action{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Action) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Action) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Action with another Action, and returns true if they represent the same GObject.
func (recv *Action) Equals(other *Action) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Action) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Action.
// Exercise care, as this is a potentially dangerous function if the Object is not a Action.
func CastToAction(object *gobject.Object) *Action {
	return ActionNewFromC(object.ToC())
}

type signalActionActivateDetail struct {
	callback  ActionSignalActivateCallback
	handlerID C.gulong
}

var signalActionActivateId int
var signalActionActivateMap = make(map[int]signalActionActivateDetail)
var signalActionActivateLock sync.RWMutex

// ActionSignalActivateCallback is a callback function for a 'activate' signal emitted from a Action.
type ActionSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Action.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Action) ConnectActivate(callback ActionSignalActivateCallback) int {
	signalActionActivateLock.Lock()
	defer signalActionActivateLock.Unlock()

	signalActionActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Action_signal_connect_activate(instance, C.gpointer(uintptr(signalActionActivateId)))

	detail := signalActionActivateDetail{callback, handlerID}
	signalActionActivateMap[signalActionActivateId] = detail

	return signalActionActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Action.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Action) DisconnectActivate(connectionID int) {
	signalActionActivateLock.Lock()
	defer signalActionActivateLock.Unlock()

	detail, exists := signalActionActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionActivateMap, connectionID)
}

//export action_activateHandler
func action_activateHandler(_ *C.GObject, data C.gpointer) {
	signalActionActivateLock.RLock()
	defer signalActionActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalActionActivateMap[index].callback
	callback()
}

// ActionNew is a wrapper around the C function gtk_action_new.
func ActionNew(name string, label string, tooltip string, stockId string) *Action {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_tooltip := C.CString(tooltip)
	defer C.free(unsafe.Pointer(c_tooltip))

	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_action_new(c_name, c_label, c_tooltip, c_stock_id)
	retGo := ActionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Activate is a wrapper around the C function gtk_action_activate.
func (recv *Action) Activate() {
	C.gtk_action_activate((*C.GtkAction)(recv.native))

	return
}

// ConnectAccelerator is a wrapper around the C function gtk_action_connect_accelerator.
func (recv *Action) ConnectAccelerator() {
	C.gtk_action_connect_accelerator((*C.GtkAction)(recv.native))

	return
}

// CreateIcon is a wrapper around the C function gtk_action_create_icon.
func (recv *Action) CreateIcon(iconSize IconSize) *Widget {
	c_icon_size := (C.GtkIconSize)(iconSize)

	retC := C.gtk_action_create_icon((*C.GtkAction)(recv.native), c_icon_size)
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CreateMenu is a wrapper around the C function gtk_action_create_menu.
func (recv *Action) CreateMenu() *Widget {
	retC := C.gtk_action_create_menu((*C.GtkAction)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CreateMenuItem is a wrapper around the C function gtk_action_create_menu_item.
func (recv *Action) CreateMenuItem() *Widget {
	retC := C.gtk_action_create_menu_item((*C.GtkAction)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CreateToolItem is a wrapper around the C function gtk_action_create_tool_item.
func (recv *Action) CreateToolItem() *Widget {
	retC := C.gtk_action_create_tool_item((*C.GtkAction)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DisconnectAccelerator is a wrapper around the C function gtk_action_disconnect_accelerator.
func (recv *Action) DisconnectAccelerator() {
	C.gtk_action_disconnect_accelerator((*C.GtkAction)(recv.native))

	return
}

// GetAccelClosure is a wrapper around the C function gtk_action_get_accel_closure.
func (recv *Action) GetAccelClosure() *gobject.Closure {
	retC := C.gtk_action_get_accel_closure((*C.GtkAction)(recv.native))
	retGo := gobject.ClosureNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAccelPath is a wrapper around the C function gtk_action_get_accel_path.
func (recv *Action) GetAccelPath() string {
	retC := C.gtk_action_get_accel_path((*C.GtkAction)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetName is a wrapper around the C function gtk_action_get_name.
func (recv *Action) GetName() string {
	retC := C.gtk_action_get_name((*C.GtkAction)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetProxies is a wrapper around the C function gtk_action_get_proxies.
func (recv *Action) GetProxies() *glib.SList {
	retC := C.gtk_action_get_proxies((*C.GtkAction)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSensitive is a wrapper around the C function gtk_action_get_sensitive.
func (recv *Action) GetSensitive() bool {
	retC := C.gtk_action_get_sensitive((*C.GtkAction)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetVisible is a wrapper around the C function gtk_action_get_visible.
func (recv *Action) GetVisible() bool {
	retC := C.gtk_action_get_visible((*C.GtkAction)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsSensitive is a wrapper around the C function gtk_action_is_sensitive.
func (recv *Action) IsSensitive() bool {
	retC := C.gtk_action_is_sensitive((*C.GtkAction)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsVisible is a wrapper around the C function gtk_action_is_visible.
func (recv *Action) IsVisible() bool {
	retC := C.gtk_action_is_visible((*C.GtkAction)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetAccelGroup is a wrapper around the C function gtk_action_set_accel_group.
func (recv *Action) SetAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_action_set_accel_group((*C.GtkAction)(recv.native), c_accel_group)

	return
}

// SetAccelPath is a wrapper around the C function gtk_action_set_accel_path.
func (recv *Action) SetAccelPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_action_set_accel_path((*C.GtkAction)(recv.native), c_accel_path)

	return
}

// SetSensitive is a wrapper around the C function gtk_action_set_sensitive.
func (recv *Action) SetSensitive(sensitive bool) {
	c_sensitive :=
		boolToGboolean(sensitive)

	C.gtk_action_set_sensitive((*C.GtkAction)(recv.native), c_sensitive)

	return
}

// SetVisible is a wrapper around the C function gtk_action_set_visible.
func (recv *Action) SetVisible(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_action_set_visible((*C.GtkAction)(recv.native), c_visible)

	return
}

// Buildable returns the Buildable interface implemented by Action
func (recv *Action) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ActionBar is a wrapper around the C record GtkActionBar.
type ActionBar struct {
	native *C.GtkActionBar
	// Private : bin
}

func ActionBarNewFromC(u unsafe.Pointer) *ActionBar {
	c := (*C.GtkActionBar)(u)
	if c == nil {
		return nil
	}

	g := &ActionBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ActionBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ActionBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionBar with another ActionBar, and returns true if they represent the same GObject.
func (recv *ActionBar) Equals(other *ActionBar) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ActionBar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ActionBar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ActionBar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ActionBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ActionBar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ActionBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a ActionBar.
func CastToActionBar(object *gobject.Object) *ActionBar {
	return ActionBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ActionBar
func (recv *ActionBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ActionBar
func (recv *ActionBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ActionGroup is a wrapper around the C record GtkActionGroup.
type ActionGroup struct {
	native *C.GtkActionGroup
	// parent : record
	// Private : priv
}

func ActionGroupNewFromC(u unsafe.Pointer) *ActionGroup {
	c := (*C.GtkActionGroup)(u)
	if c == nil {
		return nil
	}

	g := &ActionGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ActionGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ActionGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionGroup with another ActionGroup, and returns true if they represent the same GObject.
func (recv *ActionGroup) Equals(other *ActionGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ActionGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ActionGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a ActionGroup.
func CastToActionGroup(object *gobject.Object) *ActionGroup {
	return ActionGroupNewFromC(object.ToC())
}

type signalActionGroupConnectProxyDetail struct {
	callback  ActionGroupSignalConnectProxyCallback
	handlerID C.gulong
}

var signalActionGroupConnectProxyId int
var signalActionGroupConnectProxyMap = make(map[int]signalActionGroupConnectProxyDetail)
var signalActionGroupConnectProxyLock sync.RWMutex

// ActionGroupSignalConnectProxyCallback is a callback function for a 'connect-proxy' signal emitted from a ActionGroup.
type ActionGroupSignalConnectProxyCallback func(action *Action, proxy *Widget)

/*
ConnectConnectProxy connects the callback to the 'connect-proxy' signal for the ActionGroup.

The returned value represents the connection, and may be passed to DisconnectConnectProxy to remove it.
*/
func (recv *ActionGroup) ConnectConnectProxy(callback ActionGroupSignalConnectProxyCallback) int {
	signalActionGroupConnectProxyLock.Lock()
	defer signalActionGroupConnectProxyLock.Unlock()

	signalActionGroupConnectProxyId++
	instance := C.gpointer(recv.native)
	handlerID := C.ActionGroup_signal_connect_connect_proxy(instance, C.gpointer(uintptr(signalActionGroupConnectProxyId)))

	detail := signalActionGroupConnectProxyDetail{callback, handlerID}
	signalActionGroupConnectProxyMap[signalActionGroupConnectProxyId] = detail

	return signalActionGroupConnectProxyId
}

/*
DisconnectConnectProxy disconnects a callback from the 'connect-proxy' signal for the ActionGroup.

The connectionID should be a value returned from a call to ConnectConnectProxy.
*/
func (recv *ActionGroup) DisconnectConnectProxy(connectionID int) {
	signalActionGroupConnectProxyLock.Lock()
	defer signalActionGroupConnectProxyLock.Unlock()

	detail, exists := signalActionGroupConnectProxyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionGroupConnectProxyMap, connectionID)
}

//export actiongroup_connectProxyHandler
func actiongroup_connectProxyHandler(_ *C.GObject, c_action *C.GtkAction, c_proxy *C.GtkWidget, data C.gpointer) {
	signalActionGroupConnectProxyLock.RLock()
	defer signalActionGroupConnectProxyLock.RUnlock()

	action := ActionNewFromC(unsafe.Pointer(c_action))

	proxy := WidgetNewFromC(unsafe.Pointer(c_proxy))

	index := int(uintptr(data))
	callback := signalActionGroupConnectProxyMap[index].callback
	callback(action, proxy)
}

type signalActionGroupDisconnectProxyDetail struct {
	callback  ActionGroupSignalDisconnectProxyCallback
	handlerID C.gulong
}

var signalActionGroupDisconnectProxyId int
var signalActionGroupDisconnectProxyMap = make(map[int]signalActionGroupDisconnectProxyDetail)
var signalActionGroupDisconnectProxyLock sync.RWMutex

// ActionGroupSignalDisconnectProxyCallback is a callback function for a 'disconnect-proxy' signal emitted from a ActionGroup.
type ActionGroupSignalDisconnectProxyCallback func(action *Action, proxy *Widget)

/*
ConnectDisconnectProxy connects the callback to the 'disconnect-proxy' signal for the ActionGroup.

The returned value represents the connection, and may be passed to DisconnectDisconnectProxy to remove it.
*/
func (recv *ActionGroup) ConnectDisconnectProxy(callback ActionGroupSignalDisconnectProxyCallback) int {
	signalActionGroupDisconnectProxyLock.Lock()
	defer signalActionGroupDisconnectProxyLock.Unlock()

	signalActionGroupDisconnectProxyId++
	instance := C.gpointer(recv.native)
	handlerID := C.ActionGroup_signal_connect_disconnect_proxy(instance, C.gpointer(uintptr(signalActionGroupDisconnectProxyId)))

	detail := signalActionGroupDisconnectProxyDetail{callback, handlerID}
	signalActionGroupDisconnectProxyMap[signalActionGroupDisconnectProxyId] = detail

	return signalActionGroupDisconnectProxyId
}

/*
DisconnectDisconnectProxy disconnects a callback from the 'disconnect-proxy' signal for the ActionGroup.

The connectionID should be a value returned from a call to ConnectDisconnectProxy.
*/
func (recv *ActionGroup) DisconnectDisconnectProxy(connectionID int) {
	signalActionGroupDisconnectProxyLock.Lock()
	defer signalActionGroupDisconnectProxyLock.Unlock()

	detail, exists := signalActionGroupDisconnectProxyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionGroupDisconnectProxyMap, connectionID)
}

//export actiongroup_disconnectProxyHandler
func actiongroup_disconnectProxyHandler(_ *C.GObject, c_action *C.GtkAction, c_proxy *C.GtkWidget, data C.gpointer) {
	signalActionGroupDisconnectProxyLock.RLock()
	defer signalActionGroupDisconnectProxyLock.RUnlock()

	action := ActionNewFromC(unsafe.Pointer(c_action))

	proxy := WidgetNewFromC(unsafe.Pointer(c_proxy))

	index := int(uintptr(data))
	callback := signalActionGroupDisconnectProxyMap[index].callback
	callback(action, proxy)
}

type signalActionGroupPostActivateDetail struct {
	callback  ActionGroupSignalPostActivateCallback
	handlerID C.gulong
}

var signalActionGroupPostActivateId int
var signalActionGroupPostActivateMap = make(map[int]signalActionGroupPostActivateDetail)
var signalActionGroupPostActivateLock sync.RWMutex

// ActionGroupSignalPostActivateCallback is a callback function for a 'post-activate' signal emitted from a ActionGroup.
type ActionGroupSignalPostActivateCallback func(action *Action)

/*
ConnectPostActivate connects the callback to the 'post-activate' signal for the ActionGroup.

The returned value represents the connection, and may be passed to DisconnectPostActivate to remove it.
*/
func (recv *ActionGroup) ConnectPostActivate(callback ActionGroupSignalPostActivateCallback) int {
	signalActionGroupPostActivateLock.Lock()
	defer signalActionGroupPostActivateLock.Unlock()

	signalActionGroupPostActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.ActionGroup_signal_connect_post_activate(instance, C.gpointer(uintptr(signalActionGroupPostActivateId)))

	detail := signalActionGroupPostActivateDetail{callback, handlerID}
	signalActionGroupPostActivateMap[signalActionGroupPostActivateId] = detail

	return signalActionGroupPostActivateId
}

/*
DisconnectPostActivate disconnects a callback from the 'post-activate' signal for the ActionGroup.

The connectionID should be a value returned from a call to ConnectPostActivate.
*/
func (recv *ActionGroup) DisconnectPostActivate(connectionID int) {
	signalActionGroupPostActivateLock.Lock()
	defer signalActionGroupPostActivateLock.Unlock()

	detail, exists := signalActionGroupPostActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionGroupPostActivateMap, connectionID)
}

//export actiongroup_postActivateHandler
func actiongroup_postActivateHandler(_ *C.GObject, c_action *C.GtkAction, data C.gpointer) {
	signalActionGroupPostActivateLock.RLock()
	defer signalActionGroupPostActivateLock.RUnlock()

	action := ActionNewFromC(unsafe.Pointer(c_action))

	index := int(uintptr(data))
	callback := signalActionGroupPostActivateMap[index].callback
	callback(action)
}

type signalActionGroupPreActivateDetail struct {
	callback  ActionGroupSignalPreActivateCallback
	handlerID C.gulong
}

var signalActionGroupPreActivateId int
var signalActionGroupPreActivateMap = make(map[int]signalActionGroupPreActivateDetail)
var signalActionGroupPreActivateLock sync.RWMutex

// ActionGroupSignalPreActivateCallback is a callback function for a 'pre-activate' signal emitted from a ActionGroup.
type ActionGroupSignalPreActivateCallback func(action *Action)

/*
ConnectPreActivate connects the callback to the 'pre-activate' signal for the ActionGroup.

The returned value represents the connection, and may be passed to DisconnectPreActivate to remove it.
*/
func (recv *ActionGroup) ConnectPreActivate(callback ActionGroupSignalPreActivateCallback) int {
	signalActionGroupPreActivateLock.Lock()
	defer signalActionGroupPreActivateLock.Unlock()

	signalActionGroupPreActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.ActionGroup_signal_connect_pre_activate(instance, C.gpointer(uintptr(signalActionGroupPreActivateId)))

	detail := signalActionGroupPreActivateDetail{callback, handlerID}
	signalActionGroupPreActivateMap[signalActionGroupPreActivateId] = detail

	return signalActionGroupPreActivateId
}

/*
DisconnectPreActivate disconnects a callback from the 'pre-activate' signal for the ActionGroup.

The connectionID should be a value returned from a call to ConnectPreActivate.
*/
func (recv *ActionGroup) DisconnectPreActivate(connectionID int) {
	signalActionGroupPreActivateLock.Lock()
	defer signalActionGroupPreActivateLock.Unlock()

	detail, exists := signalActionGroupPreActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalActionGroupPreActivateMap, connectionID)
}

//export actiongroup_preActivateHandler
func actiongroup_preActivateHandler(_ *C.GObject, c_action *C.GtkAction, data C.gpointer) {
	signalActionGroupPreActivateLock.RLock()
	defer signalActionGroupPreActivateLock.RUnlock()

	action := ActionNewFromC(unsafe.Pointer(c_action))

	index := int(uintptr(data))
	callback := signalActionGroupPreActivateMap[index].callback
	callback(action)
}

// ActionGroupNew is a wrapper around the C function gtk_action_group_new.
func ActionGroupNew(name string) *ActionGroup {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_action_group_new(c_name)
	retGo := ActionGroupNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddAction is a wrapper around the C function gtk_action_group_add_action.
func (recv *ActionGroup) AddAction(action *Action) {
	c_action := (*C.GtkAction)(C.NULL)
	if action != nil {
		c_action = (*C.GtkAction)(action.ToC())
	}

	C.gtk_action_group_add_action((*C.GtkActionGroup)(recv.native), c_action)

	return
}

// AddActionWithAccel is a wrapper around the C function gtk_action_group_add_action_with_accel.
func (recv *ActionGroup) AddActionWithAccel(action *Action, accelerator string) {
	c_action := (*C.GtkAction)(C.NULL)
	if action != nil {
		c_action = (*C.GtkAction)(action.ToC())
	}

	c_accelerator := C.CString(accelerator)
	defer C.free(unsafe.Pointer(c_accelerator))

	C.gtk_action_group_add_action_with_accel((*C.GtkActionGroup)(recv.native), c_action, c_accelerator)

	return
}

// Unsupported : gtk_action_group_add_actions : unsupported parameter entries :

// Unsupported : gtk_action_group_add_actions_full : unsupported parameter entries :

// Unsupported : gtk_action_group_add_radio_actions : unsupported parameter entries :

// Unsupported : gtk_action_group_add_radio_actions_full : unsupported parameter entries :

// Unsupported : gtk_action_group_add_toggle_actions : unsupported parameter entries :

// Unsupported : gtk_action_group_add_toggle_actions_full : unsupported parameter entries :

// GetAction is a wrapper around the C function gtk_action_group_get_action.
func (recv *ActionGroup) GetAction(actionName string) *Action {
	c_action_name := C.CString(actionName)
	defer C.free(unsafe.Pointer(c_action_name))

	retC := C.gtk_action_group_get_action((*C.GtkActionGroup)(recv.native), c_action_name)
	retGo := ActionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetName is a wrapper around the C function gtk_action_group_get_name.
func (recv *ActionGroup) GetName() string {
	retC := C.gtk_action_group_get_name((*C.GtkActionGroup)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetSensitive is a wrapper around the C function gtk_action_group_get_sensitive.
func (recv *ActionGroup) GetSensitive() bool {
	retC := C.gtk_action_group_get_sensitive((*C.GtkActionGroup)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetVisible is a wrapper around the C function gtk_action_group_get_visible.
func (recv *ActionGroup) GetVisible() bool {
	retC := C.gtk_action_group_get_visible((*C.GtkActionGroup)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ListActions is a wrapper around the C function gtk_action_group_list_actions.
func (recv *ActionGroup) ListActions() *glib.List {
	retC := C.gtk_action_group_list_actions((*C.GtkActionGroup)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RemoveAction is a wrapper around the C function gtk_action_group_remove_action.
func (recv *ActionGroup) RemoveAction(action *Action) {
	c_action := (*C.GtkAction)(C.NULL)
	if action != nil {
		c_action = (*C.GtkAction)(action.ToC())
	}

	C.gtk_action_group_remove_action((*C.GtkActionGroup)(recv.native), c_action)

	return
}

// SetSensitive is a wrapper around the C function gtk_action_group_set_sensitive.
func (recv *ActionGroup) SetSensitive(sensitive bool) {
	c_sensitive :=
		boolToGboolean(sensitive)

	C.gtk_action_group_set_sensitive((*C.GtkActionGroup)(recv.native), c_sensitive)

	return
}

// Unsupported : gtk_action_group_set_translate_func : unsupported parameter func : no type generator for TranslateFunc (GtkTranslateFunc) for param func

// SetTranslationDomain is a wrapper around the C function gtk_action_group_set_translation_domain.
func (recv *ActionGroup) SetTranslationDomain(domain string) {
	c_domain := C.CString(domain)
	defer C.free(unsafe.Pointer(c_domain))

	C.gtk_action_group_set_translation_domain((*C.GtkActionGroup)(recv.native), c_domain)

	return
}

// SetVisible is a wrapper around the C function gtk_action_group_set_visible.
func (recv *ActionGroup) SetVisible(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_action_group_set_visible((*C.GtkActionGroup)(recv.native), c_visible)

	return
}

// TranslateString is a wrapper around the C function gtk_action_group_translate_string.
func (recv *ActionGroup) TranslateString(string_ string) string {
	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	retC := C.gtk_action_group_translate_string((*C.GtkActionGroup)(recv.native), c_string)
	retGo := C.GoString(retC)

	return retGo
}

// Buildable returns the Buildable interface implemented by ActionGroup
func (recv *ActionGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Adjustment is a wrapper around the C record GtkAdjustment.
type Adjustment struct {
	native *C.GtkAdjustment
	// parent_instance : record
	// priv : record
}

func AdjustmentNewFromC(u unsafe.Pointer) *Adjustment {
	c := (*C.GtkAdjustment)(u)
	if c == nil {
		return nil
	}

	g := &Adjustment{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Adjustment) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Adjustment) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Adjustment with another Adjustment, and returns true if they represent the same GObject.
func (recv *Adjustment) Equals(other *Adjustment) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Adjustment) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Adjustment) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to Adjustment.
// Exercise care, as this is a potentially dangerous function if the Object is not a Adjustment.
func CastToAdjustment(object *gobject.Object) *Adjustment {
	return AdjustmentNewFromC(object.ToC())
}

type signalAdjustmentChangedDetail struct {
	callback  AdjustmentSignalChangedCallback
	handlerID C.gulong
}

var signalAdjustmentChangedId int
var signalAdjustmentChangedMap = make(map[int]signalAdjustmentChangedDetail)
var signalAdjustmentChangedLock sync.RWMutex

// AdjustmentSignalChangedCallback is a callback function for a 'changed' signal emitted from a Adjustment.
type AdjustmentSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the Adjustment.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Adjustment) ConnectChanged(callback AdjustmentSignalChangedCallback) int {
	signalAdjustmentChangedLock.Lock()
	defer signalAdjustmentChangedLock.Unlock()

	signalAdjustmentChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Adjustment_signal_connect_changed(instance, C.gpointer(uintptr(signalAdjustmentChangedId)))

	detail := signalAdjustmentChangedDetail{callback, handlerID}
	signalAdjustmentChangedMap[signalAdjustmentChangedId] = detail

	return signalAdjustmentChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Adjustment.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Adjustment) DisconnectChanged(connectionID int) {
	signalAdjustmentChangedLock.Lock()
	defer signalAdjustmentChangedLock.Unlock()

	detail, exists := signalAdjustmentChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAdjustmentChangedMap, connectionID)
}

//export adjustment_changedHandler
func adjustment_changedHandler(_ *C.GObject, data C.gpointer) {
	signalAdjustmentChangedLock.RLock()
	defer signalAdjustmentChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAdjustmentChangedMap[index].callback
	callback()
}

type signalAdjustmentValueChangedDetail struct {
	callback  AdjustmentSignalValueChangedCallback
	handlerID C.gulong
}

var signalAdjustmentValueChangedId int
var signalAdjustmentValueChangedMap = make(map[int]signalAdjustmentValueChangedDetail)
var signalAdjustmentValueChangedLock sync.RWMutex

// AdjustmentSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a Adjustment.
type AdjustmentSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the Adjustment.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *Adjustment) ConnectValueChanged(callback AdjustmentSignalValueChangedCallback) int {
	signalAdjustmentValueChangedLock.Lock()
	defer signalAdjustmentValueChangedLock.Unlock()

	signalAdjustmentValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Adjustment_signal_connect_value_changed(instance, C.gpointer(uintptr(signalAdjustmentValueChangedId)))

	detail := signalAdjustmentValueChangedDetail{callback, handlerID}
	signalAdjustmentValueChangedMap[signalAdjustmentValueChangedId] = detail

	return signalAdjustmentValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the Adjustment.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *Adjustment) DisconnectValueChanged(connectionID int) {
	signalAdjustmentValueChangedLock.Lock()
	defer signalAdjustmentValueChangedLock.Unlock()

	detail, exists := signalAdjustmentValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAdjustmentValueChangedMap, connectionID)
}

//export adjustment_valueChangedHandler
func adjustment_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	signalAdjustmentValueChangedLock.RLock()
	defer signalAdjustmentValueChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAdjustmentValueChangedMap[index].callback
	callback()
}

// AdjustmentNew is a wrapper around the C function gtk_adjustment_new.
func AdjustmentNew(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) *Adjustment {
	c_value := (C.gdouble)(value)

	c_lower := (C.gdouble)(lower)

	c_upper := (C.gdouble)(upper)

	c_step_increment := (C.gdouble)(stepIncrement)

	c_page_increment := (C.gdouble)(pageIncrement)

	c_page_size := (C.gdouble)(pageSize)

	retC := C.gtk_adjustment_new(c_value, c_lower, c_upper, c_step_increment, c_page_increment, c_page_size)
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Changed is a wrapper around the C function gtk_adjustment_changed.
func (recv *Adjustment) Changed() {
	C.gtk_adjustment_changed((*C.GtkAdjustment)(recv.native))

	return
}

// ClampPage is a wrapper around the C function gtk_adjustment_clamp_page.
func (recv *Adjustment) ClampPage(lower float64, upper float64) {
	c_lower := (C.gdouble)(lower)

	c_upper := (C.gdouble)(upper)

	C.gtk_adjustment_clamp_page((*C.GtkAdjustment)(recv.native), c_lower, c_upper)

	return
}

// GetValue is a wrapper around the C function gtk_adjustment_get_value.
func (recv *Adjustment) GetValue() float64 {
	retC := C.gtk_adjustment_get_value((*C.GtkAdjustment)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// SetValue is a wrapper around the C function gtk_adjustment_set_value.
func (recv *Adjustment) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_adjustment_set_value((*C.GtkAdjustment)(recv.native), c_value)

	return
}

// ValueChanged is a wrapper around the C function gtk_adjustment_value_changed.
func (recv *Adjustment) ValueChanged() {
	C.gtk_adjustment_value_changed((*C.GtkAdjustment)(recv.native))

	return
}

// Alignment is a wrapper around the C record GtkAlignment.
type Alignment struct {
	native *C.GtkAlignment
	// bin : record
	// Private : priv
}

func AlignmentNewFromC(u unsafe.Pointer) *Alignment {
	c := (*C.GtkAlignment)(u)
	if c == nil {
		return nil
	}

	g := &Alignment{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Alignment) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Alignment) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Alignment with another Alignment, and returns true if they represent the same GObject.
func (recv *Alignment) Equals(other *Alignment) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Alignment) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Alignment) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Alignment) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Alignment) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Alignment) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Alignment.
// Exercise care, as this is a potentially dangerous function if the Object is not a Alignment.
func CastToAlignment(object *gobject.Object) *Alignment {
	return AlignmentNewFromC(object.ToC())
}

// AlignmentNew is a wrapper around the C function gtk_alignment_new.
func AlignmentNew(xalign float32, yalign float32, xscale float32, yscale float32) *Alignment {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_xscale := (C.gfloat)(xscale)

	c_yscale := (C.gfloat)(yscale)

	retC := C.gtk_alignment_new(c_xalign, c_yalign, c_xscale, c_yscale)
	retGo := AlignmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPadding is a wrapper around the C function gtk_alignment_get_padding.
func (recv *Alignment) GetPadding() (uint32, uint32, uint32, uint32) {
	var c_padding_top C.guint

	var c_padding_bottom C.guint

	var c_padding_left C.guint

	var c_padding_right C.guint

	C.gtk_alignment_get_padding((*C.GtkAlignment)(recv.native), &c_padding_top, &c_padding_bottom, &c_padding_left, &c_padding_right)

	paddingTop := (uint32)(c_padding_top)

	paddingBottom := (uint32)(c_padding_bottom)

	paddingLeft := (uint32)(c_padding_left)

	paddingRight := (uint32)(c_padding_right)

	return paddingTop, paddingBottom, paddingLeft, paddingRight
}

// Set is a wrapper around the C function gtk_alignment_set.
func (recv *Alignment) Set(xalign float32, yalign float32, xscale float32, yscale float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_xscale := (C.gfloat)(xscale)

	c_yscale := (C.gfloat)(yscale)

	C.gtk_alignment_set((*C.GtkAlignment)(recv.native), c_xalign, c_yalign, c_xscale, c_yscale)

	return
}

// SetPadding is a wrapper around the C function gtk_alignment_set_padding.
func (recv *Alignment) SetPadding(paddingTop uint32, paddingBottom uint32, paddingLeft uint32, paddingRight uint32) {
	c_padding_top := (C.guint)(paddingTop)

	c_padding_bottom := (C.guint)(paddingBottom)

	c_padding_left := (C.guint)(paddingLeft)

	c_padding_right := (C.guint)(paddingRight)

	C.gtk_alignment_set_padding((*C.GtkAlignment)(recv.native), c_padding_top, c_padding_bottom, c_padding_left, c_padding_right)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Alignment
func (recv *Alignment) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Alignment
func (recv *Alignment) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AppChooserButton is a wrapper around the C record GtkAppChooserButton.
type AppChooserButton struct {
	native *C.GtkAppChooserButton
	// parent : record
	// Private : priv
}

func AppChooserButtonNewFromC(u unsafe.Pointer) *AppChooserButton {
	c := (*C.GtkAppChooserButton)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AppChooserButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AppChooserButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserButton with another AppChooserButton, and returns true if they represent the same GObject.
func (recv *AppChooserButton) Equals(other *AppChooserButton) bool {
	return other.ToC() == recv.ToC()
}

// ComboBox upcasts to *ComboBox
func (recv *AppChooserButton) ComboBox() *ComboBox {
	return ComboBoxNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *AppChooserButton) Bin() *Bin {
	return recv.ComboBox().Bin()
}

// Container upcasts to *Container
func (recv *AppChooserButton) Container() *Container {
	return recv.ComboBox().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserButton) Widget() *Widget {
	return recv.ComboBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ComboBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserButton) Object() *gobject.Object {
	return recv.ComboBox().Object()
}

// CastToWidget down casts any arbitrary Object to AppChooserButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserButton.
func CastToAppChooserButton(object *gobject.Object) *AppChooserButton {
	return AppChooserButtonNewFromC(object.ToC())
}

type signalAppChooserButtonCustomItemActivatedDetail struct {
	callback  AppChooserButtonSignalCustomItemActivatedCallback
	handlerID C.gulong
}

var signalAppChooserButtonCustomItemActivatedId int
var signalAppChooserButtonCustomItemActivatedMap = make(map[int]signalAppChooserButtonCustomItemActivatedDetail)
var signalAppChooserButtonCustomItemActivatedLock sync.RWMutex

// AppChooserButtonSignalCustomItemActivatedCallback is a callback function for a 'custom-item-activated' signal emitted from a AppChooserButton.
type AppChooserButtonSignalCustomItemActivatedCallback func(itemName string)

/*
ConnectCustomItemActivated connects the callback to the 'custom-item-activated' signal for the AppChooserButton.

The returned value represents the connection, and may be passed to DisconnectCustomItemActivated to remove it.
*/
func (recv *AppChooserButton) ConnectCustomItemActivated(callback AppChooserButtonSignalCustomItemActivatedCallback) int {
	signalAppChooserButtonCustomItemActivatedLock.Lock()
	defer signalAppChooserButtonCustomItemActivatedLock.Unlock()

	signalAppChooserButtonCustomItemActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserButton_signal_connect_custom_item_activated(instance, C.gpointer(uintptr(signalAppChooserButtonCustomItemActivatedId)))

	detail := signalAppChooserButtonCustomItemActivatedDetail{callback, handlerID}
	signalAppChooserButtonCustomItemActivatedMap[signalAppChooserButtonCustomItemActivatedId] = detail

	return signalAppChooserButtonCustomItemActivatedId
}

/*
DisconnectCustomItemActivated disconnects a callback from the 'custom-item-activated' signal for the AppChooserButton.

The connectionID should be a value returned from a call to ConnectCustomItemActivated.
*/
func (recv *AppChooserButton) DisconnectCustomItemActivated(connectionID int) {
	signalAppChooserButtonCustomItemActivatedLock.Lock()
	defer signalAppChooserButtonCustomItemActivatedLock.Unlock()

	detail, exists := signalAppChooserButtonCustomItemActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserButtonCustomItemActivatedMap, connectionID)
}

//export appchooserbutton_customItemActivatedHandler
func appchooserbutton_customItemActivatedHandler(_ *C.GObject, c_item_name *C.gchar, data C.gpointer) {
	signalAppChooserButtonCustomItemActivatedLock.RLock()
	defer signalAppChooserButtonCustomItemActivatedLock.RUnlock()

	itemName := C.GoString(c_item_name)

	index := int(uintptr(data))
	callback := signalAppChooserButtonCustomItemActivatedMap[index].callback
	callback(itemName)
}

// GetHeading is a wrapper around the C function gtk_app_chooser_button_get_heading.
func (recv *AppChooserButton) GetHeading() string {
	retC := C.gtk_app_chooser_button_get_heading((*C.GtkAppChooserButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SetHeading is a wrapper around the C function gtk_app_chooser_button_set_heading.
func (recv *AppChooserButton) SetHeading(heading string) {
	c_heading := C.CString(heading)
	defer C.free(unsafe.Pointer(c_heading))

	C.gtk_app_chooser_button_set_heading((*C.GtkAppChooserButton)(recv.native), c_heading)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserButton
func (recv *AppChooserButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserButton
func (recv *AppChooserButton) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserButton
func (recv *AppChooserButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by AppChooserButton
func (recv *AppChooserButton) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by AppChooserButton
func (recv *AppChooserButton) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// AppChooserDialog is a wrapper around the C record GtkAppChooserDialog.
type AppChooserDialog struct {
	native *C.GtkAppChooserDialog
	// parent : record
	// Private : priv
}

func AppChooserDialogNewFromC(u unsafe.Pointer) *AppChooserDialog {
	c := (*C.GtkAppChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AppChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AppChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserDialog with another AppChooserDialog, and returns true if they represent the same GObject.
func (recv *AppChooserDialog) Equals(other *AppChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *AppChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *AppChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *AppChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *AppChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to AppChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserDialog.
func CastToAppChooserDialog(object *gobject.Object) *AppChooserDialog {
	return AppChooserDialogNewFromC(object.ToC())
}

// GetHeading is a wrapper around the C function gtk_app_chooser_dialog_get_heading.
func (recv *AppChooserDialog) GetHeading() string {
	retC := C.gtk_app_chooser_dialog_get_heading((*C.GtkAppChooserDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SetHeading is a wrapper around the C function gtk_app_chooser_dialog_set_heading.
func (recv *AppChooserDialog) SetHeading(heading string) {
	c_heading := C.CString(heading)
	defer C.free(unsafe.Pointer(c_heading))

	C.gtk_app_chooser_dialog_set_heading((*C.GtkAppChooserDialog)(recv.native), c_heading)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserDialog
func (recv *AppChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserDialog
func (recv *AppChooserDialog) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserDialog
func (recv *AppChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// AppChooserWidget is a wrapper around the C record GtkAppChooserWidget.
type AppChooserWidget struct {
	native *C.GtkAppChooserWidget
	// parent : record
	// Private : priv
}

func AppChooserWidgetNewFromC(u unsafe.Pointer) *AppChooserWidget {
	c := (*C.GtkAppChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AppChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AppChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserWidget with another AppChooserWidget, and returns true if they represent the same GObject.
func (recv *AppChooserWidget) Equals(other *AppChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *AppChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *AppChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *AppChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AppChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AppChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to AppChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a AppChooserWidget.
func CastToAppChooserWidget(object *gobject.Object) *AppChooserWidget {
	return AppChooserWidgetNewFromC(object.ToC())
}

type signalAppChooserWidgetApplicationActivatedDetail struct {
	callback  AppChooserWidgetSignalApplicationActivatedCallback
	handlerID C.gulong
}

var signalAppChooserWidgetApplicationActivatedId int
var signalAppChooserWidgetApplicationActivatedMap = make(map[int]signalAppChooserWidgetApplicationActivatedDetail)
var signalAppChooserWidgetApplicationActivatedLock sync.RWMutex

// AppChooserWidgetSignalApplicationActivatedCallback is a callback function for a 'application-activated' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalApplicationActivatedCallback func(application *gio.AppInfo)

/*
ConnectApplicationActivated connects the callback to the 'application-activated' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectApplicationActivated to remove it.
*/
func (recv *AppChooserWidget) ConnectApplicationActivated(callback AppChooserWidgetSignalApplicationActivatedCallback) int {
	signalAppChooserWidgetApplicationActivatedLock.Lock()
	defer signalAppChooserWidgetApplicationActivatedLock.Unlock()

	signalAppChooserWidgetApplicationActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_application_activated(instance, C.gpointer(uintptr(signalAppChooserWidgetApplicationActivatedId)))

	detail := signalAppChooserWidgetApplicationActivatedDetail{callback, handlerID}
	signalAppChooserWidgetApplicationActivatedMap[signalAppChooserWidgetApplicationActivatedId] = detail

	return signalAppChooserWidgetApplicationActivatedId
}

/*
DisconnectApplicationActivated disconnects a callback from the 'application-activated' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectApplicationActivated.
*/
func (recv *AppChooserWidget) DisconnectApplicationActivated(connectionID int) {
	signalAppChooserWidgetApplicationActivatedLock.Lock()
	defer signalAppChooserWidgetApplicationActivatedLock.Unlock()

	detail, exists := signalAppChooserWidgetApplicationActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetApplicationActivatedMap, connectionID)
}

//export appchooserwidget_applicationActivatedHandler
func appchooserwidget_applicationActivatedHandler(_ *C.GObject, c_application *C.GAppInfo, data C.gpointer) {
	signalAppChooserWidgetApplicationActivatedLock.RLock()
	defer signalAppChooserWidgetApplicationActivatedLock.RUnlock()

	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetApplicationActivatedMap[index].callback
	callback(application)
}

type signalAppChooserWidgetApplicationSelectedDetail struct {
	callback  AppChooserWidgetSignalApplicationSelectedCallback
	handlerID C.gulong
}

var signalAppChooserWidgetApplicationSelectedId int
var signalAppChooserWidgetApplicationSelectedMap = make(map[int]signalAppChooserWidgetApplicationSelectedDetail)
var signalAppChooserWidgetApplicationSelectedLock sync.RWMutex

// AppChooserWidgetSignalApplicationSelectedCallback is a callback function for a 'application-selected' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalApplicationSelectedCallback func(application *gio.AppInfo)

/*
ConnectApplicationSelected connects the callback to the 'application-selected' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectApplicationSelected to remove it.
*/
func (recv *AppChooserWidget) ConnectApplicationSelected(callback AppChooserWidgetSignalApplicationSelectedCallback) int {
	signalAppChooserWidgetApplicationSelectedLock.Lock()
	defer signalAppChooserWidgetApplicationSelectedLock.Unlock()

	signalAppChooserWidgetApplicationSelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_application_selected(instance, C.gpointer(uintptr(signalAppChooserWidgetApplicationSelectedId)))

	detail := signalAppChooserWidgetApplicationSelectedDetail{callback, handlerID}
	signalAppChooserWidgetApplicationSelectedMap[signalAppChooserWidgetApplicationSelectedId] = detail

	return signalAppChooserWidgetApplicationSelectedId
}

/*
DisconnectApplicationSelected disconnects a callback from the 'application-selected' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectApplicationSelected.
*/
func (recv *AppChooserWidget) DisconnectApplicationSelected(connectionID int) {
	signalAppChooserWidgetApplicationSelectedLock.Lock()
	defer signalAppChooserWidgetApplicationSelectedLock.Unlock()

	detail, exists := signalAppChooserWidgetApplicationSelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetApplicationSelectedMap, connectionID)
}

//export appchooserwidget_applicationSelectedHandler
func appchooserwidget_applicationSelectedHandler(_ *C.GObject, c_application *C.GAppInfo, data C.gpointer) {
	signalAppChooserWidgetApplicationSelectedLock.RLock()
	defer signalAppChooserWidgetApplicationSelectedLock.RUnlock()

	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetApplicationSelectedMap[index].callback
	callback(application)
}

type signalAppChooserWidgetPopulatePopupDetail struct {
	callback  AppChooserWidgetSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalAppChooserWidgetPopulatePopupId int
var signalAppChooserWidgetPopulatePopupMap = make(map[int]signalAppChooserWidgetPopulatePopupDetail)
var signalAppChooserWidgetPopulatePopupLock sync.RWMutex

// AppChooserWidgetSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a AppChooserWidget.
type AppChooserWidgetSignalPopulatePopupCallback func(menu *Menu, application *gio.AppInfo)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the AppChooserWidget.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *AppChooserWidget) ConnectPopulatePopup(callback AppChooserWidgetSignalPopulatePopupCallback) int {
	signalAppChooserWidgetPopulatePopupLock.Lock()
	defer signalAppChooserWidgetPopulatePopupLock.Unlock()

	signalAppChooserWidgetPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.AppChooserWidget_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalAppChooserWidgetPopulatePopupId)))

	detail := signalAppChooserWidgetPopulatePopupDetail{callback, handlerID}
	signalAppChooserWidgetPopulatePopupMap[signalAppChooserWidgetPopulatePopupId] = detail

	return signalAppChooserWidgetPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the AppChooserWidget.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *AppChooserWidget) DisconnectPopulatePopup(connectionID int) {
	signalAppChooserWidgetPopulatePopupLock.Lock()
	defer signalAppChooserWidgetPopulatePopupLock.Unlock()

	detail, exists := signalAppChooserWidgetPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAppChooserWidgetPopulatePopupMap, connectionID)
}

//export appchooserwidget_populatePopupHandler
func appchooserwidget_populatePopupHandler(_ *C.GObject, c_menu *C.GtkMenu, c_application *C.GAppInfo, data C.gpointer) {
	signalAppChooserWidgetPopulatePopupLock.RLock()
	defer signalAppChooserWidgetPopulatePopupLock.RUnlock()

	menu := MenuNewFromC(unsafe.Pointer(c_menu))

	application := gio.AppInfoNewFromC(unsafe.Pointer(c_application))

	index := int(uintptr(data))
	callback := signalAppChooserWidgetPopulatePopupMap[index].callback
	callback(menu, application)
}

// SetDefaultText is a wrapper around the C function gtk_app_chooser_widget_set_default_text.
func (recv *AppChooserWidget) SetDefaultText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_app_chooser_widget_set_default_text((*C.GtkAppChooserWidget)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AppChooserWidget
func (recv *AppChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// AppChooser returns the AppChooser interface implemented by AppChooserWidget
func (recv *AppChooserWidget) AppChooser() *AppChooser {
	return AppChooserNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AppChooserWidget
func (recv *AppChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by AppChooserWidget
func (recv *AppChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Application is a wrapper around the C record GtkApplication.
type Application struct {
	native *C.GtkApplication
	// parent : record
	// Private : priv
}

func ApplicationNewFromC(u unsafe.Pointer) *Application {
	c := (*C.GtkApplication)(u)
	if c == nil {
		return nil
	}

	g := &Application{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Application) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Application) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Application with another Application, and returns true if they represent the same GObject.
func (recv *Application) Equals(other *Application) bool {
	return other.ToC() == recv.ToC()
}

// Application upcasts to *Application
func (recv *Application) Application() *gio.Application {
	return gio.ApplicationNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Application) Object() *gobject.Object {
	return recv.Application().Object()
}

// CastToWidget down casts any arbitrary Object to Application.
// Exercise care, as this is a potentially dangerous function if the Object is not a Application.
func CastToApplication(object *gobject.Object) *Application {
	return ApplicationNewFromC(object.ToC())
}

// ActionGroup returns the ActionGroup interface implemented by Application
func (recv *Application) ActionGroup() *gio.ActionGroup {
	return gio.ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by Application
func (recv *Application) ActionMap() *gio.ActionMap {
	return gio.ActionMapNewFromC(recv.ToC())
}

// ApplicationWindow is a wrapper around the C record GtkApplicationWindow.
type ApplicationWindow struct {
	native *C.GtkApplicationWindow
	// parent_instance : record
	// Private : priv
}

func ApplicationWindowNewFromC(u unsafe.Pointer) *ApplicationWindow {
	c := (*C.GtkApplicationWindow)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationWindow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ApplicationWindow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ApplicationWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationWindow with another ApplicationWindow, and returns true if they represent the same GObject.
func (recv *ApplicationWindow) Equals(other *ApplicationWindow) bool {
	return other.ToC() == recv.ToC()
}

// Window upcasts to *Window
func (recv *ApplicationWindow) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ApplicationWindow) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *ApplicationWindow) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *ApplicationWindow) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ApplicationWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ApplicationWindow) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitrary Object to ApplicationWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ApplicationWindow.
func CastToApplicationWindow(object *gobject.Object) *ApplicationWindow {
	return ApplicationWindowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// ActionGroup returns the ActionGroup interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ActionGroup() *gio.ActionGroup {
	return gio.ActionGroupNewFromC(recv.ToC())
}

// ActionMap returns the ActionMap interface implemented by ApplicationWindow
func (recv *ApplicationWindow) ActionMap() *gio.ActionMap {
	return gio.ActionMapNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ApplicationWindow
func (recv *ApplicationWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Arrow is a wrapper around the C record GtkArrow.
type Arrow struct {
	native *C.GtkArrow
	// misc : record
	// Private : priv
}

func ArrowNewFromC(u unsafe.Pointer) *Arrow {
	c := (*C.GtkArrow)(u)
	if c == nil {
		return nil
	}

	g := &Arrow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Arrow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Arrow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Arrow with another Arrow, and returns true if they represent the same GObject.
func (recv *Arrow) Equals(other *Arrow) bool {
	return other.ToC() == recv.ToC()
}

// Misc upcasts to *Misc
func (recv *Arrow) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Arrow) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Arrow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Arrow) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitrary Object to Arrow.
// Exercise care, as this is a potentially dangerous function if the Object is not a Arrow.
func CastToArrow(object *gobject.Object) *Arrow {
	return ArrowNewFromC(object.ToC())
}

// ArrowNew is a wrapper around the C function gtk_arrow_new.
func ArrowNew(arrowType ArrowType, shadowType ShadowType) *Arrow {
	c_arrow_type := (C.GtkArrowType)(arrowType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	retC := C.gtk_arrow_new(c_arrow_type, c_shadow_type)
	retGo := ArrowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Set is a wrapper around the C function gtk_arrow_set.
func (recv *Arrow) Set(arrowType ArrowType, shadowType ShadowType) {
	c_arrow_type := (C.GtkArrowType)(arrowType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	C.gtk_arrow_set((*C.GtkArrow)(recv.native), c_arrow_type, c_shadow_type)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Arrow
func (recv *Arrow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Arrow
func (recv *Arrow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ArrowAccessible is a wrapper around the C record GtkArrowAccessible.
type ArrowAccessible struct {
	native *C.GtkArrowAccessible
	// parent : record
	// priv : record
}

func ArrowAccessibleNewFromC(u unsafe.Pointer) *ArrowAccessible {
	c := (*C.GtkArrowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ArrowAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ArrowAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ArrowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ArrowAccessible with another ArrowAccessible, and returns true if they represent the same GObject.
func (recv *ArrowAccessible) Equals(other *ArrowAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ArrowAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ArrowAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ArrowAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ArrowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ArrowAccessible.
func CastToArrowAccessible(object *gobject.Object) *ArrowAccessible {
	return ArrowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ArrowAccessible
func (recv *ArrowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ArrowAccessible
func (recv *ArrowAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// AspectFrame is a wrapper around the C record GtkAspectFrame.
type AspectFrame struct {
	native *C.GtkAspectFrame
	// frame : record
	// Private : priv
}

func AspectFrameNewFromC(u unsafe.Pointer) *AspectFrame {
	c := (*C.GtkAspectFrame)(u)
	if c == nil {
		return nil
	}

	g := &AspectFrame{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *AspectFrame) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *AspectFrame) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AspectFrame with another AspectFrame, and returns true if they represent the same GObject.
func (recv *AspectFrame) Equals(other *AspectFrame) bool {
	return other.ToC() == recv.ToC()
}

// Frame upcasts to *Frame
func (recv *AspectFrame) Frame() *Frame {
	return FrameNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *AspectFrame) Bin() *Bin {
	return recv.Frame().Bin()
}

// Container upcasts to *Container
func (recv *AspectFrame) Container() *Container {
	return recv.Frame().Container()
}

// Widget upcasts to *Widget
func (recv *AspectFrame) Widget() *Widget {
	return recv.Frame().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *AspectFrame) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Frame().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *AspectFrame) Object() *gobject.Object {
	return recv.Frame().Object()
}

// CastToWidget down casts any arbitrary Object to AspectFrame.
// Exercise care, as this is a potentially dangerous function if the Object is not a AspectFrame.
func CastToAspectFrame(object *gobject.Object) *AspectFrame {
	return AspectFrameNewFromC(object.ToC())
}

// AspectFrameNew is a wrapper around the C function gtk_aspect_frame_new.
func AspectFrameNew(label string, xalign float32, yalign float32, ratio float32, obeyChild bool) *AspectFrame {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_ratio := (C.gfloat)(ratio)

	c_obey_child :=
		boolToGboolean(obeyChild)

	retC := C.gtk_aspect_frame_new(c_label, c_xalign, c_yalign, c_ratio, c_obey_child)
	retGo := AspectFrameNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Set is a wrapper around the C function gtk_aspect_frame_set.
func (recv *AspectFrame) Set(xalign float32, yalign float32, ratio float32, obeyChild bool) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	c_ratio := (C.gfloat)(ratio)

	c_obey_child :=
		boolToGboolean(obeyChild)

	C.gtk_aspect_frame_set((*C.GtkAspectFrame)(recv.native), c_xalign, c_yalign, c_ratio, c_obey_child)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by AspectFrame
func (recv *AspectFrame) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by AspectFrame
func (recv *AspectFrame) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Assistant is a wrapper around the C record GtkAssistant.
type Assistant struct {
	native *C.GtkAssistant
	// parent : record
	// Private : priv
}

func AssistantNewFromC(u unsafe.Pointer) *Assistant {
	c := (*C.GtkAssistant)(u)
	if c == nil {
		return nil
	}

	g := &Assistant{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Assistant) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Assistant) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Assistant with another Assistant, and returns true if they represent the same GObject.
func (recv *Assistant) Equals(other *Assistant) bool {
	return other.ToC() == recv.ToC()
}

// Window upcasts to *Window
func (recv *Assistant) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *Assistant) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *Assistant) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *Assistant) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Assistant) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Assistant) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitrary Object to Assistant.
// Exercise care, as this is a potentially dangerous function if the Object is not a Assistant.
func CastToAssistant(object *gobject.Object) *Assistant {
	return AssistantNewFromC(object.ToC())
}

type signalAssistantApplyDetail struct {
	callback  AssistantSignalApplyCallback
	handlerID C.gulong
}

var signalAssistantApplyId int
var signalAssistantApplyMap = make(map[int]signalAssistantApplyDetail)
var signalAssistantApplyLock sync.RWMutex

// AssistantSignalApplyCallback is a callback function for a 'apply' signal emitted from a Assistant.
type AssistantSignalApplyCallback func()

/*
ConnectApply connects the callback to the 'apply' signal for the Assistant.

The returned value represents the connection, and may be passed to DisconnectApply to remove it.
*/
func (recv *Assistant) ConnectApply(callback AssistantSignalApplyCallback) int {
	signalAssistantApplyLock.Lock()
	defer signalAssistantApplyLock.Unlock()

	signalAssistantApplyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Assistant_signal_connect_apply(instance, C.gpointer(uintptr(signalAssistantApplyId)))

	detail := signalAssistantApplyDetail{callback, handlerID}
	signalAssistantApplyMap[signalAssistantApplyId] = detail

	return signalAssistantApplyId
}

/*
DisconnectApply disconnects a callback from the 'apply' signal for the Assistant.

The connectionID should be a value returned from a call to ConnectApply.
*/
func (recv *Assistant) DisconnectApply(connectionID int) {
	signalAssistantApplyLock.Lock()
	defer signalAssistantApplyLock.Unlock()

	detail, exists := signalAssistantApplyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAssistantApplyMap, connectionID)
}

//export assistant_applyHandler
func assistant_applyHandler(_ *C.GObject, data C.gpointer) {
	signalAssistantApplyLock.RLock()
	defer signalAssistantApplyLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAssistantApplyMap[index].callback
	callback()
}

type signalAssistantCancelDetail struct {
	callback  AssistantSignalCancelCallback
	handlerID C.gulong
}

var signalAssistantCancelId int
var signalAssistantCancelMap = make(map[int]signalAssistantCancelDetail)
var signalAssistantCancelLock sync.RWMutex

// AssistantSignalCancelCallback is a callback function for a 'cancel' signal emitted from a Assistant.
type AssistantSignalCancelCallback func()

/*
ConnectCancel connects the callback to the 'cancel' signal for the Assistant.

The returned value represents the connection, and may be passed to DisconnectCancel to remove it.
*/
func (recv *Assistant) ConnectCancel(callback AssistantSignalCancelCallback) int {
	signalAssistantCancelLock.Lock()
	defer signalAssistantCancelLock.Unlock()

	signalAssistantCancelId++
	instance := C.gpointer(recv.native)
	handlerID := C.Assistant_signal_connect_cancel(instance, C.gpointer(uintptr(signalAssistantCancelId)))

	detail := signalAssistantCancelDetail{callback, handlerID}
	signalAssistantCancelMap[signalAssistantCancelId] = detail

	return signalAssistantCancelId
}

/*
DisconnectCancel disconnects a callback from the 'cancel' signal for the Assistant.

The connectionID should be a value returned from a call to ConnectCancel.
*/
func (recv *Assistant) DisconnectCancel(connectionID int) {
	signalAssistantCancelLock.Lock()
	defer signalAssistantCancelLock.Unlock()

	detail, exists := signalAssistantCancelMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAssistantCancelMap, connectionID)
}

//export assistant_cancelHandler
func assistant_cancelHandler(_ *C.GObject, data C.gpointer) {
	signalAssistantCancelLock.RLock()
	defer signalAssistantCancelLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAssistantCancelMap[index].callback
	callback()
}

type signalAssistantCloseDetail struct {
	callback  AssistantSignalCloseCallback
	handlerID C.gulong
}

var signalAssistantCloseId int
var signalAssistantCloseMap = make(map[int]signalAssistantCloseDetail)
var signalAssistantCloseLock sync.RWMutex

// AssistantSignalCloseCallback is a callback function for a 'close' signal emitted from a Assistant.
type AssistantSignalCloseCallback func()

/*
ConnectClose connects the callback to the 'close' signal for the Assistant.

The returned value represents the connection, and may be passed to DisconnectClose to remove it.
*/
func (recv *Assistant) ConnectClose(callback AssistantSignalCloseCallback) int {
	signalAssistantCloseLock.Lock()
	defer signalAssistantCloseLock.Unlock()

	signalAssistantCloseId++
	instance := C.gpointer(recv.native)
	handlerID := C.Assistant_signal_connect_close(instance, C.gpointer(uintptr(signalAssistantCloseId)))

	detail := signalAssistantCloseDetail{callback, handlerID}
	signalAssistantCloseMap[signalAssistantCloseId] = detail

	return signalAssistantCloseId
}

/*
DisconnectClose disconnects a callback from the 'close' signal for the Assistant.

The connectionID should be a value returned from a call to ConnectClose.
*/
func (recv *Assistant) DisconnectClose(connectionID int) {
	signalAssistantCloseLock.Lock()
	defer signalAssistantCloseLock.Unlock()

	detail, exists := signalAssistantCloseMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAssistantCloseMap, connectionID)
}

//export assistant_closeHandler
func assistant_closeHandler(_ *C.GObject, data C.gpointer) {
	signalAssistantCloseLock.RLock()
	defer signalAssistantCloseLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAssistantCloseMap[index].callback
	callback()
}

type signalAssistantEscapeDetail struct {
	callback  AssistantSignalEscapeCallback
	handlerID C.gulong
}

var signalAssistantEscapeId int
var signalAssistantEscapeMap = make(map[int]signalAssistantEscapeDetail)
var signalAssistantEscapeLock sync.RWMutex

// AssistantSignalEscapeCallback is a callback function for a 'escape' signal emitted from a Assistant.
type AssistantSignalEscapeCallback func()

/*
ConnectEscape connects the callback to the 'escape' signal for the Assistant.

The returned value represents the connection, and may be passed to DisconnectEscape to remove it.
*/
func (recv *Assistant) ConnectEscape(callback AssistantSignalEscapeCallback) int {
	signalAssistantEscapeLock.Lock()
	defer signalAssistantEscapeLock.Unlock()

	signalAssistantEscapeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Assistant_signal_connect_escape(instance, C.gpointer(uintptr(signalAssistantEscapeId)))

	detail := signalAssistantEscapeDetail{callback, handlerID}
	signalAssistantEscapeMap[signalAssistantEscapeId] = detail

	return signalAssistantEscapeId
}

/*
DisconnectEscape disconnects a callback from the 'escape' signal for the Assistant.

The connectionID should be a value returned from a call to ConnectEscape.
*/
func (recv *Assistant) DisconnectEscape(connectionID int) {
	signalAssistantEscapeLock.Lock()
	defer signalAssistantEscapeLock.Unlock()

	detail, exists := signalAssistantEscapeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAssistantEscapeMap, connectionID)
}

//export assistant_escapeHandler
func assistant_escapeHandler(_ *C.GObject, data C.gpointer) {
	signalAssistantEscapeLock.RLock()
	defer signalAssistantEscapeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalAssistantEscapeMap[index].callback
	callback()
}

type signalAssistantPrepareDetail struct {
	callback  AssistantSignalPrepareCallback
	handlerID C.gulong
}

var signalAssistantPrepareId int
var signalAssistantPrepareMap = make(map[int]signalAssistantPrepareDetail)
var signalAssistantPrepareLock sync.RWMutex

// AssistantSignalPrepareCallback is a callback function for a 'prepare' signal emitted from a Assistant.
type AssistantSignalPrepareCallback func(page *Widget)

/*
ConnectPrepare connects the callback to the 'prepare' signal for the Assistant.

The returned value represents the connection, and may be passed to DisconnectPrepare to remove it.
*/
func (recv *Assistant) ConnectPrepare(callback AssistantSignalPrepareCallback) int {
	signalAssistantPrepareLock.Lock()
	defer signalAssistantPrepareLock.Unlock()

	signalAssistantPrepareId++
	instance := C.gpointer(recv.native)
	handlerID := C.Assistant_signal_connect_prepare(instance, C.gpointer(uintptr(signalAssistantPrepareId)))

	detail := signalAssistantPrepareDetail{callback, handlerID}
	signalAssistantPrepareMap[signalAssistantPrepareId] = detail

	return signalAssistantPrepareId
}

/*
DisconnectPrepare disconnects a callback from the 'prepare' signal for the Assistant.

The connectionID should be a value returned from a call to ConnectPrepare.
*/
func (recv *Assistant) DisconnectPrepare(connectionID int) {
	signalAssistantPrepareLock.Lock()
	defer signalAssistantPrepareLock.Unlock()

	detail, exists := signalAssistantPrepareMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalAssistantPrepareMap, connectionID)
}

//export assistant_prepareHandler
func assistant_prepareHandler(_ *C.GObject, c_page *C.GtkWidget, data C.gpointer) {
	signalAssistantPrepareLock.RLock()
	defer signalAssistantPrepareLock.RUnlock()

	page := WidgetNewFromC(unsafe.Pointer(c_page))

	index := int(uintptr(data))
	callback := signalAssistantPrepareMap[index].callback
	callback(page)
}

// AssistantNew is a wrapper around the C function gtk_assistant_new.
func AssistantNew() *Assistant {
	retC := C.gtk_assistant_new()
	retGo := AssistantNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AddActionWidget is a wrapper around the C function gtk_assistant_add_action_widget.
func (recv *Assistant) AddActionWidget(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_assistant_add_action_widget((*C.GtkAssistant)(recv.native), c_child)

	return
}

// AppendPage is a wrapper around the C function gtk_assistant_append_page.
func (recv *Assistant) AppendPage(page *Widget) int32 {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	retC := C.gtk_assistant_append_page((*C.GtkAssistant)(recv.native), c_page)
	retGo := (int32)(retC)

	return retGo
}

// GetCurrentPage is a wrapper around the C function gtk_assistant_get_current_page.
func (recv *Assistant) GetCurrentPage() int32 {
	retC := C.gtk_assistant_get_current_page((*C.GtkAssistant)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetNPages is a wrapper around the C function gtk_assistant_get_n_pages.
func (recv *Assistant) GetNPages() int32 {
	retC := C.gtk_assistant_get_n_pages((*C.GtkAssistant)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetNthPage is a wrapper around the C function gtk_assistant_get_nth_page.
func (recv *Assistant) GetNthPage(pageNum int32) *Widget {
	c_page_num := (C.gint)(pageNum)

	retC := C.gtk_assistant_get_nth_page((*C.GtkAssistant)(recv.native), c_page_num)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPageComplete is a wrapper around the C function gtk_assistant_get_page_complete.
func (recv *Assistant) GetPageComplete(page *Widget) bool {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	retC := C.gtk_assistant_get_page_complete((*C.GtkAssistant)(recv.native), c_page)
	retGo := retC == C.TRUE

	return retGo
}

// GetPageHeaderImage is a wrapper around the C function gtk_assistant_get_page_header_image.
func (recv *Assistant) GetPageHeaderImage(page *Widget) *gdkpixbuf.Pixbuf {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	retC := C.gtk_assistant_get_page_header_image((*C.GtkAssistant)(recv.native), c_page)
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPageSideImage is a wrapper around the C function gtk_assistant_get_page_side_image.
func (recv *Assistant) GetPageSideImage(page *Widget) *gdkpixbuf.Pixbuf {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	retC := C.gtk_assistant_get_page_side_image((*C.GtkAssistant)(recv.native), c_page)
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPageTitle is a wrapper around the C function gtk_assistant_get_page_title.
func (recv *Assistant) GetPageTitle(page *Widget) string {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	retC := C.gtk_assistant_get_page_title((*C.GtkAssistant)(recv.native), c_page)
	retGo := C.GoString(retC)

	return retGo
}

// GetPageType is a wrapper around the C function gtk_assistant_get_page_type.
func (recv *Assistant) GetPageType(page *Widget) AssistantPageType {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	retC := C.gtk_assistant_get_page_type((*C.GtkAssistant)(recv.native), c_page)
	retGo := (AssistantPageType)(retC)

	return retGo
}

// InsertPage is a wrapper around the C function gtk_assistant_insert_page.
func (recv *Assistant) InsertPage(page *Widget, position int32) int32 {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_assistant_insert_page((*C.GtkAssistant)(recv.native), c_page, c_position)
	retGo := (int32)(retC)

	return retGo
}

// PrependPage is a wrapper around the C function gtk_assistant_prepend_page.
func (recv *Assistant) PrependPage(page *Widget) int32 {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	retC := C.gtk_assistant_prepend_page((*C.GtkAssistant)(recv.native), c_page)
	retGo := (int32)(retC)

	return retGo
}

// RemoveActionWidget is a wrapper around the C function gtk_assistant_remove_action_widget.
func (recv *Assistant) RemoveActionWidget(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_assistant_remove_action_widget((*C.GtkAssistant)(recv.native), c_child)

	return
}

// SetCurrentPage is a wrapper around the C function gtk_assistant_set_current_page.
func (recv *Assistant) SetCurrentPage(pageNum int32) {
	c_page_num := (C.gint)(pageNum)

	C.gtk_assistant_set_current_page((*C.GtkAssistant)(recv.native), c_page_num)

	return
}

// Unsupported : gtk_assistant_set_forward_page_func : unsupported parameter page_func : no type generator for AssistantPageFunc (GtkAssistantPageFunc) for param page_func

// SetPageComplete is a wrapper around the C function gtk_assistant_set_page_complete.
func (recv *Assistant) SetPageComplete(page *Widget, complete bool) {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	c_complete :=
		boolToGboolean(complete)

	C.gtk_assistant_set_page_complete((*C.GtkAssistant)(recv.native), c_page, c_complete)

	return
}

// SetPageHeaderImage is a wrapper around the C function gtk_assistant_set_page_header_image.
func (recv *Assistant) SetPageHeaderImage(page *Widget, pixbuf *gdkpixbuf.Pixbuf) {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_assistant_set_page_header_image((*C.GtkAssistant)(recv.native), c_page, c_pixbuf)

	return
}

// SetPageSideImage is a wrapper around the C function gtk_assistant_set_page_side_image.
func (recv *Assistant) SetPageSideImage(page *Widget, pixbuf *gdkpixbuf.Pixbuf) {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_assistant_set_page_side_image((*C.GtkAssistant)(recv.native), c_page, c_pixbuf)

	return
}

// SetPageTitle is a wrapper around the C function gtk_assistant_set_page_title.
func (recv *Assistant) SetPageTitle(page *Widget, title string) {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_assistant_set_page_title((*C.GtkAssistant)(recv.native), c_page, c_title)

	return
}

// SetPageType is a wrapper around the C function gtk_assistant_set_page_type.
func (recv *Assistant) SetPageType(page *Widget, type_ AssistantPageType) {
	c_page := (*C.GtkWidget)(C.NULL)
	if page != nil {
		c_page = (*C.GtkWidget)(page.ToC())
	}

	c_type := (C.GtkAssistantPageType)(type_)

	C.gtk_assistant_set_page_type((*C.GtkAssistant)(recv.native), c_page, c_type)

	return
}

// UpdateButtonsState is a wrapper around the C function gtk_assistant_update_buttons_state.
func (recv *Assistant) UpdateButtonsState() {
	C.gtk_assistant_update_buttons_state((*C.GtkAssistant)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Assistant
func (recv *Assistant) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Assistant
func (recv *Assistant) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Bin is a wrapper around the C record GtkBin.
type Bin struct {
	native *C.GtkBin
	// container : record
	// Private : priv
}

func BinNewFromC(u unsafe.Pointer) *Bin {
	c := (*C.GtkBin)(u)
	if c == nil {
		return nil
	}

	g := &Bin{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Bin) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Bin) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Bin with another Bin, and returns true if they represent the same GObject.
func (recv *Bin) Equals(other *Bin) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Bin) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Bin) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Bin) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Bin) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Bin.
// Exercise care, as this is a potentially dangerous function if the Object is not a Bin.
func CastToBin(object *gobject.Object) *Bin {
	return BinNewFromC(object.ToC())
}

// GetChild is a wrapper around the C function gtk_bin_get_child.
func (recv *Bin) GetChild() *Widget {
	retC := C.gtk_bin_get_child((*C.GtkBin)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Bin
func (recv *Bin) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Bin
func (recv *Bin) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// BooleanCellAccessible is a wrapper around the C record GtkBooleanCellAccessible.
type BooleanCellAccessible struct {
	native *C.GtkBooleanCellAccessible
	// parent : record
	// priv : record
}

func BooleanCellAccessibleNewFromC(u unsafe.Pointer) *BooleanCellAccessible {
	c := (*C.GtkBooleanCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &BooleanCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *BooleanCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *BooleanCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BooleanCellAccessible with another BooleanCellAccessible, and returns true if they represent the same GObject.
func (recv *BooleanCellAccessible) Equals(other *BooleanCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *BooleanCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *BooleanCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *BooleanCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *BooleanCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to BooleanCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a BooleanCellAccessible.
func CastToBooleanCellAccessible(object *gobject.Object) *BooleanCellAccessible {
	return BooleanCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by BooleanCellAccessible
func (recv *BooleanCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by BooleanCellAccessible
func (recv *BooleanCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Box is a wrapper around the C record GtkBox.
type Box struct {
	native *C.GtkBox
	// container : record
	// Private : priv
}

func BoxNewFromC(u unsafe.Pointer) *Box {
	c := (*C.GtkBox)(u)
	if c == nil {
		return nil
	}

	g := &Box{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Box) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Box) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Box with another Box, and returns true if they represent the same GObject.
func (recv *Box) Equals(other *Box) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Box) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Box) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Box) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Box) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Box.
// Exercise care, as this is a potentially dangerous function if the Object is not a Box.
func CastToBox(object *gobject.Object) *Box {
	return BoxNewFromC(object.ToC())
}

// GetHomogeneous is a wrapper around the C function gtk_box_get_homogeneous.
func (recv *Box) GetHomogeneous() bool {
	retC := C.gtk_box_get_homogeneous((*C.GtkBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSpacing is a wrapper around the C function gtk_box_get_spacing.
func (recv *Box) GetSpacing() int32 {
	retC := C.gtk_box_get_spacing((*C.GtkBox)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// PackEnd is a wrapper around the C function gtk_box_pack_end.
func (recv *Box) PackEnd(child *Widget, expand bool, fill bool, padding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	C.gtk_box_pack_end((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding)

	return
}

// PackStart is a wrapper around the C function gtk_box_pack_start.
func (recv *Box) PackStart(child *Widget, expand bool, fill bool, padding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	C.gtk_box_pack_start((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding)

	return
}

// QueryChildPacking is a wrapper around the C function gtk_box_query_child_packing.
func (recv *Box) QueryChildPacking(child *Widget) (bool, bool, uint32, PackType) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	var c_expand C.gboolean

	var c_fill C.gboolean

	var c_padding C.guint

	var c_pack_type C.GtkPackType

	C.gtk_box_query_child_packing((*C.GtkBox)(recv.native), c_child, &c_expand, &c_fill, &c_padding, &c_pack_type)

	expand := c_expand == C.TRUE

	fill := c_fill == C.TRUE

	padding := (uint32)(c_padding)

	packType := (PackType)(c_pack_type)

	return expand, fill, padding, packType
}

// ReorderChild is a wrapper around the C function gtk_box_reorder_child.
func (recv *Box) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_box_reorder_child((*C.GtkBox)(recv.native), c_child, c_position)

	return
}

// SetChildPacking is a wrapper around the C function gtk_box_set_child_packing.
func (recv *Box) SetChildPacking(child *Widget, expand bool, fill bool, padding uint32, packType PackType) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	c_fill :=
		boolToGboolean(fill)

	c_padding := (C.guint)(padding)

	c_pack_type := (C.GtkPackType)(packType)

	C.gtk_box_set_child_packing((*C.GtkBox)(recv.native), c_child, c_expand, c_fill, c_padding, c_pack_type)

	return
}

// SetHomogeneous is a wrapper around the C function gtk_box_set_homogeneous.
func (recv *Box) SetHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_box_set_homogeneous((*C.GtkBox)(recv.native), c_homogeneous)

	return
}

// SetSpacing is a wrapper around the C function gtk_box_set_spacing.
func (recv *Box) SetSpacing(spacing int32) {
	c_spacing := (C.gint)(spacing)

	C.gtk_box_set_spacing((*C.GtkBox)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Box
func (recv *Box) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Box
func (recv *Box) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Box
func (recv *Box) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Builder is a wrapper around the C record GtkBuilder.
type Builder struct {
	native *C.GtkBuilder
	// parent_instance : record
	// priv : record
}

func BuilderNewFromC(u unsafe.Pointer) *Builder {
	c := (*C.GtkBuilder)(u)
	if c == nil {
		return nil
	}

	g := &Builder{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Builder) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Builder) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Builder with another Builder, and returns true if they represent the same GObject.
func (recv *Builder) Equals(other *Builder) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Builder) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Builder.
// Exercise care, as this is a potentially dangerous function if the Object is not a Builder.
func CastToBuilder(object *gobject.Object) *Builder {
	return BuilderNewFromC(object.ToC())
}

// BuilderNew is a wrapper around the C function gtk_builder_new.
func BuilderNew() *Builder {
	retC := C.gtk_builder_new()
	retGo := BuilderNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddFromFile is a wrapper around the C function gtk_builder_add_from_file.
func (recv *Builder) AddFromFile(filename string) (uint32, error) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	var cThrowableError *C.GError

	retC := C.gtk_builder_add_from_file((*C.GtkBuilder)(recv.native), c_filename, &cThrowableError)
	retGo := (uint32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// AddFromString is a wrapper around the C function gtk_builder_add_from_string.
func (recv *Builder) AddFromString(buffer string, length uint64) (uint32, error) {
	c_buffer := C.CString(buffer)
	defer C.free(unsafe.Pointer(c_buffer))

	c_length := (C.gsize)(length)

	var cThrowableError *C.GError

	retC := C.gtk_builder_add_from_string((*C.GtkBuilder)(recv.native), c_buffer, c_length, &cThrowableError)
	retGo := (uint32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ConnectSignals is a wrapper around the C function gtk_builder_connect_signals.
func (recv *Builder) ConnectSignals(userData uintptr) {
	c_user_data := (C.gpointer)(userData)

	C.gtk_builder_connect_signals((*C.GtkBuilder)(recv.native), c_user_data)

	return
}

// Unsupported : gtk_builder_connect_signals_full : unsupported parameter func : no type generator for BuilderConnectFunc (GtkBuilderConnectFunc) for param func

// Blacklisted : gtk_builder_extend_with_template

// GetObject is a wrapper around the C function gtk_builder_get_object.
func (recv *Builder) GetObject(name string) *gobject.Object {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_builder_get_object((*C.GtkBuilder)(recv.native), c_name)
	var retGo (*gobject.Object)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gobject.ObjectNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetObjects is a wrapper around the C function gtk_builder_get_objects.
func (recv *Builder) GetObjects() *glib.SList {
	retC := C.gtk_builder_get_objects((*C.GtkBuilder)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetTranslationDomain is a wrapper around the C function gtk_builder_get_translation_domain.
func (recv *Builder) GetTranslationDomain() string {
	retC := C.gtk_builder_get_translation_domain((*C.GtkBuilder)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetTypeFromName is a wrapper around the C function gtk_builder_get_type_from_name.
func (recv *Builder) GetTypeFromName(typeName string) gobject.Type {
	c_type_name := C.CString(typeName)
	defer C.free(unsafe.Pointer(c_type_name))

	retC := C.gtk_builder_get_type_from_name((*C.GtkBuilder)(recv.native), c_type_name)
	retGo := (gobject.Type)(retC)

	return retGo
}

// SetTranslationDomain is a wrapper around the C function gtk_builder_set_translation_domain.
func (recv *Builder) SetTranslationDomain(domain string) {
	c_domain := C.CString(domain)
	defer C.free(unsafe.Pointer(c_domain))

	C.gtk_builder_set_translation_domain((*C.GtkBuilder)(recv.native), c_domain)

	return
}

// ValueFromString is a wrapper around the C function gtk_builder_value_from_string.
func (recv *Builder) ValueFromString(pspec *gobject.ParamSpec, string_ string) (bool, *gobject.Value, error) {
	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	var c_value C.GValue

	var cThrowableError *C.GError

	retC := C.gtk_builder_value_from_string((*C.GtkBuilder)(recv.native), c_pspec, c_string, &c_value, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	value := gobject.ValueNewFromC(unsafe.Pointer(&c_value))

	return retGo, value, goError
}

// ValueFromStringType is a wrapper around the C function gtk_builder_value_from_string_type.
func (recv *Builder) ValueFromStringType(type_ gobject.Type, string_ string) (bool, *gobject.Value, error) {
	c_type := (C.GType)(type_)

	c_string := C.CString(string_)
	defer C.free(unsafe.Pointer(c_string))

	var c_value C.GValue

	var cThrowableError *C.GError

	retC := C.gtk_builder_value_from_string_type((*C.GtkBuilder)(recv.native), c_type, c_string, &c_value, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	value := gobject.ValueNewFromC(unsafe.Pointer(&c_value))

	return retGo, value, goError
}

// Button is a wrapper around the C record GtkButton.
type Button struct {
	native *C.GtkButton
	// Private : bin
	// Private : priv
}

func ButtonNewFromC(u unsafe.Pointer) *Button {
	c := (*C.GtkButton)(u)
	if c == nil {
		return nil
	}

	g := &Button{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Button) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Button) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Button with another Button, and returns true if they represent the same GObject.
func (recv *Button) Equals(other *Button) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Button) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Button) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Button) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Button) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Button) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Button.
// Exercise care, as this is a potentially dangerous function if the Object is not a Button.
func CastToButton(object *gobject.Object) *Button {
	return ButtonNewFromC(object.ToC())
}

type signalButtonActivateDetail struct {
	callback  ButtonSignalActivateCallback
	handlerID C.gulong
}

var signalButtonActivateId int
var signalButtonActivateMap = make(map[int]signalButtonActivateDetail)
var signalButtonActivateLock sync.RWMutex

// ButtonSignalActivateCallback is a callback function for a 'activate' signal emitted from a Button.
type ButtonSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Button) ConnectActivate(callback ButtonSignalActivateCallback) int {
	signalButtonActivateLock.Lock()
	defer signalButtonActivateLock.Unlock()

	signalButtonActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_activate(instance, C.gpointer(uintptr(signalButtonActivateId)))

	detail := signalButtonActivateDetail{callback, handlerID}
	signalButtonActivateMap[signalButtonActivateId] = detail

	return signalButtonActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Button.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Button) DisconnectActivate(connectionID int) {
	signalButtonActivateLock.Lock()
	defer signalButtonActivateLock.Unlock()

	detail, exists := signalButtonActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonActivateMap, connectionID)
}

//export button_activateHandler
func button_activateHandler(_ *C.GObject, data C.gpointer) {
	signalButtonActivateLock.RLock()
	defer signalButtonActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonActivateMap[index].callback
	callback()
}

type signalButtonClickedDetail struct {
	callback  ButtonSignalClickedCallback
	handlerID C.gulong
}

var signalButtonClickedId int
var signalButtonClickedMap = make(map[int]signalButtonClickedDetail)
var signalButtonClickedLock sync.RWMutex

// ButtonSignalClickedCallback is a callback function for a 'clicked' signal emitted from a Button.
type ButtonSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *Button) ConnectClicked(callback ButtonSignalClickedCallback) int {
	signalButtonClickedLock.Lock()
	defer signalButtonClickedLock.Unlock()

	signalButtonClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_clicked(instance, C.gpointer(uintptr(signalButtonClickedId)))

	detail := signalButtonClickedDetail{callback, handlerID}
	signalButtonClickedMap[signalButtonClickedId] = detail

	return signalButtonClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the Button.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *Button) DisconnectClicked(connectionID int) {
	signalButtonClickedLock.Lock()
	defer signalButtonClickedLock.Unlock()

	detail, exists := signalButtonClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonClickedMap, connectionID)
}

//export button_clickedHandler
func button_clickedHandler(_ *C.GObject, data C.gpointer) {
	signalButtonClickedLock.RLock()
	defer signalButtonClickedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonClickedMap[index].callback
	callback()
}

type signalButtonEnterDetail struct {
	callback  ButtonSignalEnterCallback
	handlerID C.gulong
}

var signalButtonEnterId int
var signalButtonEnterMap = make(map[int]signalButtonEnterDetail)
var signalButtonEnterLock sync.RWMutex

// ButtonSignalEnterCallback is a callback function for a 'enter' signal emitted from a Button.
type ButtonSignalEnterCallback func()

/*
ConnectEnter connects the callback to the 'enter' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectEnter to remove it.
*/
func (recv *Button) ConnectEnter(callback ButtonSignalEnterCallback) int {
	signalButtonEnterLock.Lock()
	defer signalButtonEnterLock.Unlock()

	signalButtonEnterId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_enter(instance, C.gpointer(uintptr(signalButtonEnterId)))

	detail := signalButtonEnterDetail{callback, handlerID}
	signalButtonEnterMap[signalButtonEnterId] = detail

	return signalButtonEnterId
}

/*
DisconnectEnter disconnects a callback from the 'enter' signal for the Button.

The connectionID should be a value returned from a call to ConnectEnter.
*/
func (recv *Button) DisconnectEnter(connectionID int) {
	signalButtonEnterLock.Lock()
	defer signalButtonEnterLock.Unlock()

	detail, exists := signalButtonEnterMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonEnterMap, connectionID)
}

//export button_enterHandler
func button_enterHandler(_ *C.GObject, data C.gpointer) {
	signalButtonEnterLock.RLock()
	defer signalButtonEnterLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonEnterMap[index].callback
	callback()
}

type signalButtonLeaveDetail struct {
	callback  ButtonSignalLeaveCallback
	handlerID C.gulong
}

var signalButtonLeaveId int
var signalButtonLeaveMap = make(map[int]signalButtonLeaveDetail)
var signalButtonLeaveLock sync.RWMutex

// ButtonSignalLeaveCallback is a callback function for a 'leave' signal emitted from a Button.
type ButtonSignalLeaveCallback func()

/*
ConnectLeave connects the callback to the 'leave' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectLeave to remove it.
*/
func (recv *Button) ConnectLeave(callback ButtonSignalLeaveCallback) int {
	signalButtonLeaveLock.Lock()
	defer signalButtonLeaveLock.Unlock()

	signalButtonLeaveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_leave(instance, C.gpointer(uintptr(signalButtonLeaveId)))

	detail := signalButtonLeaveDetail{callback, handlerID}
	signalButtonLeaveMap[signalButtonLeaveId] = detail

	return signalButtonLeaveId
}

/*
DisconnectLeave disconnects a callback from the 'leave' signal for the Button.

The connectionID should be a value returned from a call to ConnectLeave.
*/
func (recv *Button) DisconnectLeave(connectionID int) {
	signalButtonLeaveLock.Lock()
	defer signalButtonLeaveLock.Unlock()

	detail, exists := signalButtonLeaveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonLeaveMap, connectionID)
}

//export button_leaveHandler
func button_leaveHandler(_ *C.GObject, data C.gpointer) {
	signalButtonLeaveLock.RLock()
	defer signalButtonLeaveLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonLeaveMap[index].callback
	callback()
}

type signalButtonPressedDetail struct {
	callback  ButtonSignalPressedCallback
	handlerID C.gulong
}

var signalButtonPressedId int
var signalButtonPressedMap = make(map[int]signalButtonPressedDetail)
var signalButtonPressedLock sync.RWMutex

// ButtonSignalPressedCallback is a callback function for a 'pressed' signal emitted from a Button.
type ButtonSignalPressedCallback func()

/*
ConnectPressed connects the callback to the 'pressed' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectPressed to remove it.
*/
func (recv *Button) ConnectPressed(callback ButtonSignalPressedCallback) int {
	signalButtonPressedLock.Lock()
	defer signalButtonPressedLock.Unlock()

	signalButtonPressedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_pressed(instance, C.gpointer(uintptr(signalButtonPressedId)))

	detail := signalButtonPressedDetail{callback, handlerID}
	signalButtonPressedMap[signalButtonPressedId] = detail

	return signalButtonPressedId
}

/*
DisconnectPressed disconnects a callback from the 'pressed' signal for the Button.

The connectionID should be a value returned from a call to ConnectPressed.
*/
func (recv *Button) DisconnectPressed(connectionID int) {
	signalButtonPressedLock.Lock()
	defer signalButtonPressedLock.Unlock()

	detail, exists := signalButtonPressedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonPressedMap, connectionID)
}

//export button_pressedHandler
func button_pressedHandler(_ *C.GObject, data C.gpointer) {
	signalButtonPressedLock.RLock()
	defer signalButtonPressedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonPressedMap[index].callback
	callback()
}

type signalButtonReleasedDetail struct {
	callback  ButtonSignalReleasedCallback
	handlerID C.gulong
}

var signalButtonReleasedId int
var signalButtonReleasedMap = make(map[int]signalButtonReleasedDetail)
var signalButtonReleasedLock sync.RWMutex

// ButtonSignalReleasedCallback is a callback function for a 'released' signal emitted from a Button.
type ButtonSignalReleasedCallback func()

/*
ConnectReleased connects the callback to the 'released' signal for the Button.

The returned value represents the connection, and may be passed to DisconnectReleased to remove it.
*/
func (recv *Button) ConnectReleased(callback ButtonSignalReleasedCallback) int {
	signalButtonReleasedLock.Lock()
	defer signalButtonReleasedLock.Unlock()

	signalButtonReleasedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Button_signal_connect_released(instance, C.gpointer(uintptr(signalButtonReleasedId)))

	detail := signalButtonReleasedDetail{callback, handlerID}
	signalButtonReleasedMap[signalButtonReleasedId] = detail

	return signalButtonReleasedId
}

/*
DisconnectReleased disconnects a callback from the 'released' signal for the Button.

The connectionID should be a value returned from a call to ConnectReleased.
*/
func (recv *Button) DisconnectReleased(connectionID int) {
	signalButtonReleasedLock.Lock()
	defer signalButtonReleasedLock.Unlock()

	detail, exists := signalButtonReleasedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalButtonReleasedMap, connectionID)
}

//export button_releasedHandler
func button_releasedHandler(_ *C.GObject, data C.gpointer) {
	signalButtonReleasedLock.RLock()
	defer signalButtonReleasedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalButtonReleasedMap[index].callback
	callback()
}

// ButtonNew is a wrapper around the C function gtk_button_new.
func ButtonNew() *Button {
	retC := C.gtk_button_new()
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ButtonNewFromStock is a wrapper around the C function gtk_button_new_from_stock.
func ButtonNewFromStock(stockId string) *Button {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_button_new_from_stock(c_stock_id)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ButtonNewWithLabel is a wrapper around the C function gtk_button_new_with_label.
func ButtonNewWithLabel(label string) *Button {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_button_new_with_label(c_label)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ButtonNewWithMnemonic is a wrapper around the C function gtk_button_new_with_mnemonic.
func ButtonNewWithMnemonic(label string) *Button {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_button_new_with_mnemonic(c_label)
	retGo := ButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Clicked is a wrapper around the C function gtk_button_clicked.
func (recv *Button) Clicked() {
	C.gtk_button_clicked((*C.GtkButton)(recv.native))

	return
}

// Enter is a wrapper around the C function gtk_button_enter.
func (recv *Button) Enter() {
	C.gtk_button_enter((*C.GtkButton)(recv.native))

	return
}

// GetAlignment is a wrapper around the C function gtk_button_get_alignment.
func (recv *Button) GetAlignment() (float32, float32) {
	var c_xalign C.gfloat

	var c_yalign C.gfloat

	C.gtk_button_get_alignment((*C.GtkButton)(recv.native), &c_xalign, &c_yalign)

	xalign := (float32)(c_xalign)

	yalign := (float32)(c_yalign)

	return xalign, yalign
}

// GetFocusOnClick is a wrapper around the C function gtk_button_get_focus_on_click.
func (recv *Button) GetFocusOnClick() bool {
	retC := C.gtk_button_get_focus_on_click((*C.GtkButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetImage is a wrapper around the C function gtk_button_get_image.
func (recv *Button) GetImage() *Widget {
	retC := C.gtk_button_get_image((*C.GtkButton)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetImagePosition is a wrapper around the C function gtk_button_get_image_position.
func (recv *Button) GetImagePosition() PositionType {
	retC := C.gtk_button_get_image_position((*C.GtkButton)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// GetLabel is a wrapper around the C function gtk_button_get_label.
func (recv *Button) GetLabel() string {
	retC := C.gtk_button_get_label((*C.GtkButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetRelief is a wrapper around the C function gtk_button_get_relief.
func (recv *Button) GetRelief() ReliefStyle {
	retC := C.gtk_button_get_relief((*C.GtkButton)(recv.native))
	retGo := (ReliefStyle)(retC)

	return retGo
}

// GetUseStock is a wrapper around the C function gtk_button_get_use_stock.
func (recv *Button) GetUseStock() bool {
	retC := C.gtk_button_get_use_stock((*C.GtkButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetUseUnderline is a wrapper around the C function gtk_button_get_use_underline.
func (recv *Button) GetUseUnderline() bool {
	retC := C.gtk_button_get_use_underline((*C.GtkButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Leave is a wrapper around the C function gtk_button_leave.
func (recv *Button) Leave() {
	C.gtk_button_leave((*C.GtkButton)(recv.native))

	return
}

// Pressed is a wrapper around the C function gtk_button_pressed.
func (recv *Button) Pressed() {
	C.gtk_button_pressed((*C.GtkButton)(recv.native))

	return
}

// Released is a wrapper around the C function gtk_button_released.
func (recv *Button) Released() {
	C.gtk_button_released((*C.GtkButton)(recv.native))

	return
}

// SetAlignment is a wrapper around the C function gtk_button_set_alignment.
func (recv *Button) SetAlignment(xalign float32, yalign float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	C.gtk_button_set_alignment((*C.GtkButton)(recv.native), c_xalign, c_yalign)

	return
}

// SetFocusOnClick is a wrapper around the C function gtk_button_set_focus_on_click.
func (recv *Button) SetFocusOnClick(focusOnClick bool) {
	c_focus_on_click :=
		boolToGboolean(focusOnClick)

	C.gtk_button_set_focus_on_click((*C.GtkButton)(recv.native), c_focus_on_click)

	return
}

// SetImage is a wrapper around the C function gtk_button_set_image.
func (recv *Button) SetImage(image *Widget) {
	c_image := (*C.GtkWidget)(C.NULL)
	if image != nil {
		c_image = (*C.GtkWidget)(image.ToC())
	}

	C.gtk_button_set_image((*C.GtkButton)(recv.native), c_image)

	return
}

// SetImagePosition is a wrapper around the C function gtk_button_set_image_position.
func (recv *Button) SetImagePosition(position PositionType) {
	c_position := (C.GtkPositionType)(position)

	C.gtk_button_set_image_position((*C.GtkButton)(recv.native), c_position)

	return
}

// SetLabel is a wrapper around the C function gtk_button_set_label.
func (recv *Button) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_button_set_label((*C.GtkButton)(recv.native), c_label)

	return
}

// SetRelief is a wrapper around the C function gtk_button_set_relief.
func (recv *Button) SetRelief(relief ReliefStyle) {
	c_relief := (C.GtkReliefStyle)(relief)

	C.gtk_button_set_relief((*C.GtkButton)(recv.native), c_relief)

	return
}

// SetUseStock is a wrapper around the C function gtk_button_set_use_stock.
func (recv *Button) SetUseStock(useStock bool) {
	c_use_stock :=
		boolToGboolean(useStock)

	C.gtk_button_set_use_stock((*C.GtkButton)(recv.native), c_use_stock)

	return
}

// SetUseUnderline is a wrapper around the C function gtk_button_set_use_underline.
func (recv *Button) SetUseUnderline(useUnderline bool) {
	c_use_underline :=
		boolToGboolean(useUnderline)

	C.gtk_button_set_use_underline((*C.GtkButton)(recv.native), c_use_underline)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Button
func (recv *Button) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by Button
func (recv *Button) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by Button
func (recv *Button) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Button
func (recv *Button) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ButtonAccessible is a wrapper around the C record GtkButtonAccessible.
type ButtonAccessible struct {
	native *C.GtkButtonAccessible
	// parent : record
	// priv : record
}

func ButtonAccessibleNewFromC(u unsafe.Pointer) *ButtonAccessible {
	c := (*C.GtkButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonAccessible with another ButtonAccessible, and returns true if they represent the same GObject.
func (recv *ButtonAccessible) Equals(other *ButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ButtonAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ButtonAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ButtonAccessible.
func CastToButtonAccessible(object *gobject.Object) *ButtonAccessible {
	return ButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ButtonAccessible
func (recv *ButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ButtonBox is a wrapper around the C record GtkButtonBox.
type ButtonBox struct {
	native *C.GtkButtonBox
	// box : record
	// Private : priv
}

func ButtonBoxNewFromC(u unsafe.Pointer) *ButtonBox {
	c := (*C.GtkButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &ButtonBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ButtonBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonBox with another ButtonBox, and returns true if they represent the same GObject.
func (recv *ButtonBox) Equals(other *ButtonBox) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *ButtonBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ButtonBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ButtonBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ButtonBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to ButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ButtonBox.
func CastToButtonBox(object *gobject.Object) *ButtonBox {
	return ButtonBoxNewFromC(object.ToC())
}

// GetChildSecondary is a wrapper around the C function gtk_button_box_get_child_secondary.
func (recv *ButtonBox) GetChildSecondary(child *Widget) bool {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_button_box_get_child_secondary((*C.GtkButtonBox)(recv.native), c_child)
	retGo := retC == C.TRUE

	return retGo
}

// GetLayout is a wrapper around the C function gtk_button_box_get_layout.
func (recv *ButtonBox) GetLayout() ButtonBoxStyle {
	retC := C.gtk_button_box_get_layout((*C.GtkButtonBox)(recv.native))
	retGo := (ButtonBoxStyle)(retC)

	return retGo
}

// SetChildSecondary is a wrapper around the C function gtk_button_box_set_child_secondary.
func (recv *ButtonBox) SetChildSecondary(child *Widget, isSecondary bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_is_secondary :=
		boolToGboolean(isSecondary)

	C.gtk_button_box_set_child_secondary((*C.GtkButtonBox)(recv.native), c_child, c_is_secondary)

	return
}

// SetLayout is a wrapper around the C function gtk_button_box_set_layout.
func (recv *ButtonBox) SetLayout(layoutStyle ButtonBoxStyle) {
	c_layout_style := (C.GtkButtonBoxStyle)(layoutStyle)

	C.gtk_button_box_set_layout((*C.GtkButtonBox)(recv.native), c_layout_style)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ButtonBox
func (recv *ButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ButtonBox
func (recv *ButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ButtonBox
func (recv *ButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Calendar is a wrapper around the C record GtkCalendar.
type Calendar struct {
	native *C.GtkCalendar
	// widget : record
	// priv : record
}

func CalendarNewFromC(u unsafe.Pointer) *Calendar {
	c := (*C.GtkCalendar)(u)
	if c == nil {
		return nil
	}

	g := &Calendar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Calendar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Calendar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Calendar with another Calendar, and returns true if they represent the same GObject.
func (recv *Calendar) Equals(other *Calendar) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Calendar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Calendar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Calendar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Calendar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Calendar.
func CastToCalendar(object *gobject.Object) *Calendar {
	return CalendarNewFromC(object.ToC())
}

type signalCalendarDaySelectedDetail struct {
	callback  CalendarSignalDaySelectedCallback
	handlerID C.gulong
}

var signalCalendarDaySelectedId int
var signalCalendarDaySelectedMap = make(map[int]signalCalendarDaySelectedDetail)
var signalCalendarDaySelectedLock sync.RWMutex

// CalendarSignalDaySelectedCallback is a callback function for a 'day-selected' signal emitted from a Calendar.
type CalendarSignalDaySelectedCallback func()

/*
ConnectDaySelected connects the callback to the 'day-selected' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectDaySelected to remove it.
*/
func (recv *Calendar) ConnectDaySelected(callback CalendarSignalDaySelectedCallback) int {
	signalCalendarDaySelectedLock.Lock()
	defer signalCalendarDaySelectedLock.Unlock()

	signalCalendarDaySelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_day_selected(instance, C.gpointer(uintptr(signalCalendarDaySelectedId)))

	detail := signalCalendarDaySelectedDetail{callback, handlerID}
	signalCalendarDaySelectedMap[signalCalendarDaySelectedId] = detail

	return signalCalendarDaySelectedId
}

/*
DisconnectDaySelected disconnects a callback from the 'day-selected' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectDaySelected.
*/
func (recv *Calendar) DisconnectDaySelected(connectionID int) {
	signalCalendarDaySelectedLock.Lock()
	defer signalCalendarDaySelectedLock.Unlock()

	detail, exists := signalCalendarDaySelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarDaySelectedMap, connectionID)
}

//export calendar_daySelectedHandler
func calendar_daySelectedHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarDaySelectedLock.RLock()
	defer signalCalendarDaySelectedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarDaySelectedMap[index].callback
	callback()
}

type signalCalendarDaySelectedDoubleClickDetail struct {
	callback  CalendarSignalDaySelectedDoubleClickCallback
	handlerID C.gulong
}

var signalCalendarDaySelectedDoubleClickId int
var signalCalendarDaySelectedDoubleClickMap = make(map[int]signalCalendarDaySelectedDoubleClickDetail)
var signalCalendarDaySelectedDoubleClickLock sync.RWMutex

// CalendarSignalDaySelectedDoubleClickCallback is a callback function for a 'day-selected-double-click' signal emitted from a Calendar.
type CalendarSignalDaySelectedDoubleClickCallback func()

/*
ConnectDaySelectedDoubleClick connects the callback to the 'day-selected-double-click' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectDaySelectedDoubleClick to remove it.
*/
func (recv *Calendar) ConnectDaySelectedDoubleClick(callback CalendarSignalDaySelectedDoubleClickCallback) int {
	signalCalendarDaySelectedDoubleClickLock.Lock()
	defer signalCalendarDaySelectedDoubleClickLock.Unlock()

	signalCalendarDaySelectedDoubleClickId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_day_selected_double_click(instance, C.gpointer(uintptr(signalCalendarDaySelectedDoubleClickId)))

	detail := signalCalendarDaySelectedDoubleClickDetail{callback, handlerID}
	signalCalendarDaySelectedDoubleClickMap[signalCalendarDaySelectedDoubleClickId] = detail

	return signalCalendarDaySelectedDoubleClickId
}

/*
DisconnectDaySelectedDoubleClick disconnects a callback from the 'day-selected-double-click' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectDaySelectedDoubleClick.
*/
func (recv *Calendar) DisconnectDaySelectedDoubleClick(connectionID int) {
	signalCalendarDaySelectedDoubleClickLock.Lock()
	defer signalCalendarDaySelectedDoubleClickLock.Unlock()

	detail, exists := signalCalendarDaySelectedDoubleClickMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarDaySelectedDoubleClickMap, connectionID)
}

//export calendar_daySelectedDoubleClickHandler
func calendar_daySelectedDoubleClickHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarDaySelectedDoubleClickLock.RLock()
	defer signalCalendarDaySelectedDoubleClickLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarDaySelectedDoubleClickMap[index].callback
	callback()
}

type signalCalendarMonthChangedDetail struct {
	callback  CalendarSignalMonthChangedCallback
	handlerID C.gulong
}

var signalCalendarMonthChangedId int
var signalCalendarMonthChangedMap = make(map[int]signalCalendarMonthChangedDetail)
var signalCalendarMonthChangedLock sync.RWMutex

// CalendarSignalMonthChangedCallback is a callback function for a 'month-changed' signal emitted from a Calendar.
type CalendarSignalMonthChangedCallback func()

/*
ConnectMonthChanged connects the callback to the 'month-changed' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectMonthChanged to remove it.
*/
func (recv *Calendar) ConnectMonthChanged(callback CalendarSignalMonthChangedCallback) int {
	signalCalendarMonthChangedLock.Lock()
	defer signalCalendarMonthChangedLock.Unlock()

	signalCalendarMonthChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_month_changed(instance, C.gpointer(uintptr(signalCalendarMonthChangedId)))

	detail := signalCalendarMonthChangedDetail{callback, handlerID}
	signalCalendarMonthChangedMap[signalCalendarMonthChangedId] = detail

	return signalCalendarMonthChangedId
}

/*
DisconnectMonthChanged disconnects a callback from the 'month-changed' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectMonthChanged.
*/
func (recv *Calendar) DisconnectMonthChanged(connectionID int) {
	signalCalendarMonthChangedLock.Lock()
	defer signalCalendarMonthChangedLock.Unlock()

	detail, exists := signalCalendarMonthChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarMonthChangedMap, connectionID)
}

//export calendar_monthChangedHandler
func calendar_monthChangedHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarMonthChangedLock.RLock()
	defer signalCalendarMonthChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarMonthChangedMap[index].callback
	callback()
}

type signalCalendarNextMonthDetail struct {
	callback  CalendarSignalNextMonthCallback
	handlerID C.gulong
}

var signalCalendarNextMonthId int
var signalCalendarNextMonthMap = make(map[int]signalCalendarNextMonthDetail)
var signalCalendarNextMonthLock sync.RWMutex

// CalendarSignalNextMonthCallback is a callback function for a 'next-month' signal emitted from a Calendar.
type CalendarSignalNextMonthCallback func()

/*
ConnectNextMonth connects the callback to the 'next-month' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectNextMonth to remove it.
*/
func (recv *Calendar) ConnectNextMonth(callback CalendarSignalNextMonthCallback) int {
	signalCalendarNextMonthLock.Lock()
	defer signalCalendarNextMonthLock.Unlock()

	signalCalendarNextMonthId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_next_month(instance, C.gpointer(uintptr(signalCalendarNextMonthId)))

	detail := signalCalendarNextMonthDetail{callback, handlerID}
	signalCalendarNextMonthMap[signalCalendarNextMonthId] = detail

	return signalCalendarNextMonthId
}

/*
DisconnectNextMonth disconnects a callback from the 'next-month' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectNextMonth.
*/
func (recv *Calendar) DisconnectNextMonth(connectionID int) {
	signalCalendarNextMonthLock.Lock()
	defer signalCalendarNextMonthLock.Unlock()

	detail, exists := signalCalendarNextMonthMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarNextMonthMap, connectionID)
}

//export calendar_nextMonthHandler
func calendar_nextMonthHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarNextMonthLock.RLock()
	defer signalCalendarNextMonthLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarNextMonthMap[index].callback
	callback()
}

type signalCalendarNextYearDetail struct {
	callback  CalendarSignalNextYearCallback
	handlerID C.gulong
}

var signalCalendarNextYearId int
var signalCalendarNextYearMap = make(map[int]signalCalendarNextYearDetail)
var signalCalendarNextYearLock sync.RWMutex

// CalendarSignalNextYearCallback is a callback function for a 'next-year' signal emitted from a Calendar.
type CalendarSignalNextYearCallback func()

/*
ConnectNextYear connects the callback to the 'next-year' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectNextYear to remove it.
*/
func (recv *Calendar) ConnectNextYear(callback CalendarSignalNextYearCallback) int {
	signalCalendarNextYearLock.Lock()
	defer signalCalendarNextYearLock.Unlock()

	signalCalendarNextYearId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_next_year(instance, C.gpointer(uintptr(signalCalendarNextYearId)))

	detail := signalCalendarNextYearDetail{callback, handlerID}
	signalCalendarNextYearMap[signalCalendarNextYearId] = detail

	return signalCalendarNextYearId
}

/*
DisconnectNextYear disconnects a callback from the 'next-year' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectNextYear.
*/
func (recv *Calendar) DisconnectNextYear(connectionID int) {
	signalCalendarNextYearLock.Lock()
	defer signalCalendarNextYearLock.Unlock()

	detail, exists := signalCalendarNextYearMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarNextYearMap, connectionID)
}

//export calendar_nextYearHandler
func calendar_nextYearHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarNextYearLock.RLock()
	defer signalCalendarNextYearLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarNextYearMap[index].callback
	callback()
}

type signalCalendarPrevMonthDetail struct {
	callback  CalendarSignalPrevMonthCallback
	handlerID C.gulong
}

var signalCalendarPrevMonthId int
var signalCalendarPrevMonthMap = make(map[int]signalCalendarPrevMonthDetail)
var signalCalendarPrevMonthLock sync.RWMutex

// CalendarSignalPrevMonthCallback is a callback function for a 'prev-month' signal emitted from a Calendar.
type CalendarSignalPrevMonthCallback func()

/*
ConnectPrevMonth connects the callback to the 'prev-month' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectPrevMonth to remove it.
*/
func (recv *Calendar) ConnectPrevMonth(callback CalendarSignalPrevMonthCallback) int {
	signalCalendarPrevMonthLock.Lock()
	defer signalCalendarPrevMonthLock.Unlock()

	signalCalendarPrevMonthId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_prev_month(instance, C.gpointer(uintptr(signalCalendarPrevMonthId)))

	detail := signalCalendarPrevMonthDetail{callback, handlerID}
	signalCalendarPrevMonthMap[signalCalendarPrevMonthId] = detail

	return signalCalendarPrevMonthId
}

/*
DisconnectPrevMonth disconnects a callback from the 'prev-month' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectPrevMonth.
*/
func (recv *Calendar) DisconnectPrevMonth(connectionID int) {
	signalCalendarPrevMonthLock.Lock()
	defer signalCalendarPrevMonthLock.Unlock()

	detail, exists := signalCalendarPrevMonthMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarPrevMonthMap, connectionID)
}

//export calendar_prevMonthHandler
func calendar_prevMonthHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarPrevMonthLock.RLock()
	defer signalCalendarPrevMonthLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarPrevMonthMap[index].callback
	callback()
}

type signalCalendarPrevYearDetail struct {
	callback  CalendarSignalPrevYearCallback
	handlerID C.gulong
}

var signalCalendarPrevYearId int
var signalCalendarPrevYearMap = make(map[int]signalCalendarPrevYearDetail)
var signalCalendarPrevYearLock sync.RWMutex

// CalendarSignalPrevYearCallback is a callback function for a 'prev-year' signal emitted from a Calendar.
type CalendarSignalPrevYearCallback func()

/*
ConnectPrevYear connects the callback to the 'prev-year' signal for the Calendar.

The returned value represents the connection, and may be passed to DisconnectPrevYear to remove it.
*/
func (recv *Calendar) ConnectPrevYear(callback CalendarSignalPrevYearCallback) int {
	signalCalendarPrevYearLock.Lock()
	defer signalCalendarPrevYearLock.Unlock()

	signalCalendarPrevYearId++
	instance := C.gpointer(recv.native)
	handlerID := C.Calendar_signal_connect_prev_year(instance, C.gpointer(uintptr(signalCalendarPrevYearId)))

	detail := signalCalendarPrevYearDetail{callback, handlerID}
	signalCalendarPrevYearMap[signalCalendarPrevYearId] = detail

	return signalCalendarPrevYearId
}

/*
DisconnectPrevYear disconnects a callback from the 'prev-year' signal for the Calendar.

The connectionID should be a value returned from a call to ConnectPrevYear.
*/
func (recv *Calendar) DisconnectPrevYear(connectionID int) {
	signalCalendarPrevYearLock.Lock()
	defer signalCalendarPrevYearLock.Unlock()

	detail, exists := signalCalendarPrevYearMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCalendarPrevYearMap, connectionID)
}

//export calendar_prevYearHandler
func calendar_prevYearHandler(_ *C.GObject, data C.gpointer) {
	signalCalendarPrevYearLock.RLock()
	defer signalCalendarPrevYearLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCalendarPrevYearMap[index].callback
	callback()
}

// CalendarNew is a wrapper around the C function gtk_calendar_new.
func CalendarNew() *Calendar {
	retC := C.gtk_calendar_new()
	retGo := CalendarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ClearMarks is a wrapper around the C function gtk_calendar_clear_marks.
func (recv *Calendar) ClearMarks() {
	C.gtk_calendar_clear_marks((*C.GtkCalendar)(recv.native))

	return
}

// GetDate is a wrapper around the C function gtk_calendar_get_date.
func (recv *Calendar) GetDate() (uint32, uint32, uint32) {
	var c_year C.guint

	var c_month C.guint

	var c_day C.guint

	C.gtk_calendar_get_date((*C.GtkCalendar)(recv.native), &c_year, &c_month, &c_day)

	year := (uint32)(c_year)

	month := (uint32)(c_month)

	day := (uint32)(c_day)

	return year, month, day
}

// GetDisplayOptions is a wrapper around the C function gtk_calendar_get_display_options.
func (recv *Calendar) GetDisplayOptions() CalendarDisplayOptions {
	retC := C.gtk_calendar_get_display_options((*C.GtkCalendar)(recv.native))
	retGo := (CalendarDisplayOptions)(retC)

	return retGo
}

// MarkDay is a wrapper around the C function gtk_calendar_mark_day.
func (recv *Calendar) MarkDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_mark_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// SelectDay is a wrapper around the C function gtk_calendar_select_day.
func (recv *Calendar) SelectDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_select_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// SelectMonth is a wrapper around the C function gtk_calendar_select_month.
func (recv *Calendar) SelectMonth(month uint32, year uint32) {
	c_month := (C.guint)(month)

	c_year := (C.guint)(year)

	C.gtk_calendar_select_month((*C.GtkCalendar)(recv.native), c_month, c_year)

	return
}

// SetDisplayOptions is a wrapper around the C function gtk_calendar_set_display_options.
func (recv *Calendar) SetDisplayOptions(flags CalendarDisplayOptions) {
	c_flags := (C.GtkCalendarDisplayOptions)(flags)

	C.gtk_calendar_set_display_options((*C.GtkCalendar)(recv.native), c_flags)

	return
}

// UnmarkDay is a wrapper around the C function gtk_calendar_unmark_day.
func (recv *Calendar) UnmarkDay(day uint32) {
	c_day := (C.guint)(day)

	C.gtk_calendar_unmark_day((*C.GtkCalendar)(recv.native), c_day)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Calendar
func (recv *Calendar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Calendar
func (recv *Calendar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellAccessible is a wrapper around the C record GtkCellAccessible.
type CellAccessible struct {
	native *C.GtkCellAccessible
	// parent : record
	// priv : record
}

func CellAccessibleNewFromC(u unsafe.Pointer) *CellAccessible {
	c := (*C.GtkCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &CellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAccessible with another CellAccessible, and returns true if they represent the same GObject.
func (recv *CellAccessible) Equals(other *CellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// Accessible upcasts to *Accessible
func (recv *CellAccessible) Accessible() *Accessible {
	return AccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellAccessible) Object() *atk.Object {
	return recv.Accessible().Object()
}

// CastToWidget down casts any arbitrary Object to CellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAccessible.
func CastToCellAccessible(object *gobject.Object) *CellAccessible {
	return CellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by CellAccessible
func (recv *CellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by CellAccessible
func (recv *CellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// CellArea is a wrapper around the C record GtkCellArea.
type CellArea struct {
	native *C.GtkCellArea
	// Private : parent_instance
	// Private : priv
}

func CellAreaNewFromC(u unsafe.Pointer) *CellArea {
	c := (*C.GtkCellArea)(u)
	if c == nil {
		return nil
	}

	g := &CellArea{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellArea) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellArea) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellArea with another CellArea, and returns true if they represent the same GObject.
func (recv *CellArea) Equals(other *CellArea) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellArea) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellArea) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to CellArea.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellArea.
func CastToCellArea(object *gobject.Object) *CellArea {
	return CellAreaNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by CellArea
func (recv *CellArea) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellArea
func (recv *CellArea) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// CellAreaBox is a wrapper around the C record GtkCellAreaBox.
type CellAreaBox struct {
	native *C.GtkCellAreaBox
	// Private : parent_instance
	// Private : priv
}

func CellAreaBoxNewFromC(u unsafe.Pointer) *CellAreaBox {
	c := (*C.GtkCellAreaBox)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellAreaBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellAreaBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaBox with another CellAreaBox, and returns true if they represent the same GObject.
func (recv *CellAreaBox) Equals(other *CellAreaBox) bool {
	return other.ToC() == recv.ToC()
}

// CellArea upcasts to *CellArea
func (recv *CellAreaBox) CellArea() *CellArea {
	return CellAreaNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellAreaBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellArea().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellAreaBox) Object() *gobject.Object {
	return recv.CellArea().Object()
}

// CastToWidget down casts any arbitrary Object to CellAreaBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAreaBox.
func CastToCellAreaBox(object *gobject.Object) *CellAreaBox {
	return CellAreaBoxNewFromC(object.ToC())
}

// Buildable returns the Buildable interface implemented by CellAreaBox
func (recv *CellAreaBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellAreaBox
func (recv *CellAreaBox) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by CellAreaBox
func (recv *CellAreaBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CellAreaContext is a wrapper around the C record GtkCellAreaContext.
type CellAreaContext struct {
	native *C.GtkCellAreaContext
	// Private : parent_instance
	// Private : priv
}

func CellAreaContextNewFromC(u unsafe.Pointer) *CellAreaContext {
	c := (*C.GtkCellAreaContext)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellAreaContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellAreaContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaContext with another CellAreaContext, and returns true if they represent the same GObject.
func (recv *CellAreaContext) Equals(other *CellAreaContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *CellAreaContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to CellAreaContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellAreaContext.
func CastToCellAreaContext(object *gobject.Object) *CellAreaContext {
	return CellAreaContextNewFromC(object.ToC())
}

// Allocate is a wrapper around the C function gtk_cell_area_context_allocate.
func (recv *CellAreaContext) Allocate(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_cell_area_context_allocate((*C.GtkCellAreaContext)(recv.native), c_width, c_height)

	return
}

// Reset is a wrapper around the C function gtk_cell_area_context_reset.
func (recv *CellAreaContext) Reset() {
	C.gtk_cell_area_context_reset((*C.GtkCellAreaContext)(recv.native))

	return
}

// CellRenderer is a wrapper around the C record GtkCellRenderer.
type CellRenderer struct {
	native *C.GtkCellRenderer
	// parent_instance : record
	// Private : priv
}

func CellRendererNewFromC(u unsafe.Pointer) *CellRenderer {
	c := (*C.GtkCellRenderer)(u)
	if c == nil {
		return nil
	}

	g := &CellRenderer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRenderer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRenderer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRenderer with another CellRenderer, and returns true if they represent the same GObject.
func (recv *CellRenderer) Equals(other *CellRenderer) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRenderer) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *CellRenderer) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to CellRenderer.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRenderer.
func CastToCellRenderer(object *gobject.Object) *CellRenderer {
	return CellRendererNewFromC(object.ToC())
}

type signalCellRendererEditingCanceledDetail struct {
	callback  CellRendererSignalEditingCanceledCallback
	handlerID C.gulong
}

var signalCellRendererEditingCanceledId int
var signalCellRendererEditingCanceledMap = make(map[int]signalCellRendererEditingCanceledDetail)
var signalCellRendererEditingCanceledLock sync.RWMutex

// CellRendererSignalEditingCanceledCallback is a callback function for a 'editing-canceled' signal emitted from a CellRenderer.
type CellRendererSignalEditingCanceledCallback func()

/*
ConnectEditingCanceled connects the callback to the 'editing-canceled' signal for the CellRenderer.

The returned value represents the connection, and may be passed to DisconnectEditingCanceled to remove it.
*/
func (recv *CellRenderer) ConnectEditingCanceled(callback CellRendererSignalEditingCanceledCallback) int {
	signalCellRendererEditingCanceledLock.Lock()
	defer signalCellRendererEditingCanceledLock.Unlock()

	signalCellRendererEditingCanceledId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellRenderer_signal_connect_editing_canceled(instance, C.gpointer(uintptr(signalCellRendererEditingCanceledId)))

	detail := signalCellRendererEditingCanceledDetail{callback, handlerID}
	signalCellRendererEditingCanceledMap[signalCellRendererEditingCanceledId] = detail

	return signalCellRendererEditingCanceledId
}

/*
DisconnectEditingCanceled disconnects a callback from the 'editing-canceled' signal for the CellRenderer.

The connectionID should be a value returned from a call to ConnectEditingCanceled.
*/
func (recv *CellRenderer) DisconnectEditingCanceled(connectionID int) {
	signalCellRendererEditingCanceledLock.Lock()
	defer signalCellRendererEditingCanceledLock.Unlock()

	detail, exists := signalCellRendererEditingCanceledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellRendererEditingCanceledMap, connectionID)
}

//export cellrenderer_editingCanceledHandler
func cellrenderer_editingCanceledHandler(_ *C.GObject, data C.gpointer) {
	signalCellRendererEditingCanceledLock.RLock()
	defer signalCellRendererEditingCanceledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCellRendererEditingCanceledMap[index].callback
	callback()
}

type signalCellRendererEditingStartedDetail struct {
	callback  CellRendererSignalEditingStartedCallback
	handlerID C.gulong
}

var signalCellRendererEditingStartedId int
var signalCellRendererEditingStartedMap = make(map[int]signalCellRendererEditingStartedDetail)
var signalCellRendererEditingStartedLock sync.RWMutex

// CellRendererSignalEditingStartedCallback is a callback function for a 'editing-started' signal emitted from a CellRenderer.
type CellRendererSignalEditingStartedCallback func(editable *CellEditable, path string)

/*
ConnectEditingStarted connects the callback to the 'editing-started' signal for the CellRenderer.

The returned value represents the connection, and may be passed to DisconnectEditingStarted to remove it.
*/
func (recv *CellRenderer) ConnectEditingStarted(callback CellRendererSignalEditingStartedCallback) int {
	signalCellRendererEditingStartedLock.Lock()
	defer signalCellRendererEditingStartedLock.Unlock()

	signalCellRendererEditingStartedId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellRenderer_signal_connect_editing_started(instance, C.gpointer(uintptr(signalCellRendererEditingStartedId)))

	detail := signalCellRendererEditingStartedDetail{callback, handlerID}
	signalCellRendererEditingStartedMap[signalCellRendererEditingStartedId] = detail

	return signalCellRendererEditingStartedId
}

/*
DisconnectEditingStarted disconnects a callback from the 'editing-started' signal for the CellRenderer.

The connectionID should be a value returned from a call to ConnectEditingStarted.
*/
func (recv *CellRenderer) DisconnectEditingStarted(connectionID int) {
	signalCellRendererEditingStartedLock.Lock()
	defer signalCellRendererEditingStartedLock.Unlock()

	detail, exists := signalCellRendererEditingStartedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellRendererEditingStartedMap, connectionID)
}

//export cellrenderer_editingStartedHandler
func cellrenderer_editingStartedHandler(_ *C.GObject, c_editable *C.GtkCellEditable, c_path *C.gchar, data C.gpointer) {
	signalCellRendererEditingStartedLock.RLock()
	defer signalCellRendererEditingStartedLock.RUnlock()

	editable := CellEditableNewFromC(unsafe.Pointer(c_editable))

	path := C.GoString(c_path)

	index := int(uintptr(data))
	callback := signalCellRendererEditingStartedMap[index].callback
	callback(editable, path)
}

// Activate is a wrapper around the C function gtk_cell_renderer_activate.
func (recv *CellRenderer) Activate(event *gdk.Event, widget *Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_background_area := (*C.GdkRectangle)(C.NULL)
	if backgroundArea != nil {
		c_background_area = (*C.GdkRectangle)(backgroundArea.ToC())
	}

	c_cell_area := (*C.GdkRectangle)(C.NULL)
	if cellArea != nil {
		c_cell_area = (*C.GdkRectangle)(cellArea.ToC())
	}

	c_flags := (C.GtkCellRendererState)(flags)

	retC := C.gtk_cell_renderer_activate((*C.GtkCellRenderer)(recv.native), c_event, c_widget, c_path, c_background_area, c_cell_area, c_flags)
	retGo := retC == C.TRUE

	return retGo
}

// GetFixedSize is a wrapper around the C function gtk_cell_renderer_get_fixed_size.
func (recv *CellRenderer) GetFixedSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_cell_renderer_get_fixed_size((*C.GtkCellRenderer)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// GetSize is a wrapper around the C function gtk_cell_renderer_get_size.
func (recv *CellRenderer) GetSize(widget *Widget, cellArea *gdk.Rectangle) (int32, int32, int32, int32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_cell_area := (*C.GdkRectangle)(C.NULL)
	if cellArea != nil {
		c_cell_area = (*C.GdkRectangle)(cellArea.ToC())
	}

	var c_x_offset C.gint

	var c_y_offset C.gint

	var c_width C.gint

	var c_height C.gint

	C.gtk_cell_renderer_get_size((*C.GtkCellRenderer)(recv.native), c_widget, c_cell_area, &c_x_offset, &c_y_offset, &c_width, &c_height)

	xOffset := (int32)(c_x_offset)

	yOffset := (int32)(c_y_offset)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return xOffset, yOffset, width, height
}

// Render is a wrapper around the C function gtk_cell_renderer_render.
func (recv *CellRenderer) Render(cr *cairo.Context, widget *Widget, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) {
	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_background_area := (*C.GdkRectangle)(C.NULL)
	if backgroundArea != nil {
		c_background_area = (*C.GdkRectangle)(backgroundArea.ToC())
	}

	c_cell_area := (*C.GdkRectangle)(C.NULL)
	if cellArea != nil {
		c_cell_area = (*C.GdkRectangle)(cellArea.ToC())
	}

	c_flags := (C.GtkCellRendererState)(flags)

	C.gtk_cell_renderer_render((*C.GtkCellRenderer)(recv.native), c_cr, c_widget, c_background_area, c_cell_area, c_flags)

	return
}

// SetFixedSize is a wrapper around the C function gtk_cell_renderer_set_fixed_size.
func (recv *CellRenderer) SetFixedSize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_cell_renderer_set_fixed_size((*C.GtkCellRenderer)(recv.native), c_width, c_height)

	return
}

// StartEditing is a wrapper around the C function gtk_cell_renderer_start_editing.
func (recv *CellRenderer) StartEditing(event *gdk.Event, widget *Widget, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) *CellEditable {
	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_background_area := (*C.GdkRectangle)(C.NULL)
	if backgroundArea != nil {
		c_background_area = (*C.GdkRectangle)(backgroundArea.ToC())
	}

	c_cell_area := (*C.GdkRectangle)(C.NULL)
	if cellArea != nil {
		c_cell_area = (*C.GdkRectangle)(cellArea.ToC())
	}

	c_flags := (C.GtkCellRendererState)(flags)

	retC := C.gtk_cell_renderer_start_editing((*C.GtkCellRenderer)(recv.native), c_event, c_widget, c_path, c_background_area, c_cell_area, c_flags)
	var retGo (*CellEditable)
	if retC == nil {
		retGo = nil
	} else {
		retGo = CellEditableNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// StopEditing is a wrapper around the C function gtk_cell_renderer_stop_editing.
func (recv *CellRenderer) StopEditing(canceled bool) {
	c_canceled :=
		boolToGboolean(canceled)

	C.gtk_cell_renderer_stop_editing((*C.GtkCellRenderer)(recv.native), c_canceled)

	return
}

// CellRendererAccel is a wrapper around the C record GtkCellRendererAccel.
type CellRendererAccel struct {
	native *C.GtkCellRendererAccel
	// parent : record
	// Private : priv
}

func CellRendererAccelNewFromC(u unsafe.Pointer) *CellRendererAccel {
	c := (*C.GtkCellRendererAccel)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererAccel{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererAccel) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererAccel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererAccel with another CellRendererAccel, and returns true if they represent the same GObject.
func (recv *CellRendererAccel) Equals(other *CellRendererAccel) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererAccel) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererAccel) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererAccel) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererAccel) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererAccel.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererAccel.
func CastToCellRendererAccel(object *gobject.Object) *CellRendererAccel {
	return CellRendererAccelNewFromC(object.ToC())
}

type signalCellRendererAccelAccelClearedDetail struct {
	callback  CellRendererAccelSignalAccelClearedCallback
	handlerID C.gulong
}

var signalCellRendererAccelAccelClearedId int
var signalCellRendererAccelAccelClearedMap = make(map[int]signalCellRendererAccelAccelClearedDetail)
var signalCellRendererAccelAccelClearedLock sync.RWMutex

// CellRendererAccelSignalAccelClearedCallback is a callback function for a 'accel-cleared' signal emitted from a CellRendererAccel.
type CellRendererAccelSignalAccelClearedCallback func(pathString string)

/*
ConnectAccelCleared connects the callback to the 'accel-cleared' signal for the CellRendererAccel.

The returned value represents the connection, and may be passed to DisconnectAccelCleared to remove it.
*/
func (recv *CellRendererAccel) ConnectAccelCleared(callback CellRendererAccelSignalAccelClearedCallback) int {
	signalCellRendererAccelAccelClearedLock.Lock()
	defer signalCellRendererAccelAccelClearedLock.Unlock()

	signalCellRendererAccelAccelClearedId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellRendererAccel_signal_connect_accel_cleared(instance, C.gpointer(uintptr(signalCellRendererAccelAccelClearedId)))

	detail := signalCellRendererAccelAccelClearedDetail{callback, handlerID}
	signalCellRendererAccelAccelClearedMap[signalCellRendererAccelAccelClearedId] = detail

	return signalCellRendererAccelAccelClearedId
}

/*
DisconnectAccelCleared disconnects a callback from the 'accel-cleared' signal for the CellRendererAccel.

The connectionID should be a value returned from a call to ConnectAccelCleared.
*/
func (recv *CellRendererAccel) DisconnectAccelCleared(connectionID int) {
	signalCellRendererAccelAccelClearedLock.Lock()
	defer signalCellRendererAccelAccelClearedLock.Unlock()

	detail, exists := signalCellRendererAccelAccelClearedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellRendererAccelAccelClearedMap, connectionID)
}

//export cellrendereraccel_accelClearedHandler
func cellrendereraccel_accelClearedHandler(_ *C.GObject, c_path_string *C.gchar, data C.gpointer) {
	signalCellRendererAccelAccelClearedLock.RLock()
	defer signalCellRendererAccelAccelClearedLock.RUnlock()

	pathString := C.GoString(c_path_string)

	index := int(uintptr(data))
	callback := signalCellRendererAccelAccelClearedMap[index].callback
	callback(pathString)
}

type signalCellRendererAccelAccelEditedDetail struct {
	callback  CellRendererAccelSignalAccelEditedCallback
	handlerID C.gulong
}

var signalCellRendererAccelAccelEditedId int
var signalCellRendererAccelAccelEditedMap = make(map[int]signalCellRendererAccelAccelEditedDetail)
var signalCellRendererAccelAccelEditedLock sync.RWMutex

// CellRendererAccelSignalAccelEditedCallback is a callback function for a 'accel-edited' signal emitted from a CellRendererAccel.
type CellRendererAccelSignalAccelEditedCallback func(pathString string, accelKey uint32, accelMods gdk.ModifierType, hardwareKeycode uint32)

/*
ConnectAccelEdited connects the callback to the 'accel-edited' signal for the CellRendererAccel.

The returned value represents the connection, and may be passed to DisconnectAccelEdited to remove it.
*/
func (recv *CellRendererAccel) ConnectAccelEdited(callback CellRendererAccelSignalAccelEditedCallback) int {
	signalCellRendererAccelAccelEditedLock.Lock()
	defer signalCellRendererAccelAccelEditedLock.Unlock()

	signalCellRendererAccelAccelEditedId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellRendererAccel_signal_connect_accel_edited(instance, C.gpointer(uintptr(signalCellRendererAccelAccelEditedId)))

	detail := signalCellRendererAccelAccelEditedDetail{callback, handlerID}
	signalCellRendererAccelAccelEditedMap[signalCellRendererAccelAccelEditedId] = detail

	return signalCellRendererAccelAccelEditedId
}

/*
DisconnectAccelEdited disconnects a callback from the 'accel-edited' signal for the CellRendererAccel.

The connectionID should be a value returned from a call to ConnectAccelEdited.
*/
func (recv *CellRendererAccel) DisconnectAccelEdited(connectionID int) {
	signalCellRendererAccelAccelEditedLock.Lock()
	defer signalCellRendererAccelAccelEditedLock.Unlock()

	detail, exists := signalCellRendererAccelAccelEditedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellRendererAccelAccelEditedMap, connectionID)
}

//export cellrendereraccel_accelEditedHandler
func cellrendereraccel_accelEditedHandler(_ *C.GObject, c_path_string *C.gchar, c_accel_key C.guint, c_accel_mods C.guint, c_hardware_keycode C.guint, data C.gpointer) {
	signalCellRendererAccelAccelEditedLock.RLock()
	defer signalCellRendererAccelAccelEditedLock.RUnlock()

	pathString := C.GoString(c_path_string)

	accelKey := uint32(c_accel_key)

	accelMods := gdk.ModifierType(c_accel_mods)

	hardwareKeycode := uint32(c_hardware_keycode)

	index := int(uintptr(data))
	callback := signalCellRendererAccelAccelEditedMap[index].callback
	callback(pathString, accelKey, accelMods, hardwareKeycode)
}

// CellRendererAccelNew is a wrapper around the C function gtk_cell_renderer_accel_new.
func CellRendererAccelNew() *CellRendererAccel {
	retC := C.gtk_cell_renderer_accel_new()
	retGo := CellRendererAccelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellRendererCombo is a wrapper around the C record GtkCellRendererCombo.
type CellRendererCombo struct {
	native *C.GtkCellRendererCombo
	// parent : record
	// Private : priv
}

func CellRendererComboNewFromC(u unsafe.Pointer) *CellRendererCombo {
	c := (*C.GtkCellRendererCombo)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererCombo{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererCombo) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererCombo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererCombo with another CellRendererCombo, and returns true if they represent the same GObject.
func (recv *CellRendererCombo) Equals(other *CellRendererCombo) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererCombo) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererCombo) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererCombo) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererCombo) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererCombo.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererCombo.
func CastToCellRendererCombo(object *gobject.Object) *CellRendererCombo {
	return CellRendererComboNewFromC(object.ToC())
}

// CellRendererComboNew is a wrapper around the C function gtk_cell_renderer_combo_new.
func CellRendererComboNew() *CellRendererCombo {
	retC := C.gtk_cell_renderer_combo_new()
	retGo := CellRendererComboNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellRendererPixbuf is a wrapper around the C record GtkCellRendererPixbuf.
type CellRendererPixbuf struct {
	native *C.GtkCellRendererPixbuf
	// parent : record
	// Private : priv
}

func CellRendererPixbufNewFromC(u unsafe.Pointer) *CellRendererPixbuf {
	c := (*C.GtkCellRendererPixbuf)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererPixbuf{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererPixbuf) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererPixbuf) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererPixbuf with another CellRendererPixbuf, and returns true if they represent the same GObject.
func (recv *CellRendererPixbuf) Equals(other *CellRendererPixbuf) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererPixbuf) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererPixbuf) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererPixbuf) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererPixbuf.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererPixbuf.
func CastToCellRendererPixbuf(object *gobject.Object) *CellRendererPixbuf {
	return CellRendererPixbufNewFromC(object.ToC())
}

// CellRendererPixbufNew is a wrapper around the C function gtk_cell_renderer_pixbuf_new.
func CellRendererPixbufNew() *CellRendererPixbuf {
	retC := C.gtk_cell_renderer_pixbuf_new()
	retGo := CellRendererPixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellRendererProgress is a wrapper around the C record GtkCellRendererProgress.
type CellRendererProgress struct {
	native *C.GtkCellRendererProgress
	// parent_instance : record
	// Private : priv
}

func CellRendererProgressNewFromC(u unsafe.Pointer) *CellRendererProgress {
	c := (*C.GtkCellRendererProgress)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererProgress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererProgress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererProgress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererProgress with another CellRendererProgress, and returns true if they represent the same GObject.
func (recv *CellRendererProgress) Equals(other *CellRendererProgress) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererProgress) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererProgress) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererProgress) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererProgress.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererProgress.
func CastToCellRendererProgress(object *gobject.Object) *CellRendererProgress {
	return CellRendererProgressNewFromC(object.ToC())
}

// CellRendererProgressNew is a wrapper around the C function gtk_cell_renderer_progress_new.
func CellRendererProgressNew() *CellRendererProgress {
	retC := C.gtk_cell_renderer_progress_new()
	retGo := CellRendererProgressNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Orientable returns the Orientable interface implemented by CellRendererProgress
func (recv *CellRendererProgress) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CellRendererSpin is a wrapper around the C record GtkCellRendererSpin.
type CellRendererSpin struct {
	native *C.GtkCellRendererSpin
	// parent : record
	// Private : priv
}

func CellRendererSpinNewFromC(u unsafe.Pointer) *CellRendererSpin {
	c := (*C.GtkCellRendererSpin)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpin{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererSpin) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererSpin) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererSpin with another CellRendererSpin, and returns true if they represent the same GObject.
func (recv *CellRendererSpin) Equals(other *CellRendererSpin) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererText upcasts to *CellRendererText
func (recv *CellRendererSpin) CellRendererText() *CellRendererText {
	return CellRendererTextNewFromC(unsafe.Pointer(recv.native))
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererSpin) CellRenderer() *CellRenderer {
	return recv.CellRendererText().CellRenderer()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererSpin) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRendererText().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererSpin) Object() *gobject.Object {
	return recv.CellRendererText().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererSpin.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererSpin.
func CastToCellRendererSpin(object *gobject.Object) *CellRendererSpin {
	return CellRendererSpinNewFromC(object.ToC())
}

// CellRendererSpinNew is a wrapper around the C function gtk_cell_renderer_spin_new.
func CellRendererSpinNew() *CellRendererSpin {
	retC := C.gtk_cell_renderer_spin_new()
	retGo := CellRendererSpinNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellRendererSpinner is a wrapper around the C record GtkCellRendererSpinner.
type CellRendererSpinner struct {
	native *C.GtkCellRendererSpinner
	// parent : record
	// Private : priv
}

func CellRendererSpinnerNewFromC(u unsafe.Pointer) *CellRendererSpinner {
	c := (*C.GtkCellRendererSpinner)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpinner{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererSpinner) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererSpinner) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererSpinner with another CellRendererSpinner, and returns true if they represent the same GObject.
func (recv *CellRendererSpinner) Equals(other *CellRendererSpinner) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererSpinner) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererSpinner) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererSpinner) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererSpinner.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererSpinner.
func CastToCellRendererSpinner(object *gobject.Object) *CellRendererSpinner {
	return CellRendererSpinnerNewFromC(object.ToC())
}

// CellRendererText is a wrapper around the C record GtkCellRendererText.
type CellRendererText struct {
	native *C.GtkCellRendererText
	// parent : record
	// Private : priv
}

func CellRendererTextNewFromC(u unsafe.Pointer) *CellRendererText {
	c := (*C.GtkCellRendererText)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererText{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererText) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererText) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererText with another CellRendererText, and returns true if they represent the same GObject.
func (recv *CellRendererText) Equals(other *CellRendererText) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererText) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererText) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererText) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererText.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererText.
func CastToCellRendererText(object *gobject.Object) *CellRendererText {
	return CellRendererTextNewFromC(object.ToC())
}

type signalCellRendererTextEditedDetail struct {
	callback  CellRendererTextSignalEditedCallback
	handlerID C.gulong
}

var signalCellRendererTextEditedId int
var signalCellRendererTextEditedMap = make(map[int]signalCellRendererTextEditedDetail)
var signalCellRendererTextEditedLock sync.RWMutex

// CellRendererTextSignalEditedCallback is a callback function for a 'edited' signal emitted from a CellRendererText.
type CellRendererTextSignalEditedCallback func(path string, newText string)

/*
ConnectEdited connects the callback to the 'edited' signal for the CellRendererText.

The returned value represents the connection, and may be passed to DisconnectEdited to remove it.
*/
func (recv *CellRendererText) ConnectEdited(callback CellRendererTextSignalEditedCallback) int {
	signalCellRendererTextEditedLock.Lock()
	defer signalCellRendererTextEditedLock.Unlock()

	signalCellRendererTextEditedId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellRendererText_signal_connect_edited(instance, C.gpointer(uintptr(signalCellRendererTextEditedId)))

	detail := signalCellRendererTextEditedDetail{callback, handlerID}
	signalCellRendererTextEditedMap[signalCellRendererTextEditedId] = detail

	return signalCellRendererTextEditedId
}

/*
DisconnectEdited disconnects a callback from the 'edited' signal for the CellRendererText.

The connectionID should be a value returned from a call to ConnectEdited.
*/
func (recv *CellRendererText) DisconnectEdited(connectionID int) {
	signalCellRendererTextEditedLock.Lock()
	defer signalCellRendererTextEditedLock.Unlock()

	detail, exists := signalCellRendererTextEditedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellRendererTextEditedMap, connectionID)
}

//export cellrenderertext_editedHandler
func cellrenderertext_editedHandler(_ *C.GObject, c_path *C.gchar, c_new_text *C.gchar, data C.gpointer) {
	signalCellRendererTextEditedLock.RLock()
	defer signalCellRendererTextEditedLock.RUnlock()

	path := C.GoString(c_path)

	newText := C.GoString(c_new_text)

	index := int(uintptr(data))
	callback := signalCellRendererTextEditedMap[index].callback
	callback(path, newText)
}

// CellRendererTextNew is a wrapper around the C function gtk_cell_renderer_text_new.
func CellRendererTextNew() *CellRendererText {
	retC := C.gtk_cell_renderer_text_new()
	retGo := CellRendererTextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetFixedHeightFromFont is a wrapper around the C function gtk_cell_renderer_text_set_fixed_height_from_font.
func (recv *CellRendererText) SetFixedHeightFromFont(numberOfRows int32) {
	c_number_of_rows := (C.gint)(numberOfRows)

	C.gtk_cell_renderer_text_set_fixed_height_from_font((*C.GtkCellRendererText)(recv.native), c_number_of_rows)

	return
}

// CellRendererToggle is a wrapper around the C record GtkCellRendererToggle.
type CellRendererToggle struct {
	native *C.GtkCellRendererToggle
	// parent : record
	// Private : priv
}

func CellRendererToggleNewFromC(u unsafe.Pointer) *CellRendererToggle {
	c := (*C.GtkCellRendererToggle)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererToggle{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellRendererToggle) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellRendererToggle) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererToggle with another CellRendererToggle, and returns true if they represent the same GObject.
func (recv *CellRendererToggle) Equals(other *CellRendererToggle) bool {
	return other.ToC() == recv.ToC()
}

// CellRenderer upcasts to *CellRenderer
func (recv *CellRendererToggle) CellRenderer() *CellRenderer {
	return CellRendererNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellRendererToggle) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CellRenderer().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellRendererToggle) Object() *gobject.Object {
	return recv.CellRenderer().Object()
}

// CastToWidget down casts any arbitrary Object to CellRendererToggle.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellRendererToggle.
func CastToCellRendererToggle(object *gobject.Object) *CellRendererToggle {
	return CellRendererToggleNewFromC(object.ToC())
}

type signalCellRendererToggleToggledDetail struct {
	callback  CellRendererToggleSignalToggledCallback
	handlerID C.gulong
}

var signalCellRendererToggleToggledId int
var signalCellRendererToggleToggledMap = make(map[int]signalCellRendererToggleToggledDetail)
var signalCellRendererToggleToggledLock sync.RWMutex

// CellRendererToggleSignalToggledCallback is a callback function for a 'toggled' signal emitted from a CellRendererToggle.
type CellRendererToggleSignalToggledCallback func(path string)

/*
ConnectToggled connects the callback to the 'toggled' signal for the CellRendererToggle.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *CellRendererToggle) ConnectToggled(callback CellRendererToggleSignalToggledCallback) int {
	signalCellRendererToggleToggledLock.Lock()
	defer signalCellRendererToggleToggledLock.Unlock()

	signalCellRendererToggleToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellRendererToggle_signal_connect_toggled(instance, C.gpointer(uintptr(signalCellRendererToggleToggledId)))

	detail := signalCellRendererToggleToggledDetail{callback, handlerID}
	signalCellRendererToggleToggledMap[signalCellRendererToggleToggledId] = detail

	return signalCellRendererToggleToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the CellRendererToggle.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *CellRendererToggle) DisconnectToggled(connectionID int) {
	signalCellRendererToggleToggledLock.Lock()
	defer signalCellRendererToggleToggledLock.Unlock()

	detail, exists := signalCellRendererToggleToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellRendererToggleToggledMap, connectionID)
}

//export cellrenderertoggle_toggledHandler
func cellrenderertoggle_toggledHandler(_ *C.GObject, c_path *C.gchar, data C.gpointer) {
	signalCellRendererToggleToggledLock.RLock()
	defer signalCellRendererToggleToggledLock.RUnlock()

	path := C.GoString(c_path)

	index := int(uintptr(data))
	callback := signalCellRendererToggleToggledMap[index].callback
	callback(path)
}

// CellRendererToggleNew is a wrapper around the C function gtk_cell_renderer_toggle_new.
func CellRendererToggleNew() *CellRendererToggle {
	retC := C.gtk_cell_renderer_toggle_new()
	retGo := CellRendererToggleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetActive is a wrapper around the C function gtk_cell_renderer_toggle_get_active.
func (recv *CellRendererToggle) GetActive() bool {
	retC := C.gtk_cell_renderer_toggle_get_active((*C.GtkCellRendererToggle)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetRadio is a wrapper around the C function gtk_cell_renderer_toggle_get_radio.
func (recv *CellRendererToggle) GetRadio() bool {
	retC := C.gtk_cell_renderer_toggle_get_radio((*C.GtkCellRendererToggle)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetActive is a wrapper around the C function gtk_cell_renderer_toggle_set_active.
func (recv *CellRendererToggle) SetActive(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_cell_renderer_toggle_set_active((*C.GtkCellRendererToggle)(recv.native), c_setting)

	return
}

// SetRadio is a wrapper around the C function gtk_cell_renderer_toggle_set_radio.
func (recv *CellRendererToggle) SetRadio(radio bool) {
	c_radio :=
		boolToGboolean(radio)

	C.gtk_cell_renderer_toggle_set_radio((*C.GtkCellRendererToggle)(recv.native), c_radio)

	return
}

// CellView is a wrapper around the C record GtkCellView.
type CellView struct {
	native *C.GtkCellView
	// parent_instance : record
	// Private : priv
}

func CellViewNewFromC(u unsafe.Pointer) *CellView {
	c := (*C.GtkCellView)(u)
	if c == nil {
		return nil
	}

	g := &CellView{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CellView) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CellView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellView with another CellView, and returns true if they represent the same GObject.
func (recv *CellView) Equals(other *CellView) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *CellView) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CellView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CellView) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to CellView.
// Exercise care, as this is a potentially dangerous function if the Object is not a CellView.
func CastToCellView(object *gobject.Object) *CellView {
	return CellViewNewFromC(object.ToC())
}

// CellViewNew is a wrapper around the C function gtk_cell_view_new.
func CellViewNew() *CellView {
	retC := C.gtk_cell_view_new()
	retGo := CellViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellViewNewWithContext is a wrapper around the C function gtk_cell_view_new_with_context.
func CellViewNewWithContext(area *CellArea, context *CellAreaContext) *CellView {
	c_area := (*C.GtkCellArea)(C.NULL)
	if area != nil {
		c_area = (*C.GtkCellArea)(area.ToC())
	}

	c_context := (*C.GtkCellAreaContext)(C.NULL)
	if context != nil {
		c_context = (*C.GtkCellAreaContext)(context.ToC())
	}

	retC := C.gtk_cell_view_new_with_context(c_area, c_context)
	retGo := CellViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellViewNewWithMarkup is a wrapper around the C function gtk_cell_view_new_with_markup.
func CellViewNewWithMarkup(markup string) *CellView {
	c_markup := C.CString(markup)
	defer C.free(unsafe.Pointer(c_markup))

	retC := C.gtk_cell_view_new_with_markup(c_markup)
	retGo := CellViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellViewNewWithPixbuf is a wrapper around the C function gtk_cell_view_new_with_pixbuf.
func CellViewNewWithPixbuf(pixbuf *gdkpixbuf.Pixbuf) *CellView {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	retC := C.gtk_cell_view_new_with_pixbuf(c_pixbuf)
	retGo := CellViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CellViewNewWithText is a wrapper around the C function gtk_cell_view_new_with_text.
func CellViewNewWithText(text string) *CellView {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	retC := C.gtk_cell_view_new_with_text(c_text)
	retGo := CellViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDisplayedRow is a wrapper around the C function gtk_cell_view_get_displayed_row.
func (recv *CellView) GetDisplayedRow() *TreePath {
	retC := C.gtk_cell_view_get_displayed_row((*C.GtkCellView)(recv.native))
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetSizeOfRow is a wrapper around the C function gtk_cell_view_get_size_of_row.
func (recv *CellView) GetSizeOfRow(path *TreePath) (bool, *Requisition) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	var c_requisition C.GtkRequisition

	retC := C.gtk_cell_view_get_size_of_row((*C.GtkCellView)(recv.native), c_path, &c_requisition)
	retGo := retC == C.TRUE

	requisition := RequisitionNewFromC(unsafe.Pointer(&c_requisition))

	return retGo, requisition
}

// SetBackgroundColor is a wrapper around the C function gtk_cell_view_set_background_color.
func (recv *CellView) SetBackgroundColor(color *gdk.Color) {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_cell_view_set_background_color((*C.GtkCellView)(recv.native), c_color)

	return
}

// SetDisplayedRow is a wrapper around the C function gtk_cell_view_set_displayed_row.
func (recv *CellView) SetDisplayedRow(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_cell_view_set_displayed_row((*C.GtkCellView)(recv.native), c_path)

	return
}

// SetModel is a wrapper around the C function gtk_cell_view_set_model.
func (recv *CellView) SetModel(model *TreeModel) {
	c_model := (*C.GtkTreeModel)(model.ToC())

	C.gtk_cell_view_set_model((*C.GtkCellView)(recv.native), c_model)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by CellView
func (recv *CellView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CellView
func (recv *CellView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by CellView
func (recv *CellView) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by CellView
func (recv *CellView) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// CheckButton is a wrapper around the C record GtkCheckButton.
type CheckButton struct {
	native *C.GtkCheckButton
	// toggle_button : record
}

func CheckButtonNewFromC(u unsafe.Pointer) *CheckButton {
	c := (*C.GtkCheckButton)(u)
	if c == nil {
		return nil
	}

	g := &CheckButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CheckButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CheckButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckButton with another CheckButton, and returns true if they represent the same GObject.
func (recv *CheckButton) Equals(other *CheckButton) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButton upcasts to *ToggleButton
func (recv *CheckButton) ToggleButton() *ToggleButton {
	return ToggleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *CheckButton) Button() *Button {
	return recv.ToggleButton().Button()
}

// Bin upcasts to *Bin
func (recv *CheckButton) Bin() *Bin {
	return recv.ToggleButton().Bin()
}

// Container upcasts to *Container
func (recv *CheckButton) Container() *Container {
	return recv.ToggleButton().Container()
}

// Widget upcasts to *Widget
func (recv *CheckButton) Widget() *Widget {
	return recv.ToggleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CheckButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CheckButton) Object() *gobject.Object {
	return recv.ToggleButton().Object()
}

// CastToWidget down casts any arbitrary Object to CheckButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckButton.
func CastToCheckButton(object *gobject.Object) *CheckButton {
	return CheckButtonNewFromC(object.ToC())
}

// CheckButtonNew is a wrapper around the C function gtk_check_button_new.
func CheckButtonNew() *CheckButton {
	retC := C.gtk_check_button_new()
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CheckButtonNewWithLabel is a wrapper around the C function gtk_check_button_new_with_label.
func CheckButtonNewWithLabel(label string) *CheckButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_button_new_with_label(c_label)
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CheckButtonNewWithMnemonic is a wrapper around the C function gtk_check_button_new_with_mnemonic.
func CheckButtonNewWithMnemonic(label string) *CheckButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_button_new_with_mnemonic(c_label)
	retGo := CheckButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by CheckButton
func (recv *CheckButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by CheckButton
func (recv *CheckButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by CheckButton
func (recv *CheckButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CheckButton
func (recv *CheckButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CheckMenuItem is a wrapper around the C record GtkCheckMenuItem.
type CheckMenuItem struct {
	native *C.GtkCheckMenuItem
	// menu_item : record
	// Private : priv
}

func CheckMenuItemNewFromC(u unsafe.Pointer) *CheckMenuItem {
	c := (*C.GtkCheckMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CheckMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CheckMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckMenuItem with another CheckMenuItem, and returns true if they represent the same GObject.
func (recv *CheckMenuItem) Equals(other *CheckMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// MenuItem upcasts to *MenuItem
func (recv *CheckMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *CheckMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *CheckMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *CheckMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *CheckMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *CheckMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to CheckMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckMenuItem.
func CastToCheckMenuItem(object *gobject.Object) *CheckMenuItem {
	return CheckMenuItemNewFromC(object.ToC())
}

type signalCheckMenuItemToggledDetail struct {
	callback  CheckMenuItemSignalToggledCallback
	handlerID C.gulong
}

var signalCheckMenuItemToggledId int
var signalCheckMenuItemToggledMap = make(map[int]signalCheckMenuItemToggledDetail)
var signalCheckMenuItemToggledLock sync.RWMutex

// CheckMenuItemSignalToggledCallback is a callback function for a 'toggled' signal emitted from a CheckMenuItem.
type CheckMenuItemSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the CheckMenuItem.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *CheckMenuItem) ConnectToggled(callback CheckMenuItemSignalToggledCallback) int {
	signalCheckMenuItemToggledLock.Lock()
	defer signalCheckMenuItemToggledLock.Unlock()

	signalCheckMenuItemToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.CheckMenuItem_signal_connect_toggled(instance, C.gpointer(uintptr(signalCheckMenuItemToggledId)))

	detail := signalCheckMenuItemToggledDetail{callback, handlerID}
	signalCheckMenuItemToggledMap[signalCheckMenuItemToggledId] = detail

	return signalCheckMenuItemToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the CheckMenuItem.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *CheckMenuItem) DisconnectToggled(connectionID int) {
	signalCheckMenuItemToggledLock.Lock()
	defer signalCheckMenuItemToggledLock.Unlock()

	detail, exists := signalCheckMenuItemToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCheckMenuItemToggledMap, connectionID)
}

//export checkmenuitem_toggledHandler
func checkmenuitem_toggledHandler(_ *C.GObject, data C.gpointer) {
	signalCheckMenuItemToggledLock.RLock()
	defer signalCheckMenuItemToggledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCheckMenuItemToggledMap[index].callback
	callback()
}

// CheckMenuItemNew is a wrapper around the C function gtk_check_menu_item_new.
func CheckMenuItemNew() *CheckMenuItem {
	retC := C.gtk_check_menu_item_new()
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CheckMenuItemNewWithLabel is a wrapper around the C function gtk_check_menu_item_new_with_label.
func CheckMenuItemNewWithLabel(label string) *CheckMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_menu_item_new_with_label(c_label)
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CheckMenuItemNewWithMnemonic is a wrapper around the C function gtk_check_menu_item_new_with_mnemonic.
func CheckMenuItemNewWithMnemonic(label string) *CheckMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_check_menu_item_new_with_mnemonic(c_label)
	retGo := CheckMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetActive is a wrapper around the C function gtk_check_menu_item_get_active.
func (recv *CheckMenuItem) GetActive() bool {
	retC := C.gtk_check_menu_item_get_active((*C.GtkCheckMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetDrawAsRadio is a wrapper around the C function gtk_check_menu_item_get_draw_as_radio.
func (recv *CheckMenuItem) GetDrawAsRadio() bool {
	retC := C.gtk_check_menu_item_get_draw_as_radio((*C.GtkCheckMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetInconsistent is a wrapper around the C function gtk_check_menu_item_get_inconsistent.
func (recv *CheckMenuItem) GetInconsistent() bool {
	retC := C.gtk_check_menu_item_get_inconsistent((*C.GtkCheckMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetActive is a wrapper around the C function gtk_check_menu_item_set_active.
func (recv *CheckMenuItem) SetActive(isActive bool) {
	c_is_active :=
		boolToGboolean(isActive)

	C.gtk_check_menu_item_set_active((*C.GtkCheckMenuItem)(recv.native), c_is_active)

	return
}

// SetDrawAsRadio is a wrapper around the C function gtk_check_menu_item_set_draw_as_radio.
func (recv *CheckMenuItem) SetDrawAsRadio(drawAsRadio bool) {
	c_draw_as_radio :=
		boolToGboolean(drawAsRadio)

	C.gtk_check_menu_item_set_draw_as_radio((*C.GtkCheckMenuItem)(recv.native), c_draw_as_radio)

	return
}

// SetInconsistent is a wrapper around the C function gtk_check_menu_item_set_inconsistent.
func (recv *CheckMenuItem) SetInconsistent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_check_menu_item_set_inconsistent((*C.GtkCheckMenuItem)(recv.native), c_setting)

	return
}

// Toggled is a wrapper around the C function gtk_check_menu_item_toggled.
func (recv *CheckMenuItem) Toggled() {
	C.gtk_check_menu_item_toggled((*C.GtkCheckMenuItem)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by CheckMenuItem
func (recv *CheckMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by CheckMenuItem
func (recv *CheckMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CheckMenuItemAccessible is a wrapper around the C record GtkCheckMenuItemAccessible.
type CheckMenuItemAccessible struct {
	native *C.GtkCheckMenuItemAccessible
	// parent : record
	// priv : record
}

func CheckMenuItemAccessibleNewFromC(u unsafe.Pointer) *CheckMenuItemAccessible {
	c := (*C.GtkCheckMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItemAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CheckMenuItemAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CheckMenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckMenuItemAccessible with another CheckMenuItemAccessible, and returns true if they represent the same GObject.
func (recv *CheckMenuItemAccessible) Equals(other *CheckMenuItemAccessible) bool {
	return other.ToC() == recv.ToC()
}

// MenuItemAccessible upcasts to *MenuItemAccessible
func (recv *CheckMenuItemAccessible) MenuItemAccessible() *MenuItemAccessible {
	return MenuItemAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *CheckMenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.MenuItemAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *CheckMenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.MenuItemAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *CheckMenuItemAccessible) Accessible() *Accessible {
	return recv.MenuItemAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *CheckMenuItemAccessible) Object() *atk.Object {
	return recv.MenuItemAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to CheckMenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a CheckMenuItemAccessible.
func CastToCheckMenuItemAccessible(object *gobject.Object) *CheckMenuItemAccessible {
	return CheckMenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by CheckMenuItemAccessible
func (recv *CheckMenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Clipboard is a wrapper around the C record GtkClipboard.
type Clipboard struct {
	native *C.GtkClipboard
}

func ClipboardNewFromC(u unsafe.Pointer) *Clipboard {
	c := (*C.GtkClipboard)(u)
	if c == nil {
		return nil
	}

	g := &Clipboard{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Clipboard) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Clipboard) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Clipboard with another Clipboard, and returns true if they represent the same GObject.
func (recv *Clipboard) Equals(other *Clipboard) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Clipboard) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Clipboard.
// Exercise care, as this is a potentially dangerous function if the Object is not a Clipboard.
func CastToClipboard(object *gobject.Object) *Clipboard {
	return ClipboardNewFromC(object.ToC())
}

type signalClipboardOwnerChangeDetail struct {
	callback  ClipboardSignalOwnerChangeCallback
	handlerID C.gulong
}

var signalClipboardOwnerChangeId int
var signalClipboardOwnerChangeMap = make(map[int]signalClipboardOwnerChangeDetail)
var signalClipboardOwnerChangeLock sync.RWMutex

// ClipboardSignalOwnerChangeCallback is a callback function for a 'owner-change' signal emitted from a Clipboard.
type ClipboardSignalOwnerChangeCallback func(event *gdk.EventOwnerChange)

/*
ConnectOwnerChange connects the callback to the 'owner-change' signal for the Clipboard.

The returned value represents the connection, and may be passed to DisconnectOwnerChange to remove it.
*/
func (recv *Clipboard) ConnectOwnerChange(callback ClipboardSignalOwnerChangeCallback) int {
	signalClipboardOwnerChangeLock.Lock()
	defer signalClipboardOwnerChangeLock.Unlock()

	signalClipboardOwnerChangeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Clipboard_signal_connect_owner_change(instance, C.gpointer(uintptr(signalClipboardOwnerChangeId)))

	detail := signalClipboardOwnerChangeDetail{callback, handlerID}
	signalClipboardOwnerChangeMap[signalClipboardOwnerChangeId] = detail

	return signalClipboardOwnerChangeId
}

/*
DisconnectOwnerChange disconnects a callback from the 'owner-change' signal for the Clipboard.

The connectionID should be a value returned from a call to ConnectOwnerChange.
*/
func (recv *Clipboard) DisconnectOwnerChange(connectionID int) {
	signalClipboardOwnerChangeLock.Lock()
	defer signalClipboardOwnerChangeLock.Unlock()

	detail, exists := signalClipboardOwnerChangeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalClipboardOwnerChangeMap, connectionID)
}

//export clipboard_ownerChangeHandler
func clipboard_ownerChangeHandler(_ *C.GObject, c_event *C.GdkEventOwnerChange, data C.gpointer) {
	signalClipboardOwnerChangeLock.RLock()
	defer signalClipboardOwnerChangeLock.RUnlock()

	event := gdk.EventOwnerChangeNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalClipboardOwnerChangeMap[index].callback
	callback(event)
}

// ClipboardGet is a wrapper around the C function gtk_clipboard_get.
func ClipboardGet(selection *gdk.Atom) *Clipboard {
	c_selection := (C.GdkAtom)(C.NULL)
	if selection != nil {
		c_selection = (C.GdkAtom)(selection.ToC())
	}

	retC := C.gtk_clipboard_get(c_selection)
	retGo := ClipboardNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ClipboardGetForDisplay is a wrapper around the C function gtk_clipboard_get_for_display.
func ClipboardGetForDisplay(display *gdk.Display, selection *gdk.Atom) *Clipboard {
	c_display := (*C.GdkDisplay)(C.NULL)
	if display != nil {
		c_display = (*C.GdkDisplay)(display.ToC())
	}

	c_selection := (C.GdkAtom)(C.NULL)
	if selection != nil {
		c_selection = (C.GdkAtom)(selection.ToC())
	}

	retC := C.gtk_clipboard_get_for_display(c_display, c_selection)
	retGo := ClipboardNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Clear is a wrapper around the C function gtk_clipboard_clear.
func (recv *Clipboard) Clear() {
	C.gtk_clipboard_clear((*C.GtkClipboard)(recv.native))

	return
}

// GetDisplay is a wrapper around the C function gtk_clipboard_get_display.
func (recv *Clipboard) GetDisplay() *gdk.Display {
	retC := C.gtk_clipboard_get_display((*C.GtkClipboard)(recv.native))
	retGo := gdk.DisplayNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetOwner is a wrapper around the C function gtk_clipboard_get_owner.
func (recv *Clipboard) GetOwner() *gobject.Object {
	retC := C.gtk_clipboard_get_owner((*C.GtkClipboard)(recv.native))
	var retGo (*gobject.Object)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gobject.ObjectNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_clipboard_request_contents : unsupported parameter callback : no type generator for ClipboardReceivedFunc (GtkClipboardReceivedFunc) for param callback

// Unsupported : gtk_clipboard_request_image : unsupported parameter callback : no type generator for ClipboardImageReceivedFunc (GtkClipboardImageReceivedFunc) for param callback

// Unsupported : gtk_clipboard_request_rich_text : unsupported parameter callback : no type generator for ClipboardRichTextReceivedFunc (GtkClipboardRichTextReceivedFunc) for param callback

// Unsupported : gtk_clipboard_request_targets : unsupported parameter callback : no type generator for ClipboardTargetsReceivedFunc (GtkClipboardTargetsReceivedFunc) for param callback

// Unsupported : gtk_clipboard_request_text : unsupported parameter callback : no type generator for ClipboardTextReceivedFunc (GtkClipboardTextReceivedFunc) for param callback

// Unsupported : gtk_clipboard_set_can_store : unsupported parameter targets :

// SetImage is a wrapper around the C function gtk_clipboard_set_image.
func (recv *Clipboard) SetImage(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_clipboard_set_image((*C.GtkClipboard)(recv.native), c_pixbuf)

	return
}

// SetText is a wrapper around the C function gtk_clipboard_set_text.
func (recv *Clipboard) SetText(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_clipboard_set_text((*C.GtkClipboard)(recv.native), c_text, c_len)

	return
}

// Unsupported : gtk_clipboard_set_with_data : unsupported parameter targets :

// Unsupported : gtk_clipboard_set_with_owner : unsupported parameter targets :

// Store is a wrapper around the C function gtk_clipboard_store.
func (recv *Clipboard) Store() {
	C.gtk_clipboard_store((*C.GtkClipboard)(recv.native))

	return
}

// WaitForContents is a wrapper around the C function gtk_clipboard_wait_for_contents.
func (recv *Clipboard) WaitForContents(target *gdk.Atom) *SelectionData {
	c_target := (C.GdkAtom)(C.NULL)
	if target != nil {
		c_target = (C.GdkAtom)(target.ToC())
	}

	retC := C.gtk_clipboard_wait_for_contents((*C.GtkClipboard)(recv.native), c_target)
	var retGo (*SelectionData)
	if retC == nil {
		retGo = nil
	} else {
		retGo = SelectionDataNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// WaitForImage is a wrapper around the C function gtk_clipboard_wait_for_image.
func (recv *Clipboard) WaitForImage() *gdkpixbuf.Pixbuf {
	retC := C.gtk_clipboard_wait_for_image((*C.GtkClipboard)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_clipboard_wait_for_rich_text : array return type :

// Unsupported : gtk_clipboard_wait_for_targets : unsupported parameter targets : output array param targets

// WaitForText is a wrapper around the C function gtk_clipboard_wait_for_text.
func (recv *Clipboard) WaitForText() string {
	retC := C.gtk_clipboard_wait_for_text((*C.GtkClipboard)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// WaitIsImageAvailable is a wrapper around the C function gtk_clipboard_wait_is_image_available.
func (recv *Clipboard) WaitIsImageAvailable() bool {
	retC := C.gtk_clipboard_wait_is_image_available((*C.GtkClipboard)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// WaitIsRichTextAvailable is a wrapper around the C function gtk_clipboard_wait_is_rich_text_available.
func (recv *Clipboard) WaitIsRichTextAvailable(buffer *TextBuffer) bool {
	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	retC := C.gtk_clipboard_wait_is_rich_text_available((*C.GtkClipboard)(recv.native), c_buffer)
	retGo := retC == C.TRUE

	return retGo
}

// WaitIsTargetAvailable is a wrapper around the C function gtk_clipboard_wait_is_target_available.
func (recv *Clipboard) WaitIsTargetAvailable(target *gdk.Atom) bool {
	c_target := (C.GdkAtom)(C.NULL)
	if target != nil {
		c_target = (C.GdkAtom)(target.ToC())
	}

	retC := C.gtk_clipboard_wait_is_target_available((*C.GtkClipboard)(recv.native), c_target)
	retGo := retC == C.TRUE

	return retGo
}

// WaitIsTextAvailable is a wrapper around the C function gtk_clipboard_wait_is_text_available.
func (recv *Clipboard) WaitIsTextAvailable() bool {
	retC := C.gtk_clipboard_wait_is_text_available((*C.GtkClipboard)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ColorButton is a wrapper around the C record GtkColorButton.
type ColorButton struct {
	native *C.GtkColorButton
	// button : record
	// Private : priv
}

func ColorButtonNewFromC(u unsafe.Pointer) *ColorButton {
	c := (*C.GtkColorButton)(u)
	if c == nil {
		return nil
	}

	g := &ColorButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorButton with another ColorButton, and returns true if they represent the same GObject.
func (recv *ColorButton) Equals(other *ColorButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *ColorButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ColorButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ColorButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ColorButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to ColorButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorButton.
func CastToColorButton(object *gobject.Object) *ColorButton {
	return ColorButtonNewFromC(object.ToC())
}

type signalColorButtonColorSetDetail struct {
	callback  ColorButtonSignalColorSetCallback
	handlerID C.gulong
}

var signalColorButtonColorSetId int
var signalColorButtonColorSetMap = make(map[int]signalColorButtonColorSetDetail)
var signalColorButtonColorSetLock sync.RWMutex

// ColorButtonSignalColorSetCallback is a callback function for a 'color-set' signal emitted from a ColorButton.
type ColorButtonSignalColorSetCallback func()

/*
ConnectColorSet connects the callback to the 'color-set' signal for the ColorButton.

The returned value represents the connection, and may be passed to DisconnectColorSet to remove it.
*/
func (recv *ColorButton) ConnectColorSet(callback ColorButtonSignalColorSetCallback) int {
	signalColorButtonColorSetLock.Lock()
	defer signalColorButtonColorSetLock.Unlock()

	signalColorButtonColorSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.ColorButton_signal_connect_color_set(instance, C.gpointer(uintptr(signalColorButtonColorSetId)))

	detail := signalColorButtonColorSetDetail{callback, handlerID}
	signalColorButtonColorSetMap[signalColorButtonColorSetId] = detail

	return signalColorButtonColorSetId
}

/*
DisconnectColorSet disconnects a callback from the 'color-set' signal for the ColorButton.

The connectionID should be a value returned from a call to ConnectColorSet.
*/
func (recv *ColorButton) DisconnectColorSet(connectionID int) {
	signalColorButtonColorSetLock.Lock()
	defer signalColorButtonColorSetLock.Unlock()

	detail, exists := signalColorButtonColorSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalColorButtonColorSetMap, connectionID)
}

//export colorbutton_colorSetHandler
func colorbutton_colorSetHandler(_ *C.GObject, data C.gpointer) {
	signalColorButtonColorSetLock.RLock()
	defer signalColorButtonColorSetLock.RUnlock()

	index := int(uintptr(data))
	callback := signalColorButtonColorSetMap[index].callback
	callback()
}

// ColorButtonNew is a wrapper around the C function gtk_color_button_new.
func ColorButtonNew() *ColorButton {
	retC := C.gtk_color_button_new()
	retGo := ColorButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ColorButtonNewWithColor is a wrapper around the C function gtk_color_button_new_with_color.
func ColorButtonNewWithColor(color *gdk.Color) *ColorButton {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	retC := C.gtk_color_button_new_with_color(c_color)
	retGo := ColorButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAlpha is a wrapper around the C function gtk_color_button_get_alpha.
func (recv *ColorButton) GetAlpha() uint16 {
	retC := C.gtk_color_button_get_alpha((*C.GtkColorButton)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// GetColor is a wrapper around the C function gtk_color_button_get_color.
func (recv *ColorButton) GetColor() *gdk.Color {
	var c_color C.GdkColor

	C.gtk_color_button_get_color((*C.GtkColorButton)(recv.native), &c_color)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return color
}

// GetTitle is a wrapper around the C function gtk_color_button_get_title.
func (recv *ColorButton) GetTitle() string {
	retC := C.gtk_color_button_get_title((*C.GtkColorButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUseAlpha is a wrapper around the C function gtk_color_button_get_use_alpha.
func (recv *ColorButton) GetUseAlpha() bool {
	retC := C.gtk_color_button_get_use_alpha((*C.GtkColorButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetAlpha is a wrapper around the C function gtk_color_button_set_alpha.
func (recv *ColorButton) SetAlpha(alpha uint16) {
	c_alpha := (C.guint16)(alpha)

	C.gtk_color_button_set_alpha((*C.GtkColorButton)(recv.native), c_alpha)

	return
}

// SetColor is a wrapper around the C function gtk_color_button_set_color.
func (recv *ColorButton) SetColor(color *gdk.Color) {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_color_button_set_color((*C.GtkColorButton)(recv.native), c_color)

	return
}

// SetTitle is a wrapper around the C function gtk_color_button_set_title.
func (recv *ColorButton) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_color_button_set_title((*C.GtkColorButton)(recv.native), c_title)

	return
}

// SetUseAlpha is a wrapper around the C function gtk_color_button_set_use_alpha.
func (recv *ColorButton) SetUseAlpha(useAlpha bool) {
	c_use_alpha :=
		boolToGboolean(useAlpha)

	C.gtk_color_button_set_use_alpha((*C.GtkColorButton)(recv.native), c_use_alpha)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorButton
func (recv *ColorButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ColorButton
func (recv *ColorButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ColorButton
func (recv *ColorButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorButton
func (recv *ColorButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorButton
func (recv *ColorButton) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// ColorChooserDialog is a wrapper around the C record GtkColorChooserDialog.
type ColorChooserDialog struct {
	native *C.GtkColorChooserDialog
	// parent_instance : record
	// Private : priv
}

func ColorChooserDialogNewFromC(u unsafe.Pointer) *ColorChooserDialog {
	c := (*C.GtkColorChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserDialog with another ColorChooserDialog, and returns true if they represent the same GObject.
func (recv *ColorChooserDialog) Equals(other *ColorChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *ColorChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *ColorChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *ColorChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *ColorChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *ColorChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to ColorChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorChooserDialog.
func CastToColorChooserDialog(object *gobject.Object) *ColorChooserDialog {
	return ColorChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorChooserDialog
func (recv *ColorChooserDialog) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// ColorChooserWidget is a wrapper around the C record GtkColorChooserWidget.
type ColorChooserWidget struct {
	native *C.GtkColorChooserWidget
	// parent_instance : record
	// Private : priv
}

func ColorChooserWidgetNewFromC(u unsafe.Pointer) *ColorChooserWidget {
	c := (*C.GtkColorChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserWidget with another ColorChooserWidget, and returns true if they represent the same GObject.
func (recv *ColorChooserWidget) Equals(other *ColorChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *ColorChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ColorChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ColorChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to ColorChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorChooserWidget.
func CastToColorChooserWidget(object *gobject.Object) *ColorChooserWidget {
	return ColorChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ColorChooser returns the ColorChooser interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) ColorChooser() *ColorChooser {
	return ColorChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ColorChooserWidget
func (recv *ColorChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ColorSelection is a wrapper around the C record GtkColorSelection.
type ColorSelection struct {
	native *C.GtkColorSelection
	// parent_instance : record
	// Private : private_data
}

func ColorSelectionNewFromC(u unsafe.Pointer) *ColorSelection {
	c := (*C.GtkColorSelection)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorSelection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorSelection with another ColorSelection, and returns true if they represent the same GObject.
func (recv *ColorSelection) Equals(other *ColorSelection) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *ColorSelection) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ColorSelection) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *ColorSelection) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorSelection) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorSelection) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to ColorSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorSelection.
func CastToColorSelection(object *gobject.Object) *ColorSelection {
	return ColorSelectionNewFromC(object.ToC())
}

type signalColorSelectionColorChangedDetail struct {
	callback  ColorSelectionSignalColorChangedCallback
	handlerID C.gulong
}

var signalColorSelectionColorChangedId int
var signalColorSelectionColorChangedMap = make(map[int]signalColorSelectionColorChangedDetail)
var signalColorSelectionColorChangedLock sync.RWMutex

// ColorSelectionSignalColorChangedCallback is a callback function for a 'color-changed' signal emitted from a ColorSelection.
type ColorSelectionSignalColorChangedCallback func()

/*
ConnectColorChanged connects the callback to the 'color-changed' signal for the ColorSelection.

The returned value represents the connection, and may be passed to DisconnectColorChanged to remove it.
*/
func (recv *ColorSelection) ConnectColorChanged(callback ColorSelectionSignalColorChangedCallback) int {
	signalColorSelectionColorChangedLock.Lock()
	defer signalColorSelectionColorChangedLock.Unlock()

	signalColorSelectionColorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ColorSelection_signal_connect_color_changed(instance, C.gpointer(uintptr(signalColorSelectionColorChangedId)))

	detail := signalColorSelectionColorChangedDetail{callback, handlerID}
	signalColorSelectionColorChangedMap[signalColorSelectionColorChangedId] = detail

	return signalColorSelectionColorChangedId
}

/*
DisconnectColorChanged disconnects a callback from the 'color-changed' signal for the ColorSelection.

The connectionID should be a value returned from a call to ConnectColorChanged.
*/
func (recv *ColorSelection) DisconnectColorChanged(connectionID int) {
	signalColorSelectionColorChangedLock.Lock()
	defer signalColorSelectionColorChangedLock.Unlock()

	detail, exists := signalColorSelectionColorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalColorSelectionColorChangedMap, connectionID)
}

//export colorselection_colorChangedHandler
func colorselection_colorChangedHandler(_ *C.GObject, data C.gpointer) {
	signalColorSelectionColorChangedLock.RLock()
	defer signalColorSelectionColorChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalColorSelectionColorChangedMap[index].callback
	callback()
}

// ColorSelectionNew is a wrapper around the C function gtk_color_selection_new.
func ColorSelectionNew() *ColorSelection {
	retC := C.gtk_color_selection_new()
	retGo := ColorSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// gtk_color_selection_palette_from_string : unsupported parameter colors : output array param colors
// gtk_color_selection_palette_to_string : unsupported parameter colors :
// gtk_color_selection_set_change_palette_with_screen_hook : unsupported parameter func : no type generator for ColorSelectionChangePaletteWithScreenFunc (GtkColorSelectionChangePaletteWithScreenFunc) for param func
// GetCurrentAlpha is a wrapper around the C function gtk_color_selection_get_current_alpha.
func (recv *ColorSelection) GetCurrentAlpha() uint16 {
	retC := C.gtk_color_selection_get_current_alpha((*C.GtkColorSelection)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// GetCurrentColor is a wrapper around the C function gtk_color_selection_get_current_color.
func (recv *ColorSelection) GetCurrentColor() *gdk.Color {
	var c_color C.GdkColor

	C.gtk_color_selection_get_current_color((*C.GtkColorSelection)(recv.native), &c_color)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return color
}

// GetHasOpacityControl is a wrapper around the C function gtk_color_selection_get_has_opacity_control.
func (recv *ColorSelection) GetHasOpacityControl() bool {
	retC := C.gtk_color_selection_get_has_opacity_control((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetHasPalette is a wrapper around the C function gtk_color_selection_get_has_palette.
func (recv *ColorSelection) GetHasPalette() bool {
	retC := C.gtk_color_selection_get_has_palette((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPreviousAlpha is a wrapper around the C function gtk_color_selection_get_previous_alpha.
func (recv *ColorSelection) GetPreviousAlpha() uint16 {
	retC := C.gtk_color_selection_get_previous_alpha((*C.GtkColorSelection)(recv.native))
	retGo := (uint16)(retC)

	return retGo
}

// GetPreviousColor is a wrapper around the C function gtk_color_selection_get_previous_color.
func (recv *ColorSelection) GetPreviousColor() *gdk.Color {
	var c_color C.GdkColor

	C.gtk_color_selection_get_previous_color((*C.GtkColorSelection)(recv.native), &c_color)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return color
}

// IsAdjusting is a wrapper around the C function gtk_color_selection_is_adjusting.
func (recv *ColorSelection) IsAdjusting() bool {
	retC := C.gtk_color_selection_is_adjusting((*C.GtkColorSelection)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetCurrentAlpha is a wrapper around the C function gtk_color_selection_set_current_alpha.
func (recv *ColorSelection) SetCurrentAlpha(alpha uint16) {
	c_alpha := (C.guint16)(alpha)

	C.gtk_color_selection_set_current_alpha((*C.GtkColorSelection)(recv.native), c_alpha)

	return
}

// SetCurrentColor is a wrapper around the C function gtk_color_selection_set_current_color.
func (recv *ColorSelection) SetCurrentColor(color *gdk.Color) {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_color_selection_set_current_color((*C.GtkColorSelection)(recv.native), c_color)

	return
}

// SetHasOpacityControl is a wrapper around the C function gtk_color_selection_set_has_opacity_control.
func (recv *ColorSelection) SetHasOpacityControl(hasOpacity bool) {
	c_has_opacity :=
		boolToGboolean(hasOpacity)

	C.gtk_color_selection_set_has_opacity_control((*C.GtkColorSelection)(recv.native), c_has_opacity)

	return
}

// SetHasPalette is a wrapper around the C function gtk_color_selection_set_has_palette.
func (recv *ColorSelection) SetHasPalette(hasPalette bool) {
	c_has_palette :=
		boolToGboolean(hasPalette)

	C.gtk_color_selection_set_has_palette((*C.GtkColorSelection)(recv.native), c_has_palette)

	return
}

// SetPreviousAlpha is a wrapper around the C function gtk_color_selection_set_previous_alpha.
func (recv *ColorSelection) SetPreviousAlpha(alpha uint16) {
	c_alpha := (C.guint16)(alpha)

	C.gtk_color_selection_set_previous_alpha((*C.GtkColorSelection)(recv.native), c_alpha)

	return
}

// SetPreviousColor is a wrapper around the C function gtk_color_selection_set_previous_color.
func (recv *ColorSelection) SetPreviousColor(color *gdk.Color) {
	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_color_selection_set_previous_color((*C.GtkColorSelection)(recv.native), c_color)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorSelection
func (recv *ColorSelection) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorSelection
func (recv *ColorSelection) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ColorSelection
func (recv *ColorSelection) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ColorSelectionDialog is a wrapper around the C record GtkColorSelectionDialog.
type ColorSelectionDialog struct {
	native *C.GtkColorSelectionDialog
	// parent_instance : record
	// Private : priv
}

func ColorSelectionDialogNewFromC(u unsafe.Pointer) *ColorSelectionDialog {
	c := (*C.GtkColorSelectionDialog)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelectionDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ColorSelectionDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ColorSelectionDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorSelectionDialog with another ColorSelectionDialog, and returns true if they represent the same GObject.
func (recv *ColorSelectionDialog) Equals(other *ColorSelectionDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *ColorSelectionDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *ColorSelectionDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *ColorSelectionDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *ColorSelectionDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *ColorSelectionDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ColorSelectionDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ColorSelectionDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to ColorSelectionDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a ColorSelectionDialog.
func CastToColorSelectionDialog(object *gobject.Object) *ColorSelectionDialog {
	return ColorSelectionDialogNewFromC(object.ToC())
}

// ColorSelectionDialogNew is a wrapper around the C function gtk_color_selection_dialog_new.
func ColorSelectionDialogNew(title string) *ColorSelectionDialog {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	retC := C.gtk_color_selection_dialog_new(c_title)
	retGo := ColorSelectionDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by ColorSelectionDialog
func (recv *ColorSelectionDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ColorSelectionDialog
func (recv *ColorSelectionDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ComboBox is a wrapper around the C record GtkComboBox.
type ComboBox struct {
	native *C.GtkComboBox
	// parent_instance : record
	// Private : priv
}

func ComboBoxNewFromC(u unsafe.Pointer) *ComboBox {
	c := (*C.GtkComboBox)(u)
	if c == nil {
		return nil
	}

	g := &ComboBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ComboBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ComboBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBox with another ComboBox, and returns true if they represent the same GObject.
func (recv *ComboBox) Equals(other *ComboBox) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ComboBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ComboBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ComboBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ComboBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ComboBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ComboBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBox.
func CastToComboBox(object *gobject.Object) *ComboBox {
	return ComboBoxNewFromC(object.ToC())
}

type signalComboBoxChangedDetail struct {
	callback  ComboBoxSignalChangedCallback
	handlerID C.gulong
}

var signalComboBoxChangedId int
var signalComboBoxChangedMap = make(map[int]signalComboBoxChangedDetail)
var signalComboBoxChangedLock sync.RWMutex

// ComboBoxSignalChangedCallback is a callback function for a 'changed' signal emitted from a ComboBox.
type ComboBoxSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the ComboBox.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *ComboBox) ConnectChanged(callback ComboBoxSignalChangedCallback) int {
	signalComboBoxChangedLock.Lock()
	defer signalComboBoxChangedLock.Unlock()

	signalComboBoxChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ComboBox_signal_connect_changed(instance, C.gpointer(uintptr(signalComboBoxChangedId)))

	detail := signalComboBoxChangedDetail{callback, handlerID}
	signalComboBoxChangedMap[signalComboBoxChangedId] = detail

	return signalComboBoxChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the ComboBox.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *ComboBox) DisconnectChanged(connectionID int) {
	signalComboBoxChangedLock.Lock()
	defer signalComboBoxChangedLock.Unlock()

	detail, exists := signalComboBoxChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalComboBoxChangedMap, connectionID)
}

//export combobox_changedHandler
func combobox_changedHandler(_ *C.GObject, data C.gpointer) {
	signalComboBoxChangedLock.RLock()
	defer signalComboBoxChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalComboBoxChangedMap[index].callback
	callback()
}

// Unsupported signal 'format-entry-text' for ComboBox : return value utf8 :

type signalComboBoxMoveActiveDetail struct {
	callback  ComboBoxSignalMoveActiveCallback
	handlerID C.gulong
}

var signalComboBoxMoveActiveId int
var signalComboBoxMoveActiveMap = make(map[int]signalComboBoxMoveActiveDetail)
var signalComboBoxMoveActiveLock sync.RWMutex

// ComboBoxSignalMoveActiveCallback is a callback function for a 'move-active' signal emitted from a ComboBox.
type ComboBoxSignalMoveActiveCallback func(scrollType ScrollType)

/*
ConnectMoveActive connects the callback to the 'move-active' signal for the ComboBox.

The returned value represents the connection, and may be passed to DisconnectMoveActive to remove it.
*/
func (recv *ComboBox) ConnectMoveActive(callback ComboBoxSignalMoveActiveCallback) int {
	signalComboBoxMoveActiveLock.Lock()
	defer signalComboBoxMoveActiveLock.Unlock()

	signalComboBoxMoveActiveId++
	instance := C.gpointer(recv.native)
	handlerID := C.ComboBox_signal_connect_move_active(instance, C.gpointer(uintptr(signalComboBoxMoveActiveId)))

	detail := signalComboBoxMoveActiveDetail{callback, handlerID}
	signalComboBoxMoveActiveMap[signalComboBoxMoveActiveId] = detail

	return signalComboBoxMoveActiveId
}

/*
DisconnectMoveActive disconnects a callback from the 'move-active' signal for the ComboBox.

The connectionID should be a value returned from a call to ConnectMoveActive.
*/
func (recv *ComboBox) DisconnectMoveActive(connectionID int) {
	signalComboBoxMoveActiveLock.Lock()
	defer signalComboBoxMoveActiveLock.Unlock()

	detail, exists := signalComboBoxMoveActiveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalComboBoxMoveActiveMap, connectionID)
}

//export combobox_moveActiveHandler
func combobox_moveActiveHandler(_ *C.GObject, c_scroll_type C.GtkScrollType, data C.gpointer) {
	signalComboBoxMoveActiveLock.RLock()
	defer signalComboBoxMoveActiveLock.RUnlock()

	scrollType := ScrollType(c_scroll_type)

	index := int(uintptr(data))
	callback := signalComboBoxMoveActiveMap[index].callback
	callback(scrollType)
}

type signalComboBoxPopdownDetail struct {
	callback  ComboBoxSignalPopdownCallback
	handlerID C.gulong
}

var signalComboBoxPopdownId int
var signalComboBoxPopdownMap = make(map[int]signalComboBoxPopdownDetail)
var signalComboBoxPopdownLock sync.RWMutex

// ComboBoxSignalPopdownCallback is a callback function for a 'popdown' signal emitted from a ComboBox.
type ComboBoxSignalPopdownCallback func() bool

/*
ConnectPopdown connects the callback to the 'popdown' signal for the ComboBox.

The returned value represents the connection, and may be passed to DisconnectPopdown to remove it.
*/
func (recv *ComboBox) ConnectPopdown(callback ComboBoxSignalPopdownCallback) int {
	signalComboBoxPopdownLock.Lock()
	defer signalComboBoxPopdownLock.Unlock()

	signalComboBoxPopdownId++
	instance := C.gpointer(recv.native)
	handlerID := C.ComboBox_signal_connect_popdown(instance, C.gpointer(uintptr(signalComboBoxPopdownId)))

	detail := signalComboBoxPopdownDetail{callback, handlerID}
	signalComboBoxPopdownMap[signalComboBoxPopdownId] = detail

	return signalComboBoxPopdownId
}

/*
DisconnectPopdown disconnects a callback from the 'popdown' signal for the ComboBox.

The connectionID should be a value returned from a call to ConnectPopdown.
*/
func (recv *ComboBox) DisconnectPopdown(connectionID int) {
	signalComboBoxPopdownLock.Lock()
	defer signalComboBoxPopdownLock.Unlock()

	detail, exists := signalComboBoxPopdownMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalComboBoxPopdownMap, connectionID)
}

//export combobox_popdownHandler
func combobox_popdownHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalComboBoxPopdownLock.RLock()
	defer signalComboBoxPopdownLock.RUnlock()

	index := int(uintptr(data))
	callback := signalComboBoxPopdownMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalComboBoxPopupDetail struct {
	callback  ComboBoxSignalPopupCallback
	handlerID C.gulong
}

var signalComboBoxPopupId int
var signalComboBoxPopupMap = make(map[int]signalComboBoxPopupDetail)
var signalComboBoxPopupLock sync.RWMutex

// ComboBoxSignalPopupCallback is a callback function for a 'popup' signal emitted from a ComboBox.
type ComboBoxSignalPopupCallback func()

/*
ConnectPopup connects the callback to the 'popup' signal for the ComboBox.

The returned value represents the connection, and may be passed to DisconnectPopup to remove it.
*/
func (recv *ComboBox) ConnectPopup(callback ComboBoxSignalPopupCallback) int {
	signalComboBoxPopupLock.Lock()
	defer signalComboBoxPopupLock.Unlock()

	signalComboBoxPopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.ComboBox_signal_connect_popup(instance, C.gpointer(uintptr(signalComboBoxPopupId)))

	detail := signalComboBoxPopupDetail{callback, handlerID}
	signalComboBoxPopupMap[signalComboBoxPopupId] = detail

	return signalComboBoxPopupId
}

/*
DisconnectPopup disconnects a callback from the 'popup' signal for the ComboBox.

The connectionID should be a value returned from a call to ConnectPopup.
*/
func (recv *ComboBox) DisconnectPopup(connectionID int) {
	signalComboBoxPopupLock.Lock()
	defer signalComboBoxPopupLock.Unlock()

	detail, exists := signalComboBoxPopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalComboBoxPopupMap, connectionID)
}

//export combobox_popupHandler
func combobox_popupHandler(_ *C.GObject, data C.gpointer) {
	signalComboBoxPopupLock.RLock()
	defer signalComboBoxPopupLock.RUnlock()

	index := int(uintptr(data))
	callback := signalComboBoxPopupMap[index].callback
	callback()
}

// ComboBoxNew is a wrapper around the C function gtk_combo_box_new.
func ComboBoxNew() *ComboBox {
	retC := C.gtk_combo_box_new()
	retGo := ComboBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ComboBoxNewWithArea is a wrapper around the C function gtk_combo_box_new_with_area.
func ComboBoxNewWithArea(area *CellArea) *ComboBox {
	c_area := (*C.GtkCellArea)(C.NULL)
	if area != nil {
		c_area = (*C.GtkCellArea)(area.ToC())
	}

	retC := C.gtk_combo_box_new_with_area(c_area)
	retGo := ComboBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ComboBoxNewWithAreaAndEntry is a wrapper around the C function gtk_combo_box_new_with_area_and_entry.
func ComboBoxNewWithAreaAndEntry(area *CellArea) *ComboBox {
	c_area := (*C.GtkCellArea)(C.NULL)
	if area != nil {
		c_area = (*C.GtkCellArea)(area.ToC())
	}

	retC := C.gtk_combo_box_new_with_area_and_entry(c_area)
	retGo := ComboBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ComboBoxNewWithModel is a wrapper around the C function gtk_combo_box_new_with_model.
func ComboBoxNewWithModel(model *TreeModel) *ComboBox {
	c_model := (*C.GtkTreeModel)(model.ToC())

	retC := C.gtk_combo_box_new_with_model(c_model)
	retGo := ComboBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetActive is a wrapper around the C function gtk_combo_box_get_active.
func (recv *ComboBox) GetActive() int32 {
	retC := C.gtk_combo_box_get_active((*C.GtkComboBox)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetActiveIter is a wrapper around the C function gtk_combo_box_get_active_iter.
func (recv *ComboBox) GetActiveIter() (bool, *TreeIter) {
	var c_iter C.GtkTreeIter

	retC := C.gtk_combo_box_get_active_iter((*C.GtkComboBox)(recv.native), &c_iter)
	retGo := retC == C.TRUE

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, iter
}

// GetAddTearoffs is a wrapper around the C function gtk_combo_box_get_add_tearoffs.
func (recv *ComboBox) GetAddTearoffs() bool {
	retC := C.gtk_combo_box_get_add_tearoffs((*C.GtkComboBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetColumnSpanColumn is a wrapper around the C function gtk_combo_box_get_column_span_column.
func (recv *ComboBox) GetColumnSpanColumn() int32 {
	retC := C.gtk_combo_box_get_column_span_column((*C.GtkComboBox)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetFocusOnClick is a wrapper around the C function gtk_combo_box_get_focus_on_click.
func (recv *ComboBox) GetFocusOnClick() bool {
	retC := C.gtk_combo_box_get_focus_on_click((*C.GtkComboBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetModel is a wrapper around the C function gtk_combo_box_get_model.
func (recv *ComboBox) GetModel() *TreeModel {
	retC := C.gtk_combo_box_get_model((*C.GtkComboBox)(recv.native))
	retGo := TreeModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPopupAccessible is a wrapper around the C function gtk_combo_box_get_popup_accessible.
func (recv *ComboBox) GetPopupAccessible() *atk.Object {
	retC := C.gtk_combo_box_get_popup_accessible((*C.GtkComboBox)(recv.native))
	retGo := atk.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_combo_box_get_row_separator_func : no return generator

// GetRowSpanColumn is a wrapper around the C function gtk_combo_box_get_row_span_column.
func (recv *ComboBox) GetRowSpanColumn() int32 {
	retC := C.gtk_combo_box_get_row_span_column((*C.GtkComboBox)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetTitle is a wrapper around the C function gtk_combo_box_get_title.
func (recv *ComboBox) GetTitle() string {
	retC := C.gtk_combo_box_get_title((*C.GtkComboBox)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetWrapWidth is a wrapper around the C function gtk_combo_box_get_wrap_width.
func (recv *ComboBox) GetWrapWidth() int32 {
	retC := C.gtk_combo_box_get_wrap_width((*C.GtkComboBox)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Popdown is a wrapper around the C function gtk_combo_box_popdown.
func (recv *ComboBox) Popdown() {
	C.gtk_combo_box_popdown((*C.GtkComboBox)(recv.native))

	return
}

// Popup is a wrapper around the C function gtk_combo_box_popup.
func (recv *ComboBox) Popup() {
	C.gtk_combo_box_popup((*C.GtkComboBox)(recv.native))

	return
}

// SetActive is a wrapper around the C function gtk_combo_box_set_active.
func (recv *ComboBox) SetActive(index int32) {
	c_index_ := (C.gint)(index)

	C.gtk_combo_box_set_active((*C.GtkComboBox)(recv.native), c_index_)

	return
}

// SetActiveIter is a wrapper around the C function gtk_combo_box_set_active_iter.
func (recv *ComboBox) SetActiveIter(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_combo_box_set_active_iter((*C.GtkComboBox)(recv.native), c_iter)

	return
}

// SetAddTearoffs is a wrapper around the C function gtk_combo_box_set_add_tearoffs.
func (recv *ComboBox) SetAddTearoffs(addTearoffs bool) {
	c_add_tearoffs :=
		boolToGboolean(addTearoffs)

	C.gtk_combo_box_set_add_tearoffs((*C.GtkComboBox)(recv.native), c_add_tearoffs)

	return
}

// SetColumnSpanColumn is a wrapper around the C function gtk_combo_box_set_column_span_column.
func (recv *ComboBox) SetColumnSpanColumn(columnSpan int32) {
	c_column_span := (C.gint)(columnSpan)

	C.gtk_combo_box_set_column_span_column((*C.GtkComboBox)(recv.native), c_column_span)

	return
}

// SetFocusOnClick is a wrapper around the C function gtk_combo_box_set_focus_on_click.
func (recv *ComboBox) SetFocusOnClick(focusOnClick bool) {
	c_focus_on_click :=
		boolToGboolean(focusOnClick)

	C.gtk_combo_box_set_focus_on_click((*C.GtkComboBox)(recv.native), c_focus_on_click)

	return
}

// SetModel is a wrapper around the C function gtk_combo_box_set_model.
func (recv *ComboBox) SetModel(model *TreeModel) {
	c_model := (*C.GtkTreeModel)(model.ToC())

	C.gtk_combo_box_set_model((*C.GtkComboBox)(recv.native), c_model)

	return
}

// Unsupported : gtk_combo_box_set_row_separator_func : unsupported parameter func : no type generator for TreeViewRowSeparatorFunc (GtkTreeViewRowSeparatorFunc) for param func

// SetRowSpanColumn is a wrapper around the C function gtk_combo_box_set_row_span_column.
func (recv *ComboBox) SetRowSpanColumn(rowSpan int32) {
	c_row_span := (C.gint)(rowSpan)

	C.gtk_combo_box_set_row_span_column((*C.GtkComboBox)(recv.native), c_row_span)

	return
}

// SetTitle is a wrapper around the C function gtk_combo_box_set_title.
func (recv *ComboBox) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_combo_box_set_title((*C.GtkComboBox)(recv.native), c_title)

	return
}

// SetWrapWidth is a wrapper around the C function gtk_combo_box_set_wrap_width.
func (recv *ComboBox) SetWrapWidth(width int32) {
	c_width := (C.gint)(width)

	C.gtk_combo_box_set_wrap_width((*C.GtkComboBox)(recv.native), c_width)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ComboBox
func (recv *ComboBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ComboBox
func (recv *ComboBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by ComboBox
func (recv *ComboBox) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by ComboBox
func (recv *ComboBox) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// ComboBoxAccessible is a wrapper around the C record GtkComboBoxAccessible.
type ComboBoxAccessible struct {
	native *C.GtkComboBoxAccessible
	// parent : record
	// priv : record
}

func ComboBoxAccessibleNewFromC(u unsafe.Pointer) *ComboBoxAccessible {
	c := (*C.GtkComboBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ComboBoxAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ComboBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxAccessible with another ComboBoxAccessible, and returns true if they represent the same GObject.
func (recv *ComboBoxAccessible) Equals(other *ComboBoxAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ComboBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ComboBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ComboBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ComboBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ComboBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBoxAccessible.
func CastToComboBoxAccessible(object *gobject.Object) *ComboBoxAccessible {
	return ComboBoxAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by ComboBoxAccessible
func (recv *ComboBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// ComboBoxText is a wrapper around the C record GtkComboBoxText.
type ComboBoxText struct {
	native *C.GtkComboBoxText
	// Private : parent_instance
	// Private : priv
}

func ComboBoxTextNewFromC(u unsafe.Pointer) *ComboBoxText {
	c := (*C.GtkComboBoxText)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxText{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ComboBoxText) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ComboBoxText) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxText with another ComboBoxText, and returns true if they represent the same GObject.
func (recv *ComboBoxText) Equals(other *ComboBoxText) bool {
	return other.ToC() == recv.ToC()
}

// ComboBox upcasts to *ComboBox
func (recv *ComboBoxText) ComboBox() *ComboBox {
	return ComboBoxNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ComboBoxText) Bin() *Bin {
	return recv.ComboBox().Bin()
}

// Container upcasts to *Container
func (recv *ComboBoxText) Container() *Container {
	return recv.ComboBox().Container()
}

// Widget upcasts to *Widget
func (recv *ComboBoxText) Widget() *Widget {
	return recv.ComboBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ComboBoxText) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ComboBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ComboBoxText) Object() *gobject.Object {
	return recv.ComboBox().Object()
}

// CastToWidget down casts any arbitrary Object to ComboBoxText.
// Exercise care, as this is a potentially dangerous function if the Object is not a ComboBoxText.
func CastToComboBoxText(object *gobject.Object) *ComboBoxText {
	return ComboBoxTextNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ComboBoxText
func (recv *ComboBoxText) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ComboBoxText
func (recv *ComboBoxText) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by ComboBoxText
func (recv *ComboBoxText) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by ComboBoxText
func (recv *ComboBoxText) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Container is a wrapper around the C record GtkContainer.
type Container struct {
	native *C.GtkContainer
	// widget : record
	// Private : priv
}

func ContainerNewFromC(u unsafe.Pointer) *Container {
	c := (*C.GtkContainer)(u)
	if c == nil {
		return nil
	}

	g := &Container{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Container) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Container) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Container with another Container, and returns true if they represent the same GObject.
func (recv *Container) Equals(other *Container) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Container) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Container) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Container) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Container.
// Exercise care, as this is a potentially dangerous function if the Object is not a Container.
func CastToContainer(object *gobject.Object) *Container {
	return ContainerNewFromC(object.ToC())
}

type signalContainerAddDetail struct {
	callback  ContainerSignalAddCallback
	handlerID C.gulong
}

var signalContainerAddId int
var signalContainerAddMap = make(map[int]signalContainerAddDetail)
var signalContainerAddLock sync.RWMutex

// ContainerSignalAddCallback is a callback function for a 'add' signal emitted from a Container.
type ContainerSignalAddCallback func(object *Widget)

/*
ConnectAdd connects the callback to the 'add' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectAdd to remove it.
*/
func (recv *Container) ConnectAdd(callback ContainerSignalAddCallback) int {
	signalContainerAddLock.Lock()
	defer signalContainerAddLock.Unlock()

	signalContainerAddId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_add(instance, C.gpointer(uintptr(signalContainerAddId)))

	detail := signalContainerAddDetail{callback, handlerID}
	signalContainerAddMap[signalContainerAddId] = detail

	return signalContainerAddId
}

/*
DisconnectAdd disconnects a callback from the 'add' signal for the Container.

The connectionID should be a value returned from a call to ConnectAdd.
*/
func (recv *Container) DisconnectAdd(connectionID int) {
	signalContainerAddLock.Lock()
	defer signalContainerAddLock.Unlock()

	detail, exists := signalContainerAddMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerAddMap, connectionID)
}

//export container_addHandler
func container_addHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	signalContainerAddLock.RLock()
	defer signalContainerAddLock.RUnlock()

	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerAddMap[index].callback
	callback(object)
}

type signalContainerCheckResizeDetail struct {
	callback  ContainerSignalCheckResizeCallback
	handlerID C.gulong
}

var signalContainerCheckResizeId int
var signalContainerCheckResizeMap = make(map[int]signalContainerCheckResizeDetail)
var signalContainerCheckResizeLock sync.RWMutex

// ContainerSignalCheckResizeCallback is a callback function for a 'check-resize' signal emitted from a Container.
type ContainerSignalCheckResizeCallback func()

/*
ConnectCheckResize connects the callback to the 'check-resize' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectCheckResize to remove it.
*/
func (recv *Container) ConnectCheckResize(callback ContainerSignalCheckResizeCallback) int {
	signalContainerCheckResizeLock.Lock()
	defer signalContainerCheckResizeLock.Unlock()

	signalContainerCheckResizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_check_resize(instance, C.gpointer(uintptr(signalContainerCheckResizeId)))

	detail := signalContainerCheckResizeDetail{callback, handlerID}
	signalContainerCheckResizeMap[signalContainerCheckResizeId] = detail

	return signalContainerCheckResizeId
}

/*
DisconnectCheckResize disconnects a callback from the 'check-resize' signal for the Container.

The connectionID should be a value returned from a call to ConnectCheckResize.
*/
func (recv *Container) DisconnectCheckResize(connectionID int) {
	signalContainerCheckResizeLock.Lock()
	defer signalContainerCheckResizeLock.Unlock()

	detail, exists := signalContainerCheckResizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerCheckResizeMap, connectionID)
}

//export container_checkResizeHandler
func container_checkResizeHandler(_ *C.GObject, data C.gpointer) {
	signalContainerCheckResizeLock.RLock()
	defer signalContainerCheckResizeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalContainerCheckResizeMap[index].callback
	callback()
}

type signalContainerRemoveDetail struct {
	callback  ContainerSignalRemoveCallback
	handlerID C.gulong
}

var signalContainerRemoveId int
var signalContainerRemoveMap = make(map[int]signalContainerRemoveDetail)
var signalContainerRemoveLock sync.RWMutex

// ContainerSignalRemoveCallback is a callback function for a 'remove' signal emitted from a Container.
type ContainerSignalRemoveCallback func(object *Widget)

/*
ConnectRemove connects the callback to the 'remove' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectRemove to remove it.
*/
func (recv *Container) ConnectRemove(callback ContainerSignalRemoveCallback) int {
	signalContainerRemoveLock.Lock()
	defer signalContainerRemoveLock.Unlock()

	signalContainerRemoveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_remove(instance, C.gpointer(uintptr(signalContainerRemoveId)))

	detail := signalContainerRemoveDetail{callback, handlerID}
	signalContainerRemoveMap[signalContainerRemoveId] = detail

	return signalContainerRemoveId
}

/*
DisconnectRemove disconnects a callback from the 'remove' signal for the Container.

The connectionID should be a value returned from a call to ConnectRemove.
*/
func (recv *Container) DisconnectRemove(connectionID int) {
	signalContainerRemoveLock.Lock()
	defer signalContainerRemoveLock.Unlock()

	detail, exists := signalContainerRemoveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerRemoveMap, connectionID)
}

//export container_removeHandler
func container_removeHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	signalContainerRemoveLock.RLock()
	defer signalContainerRemoveLock.RUnlock()

	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerRemoveMap[index].callback
	callback(object)
}

type signalContainerSetFocusChildDetail struct {
	callback  ContainerSignalSetFocusChildCallback
	handlerID C.gulong
}

var signalContainerSetFocusChildId int
var signalContainerSetFocusChildMap = make(map[int]signalContainerSetFocusChildDetail)
var signalContainerSetFocusChildLock sync.RWMutex

// ContainerSignalSetFocusChildCallback is a callback function for a 'set-focus-child' signal emitted from a Container.
type ContainerSignalSetFocusChildCallback func(object *Widget)

/*
ConnectSetFocusChild connects the callback to the 'set-focus-child' signal for the Container.

The returned value represents the connection, and may be passed to DisconnectSetFocusChild to remove it.
*/
func (recv *Container) ConnectSetFocusChild(callback ContainerSignalSetFocusChildCallback) int {
	signalContainerSetFocusChildLock.Lock()
	defer signalContainerSetFocusChildLock.Unlock()

	signalContainerSetFocusChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.Container_signal_connect_set_focus_child(instance, C.gpointer(uintptr(signalContainerSetFocusChildId)))

	detail := signalContainerSetFocusChildDetail{callback, handlerID}
	signalContainerSetFocusChildMap[signalContainerSetFocusChildId] = detail

	return signalContainerSetFocusChildId
}

/*
DisconnectSetFocusChild disconnects a callback from the 'set-focus-child' signal for the Container.

The connectionID should be a value returned from a call to ConnectSetFocusChild.
*/
func (recv *Container) DisconnectSetFocusChild(connectionID int) {
	signalContainerSetFocusChildLock.Lock()
	defer signalContainerSetFocusChildLock.Unlock()

	detail, exists := signalContainerSetFocusChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalContainerSetFocusChildMap, connectionID)
}

//export container_setFocusChildHandler
func container_setFocusChildHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	signalContainerSetFocusChildLock.RLock()
	defer signalContainerSetFocusChildLock.RUnlock()

	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalContainerSetFocusChildMap[index].callback
	callback(object)
}

// Add is a wrapper around the C function gtk_container_add.
func (recv *Container) Add(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_container_add((*C.GtkContainer)(recv.native), c_widget)

	return
}

// Unsupported : gtk_container_add_with_properties : unsupported parameter ... : varargs

// CheckResize is a wrapper around the C function gtk_container_check_resize.
func (recv *Container) CheckResize() {
	C.gtk_container_check_resize((*C.GtkContainer)(recv.native))

	return
}

// Unsupported : gtk_container_child_get : unsupported parameter ... : varargs

// ChildGetProperty is a wrapper around the C function gtk_container_child_get_property.
func (recv *Container) ChildGetProperty(child *Widget, propertyName string, value *gobject.Value) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_container_child_get_property((*C.GtkContainer)(recv.native), c_child, c_property_name, c_value)

	return
}

// Unsupported : gtk_container_child_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// Unsupported : gtk_container_child_set : unsupported parameter ... : varargs

// ChildSetProperty is a wrapper around the C function gtk_container_child_set_property.
func (recv *Container) ChildSetProperty(child *Widget, propertyName string, value *gobject.Value) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_container_child_set_property((*C.GtkContainer)(recv.native), c_child, c_property_name, c_value)

	return
}

// Unsupported : gtk_container_child_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// ChildType is a wrapper around the C function gtk_container_child_type.
func (recv *Container) ChildType() gobject.Type {
	retC := C.gtk_container_child_type((*C.GtkContainer)(recv.native))
	retGo := (gobject.Type)(retC)

	return retGo
}

// Unsupported : gtk_container_forall : unsupported parameter callback : no type generator for Callback (GtkCallback) for param callback

// Unsupported : gtk_container_foreach : unsupported parameter callback : no type generator for Callback (GtkCallback) for param callback

// GetBorderWidth is a wrapper around the C function gtk_container_get_border_width.
func (recv *Container) GetBorderWidth() uint32 {
	retC := C.gtk_container_get_border_width((*C.GtkContainer)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetChildren is a wrapper around the C function gtk_container_get_children.
func (recv *Container) GetChildren() *glib.List {
	retC := C.gtk_container_get_children((*C.GtkContainer)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFocusChain is a wrapper around the C function gtk_container_get_focus_chain.
func (recv *Container) GetFocusChain() (bool, *glib.List) {
	var c_focusable_widgets *C.GList

	retC := C.gtk_container_get_focus_chain((*C.GtkContainer)(recv.native), &c_focusable_widgets)
	retGo := retC == C.TRUE

	focusableWidgets := glib.ListNewFromC(unsafe.Pointer(c_focusable_widgets))

	return retGo, focusableWidgets
}

// GetFocusHadjustment is a wrapper around the C function gtk_container_get_focus_hadjustment.
func (recv *Container) GetFocusHadjustment() *Adjustment {
	retC := C.gtk_container_get_focus_hadjustment((*C.GtkContainer)(recv.native))
	var retGo (*Adjustment)
	if retC == nil {
		retGo = nil
	} else {
		retGo = AdjustmentNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetFocusVadjustment is a wrapper around the C function gtk_container_get_focus_vadjustment.
func (recv *Container) GetFocusVadjustment() *Adjustment {
	retC := C.gtk_container_get_focus_vadjustment((*C.GtkContainer)(recv.native))
	var retGo (*Adjustment)
	if retC == nil {
		retGo = nil
	} else {
		retGo = AdjustmentNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPathForChild is a wrapper around the C function gtk_container_get_path_for_child.
func (recv *Container) GetPathForChild(child *Widget) *WidgetPath {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_container_get_path_for_child((*C.GtkContainer)(recv.native), c_child)
	retGo := WidgetPathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetResizeMode is a wrapper around the C function gtk_container_get_resize_mode.
func (recv *Container) GetResizeMode() ResizeMode {
	retC := C.gtk_container_get_resize_mode((*C.GtkContainer)(recv.native))
	retGo := (ResizeMode)(retC)

	return retGo
}

// PropagateDraw is a wrapper around the C function gtk_container_propagate_draw.
func (recv *Container) PropagateDraw(child *Widget, cr *cairo.Context) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	C.gtk_container_propagate_draw((*C.GtkContainer)(recv.native), c_child, c_cr)

	return
}

// Remove is a wrapper around the C function gtk_container_remove.
func (recv *Container) Remove(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_container_remove((*C.GtkContainer)(recv.native), c_widget)

	return
}

// ResizeChildren is a wrapper around the C function gtk_container_resize_children.
func (recv *Container) ResizeChildren() {
	C.gtk_container_resize_children((*C.GtkContainer)(recv.native))

	return
}

// SetBorderWidth is a wrapper around the C function gtk_container_set_border_width.
func (recv *Container) SetBorderWidth(borderWidth uint32) {
	c_border_width := (C.guint)(borderWidth)

	C.gtk_container_set_border_width((*C.GtkContainer)(recv.native), c_border_width)

	return
}

// SetFocusChain is a wrapper around the C function gtk_container_set_focus_chain.
func (recv *Container) SetFocusChain(focusableWidgets *glib.List) {
	c_focusable_widgets := (*C.GList)(C.NULL)
	if focusableWidgets != nil {
		c_focusable_widgets = (*C.GList)(focusableWidgets.ToC())
	}

	C.gtk_container_set_focus_chain((*C.GtkContainer)(recv.native), c_focusable_widgets)

	return
}

// SetFocusChild is a wrapper around the C function gtk_container_set_focus_child.
func (recv *Container) SetFocusChild(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_container_set_focus_child((*C.GtkContainer)(recv.native), c_child)

	return
}

// SetFocusHadjustment is a wrapper around the C function gtk_container_set_focus_hadjustment.
func (recv *Container) SetFocusHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_container_set_focus_hadjustment((*C.GtkContainer)(recv.native), c_adjustment)

	return
}

// SetFocusVadjustment is a wrapper around the C function gtk_container_set_focus_vadjustment.
func (recv *Container) SetFocusVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_container_set_focus_vadjustment((*C.GtkContainer)(recv.native), c_adjustment)

	return
}

// SetReallocateRedraws is a wrapper around the C function gtk_container_set_reallocate_redraws.
func (recv *Container) SetReallocateRedraws(needsRedraws bool) {
	c_needs_redraws :=
		boolToGboolean(needsRedraws)

	C.gtk_container_set_reallocate_redraws((*C.GtkContainer)(recv.native), c_needs_redraws)

	return
}

// SetResizeMode is a wrapper around the C function gtk_container_set_resize_mode.
func (recv *Container) SetResizeMode(resizeMode ResizeMode) {
	c_resize_mode := (C.GtkResizeMode)(resizeMode)

	C.gtk_container_set_resize_mode((*C.GtkContainer)(recv.native), c_resize_mode)

	return
}

// UnsetFocusChain is a wrapper around the C function gtk_container_unset_focus_chain.
func (recv *Container) UnsetFocusChain() {
	C.gtk_container_unset_focus_chain((*C.GtkContainer)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Container
func (recv *Container) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Container
func (recv *Container) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ContainerAccessible is a wrapper around the C record GtkContainerAccessible.
type ContainerAccessible struct {
	native *C.GtkContainerAccessible
	// parent : record
	// priv : record
}

func ContainerAccessibleNewFromC(u unsafe.Pointer) *ContainerAccessible {
	c := (*C.GtkContainerAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ContainerAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ContainerAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ContainerAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerAccessible with another ContainerAccessible, and returns true if they represent the same GObject.
func (recv *ContainerAccessible) Equals(other *ContainerAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ContainerAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ContainerAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ContainerAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ContainerAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ContainerAccessible.
func CastToContainerAccessible(object *gobject.Object) *ContainerAccessible {
	return ContainerAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ContainerAccessible
func (recv *ContainerAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// ContainerCellAccessible is a wrapper around the C record GtkContainerCellAccessible.
type ContainerCellAccessible struct {
	native *C.GtkContainerCellAccessible
	// parent : record
	// priv : record
}

func ContainerCellAccessibleNewFromC(u unsafe.Pointer) *ContainerCellAccessible {
	c := (*C.GtkContainerCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ContainerCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ContainerCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ContainerCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerCellAccessible with another ContainerCellAccessible, and returns true if they represent the same GObject.
func (recv *ContainerCellAccessible) Equals(other *ContainerCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// CellAccessible upcasts to *CellAccessible
func (recv *ContainerCellAccessible) CellAccessible() *CellAccessible {
	return CellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ContainerCellAccessible) Accessible() *Accessible {
	return recv.CellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ContainerCellAccessible) Object() *atk.Object {
	return recv.CellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ContainerCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ContainerCellAccessible.
func CastToContainerCellAccessible(object *gobject.Object) *ContainerCellAccessible {
	return ContainerCellAccessibleNewFromC(object.ToC())
}

// ContainerCellAccessibleNew is a wrapper around the C function gtk_container_cell_accessible_new.
func ContainerCellAccessibleNew() *ContainerCellAccessible {
	retC := C.gtk_container_cell_accessible_new()
	retGo := ContainerCellAccessibleNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddChild is a wrapper around the C function gtk_container_cell_accessible_add_child.
func (recv *ContainerCellAccessible) AddChild(child *CellAccessible) {
	c_child := (*C.GtkCellAccessible)(C.NULL)
	if child != nil {
		c_child = (*C.GtkCellAccessible)(child.ToC())
	}

	C.gtk_container_cell_accessible_add_child((*C.GtkContainerCellAccessible)(recv.native), c_child)

	return
}

// GetChildren is a wrapper around the C function gtk_container_cell_accessible_get_children.
func (recv *ContainerCellAccessible) GetChildren() *glib.List {
	retC := C.gtk_container_cell_accessible_get_children((*C.GtkContainerCellAccessible)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RemoveChild is a wrapper around the C function gtk_container_cell_accessible_remove_child.
func (recv *ContainerCellAccessible) RemoveChild(child *CellAccessible) {
	c_child := (*C.GtkCellAccessible)(C.NULL)
	if child != nil {
		c_child = (*C.GtkCellAccessible)(child.ToC())
	}

	C.gtk_container_cell_accessible_remove_child((*C.GtkContainerCellAccessible)(recv.native), c_child)

	return
}

// Action returns the Action interface implemented by ContainerCellAccessible
func (recv *ContainerCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ContainerCellAccessible
func (recv *ContainerCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// CssProvider is a wrapper around the C record GtkCssProvider.
type CssProvider struct {
	native *C.GtkCssProvider
	// parent_instance : record
	// priv : record
}

func CssProviderNewFromC(u unsafe.Pointer) *CssProvider {
	c := (*C.GtkCssProvider)(u)
	if c == nil {
		return nil
	}

	g := &CssProvider{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *CssProvider) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *CssProvider) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CssProvider with another CssProvider, and returns true if they represent the same GObject.
func (recv *CssProvider) Equals(other *CssProvider) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *CssProvider) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to CssProvider.
// Exercise care, as this is a potentially dangerous function if the Object is not a CssProvider.
func CastToCssProvider(object *gobject.Object) *CssProvider {
	return CssProviderNewFromC(object.ToC())
}

type signalCssProviderParsingErrorDetail struct {
	callback  CssProviderSignalParsingErrorCallback
	handlerID C.gulong
}

var signalCssProviderParsingErrorId int
var signalCssProviderParsingErrorMap = make(map[int]signalCssProviderParsingErrorDetail)
var signalCssProviderParsingErrorLock sync.RWMutex

// CssProviderSignalParsingErrorCallback is a callback function for a 'parsing-error' signal emitted from a CssProvider.
type CssProviderSignalParsingErrorCallback func(section *CssSection, error *glib.Error)

/*
ConnectParsingError connects the callback to the 'parsing-error' signal for the CssProvider.

The returned value represents the connection, and may be passed to DisconnectParsingError to remove it.
*/
func (recv *CssProvider) ConnectParsingError(callback CssProviderSignalParsingErrorCallback) int {
	signalCssProviderParsingErrorLock.Lock()
	defer signalCssProviderParsingErrorLock.Unlock()

	signalCssProviderParsingErrorId++
	instance := C.gpointer(recv.native)
	handlerID := C.CssProvider_signal_connect_parsing_error(instance, C.gpointer(uintptr(signalCssProviderParsingErrorId)))

	detail := signalCssProviderParsingErrorDetail{callback, handlerID}
	signalCssProviderParsingErrorMap[signalCssProviderParsingErrorId] = detail

	return signalCssProviderParsingErrorId
}

/*
DisconnectParsingError disconnects a callback from the 'parsing-error' signal for the CssProvider.

The connectionID should be a value returned from a call to ConnectParsingError.
*/
func (recv *CssProvider) DisconnectParsingError(connectionID int) {
	signalCssProviderParsingErrorLock.Lock()
	defer signalCssProviderParsingErrorLock.Unlock()

	detail, exists := signalCssProviderParsingErrorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCssProviderParsingErrorMap, connectionID)
}

//export cssprovider_parsingErrorHandler
func cssprovider_parsingErrorHandler(_ *C.GObject, c_section *C.GtkCssSection, c_error *C.GError, data C.gpointer) {
	signalCssProviderParsingErrorLock.RLock()
	defer signalCssProviderParsingErrorLock.RUnlock()

	section := CssSectionNewFromC(unsafe.Pointer(c_section))

	error := glib.ErrorNewFromC(unsafe.Pointer(c_error))

	index := int(uintptr(data))
	callback := signalCssProviderParsingErrorMap[index].callback
	callback(section, error)
}

// CssProviderNew is a wrapper around the C function gtk_css_provider_new.
func CssProviderNew() *CssProvider {
	retC := C.gtk_css_provider_new()
	retGo := CssProviderNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// CssProviderGetDefault is a wrapper around the C function gtk_css_provider_get_default.
func CssProviderGetDefault() *CssProvider {
	retC := C.gtk_css_provider_get_default()
	retGo := CssProviderNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CssProviderGetNamed is a wrapper around the C function gtk_css_provider_get_named.
func CssProviderGetNamed(name string, variant string) *CssProvider {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_variant := C.CString(variant)
	defer C.free(unsafe.Pointer(c_variant))

	retC := C.gtk_css_provider_get_named(c_name, c_variant)
	retGo := CssProviderNewFromC(unsafe.Pointer(retC))

	return retGo
}

// LoadFromData is a wrapper around the C function gtk_css_provider_load_from_data.
func (recv *CssProvider) LoadFromData(data []uint8) (bool, error) {
	c_data_array := make([]C.guint8, len(data)+1, len(data)+1)
	for i, item := range data {
		c := (C.guint8)(item)
		c_data_array[i] = c
	}
	c_data_array[len(data)] = 0
	c_data_arrayPtr := &c_data_array[0]
	c_data := (*C.gchar)(unsafe.Pointer(c_data_arrayPtr))

	c_length := (C.gssize)(len(data))

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_data((*C.GtkCssProvider)(recv.native), c_data, c_length, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LoadFromFile is a wrapper around the C function gtk_css_provider_load_from_file.
func (recv *CssProvider) LoadFromFile(file *gio.File) (bool, error) {
	c_file := (*C.GFile)(file.ToC())

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_file((*C.GtkCssProvider)(recv.native), c_file, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LoadFromPath is a wrapper around the C function gtk_css_provider_load_from_path.
func (recv *CssProvider) LoadFromPath(path string) (bool, error) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	var cThrowableError *C.GError

	retC := C.gtk_css_provider_load_from_path((*C.GtkCssProvider)(recv.native), c_path, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// StyleProvider returns the StyleProvider interface implemented by CssProvider
func (recv *CssProvider) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// Dialog is a wrapper around the C record GtkDialog.
type Dialog struct {
	native *C.GtkDialog
	// window : record
	// Private : priv
}

func DialogNewFromC(u unsafe.Pointer) *Dialog {
	c := (*C.GtkDialog)(u)
	if c == nil {
		return nil
	}

	g := &Dialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Dialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Dialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Dialog with another Dialog, and returns true if they represent the same GObject.
func (recv *Dialog) Equals(other *Dialog) bool {
	return other.ToC() == recv.ToC()
}

// Window upcasts to *Window
func (recv *Dialog) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *Dialog) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *Dialog) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *Dialog) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Dialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Dialog) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitrary Object to Dialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a Dialog.
func CastToDialog(object *gobject.Object) *Dialog {
	return DialogNewFromC(object.ToC())
}

type signalDialogCloseDetail struct {
	callback  DialogSignalCloseCallback
	handlerID C.gulong
}

var signalDialogCloseId int
var signalDialogCloseMap = make(map[int]signalDialogCloseDetail)
var signalDialogCloseLock sync.RWMutex

// DialogSignalCloseCallback is a callback function for a 'close' signal emitted from a Dialog.
type DialogSignalCloseCallback func()

/*
ConnectClose connects the callback to the 'close' signal for the Dialog.

The returned value represents the connection, and may be passed to DisconnectClose to remove it.
*/
func (recv *Dialog) ConnectClose(callback DialogSignalCloseCallback) int {
	signalDialogCloseLock.Lock()
	defer signalDialogCloseLock.Unlock()

	signalDialogCloseId++
	instance := C.gpointer(recv.native)
	handlerID := C.Dialog_signal_connect_close(instance, C.gpointer(uintptr(signalDialogCloseId)))

	detail := signalDialogCloseDetail{callback, handlerID}
	signalDialogCloseMap[signalDialogCloseId] = detail

	return signalDialogCloseId
}

/*
DisconnectClose disconnects a callback from the 'close' signal for the Dialog.

The connectionID should be a value returned from a call to ConnectClose.
*/
func (recv *Dialog) DisconnectClose(connectionID int) {
	signalDialogCloseLock.Lock()
	defer signalDialogCloseLock.Unlock()

	detail, exists := signalDialogCloseMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDialogCloseMap, connectionID)
}

//export dialog_closeHandler
func dialog_closeHandler(_ *C.GObject, data C.gpointer) {
	signalDialogCloseLock.RLock()
	defer signalDialogCloseLock.RUnlock()

	index := int(uintptr(data))
	callback := signalDialogCloseMap[index].callback
	callback()
}

type signalDialogResponseDetail struct {
	callback  DialogSignalResponseCallback
	handlerID C.gulong
}

var signalDialogResponseId int
var signalDialogResponseMap = make(map[int]signalDialogResponseDetail)
var signalDialogResponseLock sync.RWMutex

// DialogSignalResponseCallback is a callback function for a 'response' signal emitted from a Dialog.
type DialogSignalResponseCallback func(responseId int32)

/*
ConnectResponse connects the callback to the 'response' signal for the Dialog.

The returned value represents the connection, and may be passed to DisconnectResponse to remove it.
*/
func (recv *Dialog) ConnectResponse(callback DialogSignalResponseCallback) int {
	signalDialogResponseLock.Lock()
	defer signalDialogResponseLock.Unlock()

	signalDialogResponseId++
	instance := C.gpointer(recv.native)
	handlerID := C.Dialog_signal_connect_response(instance, C.gpointer(uintptr(signalDialogResponseId)))

	detail := signalDialogResponseDetail{callback, handlerID}
	signalDialogResponseMap[signalDialogResponseId] = detail

	return signalDialogResponseId
}

/*
DisconnectResponse disconnects a callback from the 'response' signal for the Dialog.

The connectionID should be a value returned from a call to ConnectResponse.
*/
func (recv *Dialog) DisconnectResponse(connectionID int) {
	signalDialogResponseLock.Lock()
	defer signalDialogResponseLock.Unlock()

	detail, exists := signalDialogResponseMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalDialogResponseMap, connectionID)
}

//export dialog_responseHandler
func dialog_responseHandler(_ *C.GObject, c_response_id C.gint, data C.gpointer) {
	signalDialogResponseLock.RLock()
	defer signalDialogResponseLock.RUnlock()

	responseId := int32(c_response_id)

	index := int(uintptr(data))
	callback := signalDialogResponseMap[index].callback
	callback(responseId)
}

// DialogNew is a wrapper around the C function gtk_dialog_new.
func DialogNew() *Dialog {
	retC := C.gtk_dialog_new()
	retGo := DialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_dialog_new_with_buttons : unsupported parameter ... : varargs

// AddActionWidget is a wrapper around the C function gtk_dialog_add_action_widget.
func (recv *Dialog) AddActionWidget(child *Widget, responseId int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_add_action_widget((*C.GtkDialog)(recv.native), c_child, c_response_id)

	return
}

// AddButton is a wrapper around the C function gtk_dialog_add_button.
func (recv *Dialog) AddButton(buttonText string, responseId int32) *Widget {
	c_button_text := C.CString(buttonText)
	defer C.free(unsafe.Pointer(c_button_text))

	c_response_id := (C.gint)(responseId)

	retC := C.gtk_dialog_add_button((*C.GtkDialog)(recv.native), c_button_text, c_response_id)
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_dialog_add_buttons : unsupported parameter ... : varargs

// GetResponseForWidget is a wrapper around the C function gtk_dialog_get_response_for_widget.
func (recv *Dialog) GetResponseForWidget(widget *Widget) int32 {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	retC := C.gtk_dialog_get_response_for_widget((*C.GtkDialog)(recv.native), c_widget)
	retGo := (int32)(retC)

	return retGo
}

// Response is a wrapper around the C function gtk_dialog_response.
func (recv *Dialog) Response(responseId int32) {
	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_response((*C.GtkDialog)(recv.native), c_response_id)

	return
}

// Run is a wrapper around the C function gtk_dialog_run.
func (recv *Dialog) Run() int32 {
	retC := C.gtk_dialog_run((*C.GtkDialog)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Unsupported : gtk_dialog_set_alternative_button_order : unsupported parameter ... : varargs

// SetAlternativeButtonOrderFromArray is a wrapper around the C function gtk_dialog_set_alternative_button_order_from_array.
func (recv *Dialog) SetAlternativeButtonOrderFromArray(newOrder []int32) {
	c_n_params := (C.gint)(len(newOrder))

	c_new_order_array := make([]C.gint, len(newOrder)+1, len(newOrder)+1)
	for i, item := range newOrder {
		c := (C.gint)(item)
		c_new_order_array[i] = c
	}
	c_new_order_array[len(newOrder)] = 0
	c_new_order_arrayPtr := &c_new_order_array[0]
	c_new_order := (*C.gint)(unsafe.Pointer(c_new_order_arrayPtr))

	C.gtk_dialog_set_alternative_button_order_from_array((*C.GtkDialog)(recv.native), c_n_params, c_new_order)

	return
}

// SetDefaultResponse is a wrapper around the C function gtk_dialog_set_default_response.
func (recv *Dialog) SetDefaultResponse(responseId int32) {
	c_response_id := (C.gint)(responseId)

	C.gtk_dialog_set_default_response((*C.GtkDialog)(recv.native), c_response_id)

	return
}

// SetResponseSensitive is a wrapper around the C function gtk_dialog_set_response_sensitive.
func (recv *Dialog) SetResponseSensitive(responseId int32, setting bool) {
	c_response_id := (C.gint)(responseId)

	c_setting :=
		boolToGboolean(setting)

	C.gtk_dialog_set_response_sensitive((*C.GtkDialog)(recv.native), c_response_id, c_setting)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Dialog
func (recv *Dialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Dialog
func (recv *Dialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// DrawingArea is a wrapper around the C record GtkDrawingArea.
type DrawingArea struct {
	native *C.GtkDrawingArea
	// widget : record
	// Private : dummy
}

func DrawingAreaNewFromC(u unsafe.Pointer) *DrawingArea {
	c := (*C.GtkDrawingArea)(u)
	if c == nil {
		return nil
	}

	g := &DrawingArea{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *DrawingArea) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *DrawingArea) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DrawingArea with another DrawingArea, and returns true if they represent the same GObject.
func (recv *DrawingArea) Equals(other *DrawingArea) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *DrawingArea) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *DrawingArea) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *DrawingArea) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to DrawingArea.
// Exercise care, as this is a potentially dangerous function if the Object is not a DrawingArea.
func CastToDrawingArea(object *gobject.Object) *DrawingArea {
	return DrawingAreaNewFromC(object.ToC())
}

// DrawingAreaNew is a wrapper around the C function gtk_drawing_area_new.
func DrawingAreaNew() *DrawingArea {
	retC := C.gtk_drawing_area_new()
	retGo := DrawingAreaNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by DrawingArea
func (recv *DrawingArea) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by DrawingArea
func (recv *DrawingArea) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Entry is a wrapper around the C record GtkEntry.
type Entry struct {
	native *C.GtkEntry
	// Private : parent_instance
	// Private : priv
}

func EntryNewFromC(u unsafe.Pointer) *Entry {
	c := (*C.GtkEntry)(u)
	if c == nil {
		return nil
	}

	g := &Entry{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Entry) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Entry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Entry with another Entry, and returns true if they represent the same GObject.
func (recv *Entry) Equals(other *Entry) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Entry) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Entry) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Entry) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Entry.
// Exercise care, as this is a potentially dangerous function if the Object is not a Entry.
func CastToEntry(object *gobject.Object) *Entry {
	return EntryNewFromC(object.ToC())
}

type signalEntryActivateDetail struct {
	callback  EntrySignalActivateCallback
	handlerID C.gulong
}

var signalEntryActivateId int
var signalEntryActivateMap = make(map[int]signalEntryActivateDetail)
var signalEntryActivateLock sync.RWMutex

// EntrySignalActivateCallback is a callback function for a 'activate' signal emitted from a Entry.
type EntrySignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Entry) ConnectActivate(callback EntrySignalActivateCallback) int {
	signalEntryActivateLock.Lock()
	defer signalEntryActivateLock.Unlock()

	signalEntryActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_activate(instance, C.gpointer(uintptr(signalEntryActivateId)))

	detail := signalEntryActivateDetail{callback, handlerID}
	signalEntryActivateMap[signalEntryActivateId] = detail

	return signalEntryActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Entry.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Entry) DisconnectActivate(connectionID int) {
	signalEntryActivateLock.Lock()
	defer signalEntryActivateLock.Unlock()

	detail, exists := signalEntryActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryActivateMap, connectionID)
}

//export entry_activateHandler
func entry_activateHandler(_ *C.GObject, data C.gpointer) {
	signalEntryActivateLock.RLock()
	defer signalEntryActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryActivateMap[index].callback
	callback()
}

type signalEntryBackspaceDetail struct {
	callback  EntrySignalBackspaceCallback
	handlerID C.gulong
}

var signalEntryBackspaceId int
var signalEntryBackspaceMap = make(map[int]signalEntryBackspaceDetail)
var signalEntryBackspaceLock sync.RWMutex

// EntrySignalBackspaceCallback is a callback function for a 'backspace' signal emitted from a Entry.
type EntrySignalBackspaceCallback func()

/*
ConnectBackspace connects the callback to the 'backspace' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectBackspace to remove it.
*/
func (recv *Entry) ConnectBackspace(callback EntrySignalBackspaceCallback) int {
	signalEntryBackspaceLock.Lock()
	defer signalEntryBackspaceLock.Unlock()

	signalEntryBackspaceId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_backspace(instance, C.gpointer(uintptr(signalEntryBackspaceId)))

	detail := signalEntryBackspaceDetail{callback, handlerID}
	signalEntryBackspaceMap[signalEntryBackspaceId] = detail

	return signalEntryBackspaceId
}

/*
DisconnectBackspace disconnects a callback from the 'backspace' signal for the Entry.

The connectionID should be a value returned from a call to ConnectBackspace.
*/
func (recv *Entry) DisconnectBackspace(connectionID int) {
	signalEntryBackspaceLock.Lock()
	defer signalEntryBackspaceLock.Unlock()

	detail, exists := signalEntryBackspaceMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryBackspaceMap, connectionID)
}

//export entry_backspaceHandler
func entry_backspaceHandler(_ *C.GObject, data C.gpointer) {
	signalEntryBackspaceLock.RLock()
	defer signalEntryBackspaceLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryBackspaceMap[index].callback
	callback()
}

type signalEntryCopyClipboardDetail struct {
	callback  EntrySignalCopyClipboardCallback
	handlerID C.gulong
}

var signalEntryCopyClipboardId int
var signalEntryCopyClipboardMap = make(map[int]signalEntryCopyClipboardDetail)
var signalEntryCopyClipboardLock sync.RWMutex

// EntrySignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a Entry.
type EntrySignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *Entry) ConnectCopyClipboard(callback EntrySignalCopyClipboardCallback) int {
	signalEntryCopyClipboardLock.Lock()
	defer signalEntryCopyClipboardLock.Unlock()

	signalEntryCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalEntryCopyClipboardId)))

	detail := signalEntryCopyClipboardDetail{callback, handlerID}
	signalEntryCopyClipboardMap[signalEntryCopyClipboardId] = detail

	return signalEntryCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *Entry) DisconnectCopyClipboard(connectionID int) {
	signalEntryCopyClipboardLock.Lock()
	defer signalEntryCopyClipboardLock.Unlock()

	detail, exists := signalEntryCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCopyClipboardMap, connectionID)
}

//export entry_copyClipboardHandler
func entry_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalEntryCopyClipboardLock.RLock()
	defer signalEntryCopyClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryCopyClipboardMap[index].callback
	callback()
}

type signalEntryCutClipboardDetail struct {
	callback  EntrySignalCutClipboardCallback
	handlerID C.gulong
}

var signalEntryCutClipboardId int
var signalEntryCutClipboardMap = make(map[int]signalEntryCutClipboardDetail)
var signalEntryCutClipboardLock sync.RWMutex

// EntrySignalCutClipboardCallback is a callback function for a 'cut-clipboard' signal emitted from a Entry.
type EntrySignalCutClipboardCallback func()

/*
ConnectCutClipboard connects the callback to the 'cut-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectCutClipboard to remove it.
*/
func (recv *Entry) ConnectCutClipboard(callback EntrySignalCutClipboardCallback) int {
	signalEntryCutClipboardLock.Lock()
	defer signalEntryCutClipboardLock.Unlock()

	signalEntryCutClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_cut_clipboard(instance, C.gpointer(uintptr(signalEntryCutClipboardId)))

	detail := signalEntryCutClipboardDetail{callback, handlerID}
	signalEntryCutClipboardMap[signalEntryCutClipboardId] = detail

	return signalEntryCutClipboardId
}

/*
DisconnectCutClipboard disconnects a callback from the 'cut-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectCutClipboard.
*/
func (recv *Entry) DisconnectCutClipboard(connectionID int) {
	signalEntryCutClipboardLock.Lock()
	defer signalEntryCutClipboardLock.Unlock()

	detail, exists := signalEntryCutClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCutClipboardMap, connectionID)
}

//export entry_cutClipboardHandler
func entry_cutClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalEntryCutClipboardLock.RLock()
	defer signalEntryCutClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryCutClipboardMap[index].callback
	callback()
}

type signalEntryDeleteFromCursorDetail struct {
	callback  EntrySignalDeleteFromCursorCallback
	handlerID C.gulong
}

var signalEntryDeleteFromCursorId int
var signalEntryDeleteFromCursorMap = make(map[int]signalEntryDeleteFromCursorDetail)
var signalEntryDeleteFromCursorLock sync.RWMutex

// EntrySignalDeleteFromCursorCallback is a callback function for a 'delete-from-cursor' signal emitted from a Entry.
type EntrySignalDeleteFromCursorCallback func(type_ DeleteType, count int32)

/*
ConnectDeleteFromCursor connects the callback to the 'delete-from-cursor' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectDeleteFromCursor to remove it.
*/
func (recv *Entry) ConnectDeleteFromCursor(callback EntrySignalDeleteFromCursorCallback) int {
	signalEntryDeleteFromCursorLock.Lock()
	defer signalEntryDeleteFromCursorLock.Unlock()

	signalEntryDeleteFromCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_delete_from_cursor(instance, C.gpointer(uintptr(signalEntryDeleteFromCursorId)))

	detail := signalEntryDeleteFromCursorDetail{callback, handlerID}
	signalEntryDeleteFromCursorMap[signalEntryDeleteFromCursorId] = detail

	return signalEntryDeleteFromCursorId
}

/*
DisconnectDeleteFromCursor disconnects a callback from the 'delete-from-cursor' signal for the Entry.

The connectionID should be a value returned from a call to ConnectDeleteFromCursor.
*/
func (recv *Entry) DisconnectDeleteFromCursor(connectionID int) {
	signalEntryDeleteFromCursorLock.Lock()
	defer signalEntryDeleteFromCursorLock.Unlock()

	detail, exists := signalEntryDeleteFromCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryDeleteFromCursorMap, connectionID)
}

//export entry_deleteFromCursorHandler
func entry_deleteFromCursorHandler(_ *C.GObject, c_type C.GtkDeleteType, c_count C.gint, data C.gpointer) {
	signalEntryDeleteFromCursorLock.RLock()
	defer signalEntryDeleteFromCursorLock.RUnlock()

	type_ := DeleteType(c_type)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalEntryDeleteFromCursorMap[index].callback
	callback(type_, count)
}

type signalEntryInsertAtCursorDetail struct {
	callback  EntrySignalInsertAtCursorCallback
	handlerID C.gulong
}

var signalEntryInsertAtCursorId int
var signalEntryInsertAtCursorMap = make(map[int]signalEntryInsertAtCursorDetail)
var signalEntryInsertAtCursorLock sync.RWMutex

// EntrySignalInsertAtCursorCallback is a callback function for a 'insert-at-cursor' signal emitted from a Entry.
type EntrySignalInsertAtCursorCallback func(string_ string)

/*
ConnectInsertAtCursor connects the callback to the 'insert-at-cursor' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectInsertAtCursor to remove it.
*/
func (recv *Entry) ConnectInsertAtCursor(callback EntrySignalInsertAtCursorCallback) int {
	signalEntryInsertAtCursorLock.Lock()
	defer signalEntryInsertAtCursorLock.Unlock()

	signalEntryInsertAtCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_insert_at_cursor(instance, C.gpointer(uintptr(signalEntryInsertAtCursorId)))

	detail := signalEntryInsertAtCursorDetail{callback, handlerID}
	signalEntryInsertAtCursorMap[signalEntryInsertAtCursorId] = detail

	return signalEntryInsertAtCursorId
}

/*
DisconnectInsertAtCursor disconnects a callback from the 'insert-at-cursor' signal for the Entry.

The connectionID should be a value returned from a call to ConnectInsertAtCursor.
*/
func (recv *Entry) DisconnectInsertAtCursor(connectionID int) {
	signalEntryInsertAtCursorLock.Lock()
	defer signalEntryInsertAtCursorLock.Unlock()

	detail, exists := signalEntryInsertAtCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryInsertAtCursorMap, connectionID)
}

//export entry_insertAtCursorHandler
func entry_insertAtCursorHandler(_ *C.GObject, c_string *C.gchar, data C.gpointer) {
	signalEntryInsertAtCursorLock.RLock()
	defer signalEntryInsertAtCursorLock.RUnlock()

	string_ := C.GoString(c_string)

	index := int(uintptr(data))
	callback := signalEntryInsertAtCursorMap[index].callback
	callback(string_)
}

type signalEntryMoveCursorDetail struct {
	callback  EntrySignalMoveCursorCallback
	handlerID C.gulong
}

var signalEntryMoveCursorId int
var signalEntryMoveCursorMap = make(map[int]signalEntryMoveCursorDetail)
var signalEntryMoveCursorLock sync.RWMutex

// EntrySignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a Entry.
type EntrySignalMoveCursorCallback func(step MovementStep, count int32, extendSelection bool)

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *Entry) ConnectMoveCursor(callback EntrySignalMoveCursorCallback) int {
	signalEntryMoveCursorLock.Lock()
	defer signalEntryMoveCursorLock.Unlock()

	signalEntryMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalEntryMoveCursorId)))

	detail := signalEntryMoveCursorDetail{callback, handlerID}
	signalEntryMoveCursorMap[signalEntryMoveCursorId] = detail

	return signalEntryMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the Entry.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *Entry) DisconnectMoveCursor(connectionID int) {
	signalEntryMoveCursorLock.Lock()
	defer signalEntryMoveCursorLock.Unlock()

	detail, exists := signalEntryMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryMoveCursorMap, connectionID)
}

//export entry_moveCursorHandler
func entry_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, c_extend_selection C.gboolean, data C.gpointer) {
	signalEntryMoveCursorLock.RLock()
	defer signalEntryMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	extendSelection := c_extend_selection == C.TRUE

	index := int(uintptr(data))
	callback := signalEntryMoveCursorMap[index].callback
	callback(step, count, extendSelection)
}

type signalEntryPasteClipboardDetail struct {
	callback  EntrySignalPasteClipboardCallback
	handlerID C.gulong
}

var signalEntryPasteClipboardId int
var signalEntryPasteClipboardMap = make(map[int]signalEntryPasteClipboardDetail)
var signalEntryPasteClipboardLock sync.RWMutex

// EntrySignalPasteClipboardCallback is a callback function for a 'paste-clipboard' signal emitted from a Entry.
type EntrySignalPasteClipboardCallback func()

/*
ConnectPasteClipboard connects the callback to the 'paste-clipboard' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectPasteClipboard to remove it.
*/
func (recv *Entry) ConnectPasteClipboard(callback EntrySignalPasteClipboardCallback) int {
	signalEntryPasteClipboardLock.Lock()
	defer signalEntryPasteClipboardLock.Unlock()

	signalEntryPasteClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_paste_clipboard(instance, C.gpointer(uintptr(signalEntryPasteClipboardId)))

	detail := signalEntryPasteClipboardDetail{callback, handlerID}
	signalEntryPasteClipboardMap[signalEntryPasteClipboardId] = detail

	return signalEntryPasteClipboardId
}

/*
DisconnectPasteClipboard disconnects a callback from the 'paste-clipboard' signal for the Entry.

The connectionID should be a value returned from a call to ConnectPasteClipboard.
*/
func (recv *Entry) DisconnectPasteClipboard(connectionID int) {
	signalEntryPasteClipboardLock.Lock()
	defer signalEntryPasteClipboardLock.Unlock()

	detail, exists := signalEntryPasteClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryPasteClipboardMap, connectionID)
}

//export entry_pasteClipboardHandler
func entry_pasteClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalEntryPasteClipboardLock.RLock()
	defer signalEntryPasteClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryPasteClipboardMap[index].callback
	callback()
}

type signalEntryPopulatePopupDetail struct {
	callback  EntrySignalPopulatePopupCallback
	handlerID C.gulong
}

var signalEntryPopulatePopupId int
var signalEntryPopulatePopupMap = make(map[int]signalEntryPopulatePopupDetail)
var signalEntryPopulatePopupLock sync.RWMutex

// EntrySignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a Entry.
type EntrySignalPopulatePopupCallback func(widget *Widget)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *Entry) ConnectPopulatePopup(callback EntrySignalPopulatePopupCallback) int {
	signalEntryPopulatePopupLock.Lock()
	defer signalEntryPopulatePopupLock.Unlock()

	signalEntryPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalEntryPopulatePopupId)))

	detail := signalEntryPopulatePopupDetail{callback, handlerID}
	signalEntryPopulatePopupMap[signalEntryPopulatePopupId] = detail

	return signalEntryPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the Entry.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *Entry) DisconnectPopulatePopup(connectionID int) {
	signalEntryPopulatePopupLock.Lock()
	defer signalEntryPopulatePopupLock.Unlock()

	detail, exists := signalEntryPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryPopulatePopupMap, connectionID)
}

//export entry_populatePopupHandler
func entry_populatePopupHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	signalEntryPopulatePopupLock.RLock()
	defer signalEntryPopulatePopupLock.RUnlock()

	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalEntryPopulatePopupMap[index].callback
	callback(widget)
}

type signalEntryToggleOverwriteDetail struct {
	callback  EntrySignalToggleOverwriteCallback
	handlerID C.gulong
}

var signalEntryToggleOverwriteId int
var signalEntryToggleOverwriteMap = make(map[int]signalEntryToggleOverwriteDetail)
var signalEntryToggleOverwriteLock sync.RWMutex

// EntrySignalToggleOverwriteCallback is a callback function for a 'toggle-overwrite' signal emitted from a Entry.
type EntrySignalToggleOverwriteCallback func()

/*
ConnectToggleOverwrite connects the callback to the 'toggle-overwrite' signal for the Entry.

The returned value represents the connection, and may be passed to DisconnectToggleOverwrite to remove it.
*/
func (recv *Entry) ConnectToggleOverwrite(callback EntrySignalToggleOverwriteCallback) int {
	signalEntryToggleOverwriteLock.Lock()
	defer signalEntryToggleOverwriteLock.Unlock()

	signalEntryToggleOverwriteId++
	instance := C.gpointer(recv.native)
	handlerID := C.Entry_signal_connect_toggle_overwrite(instance, C.gpointer(uintptr(signalEntryToggleOverwriteId)))

	detail := signalEntryToggleOverwriteDetail{callback, handlerID}
	signalEntryToggleOverwriteMap[signalEntryToggleOverwriteId] = detail

	return signalEntryToggleOverwriteId
}

/*
DisconnectToggleOverwrite disconnects a callback from the 'toggle-overwrite' signal for the Entry.

The connectionID should be a value returned from a call to ConnectToggleOverwrite.
*/
func (recv *Entry) DisconnectToggleOverwrite(connectionID int) {
	signalEntryToggleOverwriteLock.Lock()
	defer signalEntryToggleOverwriteLock.Unlock()

	detail, exists := signalEntryToggleOverwriteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryToggleOverwriteMap, connectionID)
}

//export entry_toggleOverwriteHandler
func entry_toggleOverwriteHandler(_ *C.GObject, data C.gpointer) {
	signalEntryToggleOverwriteLock.RLock()
	defer signalEntryToggleOverwriteLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEntryToggleOverwriteMap[index].callback
	callback()
}

// EntryNew is a wrapper around the C function gtk_entry_new.
func EntryNew() *Entry {
	retC := C.gtk_entry_new()
	retGo := EntryNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetActivatesDefault is a wrapper around the C function gtk_entry_get_activates_default.
func (recv *Entry) GetActivatesDefault() bool {
	retC := C.gtk_entry_get_activates_default((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetAlignment is a wrapper around the C function gtk_entry_get_alignment.
func (recv *Entry) GetAlignment() float32 {
	retC := C.gtk_entry_get_alignment((*C.GtkEntry)(recv.native))
	retGo := (float32)(retC)

	return retGo
}

// GetCompletion is a wrapper around the C function gtk_entry_get_completion.
func (recv *Entry) GetCompletion() *EntryCompletion {
	retC := C.gtk_entry_get_completion((*C.GtkEntry)(recv.native))
	retGo := EntryCompletionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCursorHadjustment is a wrapper around the C function gtk_entry_get_cursor_hadjustment.
func (recv *Entry) GetCursorHadjustment() *Adjustment {
	retC := C.gtk_entry_get_cursor_hadjustment((*C.GtkEntry)(recv.native))
	var retGo (*Adjustment)
	if retC == nil {
		retGo = nil
	} else {
		retGo = AdjustmentNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetHasFrame is a wrapper around the C function gtk_entry_get_has_frame.
func (recv *Entry) GetHasFrame() bool {
	retC := C.gtk_entry_get_has_frame((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetInnerBorder is a wrapper around the C function gtk_entry_get_inner_border.
func (recv *Entry) GetInnerBorder() *Border {
	retC := C.gtk_entry_get_inner_border((*C.GtkEntry)(recv.native))
	var retGo (*Border)
	if retC == nil {
		retGo = nil
	} else {
		retGo = BorderNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetInvisibleChar is a wrapper around the C function gtk_entry_get_invisible_char.
func (recv *Entry) GetInvisibleChar() rune {
	retC := C.gtk_entry_get_invisible_char((*C.GtkEntry)(recv.native))
	retGo := (rune)(retC)

	return retGo
}

// GetLayout is a wrapper around the C function gtk_entry_get_layout.
func (recv *Entry) GetLayout() *pango.Layout {
	retC := C.gtk_entry_get_layout((*C.GtkEntry)(recv.native))
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLayoutOffsets is a wrapper around the C function gtk_entry_get_layout_offsets.
func (recv *Entry) GetLayoutOffsets() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_entry_get_layout_offsets((*C.GtkEntry)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// GetMaxLength is a wrapper around the C function gtk_entry_get_max_length.
func (recv *Entry) GetMaxLength() int32 {
	retC := C.gtk_entry_get_max_length((*C.GtkEntry)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetText is a wrapper around the C function gtk_entry_get_text.
func (recv *Entry) GetText() string {
	retC := C.gtk_entry_get_text((*C.GtkEntry)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetVisibility is a wrapper around the C function gtk_entry_get_visibility.
func (recv *Entry) GetVisibility() bool {
	retC := C.gtk_entry_get_visibility((*C.GtkEntry)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetWidthChars is a wrapper around the C function gtk_entry_get_width_chars.
func (recv *Entry) GetWidthChars() int32 {
	retC := C.gtk_entry_get_width_chars((*C.GtkEntry)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// LayoutIndexToTextIndex is a wrapper around the C function gtk_entry_layout_index_to_text_index.
func (recv *Entry) LayoutIndexToTextIndex(layoutIndex int32) int32 {
	c_layout_index := (C.gint)(layoutIndex)

	retC := C.gtk_entry_layout_index_to_text_index((*C.GtkEntry)(recv.native), c_layout_index)
	retGo := (int32)(retC)

	return retGo
}

// SetActivatesDefault is a wrapper around the C function gtk_entry_set_activates_default.
func (recv *Entry) SetActivatesDefault(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_entry_set_activates_default((*C.GtkEntry)(recv.native), c_setting)

	return
}

// SetAlignment is a wrapper around the C function gtk_entry_set_alignment.
func (recv *Entry) SetAlignment(xalign float32) {
	c_xalign := (C.gfloat)(xalign)

	C.gtk_entry_set_alignment((*C.GtkEntry)(recv.native), c_xalign)

	return
}

// SetCompletion is a wrapper around the C function gtk_entry_set_completion.
func (recv *Entry) SetCompletion(completion *EntryCompletion) {
	c_completion := (*C.GtkEntryCompletion)(C.NULL)
	if completion != nil {
		c_completion = (*C.GtkEntryCompletion)(completion.ToC())
	}

	C.gtk_entry_set_completion((*C.GtkEntry)(recv.native), c_completion)

	return
}

// SetCursorHadjustment is a wrapper around the C function gtk_entry_set_cursor_hadjustment.
func (recv *Entry) SetCursorHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_entry_set_cursor_hadjustment((*C.GtkEntry)(recv.native), c_adjustment)

	return
}

// SetHasFrame is a wrapper around the C function gtk_entry_set_has_frame.
func (recv *Entry) SetHasFrame(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_entry_set_has_frame((*C.GtkEntry)(recv.native), c_setting)

	return
}

// SetInnerBorder is a wrapper around the C function gtk_entry_set_inner_border.
func (recv *Entry) SetInnerBorder(border *Border) {
	c_border := (*C.GtkBorder)(C.NULL)
	if border != nil {
		c_border = (*C.GtkBorder)(border.ToC())
	}

	C.gtk_entry_set_inner_border((*C.GtkEntry)(recv.native), c_border)

	return
}

// SetInvisibleChar is a wrapper around the C function gtk_entry_set_invisible_char.
func (recv *Entry) SetInvisibleChar(ch rune) {
	c_ch := (C.gunichar)(ch)

	C.gtk_entry_set_invisible_char((*C.GtkEntry)(recv.native), c_ch)

	return
}

// SetMaxLength is a wrapper around the C function gtk_entry_set_max_length.
func (recv *Entry) SetMaxLength(max int32) {
	c_max := (C.gint)(max)

	C.gtk_entry_set_max_length((*C.GtkEntry)(recv.native), c_max)

	return
}

// SetText is a wrapper around the C function gtk_entry_set_text.
func (recv *Entry) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_entry_set_text((*C.GtkEntry)(recv.native), c_text)

	return
}

// SetVisibility is a wrapper around the C function gtk_entry_set_visibility.
func (recv *Entry) SetVisibility(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_entry_set_visibility((*C.GtkEntry)(recv.native), c_visible)

	return
}

// SetWidthChars is a wrapper around the C function gtk_entry_set_width_chars.
func (recv *Entry) SetWidthChars(nChars int32) {
	c_n_chars := (C.gint)(nChars)

	C.gtk_entry_set_width_chars((*C.GtkEntry)(recv.native), c_n_chars)

	return
}

// TextIndexToLayoutIndex is a wrapper around the C function gtk_entry_text_index_to_layout_index.
func (recv *Entry) TextIndexToLayoutIndex(textIndex int32) int32 {
	c_text_index := (C.gint)(textIndex)

	retC := C.gtk_entry_text_index_to_layout_index((*C.GtkEntry)(recv.native), c_text_index)
	retGo := (int32)(retC)

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Entry
func (recv *Entry) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Entry
func (recv *Entry) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by Entry
func (recv *Entry) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by Entry
func (recv *Entry) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// EntryAccessible is a wrapper around the C record GtkEntryAccessible.
type EntryAccessible struct {
	native *C.GtkEntryAccessible
	// parent : record
	// priv : record
}

func EntryAccessibleNewFromC(u unsafe.Pointer) *EntryAccessible {
	c := (*C.GtkEntryAccessible)(u)
	if c == nil {
		return nil
	}

	g := &EntryAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EntryAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EntryAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryAccessible with another EntryAccessible, and returns true if they represent the same GObject.
func (recv *EntryAccessible) Equals(other *EntryAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *EntryAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *EntryAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *EntryAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to EntryAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryAccessible.
func CastToEntryAccessible(object *gobject.Object) *EntryAccessible {
	return EntryAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by EntryAccessible
func (recv *EntryAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by EntryAccessible
func (recv *EntryAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by EntryAccessible
func (recv *EntryAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by EntryAccessible
func (recv *EntryAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// EntryBuffer is a wrapper around the C record GtkEntryBuffer.
type EntryBuffer struct {
	native *C.GtkEntryBuffer
	// parent_instance : record
	// Private : priv
}

func EntryBufferNewFromC(u unsafe.Pointer) *EntryBuffer {
	c := (*C.GtkEntryBuffer)(u)
	if c == nil {
		return nil
	}

	g := &EntryBuffer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EntryBuffer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EntryBuffer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryBuffer with another EntryBuffer, and returns true if they represent the same GObject.
func (recv *EntryBuffer) Equals(other *EntryBuffer) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *EntryBuffer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to EntryBuffer.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryBuffer.
func CastToEntryBuffer(object *gobject.Object) *EntryBuffer {
	return EntryBufferNewFromC(object.ToC())
}

// EntryCompletion is a wrapper around the C record GtkEntryCompletion.
type EntryCompletion struct {
	native *C.GtkEntryCompletion
	// parent_instance : record
	// Private : priv
}

func EntryCompletionNewFromC(u unsafe.Pointer) *EntryCompletion {
	c := (*C.GtkEntryCompletion)(u)
	if c == nil {
		return nil
	}

	g := &EntryCompletion{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EntryCompletion) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EntryCompletion) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryCompletion with another EntryCompletion, and returns true if they represent the same GObject.
func (recv *EntryCompletion) Equals(other *EntryCompletion) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *EntryCompletion) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to EntryCompletion.
// Exercise care, as this is a potentially dangerous function if the Object is not a EntryCompletion.
func CastToEntryCompletion(object *gobject.Object) *EntryCompletion {
	return EntryCompletionNewFromC(object.ToC())
}

type signalEntryCompletionActionActivatedDetail struct {
	callback  EntryCompletionSignalActionActivatedCallback
	handlerID C.gulong
}

var signalEntryCompletionActionActivatedId int
var signalEntryCompletionActionActivatedMap = make(map[int]signalEntryCompletionActionActivatedDetail)
var signalEntryCompletionActionActivatedLock sync.RWMutex

// EntryCompletionSignalActionActivatedCallback is a callback function for a 'action-activated' signal emitted from a EntryCompletion.
type EntryCompletionSignalActionActivatedCallback func(Index int32)

/*
ConnectActionActivated connects the callback to the 'action-activated' signal for the EntryCompletion.

The returned value represents the connection, and may be passed to DisconnectActionActivated to remove it.
*/
func (recv *EntryCompletion) ConnectActionActivated(callback EntryCompletionSignalActionActivatedCallback) int {
	signalEntryCompletionActionActivatedLock.Lock()
	defer signalEntryCompletionActionActivatedLock.Unlock()

	signalEntryCompletionActionActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.EntryCompletion_signal_connect_action_activated(instance, C.gpointer(uintptr(signalEntryCompletionActionActivatedId)))

	detail := signalEntryCompletionActionActivatedDetail{callback, handlerID}
	signalEntryCompletionActionActivatedMap[signalEntryCompletionActionActivatedId] = detail

	return signalEntryCompletionActionActivatedId
}

/*
DisconnectActionActivated disconnects a callback from the 'action-activated' signal for the EntryCompletion.

The connectionID should be a value returned from a call to ConnectActionActivated.
*/
func (recv *EntryCompletion) DisconnectActionActivated(connectionID int) {
	signalEntryCompletionActionActivatedLock.Lock()
	defer signalEntryCompletionActionActivatedLock.Unlock()

	detail, exists := signalEntryCompletionActionActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCompletionActionActivatedMap, connectionID)
}

//export entrycompletion_actionActivatedHandler
func entrycompletion_actionActivatedHandler(_ *C.GObject, c__index C.gint, data C.gpointer) {
	signalEntryCompletionActionActivatedLock.RLock()
	defer signalEntryCompletionActionActivatedLock.RUnlock()

	Index := int32(c__index)

	index := int(uintptr(data))
	callback := signalEntryCompletionActionActivatedMap[index].callback
	callback(Index)
}

type signalEntryCompletionCursorOnMatchDetail struct {
	callback  EntryCompletionSignalCursorOnMatchCallback
	handlerID C.gulong
}

var signalEntryCompletionCursorOnMatchId int
var signalEntryCompletionCursorOnMatchMap = make(map[int]signalEntryCompletionCursorOnMatchDetail)
var signalEntryCompletionCursorOnMatchLock sync.RWMutex

// EntryCompletionSignalCursorOnMatchCallback is a callback function for a 'cursor-on-match' signal emitted from a EntryCompletion.
type EntryCompletionSignalCursorOnMatchCallback func(model *TreeModel, iter *TreeIter) bool

/*
ConnectCursorOnMatch connects the callback to the 'cursor-on-match' signal for the EntryCompletion.

The returned value represents the connection, and may be passed to DisconnectCursorOnMatch to remove it.
*/
func (recv *EntryCompletion) ConnectCursorOnMatch(callback EntryCompletionSignalCursorOnMatchCallback) int {
	signalEntryCompletionCursorOnMatchLock.Lock()
	defer signalEntryCompletionCursorOnMatchLock.Unlock()

	signalEntryCompletionCursorOnMatchId++
	instance := C.gpointer(recv.native)
	handlerID := C.EntryCompletion_signal_connect_cursor_on_match(instance, C.gpointer(uintptr(signalEntryCompletionCursorOnMatchId)))

	detail := signalEntryCompletionCursorOnMatchDetail{callback, handlerID}
	signalEntryCompletionCursorOnMatchMap[signalEntryCompletionCursorOnMatchId] = detail

	return signalEntryCompletionCursorOnMatchId
}

/*
DisconnectCursorOnMatch disconnects a callback from the 'cursor-on-match' signal for the EntryCompletion.

The connectionID should be a value returned from a call to ConnectCursorOnMatch.
*/
func (recv *EntryCompletion) DisconnectCursorOnMatch(connectionID int) {
	signalEntryCompletionCursorOnMatchLock.Lock()
	defer signalEntryCompletionCursorOnMatchLock.Unlock()

	detail, exists := signalEntryCompletionCursorOnMatchMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCompletionCursorOnMatchMap, connectionID)
}

//export entrycompletion_cursorOnMatchHandler
func entrycompletion_cursorOnMatchHandler(_ *C.GObject, c_model *C.GtkTreeModel, c_iter *C.GtkTreeIter, data C.gpointer) C.gboolean {
	signalEntryCompletionCursorOnMatchLock.RLock()
	defer signalEntryCompletionCursorOnMatchLock.RUnlock()

	model := TreeModelNewFromC(unsafe.Pointer(c_model))

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	index := int(uintptr(data))
	callback := signalEntryCompletionCursorOnMatchMap[index].callback
	retGo := callback(model, iter)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalEntryCompletionInsertPrefixDetail struct {
	callback  EntryCompletionSignalInsertPrefixCallback
	handlerID C.gulong
}

var signalEntryCompletionInsertPrefixId int
var signalEntryCompletionInsertPrefixMap = make(map[int]signalEntryCompletionInsertPrefixDetail)
var signalEntryCompletionInsertPrefixLock sync.RWMutex

// EntryCompletionSignalInsertPrefixCallback is a callback function for a 'insert-prefix' signal emitted from a EntryCompletion.
type EntryCompletionSignalInsertPrefixCallback func(prefix string) bool

/*
ConnectInsertPrefix connects the callback to the 'insert-prefix' signal for the EntryCompletion.

The returned value represents the connection, and may be passed to DisconnectInsertPrefix to remove it.
*/
func (recv *EntryCompletion) ConnectInsertPrefix(callback EntryCompletionSignalInsertPrefixCallback) int {
	signalEntryCompletionInsertPrefixLock.Lock()
	defer signalEntryCompletionInsertPrefixLock.Unlock()

	signalEntryCompletionInsertPrefixId++
	instance := C.gpointer(recv.native)
	handlerID := C.EntryCompletion_signal_connect_insert_prefix(instance, C.gpointer(uintptr(signalEntryCompletionInsertPrefixId)))

	detail := signalEntryCompletionInsertPrefixDetail{callback, handlerID}
	signalEntryCompletionInsertPrefixMap[signalEntryCompletionInsertPrefixId] = detail

	return signalEntryCompletionInsertPrefixId
}

/*
DisconnectInsertPrefix disconnects a callback from the 'insert-prefix' signal for the EntryCompletion.

The connectionID should be a value returned from a call to ConnectInsertPrefix.
*/
func (recv *EntryCompletion) DisconnectInsertPrefix(connectionID int) {
	signalEntryCompletionInsertPrefixLock.Lock()
	defer signalEntryCompletionInsertPrefixLock.Unlock()

	detail, exists := signalEntryCompletionInsertPrefixMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCompletionInsertPrefixMap, connectionID)
}

//export entrycompletion_insertPrefixHandler
func entrycompletion_insertPrefixHandler(_ *C.GObject, c_prefix *C.gchar, data C.gpointer) C.gboolean {
	signalEntryCompletionInsertPrefixLock.RLock()
	defer signalEntryCompletionInsertPrefixLock.RUnlock()

	prefix := C.GoString(c_prefix)

	index := int(uintptr(data))
	callback := signalEntryCompletionInsertPrefixMap[index].callback
	retGo := callback(prefix)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalEntryCompletionMatchSelectedDetail struct {
	callback  EntryCompletionSignalMatchSelectedCallback
	handlerID C.gulong
}

var signalEntryCompletionMatchSelectedId int
var signalEntryCompletionMatchSelectedMap = make(map[int]signalEntryCompletionMatchSelectedDetail)
var signalEntryCompletionMatchSelectedLock sync.RWMutex

// EntryCompletionSignalMatchSelectedCallback is a callback function for a 'match-selected' signal emitted from a EntryCompletion.
type EntryCompletionSignalMatchSelectedCallback func(model *TreeModel, iter *TreeIter) bool

/*
ConnectMatchSelected connects the callback to the 'match-selected' signal for the EntryCompletion.

The returned value represents the connection, and may be passed to DisconnectMatchSelected to remove it.
*/
func (recv *EntryCompletion) ConnectMatchSelected(callback EntryCompletionSignalMatchSelectedCallback) int {
	signalEntryCompletionMatchSelectedLock.Lock()
	defer signalEntryCompletionMatchSelectedLock.Unlock()

	signalEntryCompletionMatchSelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.EntryCompletion_signal_connect_match_selected(instance, C.gpointer(uintptr(signalEntryCompletionMatchSelectedId)))

	detail := signalEntryCompletionMatchSelectedDetail{callback, handlerID}
	signalEntryCompletionMatchSelectedMap[signalEntryCompletionMatchSelectedId] = detail

	return signalEntryCompletionMatchSelectedId
}

/*
DisconnectMatchSelected disconnects a callback from the 'match-selected' signal for the EntryCompletion.

The connectionID should be a value returned from a call to ConnectMatchSelected.
*/
func (recv *EntryCompletion) DisconnectMatchSelected(connectionID int) {
	signalEntryCompletionMatchSelectedLock.Lock()
	defer signalEntryCompletionMatchSelectedLock.Unlock()

	detail, exists := signalEntryCompletionMatchSelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEntryCompletionMatchSelectedMap, connectionID)
}

//export entrycompletion_matchSelectedHandler
func entrycompletion_matchSelectedHandler(_ *C.GObject, c_model *C.GtkTreeModel, c_iter *C.GtkTreeIter, data C.gpointer) C.gboolean {
	signalEntryCompletionMatchSelectedLock.RLock()
	defer signalEntryCompletionMatchSelectedLock.RUnlock()

	model := TreeModelNewFromC(unsafe.Pointer(c_model))

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	index := int(uintptr(data))
	callback := signalEntryCompletionMatchSelectedMap[index].callback
	retGo := callback(model, iter)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// EntryCompletionNew is a wrapper around the C function gtk_entry_completion_new.
func EntryCompletionNew() *EntryCompletion {
	retC := C.gtk_entry_completion_new()
	retGo := EntryCompletionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Complete is a wrapper around the C function gtk_entry_completion_complete.
func (recv *EntryCompletion) Complete() {
	C.gtk_entry_completion_complete((*C.GtkEntryCompletion)(recv.native))

	return
}

// DeleteAction is a wrapper around the C function gtk_entry_completion_delete_action.
func (recv *EntryCompletion) DeleteAction(index int32) {
	c_index_ := (C.gint)(index)

	C.gtk_entry_completion_delete_action((*C.GtkEntryCompletion)(recv.native), c_index_)

	return
}

// GetCompletionPrefix is a wrapper around the C function gtk_entry_completion_get_completion_prefix.
func (recv *EntryCompletion) GetCompletionPrefix() string {
	retC := C.gtk_entry_completion_get_completion_prefix((*C.GtkEntryCompletion)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetEntry is a wrapper around the C function gtk_entry_completion_get_entry.
func (recv *EntryCompletion) GetEntry() *Widget {
	retC := C.gtk_entry_completion_get_entry((*C.GtkEntryCompletion)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetInlineCompletion is a wrapper around the C function gtk_entry_completion_get_inline_completion.
func (recv *EntryCompletion) GetInlineCompletion() bool {
	retC := C.gtk_entry_completion_get_inline_completion((*C.GtkEntryCompletion)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetInlineSelection is a wrapper around the C function gtk_entry_completion_get_inline_selection.
func (recv *EntryCompletion) GetInlineSelection() bool {
	retC := C.gtk_entry_completion_get_inline_selection((*C.GtkEntryCompletion)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetMinimumKeyLength is a wrapper around the C function gtk_entry_completion_get_minimum_key_length.
func (recv *EntryCompletion) GetMinimumKeyLength() int32 {
	retC := C.gtk_entry_completion_get_minimum_key_length((*C.GtkEntryCompletion)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetModel is a wrapper around the C function gtk_entry_completion_get_model.
func (recv *EntryCompletion) GetModel() *TreeModel {
	retC := C.gtk_entry_completion_get_model((*C.GtkEntryCompletion)(recv.native))
	var retGo (*TreeModel)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreeModelNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPopupCompletion is a wrapper around the C function gtk_entry_completion_get_popup_completion.
func (recv *EntryCompletion) GetPopupCompletion() bool {
	retC := C.gtk_entry_completion_get_popup_completion((*C.GtkEntryCompletion)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPopupSetWidth is a wrapper around the C function gtk_entry_completion_get_popup_set_width.
func (recv *EntryCompletion) GetPopupSetWidth() bool {
	retC := C.gtk_entry_completion_get_popup_set_width((*C.GtkEntryCompletion)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPopupSingleMatch is a wrapper around the C function gtk_entry_completion_get_popup_single_match.
func (recv *EntryCompletion) GetPopupSingleMatch() bool {
	retC := C.gtk_entry_completion_get_popup_single_match((*C.GtkEntryCompletion)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTextColumn is a wrapper around the C function gtk_entry_completion_get_text_column.
func (recv *EntryCompletion) GetTextColumn() int32 {
	retC := C.gtk_entry_completion_get_text_column((*C.GtkEntryCompletion)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// InsertActionMarkup is a wrapper around the C function gtk_entry_completion_insert_action_markup.
func (recv *EntryCompletion) InsertActionMarkup(index int32, markup string) {
	c_index_ := (C.gint)(index)

	c_markup := C.CString(markup)
	defer C.free(unsafe.Pointer(c_markup))

	C.gtk_entry_completion_insert_action_markup((*C.GtkEntryCompletion)(recv.native), c_index_, c_markup)

	return
}

// InsertActionText is a wrapper around the C function gtk_entry_completion_insert_action_text.
func (recv *EntryCompletion) InsertActionText(index int32, text string) {
	c_index_ := (C.gint)(index)

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_entry_completion_insert_action_text((*C.GtkEntryCompletion)(recv.native), c_index_, c_text)

	return
}

// InsertPrefix is a wrapper around the C function gtk_entry_completion_insert_prefix.
func (recv *EntryCompletion) InsertPrefix() {
	C.gtk_entry_completion_insert_prefix((*C.GtkEntryCompletion)(recv.native))

	return
}

// SetInlineCompletion is a wrapper around the C function gtk_entry_completion_set_inline_completion.
func (recv *EntryCompletion) SetInlineCompletion(inlineCompletion bool) {
	c_inline_completion :=
		boolToGboolean(inlineCompletion)

	C.gtk_entry_completion_set_inline_completion((*C.GtkEntryCompletion)(recv.native), c_inline_completion)

	return
}

// SetInlineSelection is a wrapper around the C function gtk_entry_completion_set_inline_selection.
func (recv *EntryCompletion) SetInlineSelection(inlineSelection bool) {
	c_inline_selection :=
		boolToGboolean(inlineSelection)

	C.gtk_entry_completion_set_inline_selection((*C.GtkEntryCompletion)(recv.native), c_inline_selection)

	return
}

// Unsupported : gtk_entry_completion_set_match_func : unsupported parameter func : no type generator for EntryCompletionMatchFunc (GtkEntryCompletionMatchFunc) for param func

// SetMinimumKeyLength is a wrapper around the C function gtk_entry_completion_set_minimum_key_length.
func (recv *EntryCompletion) SetMinimumKeyLength(length int32) {
	c_length := (C.gint)(length)

	C.gtk_entry_completion_set_minimum_key_length((*C.GtkEntryCompletion)(recv.native), c_length)

	return
}

// SetModel is a wrapper around the C function gtk_entry_completion_set_model.
func (recv *EntryCompletion) SetModel(model *TreeModel) {
	c_model := (*C.GtkTreeModel)(model.ToC())

	C.gtk_entry_completion_set_model((*C.GtkEntryCompletion)(recv.native), c_model)

	return
}

// SetPopupCompletion is a wrapper around the C function gtk_entry_completion_set_popup_completion.
func (recv *EntryCompletion) SetPopupCompletion(popupCompletion bool) {
	c_popup_completion :=
		boolToGboolean(popupCompletion)

	C.gtk_entry_completion_set_popup_completion((*C.GtkEntryCompletion)(recv.native), c_popup_completion)

	return
}

// SetPopupSetWidth is a wrapper around the C function gtk_entry_completion_set_popup_set_width.
func (recv *EntryCompletion) SetPopupSetWidth(popupSetWidth bool) {
	c_popup_set_width :=
		boolToGboolean(popupSetWidth)

	C.gtk_entry_completion_set_popup_set_width((*C.GtkEntryCompletion)(recv.native), c_popup_set_width)

	return
}

// SetPopupSingleMatch is a wrapper around the C function gtk_entry_completion_set_popup_single_match.
func (recv *EntryCompletion) SetPopupSingleMatch(popupSingleMatch bool) {
	c_popup_single_match :=
		boolToGboolean(popupSingleMatch)

	C.gtk_entry_completion_set_popup_single_match((*C.GtkEntryCompletion)(recv.native), c_popup_single_match)

	return
}

// SetTextColumn is a wrapper around the C function gtk_entry_completion_set_text_column.
func (recv *EntryCompletion) SetTextColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_entry_completion_set_text_column((*C.GtkEntryCompletion)(recv.native), c_column)

	return
}

// Buildable returns the Buildable interface implemented by EntryCompletion
func (recv *EntryCompletion) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by EntryCompletion
func (recv *EntryCompletion) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Unsupported : EntryIconAccessible : no CType

// EventBox is a wrapper around the C record GtkEventBox.
type EventBox struct {
	native *C.GtkEventBox
	// bin : record
	// Private : priv
}

func EventBoxNewFromC(u unsafe.Pointer) *EventBox {
	c := (*C.GtkEventBox)(u)
	if c == nil {
		return nil
	}

	g := &EventBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EventBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EventBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EventBox with another EventBox, and returns true if they represent the same GObject.
func (recv *EventBox) Equals(other *EventBox) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *EventBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *EventBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *EventBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *EventBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *EventBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to EventBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a EventBox.
func CastToEventBox(object *gobject.Object) *EventBox {
	return EventBoxNewFromC(object.ToC())
}

// EventBoxNew is a wrapper around the C function gtk_event_box_new.
func EventBoxNew() *EventBox {
	retC := C.gtk_event_box_new()
	retGo := EventBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAboveChild is a wrapper around the C function gtk_event_box_get_above_child.
func (recv *EventBox) GetAboveChild() bool {
	retC := C.gtk_event_box_get_above_child((*C.GtkEventBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetVisibleWindow is a wrapper around the C function gtk_event_box_get_visible_window.
func (recv *EventBox) GetVisibleWindow() bool {
	retC := C.gtk_event_box_get_visible_window((*C.GtkEventBox)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetAboveChild is a wrapper around the C function gtk_event_box_set_above_child.
func (recv *EventBox) SetAboveChild(aboveChild bool) {
	c_above_child :=
		boolToGboolean(aboveChild)

	C.gtk_event_box_set_above_child((*C.GtkEventBox)(recv.native), c_above_child)

	return
}

// SetVisibleWindow is a wrapper around the C function gtk_event_box_set_visible_window.
func (recv *EventBox) SetVisibleWindow(visibleWindow bool) {
	c_visible_window :=
		boolToGboolean(visibleWindow)

	C.gtk_event_box_set_visible_window((*C.GtkEventBox)(recv.native), c_visible_window)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by EventBox
func (recv *EventBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by EventBox
func (recv *EventBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// EventController is a wrapper around the C record GtkEventController.
type EventController struct {
	native *C.GtkEventController
}

func EventControllerNewFromC(u unsafe.Pointer) *EventController {
	c := (*C.GtkEventController)(u)
	if c == nil {
		return nil
	}

	g := &EventController{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *EventController) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *EventController) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EventController with another EventController, and returns true if they represent the same GObject.
func (recv *EventController) Equals(other *EventController) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *EventController) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to EventController.
// Exercise care, as this is a potentially dangerous function if the Object is not a EventController.
func CastToEventController(object *gobject.Object) *EventController {
	return EventControllerNewFromC(object.ToC())
}

// Expander is a wrapper around the C record GtkExpander.
type Expander struct {
	native *C.GtkExpander
	// bin : record
	// priv : record
}

func ExpanderNewFromC(u unsafe.Pointer) *Expander {
	c := (*C.GtkExpander)(u)
	if c == nil {
		return nil
	}

	g := &Expander{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Expander) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Expander) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Expander with another Expander, and returns true if they represent the same GObject.
func (recv *Expander) Equals(other *Expander) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Expander) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Expander) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Expander) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Expander) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Expander) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Expander.
// Exercise care, as this is a potentially dangerous function if the Object is not a Expander.
func CastToExpander(object *gobject.Object) *Expander {
	return ExpanderNewFromC(object.ToC())
}

type signalExpanderActivateDetail struct {
	callback  ExpanderSignalActivateCallback
	handlerID C.gulong
}

var signalExpanderActivateId int
var signalExpanderActivateMap = make(map[int]signalExpanderActivateDetail)
var signalExpanderActivateLock sync.RWMutex

// ExpanderSignalActivateCallback is a callback function for a 'activate' signal emitted from a Expander.
type ExpanderSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Expander.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Expander) ConnectActivate(callback ExpanderSignalActivateCallback) int {
	signalExpanderActivateLock.Lock()
	defer signalExpanderActivateLock.Unlock()

	signalExpanderActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Expander_signal_connect_activate(instance, C.gpointer(uintptr(signalExpanderActivateId)))

	detail := signalExpanderActivateDetail{callback, handlerID}
	signalExpanderActivateMap[signalExpanderActivateId] = detail

	return signalExpanderActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Expander.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Expander) DisconnectActivate(connectionID int) {
	signalExpanderActivateLock.Lock()
	defer signalExpanderActivateLock.Unlock()

	detail, exists := signalExpanderActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalExpanderActivateMap, connectionID)
}

//export expander_activateHandler
func expander_activateHandler(_ *C.GObject, data C.gpointer) {
	signalExpanderActivateLock.RLock()
	defer signalExpanderActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalExpanderActivateMap[index].callback
	callback()
}

// ExpanderNew is a wrapper around the C function gtk_expander_new.
func ExpanderNew(label string) *Expander {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_expander_new(c_label)
	retGo := ExpanderNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ExpanderNewWithMnemonic is a wrapper around the C function gtk_expander_new_with_mnemonic.
func ExpanderNewWithMnemonic(label string) *Expander {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_expander_new_with_mnemonic(c_label)
	retGo := ExpanderNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetExpanded is a wrapper around the C function gtk_expander_get_expanded.
func (recv *Expander) GetExpanded() bool {
	retC := C.gtk_expander_get_expanded((*C.GtkExpander)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetLabel is a wrapper around the C function gtk_expander_get_label.
func (recv *Expander) GetLabel() string {
	retC := C.gtk_expander_get_label((*C.GtkExpander)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetLabelWidget is a wrapper around the C function gtk_expander_get_label_widget.
func (recv *Expander) GetLabelWidget() *Widget {
	retC := C.gtk_expander_get_label_widget((*C.GtkExpander)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetSpacing is a wrapper around the C function gtk_expander_get_spacing.
func (recv *Expander) GetSpacing() int32 {
	retC := C.gtk_expander_get_spacing((*C.GtkExpander)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetUseMarkup is a wrapper around the C function gtk_expander_get_use_markup.
func (recv *Expander) GetUseMarkup() bool {
	retC := C.gtk_expander_get_use_markup((*C.GtkExpander)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetUseUnderline is a wrapper around the C function gtk_expander_get_use_underline.
func (recv *Expander) GetUseUnderline() bool {
	retC := C.gtk_expander_get_use_underline((*C.GtkExpander)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetExpanded is a wrapper around the C function gtk_expander_set_expanded.
func (recv *Expander) SetExpanded(expanded bool) {
	c_expanded :=
		boolToGboolean(expanded)

	C.gtk_expander_set_expanded((*C.GtkExpander)(recv.native), c_expanded)

	return
}

// SetLabel is a wrapper around the C function gtk_expander_set_label.
func (recv *Expander) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_expander_set_label((*C.GtkExpander)(recv.native), c_label)

	return
}

// SetLabelWidget is a wrapper around the C function gtk_expander_set_label_widget.
func (recv *Expander) SetLabelWidget(labelWidget *Widget) {
	c_label_widget := (*C.GtkWidget)(C.NULL)
	if labelWidget != nil {
		c_label_widget = (*C.GtkWidget)(labelWidget.ToC())
	}

	C.gtk_expander_set_label_widget((*C.GtkExpander)(recv.native), c_label_widget)

	return
}

// SetSpacing is a wrapper around the C function gtk_expander_set_spacing.
func (recv *Expander) SetSpacing(spacing int32) {
	c_spacing := (C.gint)(spacing)

	C.gtk_expander_set_spacing((*C.GtkExpander)(recv.native), c_spacing)

	return
}

// SetUseMarkup is a wrapper around the C function gtk_expander_set_use_markup.
func (recv *Expander) SetUseMarkup(useMarkup bool) {
	c_use_markup :=
		boolToGboolean(useMarkup)

	C.gtk_expander_set_use_markup((*C.GtkExpander)(recv.native), c_use_markup)

	return
}

// SetUseUnderline is a wrapper around the C function gtk_expander_set_use_underline.
func (recv *Expander) SetUseUnderline(useUnderline bool) {
	c_use_underline :=
		boolToGboolean(useUnderline)

	C.gtk_expander_set_use_underline((*C.GtkExpander)(recv.native), c_use_underline)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Expander
func (recv *Expander) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Expander
func (recv *Expander) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ExpanderAccessible is a wrapper around the C record GtkExpanderAccessible.
type ExpanderAccessible struct {
	native *C.GtkExpanderAccessible
	// parent : record
	// priv : record
}

func ExpanderAccessibleNewFromC(u unsafe.Pointer) *ExpanderAccessible {
	c := (*C.GtkExpanderAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ExpanderAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ExpanderAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ExpanderAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ExpanderAccessible with another ExpanderAccessible, and returns true if they represent the same GObject.
func (recv *ExpanderAccessible) Equals(other *ExpanderAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ExpanderAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ExpanderAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ExpanderAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ExpanderAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ExpanderAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ExpanderAccessible.
func CastToExpanderAccessible(object *gobject.Object) *ExpanderAccessible {
	return ExpanderAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ExpanderAccessible
func (recv *ExpanderAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ExpanderAccessible
func (recv *ExpanderAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// FileChooserButton is a wrapper around the C record GtkFileChooserButton.
type FileChooserButton struct {
	native *C.GtkFileChooserButton
	// parent : record
	// Private : priv
}

func FileChooserButtonNewFromC(u unsafe.Pointer) *FileChooserButton {
	c := (*C.GtkFileChooserButton)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileChooserButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileChooserButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserButton with another FileChooserButton, and returns true if they represent the same GObject.
func (recv *FileChooserButton) Equals(other *FileChooserButton) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *FileChooserButton) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FileChooserButton) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserButton) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserButton) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to FileChooserButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserButton.
func CastToFileChooserButton(object *gobject.Object) *FileChooserButton {
	return FileChooserButtonNewFromC(object.ToC())
}

type signalFileChooserButtonFileSetDetail struct {
	callback  FileChooserButtonSignalFileSetCallback
	handlerID C.gulong
}

var signalFileChooserButtonFileSetId int
var signalFileChooserButtonFileSetMap = make(map[int]signalFileChooserButtonFileSetDetail)
var signalFileChooserButtonFileSetLock sync.RWMutex

// FileChooserButtonSignalFileSetCallback is a callback function for a 'file-set' signal emitted from a FileChooserButton.
type FileChooserButtonSignalFileSetCallback func()

/*
ConnectFileSet connects the callback to the 'file-set' signal for the FileChooserButton.

The returned value represents the connection, and may be passed to DisconnectFileSet to remove it.
*/
func (recv *FileChooserButton) ConnectFileSet(callback FileChooserButtonSignalFileSetCallback) int {
	signalFileChooserButtonFileSetLock.Lock()
	defer signalFileChooserButtonFileSetLock.Unlock()

	signalFileChooserButtonFileSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserButton_signal_connect_file_set(instance, C.gpointer(uintptr(signalFileChooserButtonFileSetId)))

	detail := signalFileChooserButtonFileSetDetail{callback, handlerID}
	signalFileChooserButtonFileSetMap[signalFileChooserButtonFileSetId] = detail

	return signalFileChooserButtonFileSetId
}

/*
DisconnectFileSet disconnects a callback from the 'file-set' signal for the FileChooserButton.

The connectionID should be a value returned from a call to ConnectFileSet.
*/
func (recv *FileChooserButton) DisconnectFileSet(connectionID int) {
	signalFileChooserButtonFileSetLock.Lock()
	defer signalFileChooserButtonFileSetLock.Unlock()

	detail, exists := signalFileChooserButtonFileSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserButtonFileSetMap, connectionID)
}

//export filechooserbutton_fileSetHandler
func filechooserbutton_fileSetHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserButtonFileSetLock.RLock()
	defer signalFileChooserButtonFileSetLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserButtonFileSetMap[index].callback
	callback()
}

// FileChooserButtonNew is a wrapper around the C function gtk_file_chooser_button_new.
func FileChooserButtonNew(title string, action FileChooserAction) *FileChooserButton {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	c_action := (C.GtkFileChooserAction)(action)

	retC := C.gtk_file_chooser_button_new(c_title, c_action)
	retGo := FileChooserButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// FileChooserButtonNewWithDialog is a wrapper around the C function gtk_file_chooser_button_new_with_dialog.
func FileChooserButtonNewWithDialog(dialog *Dialog) *FileChooserButton {
	c_dialog := (*C.GtkWidget)(C.NULL)
	if dialog != nil {
		c_dialog = (*C.GtkWidget)(dialog.ToC())
	}

	retC := C.gtk_file_chooser_button_new_with_dialog(c_dialog)
	retGo := FileChooserButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFocusOnClick is a wrapper around the C function gtk_file_chooser_button_get_focus_on_click.
func (recv *FileChooserButton) GetFocusOnClick() bool {
	retC := C.gtk_file_chooser_button_get_focus_on_click((*C.GtkFileChooserButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTitle is a wrapper around the C function gtk_file_chooser_button_get_title.
func (recv *FileChooserButton) GetTitle() string {
	retC := C.gtk_file_chooser_button_get_title((*C.GtkFileChooserButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetWidthChars is a wrapper around the C function gtk_file_chooser_button_get_width_chars.
func (recv *FileChooserButton) GetWidthChars() int32 {
	retC := C.gtk_file_chooser_button_get_width_chars((*C.GtkFileChooserButton)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// SetFocusOnClick is a wrapper around the C function gtk_file_chooser_button_set_focus_on_click.
func (recv *FileChooserButton) SetFocusOnClick(focusOnClick bool) {
	c_focus_on_click :=
		boolToGboolean(focusOnClick)

	C.gtk_file_chooser_button_set_focus_on_click((*C.GtkFileChooserButton)(recv.native), c_focus_on_click)

	return
}

// SetTitle is a wrapper around the C function gtk_file_chooser_button_set_title.
func (recv *FileChooserButton) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_file_chooser_button_set_title((*C.GtkFileChooserButton)(recv.native), c_title)

	return
}

// SetWidthChars is a wrapper around the C function gtk_file_chooser_button_set_width_chars.
func (recv *FileChooserButton) SetWidthChars(nChars int32) {
	c_n_chars := (C.gint)(nChars)

	C.gtk_file_chooser_button_set_width_chars((*C.GtkFileChooserButton)(recv.native), c_n_chars)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserButton
func (recv *FileChooserButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserButton
func (recv *FileChooserButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserButton
func (recv *FileChooserButton) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FileChooserButton
func (recv *FileChooserButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FileChooserDialog is a wrapper around the C record GtkFileChooserDialog.
type FileChooserDialog struct {
	native *C.GtkFileChooserDialog
	// parent_instance : record
	// priv : record
}

func FileChooserDialogNewFromC(u unsafe.Pointer) *FileChooserDialog {
	c := (*C.GtkFileChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserDialog with another FileChooserDialog, and returns true if they represent the same GObject.
func (recv *FileChooserDialog) Equals(other *FileChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *FileChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FileChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FileChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FileChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to FileChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserDialog.
func CastToFileChooserDialog(object *gobject.Object) *FileChooserDialog {
	return FileChooserDialogNewFromC(object.ToC())
}

// Unsupported : gtk_file_chooser_dialog_new : unsupported parameter ... : varargs

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserDialog
func (recv *FileChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserDialog
func (recv *FileChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserDialog
func (recv *FileChooserDialog) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// FileChooserWidget is a wrapper around the C record GtkFileChooserWidget.
type FileChooserWidget struct {
	native *C.GtkFileChooserWidget
	// parent_instance : record
	// priv : record
}

func FileChooserWidgetNewFromC(u unsafe.Pointer) *FileChooserWidget {
	c := (*C.GtkFileChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserWidget with another FileChooserWidget, and returns true if they represent the same GObject.
func (recv *FileChooserWidget) Equals(other *FileChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *FileChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FileChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FileChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FileChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to FileChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileChooserWidget.
func CastToFileChooserWidget(object *gobject.Object) *FileChooserWidget {
	return FileChooserWidgetNewFromC(object.ToC())
}

type signalFileChooserWidgetDesktopFolderDetail struct {
	callback  FileChooserWidgetSignalDesktopFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetDesktopFolderId int
var signalFileChooserWidgetDesktopFolderMap = make(map[int]signalFileChooserWidgetDesktopFolderDetail)
var signalFileChooserWidgetDesktopFolderLock sync.RWMutex

// FileChooserWidgetSignalDesktopFolderCallback is a callback function for a 'desktop-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalDesktopFolderCallback func()

/*
ConnectDesktopFolder connects the callback to the 'desktop-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectDesktopFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectDesktopFolder(callback FileChooserWidgetSignalDesktopFolderCallback) int {
	signalFileChooserWidgetDesktopFolderLock.Lock()
	defer signalFileChooserWidgetDesktopFolderLock.Unlock()

	signalFileChooserWidgetDesktopFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_desktop_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetDesktopFolderId)))

	detail := signalFileChooserWidgetDesktopFolderDetail{callback, handlerID}
	signalFileChooserWidgetDesktopFolderMap[signalFileChooserWidgetDesktopFolderId] = detail

	return signalFileChooserWidgetDesktopFolderId
}

/*
DisconnectDesktopFolder disconnects a callback from the 'desktop-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectDesktopFolder.
*/
func (recv *FileChooserWidget) DisconnectDesktopFolder(connectionID int) {
	signalFileChooserWidgetDesktopFolderLock.Lock()
	defer signalFileChooserWidgetDesktopFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetDesktopFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetDesktopFolderMap, connectionID)
}

//export filechooserwidget_desktopFolderHandler
func filechooserwidget_desktopFolderHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetDesktopFolderLock.RLock()
	defer signalFileChooserWidgetDesktopFolderLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetDesktopFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetDownFolderDetail struct {
	callback  FileChooserWidgetSignalDownFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetDownFolderId int
var signalFileChooserWidgetDownFolderMap = make(map[int]signalFileChooserWidgetDownFolderDetail)
var signalFileChooserWidgetDownFolderLock sync.RWMutex

// FileChooserWidgetSignalDownFolderCallback is a callback function for a 'down-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalDownFolderCallback func()

/*
ConnectDownFolder connects the callback to the 'down-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectDownFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectDownFolder(callback FileChooserWidgetSignalDownFolderCallback) int {
	signalFileChooserWidgetDownFolderLock.Lock()
	defer signalFileChooserWidgetDownFolderLock.Unlock()

	signalFileChooserWidgetDownFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_down_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetDownFolderId)))

	detail := signalFileChooserWidgetDownFolderDetail{callback, handlerID}
	signalFileChooserWidgetDownFolderMap[signalFileChooserWidgetDownFolderId] = detail

	return signalFileChooserWidgetDownFolderId
}

/*
DisconnectDownFolder disconnects a callback from the 'down-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectDownFolder.
*/
func (recv *FileChooserWidget) DisconnectDownFolder(connectionID int) {
	signalFileChooserWidgetDownFolderLock.Lock()
	defer signalFileChooserWidgetDownFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetDownFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetDownFolderMap, connectionID)
}

//export filechooserwidget_downFolderHandler
func filechooserwidget_downFolderHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetDownFolderLock.RLock()
	defer signalFileChooserWidgetDownFolderLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetDownFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetHomeFolderDetail struct {
	callback  FileChooserWidgetSignalHomeFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetHomeFolderId int
var signalFileChooserWidgetHomeFolderMap = make(map[int]signalFileChooserWidgetHomeFolderDetail)
var signalFileChooserWidgetHomeFolderLock sync.RWMutex

// FileChooserWidgetSignalHomeFolderCallback is a callback function for a 'home-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalHomeFolderCallback func()

/*
ConnectHomeFolder connects the callback to the 'home-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectHomeFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectHomeFolder(callback FileChooserWidgetSignalHomeFolderCallback) int {
	signalFileChooserWidgetHomeFolderLock.Lock()
	defer signalFileChooserWidgetHomeFolderLock.Unlock()

	signalFileChooserWidgetHomeFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_home_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetHomeFolderId)))

	detail := signalFileChooserWidgetHomeFolderDetail{callback, handlerID}
	signalFileChooserWidgetHomeFolderMap[signalFileChooserWidgetHomeFolderId] = detail

	return signalFileChooserWidgetHomeFolderId
}

/*
DisconnectHomeFolder disconnects a callback from the 'home-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectHomeFolder.
*/
func (recv *FileChooserWidget) DisconnectHomeFolder(connectionID int) {
	signalFileChooserWidgetHomeFolderLock.Lock()
	defer signalFileChooserWidgetHomeFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetHomeFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetHomeFolderMap, connectionID)
}

//export filechooserwidget_homeFolderHandler
func filechooserwidget_homeFolderHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetHomeFolderLock.RLock()
	defer signalFileChooserWidgetHomeFolderLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetHomeFolderMap[index].callback
	callback()
}

type signalFileChooserWidgetLocationPopupDetail struct {
	callback  FileChooserWidgetSignalLocationPopupCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationPopupId int
var signalFileChooserWidgetLocationPopupMap = make(map[int]signalFileChooserWidgetLocationPopupDetail)
var signalFileChooserWidgetLocationPopupLock sync.RWMutex

// FileChooserWidgetSignalLocationPopupCallback is a callback function for a 'location-popup' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationPopupCallback func(path string)

/*
ConnectLocationPopup connects the callback to the 'location-popup' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationPopup to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationPopup(callback FileChooserWidgetSignalLocationPopupCallback) int {
	signalFileChooserWidgetLocationPopupLock.Lock()
	defer signalFileChooserWidgetLocationPopupLock.Unlock()

	signalFileChooserWidgetLocationPopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_popup(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationPopupId)))

	detail := signalFileChooserWidgetLocationPopupDetail{callback, handlerID}
	signalFileChooserWidgetLocationPopupMap[signalFileChooserWidgetLocationPopupId] = detail

	return signalFileChooserWidgetLocationPopupId
}

/*
DisconnectLocationPopup disconnects a callback from the 'location-popup' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationPopup.
*/
func (recv *FileChooserWidget) DisconnectLocationPopup(connectionID int) {
	signalFileChooserWidgetLocationPopupLock.Lock()
	defer signalFileChooserWidgetLocationPopupLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationPopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationPopupMap, connectionID)
}

//export filechooserwidget_locationPopupHandler
func filechooserwidget_locationPopupHandler(_ *C.GObject, c_path *C.gchar, data C.gpointer) {
	signalFileChooserWidgetLocationPopupLock.RLock()
	defer signalFileChooserWidgetLocationPopupLock.RUnlock()

	path := C.GoString(c_path)

	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationPopupMap[index].callback
	callback(path)
}

type signalFileChooserWidgetLocationPopupOnPasteDetail struct {
	callback  FileChooserWidgetSignalLocationPopupOnPasteCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationPopupOnPasteId int
var signalFileChooserWidgetLocationPopupOnPasteMap = make(map[int]signalFileChooserWidgetLocationPopupOnPasteDetail)
var signalFileChooserWidgetLocationPopupOnPasteLock sync.RWMutex

// FileChooserWidgetSignalLocationPopupOnPasteCallback is a callback function for a 'location-popup-on-paste' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationPopupOnPasteCallback func()

/*
ConnectLocationPopupOnPaste connects the callback to the 'location-popup-on-paste' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationPopupOnPaste to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationPopupOnPaste(callback FileChooserWidgetSignalLocationPopupOnPasteCallback) int {
	signalFileChooserWidgetLocationPopupOnPasteLock.Lock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.Unlock()

	signalFileChooserWidgetLocationPopupOnPasteId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_popup_on_paste(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationPopupOnPasteId)))

	detail := signalFileChooserWidgetLocationPopupOnPasteDetail{callback, handlerID}
	signalFileChooserWidgetLocationPopupOnPasteMap[signalFileChooserWidgetLocationPopupOnPasteId] = detail

	return signalFileChooserWidgetLocationPopupOnPasteId
}

/*
DisconnectLocationPopupOnPaste disconnects a callback from the 'location-popup-on-paste' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationPopupOnPaste.
*/
func (recv *FileChooserWidget) DisconnectLocationPopupOnPaste(connectionID int) {
	signalFileChooserWidgetLocationPopupOnPasteLock.Lock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationPopupOnPasteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationPopupOnPasteMap, connectionID)
}

//export filechooserwidget_locationPopupOnPasteHandler
func filechooserwidget_locationPopupOnPasteHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetLocationPopupOnPasteLock.RLock()
	defer signalFileChooserWidgetLocationPopupOnPasteLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationPopupOnPasteMap[index].callback
	callback()
}

type signalFileChooserWidgetLocationTogglePopupDetail struct {
	callback  FileChooserWidgetSignalLocationTogglePopupCallback
	handlerID C.gulong
}

var signalFileChooserWidgetLocationTogglePopupId int
var signalFileChooserWidgetLocationTogglePopupMap = make(map[int]signalFileChooserWidgetLocationTogglePopupDetail)
var signalFileChooserWidgetLocationTogglePopupLock sync.RWMutex

// FileChooserWidgetSignalLocationTogglePopupCallback is a callback function for a 'location-toggle-popup' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalLocationTogglePopupCallback func()

/*
ConnectLocationTogglePopup connects the callback to the 'location-toggle-popup' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectLocationTogglePopup to remove it.
*/
func (recv *FileChooserWidget) ConnectLocationTogglePopup(callback FileChooserWidgetSignalLocationTogglePopupCallback) int {
	signalFileChooserWidgetLocationTogglePopupLock.Lock()
	defer signalFileChooserWidgetLocationTogglePopupLock.Unlock()

	signalFileChooserWidgetLocationTogglePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_location_toggle_popup(instance, C.gpointer(uintptr(signalFileChooserWidgetLocationTogglePopupId)))

	detail := signalFileChooserWidgetLocationTogglePopupDetail{callback, handlerID}
	signalFileChooserWidgetLocationTogglePopupMap[signalFileChooserWidgetLocationTogglePopupId] = detail

	return signalFileChooserWidgetLocationTogglePopupId
}

/*
DisconnectLocationTogglePopup disconnects a callback from the 'location-toggle-popup' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectLocationTogglePopup.
*/
func (recv *FileChooserWidget) DisconnectLocationTogglePopup(connectionID int) {
	signalFileChooserWidgetLocationTogglePopupLock.Lock()
	defer signalFileChooserWidgetLocationTogglePopupLock.Unlock()

	detail, exists := signalFileChooserWidgetLocationTogglePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetLocationTogglePopupMap, connectionID)
}

//export filechooserwidget_locationTogglePopupHandler
func filechooserwidget_locationTogglePopupHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetLocationTogglePopupLock.RLock()
	defer signalFileChooserWidgetLocationTogglePopupLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetLocationTogglePopupMap[index].callback
	callback()
}

type signalFileChooserWidgetPlacesShortcutDetail struct {
	callback  FileChooserWidgetSignalPlacesShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetPlacesShortcutId int
var signalFileChooserWidgetPlacesShortcutMap = make(map[int]signalFileChooserWidgetPlacesShortcutDetail)
var signalFileChooserWidgetPlacesShortcutLock sync.RWMutex

// FileChooserWidgetSignalPlacesShortcutCallback is a callback function for a 'places-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalPlacesShortcutCallback func()

/*
ConnectPlacesShortcut connects the callback to the 'places-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectPlacesShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectPlacesShortcut(callback FileChooserWidgetSignalPlacesShortcutCallback) int {
	signalFileChooserWidgetPlacesShortcutLock.Lock()
	defer signalFileChooserWidgetPlacesShortcutLock.Unlock()

	signalFileChooserWidgetPlacesShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_places_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetPlacesShortcutId)))

	detail := signalFileChooserWidgetPlacesShortcutDetail{callback, handlerID}
	signalFileChooserWidgetPlacesShortcutMap[signalFileChooserWidgetPlacesShortcutId] = detail

	return signalFileChooserWidgetPlacesShortcutId
}

/*
DisconnectPlacesShortcut disconnects a callback from the 'places-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectPlacesShortcut.
*/
func (recv *FileChooserWidget) DisconnectPlacesShortcut(connectionID int) {
	signalFileChooserWidgetPlacesShortcutLock.Lock()
	defer signalFileChooserWidgetPlacesShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetPlacesShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetPlacesShortcutMap, connectionID)
}

//export filechooserwidget_placesShortcutHandler
func filechooserwidget_placesShortcutHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetPlacesShortcutLock.RLock()
	defer signalFileChooserWidgetPlacesShortcutLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetPlacesShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetQuickBookmarkDetail struct {
	callback  FileChooserWidgetSignalQuickBookmarkCallback
	handlerID C.gulong
}

var signalFileChooserWidgetQuickBookmarkId int
var signalFileChooserWidgetQuickBookmarkMap = make(map[int]signalFileChooserWidgetQuickBookmarkDetail)
var signalFileChooserWidgetQuickBookmarkLock sync.RWMutex

// FileChooserWidgetSignalQuickBookmarkCallback is a callback function for a 'quick-bookmark' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalQuickBookmarkCallback func(bookmarkIndex int32)

/*
ConnectQuickBookmark connects the callback to the 'quick-bookmark' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectQuickBookmark to remove it.
*/
func (recv *FileChooserWidget) ConnectQuickBookmark(callback FileChooserWidgetSignalQuickBookmarkCallback) int {
	signalFileChooserWidgetQuickBookmarkLock.Lock()
	defer signalFileChooserWidgetQuickBookmarkLock.Unlock()

	signalFileChooserWidgetQuickBookmarkId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_quick_bookmark(instance, C.gpointer(uintptr(signalFileChooserWidgetQuickBookmarkId)))

	detail := signalFileChooserWidgetQuickBookmarkDetail{callback, handlerID}
	signalFileChooserWidgetQuickBookmarkMap[signalFileChooserWidgetQuickBookmarkId] = detail

	return signalFileChooserWidgetQuickBookmarkId
}

/*
DisconnectQuickBookmark disconnects a callback from the 'quick-bookmark' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectQuickBookmark.
*/
func (recv *FileChooserWidget) DisconnectQuickBookmark(connectionID int) {
	signalFileChooserWidgetQuickBookmarkLock.Lock()
	defer signalFileChooserWidgetQuickBookmarkLock.Unlock()

	detail, exists := signalFileChooserWidgetQuickBookmarkMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetQuickBookmarkMap, connectionID)
}

//export filechooserwidget_quickBookmarkHandler
func filechooserwidget_quickBookmarkHandler(_ *C.GObject, c_bookmark_index C.gint, data C.gpointer) {
	signalFileChooserWidgetQuickBookmarkLock.RLock()
	defer signalFileChooserWidgetQuickBookmarkLock.RUnlock()

	bookmarkIndex := int32(c_bookmark_index)

	index := int(uintptr(data))
	callback := signalFileChooserWidgetQuickBookmarkMap[index].callback
	callback(bookmarkIndex)
}

type signalFileChooserWidgetRecentShortcutDetail struct {
	callback  FileChooserWidgetSignalRecentShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetRecentShortcutId int
var signalFileChooserWidgetRecentShortcutMap = make(map[int]signalFileChooserWidgetRecentShortcutDetail)
var signalFileChooserWidgetRecentShortcutLock sync.RWMutex

// FileChooserWidgetSignalRecentShortcutCallback is a callback function for a 'recent-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalRecentShortcutCallback func()

/*
ConnectRecentShortcut connects the callback to the 'recent-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectRecentShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectRecentShortcut(callback FileChooserWidgetSignalRecentShortcutCallback) int {
	signalFileChooserWidgetRecentShortcutLock.Lock()
	defer signalFileChooserWidgetRecentShortcutLock.Unlock()

	signalFileChooserWidgetRecentShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_recent_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetRecentShortcutId)))

	detail := signalFileChooserWidgetRecentShortcutDetail{callback, handlerID}
	signalFileChooserWidgetRecentShortcutMap[signalFileChooserWidgetRecentShortcutId] = detail

	return signalFileChooserWidgetRecentShortcutId
}

/*
DisconnectRecentShortcut disconnects a callback from the 'recent-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectRecentShortcut.
*/
func (recv *FileChooserWidget) DisconnectRecentShortcut(connectionID int) {
	signalFileChooserWidgetRecentShortcutLock.Lock()
	defer signalFileChooserWidgetRecentShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetRecentShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetRecentShortcutMap, connectionID)
}

//export filechooserwidget_recentShortcutHandler
func filechooserwidget_recentShortcutHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetRecentShortcutLock.RLock()
	defer signalFileChooserWidgetRecentShortcutLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetRecentShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetSearchShortcutDetail struct {
	callback  FileChooserWidgetSignalSearchShortcutCallback
	handlerID C.gulong
}

var signalFileChooserWidgetSearchShortcutId int
var signalFileChooserWidgetSearchShortcutMap = make(map[int]signalFileChooserWidgetSearchShortcutDetail)
var signalFileChooserWidgetSearchShortcutLock sync.RWMutex

// FileChooserWidgetSignalSearchShortcutCallback is a callback function for a 'search-shortcut' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalSearchShortcutCallback func()

/*
ConnectSearchShortcut connects the callback to the 'search-shortcut' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectSearchShortcut to remove it.
*/
func (recv *FileChooserWidget) ConnectSearchShortcut(callback FileChooserWidgetSignalSearchShortcutCallback) int {
	signalFileChooserWidgetSearchShortcutLock.Lock()
	defer signalFileChooserWidgetSearchShortcutLock.Unlock()

	signalFileChooserWidgetSearchShortcutId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_search_shortcut(instance, C.gpointer(uintptr(signalFileChooserWidgetSearchShortcutId)))

	detail := signalFileChooserWidgetSearchShortcutDetail{callback, handlerID}
	signalFileChooserWidgetSearchShortcutMap[signalFileChooserWidgetSearchShortcutId] = detail

	return signalFileChooserWidgetSearchShortcutId
}

/*
DisconnectSearchShortcut disconnects a callback from the 'search-shortcut' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectSearchShortcut.
*/
func (recv *FileChooserWidget) DisconnectSearchShortcut(connectionID int) {
	signalFileChooserWidgetSearchShortcutLock.Lock()
	defer signalFileChooserWidgetSearchShortcutLock.Unlock()

	detail, exists := signalFileChooserWidgetSearchShortcutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetSearchShortcutMap, connectionID)
}

//export filechooserwidget_searchShortcutHandler
func filechooserwidget_searchShortcutHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetSearchShortcutLock.RLock()
	defer signalFileChooserWidgetSearchShortcutLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetSearchShortcutMap[index].callback
	callback()
}

type signalFileChooserWidgetShowHiddenDetail struct {
	callback  FileChooserWidgetSignalShowHiddenCallback
	handlerID C.gulong
}

var signalFileChooserWidgetShowHiddenId int
var signalFileChooserWidgetShowHiddenMap = make(map[int]signalFileChooserWidgetShowHiddenDetail)
var signalFileChooserWidgetShowHiddenLock sync.RWMutex

// FileChooserWidgetSignalShowHiddenCallback is a callback function for a 'show-hidden' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalShowHiddenCallback func()

/*
ConnectShowHidden connects the callback to the 'show-hidden' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectShowHidden to remove it.
*/
func (recv *FileChooserWidget) ConnectShowHidden(callback FileChooserWidgetSignalShowHiddenCallback) int {
	signalFileChooserWidgetShowHiddenLock.Lock()
	defer signalFileChooserWidgetShowHiddenLock.Unlock()

	signalFileChooserWidgetShowHiddenId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_show_hidden(instance, C.gpointer(uintptr(signalFileChooserWidgetShowHiddenId)))

	detail := signalFileChooserWidgetShowHiddenDetail{callback, handlerID}
	signalFileChooserWidgetShowHiddenMap[signalFileChooserWidgetShowHiddenId] = detail

	return signalFileChooserWidgetShowHiddenId
}

/*
DisconnectShowHidden disconnects a callback from the 'show-hidden' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectShowHidden.
*/
func (recv *FileChooserWidget) DisconnectShowHidden(connectionID int) {
	signalFileChooserWidgetShowHiddenLock.Lock()
	defer signalFileChooserWidgetShowHiddenLock.Unlock()

	detail, exists := signalFileChooserWidgetShowHiddenMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetShowHiddenMap, connectionID)
}

//export filechooserwidget_showHiddenHandler
func filechooserwidget_showHiddenHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetShowHiddenLock.RLock()
	defer signalFileChooserWidgetShowHiddenLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetShowHiddenMap[index].callback
	callback()
}

type signalFileChooserWidgetUpFolderDetail struct {
	callback  FileChooserWidgetSignalUpFolderCallback
	handlerID C.gulong
}

var signalFileChooserWidgetUpFolderId int
var signalFileChooserWidgetUpFolderMap = make(map[int]signalFileChooserWidgetUpFolderDetail)
var signalFileChooserWidgetUpFolderLock sync.RWMutex

// FileChooserWidgetSignalUpFolderCallback is a callback function for a 'up-folder' signal emitted from a FileChooserWidget.
type FileChooserWidgetSignalUpFolderCallback func()

/*
ConnectUpFolder connects the callback to the 'up-folder' signal for the FileChooserWidget.

The returned value represents the connection, and may be passed to DisconnectUpFolder to remove it.
*/
func (recv *FileChooserWidget) ConnectUpFolder(callback FileChooserWidgetSignalUpFolderCallback) int {
	signalFileChooserWidgetUpFolderLock.Lock()
	defer signalFileChooserWidgetUpFolderLock.Unlock()

	signalFileChooserWidgetUpFolderId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooserWidget_signal_connect_up_folder(instance, C.gpointer(uintptr(signalFileChooserWidgetUpFolderId)))

	detail := signalFileChooserWidgetUpFolderDetail{callback, handlerID}
	signalFileChooserWidgetUpFolderMap[signalFileChooserWidgetUpFolderId] = detail

	return signalFileChooserWidgetUpFolderId
}

/*
DisconnectUpFolder disconnects a callback from the 'up-folder' signal for the FileChooserWidget.

The connectionID should be a value returned from a call to ConnectUpFolder.
*/
func (recv *FileChooserWidget) DisconnectUpFolder(connectionID int) {
	signalFileChooserWidgetUpFolderLock.Lock()
	defer signalFileChooserWidgetUpFolderLock.Unlock()

	detail, exists := signalFileChooserWidgetUpFolderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserWidgetUpFolderMap, connectionID)
}

//export filechooserwidget_upFolderHandler
func filechooserwidget_upFolderHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserWidgetUpFolderLock.RLock()
	defer signalFileChooserWidgetUpFolderLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserWidgetUpFolderMap[index].callback
	callback()
}

// FileChooserWidgetNew is a wrapper around the C function gtk_file_chooser_widget_new.
func FileChooserWidgetNew(action FileChooserAction) *FileChooserWidget {
	c_action := (C.GtkFileChooserAction)(action)

	retC := C.gtk_file_chooser_widget_new(c_action)
	retGo := FileChooserWidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by FileChooserWidget
func (recv *FileChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FileChooserWidget
func (recv *FileChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FileChooser returns the FileChooser interface implemented by FileChooserWidget
func (recv *FileChooserWidget) FileChooser() *FileChooser {
	return FileChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FileChooserWidget
func (recv *FileChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FileFilter is a wrapper around the C record GtkFileFilter.
type FileFilter struct {
	native *C.GtkFileFilter
}

func FileFilterNewFromC(u unsafe.Pointer) *FileFilter {
	c := (*C.GtkFileFilter)(u)
	if c == nil {
		return nil
	}

	g := &FileFilter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FileFilter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FileFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileFilter with another FileFilter, and returns true if they represent the same GObject.
func (recv *FileFilter) Equals(other *FileFilter) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FileFilter) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *FileFilter) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to FileFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a FileFilter.
func CastToFileFilter(object *gobject.Object) *FileFilter {
	return FileFilterNewFromC(object.ToC())
}

// FileFilterNew is a wrapper around the C function gtk_file_filter_new.
func FileFilterNew() *FileFilter {
	retC := C.gtk_file_filter_new()
	retGo := FileFilterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_file_filter_add_custom : unsupported parameter func : no type generator for FileFilterFunc (GtkFileFilterFunc) for param func

// AddMimeType is a wrapper around the C function gtk_file_filter_add_mime_type.
func (recv *FileFilter) AddMimeType(mimeType string) {
	c_mime_type := C.CString(mimeType)
	defer C.free(unsafe.Pointer(c_mime_type))

	C.gtk_file_filter_add_mime_type((*C.GtkFileFilter)(recv.native), c_mime_type)

	return
}

// AddPattern is a wrapper around the C function gtk_file_filter_add_pattern.
func (recv *FileFilter) AddPattern(pattern string) {
	c_pattern := C.CString(pattern)
	defer C.free(unsafe.Pointer(c_pattern))

	C.gtk_file_filter_add_pattern((*C.GtkFileFilter)(recv.native), c_pattern)

	return
}

// AddPixbufFormats is a wrapper around the C function gtk_file_filter_add_pixbuf_formats.
func (recv *FileFilter) AddPixbufFormats() {
	C.gtk_file_filter_add_pixbuf_formats((*C.GtkFileFilter)(recv.native))

	return
}

// Filter is a wrapper around the C function gtk_file_filter_filter.
func (recv *FileFilter) Filter(filterInfo *FileFilterInfo) bool {
	c_filter_info := (*C.GtkFileFilterInfo)(C.NULL)
	if filterInfo != nil {
		c_filter_info = (*C.GtkFileFilterInfo)(filterInfo.ToC())
	}

	retC := C.gtk_file_filter_filter((*C.GtkFileFilter)(recv.native), c_filter_info)
	retGo := retC == C.TRUE

	return retGo
}

// GetName is a wrapper around the C function gtk_file_filter_get_name.
func (recv *FileFilter) GetName() string {
	retC := C.gtk_file_filter_get_name((*C.GtkFileFilter)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetNeeded is a wrapper around the C function gtk_file_filter_get_needed.
func (recv *FileFilter) GetNeeded() FileFilterFlags {
	retC := C.gtk_file_filter_get_needed((*C.GtkFileFilter)(recv.native))
	retGo := (FileFilterFlags)(retC)

	return retGo
}

// SetName is a wrapper around the C function gtk_file_filter_set_name.
func (recv *FileFilter) SetName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_file_filter_set_name((*C.GtkFileFilter)(recv.native), c_name)

	return
}

// Buildable returns the Buildable interface implemented by FileFilter
func (recv *FileFilter) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Fixed is a wrapper around the C record GtkFixed.
type Fixed struct {
	native *C.GtkFixed
	// container : record
	// Private : priv
}

func FixedNewFromC(u unsafe.Pointer) *Fixed {
	c := (*C.GtkFixed)(u)
	if c == nil {
		return nil
	}

	g := &Fixed{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Fixed) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Fixed) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Fixed with another Fixed, and returns true if they represent the same GObject.
func (recv *Fixed) Equals(other *Fixed) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Fixed) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Fixed) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Fixed) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Fixed) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Fixed.
// Exercise care, as this is a potentially dangerous function if the Object is not a Fixed.
func CastToFixed(object *gobject.Object) *Fixed {
	return FixedNewFromC(object.ToC())
}

// FixedNew is a wrapper around the C function gtk_fixed_new.
func FixedNew() *Fixed {
	retC := C.gtk_fixed_new()
	retGo := FixedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Move is a wrapper around the C function gtk_fixed_move.
func (recv *Fixed) Move(widget *Widget, x int32, y int32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_fixed_move((*C.GtkFixed)(recv.native), c_widget, c_x, c_y)

	return
}

// Put is a wrapper around the C function gtk_fixed_put.
func (recv *Fixed) Put(widget *Widget, x int32, y int32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_fixed_put((*C.GtkFixed)(recv.native), c_widget, c_x, c_y)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Fixed
func (recv *Fixed) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Fixed
func (recv *Fixed) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FlowBox is a wrapper around the C record GtkFlowBox.
type FlowBox struct {
	native *C.GtkFlowBox
	// container : record
}

func FlowBoxNewFromC(u unsafe.Pointer) *FlowBox {
	c := (*C.GtkFlowBox)(u)
	if c == nil {
		return nil
	}

	g := &FlowBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FlowBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FlowBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBox with another FlowBox, and returns true if they represent the same GObject.
func (recv *FlowBox) Equals(other *FlowBox) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *FlowBox) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *FlowBox) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FlowBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FlowBox) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to FlowBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBox.
func CastToFlowBox(object *gobject.Object) *FlowBox {
	return FlowBoxNewFromC(object.ToC())
}

type signalFlowBoxActivateCursorChildDetail struct {
	callback  FlowBoxSignalActivateCursorChildCallback
	handlerID C.gulong
}

var signalFlowBoxActivateCursorChildId int
var signalFlowBoxActivateCursorChildMap = make(map[int]signalFlowBoxActivateCursorChildDetail)
var signalFlowBoxActivateCursorChildLock sync.RWMutex

// FlowBoxSignalActivateCursorChildCallback is a callback function for a 'activate-cursor-child' signal emitted from a FlowBox.
type FlowBoxSignalActivateCursorChildCallback func()

/*
ConnectActivateCursorChild connects the callback to the 'activate-cursor-child' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectActivateCursorChild to remove it.
*/
func (recv *FlowBox) ConnectActivateCursorChild(callback FlowBoxSignalActivateCursorChildCallback) int {
	signalFlowBoxActivateCursorChildLock.Lock()
	defer signalFlowBoxActivateCursorChildLock.Unlock()

	signalFlowBoxActivateCursorChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_activate_cursor_child(instance, C.gpointer(uintptr(signalFlowBoxActivateCursorChildId)))

	detail := signalFlowBoxActivateCursorChildDetail{callback, handlerID}
	signalFlowBoxActivateCursorChildMap[signalFlowBoxActivateCursorChildId] = detail

	return signalFlowBoxActivateCursorChildId
}

/*
DisconnectActivateCursorChild disconnects a callback from the 'activate-cursor-child' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectActivateCursorChild.
*/
func (recv *FlowBox) DisconnectActivateCursorChild(connectionID int) {
	signalFlowBoxActivateCursorChildLock.Lock()
	defer signalFlowBoxActivateCursorChildLock.Unlock()

	detail, exists := signalFlowBoxActivateCursorChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxActivateCursorChildMap, connectionID)
}

//export flowbox_activateCursorChildHandler
func flowbox_activateCursorChildHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxActivateCursorChildLock.RLock()
	defer signalFlowBoxActivateCursorChildLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxActivateCursorChildMap[index].callback
	callback()
}

type signalFlowBoxChildActivatedDetail struct {
	callback  FlowBoxSignalChildActivatedCallback
	handlerID C.gulong
}

var signalFlowBoxChildActivatedId int
var signalFlowBoxChildActivatedMap = make(map[int]signalFlowBoxChildActivatedDetail)
var signalFlowBoxChildActivatedLock sync.RWMutex

// FlowBoxSignalChildActivatedCallback is a callback function for a 'child-activated' signal emitted from a FlowBox.
type FlowBoxSignalChildActivatedCallback func(child *FlowBoxChild)

/*
ConnectChildActivated connects the callback to the 'child-activated' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectChildActivated to remove it.
*/
func (recv *FlowBox) ConnectChildActivated(callback FlowBoxSignalChildActivatedCallback) int {
	signalFlowBoxChildActivatedLock.Lock()
	defer signalFlowBoxChildActivatedLock.Unlock()

	signalFlowBoxChildActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_child_activated(instance, C.gpointer(uintptr(signalFlowBoxChildActivatedId)))

	detail := signalFlowBoxChildActivatedDetail{callback, handlerID}
	signalFlowBoxChildActivatedMap[signalFlowBoxChildActivatedId] = detail

	return signalFlowBoxChildActivatedId
}

/*
DisconnectChildActivated disconnects a callback from the 'child-activated' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectChildActivated.
*/
func (recv *FlowBox) DisconnectChildActivated(connectionID int) {
	signalFlowBoxChildActivatedLock.Lock()
	defer signalFlowBoxChildActivatedLock.Unlock()

	detail, exists := signalFlowBoxChildActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxChildActivatedMap, connectionID)
}

//export flowbox_childActivatedHandler
func flowbox_childActivatedHandler(_ *C.GObject, c_child *C.GtkFlowBoxChild, data C.gpointer) {
	signalFlowBoxChildActivatedLock.RLock()
	defer signalFlowBoxChildActivatedLock.RUnlock()

	child := FlowBoxChildNewFromC(unsafe.Pointer(c_child))

	index := int(uintptr(data))
	callback := signalFlowBoxChildActivatedMap[index].callback
	callback(child)
}

type signalFlowBoxMoveCursorDetail struct {
	callback  FlowBoxSignalMoveCursorCallback
	handlerID C.gulong
}

var signalFlowBoxMoveCursorId int
var signalFlowBoxMoveCursorMap = make(map[int]signalFlowBoxMoveCursorDetail)
var signalFlowBoxMoveCursorLock sync.RWMutex

// FlowBoxSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a FlowBox.
type FlowBoxSignalMoveCursorCallback func(step MovementStep, count int32) bool

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *FlowBox) ConnectMoveCursor(callback FlowBoxSignalMoveCursorCallback) int {
	signalFlowBoxMoveCursorLock.Lock()
	defer signalFlowBoxMoveCursorLock.Unlock()

	signalFlowBoxMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalFlowBoxMoveCursorId)))

	detail := signalFlowBoxMoveCursorDetail{callback, handlerID}
	signalFlowBoxMoveCursorMap[signalFlowBoxMoveCursorId] = detail

	return signalFlowBoxMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *FlowBox) DisconnectMoveCursor(connectionID int) {
	signalFlowBoxMoveCursorLock.Lock()
	defer signalFlowBoxMoveCursorLock.Unlock()

	detail, exists := signalFlowBoxMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxMoveCursorMap, connectionID)
}

//export flowbox_moveCursorHandler
func flowbox_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, data C.gpointer) C.gboolean {
	signalFlowBoxMoveCursorLock.RLock()
	defer signalFlowBoxMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalFlowBoxMoveCursorMap[index].callback
	retGo := callback(step, count)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalFlowBoxSelectAllDetail struct {
	callback  FlowBoxSignalSelectAllCallback
	handlerID C.gulong
}

var signalFlowBoxSelectAllId int
var signalFlowBoxSelectAllMap = make(map[int]signalFlowBoxSelectAllDetail)
var signalFlowBoxSelectAllLock sync.RWMutex

// FlowBoxSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a FlowBox.
type FlowBoxSignalSelectAllCallback func()

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *FlowBox) ConnectSelectAll(callback FlowBoxSignalSelectAllCallback) int {
	signalFlowBoxSelectAllLock.Lock()
	defer signalFlowBoxSelectAllLock.Unlock()

	signalFlowBoxSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_select_all(instance, C.gpointer(uintptr(signalFlowBoxSelectAllId)))

	detail := signalFlowBoxSelectAllDetail{callback, handlerID}
	signalFlowBoxSelectAllMap[signalFlowBoxSelectAllId] = detail

	return signalFlowBoxSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *FlowBox) DisconnectSelectAll(connectionID int) {
	signalFlowBoxSelectAllLock.Lock()
	defer signalFlowBoxSelectAllLock.Unlock()

	detail, exists := signalFlowBoxSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxSelectAllMap, connectionID)
}

//export flowbox_selectAllHandler
func flowbox_selectAllHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxSelectAllLock.RLock()
	defer signalFlowBoxSelectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxSelectAllMap[index].callback
	callback()
}

type signalFlowBoxSelectedChildrenChangedDetail struct {
	callback  FlowBoxSignalSelectedChildrenChangedCallback
	handlerID C.gulong
}

var signalFlowBoxSelectedChildrenChangedId int
var signalFlowBoxSelectedChildrenChangedMap = make(map[int]signalFlowBoxSelectedChildrenChangedDetail)
var signalFlowBoxSelectedChildrenChangedLock sync.RWMutex

// FlowBoxSignalSelectedChildrenChangedCallback is a callback function for a 'selected-children-changed' signal emitted from a FlowBox.
type FlowBoxSignalSelectedChildrenChangedCallback func()

/*
ConnectSelectedChildrenChanged connects the callback to the 'selected-children-changed' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectSelectedChildrenChanged to remove it.
*/
func (recv *FlowBox) ConnectSelectedChildrenChanged(callback FlowBoxSignalSelectedChildrenChangedCallback) int {
	signalFlowBoxSelectedChildrenChangedLock.Lock()
	defer signalFlowBoxSelectedChildrenChangedLock.Unlock()

	signalFlowBoxSelectedChildrenChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_selected_children_changed(instance, C.gpointer(uintptr(signalFlowBoxSelectedChildrenChangedId)))

	detail := signalFlowBoxSelectedChildrenChangedDetail{callback, handlerID}
	signalFlowBoxSelectedChildrenChangedMap[signalFlowBoxSelectedChildrenChangedId] = detail

	return signalFlowBoxSelectedChildrenChangedId
}

/*
DisconnectSelectedChildrenChanged disconnects a callback from the 'selected-children-changed' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectSelectedChildrenChanged.
*/
func (recv *FlowBox) DisconnectSelectedChildrenChanged(connectionID int) {
	signalFlowBoxSelectedChildrenChangedLock.Lock()
	defer signalFlowBoxSelectedChildrenChangedLock.Unlock()

	detail, exists := signalFlowBoxSelectedChildrenChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxSelectedChildrenChangedMap, connectionID)
}

//export flowbox_selectedChildrenChangedHandler
func flowbox_selectedChildrenChangedHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxSelectedChildrenChangedLock.RLock()
	defer signalFlowBoxSelectedChildrenChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxSelectedChildrenChangedMap[index].callback
	callback()
}

type signalFlowBoxToggleCursorChildDetail struct {
	callback  FlowBoxSignalToggleCursorChildCallback
	handlerID C.gulong
}

var signalFlowBoxToggleCursorChildId int
var signalFlowBoxToggleCursorChildMap = make(map[int]signalFlowBoxToggleCursorChildDetail)
var signalFlowBoxToggleCursorChildLock sync.RWMutex

// FlowBoxSignalToggleCursorChildCallback is a callback function for a 'toggle-cursor-child' signal emitted from a FlowBox.
type FlowBoxSignalToggleCursorChildCallback func()

/*
ConnectToggleCursorChild connects the callback to the 'toggle-cursor-child' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectToggleCursorChild to remove it.
*/
func (recv *FlowBox) ConnectToggleCursorChild(callback FlowBoxSignalToggleCursorChildCallback) int {
	signalFlowBoxToggleCursorChildLock.Lock()
	defer signalFlowBoxToggleCursorChildLock.Unlock()

	signalFlowBoxToggleCursorChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_toggle_cursor_child(instance, C.gpointer(uintptr(signalFlowBoxToggleCursorChildId)))

	detail := signalFlowBoxToggleCursorChildDetail{callback, handlerID}
	signalFlowBoxToggleCursorChildMap[signalFlowBoxToggleCursorChildId] = detail

	return signalFlowBoxToggleCursorChildId
}

/*
DisconnectToggleCursorChild disconnects a callback from the 'toggle-cursor-child' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectToggleCursorChild.
*/
func (recv *FlowBox) DisconnectToggleCursorChild(connectionID int) {
	signalFlowBoxToggleCursorChildLock.Lock()
	defer signalFlowBoxToggleCursorChildLock.Unlock()

	detail, exists := signalFlowBoxToggleCursorChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxToggleCursorChildMap, connectionID)
}

//export flowbox_toggleCursorChildHandler
func flowbox_toggleCursorChildHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxToggleCursorChildLock.RLock()
	defer signalFlowBoxToggleCursorChildLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxToggleCursorChildMap[index].callback
	callback()
}

type signalFlowBoxUnselectAllDetail struct {
	callback  FlowBoxSignalUnselectAllCallback
	handlerID C.gulong
}

var signalFlowBoxUnselectAllId int
var signalFlowBoxUnselectAllMap = make(map[int]signalFlowBoxUnselectAllDetail)
var signalFlowBoxUnselectAllLock sync.RWMutex

// FlowBoxSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a FlowBox.
type FlowBoxSignalUnselectAllCallback func()

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the FlowBox.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *FlowBox) ConnectUnselectAll(callback FlowBoxSignalUnselectAllCallback) int {
	signalFlowBoxUnselectAllLock.Lock()
	defer signalFlowBoxUnselectAllLock.Unlock()

	signalFlowBoxUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBox_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalFlowBoxUnselectAllId)))

	detail := signalFlowBoxUnselectAllDetail{callback, handlerID}
	signalFlowBoxUnselectAllMap[signalFlowBoxUnselectAllId] = detail

	return signalFlowBoxUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the FlowBox.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *FlowBox) DisconnectUnselectAll(connectionID int) {
	signalFlowBoxUnselectAllLock.Lock()
	defer signalFlowBoxUnselectAllLock.Unlock()

	detail, exists := signalFlowBoxUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxUnselectAllMap, connectionID)
}

//export flowbox_unselectAllHandler
func flowbox_unselectAllHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxUnselectAllLock.RLock()
	defer signalFlowBoxUnselectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxUnselectAllMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FlowBox
func (recv *FlowBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FlowBox
func (recv *FlowBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FlowBox
func (recv *FlowBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FlowBoxAccessible is a wrapper around the C record GtkFlowBoxAccessible.
type FlowBoxAccessible struct {
	native *C.GtkFlowBoxAccessible
	// parent : record
	// priv : record
}

func FlowBoxAccessibleNewFromC(u unsafe.Pointer) *FlowBoxAccessible {
	c := (*C.GtkFlowBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FlowBoxAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FlowBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxAccessible with another FlowBoxAccessible, and returns true if they represent the same GObject.
func (recv *FlowBoxAccessible) Equals(other *FlowBoxAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FlowBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FlowBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FlowBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FlowBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to FlowBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxAccessible.
func CastToFlowBoxAccessible(object *gobject.Object) *FlowBoxAccessible {
	return FlowBoxAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FlowBoxAccessible
func (recv *FlowBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by FlowBoxAccessible
func (recv *FlowBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// FlowBoxChild is a wrapper around the C record GtkFlowBoxChild.
type FlowBoxChild struct {
	native *C.GtkFlowBoxChild
	// parent_instance : record
}

func FlowBoxChildNewFromC(u unsafe.Pointer) *FlowBoxChild {
	c := (*C.GtkFlowBoxChild)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChild{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FlowBoxChild) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FlowBoxChild) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxChild with another FlowBoxChild, and returns true if they represent the same GObject.
func (recv *FlowBoxChild) Equals(other *FlowBoxChild) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *FlowBoxChild) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FlowBoxChild) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *FlowBoxChild) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FlowBoxChild) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FlowBoxChild) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to FlowBoxChild.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxChild.
func CastToFlowBoxChild(object *gobject.Object) *FlowBoxChild {
	return FlowBoxChildNewFromC(object.ToC())
}

type signalFlowBoxChildActivateDetail struct {
	callback  FlowBoxChildSignalActivateCallback
	handlerID C.gulong
}

var signalFlowBoxChildActivateId int
var signalFlowBoxChildActivateMap = make(map[int]signalFlowBoxChildActivateDetail)
var signalFlowBoxChildActivateLock sync.RWMutex

// FlowBoxChildSignalActivateCallback is a callback function for a 'activate' signal emitted from a FlowBoxChild.
type FlowBoxChildSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the FlowBoxChild.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *FlowBoxChild) ConnectActivate(callback FlowBoxChildSignalActivateCallback) int {
	signalFlowBoxChildActivateLock.Lock()
	defer signalFlowBoxChildActivateLock.Unlock()

	signalFlowBoxChildActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.FlowBoxChild_signal_connect_activate(instance, C.gpointer(uintptr(signalFlowBoxChildActivateId)))

	detail := signalFlowBoxChildActivateDetail{callback, handlerID}
	signalFlowBoxChildActivateMap[signalFlowBoxChildActivateId] = detail

	return signalFlowBoxChildActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the FlowBoxChild.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *FlowBoxChild) DisconnectActivate(connectionID int) {
	signalFlowBoxChildActivateLock.Lock()
	defer signalFlowBoxChildActivateLock.Unlock()

	detail, exists := signalFlowBoxChildActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFlowBoxChildActivateMap, connectionID)
}

//export flowboxchild_activateHandler
func flowboxchild_activateHandler(_ *C.GObject, data C.gpointer) {
	signalFlowBoxChildActivateLock.RLock()
	defer signalFlowBoxChildActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFlowBoxChildActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by FlowBoxChild
func (recv *FlowBoxChild) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FlowBoxChild
func (recv *FlowBoxChild) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FlowBoxChildAccessible is a wrapper around the C record GtkFlowBoxChildAccessible.
type FlowBoxChildAccessible struct {
	native *C.GtkFlowBoxChildAccessible
	// parent : record
}

func FlowBoxChildAccessibleNewFromC(u unsafe.Pointer) *FlowBoxChildAccessible {
	c := (*C.GtkFlowBoxChildAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChildAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FlowBoxChildAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FlowBoxChildAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxChildAccessible with another FlowBoxChildAccessible, and returns true if they represent the same GObject.
func (recv *FlowBoxChildAccessible) Equals(other *FlowBoxChildAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FlowBoxChildAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FlowBoxChildAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FlowBoxChildAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FlowBoxChildAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to FlowBoxChildAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FlowBoxChildAccessible.
func CastToFlowBoxChildAccessible(object *gobject.Object) *FlowBoxChildAccessible {
	return FlowBoxChildAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FlowBoxChildAccessible
func (recv *FlowBoxChildAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// FontButton is a wrapper around the C record GtkFontButton.
type FontButton struct {
	native *C.GtkFontButton
	// button : record
	// Private : priv
}

func FontButtonNewFromC(u unsafe.Pointer) *FontButton {
	c := (*C.GtkFontButton)(u)
	if c == nil {
		return nil
	}

	g := &FontButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontButton with another FontButton, and returns true if they represent the same GObject.
func (recv *FontButton) Equals(other *FontButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *FontButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *FontButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *FontButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *FontButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to FontButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontButton.
func CastToFontButton(object *gobject.Object) *FontButton {
	return FontButtonNewFromC(object.ToC())
}

type signalFontButtonFontSetDetail struct {
	callback  FontButtonSignalFontSetCallback
	handlerID C.gulong
}

var signalFontButtonFontSetId int
var signalFontButtonFontSetMap = make(map[int]signalFontButtonFontSetDetail)
var signalFontButtonFontSetLock sync.RWMutex

// FontButtonSignalFontSetCallback is a callback function for a 'font-set' signal emitted from a FontButton.
type FontButtonSignalFontSetCallback func()

/*
ConnectFontSet connects the callback to the 'font-set' signal for the FontButton.

The returned value represents the connection, and may be passed to DisconnectFontSet to remove it.
*/
func (recv *FontButton) ConnectFontSet(callback FontButtonSignalFontSetCallback) int {
	signalFontButtonFontSetLock.Lock()
	defer signalFontButtonFontSetLock.Unlock()

	signalFontButtonFontSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.FontButton_signal_connect_font_set(instance, C.gpointer(uintptr(signalFontButtonFontSetId)))

	detail := signalFontButtonFontSetDetail{callback, handlerID}
	signalFontButtonFontSetMap[signalFontButtonFontSetId] = detail

	return signalFontButtonFontSetId
}

/*
DisconnectFontSet disconnects a callback from the 'font-set' signal for the FontButton.

The connectionID should be a value returned from a call to ConnectFontSet.
*/
func (recv *FontButton) DisconnectFontSet(connectionID int) {
	signalFontButtonFontSetLock.Lock()
	defer signalFontButtonFontSetLock.Unlock()

	detail, exists := signalFontButtonFontSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFontButtonFontSetMap, connectionID)
}

//export fontbutton_fontSetHandler
func fontbutton_fontSetHandler(_ *C.GObject, data C.gpointer) {
	signalFontButtonFontSetLock.RLock()
	defer signalFontButtonFontSetLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFontButtonFontSetMap[index].callback
	callback()
}

// FontButtonNew is a wrapper around the C function gtk_font_button_new.
func FontButtonNew() *FontButton {
	retC := C.gtk_font_button_new()
	retGo := FontButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// FontButtonNewWithFont is a wrapper around the C function gtk_font_button_new_with_font.
func FontButtonNewWithFont(fontname string) *FontButton {
	c_fontname := C.CString(fontname)
	defer C.free(unsafe.Pointer(c_fontname))

	retC := C.gtk_font_button_new_with_font(c_fontname)
	retGo := FontButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFontName is a wrapper around the C function gtk_font_button_get_font_name.
func (recv *FontButton) GetFontName() string {
	retC := C.gtk_font_button_get_font_name((*C.GtkFontButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetShowSize is a wrapper around the C function gtk_font_button_get_show_size.
func (recv *FontButton) GetShowSize() bool {
	retC := C.gtk_font_button_get_show_size((*C.GtkFontButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowStyle is a wrapper around the C function gtk_font_button_get_show_style.
func (recv *FontButton) GetShowStyle() bool {
	retC := C.gtk_font_button_get_show_style((*C.GtkFontButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTitle is a wrapper around the C function gtk_font_button_get_title.
func (recv *FontButton) GetTitle() string {
	retC := C.gtk_font_button_get_title((*C.GtkFontButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUseFont is a wrapper around the C function gtk_font_button_get_use_font.
func (recv *FontButton) GetUseFont() bool {
	retC := C.gtk_font_button_get_use_font((*C.GtkFontButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetUseSize is a wrapper around the C function gtk_font_button_get_use_size.
func (recv *FontButton) GetUseSize() bool {
	retC := C.gtk_font_button_get_use_size((*C.GtkFontButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetFontName is a wrapper around the C function gtk_font_button_set_font_name.
func (recv *FontButton) SetFontName(fontname string) bool {
	c_fontname := C.CString(fontname)
	defer C.free(unsafe.Pointer(c_fontname))

	retC := C.gtk_font_button_set_font_name((*C.GtkFontButton)(recv.native), c_fontname)
	retGo := retC == C.TRUE

	return retGo
}

// SetShowSize is a wrapper around the C function gtk_font_button_set_show_size.
func (recv *FontButton) SetShowSize(showSize bool) {
	c_show_size :=
		boolToGboolean(showSize)

	C.gtk_font_button_set_show_size((*C.GtkFontButton)(recv.native), c_show_size)

	return
}

// SetShowStyle is a wrapper around the C function gtk_font_button_set_show_style.
func (recv *FontButton) SetShowStyle(showStyle bool) {
	c_show_style :=
		boolToGboolean(showStyle)

	C.gtk_font_button_set_show_style((*C.GtkFontButton)(recv.native), c_show_style)

	return
}

// SetTitle is a wrapper around the C function gtk_font_button_set_title.
func (recv *FontButton) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_font_button_set_title((*C.GtkFontButton)(recv.native), c_title)

	return
}

// SetUseFont is a wrapper around the C function gtk_font_button_set_use_font.
func (recv *FontButton) SetUseFont(useFont bool) {
	c_use_font :=
		boolToGboolean(useFont)

	C.gtk_font_button_set_use_font((*C.GtkFontButton)(recv.native), c_use_font)

	return
}

// SetUseSize is a wrapper around the C function gtk_font_button_set_use_size.
func (recv *FontButton) SetUseSize(useSize bool) {
	c_use_size :=
		boolToGboolean(useSize)

	C.gtk_font_button_set_use_size((*C.GtkFontButton)(recv.native), c_use_size)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by FontButton
func (recv *FontButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by FontButton
func (recv *FontButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by FontButton
func (recv *FontButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontButton
func (recv *FontButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontButton
func (recv *FontButton) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// FontChooserDialog is a wrapper around the C record GtkFontChooserDialog.
type FontChooserDialog struct {
	native *C.GtkFontChooserDialog
	// parent_instance : record
	// Private : priv
}

func FontChooserDialogNewFromC(u unsafe.Pointer) *FontChooserDialog {
	c := (*C.GtkFontChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserDialog with another FontChooserDialog, and returns true if they represent the same GObject.
func (recv *FontChooserDialog) Equals(other *FontChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *FontChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FontChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FontChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FontChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FontChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to FontChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontChooserDialog.
func CastToFontChooserDialog(object *gobject.Object) *FontChooserDialog {
	return FontChooserDialogNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontChooserDialog
func (recv *FontChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontChooserDialog
func (recv *FontChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontChooserDialog
func (recv *FontChooserDialog) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// FontChooserWidget is a wrapper around the C record GtkFontChooserWidget.
type FontChooserWidget struct {
	native *C.GtkFontChooserWidget
	// parent_instance : record
	// Private : priv
}

func FontChooserWidgetNewFromC(u unsafe.Pointer) *FontChooserWidget {
	c := (*C.GtkFontChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserWidget with another FontChooserWidget, and returns true if they represent the same GObject.
func (recv *FontChooserWidget) Equals(other *FontChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *FontChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FontChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FontChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to FontChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontChooserWidget.
func CastToFontChooserWidget(object *gobject.Object) *FontChooserWidget {
	return FontChooserWidgetNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by FontChooserWidget
func (recv *FontChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontChooserWidget
func (recv *FontChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FontChooser returns the FontChooser interface implemented by FontChooserWidget
func (recv *FontChooserWidget) FontChooser() *FontChooser {
	return FontChooserNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FontChooserWidget
func (recv *FontChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FontSelection is a wrapper around the C record GtkFontSelection.
type FontSelection struct {
	native *C.GtkFontSelection
	// parent_instance : record
	// Private : priv
}

func FontSelectionNewFromC(u unsafe.Pointer) *FontSelection {
	c := (*C.GtkFontSelection)(u)
	if c == nil {
		return nil
	}

	g := &FontSelection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontSelection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontSelection with another FontSelection, and returns true if they represent the same GObject.
func (recv *FontSelection) Equals(other *FontSelection) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *FontSelection) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *FontSelection) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *FontSelection) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontSelection) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontSelection) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to FontSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontSelection.
func CastToFontSelection(object *gobject.Object) *FontSelection {
	return FontSelectionNewFromC(object.ToC())
}

// FontSelectionNew is a wrapper around the C function gtk_font_selection_new.
func FontSelectionNew() *FontSelection {
	retC := C.gtk_font_selection_new()
	retGo := FontSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFontName is a wrapper around the C function gtk_font_selection_get_font_name.
func (recv *FontSelection) GetFontName() string {
	retC := C.gtk_font_selection_get_font_name((*C.GtkFontSelection)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetPreviewText is a wrapper around the C function gtk_font_selection_get_preview_text.
func (recv *FontSelection) GetPreviewText() string {
	retC := C.gtk_font_selection_get_preview_text((*C.GtkFontSelection)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SetFontName is a wrapper around the C function gtk_font_selection_set_font_name.
func (recv *FontSelection) SetFontName(fontname string) bool {
	c_fontname := C.CString(fontname)
	defer C.free(unsafe.Pointer(c_fontname))

	retC := C.gtk_font_selection_set_font_name((*C.GtkFontSelection)(recv.native), c_fontname)
	retGo := retC == C.TRUE

	return retGo
}

// SetPreviewText is a wrapper around the C function gtk_font_selection_set_preview_text.
func (recv *FontSelection) SetPreviewText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_font_selection_set_preview_text((*C.GtkFontSelection)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by FontSelection
func (recv *FontSelection) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontSelection
func (recv *FontSelection) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by FontSelection
func (recv *FontSelection) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// FontSelectionDialog is a wrapper around the C record GtkFontSelectionDialog.
type FontSelectionDialog struct {
	native *C.GtkFontSelectionDialog
	// parent_instance : record
	// Private : priv
}

func FontSelectionDialogNewFromC(u unsafe.Pointer) *FontSelectionDialog {
	c := (*C.GtkFontSelectionDialog)(u)
	if c == nil {
		return nil
	}

	g := &FontSelectionDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FontSelectionDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FontSelectionDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontSelectionDialog with another FontSelectionDialog, and returns true if they represent the same GObject.
func (recv *FontSelectionDialog) Equals(other *FontSelectionDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *FontSelectionDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *FontSelectionDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *FontSelectionDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *FontSelectionDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *FontSelectionDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *FontSelectionDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *FontSelectionDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to FontSelectionDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a FontSelectionDialog.
func CastToFontSelectionDialog(object *gobject.Object) *FontSelectionDialog {
	return FontSelectionDialogNewFromC(object.ToC())
}

// FontSelectionDialogNew is a wrapper around the C function gtk_font_selection_dialog_new.
func FontSelectionDialogNew(title string) *FontSelectionDialog {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	retC := C.gtk_font_selection_dialog_new(c_title)
	retGo := FontSelectionDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFontName is a wrapper around the C function gtk_font_selection_dialog_get_font_name.
func (recv *FontSelectionDialog) GetFontName() string {
	retC := C.gtk_font_selection_dialog_get_font_name((*C.GtkFontSelectionDialog)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetPreviewText is a wrapper around the C function gtk_font_selection_dialog_get_preview_text.
func (recv *FontSelectionDialog) GetPreviewText() string {
	retC := C.gtk_font_selection_dialog_get_preview_text((*C.GtkFontSelectionDialog)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SetFontName is a wrapper around the C function gtk_font_selection_dialog_set_font_name.
func (recv *FontSelectionDialog) SetFontName(fontname string) bool {
	c_fontname := C.CString(fontname)
	defer C.free(unsafe.Pointer(c_fontname))

	retC := C.gtk_font_selection_dialog_set_font_name((*C.GtkFontSelectionDialog)(recv.native), c_fontname)
	retGo := retC == C.TRUE

	return retGo
}

// SetPreviewText is a wrapper around the C function gtk_font_selection_dialog_set_preview_text.
func (recv *FontSelectionDialog) SetPreviewText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_font_selection_dialog_set_preview_text((*C.GtkFontSelectionDialog)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by FontSelectionDialog
func (recv *FontSelectionDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by FontSelectionDialog
func (recv *FontSelectionDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Frame is a wrapper around the C record GtkFrame.
type Frame struct {
	native *C.GtkFrame
	// bin : record
	// Private : priv
}

func FrameNewFromC(u unsafe.Pointer) *Frame {
	c := (*C.GtkFrame)(u)
	if c == nil {
		return nil
	}

	g := &Frame{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Frame) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Frame) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Frame with another Frame, and returns true if they represent the same GObject.
func (recv *Frame) Equals(other *Frame) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Frame) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Frame) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Frame) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Frame) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Frame) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Frame.
// Exercise care, as this is a potentially dangerous function if the Object is not a Frame.
func CastToFrame(object *gobject.Object) *Frame {
	return FrameNewFromC(object.ToC())
}

// FrameNew is a wrapper around the C function gtk_frame_new.
func FrameNew(label string) *Frame {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_frame_new(c_label)
	retGo := FrameNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLabel is a wrapper around the C function gtk_frame_get_label.
func (recv *Frame) GetLabel() string {
	retC := C.gtk_frame_get_label((*C.GtkFrame)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetLabelAlign is a wrapper around the C function gtk_frame_get_label_align.
func (recv *Frame) GetLabelAlign() (float32, float32) {
	var c_xalign C.gfloat

	var c_yalign C.gfloat

	C.gtk_frame_get_label_align((*C.GtkFrame)(recv.native), &c_xalign, &c_yalign)

	xalign := (float32)(c_xalign)

	yalign := (float32)(c_yalign)

	return xalign, yalign
}

// GetLabelWidget is a wrapper around the C function gtk_frame_get_label_widget.
func (recv *Frame) GetLabelWidget() *Widget {
	retC := C.gtk_frame_get_label_widget((*C.GtkFrame)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetShadowType is a wrapper around the C function gtk_frame_get_shadow_type.
func (recv *Frame) GetShadowType() ShadowType {
	retC := C.gtk_frame_get_shadow_type((*C.GtkFrame)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// SetLabel is a wrapper around the C function gtk_frame_set_label.
func (recv *Frame) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_frame_set_label((*C.GtkFrame)(recv.native), c_label)

	return
}

// SetLabelAlign is a wrapper around the C function gtk_frame_set_label_align.
func (recv *Frame) SetLabelAlign(xalign float32, yalign float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	C.gtk_frame_set_label_align((*C.GtkFrame)(recv.native), c_xalign, c_yalign)

	return
}

// SetLabelWidget is a wrapper around the C function gtk_frame_set_label_widget.
func (recv *Frame) SetLabelWidget(labelWidget *Widget) {
	c_label_widget := (*C.GtkWidget)(C.NULL)
	if labelWidget != nil {
		c_label_widget = (*C.GtkWidget)(labelWidget.ToC())
	}

	C.gtk_frame_set_label_widget((*C.GtkFrame)(recv.native), c_label_widget)

	return
}

// SetShadowType is a wrapper around the C function gtk_frame_set_shadow_type.
func (recv *Frame) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_frame_set_shadow_type((*C.GtkFrame)(recv.native), c_type)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Frame
func (recv *Frame) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Frame
func (recv *Frame) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// FrameAccessible is a wrapper around the C record GtkFrameAccessible.
type FrameAccessible struct {
	native *C.GtkFrameAccessible
	// parent : record
	// priv : record
}

func FrameAccessibleNewFromC(u unsafe.Pointer) *FrameAccessible {
	c := (*C.GtkFrameAccessible)(u)
	if c == nil {
		return nil
	}

	g := &FrameAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *FrameAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *FrameAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FrameAccessible with another FrameAccessible, and returns true if they represent the same GObject.
func (recv *FrameAccessible) Equals(other *FrameAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *FrameAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *FrameAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *FrameAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *FrameAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to FrameAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a FrameAccessible.
func CastToFrameAccessible(object *gobject.Object) *FrameAccessible {
	return FrameAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by FrameAccessible
func (recv *FrameAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Gesture is a wrapper around the C record GtkGesture.
type Gesture struct {
	native *C.GtkGesture
}

func GestureNewFromC(u unsafe.Pointer) *Gesture {
	c := (*C.GtkGesture)(u)
	if c == nil {
		return nil
	}

	g := &Gesture{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Gesture) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Gesture) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Gesture with another Gesture, and returns true if they represent the same GObject.
func (recv *Gesture) Equals(other *Gesture) bool {
	return other.ToC() == recv.ToC()
}

// EventController upcasts to *EventController
func (recv *Gesture) EventController() *EventController {
	return EventControllerNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Gesture) Object() *gobject.Object {
	return recv.EventController().Object()
}

// CastToWidget down casts any arbitrary Object to Gesture.
// Exercise care, as this is a potentially dangerous function if the Object is not a Gesture.
func CastToGesture(object *gobject.Object) *Gesture {
	return GestureNewFromC(object.ToC())
}

// GetLastEvent is a wrapper around the C function gtk_gesture_get_last_event.
func (recv *Gesture) GetLastEvent(sequence *gdk.EventSequence) *gdk.Event {
	c_sequence := (*C.GdkEventSequence)(C.NULL)
	if sequence != nil {
		c_sequence = (*C.GdkEventSequence)(sequence.ToC())
	}

	retC := C.gtk_gesture_get_last_event((*C.GtkGesture)(recv.native), c_sequence)
	var retGo (*gdk.Event)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.EventNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GestureDrag is a wrapper around the C record GtkGestureDrag.
type GestureDrag struct {
	native *C.GtkGestureDrag
}

func GestureDragNewFromC(u unsafe.Pointer) *GestureDrag {
	c := (*C.GtkGestureDrag)(u)
	if c == nil {
		return nil
	}

	g := &GestureDrag{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureDrag) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureDrag) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureDrag with another GestureDrag, and returns true if they represent the same GObject.
func (recv *GestureDrag) Equals(other *GestureDrag) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureDrag) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureDrag) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureDrag) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureDrag) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitrary Object to GestureDrag.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureDrag.
func CastToGestureDrag(object *gobject.Object) *GestureDrag {
	return GestureDragNewFromC(object.ToC())
}

// GestureLongPress is a wrapper around the C record GtkGestureLongPress.
type GestureLongPress struct {
	native *C.GtkGestureLongPress
}

func GestureLongPressNewFromC(u unsafe.Pointer) *GestureLongPress {
	c := (*C.GtkGestureLongPress)(u)
	if c == nil {
		return nil
	}

	g := &GestureLongPress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureLongPress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureLongPress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureLongPress with another GestureLongPress, and returns true if they represent the same GObject.
func (recv *GestureLongPress) Equals(other *GestureLongPress) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureLongPress) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureLongPress) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureLongPress) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureLongPress) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitrary Object to GestureLongPress.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureLongPress.
func CastToGestureLongPress(object *gobject.Object) *GestureLongPress {
	return GestureLongPressNewFromC(object.ToC())
}

// GestureMultiPress is a wrapper around the C record GtkGestureMultiPress.
type GestureMultiPress struct {
	native *C.GtkGestureMultiPress
}

func GestureMultiPressNewFromC(u unsafe.Pointer) *GestureMultiPress {
	c := (*C.GtkGestureMultiPress)(u)
	if c == nil {
		return nil
	}

	g := &GestureMultiPress{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureMultiPress) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureMultiPress) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureMultiPress with another GestureMultiPress, and returns true if they represent the same GObject.
func (recv *GestureMultiPress) Equals(other *GestureMultiPress) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureMultiPress) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureMultiPress) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureMultiPress) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureMultiPress) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitrary Object to GestureMultiPress.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureMultiPress.
func CastToGestureMultiPress(object *gobject.Object) *GestureMultiPress {
	return GestureMultiPressNewFromC(object.ToC())
}

// GesturePan is a wrapper around the C record GtkGesturePan.
type GesturePan struct {
	native *C.GtkGesturePan
}

func GesturePanNewFromC(u unsafe.Pointer) *GesturePan {
	c := (*C.GtkGesturePan)(u)
	if c == nil {
		return nil
	}

	g := &GesturePan{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GesturePan) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GesturePan) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GesturePan with another GesturePan, and returns true if they represent the same GObject.
func (recv *GesturePan) Equals(other *GesturePan) bool {
	return other.ToC() == recv.ToC()
}

// GestureDrag upcasts to *GestureDrag
func (recv *GesturePan) GestureDrag() *GestureDrag {
	return GestureDragNewFromC(unsafe.Pointer(recv.native))
}

// GestureSingle upcasts to *GestureSingle
func (recv *GesturePan) GestureSingle() *GestureSingle {
	return recv.GestureDrag().GestureSingle()
}

// Gesture upcasts to *Gesture
func (recv *GesturePan) Gesture() *Gesture {
	return recv.GestureDrag().Gesture()
}

// EventController upcasts to *EventController
func (recv *GesturePan) EventController() *EventController {
	return recv.GestureDrag().EventController()
}

// Object upcasts to *Object
func (recv *GesturePan) Object() *gobject.Object {
	return recv.GestureDrag().Object()
}

// CastToWidget down casts any arbitrary Object to GesturePan.
// Exercise care, as this is a potentially dangerous function if the Object is not a GesturePan.
func CastToGesturePan(object *gobject.Object) *GesturePan {
	return GesturePanNewFromC(object.ToC())
}

// GestureRotate is a wrapper around the C record GtkGestureRotate.
type GestureRotate struct {
	native *C.GtkGestureRotate
}

func GestureRotateNewFromC(u unsafe.Pointer) *GestureRotate {
	c := (*C.GtkGestureRotate)(u)
	if c == nil {
		return nil
	}

	g := &GestureRotate{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureRotate) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureRotate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureRotate with another GestureRotate, and returns true if they represent the same GObject.
func (recv *GestureRotate) Equals(other *GestureRotate) bool {
	return other.ToC() == recv.ToC()
}

// Gesture upcasts to *Gesture
func (recv *GestureRotate) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureRotate) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureRotate) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitrary Object to GestureRotate.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureRotate.
func CastToGestureRotate(object *gobject.Object) *GestureRotate {
	return GestureRotateNewFromC(object.ToC())
}

// GestureSingle is a wrapper around the C record GtkGestureSingle.
type GestureSingle struct {
	native *C.GtkGestureSingle
}

func GestureSingleNewFromC(u unsafe.Pointer) *GestureSingle {
	c := (*C.GtkGestureSingle)(u)
	if c == nil {
		return nil
	}

	g := &GestureSingle{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureSingle) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureSingle) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureSingle with another GestureSingle, and returns true if they represent the same GObject.
func (recv *GestureSingle) Equals(other *GestureSingle) bool {
	return other.ToC() == recv.ToC()
}

// Gesture upcasts to *Gesture
func (recv *GestureSingle) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureSingle) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureSingle) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitrary Object to GestureSingle.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureSingle.
func CastToGestureSingle(object *gobject.Object) *GestureSingle {
	return GestureSingleNewFromC(object.ToC())
}

// GestureSwipe is a wrapper around the C record GtkGestureSwipe.
type GestureSwipe struct {
	native *C.GtkGestureSwipe
}

func GestureSwipeNewFromC(u unsafe.Pointer) *GestureSwipe {
	c := (*C.GtkGestureSwipe)(u)
	if c == nil {
		return nil
	}

	g := &GestureSwipe{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureSwipe) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureSwipe) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureSwipe with another GestureSwipe, and returns true if they represent the same GObject.
func (recv *GestureSwipe) Equals(other *GestureSwipe) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingle upcasts to *GestureSingle
func (recv *GestureSwipe) GestureSingle() *GestureSingle {
	return GestureSingleNewFromC(unsafe.Pointer(recv.native))
}

// Gesture upcasts to *Gesture
func (recv *GestureSwipe) Gesture() *Gesture {
	return recv.GestureSingle().Gesture()
}

// EventController upcasts to *EventController
func (recv *GestureSwipe) EventController() *EventController {
	return recv.GestureSingle().EventController()
}

// Object upcasts to *Object
func (recv *GestureSwipe) Object() *gobject.Object {
	return recv.GestureSingle().Object()
}

// CastToWidget down casts any arbitrary Object to GestureSwipe.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureSwipe.
func CastToGestureSwipe(object *gobject.Object) *GestureSwipe {
	return GestureSwipeNewFromC(object.ToC())
}

// GestureZoom is a wrapper around the C record GtkGestureZoom.
type GestureZoom struct {
	native *C.GtkGestureZoom
}

func GestureZoomNewFromC(u unsafe.Pointer) *GestureZoom {
	c := (*C.GtkGestureZoom)(u)
	if c == nil {
		return nil
	}

	g := &GestureZoom{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *GestureZoom) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *GestureZoom) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureZoom with another GestureZoom, and returns true if they represent the same GObject.
func (recv *GestureZoom) Equals(other *GestureZoom) bool {
	return other.ToC() == recv.ToC()
}

// Gesture upcasts to *Gesture
func (recv *GestureZoom) Gesture() *Gesture {
	return GestureNewFromC(unsafe.Pointer(recv.native))
}

// EventController upcasts to *EventController
func (recv *GestureZoom) EventController() *EventController {
	return recv.Gesture().EventController()
}

// Object upcasts to *Object
func (recv *GestureZoom) Object() *gobject.Object {
	return recv.Gesture().Object()
}

// CastToWidget down casts any arbitrary Object to GestureZoom.
// Exercise care, as this is a potentially dangerous function if the Object is not a GestureZoom.
func CastToGestureZoom(object *gobject.Object) *GestureZoom {
	return GestureZoomNewFromC(object.ToC())
}

// Grid is a wrapper around the C record GtkGrid.
type Grid struct {
	native *C.GtkGrid
	// Private : container
	// Private : priv
}

func GridNewFromC(u unsafe.Pointer) *Grid {
	c := (*C.GtkGrid)(u)
	if c == nil {
		return nil
	}

	g := &Grid{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Grid) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Grid) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Grid with another Grid, and returns true if they represent the same GObject.
func (recv *Grid) Equals(other *Grid) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Grid) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Grid) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Grid) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Grid) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Grid.
// Exercise care, as this is a potentially dangerous function if the Object is not a Grid.
func CastToGrid(object *gobject.Object) *Grid {
	return GridNewFromC(object.ToC())
}

// GridNew is a wrapper around the C function gtk_grid_new.
func GridNew() *Grid {
	retC := C.gtk_grid_new()
	retGo := GridNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Attach is a wrapper around the C function gtk_grid_attach.
func (recv *Grid) Attach(child *Widget, left int32, top int32, width int32, height int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_left := (C.gint)(left)

	c_top := (C.gint)(top)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_grid_attach((*C.GtkGrid)(recv.native), c_child, c_left, c_top, c_width, c_height)

	return
}

// AttachNextTo is a wrapper around the C function gtk_grid_attach_next_to.
func (recv *Grid) AttachNextTo(child *Widget, sibling *Widget, side PositionType, width int32, height int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_sibling := (*C.GtkWidget)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkWidget)(sibling.ToC())
	}

	c_side := (C.GtkPositionType)(side)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_grid_attach_next_to((*C.GtkGrid)(recv.native), c_child, c_sibling, c_side, c_width, c_height)

	return
}

// GetColumnHomogeneous is a wrapper around the C function gtk_grid_get_column_homogeneous.
func (recv *Grid) GetColumnHomogeneous() bool {
	retC := C.gtk_grid_get_column_homogeneous((*C.GtkGrid)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetColumnSpacing is a wrapper around the C function gtk_grid_get_column_spacing.
func (recv *Grid) GetColumnSpacing() uint32 {
	retC := C.gtk_grid_get_column_spacing((*C.GtkGrid)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetRowHomogeneous is a wrapper around the C function gtk_grid_get_row_homogeneous.
func (recv *Grid) GetRowHomogeneous() bool {
	retC := C.gtk_grid_get_row_homogeneous((*C.GtkGrid)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetRowSpacing is a wrapper around the C function gtk_grid_get_row_spacing.
func (recv *Grid) GetRowSpacing() uint32 {
	retC := C.gtk_grid_get_row_spacing((*C.GtkGrid)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// SetColumnHomogeneous is a wrapper around the C function gtk_grid_set_column_homogeneous.
func (recv *Grid) SetColumnHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_grid_set_column_homogeneous((*C.GtkGrid)(recv.native), c_homogeneous)

	return
}

// SetColumnSpacing is a wrapper around the C function gtk_grid_set_column_spacing.
func (recv *Grid) SetColumnSpacing(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_grid_set_column_spacing((*C.GtkGrid)(recv.native), c_spacing)

	return
}

// SetRowHomogeneous is a wrapper around the C function gtk_grid_set_row_homogeneous.
func (recv *Grid) SetRowHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_grid_set_row_homogeneous((*C.GtkGrid)(recv.native), c_homogeneous)

	return
}

// SetRowSpacing is a wrapper around the C function gtk_grid_set_row_spacing.
func (recv *Grid) SetRowSpacing(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_grid_set_row_spacing((*C.GtkGrid)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Grid
func (recv *Grid) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Grid
func (recv *Grid) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Grid
func (recv *Grid) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HBox is a wrapper around the C record GtkHBox.
type HBox struct {
	native *C.GtkHBox
	// box : record
}

func HBoxNewFromC(u unsafe.Pointer) *HBox {
	c := (*C.GtkHBox)(u)
	if c == nil {
		return nil
	}

	g := &HBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HBox with another HBox, and returns true if they represent the same GObject.
func (recv *HBox) Equals(other *HBox) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *HBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *HBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to HBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HBox.
func CastToHBox(object *gobject.Object) *HBox {
	return HBoxNewFromC(object.ToC())
}

// HBoxNew is a wrapper around the C function gtk_hbox_new.
func HBoxNew(homogeneous bool, spacing int32) *HBox {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	c_spacing := (C.gint)(spacing)

	retC := C.gtk_hbox_new(c_homogeneous, c_spacing)
	retGo := HBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HBox
func (recv *HBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HBox
func (recv *HBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HBox
func (recv *HBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HButtonBox is a wrapper around the C record GtkHButtonBox.
type HButtonBox struct {
	native *C.GtkHButtonBox
	// button_box : record
}

func HButtonBoxNewFromC(u unsafe.Pointer) *HButtonBox {
	c := (*C.GtkHButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &HButtonBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HButtonBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HButtonBox with another HButtonBox, and returns true if they represent the same GObject.
func (recv *HButtonBox) Equals(other *HButtonBox) bool {
	return other.ToC() == recv.ToC()
}

// ButtonBox upcasts to *ButtonBox
func (recv *HButtonBox) ButtonBox() *ButtonBox {
	return ButtonBoxNewFromC(unsafe.Pointer(recv.native))
}

// Box upcasts to *Box
func (recv *HButtonBox) Box() *Box {
	return recv.ButtonBox().Box()
}

// Container upcasts to *Container
func (recv *HButtonBox) Container() *Container {
	return recv.ButtonBox().Container()
}

// Widget upcasts to *Widget
func (recv *HButtonBox) Widget() *Widget {
	return recv.ButtonBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ButtonBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HButtonBox) Object() *gobject.Object {
	return recv.ButtonBox().Object()
}

// CastToWidget down casts any arbitrary Object to HButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HButtonBox.
func CastToHButtonBox(object *gobject.Object) *HButtonBox {
	return HButtonBoxNewFromC(object.ToC())
}

// HButtonBoxNew is a wrapper around the C function gtk_hbutton_box_new.
func HButtonBoxNew() *HButtonBox {
	retC := C.gtk_hbutton_box_new()
	retGo := HButtonBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HButtonBox
func (recv *HButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HButtonBox
func (recv *HButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HButtonBox
func (recv *HButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HPaned is a wrapper around the C record GtkHPaned.
type HPaned struct {
	native *C.GtkHPaned
	// paned : record
}

func HPanedNewFromC(u unsafe.Pointer) *HPaned {
	c := (*C.GtkHPaned)(u)
	if c == nil {
		return nil
	}

	g := &HPaned{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HPaned) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HPaned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HPaned with another HPaned, and returns true if they represent the same GObject.
func (recv *HPaned) Equals(other *HPaned) bool {
	return other.ToC() == recv.ToC()
}

// Paned upcasts to *Paned
func (recv *HPaned) Paned() *Paned {
	return PanedNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HPaned) Container() *Container {
	return recv.Paned().Container()
}

// Widget upcasts to *Widget
func (recv *HPaned) Widget() *Widget {
	return recv.Paned().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HPaned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Paned().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HPaned) Object() *gobject.Object {
	return recv.Paned().Object()
}

// CastToWidget down casts any arbitrary Object to HPaned.
// Exercise care, as this is a potentially dangerous function if the Object is not a HPaned.
func CastToHPaned(object *gobject.Object) *HPaned {
	return HPanedNewFromC(object.ToC())
}

// HPanedNew is a wrapper around the C function gtk_hpaned_new.
func HPanedNew() *HPaned {
	retC := C.gtk_hpaned_new()
	retGo := HPanedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HPaned
func (recv *HPaned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HPaned
func (recv *HPaned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HPaned
func (recv *HPaned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HSV is a wrapper around the C record GtkHSV.
type HSV struct {
	native *C.GtkHSV
	// parent_instance : record
	// Private : priv
}

func HSVNewFromC(u unsafe.Pointer) *HSV {
	c := (*C.GtkHSV)(u)
	if c == nil {
		return nil
	}

	g := &HSV{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HSV) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HSV) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HSV with another HSV, and returns true if they represent the same GObject.
func (recv *HSV) Equals(other *HSV) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *HSV) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HSV) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HSV) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to HSV.
// Exercise care, as this is a potentially dangerous function if the Object is not a HSV.
func CastToHSV(object *gobject.Object) *HSV {
	return HSVNewFromC(object.ToC())
}

type signalHSVChangedDetail struct {
	callback  HSVSignalChangedCallback
	handlerID C.gulong
}

var signalHSVChangedId int
var signalHSVChangedMap = make(map[int]signalHSVChangedDetail)
var signalHSVChangedLock sync.RWMutex

// HSVSignalChangedCallback is a callback function for a 'changed' signal emitted from a HSV.
type HSVSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the HSV.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *HSV) ConnectChanged(callback HSVSignalChangedCallback) int {
	signalHSVChangedLock.Lock()
	defer signalHSVChangedLock.Unlock()

	signalHSVChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HSV_signal_connect_changed(instance, C.gpointer(uintptr(signalHSVChangedId)))

	detail := signalHSVChangedDetail{callback, handlerID}
	signalHSVChangedMap[signalHSVChangedId] = detail

	return signalHSVChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the HSV.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *HSV) DisconnectChanged(connectionID int) {
	signalHSVChangedLock.Lock()
	defer signalHSVChangedLock.Unlock()

	detail, exists := signalHSVChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHSVChangedMap, connectionID)
}

//export hsv_changedHandler
func hsv_changedHandler(_ *C.GObject, data C.gpointer) {
	signalHSVChangedLock.RLock()
	defer signalHSVChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalHSVChangedMap[index].callback
	callback()
}

type signalHSVMoveDetail struct {
	callback  HSVSignalMoveCallback
	handlerID C.gulong
}

var signalHSVMoveId int
var signalHSVMoveMap = make(map[int]signalHSVMoveDetail)
var signalHSVMoveLock sync.RWMutex

// HSVSignalMoveCallback is a callback function for a 'move' signal emitted from a HSV.
type HSVSignalMoveCallback func(object DirectionType)

/*
ConnectMove connects the callback to the 'move' signal for the HSV.

The returned value represents the connection, and may be passed to DisconnectMove to remove it.
*/
func (recv *HSV) ConnectMove(callback HSVSignalMoveCallback) int {
	signalHSVMoveLock.Lock()
	defer signalHSVMoveLock.Unlock()

	signalHSVMoveId++
	instance := C.gpointer(recv.native)
	handlerID := C.HSV_signal_connect_move(instance, C.gpointer(uintptr(signalHSVMoveId)))

	detail := signalHSVMoveDetail{callback, handlerID}
	signalHSVMoveMap[signalHSVMoveId] = detail

	return signalHSVMoveId
}

/*
DisconnectMove disconnects a callback from the 'move' signal for the HSV.

The connectionID should be a value returned from a call to ConnectMove.
*/
func (recv *HSV) DisconnectMove(connectionID int) {
	signalHSVMoveLock.Lock()
	defer signalHSVMoveLock.Unlock()

	detail, exists := signalHSVMoveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHSVMoveMap, connectionID)
}

//export hsv_moveHandler
func hsv_moveHandler(_ *C.GObject, c_object C.GtkDirectionType, data C.gpointer) {
	signalHSVMoveLock.RLock()
	defer signalHSVMoveLock.RUnlock()

	object := DirectionType(c_object)

	index := int(uintptr(data))
	callback := signalHSVMoveMap[index].callback
	callback(object)
}

// ImplementorIface returns the ImplementorIface interface implemented by HSV
func (recv *HSV) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HSV
func (recv *HSV) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// HScale is a wrapper around the C record GtkHScale.
type HScale struct {
	native *C.GtkHScale
	// scale : record
}

func HScaleNewFromC(u unsafe.Pointer) *HScale {
	c := (*C.GtkHScale)(u)
	if c == nil {
		return nil
	}

	g := &HScale{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HScale) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HScale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HScale with another HScale, and returns true if they represent the same GObject.
func (recv *HScale) Equals(other *HScale) bool {
	return other.ToC() == recv.ToC()
}

// Scale upcasts to *Scale
func (recv *HScale) Scale() *Scale {
	return ScaleNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *HScale) Range() *Range {
	return recv.Scale().Range()
}

// Widget upcasts to *Widget
func (recv *HScale) Widget() *Widget {
	return recv.Scale().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HScale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scale().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HScale) Object() *gobject.Object {
	return recv.Scale().Object()
}

// CastToWidget down casts any arbitrary Object to HScale.
// Exercise care, as this is a potentially dangerous function if the Object is not a HScale.
func CastToHScale(object *gobject.Object) *HScale {
	return HScaleNewFromC(object.ToC())
}

// HScaleNew is a wrapper around the C function gtk_hscale_new.
func HScaleNew(adjustment *Adjustment) *HScale {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_hscale_new(c_adjustment)
	retGo := HScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// HScaleNewWithRange is a wrapper around the C function gtk_hscale_new_with_range.
func HScaleNewWithRange(min float64, max float64, step float64) *HScale {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_hscale_new_with_range(c_min, c_max, c_step)
	retGo := HScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HScale
func (recv *HScale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HScale
func (recv *HScale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HScale
func (recv *HScale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HScrollbar is a wrapper around the C record GtkHScrollbar.
type HScrollbar struct {
	native *C.GtkHScrollbar
	// scrollbar : record
}

func HScrollbarNewFromC(u unsafe.Pointer) *HScrollbar {
	c := (*C.GtkHScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &HScrollbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HScrollbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HScrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HScrollbar with another HScrollbar, and returns true if they represent the same GObject.
func (recv *HScrollbar) Equals(other *HScrollbar) bool {
	return other.ToC() == recv.ToC()
}

// Scrollbar upcasts to *Scrollbar
func (recv *HScrollbar) Scrollbar() *Scrollbar {
	return ScrollbarNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *HScrollbar) Range() *Range {
	return recv.Scrollbar().Range()
}

// Widget upcasts to *Widget
func (recv *HScrollbar) Widget() *Widget {
	return recv.Scrollbar().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HScrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scrollbar().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HScrollbar) Object() *gobject.Object {
	return recv.Scrollbar().Object()
}

// CastToWidget down casts any arbitrary Object to HScrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a HScrollbar.
func CastToHScrollbar(object *gobject.Object) *HScrollbar {
	return HScrollbarNewFromC(object.ToC())
}

// HScrollbarNew is a wrapper around the C function gtk_hscrollbar_new.
func HScrollbarNew(adjustment *Adjustment) *HScrollbar {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_hscrollbar_new(c_adjustment)
	retGo := HScrollbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HScrollbar
func (recv *HScrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HScrollbar
func (recv *HScrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HScrollbar
func (recv *HScrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HSeparator is a wrapper around the C record GtkHSeparator.
type HSeparator struct {
	native *C.GtkHSeparator
	// separator : record
}

func HSeparatorNewFromC(u unsafe.Pointer) *HSeparator {
	c := (*C.GtkHSeparator)(u)
	if c == nil {
		return nil
	}

	g := &HSeparator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HSeparator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HSeparator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HSeparator with another HSeparator, and returns true if they represent the same GObject.
func (recv *HSeparator) Equals(other *HSeparator) bool {
	return other.ToC() == recv.ToC()
}

// Separator upcasts to *Separator
func (recv *HSeparator) Separator() *Separator {
	return SeparatorNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *HSeparator) Widget() *Widget {
	return recv.Separator().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HSeparator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Separator().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HSeparator) Object() *gobject.Object {
	return recv.Separator().Object()
}

// CastToWidget down casts any arbitrary Object to HSeparator.
// Exercise care, as this is a potentially dangerous function if the Object is not a HSeparator.
func CastToHSeparator(object *gobject.Object) *HSeparator {
	return HSeparatorNewFromC(object.ToC())
}

// HSeparatorNew is a wrapper around the C function gtk_hseparator_new.
func HSeparatorNew() *HSeparator {
	retC := C.gtk_hseparator_new()
	retGo := HSeparatorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by HSeparator
func (recv *HSeparator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HSeparator
func (recv *HSeparator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by HSeparator
func (recv *HSeparator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// HandleBox is a wrapper around the C record GtkHandleBox.
type HandleBox struct {
	native *C.GtkHandleBox
	// bin : record
	// Private : priv
}

func HandleBoxNewFromC(u unsafe.Pointer) *HandleBox {
	c := (*C.GtkHandleBox)(u)
	if c == nil {
		return nil
	}

	g := &HandleBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HandleBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HandleBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HandleBox with another HandleBox, and returns true if they represent the same GObject.
func (recv *HandleBox) Equals(other *HandleBox) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *HandleBox) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *HandleBox) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *HandleBox) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HandleBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HandleBox) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to HandleBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a HandleBox.
func CastToHandleBox(object *gobject.Object) *HandleBox {
	return HandleBoxNewFromC(object.ToC())
}

type signalHandleBoxChildAttachedDetail struct {
	callback  HandleBoxSignalChildAttachedCallback
	handlerID C.gulong
}

var signalHandleBoxChildAttachedId int
var signalHandleBoxChildAttachedMap = make(map[int]signalHandleBoxChildAttachedDetail)
var signalHandleBoxChildAttachedLock sync.RWMutex

// HandleBoxSignalChildAttachedCallback is a callback function for a 'child-attached' signal emitted from a HandleBox.
type HandleBoxSignalChildAttachedCallback func(widget *Widget)

/*
ConnectChildAttached connects the callback to the 'child-attached' signal for the HandleBox.

The returned value represents the connection, and may be passed to DisconnectChildAttached to remove it.
*/
func (recv *HandleBox) ConnectChildAttached(callback HandleBoxSignalChildAttachedCallback) int {
	signalHandleBoxChildAttachedLock.Lock()
	defer signalHandleBoxChildAttachedLock.Unlock()

	signalHandleBoxChildAttachedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HandleBox_signal_connect_child_attached(instance, C.gpointer(uintptr(signalHandleBoxChildAttachedId)))

	detail := signalHandleBoxChildAttachedDetail{callback, handlerID}
	signalHandleBoxChildAttachedMap[signalHandleBoxChildAttachedId] = detail

	return signalHandleBoxChildAttachedId
}

/*
DisconnectChildAttached disconnects a callback from the 'child-attached' signal for the HandleBox.

The connectionID should be a value returned from a call to ConnectChildAttached.
*/
func (recv *HandleBox) DisconnectChildAttached(connectionID int) {
	signalHandleBoxChildAttachedLock.Lock()
	defer signalHandleBoxChildAttachedLock.Unlock()

	detail, exists := signalHandleBoxChildAttachedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHandleBoxChildAttachedMap, connectionID)
}

//export handlebox_childAttachedHandler
func handlebox_childAttachedHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	signalHandleBoxChildAttachedLock.RLock()
	defer signalHandleBoxChildAttachedLock.RUnlock()

	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalHandleBoxChildAttachedMap[index].callback
	callback(widget)
}

type signalHandleBoxChildDetachedDetail struct {
	callback  HandleBoxSignalChildDetachedCallback
	handlerID C.gulong
}

var signalHandleBoxChildDetachedId int
var signalHandleBoxChildDetachedMap = make(map[int]signalHandleBoxChildDetachedDetail)
var signalHandleBoxChildDetachedLock sync.RWMutex

// HandleBoxSignalChildDetachedCallback is a callback function for a 'child-detached' signal emitted from a HandleBox.
type HandleBoxSignalChildDetachedCallback func(widget *Widget)

/*
ConnectChildDetached connects the callback to the 'child-detached' signal for the HandleBox.

The returned value represents the connection, and may be passed to DisconnectChildDetached to remove it.
*/
func (recv *HandleBox) ConnectChildDetached(callback HandleBoxSignalChildDetachedCallback) int {
	signalHandleBoxChildDetachedLock.Lock()
	defer signalHandleBoxChildDetachedLock.Unlock()

	signalHandleBoxChildDetachedId++
	instance := C.gpointer(recv.native)
	handlerID := C.HandleBox_signal_connect_child_detached(instance, C.gpointer(uintptr(signalHandleBoxChildDetachedId)))

	detail := signalHandleBoxChildDetachedDetail{callback, handlerID}
	signalHandleBoxChildDetachedMap[signalHandleBoxChildDetachedId] = detail

	return signalHandleBoxChildDetachedId
}

/*
DisconnectChildDetached disconnects a callback from the 'child-detached' signal for the HandleBox.

The connectionID should be a value returned from a call to ConnectChildDetached.
*/
func (recv *HandleBox) DisconnectChildDetached(connectionID int) {
	signalHandleBoxChildDetachedLock.Lock()
	defer signalHandleBoxChildDetachedLock.Unlock()

	detail, exists := signalHandleBoxChildDetachedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalHandleBoxChildDetachedMap, connectionID)
}

//export handlebox_childDetachedHandler
func handlebox_childDetachedHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	signalHandleBoxChildDetachedLock.RLock()
	defer signalHandleBoxChildDetachedLock.RUnlock()

	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalHandleBoxChildDetachedMap[index].callback
	callback(widget)
}

// HandleBoxNew is a wrapper around the C function gtk_handle_box_new.
func HandleBoxNew() *HandleBox {
	retC := C.gtk_handle_box_new()
	retGo := HandleBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetHandlePosition is a wrapper around the C function gtk_handle_box_get_handle_position.
func (recv *HandleBox) GetHandlePosition() PositionType {
	retC := C.gtk_handle_box_get_handle_position((*C.GtkHandleBox)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// GetShadowType is a wrapper around the C function gtk_handle_box_get_shadow_type.
func (recv *HandleBox) GetShadowType() ShadowType {
	retC := C.gtk_handle_box_get_shadow_type((*C.GtkHandleBox)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// GetSnapEdge is a wrapper around the C function gtk_handle_box_get_snap_edge.
func (recv *HandleBox) GetSnapEdge() PositionType {
	retC := C.gtk_handle_box_get_snap_edge((*C.GtkHandleBox)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// SetHandlePosition is a wrapper around the C function gtk_handle_box_set_handle_position.
func (recv *HandleBox) SetHandlePosition(position PositionType) {
	c_position := (C.GtkPositionType)(position)

	C.gtk_handle_box_set_handle_position((*C.GtkHandleBox)(recv.native), c_position)

	return
}

// SetShadowType is a wrapper around the C function gtk_handle_box_set_shadow_type.
func (recv *HandleBox) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_handle_box_set_shadow_type((*C.GtkHandleBox)(recv.native), c_type)

	return
}

// SetSnapEdge is a wrapper around the C function gtk_handle_box_set_snap_edge.
func (recv *HandleBox) SetSnapEdge(edge PositionType) {
	c_edge := (C.GtkPositionType)(edge)

	C.gtk_handle_box_set_snap_edge((*C.GtkHandleBox)(recv.native), c_edge)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by HandleBox
func (recv *HandleBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HandleBox
func (recv *HandleBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// HeaderBar is a wrapper around the C record GtkHeaderBar.
type HeaderBar struct {
	native *C.GtkHeaderBar
	// container : record
}

func HeaderBarNewFromC(u unsafe.Pointer) *HeaderBar {
	c := (*C.GtkHeaderBar)(u)
	if c == nil {
		return nil
	}

	g := &HeaderBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *HeaderBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *HeaderBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HeaderBar with another HeaderBar, and returns true if they represent the same GObject.
func (recv *HeaderBar) Equals(other *HeaderBar) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *HeaderBar) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *HeaderBar) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *HeaderBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *HeaderBar) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to HeaderBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a HeaderBar.
func CastToHeaderBar(object *gobject.Object) *HeaderBar {
	return HeaderBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by HeaderBar
func (recv *HeaderBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by HeaderBar
func (recv *HeaderBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// IMContext is a wrapper around the C record GtkIMContext.
type IMContext struct {
	native *C.GtkIMContext
	// parent_instance : record
}

func IMContextNewFromC(u unsafe.Pointer) *IMContext {
	c := (*C.GtkIMContext)(u)
	if c == nil {
		return nil
	}

	g := &IMContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IMContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IMContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMContext with another IMContext, and returns true if they represent the same GObject.
func (recv *IMContext) Equals(other *IMContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IMContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IMContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMContext.
func CastToIMContext(object *gobject.Object) *IMContext {
	return IMContextNewFromC(object.ToC())
}

type signalIMContextCommitDetail struct {
	callback  IMContextSignalCommitCallback
	handlerID C.gulong
}

var signalIMContextCommitId int
var signalIMContextCommitMap = make(map[int]signalIMContextCommitDetail)
var signalIMContextCommitLock sync.RWMutex

// IMContextSignalCommitCallback is a callback function for a 'commit' signal emitted from a IMContext.
type IMContextSignalCommitCallback func(str string)

/*
ConnectCommit connects the callback to the 'commit' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectCommit to remove it.
*/
func (recv *IMContext) ConnectCommit(callback IMContextSignalCommitCallback) int {
	signalIMContextCommitLock.Lock()
	defer signalIMContextCommitLock.Unlock()

	signalIMContextCommitId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_commit(instance, C.gpointer(uintptr(signalIMContextCommitId)))

	detail := signalIMContextCommitDetail{callback, handlerID}
	signalIMContextCommitMap[signalIMContextCommitId] = detail

	return signalIMContextCommitId
}

/*
DisconnectCommit disconnects a callback from the 'commit' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectCommit.
*/
func (recv *IMContext) DisconnectCommit(connectionID int) {
	signalIMContextCommitLock.Lock()
	defer signalIMContextCommitLock.Unlock()

	detail, exists := signalIMContextCommitMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextCommitMap, connectionID)
}

//export imcontext_commitHandler
func imcontext_commitHandler(_ *C.GObject, c_str *C.gchar, data C.gpointer) {
	signalIMContextCommitLock.RLock()
	defer signalIMContextCommitLock.RUnlock()

	str := C.GoString(c_str)

	index := int(uintptr(data))
	callback := signalIMContextCommitMap[index].callback
	callback(str)
}

type signalIMContextDeleteSurroundingDetail struct {
	callback  IMContextSignalDeleteSurroundingCallback
	handlerID C.gulong
}

var signalIMContextDeleteSurroundingId int
var signalIMContextDeleteSurroundingMap = make(map[int]signalIMContextDeleteSurroundingDetail)
var signalIMContextDeleteSurroundingLock sync.RWMutex

// IMContextSignalDeleteSurroundingCallback is a callback function for a 'delete-surrounding' signal emitted from a IMContext.
type IMContextSignalDeleteSurroundingCallback func(offset int32, nChars int32) bool

/*
ConnectDeleteSurrounding connects the callback to the 'delete-surrounding' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectDeleteSurrounding to remove it.
*/
func (recv *IMContext) ConnectDeleteSurrounding(callback IMContextSignalDeleteSurroundingCallback) int {
	signalIMContextDeleteSurroundingLock.Lock()
	defer signalIMContextDeleteSurroundingLock.Unlock()

	signalIMContextDeleteSurroundingId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_delete_surrounding(instance, C.gpointer(uintptr(signalIMContextDeleteSurroundingId)))

	detail := signalIMContextDeleteSurroundingDetail{callback, handlerID}
	signalIMContextDeleteSurroundingMap[signalIMContextDeleteSurroundingId] = detail

	return signalIMContextDeleteSurroundingId
}

/*
DisconnectDeleteSurrounding disconnects a callback from the 'delete-surrounding' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectDeleteSurrounding.
*/
func (recv *IMContext) DisconnectDeleteSurrounding(connectionID int) {
	signalIMContextDeleteSurroundingLock.Lock()
	defer signalIMContextDeleteSurroundingLock.Unlock()

	detail, exists := signalIMContextDeleteSurroundingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextDeleteSurroundingMap, connectionID)
}

//export imcontext_deleteSurroundingHandler
func imcontext_deleteSurroundingHandler(_ *C.GObject, c_offset C.gint, c_n_chars C.gint, data C.gpointer) C.gboolean {
	signalIMContextDeleteSurroundingLock.RLock()
	defer signalIMContextDeleteSurroundingLock.RUnlock()

	offset := int32(c_offset)

	nChars := int32(c_n_chars)

	index := int(uintptr(data))
	callback := signalIMContextDeleteSurroundingMap[index].callback
	retGo := callback(offset, nChars)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalIMContextPreeditChangedDetail struct {
	callback  IMContextSignalPreeditChangedCallback
	handlerID C.gulong
}

var signalIMContextPreeditChangedId int
var signalIMContextPreeditChangedMap = make(map[int]signalIMContextPreeditChangedDetail)
var signalIMContextPreeditChangedLock sync.RWMutex

// IMContextSignalPreeditChangedCallback is a callback function for a 'preedit-changed' signal emitted from a IMContext.
type IMContextSignalPreeditChangedCallback func()

/*
ConnectPreeditChanged connects the callback to the 'preedit-changed' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditChanged to remove it.
*/
func (recv *IMContext) ConnectPreeditChanged(callback IMContextSignalPreeditChangedCallback) int {
	signalIMContextPreeditChangedLock.Lock()
	defer signalIMContextPreeditChangedLock.Unlock()

	signalIMContextPreeditChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_changed(instance, C.gpointer(uintptr(signalIMContextPreeditChangedId)))

	detail := signalIMContextPreeditChangedDetail{callback, handlerID}
	signalIMContextPreeditChangedMap[signalIMContextPreeditChangedId] = detail

	return signalIMContextPreeditChangedId
}

/*
DisconnectPreeditChanged disconnects a callback from the 'preedit-changed' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditChanged.
*/
func (recv *IMContext) DisconnectPreeditChanged(connectionID int) {
	signalIMContextPreeditChangedLock.Lock()
	defer signalIMContextPreeditChangedLock.Unlock()

	detail, exists := signalIMContextPreeditChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditChangedMap, connectionID)
}

//export imcontext_preeditChangedHandler
func imcontext_preeditChangedHandler(_ *C.GObject, data C.gpointer) {
	signalIMContextPreeditChangedLock.RLock()
	defer signalIMContextPreeditChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIMContextPreeditChangedMap[index].callback
	callback()
}

type signalIMContextPreeditEndDetail struct {
	callback  IMContextSignalPreeditEndCallback
	handlerID C.gulong
}

var signalIMContextPreeditEndId int
var signalIMContextPreeditEndMap = make(map[int]signalIMContextPreeditEndDetail)
var signalIMContextPreeditEndLock sync.RWMutex

// IMContextSignalPreeditEndCallback is a callback function for a 'preedit-end' signal emitted from a IMContext.
type IMContextSignalPreeditEndCallback func()

/*
ConnectPreeditEnd connects the callback to the 'preedit-end' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditEnd to remove it.
*/
func (recv *IMContext) ConnectPreeditEnd(callback IMContextSignalPreeditEndCallback) int {
	signalIMContextPreeditEndLock.Lock()
	defer signalIMContextPreeditEndLock.Unlock()

	signalIMContextPreeditEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_end(instance, C.gpointer(uintptr(signalIMContextPreeditEndId)))

	detail := signalIMContextPreeditEndDetail{callback, handlerID}
	signalIMContextPreeditEndMap[signalIMContextPreeditEndId] = detail

	return signalIMContextPreeditEndId
}

/*
DisconnectPreeditEnd disconnects a callback from the 'preedit-end' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditEnd.
*/
func (recv *IMContext) DisconnectPreeditEnd(connectionID int) {
	signalIMContextPreeditEndLock.Lock()
	defer signalIMContextPreeditEndLock.Unlock()

	detail, exists := signalIMContextPreeditEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditEndMap, connectionID)
}

//export imcontext_preeditEndHandler
func imcontext_preeditEndHandler(_ *C.GObject, data C.gpointer) {
	signalIMContextPreeditEndLock.RLock()
	defer signalIMContextPreeditEndLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIMContextPreeditEndMap[index].callback
	callback()
}

type signalIMContextPreeditStartDetail struct {
	callback  IMContextSignalPreeditStartCallback
	handlerID C.gulong
}

var signalIMContextPreeditStartId int
var signalIMContextPreeditStartMap = make(map[int]signalIMContextPreeditStartDetail)
var signalIMContextPreeditStartLock sync.RWMutex

// IMContextSignalPreeditStartCallback is a callback function for a 'preedit-start' signal emitted from a IMContext.
type IMContextSignalPreeditStartCallback func()

/*
ConnectPreeditStart connects the callback to the 'preedit-start' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectPreeditStart to remove it.
*/
func (recv *IMContext) ConnectPreeditStart(callback IMContextSignalPreeditStartCallback) int {
	signalIMContextPreeditStartLock.Lock()
	defer signalIMContextPreeditStartLock.Unlock()

	signalIMContextPreeditStartId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_preedit_start(instance, C.gpointer(uintptr(signalIMContextPreeditStartId)))

	detail := signalIMContextPreeditStartDetail{callback, handlerID}
	signalIMContextPreeditStartMap[signalIMContextPreeditStartId] = detail

	return signalIMContextPreeditStartId
}

/*
DisconnectPreeditStart disconnects a callback from the 'preedit-start' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectPreeditStart.
*/
func (recv *IMContext) DisconnectPreeditStart(connectionID int) {
	signalIMContextPreeditStartLock.Lock()
	defer signalIMContextPreeditStartLock.Unlock()

	detail, exists := signalIMContextPreeditStartMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextPreeditStartMap, connectionID)
}

//export imcontext_preeditStartHandler
func imcontext_preeditStartHandler(_ *C.GObject, data C.gpointer) {
	signalIMContextPreeditStartLock.RLock()
	defer signalIMContextPreeditStartLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIMContextPreeditStartMap[index].callback
	callback()
}

type signalIMContextRetrieveSurroundingDetail struct {
	callback  IMContextSignalRetrieveSurroundingCallback
	handlerID C.gulong
}

var signalIMContextRetrieveSurroundingId int
var signalIMContextRetrieveSurroundingMap = make(map[int]signalIMContextRetrieveSurroundingDetail)
var signalIMContextRetrieveSurroundingLock sync.RWMutex

// IMContextSignalRetrieveSurroundingCallback is a callback function for a 'retrieve-surrounding' signal emitted from a IMContext.
type IMContextSignalRetrieveSurroundingCallback func() bool

/*
ConnectRetrieveSurrounding connects the callback to the 'retrieve-surrounding' signal for the IMContext.

The returned value represents the connection, and may be passed to DisconnectRetrieveSurrounding to remove it.
*/
func (recv *IMContext) ConnectRetrieveSurrounding(callback IMContextSignalRetrieveSurroundingCallback) int {
	signalIMContextRetrieveSurroundingLock.Lock()
	defer signalIMContextRetrieveSurroundingLock.Unlock()

	signalIMContextRetrieveSurroundingId++
	instance := C.gpointer(recv.native)
	handlerID := C.IMContext_signal_connect_retrieve_surrounding(instance, C.gpointer(uintptr(signalIMContextRetrieveSurroundingId)))

	detail := signalIMContextRetrieveSurroundingDetail{callback, handlerID}
	signalIMContextRetrieveSurroundingMap[signalIMContextRetrieveSurroundingId] = detail

	return signalIMContextRetrieveSurroundingId
}

/*
DisconnectRetrieveSurrounding disconnects a callback from the 'retrieve-surrounding' signal for the IMContext.

The connectionID should be a value returned from a call to ConnectRetrieveSurrounding.
*/
func (recv *IMContext) DisconnectRetrieveSurrounding(connectionID int) {
	signalIMContextRetrieveSurroundingLock.Lock()
	defer signalIMContextRetrieveSurroundingLock.Unlock()

	detail, exists := signalIMContextRetrieveSurroundingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIMContextRetrieveSurroundingMap, connectionID)
}

//export imcontext_retrieveSurroundingHandler
func imcontext_retrieveSurroundingHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalIMContextRetrieveSurroundingLock.RLock()
	defer signalIMContextRetrieveSurroundingLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIMContextRetrieveSurroundingMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// DeleteSurrounding is a wrapper around the C function gtk_im_context_delete_surrounding.
func (recv *IMContext) DeleteSurrounding(offset int32, nChars int32) bool {
	c_offset := (C.gint)(offset)

	c_n_chars := (C.gint)(nChars)

	retC := C.gtk_im_context_delete_surrounding((*C.GtkIMContext)(recv.native), c_offset, c_n_chars)
	retGo := retC == C.TRUE

	return retGo
}

// FilterKeypress is a wrapper around the C function gtk_im_context_filter_keypress.
func (recv *IMContext) FilterKeypress(event *gdk.EventKey) bool {
	c_event := (*C.GdkEventKey)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEventKey)(event.ToC())
	}

	retC := C.gtk_im_context_filter_keypress((*C.GtkIMContext)(recv.native), c_event)
	retGo := retC == C.TRUE

	return retGo
}

// FocusIn is a wrapper around the C function gtk_im_context_focus_in.
func (recv *IMContext) FocusIn() {
	C.gtk_im_context_focus_in((*C.GtkIMContext)(recv.native))

	return
}

// FocusOut is a wrapper around the C function gtk_im_context_focus_out.
func (recv *IMContext) FocusOut() {
	C.gtk_im_context_focus_out((*C.GtkIMContext)(recv.native))

	return
}

// GetPreeditString is a wrapper around the C function gtk_im_context_get_preedit_string.
func (recv *IMContext) GetPreeditString() (string, *pango.AttrList, int32) {
	var c_str *C.gchar

	var c_attrs *C.PangoAttrList

	var c_cursor_pos C.gint

	C.gtk_im_context_get_preedit_string((*C.GtkIMContext)(recv.native), &c_str, &c_attrs, &c_cursor_pos)

	str := C.GoString(c_str)
	defer C.free(unsafe.Pointer(c_str))

	attrs := pango.AttrListNewFromC(unsafe.Pointer(c_attrs))

	cursorPos := (int32)(c_cursor_pos)

	return str, attrs, cursorPos
}

// GetSurrounding is a wrapper around the C function gtk_im_context_get_surrounding.
func (recv *IMContext) GetSurrounding() (bool, string, int32) {
	var c_text *C.gchar

	var c_cursor_index C.gint

	retC := C.gtk_im_context_get_surrounding((*C.GtkIMContext)(recv.native), &c_text, &c_cursor_index)
	retGo := retC == C.TRUE

	text := C.GoString(c_text)
	defer C.free(unsafe.Pointer(c_text))

	cursorIndex := (int32)(c_cursor_index)

	return retGo, text, cursorIndex
}

// Reset is a wrapper around the C function gtk_im_context_reset.
func (recv *IMContext) Reset() {
	C.gtk_im_context_reset((*C.GtkIMContext)(recv.native))

	return
}

// SetClientWindow is a wrapper around the C function gtk_im_context_set_client_window.
func (recv *IMContext) SetClientWindow(window *gdk.Window) {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	C.gtk_im_context_set_client_window((*C.GtkIMContext)(recv.native), c_window)

	return
}

// SetCursorLocation is a wrapper around the C function gtk_im_context_set_cursor_location.
func (recv *IMContext) SetCursorLocation(area *gdk.Rectangle) {
	c_area := (*C.GdkRectangle)(C.NULL)
	if area != nil {
		c_area = (*C.GdkRectangle)(area.ToC())
	}

	C.gtk_im_context_set_cursor_location((*C.GtkIMContext)(recv.native), c_area)

	return
}

// SetSurrounding is a wrapper around the C function gtk_im_context_set_surrounding.
func (recv *IMContext) SetSurrounding(text string, len int32, cursorIndex int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_cursor_index := (C.gint)(cursorIndex)

	C.gtk_im_context_set_surrounding((*C.GtkIMContext)(recv.native), c_text, c_len, c_cursor_index)

	return
}

// SetUsePreedit is a wrapper around the C function gtk_im_context_set_use_preedit.
func (recv *IMContext) SetUsePreedit(usePreedit bool) {
	c_use_preedit :=
		boolToGboolean(usePreedit)

	C.gtk_im_context_set_use_preedit((*C.GtkIMContext)(recv.native), c_use_preedit)

	return
}

// IMContextSimple is a wrapper around the C record GtkIMContextSimple.
type IMContextSimple struct {
	native *C.GtkIMContextSimple
	// object : record
	// Private : priv
}

func IMContextSimpleNewFromC(u unsafe.Pointer) *IMContextSimple {
	c := (*C.GtkIMContextSimple)(u)
	if c == nil {
		return nil
	}

	g := &IMContextSimple{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IMContextSimple) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IMContextSimple) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMContextSimple with another IMContextSimple, and returns true if they represent the same GObject.
func (recv *IMContextSimple) Equals(other *IMContextSimple) bool {
	return other.ToC() == recv.ToC()
}

// IMContext upcasts to *IMContext
func (recv *IMContextSimple) IMContext() *IMContext {
	return IMContextNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *IMContextSimple) Object() *gobject.Object {
	return recv.IMContext().Object()
}

// CastToWidget down casts any arbitrary Object to IMContextSimple.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMContextSimple.
func CastToIMContextSimple(object *gobject.Object) *IMContextSimple {
	return IMContextSimpleNewFromC(object.ToC())
}

// IMContextSimpleNew is a wrapper around the C function gtk_im_context_simple_new.
func IMContextSimpleNew() *IMContextSimple {
	retC := C.gtk_im_context_simple_new()
	retGo := IMContextSimpleNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Blacklisted : gtk_im_context_simple_add_compose_file

// AddTable is a wrapper around the C function gtk_im_context_simple_add_table.
func (recv *IMContextSimple) AddTable(data []uint16, maxSeqLen int32, nSeqs int32) {
	c_data_array := make([]C.guint16, len(data)+1, len(data)+1)
	for i, item := range data {
		c := (C.guint16)(item)
		c_data_array[i] = c
	}
	c_data_array[len(data)] = 0
	c_data_arrayPtr := &c_data_array[0]
	c_data := (*C.guint16)(unsafe.Pointer(c_data_arrayPtr))

	c_max_seq_len := (C.gint)(maxSeqLen)

	c_n_seqs := (C.gint)(nSeqs)

	C.gtk_im_context_simple_add_table((*C.GtkIMContextSimple)(recv.native), c_data, c_max_seq_len, c_n_seqs)

	return
}

// IMMulticontext is a wrapper around the C record GtkIMMulticontext.
type IMMulticontext struct {
	native *C.GtkIMMulticontext
	// object : record
	// Private : priv
}

func IMMulticontextNewFromC(u unsafe.Pointer) *IMMulticontext {
	c := (*C.GtkIMMulticontext)(u)
	if c == nil {
		return nil
	}

	g := &IMMulticontext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IMMulticontext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IMMulticontext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMMulticontext with another IMMulticontext, and returns true if they represent the same GObject.
func (recv *IMMulticontext) Equals(other *IMMulticontext) bool {
	return other.ToC() == recv.ToC()
}

// IMContext upcasts to *IMContext
func (recv *IMMulticontext) IMContext() *IMContext {
	return IMContextNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *IMMulticontext) Object() *gobject.Object {
	return recv.IMContext().Object()
}

// CastToWidget down casts any arbitrary Object to IMMulticontext.
// Exercise care, as this is a potentially dangerous function if the Object is not a IMMulticontext.
func CastToIMMulticontext(object *gobject.Object) *IMMulticontext {
	return IMMulticontextNewFromC(object.ToC())
}

// IMMulticontextNew is a wrapper around the C function gtk_im_multicontext_new.
func IMMulticontextNew() *IMMulticontext {
	retC := C.gtk_im_multicontext_new()
	retGo := IMMulticontextNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AppendMenuitems is a wrapper around the C function gtk_im_multicontext_append_menuitems.
func (recv *IMMulticontext) AppendMenuitems(menushell *MenuShell) {
	c_menushell := (*C.GtkMenuShell)(C.NULL)
	if menushell != nil {
		c_menushell = (*C.GtkMenuShell)(menushell.ToC())
	}

	C.gtk_im_multicontext_append_menuitems((*C.GtkIMMulticontext)(recv.native), c_menushell)

	return
}

// IconFactory is a wrapper around the C record GtkIconFactory.
type IconFactory struct {
	native *C.GtkIconFactory
	// parent_instance : record
	// Private : priv
}

func IconFactoryNewFromC(u unsafe.Pointer) *IconFactory {
	c := (*C.GtkIconFactory)(u)
	if c == nil {
		return nil
	}

	g := &IconFactory{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconFactory) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconFactory) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconFactory with another IconFactory, and returns true if they represent the same GObject.
func (recv *IconFactory) Equals(other *IconFactory) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IconFactory) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IconFactory.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconFactory.
func CastToIconFactory(object *gobject.Object) *IconFactory {
	return IconFactoryNewFromC(object.ToC())
}

// IconFactoryNew is a wrapper around the C function gtk_icon_factory_new.
func IconFactoryNew() *IconFactory {
	retC := C.gtk_icon_factory_new()
	retGo := IconFactoryNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// IconFactoryLookupDefault is a wrapper around the C function gtk_icon_factory_lookup_default.
func IconFactoryLookupDefault(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_icon_factory_lookup_default(c_stock_id)
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Add is a wrapper around the C function gtk_icon_factory_add.
func (recv *IconFactory) Add(stockId string, iconSet *IconSet) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	C.gtk_icon_factory_add((*C.GtkIconFactory)(recv.native), c_stock_id, c_icon_set)

	return
}

// AddDefault is a wrapper around the C function gtk_icon_factory_add_default.
func (recv *IconFactory) AddDefault() {
	C.gtk_icon_factory_add_default((*C.GtkIconFactory)(recv.native))

	return
}

// Lookup is a wrapper around the C function gtk_icon_factory_lookup.
func (recv *IconFactory) Lookup(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_icon_factory_lookup((*C.GtkIconFactory)(recv.native), c_stock_id)
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RemoveDefault is a wrapper around the C function gtk_icon_factory_remove_default.
func (recv *IconFactory) RemoveDefault() {
	C.gtk_icon_factory_remove_default((*C.GtkIconFactory)(recv.native))

	return
}

// Buildable returns the Buildable interface implemented by IconFactory
func (recv *IconFactory) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// IconInfo is a wrapper around the C record GtkIconInfo.
type IconInfo struct {
	native *C.GtkIconInfo
}

func IconInfoNewFromC(u unsafe.Pointer) *IconInfo {
	c := (*C.GtkIconInfo)(u)
	if c == nil {
		return nil
	}

	g := &IconInfo{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconInfo) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconInfo with another IconInfo, and returns true if they represent the same GObject.
func (recv *IconInfo) Equals(other *IconInfo) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IconInfo) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IconInfo.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconInfo.
func CastToIconInfo(object *gobject.Object) *IconInfo {
	return IconInfoNewFromC(object.ToC())
}

// Copy is a wrapper around the C function gtk_icon_info_copy.
func (recv *IconInfo) Copy() *IconInfo {
	retC := C.gtk_icon_info_copy((*C.GtkIconInfo)(recv.native))
	retGo := IconInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_icon_info_free.
func (recv *IconInfo) Free() {
	C.gtk_icon_info_free((*C.GtkIconInfo)(recv.native))

	return
}

// Unsupported : gtk_icon_info_get_attach_points : unsupported parameter points : output array param points

// GetBaseSize is a wrapper around the C function gtk_icon_info_get_base_size.
func (recv *IconInfo) GetBaseSize() int32 {
	retC := C.gtk_icon_info_get_base_size((*C.GtkIconInfo)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetBuiltinPixbuf is a wrapper around the C function gtk_icon_info_get_builtin_pixbuf.
func (recv *IconInfo) GetBuiltinPixbuf() *gdkpixbuf.Pixbuf {
	retC := C.gtk_icon_info_get_builtin_pixbuf((*C.GtkIconInfo)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetDisplayName is a wrapper around the C function gtk_icon_info_get_display_name.
func (recv *IconInfo) GetDisplayName() string {
	retC := C.gtk_icon_info_get_display_name((*C.GtkIconInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetEmbeddedRect is a wrapper around the C function gtk_icon_info_get_embedded_rect.
func (recv *IconInfo) GetEmbeddedRect() (bool, *gdk.Rectangle) {
	var c_rectangle C.GdkRectangle

	retC := C.gtk_icon_info_get_embedded_rect((*C.GtkIconInfo)(recv.native), &c_rectangle)
	retGo := retC == C.TRUE

	rectangle := gdk.RectangleNewFromC(unsafe.Pointer(&c_rectangle))

	return retGo, rectangle
}

// GetFilename is a wrapper around the C function gtk_icon_info_get_filename.
func (recv *IconInfo) GetFilename() string {
	retC := C.gtk_icon_info_get_filename((*C.GtkIconInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// LoadIcon is a wrapper around the C function gtk_icon_info_load_icon.
func (recv *IconInfo) LoadIcon() (*gdkpixbuf.Pixbuf, error) {
	var cThrowableError *C.GError

	retC := C.gtk_icon_info_load_icon((*C.GtkIconInfo)(recv.native), &cThrowableError)
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetRawCoordinates is a wrapper around the C function gtk_icon_info_set_raw_coordinates.
func (recv *IconInfo) SetRawCoordinates(rawCoordinates bool) {
	c_raw_coordinates :=
		boolToGboolean(rawCoordinates)

	C.gtk_icon_info_set_raw_coordinates((*C.GtkIconInfo)(recv.native), c_raw_coordinates)

	return
}

// IconTheme is a wrapper around the C record GtkIconTheme.
type IconTheme struct {
	native *C.GtkIconTheme
	// Private : parent_instance
	// Private : priv
}

func IconThemeNewFromC(u unsafe.Pointer) *IconTheme {
	c := (*C.GtkIconTheme)(u)
	if c == nil {
		return nil
	}

	g := &IconTheme{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconTheme) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconTheme) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconTheme with another IconTheme, and returns true if they represent the same GObject.
func (recv *IconTheme) Equals(other *IconTheme) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *IconTheme) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to IconTheme.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconTheme.
func CastToIconTheme(object *gobject.Object) *IconTheme {
	return IconThemeNewFromC(object.ToC())
}

type signalIconThemeChangedDetail struct {
	callback  IconThemeSignalChangedCallback
	handlerID C.gulong
}

var signalIconThemeChangedId int
var signalIconThemeChangedMap = make(map[int]signalIconThemeChangedDetail)
var signalIconThemeChangedLock sync.RWMutex

// IconThemeSignalChangedCallback is a callback function for a 'changed' signal emitted from a IconTheme.
type IconThemeSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the IconTheme.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *IconTheme) ConnectChanged(callback IconThemeSignalChangedCallback) int {
	signalIconThemeChangedLock.Lock()
	defer signalIconThemeChangedLock.Unlock()

	signalIconThemeChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconTheme_signal_connect_changed(instance, C.gpointer(uintptr(signalIconThemeChangedId)))

	detail := signalIconThemeChangedDetail{callback, handlerID}
	signalIconThemeChangedMap[signalIconThemeChangedId] = detail

	return signalIconThemeChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the IconTheme.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *IconTheme) DisconnectChanged(connectionID int) {
	signalIconThemeChangedLock.Lock()
	defer signalIconThemeChangedLock.Unlock()

	detail, exists := signalIconThemeChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconThemeChangedMap, connectionID)
}

//export icontheme_changedHandler
func icontheme_changedHandler(_ *C.GObject, data C.gpointer) {
	signalIconThemeChangedLock.RLock()
	defer signalIconThemeChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconThemeChangedMap[index].callback
	callback()
}

// IconThemeNew is a wrapper around the C function gtk_icon_theme_new.
func IconThemeNew() *IconTheme {
	retC := C.gtk_icon_theme_new()
	retGo := IconThemeNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// IconThemeAddBuiltinIcon is a wrapper around the C function gtk_icon_theme_add_builtin_icon.
func IconThemeAddBuiltinIcon(iconName string, size int32, pixbuf *gdkpixbuf.Pixbuf) {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	c_size := (C.gint)(size)

	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_icon_theme_add_builtin_icon(c_icon_name, c_size, c_pixbuf)

	return
}

// IconThemeGetDefault is a wrapper around the C function gtk_icon_theme_get_default.
func IconThemeGetDefault() *IconTheme {
	retC := C.gtk_icon_theme_get_default()
	retGo := IconThemeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IconThemeGetForScreen is a wrapper around the C function gtk_icon_theme_get_for_screen.
func IconThemeGetForScreen(screen *gdk.Screen) *IconTheme {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	retC := C.gtk_icon_theme_get_for_screen(c_screen)
	retGo := IconThemeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppendSearchPath is a wrapper around the C function gtk_icon_theme_append_search_path.
func (recv *IconTheme) AppendSearchPath(path string) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	C.gtk_icon_theme_append_search_path((*C.GtkIconTheme)(recv.native), c_path)

	return
}

// Blacklisted : gtk_icon_theme_choose_icon

// GetExampleIconName is a wrapper around the C function gtk_icon_theme_get_example_icon_name.
func (recv *IconTheme) GetExampleIconName() string {
	retC := C.gtk_icon_theme_get_example_icon_name((*C.GtkIconTheme)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_icon_theme_get_icon_sizes : array return type :

// Unsupported : gtk_icon_theme_get_search_path : unsupported parameter path : output array param path

// HasIcon is a wrapper around the C function gtk_icon_theme_has_icon.
func (recv *IconTheme) HasIcon(iconName string) bool {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	retC := C.gtk_icon_theme_has_icon((*C.GtkIconTheme)(recv.native), c_icon_name)
	retGo := retC == C.TRUE

	return retGo
}

// ListContexts is a wrapper around the C function gtk_icon_theme_list_contexts.
func (recv *IconTheme) ListContexts() *glib.List {
	retC := C.gtk_icon_theme_list_contexts((*C.GtkIconTheme)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ListIcons is a wrapper around the C function gtk_icon_theme_list_icons.
func (recv *IconTheme) ListIcons(context string) *glib.List {
	c_context := C.CString(context)
	defer C.free(unsafe.Pointer(c_context))

	retC := C.gtk_icon_theme_list_icons((*C.GtkIconTheme)(recv.native), c_context)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// LoadIcon is a wrapper around the C function gtk_icon_theme_load_icon.
func (recv *IconTheme) LoadIcon(iconName string, size int32, flags IconLookupFlags) (*gdkpixbuf.Pixbuf, error) {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	c_size := (C.gint)(size)

	c_flags := (C.GtkIconLookupFlags)(flags)

	var cThrowableError *C.GError

	retC := C.gtk_icon_theme_load_icon((*C.GtkIconTheme)(recv.native), c_icon_name, c_size, c_flags, &cThrowableError)
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// LookupIcon is a wrapper around the C function gtk_icon_theme_lookup_icon.
func (recv *IconTheme) LookupIcon(iconName string, size int32, flags IconLookupFlags) *IconInfo {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	c_size := (C.gint)(size)

	c_flags := (C.GtkIconLookupFlags)(flags)

	retC := C.gtk_icon_theme_lookup_icon((*C.GtkIconTheme)(recv.native), c_icon_name, c_size, c_flags)
	var retGo (*IconInfo)
	if retC == nil {
		retGo = nil
	} else {
		retGo = IconInfoNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// PrependSearchPath is a wrapper around the C function gtk_icon_theme_prepend_search_path.
func (recv *IconTheme) PrependSearchPath(path string) {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	C.gtk_icon_theme_prepend_search_path((*C.GtkIconTheme)(recv.native), c_path)

	return
}

// RescanIfNeeded is a wrapper around the C function gtk_icon_theme_rescan_if_needed.
func (recv *IconTheme) RescanIfNeeded() bool {
	retC := C.gtk_icon_theme_rescan_if_needed((*C.GtkIconTheme)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetCustomTheme is a wrapper around the C function gtk_icon_theme_set_custom_theme.
func (recv *IconTheme) SetCustomTheme(themeName string) {
	c_theme_name := C.CString(themeName)
	defer C.free(unsafe.Pointer(c_theme_name))

	C.gtk_icon_theme_set_custom_theme((*C.GtkIconTheme)(recv.native), c_theme_name)

	return
}

// SetScreen is a wrapper around the C function gtk_icon_theme_set_screen.
func (recv *IconTheme) SetScreen(screen *gdk.Screen) {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	C.gtk_icon_theme_set_screen((*C.GtkIconTheme)(recv.native), c_screen)

	return
}

// Blacklisted : gtk_icon_theme_set_search_path

// IconView is a wrapper around the C record GtkIconView.
type IconView struct {
	native *C.GtkIconView
	// parent : record
	// Private : priv
}

func IconViewNewFromC(u unsafe.Pointer) *IconView {
	c := (*C.GtkIconView)(u)
	if c == nil {
		return nil
	}

	g := &IconView{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconView) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconView with another IconView, and returns true if they represent the same GObject.
func (recv *IconView) Equals(other *IconView) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *IconView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *IconView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *IconView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *IconView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to IconView.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconView.
func CastToIconView(object *gobject.Object) *IconView {
	return IconViewNewFromC(object.ToC())
}

type signalIconViewActivateCursorItemDetail struct {
	callback  IconViewSignalActivateCursorItemCallback
	handlerID C.gulong
}

var signalIconViewActivateCursorItemId int
var signalIconViewActivateCursorItemMap = make(map[int]signalIconViewActivateCursorItemDetail)
var signalIconViewActivateCursorItemLock sync.RWMutex

// IconViewSignalActivateCursorItemCallback is a callback function for a 'activate-cursor-item' signal emitted from a IconView.
type IconViewSignalActivateCursorItemCallback func() bool

/*
ConnectActivateCursorItem connects the callback to the 'activate-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectActivateCursorItem to remove it.
*/
func (recv *IconView) ConnectActivateCursorItem(callback IconViewSignalActivateCursorItemCallback) int {
	signalIconViewActivateCursorItemLock.Lock()
	defer signalIconViewActivateCursorItemLock.Unlock()

	signalIconViewActivateCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_activate_cursor_item(instance, C.gpointer(uintptr(signalIconViewActivateCursorItemId)))

	detail := signalIconViewActivateCursorItemDetail{callback, handlerID}
	signalIconViewActivateCursorItemMap[signalIconViewActivateCursorItemId] = detail

	return signalIconViewActivateCursorItemId
}

/*
DisconnectActivateCursorItem disconnects a callback from the 'activate-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectActivateCursorItem.
*/
func (recv *IconView) DisconnectActivateCursorItem(connectionID int) {
	signalIconViewActivateCursorItemLock.Lock()
	defer signalIconViewActivateCursorItemLock.Unlock()

	detail, exists := signalIconViewActivateCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewActivateCursorItemMap, connectionID)
}

//export iconview_activateCursorItemHandler
func iconview_activateCursorItemHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalIconViewActivateCursorItemLock.RLock()
	defer signalIconViewActivateCursorItemLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewActivateCursorItemMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalIconViewItemActivatedDetail struct {
	callback  IconViewSignalItemActivatedCallback
	handlerID C.gulong
}

var signalIconViewItemActivatedId int
var signalIconViewItemActivatedMap = make(map[int]signalIconViewItemActivatedDetail)
var signalIconViewItemActivatedLock sync.RWMutex

// IconViewSignalItemActivatedCallback is a callback function for a 'item-activated' signal emitted from a IconView.
type IconViewSignalItemActivatedCallback func(path *TreePath)

/*
ConnectItemActivated connects the callback to the 'item-activated' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectItemActivated to remove it.
*/
func (recv *IconView) ConnectItemActivated(callback IconViewSignalItemActivatedCallback) int {
	signalIconViewItemActivatedLock.Lock()
	defer signalIconViewItemActivatedLock.Unlock()

	signalIconViewItemActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_item_activated(instance, C.gpointer(uintptr(signalIconViewItemActivatedId)))

	detail := signalIconViewItemActivatedDetail{callback, handlerID}
	signalIconViewItemActivatedMap[signalIconViewItemActivatedId] = detail

	return signalIconViewItemActivatedId
}

/*
DisconnectItemActivated disconnects a callback from the 'item-activated' signal for the IconView.

The connectionID should be a value returned from a call to ConnectItemActivated.
*/
func (recv *IconView) DisconnectItemActivated(connectionID int) {
	signalIconViewItemActivatedLock.Lock()
	defer signalIconViewItemActivatedLock.Unlock()

	detail, exists := signalIconViewItemActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewItemActivatedMap, connectionID)
}

//export iconview_itemActivatedHandler
func iconview_itemActivatedHandler(_ *C.GObject, c_path *C.GtkTreePath, data C.gpointer) {
	signalIconViewItemActivatedLock.RLock()
	defer signalIconViewItemActivatedLock.RUnlock()

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalIconViewItemActivatedMap[index].callback
	callback(path)
}

type signalIconViewMoveCursorDetail struct {
	callback  IconViewSignalMoveCursorCallback
	handlerID C.gulong
}

var signalIconViewMoveCursorId int
var signalIconViewMoveCursorMap = make(map[int]signalIconViewMoveCursorDetail)
var signalIconViewMoveCursorLock sync.RWMutex

// IconViewSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a IconView.
type IconViewSignalMoveCursorCallback func(step MovementStep, count int32) bool

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *IconView) ConnectMoveCursor(callback IconViewSignalMoveCursorCallback) int {
	signalIconViewMoveCursorLock.Lock()
	defer signalIconViewMoveCursorLock.Unlock()

	signalIconViewMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalIconViewMoveCursorId)))

	detail := signalIconViewMoveCursorDetail{callback, handlerID}
	signalIconViewMoveCursorMap[signalIconViewMoveCursorId] = detail

	return signalIconViewMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the IconView.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *IconView) DisconnectMoveCursor(connectionID int) {
	signalIconViewMoveCursorLock.Lock()
	defer signalIconViewMoveCursorLock.Unlock()

	detail, exists := signalIconViewMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewMoveCursorMap, connectionID)
}

//export iconview_moveCursorHandler
func iconview_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, data C.gpointer) C.gboolean {
	signalIconViewMoveCursorLock.RLock()
	defer signalIconViewMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalIconViewMoveCursorMap[index].callback
	retGo := callback(step, count)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalIconViewSelectAllDetail struct {
	callback  IconViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalIconViewSelectAllId int
var signalIconViewSelectAllMap = make(map[int]signalIconViewSelectAllDetail)
var signalIconViewSelectAllLock sync.RWMutex

// IconViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a IconView.
type IconViewSignalSelectAllCallback func()

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *IconView) ConnectSelectAll(callback IconViewSignalSelectAllCallback) int {
	signalIconViewSelectAllLock.Lock()
	defer signalIconViewSelectAllLock.Unlock()

	signalIconViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_select_all(instance, C.gpointer(uintptr(signalIconViewSelectAllId)))

	detail := signalIconViewSelectAllDetail{callback, handlerID}
	signalIconViewSelectAllMap[signalIconViewSelectAllId] = detail

	return signalIconViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *IconView) DisconnectSelectAll(connectionID int) {
	signalIconViewSelectAllLock.Lock()
	defer signalIconViewSelectAllLock.Unlock()

	detail, exists := signalIconViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectAllMap, connectionID)
}

//export iconview_selectAllHandler
func iconview_selectAllHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewSelectAllLock.RLock()
	defer signalIconViewSelectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewSelectAllMap[index].callback
	callback()
}

type signalIconViewSelectCursorItemDetail struct {
	callback  IconViewSignalSelectCursorItemCallback
	handlerID C.gulong
}

var signalIconViewSelectCursorItemId int
var signalIconViewSelectCursorItemMap = make(map[int]signalIconViewSelectCursorItemDetail)
var signalIconViewSelectCursorItemLock sync.RWMutex

// IconViewSignalSelectCursorItemCallback is a callback function for a 'select-cursor-item' signal emitted from a IconView.
type IconViewSignalSelectCursorItemCallback func()

/*
ConnectSelectCursorItem connects the callback to the 'select-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorItem to remove it.
*/
func (recv *IconView) ConnectSelectCursorItem(callback IconViewSignalSelectCursorItemCallback) int {
	signalIconViewSelectCursorItemLock.Lock()
	defer signalIconViewSelectCursorItemLock.Unlock()

	signalIconViewSelectCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_select_cursor_item(instance, C.gpointer(uintptr(signalIconViewSelectCursorItemId)))

	detail := signalIconViewSelectCursorItemDetail{callback, handlerID}
	signalIconViewSelectCursorItemMap[signalIconViewSelectCursorItemId] = detail

	return signalIconViewSelectCursorItemId
}

/*
DisconnectSelectCursorItem disconnects a callback from the 'select-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectCursorItem.
*/
func (recv *IconView) DisconnectSelectCursorItem(connectionID int) {
	signalIconViewSelectCursorItemLock.Lock()
	defer signalIconViewSelectCursorItemLock.Unlock()

	detail, exists := signalIconViewSelectCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectCursorItemMap, connectionID)
}

//export iconview_selectCursorItemHandler
func iconview_selectCursorItemHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewSelectCursorItemLock.RLock()
	defer signalIconViewSelectCursorItemLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewSelectCursorItemMap[index].callback
	callback()
}

type signalIconViewSelectionChangedDetail struct {
	callback  IconViewSignalSelectionChangedCallback
	handlerID C.gulong
}

var signalIconViewSelectionChangedId int
var signalIconViewSelectionChangedMap = make(map[int]signalIconViewSelectionChangedDetail)
var signalIconViewSelectionChangedLock sync.RWMutex

// IconViewSignalSelectionChangedCallback is a callback function for a 'selection-changed' signal emitted from a IconView.
type IconViewSignalSelectionChangedCallback func()

/*
ConnectSelectionChanged connects the callback to the 'selection-changed' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectSelectionChanged to remove it.
*/
func (recv *IconView) ConnectSelectionChanged(callback IconViewSignalSelectionChangedCallback) int {
	signalIconViewSelectionChangedLock.Lock()
	defer signalIconViewSelectionChangedLock.Unlock()

	signalIconViewSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_selection_changed(instance, C.gpointer(uintptr(signalIconViewSelectionChangedId)))

	detail := signalIconViewSelectionChangedDetail{callback, handlerID}
	signalIconViewSelectionChangedMap[signalIconViewSelectionChangedId] = detail

	return signalIconViewSelectionChangedId
}

/*
DisconnectSelectionChanged disconnects a callback from the 'selection-changed' signal for the IconView.

The connectionID should be a value returned from a call to ConnectSelectionChanged.
*/
func (recv *IconView) DisconnectSelectionChanged(connectionID int) {
	signalIconViewSelectionChangedLock.Lock()
	defer signalIconViewSelectionChangedLock.Unlock()

	detail, exists := signalIconViewSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewSelectionChangedMap, connectionID)
}

//export iconview_selectionChangedHandler
func iconview_selectionChangedHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewSelectionChangedLock.RLock()
	defer signalIconViewSelectionChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewSelectionChangedMap[index].callback
	callback()
}

type signalIconViewToggleCursorItemDetail struct {
	callback  IconViewSignalToggleCursorItemCallback
	handlerID C.gulong
}

var signalIconViewToggleCursorItemId int
var signalIconViewToggleCursorItemMap = make(map[int]signalIconViewToggleCursorItemDetail)
var signalIconViewToggleCursorItemLock sync.RWMutex

// IconViewSignalToggleCursorItemCallback is a callback function for a 'toggle-cursor-item' signal emitted from a IconView.
type IconViewSignalToggleCursorItemCallback func()

/*
ConnectToggleCursorItem connects the callback to the 'toggle-cursor-item' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorItem to remove it.
*/
func (recv *IconView) ConnectToggleCursorItem(callback IconViewSignalToggleCursorItemCallback) int {
	signalIconViewToggleCursorItemLock.Lock()
	defer signalIconViewToggleCursorItemLock.Unlock()

	signalIconViewToggleCursorItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_toggle_cursor_item(instance, C.gpointer(uintptr(signalIconViewToggleCursorItemId)))

	detail := signalIconViewToggleCursorItemDetail{callback, handlerID}
	signalIconViewToggleCursorItemMap[signalIconViewToggleCursorItemId] = detail

	return signalIconViewToggleCursorItemId
}

/*
DisconnectToggleCursorItem disconnects a callback from the 'toggle-cursor-item' signal for the IconView.

The connectionID should be a value returned from a call to ConnectToggleCursorItem.
*/
func (recv *IconView) DisconnectToggleCursorItem(connectionID int) {
	signalIconViewToggleCursorItemLock.Lock()
	defer signalIconViewToggleCursorItemLock.Unlock()

	detail, exists := signalIconViewToggleCursorItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewToggleCursorItemMap, connectionID)
}

//export iconview_toggleCursorItemHandler
func iconview_toggleCursorItemHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewToggleCursorItemLock.RLock()
	defer signalIconViewToggleCursorItemLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewToggleCursorItemMap[index].callback
	callback()
}

type signalIconViewUnselectAllDetail struct {
	callback  IconViewSignalUnselectAllCallback
	handlerID C.gulong
}

var signalIconViewUnselectAllId int
var signalIconViewUnselectAllMap = make(map[int]signalIconViewUnselectAllDetail)
var signalIconViewUnselectAllLock sync.RWMutex

// IconViewSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a IconView.
type IconViewSignalUnselectAllCallback func()

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the IconView.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *IconView) ConnectUnselectAll(callback IconViewSignalUnselectAllCallback) int {
	signalIconViewUnselectAllLock.Lock()
	defer signalIconViewUnselectAllLock.Unlock()

	signalIconViewUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.IconView_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalIconViewUnselectAllId)))

	detail := signalIconViewUnselectAllDetail{callback, handlerID}
	signalIconViewUnselectAllMap[signalIconViewUnselectAllId] = detail

	return signalIconViewUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the IconView.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *IconView) DisconnectUnselectAll(connectionID int) {
	signalIconViewUnselectAllLock.Lock()
	defer signalIconViewUnselectAllLock.Unlock()

	detail, exists := signalIconViewUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalIconViewUnselectAllMap, connectionID)
}

//export iconview_unselectAllHandler
func iconview_unselectAllHandler(_ *C.GObject, data C.gpointer) {
	signalIconViewUnselectAllLock.RLock()
	defer signalIconViewUnselectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalIconViewUnselectAllMap[index].callback
	callback()
}

// IconViewNew is a wrapper around the C function gtk_icon_view_new.
func IconViewNew() *IconView {
	retC := C.gtk_icon_view_new()
	retGo := IconViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IconViewNewWithModel is a wrapper around the C function gtk_icon_view_new_with_model.
func IconViewNewWithModel(model *TreeModel) *IconView {
	c_model := (*C.GtkTreeModel)(model.ToC())

	retC := C.gtk_icon_view_new_with_model(c_model)
	retGo := IconViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ConvertWidgetToBinWindowCoords is a wrapper around the C function gtk_icon_view_convert_widget_to_bin_window_coords.
func (recv *IconView) ConvertWidgetToBinWindowCoords(wx int32, wy int32) (int32, int32) {
	c_wx := (C.gint)(wx)

	c_wy := (C.gint)(wy)

	var c_bx C.gint

	var c_by C.gint

	C.gtk_icon_view_convert_widget_to_bin_window_coords((*C.GtkIconView)(recv.native), c_wx, c_wy, &c_bx, &c_by)

	bx := (int32)(c_bx)

	by := (int32)(c_by)

	return bx, by
}

// CreateDragIcon is a wrapper around the C function gtk_icon_view_create_drag_icon.
func (recv *IconView) CreateDragIcon(path *TreePath) *cairo.Surface {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_icon_view_create_drag_icon((*C.GtkIconView)(recv.native), c_path)
	retGo := cairo.SurfaceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_icon_view_enable_model_drag_dest : unsupported parameter targets :

// Unsupported : gtk_icon_view_enable_model_drag_source : unsupported parameter targets :

// GetColumnSpacing is a wrapper around the C function gtk_icon_view_get_column_spacing.
func (recv *IconView) GetColumnSpacing() int32 {
	retC := C.gtk_icon_view_get_column_spacing((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetColumns is a wrapper around the C function gtk_icon_view_get_columns.
func (recv *IconView) GetColumns() int32 {
	retC := C.gtk_icon_view_get_columns((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetCursor is a wrapper around the C function gtk_icon_view_get_cursor.
func (recv *IconView) GetCursor() (bool, *TreePath, *CellRenderer) {
	var c_path *C.GtkTreePath

	var c_cell *C.GtkCellRenderer

	retC := C.gtk_icon_view_get_cursor((*C.GtkIconView)(recv.native), &c_path, &c_cell)
	retGo := retC == C.TRUE

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	cell := CellRendererNewFromC(unsafe.Pointer(c_cell))

	return retGo, path, cell
}

// GetDestItemAtPos is a wrapper around the C function gtk_icon_view_get_dest_item_at_pos.
func (recv *IconView) GetDestItemAtPos(dragX int32, dragY int32) (bool, *TreePath, IconViewDropPosition) {
	c_drag_x := (C.gint)(dragX)

	c_drag_y := (C.gint)(dragY)

	var c_path *C.GtkTreePath

	var c_pos C.GtkIconViewDropPosition

	retC := C.gtk_icon_view_get_dest_item_at_pos((*C.GtkIconView)(recv.native), c_drag_x, c_drag_y, &c_path, &c_pos)
	retGo := retC == C.TRUE

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	pos := (IconViewDropPosition)(c_pos)

	return retGo, path, pos
}

// GetDragDestItem is a wrapper around the C function gtk_icon_view_get_drag_dest_item.
func (recv *IconView) GetDragDestItem() (*TreePath, IconViewDropPosition) {
	var c_path *C.GtkTreePath

	var c_pos C.GtkIconViewDropPosition

	C.gtk_icon_view_get_drag_dest_item((*C.GtkIconView)(recv.native), &c_path, &c_pos)

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	pos := (IconViewDropPosition)(c_pos)

	return path, pos
}

// GetItemAtPos is a wrapper around the C function gtk_icon_view_get_item_at_pos.
func (recv *IconView) GetItemAtPos(x int32, y int32) (bool, *TreePath, *CellRenderer) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	var c_path *C.GtkTreePath

	var c_cell *C.GtkCellRenderer

	retC := C.gtk_icon_view_get_item_at_pos((*C.GtkIconView)(recv.native), c_x, c_y, &c_path, &c_cell)
	retGo := retC == C.TRUE

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	cell := CellRendererNewFromC(unsafe.Pointer(c_cell))

	return retGo, path, cell
}

// GetItemOrientation is a wrapper around the C function gtk_icon_view_get_item_orientation.
func (recv *IconView) GetItemOrientation() Orientation {
	retC := C.gtk_icon_view_get_item_orientation((*C.GtkIconView)(recv.native))
	retGo := (Orientation)(retC)

	return retGo
}

// GetItemWidth is a wrapper around the C function gtk_icon_view_get_item_width.
func (recv *IconView) GetItemWidth() int32 {
	retC := C.gtk_icon_view_get_item_width((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMargin is a wrapper around the C function gtk_icon_view_get_margin.
func (recv *IconView) GetMargin() int32 {
	retC := C.gtk_icon_view_get_margin((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMarkupColumn is a wrapper around the C function gtk_icon_view_get_markup_column.
func (recv *IconView) GetMarkupColumn() int32 {
	retC := C.gtk_icon_view_get_markup_column((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetModel is a wrapper around the C function gtk_icon_view_get_model.
func (recv *IconView) GetModel() *TreeModel {
	retC := C.gtk_icon_view_get_model((*C.GtkIconView)(recv.native))
	var retGo (*TreeModel)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreeModelNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPathAtPos is a wrapper around the C function gtk_icon_view_get_path_at_pos.
func (recv *IconView) GetPathAtPos(x int32, y int32) *TreePath {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	retC := C.gtk_icon_view_get_path_at_pos((*C.GtkIconView)(recv.native), c_x, c_y)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPixbufColumn is a wrapper around the C function gtk_icon_view_get_pixbuf_column.
func (recv *IconView) GetPixbufColumn() int32 {
	retC := C.gtk_icon_view_get_pixbuf_column((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetReorderable is a wrapper around the C function gtk_icon_view_get_reorderable.
func (recv *IconView) GetReorderable() bool {
	retC := C.gtk_icon_view_get_reorderable((*C.GtkIconView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetRowSpacing is a wrapper around the C function gtk_icon_view_get_row_spacing.
func (recv *IconView) GetRowSpacing() int32 {
	retC := C.gtk_icon_view_get_row_spacing((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetSelectedItems is a wrapper around the C function gtk_icon_view_get_selected_items.
func (recv *IconView) GetSelectedItems() *glib.List {
	retC := C.gtk_icon_view_get_selected_items((*C.GtkIconView)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSelectionMode is a wrapper around the C function gtk_icon_view_get_selection_mode.
func (recv *IconView) GetSelectionMode() SelectionMode {
	retC := C.gtk_icon_view_get_selection_mode((*C.GtkIconView)(recv.native))
	retGo := (SelectionMode)(retC)

	return retGo
}

// GetSpacing is a wrapper around the C function gtk_icon_view_get_spacing.
func (recv *IconView) GetSpacing() int32 {
	retC := C.gtk_icon_view_get_spacing((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetTextColumn is a wrapper around the C function gtk_icon_view_get_text_column.
func (recv *IconView) GetTextColumn() int32 {
	retC := C.gtk_icon_view_get_text_column((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetTooltipColumn is a wrapper around the C function gtk_icon_view_get_tooltip_column.
func (recv *IconView) GetTooltipColumn() int32 {
	retC := C.gtk_icon_view_get_tooltip_column((*C.GtkIconView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetTooltipContext is a wrapper around the C function gtk_icon_view_get_tooltip_context.
func (recv *IconView) GetTooltipContext(x int32, y int32, keyboardTip bool) (bool, *TreeModel, *TreePath, *TreeIter) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_keyboard_tip :=
		boolToGboolean(keyboardTip)

	var c_model *C.GtkTreeModel

	var c_path *C.GtkTreePath

	var c_iter C.GtkTreeIter

	retC := C.gtk_icon_view_get_tooltip_context((*C.GtkIconView)(recv.native), &c_x, &c_y, c_keyboard_tip, &c_model, &c_path, &c_iter)
	retGo := retC == C.TRUE

	model := TreeModelNewFromC(unsafe.Pointer(c_model))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, model, path, iter
}

// GetVisibleRange is a wrapper around the C function gtk_icon_view_get_visible_range.
func (recv *IconView) GetVisibleRange() (bool, *TreePath, *TreePath) {
	var c_start_path *C.GtkTreePath

	var c_end_path *C.GtkTreePath

	retC := C.gtk_icon_view_get_visible_range((*C.GtkIconView)(recv.native), &c_start_path, &c_end_path)
	retGo := retC == C.TRUE

	startPath := TreePathNewFromC(unsafe.Pointer(c_start_path))

	endPath := TreePathNewFromC(unsafe.Pointer(c_end_path))

	return retGo, startPath, endPath
}

// ItemActivated is a wrapper around the C function gtk_icon_view_item_activated.
func (recv *IconView) ItemActivated(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_icon_view_item_activated((*C.GtkIconView)(recv.native), c_path)

	return
}

// PathIsSelected is a wrapper around the C function gtk_icon_view_path_is_selected.
func (recv *IconView) PathIsSelected(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_icon_view_path_is_selected((*C.GtkIconView)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// ScrollToPath is a wrapper around the C function gtk_icon_view_scroll_to_path.
func (recv *IconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_use_align :=
		boolToGboolean(useAlign)

	c_row_align := (C.gfloat)(rowAlign)

	c_col_align := (C.gfloat)(colAlign)

	C.gtk_icon_view_scroll_to_path((*C.GtkIconView)(recv.native), c_path, c_use_align, c_row_align, c_col_align)

	return
}

// SelectAll is a wrapper around the C function gtk_icon_view_select_all.
func (recv *IconView) SelectAll() {
	C.gtk_icon_view_select_all((*C.GtkIconView)(recv.native))

	return
}

// SelectPath is a wrapper around the C function gtk_icon_view_select_path.
func (recv *IconView) SelectPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_icon_view_select_path((*C.GtkIconView)(recv.native), c_path)

	return
}

// Unsupported : gtk_icon_view_selected_foreach : unsupported parameter func : no type generator for IconViewForeachFunc (GtkIconViewForeachFunc) for param func

// SetColumnSpacing is a wrapper around the C function gtk_icon_view_set_column_spacing.
func (recv *IconView) SetColumnSpacing(columnSpacing int32) {
	c_column_spacing := (C.gint)(columnSpacing)

	C.gtk_icon_view_set_column_spacing((*C.GtkIconView)(recv.native), c_column_spacing)

	return
}

// SetColumns is a wrapper around the C function gtk_icon_view_set_columns.
func (recv *IconView) SetColumns(columns int32) {
	c_columns := (C.gint)(columns)

	C.gtk_icon_view_set_columns((*C.GtkIconView)(recv.native), c_columns)

	return
}

// SetCursor is a wrapper around the C function gtk_icon_view_set_cursor.
func (recv *IconView) SetCursor(path *TreePath, cell *CellRenderer, startEditing bool) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_start_editing :=
		boolToGboolean(startEditing)

	C.gtk_icon_view_set_cursor((*C.GtkIconView)(recv.native), c_path, c_cell, c_start_editing)

	return
}

// SetDragDestItem is a wrapper around the C function gtk_icon_view_set_drag_dest_item.
func (recv *IconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_pos := (C.GtkIconViewDropPosition)(pos)

	C.gtk_icon_view_set_drag_dest_item((*C.GtkIconView)(recv.native), c_path, c_pos)

	return
}

// SetItemOrientation is a wrapper around the C function gtk_icon_view_set_item_orientation.
func (recv *IconView) SetItemOrientation(orientation Orientation) {
	c_orientation := (C.GtkOrientation)(orientation)

	C.gtk_icon_view_set_item_orientation((*C.GtkIconView)(recv.native), c_orientation)

	return
}

// SetItemWidth is a wrapper around the C function gtk_icon_view_set_item_width.
func (recv *IconView) SetItemWidth(itemWidth int32) {
	c_item_width := (C.gint)(itemWidth)

	C.gtk_icon_view_set_item_width((*C.GtkIconView)(recv.native), c_item_width)

	return
}

// SetMargin is a wrapper around the C function gtk_icon_view_set_margin.
func (recv *IconView) SetMargin(margin int32) {
	c_margin := (C.gint)(margin)

	C.gtk_icon_view_set_margin((*C.GtkIconView)(recv.native), c_margin)

	return
}

// SetMarkupColumn is a wrapper around the C function gtk_icon_view_set_markup_column.
func (recv *IconView) SetMarkupColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_icon_view_set_markup_column((*C.GtkIconView)(recv.native), c_column)

	return
}

// SetModel is a wrapper around the C function gtk_icon_view_set_model.
func (recv *IconView) SetModel(model *TreeModel) {
	c_model := (*C.GtkTreeModel)(model.ToC())

	C.gtk_icon_view_set_model((*C.GtkIconView)(recv.native), c_model)

	return
}

// SetPixbufColumn is a wrapper around the C function gtk_icon_view_set_pixbuf_column.
func (recv *IconView) SetPixbufColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_icon_view_set_pixbuf_column((*C.GtkIconView)(recv.native), c_column)

	return
}

// SetReorderable is a wrapper around the C function gtk_icon_view_set_reorderable.
func (recv *IconView) SetReorderable(reorderable bool) {
	c_reorderable :=
		boolToGboolean(reorderable)

	C.gtk_icon_view_set_reorderable((*C.GtkIconView)(recv.native), c_reorderable)

	return
}

// SetRowSpacing is a wrapper around the C function gtk_icon_view_set_row_spacing.
func (recv *IconView) SetRowSpacing(rowSpacing int32) {
	c_row_spacing := (C.gint)(rowSpacing)

	C.gtk_icon_view_set_row_spacing((*C.GtkIconView)(recv.native), c_row_spacing)

	return
}

// SetSelectionMode is a wrapper around the C function gtk_icon_view_set_selection_mode.
func (recv *IconView) SetSelectionMode(mode SelectionMode) {
	c_mode := (C.GtkSelectionMode)(mode)

	C.gtk_icon_view_set_selection_mode((*C.GtkIconView)(recv.native), c_mode)

	return
}

// SetSpacing is a wrapper around the C function gtk_icon_view_set_spacing.
func (recv *IconView) SetSpacing(spacing int32) {
	c_spacing := (C.gint)(spacing)

	C.gtk_icon_view_set_spacing((*C.GtkIconView)(recv.native), c_spacing)

	return
}

// SetTextColumn is a wrapper around the C function gtk_icon_view_set_text_column.
func (recv *IconView) SetTextColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_icon_view_set_text_column((*C.GtkIconView)(recv.native), c_column)

	return
}

// SetTooltipCell is a wrapper around the C function gtk_icon_view_set_tooltip_cell.
func (recv *IconView) SetTooltipCell(tooltip *Tooltip, path *TreePath, cell *CellRenderer) {
	c_tooltip := (*C.GtkTooltip)(C.NULL)
	if tooltip != nil {
		c_tooltip = (*C.GtkTooltip)(tooltip.ToC())
	}

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	C.gtk_icon_view_set_tooltip_cell((*C.GtkIconView)(recv.native), c_tooltip, c_path, c_cell)

	return
}

// SetTooltipColumn is a wrapper around the C function gtk_icon_view_set_tooltip_column.
func (recv *IconView) SetTooltipColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_icon_view_set_tooltip_column((*C.GtkIconView)(recv.native), c_column)

	return
}

// SetTooltipItem is a wrapper around the C function gtk_icon_view_set_tooltip_item.
func (recv *IconView) SetTooltipItem(tooltip *Tooltip, path *TreePath) {
	c_tooltip := (*C.GtkTooltip)(C.NULL)
	if tooltip != nil {
		c_tooltip = (*C.GtkTooltip)(tooltip.ToC())
	}

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_icon_view_set_tooltip_item((*C.GtkIconView)(recv.native), c_tooltip, c_path)

	return
}

// UnselectAll is a wrapper around the C function gtk_icon_view_unselect_all.
func (recv *IconView) UnselectAll() {
	C.gtk_icon_view_unselect_all((*C.GtkIconView)(recv.native))

	return
}

// UnselectPath is a wrapper around the C function gtk_icon_view_unselect_path.
func (recv *IconView) UnselectPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_icon_view_unselect_path((*C.GtkIconView)(recv.native), c_path)

	return
}

// UnsetModelDragDest is a wrapper around the C function gtk_icon_view_unset_model_drag_dest.
func (recv *IconView) UnsetModelDragDest() {
	C.gtk_icon_view_unset_model_drag_dest((*C.GtkIconView)(recv.native))

	return
}

// UnsetModelDragSource is a wrapper around the C function gtk_icon_view_unset_model_drag_source.
func (recv *IconView) UnsetModelDragSource() {
	C.gtk_icon_view_unset_model_drag_source((*C.GtkIconView)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by IconView
func (recv *IconView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by IconView
func (recv *IconView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by IconView
func (recv *IconView) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by IconView
func (recv *IconView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// IconViewAccessible is a wrapper around the C record GtkIconViewAccessible.
type IconViewAccessible struct {
	native *C.GtkIconViewAccessible
	// parent : record
	// priv : record
}

func IconViewAccessibleNewFromC(u unsafe.Pointer) *IconViewAccessible {
	c := (*C.GtkIconViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &IconViewAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *IconViewAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *IconViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconViewAccessible with another IconViewAccessible, and returns true if they represent the same GObject.
func (recv *IconViewAccessible) Equals(other *IconViewAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *IconViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *IconViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *IconViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *IconViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to IconViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a IconViewAccessible.
func CastToIconViewAccessible(object *gobject.Object) *IconViewAccessible {
	return IconViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by IconViewAccessible
func (recv *IconViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by IconViewAccessible
func (recv *IconViewAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Image is a wrapper around the C record GtkImage.
type Image struct {
	native *C.GtkImage
	// misc : record
	// Private : priv
}

func ImageNewFromC(u unsafe.Pointer) *Image {
	c := (*C.GtkImage)(u)
	if c == nil {
		return nil
	}

	g := &Image{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Image) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Image) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Image with another Image, and returns true if they represent the same GObject.
func (recv *Image) Equals(other *Image) bool {
	return other.ToC() == recv.ToC()
}

// Misc upcasts to *Misc
func (recv *Image) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Image) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Image) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Image) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitrary Object to Image.
// Exercise care, as this is a potentially dangerous function if the Object is not a Image.
func CastToImage(object *gobject.Object) *Image {
	return ImageNewFromC(object.ToC())
}

// ImageNew is a wrapper around the C function gtk_image_new.
func ImageNew() *Image {
	retC := C.gtk_image_new()
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageNewFromAnimation is a wrapper around the C function gtk_image_new_from_animation.
func ImageNewFromAnimation(animation *gdkpixbuf.PixbufAnimation) *Image {
	c_animation := (*C.GdkPixbufAnimation)(C.NULL)
	if animation != nil {
		c_animation = (*C.GdkPixbufAnimation)(animation.ToC())
	}

	retC := C.gtk_image_new_from_animation(c_animation)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageNewFromFile is a wrapper around the C function gtk_image_new_from_file.
func ImageNewFromFile(filename string) *Image {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.gtk_image_new_from_file(c_filename)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageNewFromIconName is a wrapper around the C function gtk_image_new_from_icon_name.
func ImageNewFromIconName(iconName string, size IconSize) *Image {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	c_size := (C.GtkIconSize)(size)

	retC := C.gtk_image_new_from_icon_name(c_icon_name, c_size)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageNewFromIconSet is a wrapper around the C function gtk_image_new_from_icon_set.
func ImageNewFromIconSet(iconSet *IconSet, size IconSize) *Image {
	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	c_size := (C.GtkIconSize)(size)

	retC := C.gtk_image_new_from_icon_set(c_icon_set, c_size)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageNewFromPixbuf is a wrapper around the C function gtk_image_new_from_pixbuf.
func ImageNewFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *Image {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	retC := C.gtk_image_new_from_pixbuf(c_pixbuf)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageNewFromStock is a wrapper around the C function gtk_image_new_from_stock.
func ImageNewFromStock(stockId string, size IconSize) *Image {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	retC := C.gtk_image_new_from_stock(c_stock_id, c_size)
	retGo := ImageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Clear is a wrapper around the C function gtk_image_clear.
func (recv *Image) Clear() {
	C.gtk_image_clear((*C.GtkImage)(recv.native))

	return
}

// GetAnimation is a wrapper around the C function gtk_image_get_animation.
func (recv *Image) GetAnimation() *gdkpixbuf.PixbufAnimation {
	retC := C.gtk_image_get_animation((*C.GtkImage)(recv.native))
	var retGo (*gdkpixbuf.PixbufAnimation)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufAnimationNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetIconName is a wrapper around the C function gtk_image_get_icon_name.
func (recv *Image) GetIconName() (string, int32) {
	var c_icon_name *C.gchar

	var c_size C.GtkIconSize

	C.gtk_image_get_icon_name((*C.GtkImage)(recv.native), &c_icon_name, &c_size)

	iconName := C.GoString(c_icon_name)

	size := (int32)(c_size)

	return iconName, size
}

// GetIconSet is a wrapper around the C function gtk_image_get_icon_set.
func (recv *Image) GetIconSet() (*IconSet, int32) {
	var c_icon_set *C.GtkIconSet

	var c_size C.GtkIconSize

	C.gtk_image_get_icon_set((*C.GtkImage)(recv.native), &c_icon_set, &c_size)

	iconSet := IconSetNewFromC(unsafe.Pointer(c_icon_set))

	size := (int32)(c_size)

	return iconSet, size
}

// GetPixbuf is a wrapper around the C function gtk_image_get_pixbuf.
func (recv *Image) GetPixbuf() *gdkpixbuf.Pixbuf {
	retC := C.gtk_image_get_pixbuf((*C.GtkImage)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPixelSize is a wrapper around the C function gtk_image_get_pixel_size.
func (recv *Image) GetPixelSize() int32 {
	retC := C.gtk_image_get_pixel_size((*C.GtkImage)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetStock is a wrapper around the C function gtk_image_get_stock.
func (recv *Image) GetStock() (string, int32) {
	var c_stock_id *C.gchar

	var c_size C.GtkIconSize

	C.gtk_image_get_stock((*C.GtkImage)(recv.native), &c_stock_id, &c_size)

	stockId := C.GoString(c_stock_id)

	size := (int32)(c_size)

	return stockId, size
}

// GetStorageType is a wrapper around the C function gtk_image_get_storage_type.
func (recv *Image) GetStorageType() ImageType {
	retC := C.gtk_image_get_storage_type((*C.GtkImage)(recv.native))
	retGo := (ImageType)(retC)

	return retGo
}

// SetFromAnimation is a wrapper around the C function gtk_image_set_from_animation.
func (recv *Image) SetFromAnimation(animation *gdkpixbuf.PixbufAnimation) {
	c_animation := (*C.GdkPixbufAnimation)(C.NULL)
	if animation != nil {
		c_animation = (*C.GdkPixbufAnimation)(animation.ToC())
	}

	C.gtk_image_set_from_animation((*C.GtkImage)(recv.native), c_animation)

	return
}

// SetFromFile is a wrapper around the C function gtk_image_set_from_file.
func (recv *Image) SetFromFile(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_image_set_from_file((*C.GtkImage)(recv.native), c_filename)

	return
}

// SetFromIconName is a wrapper around the C function gtk_image_set_from_icon_name.
func (recv *Image) SetFromIconName(iconName string, size IconSize) {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	c_size := (C.GtkIconSize)(size)

	C.gtk_image_set_from_icon_name((*C.GtkImage)(recv.native), c_icon_name, c_size)

	return
}

// SetFromIconSet is a wrapper around the C function gtk_image_set_from_icon_set.
func (recv *Image) SetFromIconSet(iconSet *IconSet, size IconSize) {
	c_icon_set := (*C.GtkIconSet)(C.NULL)
	if iconSet != nil {
		c_icon_set = (*C.GtkIconSet)(iconSet.ToC())
	}

	c_size := (C.GtkIconSize)(size)

	C.gtk_image_set_from_icon_set((*C.GtkImage)(recv.native), c_icon_set, c_size)

	return
}

// SetFromPixbuf is a wrapper around the C function gtk_image_set_from_pixbuf.
func (recv *Image) SetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_image_set_from_pixbuf((*C.GtkImage)(recv.native), c_pixbuf)

	return
}

// SetFromResource is a wrapper around the C function gtk_image_set_from_resource.
func (recv *Image) SetFromResource(resourcePath string) {
	c_resource_path := C.CString(resourcePath)
	defer C.free(unsafe.Pointer(c_resource_path))

	C.gtk_image_set_from_resource((*C.GtkImage)(recv.native), c_resource_path)

	return
}

// SetFromStock is a wrapper around the C function gtk_image_set_from_stock.
func (recv *Image) SetFromStock(stockId string, size IconSize) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	C.gtk_image_set_from_stock((*C.GtkImage)(recv.native), c_stock_id, c_size)

	return
}

// SetPixelSize is a wrapper around the C function gtk_image_set_pixel_size.
func (recv *Image) SetPixelSize(pixelSize int32) {
	c_pixel_size := (C.gint)(pixelSize)

	C.gtk_image_set_pixel_size((*C.GtkImage)(recv.native), c_pixel_size)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Image
func (recv *Image) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Image
func (recv *Image) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ImageAccessible is a wrapper around the C record GtkImageAccessible.
type ImageAccessible struct {
	native *C.GtkImageAccessible
	// parent : record
	// priv : record
}

func ImageAccessibleNewFromC(u unsafe.Pointer) *ImageAccessible {
	c := (*C.GtkImageAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ImageAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ImageAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ImageAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageAccessible with another ImageAccessible, and returns true if they represent the same GObject.
func (recv *ImageAccessible) Equals(other *ImageAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ImageAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ImageAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ImageAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ImageAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageAccessible.
func CastToImageAccessible(object *gobject.Object) *ImageAccessible {
	return ImageAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ImageAccessible
func (recv *ImageAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ImageAccessible
func (recv *ImageAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ImageCellAccessible is a wrapper around the C record GtkImageCellAccessible.
type ImageCellAccessible struct {
	native *C.GtkImageCellAccessible
	// parent : record
	// priv : record
}

func ImageCellAccessibleNewFromC(u unsafe.Pointer) *ImageCellAccessible {
	c := (*C.GtkImageCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ImageCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ImageCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ImageCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageCellAccessible with another ImageCellAccessible, and returns true if they represent the same GObject.
func (recv *ImageCellAccessible) Equals(other *ImageCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *ImageCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *ImageCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ImageCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ImageCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ImageCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageCellAccessible.
func CastToImageCellAccessible(object *gobject.Object) *ImageCellAccessible {
	return ImageCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ImageCellAccessible
func (recv *ImageCellAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ImageMenuItem is a wrapper around the C record GtkImageMenuItem.
type ImageMenuItem struct {
	native *C.GtkImageMenuItem
	// menu_item : record
	// Private : priv
}

func ImageMenuItemNewFromC(u unsafe.Pointer) *ImageMenuItem {
	c := (*C.GtkImageMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &ImageMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ImageMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ImageMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageMenuItem with another ImageMenuItem, and returns true if they represent the same GObject.
func (recv *ImageMenuItem) Equals(other *ImageMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// MenuItem upcasts to *MenuItem
func (recv *ImageMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ImageMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *ImageMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *ImageMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ImageMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ImageMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to ImageMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a ImageMenuItem.
func CastToImageMenuItem(object *gobject.Object) *ImageMenuItem {
	return ImageMenuItemNewFromC(object.ToC())
}

// ImageMenuItemNew is a wrapper around the C function gtk_image_menu_item_new.
func ImageMenuItemNew() *ImageMenuItem {
	retC := C.gtk_image_menu_item_new()
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageMenuItemNewFromStock is a wrapper around the C function gtk_image_menu_item_new_from_stock.
func ImageMenuItemNewFromStock(stockId string, accelGroup *AccelGroup) *ImageMenuItem {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	retC := C.gtk_image_menu_item_new_from_stock(c_stock_id, c_accel_group)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageMenuItemNewWithLabel is a wrapper around the C function gtk_image_menu_item_new_with_label.
func ImageMenuItemNewWithLabel(label string) *ImageMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_image_menu_item_new_with_label(c_label)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImageMenuItemNewWithMnemonic is a wrapper around the C function gtk_image_menu_item_new_with_mnemonic.
func ImageMenuItemNewWithMnemonic(label string) *ImageMenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_image_menu_item_new_with_mnemonic(c_label)
	retGo := ImageMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetImage is a wrapper around the C function gtk_image_menu_item_get_image.
func (recv *ImageMenuItem) GetImage() *Widget {
	retC := C.gtk_image_menu_item_get_image((*C.GtkImageMenuItem)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetImage is a wrapper around the C function gtk_image_menu_item_set_image.
func (recv *ImageMenuItem) SetImage(image *Widget) {
	c_image := (*C.GtkWidget)(C.NULL)
	if image != nil {
		c_image = (*C.GtkWidget)(image.ToC())
	}

	C.gtk_image_menu_item_set_image((*C.GtkImageMenuItem)(recv.native), c_image)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ImageMenuItem
func (recv *ImageMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ImageMenuItem
func (recv *ImageMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// InfoBar is a wrapper around the C record GtkInfoBar.
type InfoBar struct {
	native *C.GtkInfoBar
	// parent : record
	// Private : priv
}

func InfoBarNewFromC(u unsafe.Pointer) *InfoBar {
	c := (*C.GtkInfoBar)(u)
	if c == nil {
		return nil
	}

	g := &InfoBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *InfoBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *InfoBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InfoBar with another InfoBar, and returns true if they represent the same GObject.
func (recv *InfoBar) Equals(other *InfoBar) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *InfoBar) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *InfoBar) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *InfoBar) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *InfoBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *InfoBar) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to InfoBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a InfoBar.
func CastToInfoBar(object *gobject.Object) *InfoBar {
	return InfoBarNewFromC(object.ToC())
}

// Unsupported : gtk_info_bar_new_with_buttons : unsupported parameter ... : varargs

// ImplementorIface returns the ImplementorIface interface implemented by InfoBar
func (recv *InfoBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by InfoBar
func (recv *InfoBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by InfoBar
func (recv *InfoBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Invisible is a wrapper around the C record GtkInvisible.
type Invisible struct {
	native *C.GtkInvisible
	// widget : record
	// Private : priv
}

func InvisibleNewFromC(u unsafe.Pointer) *Invisible {
	c := (*C.GtkInvisible)(u)
	if c == nil {
		return nil
	}

	g := &Invisible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Invisible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Invisible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Invisible with another Invisible, and returns true if they represent the same GObject.
func (recv *Invisible) Equals(other *Invisible) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Invisible) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Invisible) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Invisible) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Invisible.
// Exercise care, as this is a potentially dangerous function if the Object is not a Invisible.
func CastToInvisible(object *gobject.Object) *Invisible {
	return InvisibleNewFromC(object.ToC())
}

// InvisibleNew is a wrapper around the C function gtk_invisible_new.
func InvisibleNew() *Invisible {
	retC := C.gtk_invisible_new()
	retGo := InvisibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// InvisibleNewForScreen is a wrapper around the C function gtk_invisible_new_for_screen.
func InvisibleNewForScreen(screen *gdk.Screen) *Invisible {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	retC := C.gtk_invisible_new_for_screen(c_screen)
	retGo := InvisibleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetScreen is a wrapper around the C function gtk_invisible_get_screen.
func (recv *Invisible) GetScreen() *gdk.Screen {
	retC := C.gtk_invisible_get_screen((*C.GtkInvisible)(recv.native))
	retGo := gdk.ScreenNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetScreen is a wrapper around the C function gtk_invisible_set_screen.
func (recv *Invisible) SetScreen(screen *gdk.Screen) {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	C.gtk_invisible_set_screen((*C.GtkInvisible)(recv.native), c_screen)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Invisible
func (recv *Invisible) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Invisible
func (recv *Invisible) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Label is a wrapper around the C record GtkLabel.
type Label struct {
	native *C.GtkLabel
	// misc : record
	// Private : priv
}

func LabelNewFromC(u unsafe.Pointer) *Label {
	c := (*C.GtkLabel)(u)
	if c == nil {
		return nil
	}

	g := &Label{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Label) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Label) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Label with another Label, and returns true if they represent the same GObject.
func (recv *Label) Equals(other *Label) bool {
	return other.ToC() == recv.ToC()
}

// Misc upcasts to *Misc
func (recv *Label) Misc() *Misc {
	return MiscNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Label) Widget() *Widget {
	return recv.Misc().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Label) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Misc().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Label) Object() *gobject.Object {
	return recv.Misc().Object()
}

// CastToWidget down casts any arbitrary Object to Label.
// Exercise care, as this is a potentially dangerous function if the Object is not a Label.
func CastToLabel(object *gobject.Object) *Label {
	return LabelNewFromC(object.ToC())
}

type signalLabelCopyClipboardDetail struct {
	callback  LabelSignalCopyClipboardCallback
	handlerID C.gulong
}

var signalLabelCopyClipboardId int
var signalLabelCopyClipboardMap = make(map[int]signalLabelCopyClipboardDetail)
var signalLabelCopyClipboardLock sync.RWMutex

// LabelSignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a Label.
type LabelSignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *Label) ConnectCopyClipboard(callback LabelSignalCopyClipboardCallback) int {
	signalLabelCopyClipboardLock.Lock()
	defer signalLabelCopyClipboardLock.Unlock()

	signalLabelCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalLabelCopyClipboardId)))

	detail := signalLabelCopyClipboardDetail{callback, handlerID}
	signalLabelCopyClipboardMap[signalLabelCopyClipboardId] = detail

	return signalLabelCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the Label.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *Label) DisconnectCopyClipboard(connectionID int) {
	signalLabelCopyClipboardLock.Lock()
	defer signalLabelCopyClipboardLock.Unlock()

	detail, exists := signalLabelCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelCopyClipboardMap, connectionID)
}

//export label_copyClipboardHandler
func label_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalLabelCopyClipboardLock.RLock()
	defer signalLabelCopyClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalLabelCopyClipboardMap[index].callback
	callback()
}

type signalLabelMoveCursorDetail struct {
	callback  LabelSignalMoveCursorCallback
	handlerID C.gulong
}

var signalLabelMoveCursorId int
var signalLabelMoveCursorMap = make(map[int]signalLabelMoveCursorDetail)
var signalLabelMoveCursorLock sync.RWMutex

// LabelSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a Label.
type LabelSignalMoveCursorCallback func(step MovementStep, count int32, extendSelection bool)

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *Label) ConnectMoveCursor(callback LabelSignalMoveCursorCallback) int {
	signalLabelMoveCursorLock.Lock()
	defer signalLabelMoveCursorLock.Unlock()

	signalLabelMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalLabelMoveCursorId)))

	detail := signalLabelMoveCursorDetail{callback, handlerID}
	signalLabelMoveCursorMap[signalLabelMoveCursorId] = detail

	return signalLabelMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the Label.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *Label) DisconnectMoveCursor(connectionID int) {
	signalLabelMoveCursorLock.Lock()
	defer signalLabelMoveCursorLock.Unlock()

	detail, exists := signalLabelMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelMoveCursorMap, connectionID)
}

//export label_moveCursorHandler
func label_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, c_extend_selection C.gboolean, data C.gpointer) {
	signalLabelMoveCursorLock.RLock()
	defer signalLabelMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	extendSelection := c_extend_selection == C.TRUE

	index := int(uintptr(data))
	callback := signalLabelMoveCursorMap[index].callback
	callback(step, count, extendSelection)
}

type signalLabelPopulatePopupDetail struct {
	callback  LabelSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalLabelPopulatePopupId int
var signalLabelPopulatePopupMap = make(map[int]signalLabelPopulatePopupDetail)
var signalLabelPopulatePopupLock sync.RWMutex

// LabelSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a Label.
type LabelSignalPopulatePopupCallback func(menu *Menu)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the Label.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *Label) ConnectPopulatePopup(callback LabelSignalPopulatePopupCallback) int {
	signalLabelPopulatePopupLock.Lock()
	defer signalLabelPopulatePopupLock.Unlock()

	signalLabelPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.Label_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalLabelPopulatePopupId)))

	detail := signalLabelPopulatePopupDetail{callback, handlerID}
	signalLabelPopulatePopupMap[signalLabelPopulatePopupId] = detail

	return signalLabelPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the Label.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *Label) DisconnectPopulatePopup(connectionID int) {
	signalLabelPopulatePopupLock.Lock()
	defer signalLabelPopulatePopupLock.Unlock()

	detail, exists := signalLabelPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLabelPopulatePopupMap, connectionID)
}

//export label_populatePopupHandler
func label_populatePopupHandler(_ *C.GObject, c_menu *C.GtkMenu, data C.gpointer) {
	signalLabelPopulatePopupLock.RLock()
	defer signalLabelPopulatePopupLock.RUnlock()

	menu := MenuNewFromC(unsafe.Pointer(c_menu))

	index := int(uintptr(data))
	callback := signalLabelPopulatePopupMap[index].callback
	callback(menu)
}

// LabelNew is a wrapper around the C function gtk_label_new.
func LabelNew(str string) *Label {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	retC := C.gtk_label_new(c_str)
	retGo := LabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// LabelNewWithMnemonic is a wrapper around the C function gtk_label_new_with_mnemonic.
func LabelNewWithMnemonic(str string) *Label {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	retC := C.gtk_label_new_with_mnemonic(c_str)
	retGo := LabelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAngle is a wrapper around the C function gtk_label_get_angle.
func (recv *Label) GetAngle() float64 {
	retC := C.gtk_label_get_angle((*C.GtkLabel)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetAttributes is a wrapper around the C function gtk_label_get_attributes.
func (recv *Label) GetAttributes() *pango.AttrList {
	retC := C.gtk_label_get_attributes((*C.GtkLabel)(recv.native))
	var retGo (*pango.AttrList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = pango.AttrListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetEllipsize is a wrapper around the C function gtk_label_get_ellipsize.
func (recv *Label) GetEllipsize() pango.EllipsizeMode {
	retC := C.gtk_label_get_ellipsize((*C.GtkLabel)(recv.native))
	retGo := (pango.EllipsizeMode)(retC)

	return retGo
}

// GetJustify is a wrapper around the C function gtk_label_get_justify.
func (recv *Label) GetJustify() Justification {
	retC := C.gtk_label_get_justify((*C.GtkLabel)(recv.native))
	retGo := (Justification)(retC)

	return retGo
}

// GetLabel is a wrapper around the C function gtk_label_get_label.
func (recv *Label) GetLabel() string {
	retC := C.gtk_label_get_label((*C.GtkLabel)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetLayout is a wrapper around the C function gtk_label_get_layout.
func (recv *Label) GetLayout() *pango.Layout {
	retC := C.gtk_label_get_layout((*C.GtkLabel)(recv.native))
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLayoutOffsets is a wrapper around the C function gtk_label_get_layout_offsets.
func (recv *Label) GetLayoutOffsets() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_label_get_layout_offsets((*C.GtkLabel)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// GetLineWrap is a wrapper around the C function gtk_label_get_line_wrap.
func (recv *Label) GetLineWrap() bool {
	retC := C.gtk_label_get_line_wrap((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetLineWrapMode is a wrapper around the C function gtk_label_get_line_wrap_mode.
func (recv *Label) GetLineWrapMode() pango.WrapMode {
	retC := C.gtk_label_get_line_wrap_mode((*C.GtkLabel)(recv.native))
	retGo := (pango.WrapMode)(retC)

	return retGo
}

// GetMaxWidthChars is a wrapper around the C function gtk_label_get_max_width_chars.
func (recv *Label) GetMaxWidthChars() int32 {
	retC := C.gtk_label_get_max_width_chars((*C.GtkLabel)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMnemonicKeyval is a wrapper around the C function gtk_label_get_mnemonic_keyval.
func (recv *Label) GetMnemonicKeyval() uint32 {
	retC := C.gtk_label_get_mnemonic_keyval((*C.GtkLabel)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetMnemonicWidget is a wrapper around the C function gtk_label_get_mnemonic_widget.
func (recv *Label) GetMnemonicWidget() *Widget {
	retC := C.gtk_label_get_mnemonic_widget((*C.GtkLabel)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetSelectable is a wrapper around the C function gtk_label_get_selectable.
func (recv *Label) GetSelectable() bool {
	retC := C.gtk_label_get_selectable((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSelectionBounds is a wrapper around the C function gtk_label_get_selection_bounds.
func (recv *Label) GetSelectionBounds() (bool, int32, int32) {
	var c_start C.gint

	var c_end C.gint

	retC := C.gtk_label_get_selection_bounds((*C.GtkLabel)(recv.native), &c_start, &c_end)
	retGo := retC == C.TRUE

	start := (int32)(c_start)

	end := (int32)(c_end)

	return retGo, start, end
}

// GetSingleLineMode is a wrapper around the C function gtk_label_get_single_line_mode.
func (recv *Label) GetSingleLineMode() bool {
	retC := C.gtk_label_get_single_line_mode((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetText is a wrapper around the C function gtk_label_get_text.
func (recv *Label) GetText() string {
	retC := C.gtk_label_get_text((*C.GtkLabel)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUseMarkup is a wrapper around the C function gtk_label_get_use_markup.
func (recv *Label) GetUseMarkup() bool {
	retC := C.gtk_label_get_use_markup((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetUseUnderline is a wrapper around the C function gtk_label_get_use_underline.
func (recv *Label) GetUseUnderline() bool {
	retC := C.gtk_label_get_use_underline((*C.GtkLabel)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetWidthChars is a wrapper around the C function gtk_label_get_width_chars.
func (recv *Label) GetWidthChars() int32 {
	retC := C.gtk_label_get_width_chars((*C.GtkLabel)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// SelectRegion is a wrapper around the C function gtk_label_select_region.
func (recv *Label) SelectRegion(startOffset int32, endOffset int32) {
	c_start_offset := (C.gint)(startOffset)

	c_end_offset := (C.gint)(endOffset)

	C.gtk_label_select_region((*C.GtkLabel)(recv.native), c_start_offset, c_end_offset)

	return
}

// SetAngle is a wrapper around the C function gtk_label_set_angle.
func (recv *Label) SetAngle(angle float64) {
	c_angle := (C.gdouble)(angle)

	C.gtk_label_set_angle((*C.GtkLabel)(recv.native), c_angle)

	return
}

// SetAttributes is a wrapper around the C function gtk_label_set_attributes.
func (recv *Label) SetAttributes(attrs *pango.AttrList) {
	c_attrs := (*C.PangoAttrList)(C.NULL)
	if attrs != nil {
		c_attrs = (*C.PangoAttrList)(attrs.ToC())
	}

	C.gtk_label_set_attributes((*C.GtkLabel)(recv.native), c_attrs)

	return
}

// SetEllipsize is a wrapper around the C function gtk_label_set_ellipsize.
func (recv *Label) SetEllipsize(mode pango.EllipsizeMode) {
	c_mode := (C.PangoEllipsizeMode)(mode)

	C.gtk_label_set_ellipsize((*C.GtkLabel)(recv.native), c_mode)

	return
}

// SetJustify is a wrapper around the C function gtk_label_set_justify.
func (recv *Label) SetJustify(jtype Justification) {
	c_jtype := (C.GtkJustification)(jtype)

	C.gtk_label_set_justify((*C.GtkLabel)(recv.native), c_jtype)

	return
}

// SetLabel is a wrapper around the C function gtk_label_set_label.
func (recv *Label) SetLabel(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_label((*C.GtkLabel)(recv.native), c_str)

	return
}

// SetLineWrap is a wrapper around the C function gtk_label_set_line_wrap.
func (recv *Label) SetLineWrap(wrap bool) {
	c_wrap :=
		boolToGboolean(wrap)

	C.gtk_label_set_line_wrap((*C.GtkLabel)(recv.native), c_wrap)

	return
}

// SetLineWrapMode is a wrapper around the C function gtk_label_set_line_wrap_mode.
func (recv *Label) SetLineWrapMode(wrapMode pango.WrapMode) {
	c_wrap_mode := (C.PangoWrapMode)(wrapMode)

	C.gtk_label_set_line_wrap_mode((*C.GtkLabel)(recv.native), c_wrap_mode)

	return
}

// SetMarkup is a wrapper around the C function gtk_label_set_markup.
func (recv *Label) SetMarkup(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_markup((*C.GtkLabel)(recv.native), c_str)

	return
}

// SetMarkupWithMnemonic is a wrapper around the C function gtk_label_set_markup_with_mnemonic.
func (recv *Label) SetMarkupWithMnemonic(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_markup_with_mnemonic((*C.GtkLabel)(recv.native), c_str)

	return
}

// SetMaxWidthChars is a wrapper around the C function gtk_label_set_max_width_chars.
func (recv *Label) SetMaxWidthChars(nChars int32) {
	c_n_chars := (C.gint)(nChars)

	C.gtk_label_set_max_width_chars((*C.GtkLabel)(recv.native), c_n_chars)

	return
}

// SetMnemonicWidget is a wrapper around the C function gtk_label_set_mnemonic_widget.
func (recv *Label) SetMnemonicWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_label_set_mnemonic_widget((*C.GtkLabel)(recv.native), c_widget)

	return
}

// SetPattern is a wrapper around the C function gtk_label_set_pattern.
func (recv *Label) SetPattern(pattern string) {
	c_pattern := C.CString(pattern)
	defer C.free(unsafe.Pointer(c_pattern))

	C.gtk_label_set_pattern((*C.GtkLabel)(recv.native), c_pattern)

	return
}

// SetSelectable is a wrapper around the C function gtk_label_set_selectable.
func (recv *Label) SetSelectable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_selectable((*C.GtkLabel)(recv.native), c_setting)

	return
}

// SetSingleLineMode is a wrapper around the C function gtk_label_set_single_line_mode.
func (recv *Label) SetSingleLineMode(singleLineMode bool) {
	c_single_line_mode :=
		boolToGboolean(singleLineMode)

	C.gtk_label_set_single_line_mode((*C.GtkLabel)(recv.native), c_single_line_mode)

	return
}

// SetText is a wrapper around the C function gtk_label_set_text.
func (recv *Label) SetText(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_text((*C.GtkLabel)(recv.native), c_str)

	return
}

// SetTextWithMnemonic is a wrapper around the C function gtk_label_set_text_with_mnemonic.
func (recv *Label) SetTextWithMnemonic(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_label_set_text_with_mnemonic((*C.GtkLabel)(recv.native), c_str)

	return
}

// SetUseMarkup is a wrapper around the C function gtk_label_set_use_markup.
func (recv *Label) SetUseMarkup(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_use_markup((*C.GtkLabel)(recv.native), c_setting)

	return
}

// SetUseUnderline is a wrapper around the C function gtk_label_set_use_underline.
func (recv *Label) SetUseUnderline(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_label_set_use_underline((*C.GtkLabel)(recv.native), c_setting)

	return
}

// SetWidthChars is a wrapper around the C function gtk_label_set_width_chars.
func (recv *Label) SetWidthChars(nChars int32) {
	c_n_chars := (C.gint)(nChars)

	C.gtk_label_set_width_chars((*C.GtkLabel)(recv.native), c_n_chars)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Label
func (recv *Label) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Label
func (recv *Label) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LabelAccessible is a wrapper around the C record GtkLabelAccessible.
type LabelAccessible struct {
	native *C.GtkLabelAccessible
	// parent : record
	// priv : record
}

func LabelAccessibleNewFromC(u unsafe.Pointer) *LabelAccessible {
	c := (*C.GtkLabelAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LabelAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LabelAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LabelAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LabelAccessible with another LabelAccessible, and returns true if they represent the same GObject.
func (recv *LabelAccessible) Equals(other *LabelAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LabelAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *LabelAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LabelAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to LabelAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LabelAccessible.
func CastToLabelAccessible(object *gobject.Object) *LabelAccessible {
	return LabelAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by LabelAccessible
func (recv *LabelAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Hypertext returns the Hypertext interface implemented by LabelAccessible
func (recv *LabelAccessible) Hypertext() *atk.Hypertext {
	return atk.HypertextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by LabelAccessible
func (recv *LabelAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// Layout is a wrapper around the C record GtkLayout.
type Layout struct {
	native *C.GtkLayout
	// container : record
	// Private : priv
}

func LayoutNewFromC(u unsafe.Pointer) *Layout {
	c := (*C.GtkLayout)(u)
	if c == nil {
		return nil
	}

	g := &Layout{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Layout) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Layout) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Layout with another Layout, and returns true if they represent the same GObject.
func (recv *Layout) Equals(other *Layout) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Layout) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Layout) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Layout) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Layout) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Layout.
// Exercise care, as this is a potentially dangerous function if the Object is not a Layout.
func CastToLayout(object *gobject.Object) *Layout {
	return LayoutNewFromC(object.ToC())
}

// LayoutNew is a wrapper around the C function gtk_layout_new.
func LayoutNew(hadjustment *Adjustment, vadjustment *Adjustment) *Layout {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_layout_new(c_hadjustment, c_vadjustment)
	retGo := LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetHadjustment is a wrapper around the C function gtk_layout_get_hadjustment.
func (recv *Layout) GetHadjustment() *Adjustment {
	retC := C.gtk_layout_get_hadjustment((*C.GtkLayout)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSize is a wrapper around the C function gtk_layout_get_size.
func (recv *Layout) GetSize() (uint32, uint32) {
	var c_width C.guint

	var c_height C.guint

	C.gtk_layout_get_size((*C.GtkLayout)(recv.native), &c_width, &c_height)

	width := (uint32)(c_width)

	height := (uint32)(c_height)

	return width, height
}

// GetVadjustment is a wrapper around the C function gtk_layout_get_vadjustment.
func (recv *Layout) GetVadjustment() *Adjustment {
	retC := C.gtk_layout_get_vadjustment((*C.GtkLayout)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Move is a wrapper around the C function gtk_layout_move.
func (recv *Layout) Move(childWidget *Widget, x int32, y int32) {
	c_child_widget := (*C.GtkWidget)(C.NULL)
	if childWidget != nil {
		c_child_widget = (*C.GtkWidget)(childWidget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_layout_move((*C.GtkLayout)(recv.native), c_child_widget, c_x, c_y)

	return
}

// Put is a wrapper around the C function gtk_layout_put.
func (recv *Layout) Put(childWidget *Widget, x int32, y int32) {
	c_child_widget := (*C.GtkWidget)(C.NULL)
	if childWidget != nil {
		c_child_widget = (*C.GtkWidget)(childWidget.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_layout_put((*C.GtkLayout)(recv.native), c_child_widget, c_x, c_y)

	return
}

// SetHadjustment is a wrapper around the C function gtk_layout_set_hadjustment.
func (recv *Layout) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_layout_set_hadjustment((*C.GtkLayout)(recv.native), c_adjustment)

	return
}

// SetSize is a wrapper around the C function gtk_layout_set_size.
func (recv *Layout) SetSize(width uint32, height uint32) {
	c_width := (C.guint)(width)

	c_height := (C.guint)(height)

	C.gtk_layout_set_size((*C.GtkLayout)(recv.native), c_width, c_height)

	return
}

// SetVadjustment is a wrapper around the C function gtk_layout_set_vadjustment.
func (recv *Layout) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_layout_set_vadjustment((*C.GtkLayout)(recv.native), c_adjustment)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Layout
func (recv *Layout) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Layout
func (recv *Layout) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by Layout
func (recv *Layout) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// LevelBar is a wrapper around the C record GtkLevelBar.
type LevelBar struct {
	native *C.GtkLevelBar
	// Private : parent
	// Private : priv
}

func LevelBarNewFromC(u unsafe.Pointer) *LevelBar {
	c := (*C.GtkLevelBar)(u)
	if c == nil {
		return nil
	}

	g := &LevelBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LevelBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LevelBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LevelBar with another LevelBar, and returns true if they represent the same GObject.
func (recv *LevelBar) Equals(other *LevelBar) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *LevelBar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LevelBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LevelBar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to LevelBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a LevelBar.
func CastToLevelBar(object *gobject.Object) *LevelBar {
	return LevelBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by LevelBar
func (recv *LevelBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LevelBar
func (recv *LevelBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by LevelBar
func (recv *LevelBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// LevelBarAccessible is a wrapper around the C record GtkLevelBarAccessible.
type LevelBarAccessible struct {
	native *C.GtkLevelBarAccessible
	// parent : record
	// priv : record
}

func LevelBarAccessibleNewFromC(u unsafe.Pointer) *LevelBarAccessible {
	c := (*C.GtkLevelBarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LevelBarAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LevelBarAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LevelBarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LevelBarAccessible with another LevelBarAccessible, and returns true if they represent the same GObject.
func (recv *LevelBarAccessible) Equals(other *LevelBarAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LevelBarAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *LevelBarAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LevelBarAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to LevelBarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LevelBarAccessible.
func CastToLevelBarAccessible(object *gobject.Object) *LevelBarAccessible {
	return LevelBarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by LevelBarAccessible
func (recv *LevelBarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by LevelBarAccessible
func (recv *LevelBarAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// LinkButton is a wrapper around the C record GtkLinkButton.
type LinkButton struct {
	native *C.GtkLinkButton
	// Private : parent_instance
	// Private : priv
}

func LinkButtonNewFromC(u unsafe.Pointer) *LinkButton {
	c := (*C.GtkLinkButton)(u)
	if c == nil {
		return nil
	}

	g := &LinkButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LinkButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LinkButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LinkButton with another LinkButton, and returns true if they represent the same GObject.
func (recv *LinkButton) Equals(other *LinkButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *LinkButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *LinkButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *LinkButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *LinkButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LinkButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LinkButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to LinkButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a LinkButton.
func CastToLinkButton(object *gobject.Object) *LinkButton {
	return LinkButtonNewFromC(object.ToC())
}

type signalLinkButtonActivateLinkDetail struct {
	callback  LinkButtonSignalActivateLinkCallback
	handlerID C.gulong
}

var signalLinkButtonActivateLinkId int
var signalLinkButtonActivateLinkMap = make(map[int]signalLinkButtonActivateLinkDetail)
var signalLinkButtonActivateLinkLock sync.RWMutex

// LinkButtonSignalActivateLinkCallback is a callback function for a 'activate-link' signal emitted from a LinkButton.
type LinkButtonSignalActivateLinkCallback func() bool

/*
ConnectActivateLink connects the callback to the 'activate-link' signal for the LinkButton.

The returned value represents the connection, and may be passed to DisconnectActivateLink to remove it.
*/
func (recv *LinkButton) ConnectActivateLink(callback LinkButtonSignalActivateLinkCallback) int {
	signalLinkButtonActivateLinkLock.Lock()
	defer signalLinkButtonActivateLinkLock.Unlock()

	signalLinkButtonActivateLinkId++
	instance := C.gpointer(recv.native)
	handlerID := C.LinkButton_signal_connect_activate_link(instance, C.gpointer(uintptr(signalLinkButtonActivateLinkId)))

	detail := signalLinkButtonActivateLinkDetail{callback, handlerID}
	signalLinkButtonActivateLinkMap[signalLinkButtonActivateLinkId] = detail

	return signalLinkButtonActivateLinkId
}

/*
DisconnectActivateLink disconnects a callback from the 'activate-link' signal for the LinkButton.

The connectionID should be a value returned from a call to ConnectActivateLink.
*/
func (recv *LinkButton) DisconnectActivateLink(connectionID int) {
	signalLinkButtonActivateLinkLock.Lock()
	defer signalLinkButtonActivateLinkLock.Unlock()

	detail, exists := signalLinkButtonActivateLinkMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalLinkButtonActivateLinkMap, connectionID)
}

//export linkbutton_activateLinkHandler
func linkbutton_activateLinkHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalLinkButtonActivateLinkLock.RLock()
	defer signalLinkButtonActivateLinkLock.RUnlock()

	index := int(uintptr(data))
	callback := signalLinkButtonActivateLinkMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// LinkButtonNew is a wrapper around the C function gtk_link_button_new.
func LinkButtonNew(uri string) *LinkButton {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	retC := C.gtk_link_button_new(c_uri)
	retGo := LinkButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// LinkButtonNewWithLabel is a wrapper around the C function gtk_link_button_new_with_label.
func LinkButtonNewWithLabel(uri string, label string) *LinkButton {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_link_button_new_with_label(c_uri, c_label)
	retGo := LinkButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetUri is a wrapper around the C function gtk_link_button_get_uri.
func (recv *LinkButton) GetUri() string {
	retC := C.gtk_link_button_get_uri((*C.GtkLinkButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// SetUri is a wrapper around the C function gtk_link_button_set_uri.
func (recv *LinkButton) SetUri(uri string) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	C.gtk_link_button_set_uri((*C.GtkLinkButton)(recv.native), c_uri)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by LinkButton
func (recv *LinkButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by LinkButton
func (recv *LinkButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by LinkButton
func (recv *LinkButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LinkButton
func (recv *LinkButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LinkButtonAccessible is a wrapper around the C record GtkLinkButtonAccessible.
type LinkButtonAccessible struct {
	native *C.GtkLinkButtonAccessible
	// parent : record
	// priv : record
}

func LinkButtonAccessibleNewFromC(u unsafe.Pointer) *LinkButtonAccessible {
	c := (*C.GtkLinkButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LinkButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LinkButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LinkButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LinkButtonAccessible with another LinkButtonAccessible, and returns true if they represent the same GObject.
func (recv *LinkButtonAccessible) Equals(other *LinkButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *LinkButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *LinkButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LinkButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *LinkButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LinkButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to LinkButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LinkButtonAccessible.
func CastToLinkButtonAccessible(object *gobject.Object) *LinkButtonAccessible {
	return LinkButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// HyperlinkImpl returns the HyperlinkImpl interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) HyperlinkImpl() *atk.HyperlinkImpl {
	return atk.HyperlinkImplNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by LinkButtonAccessible
func (recv *LinkButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ListBox is a wrapper around the C record GtkListBox.
type ListBox struct {
	native *C.GtkListBox
	// parent_instance : record
}

func ListBoxNewFromC(u unsafe.Pointer) *ListBox {
	c := (*C.GtkListBox)(u)
	if c == nil {
		return nil
	}

	g := &ListBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBox with another ListBox, and returns true if they represent the same GObject.
func (recv *ListBox) Equals(other *ListBox) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *ListBox) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ListBox) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ListBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ListBox) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to ListBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBox.
func CastToListBox(object *gobject.Object) *ListBox {
	return ListBoxNewFromC(object.ToC())
}

type signalListBoxActivateCursorRowDetail struct {
	callback  ListBoxSignalActivateCursorRowCallback
	handlerID C.gulong
}

var signalListBoxActivateCursorRowId int
var signalListBoxActivateCursorRowMap = make(map[int]signalListBoxActivateCursorRowDetail)
var signalListBoxActivateCursorRowLock sync.RWMutex

// ListBoxSignalActivateCursorRowCallback is a callback function for a 'activate-cursor-row' signal emitted from a ListBox.
type ListBoxSignalActivateCursorRowCallback func()

/*
ConnectActivateCursorRow connects the callback to the 'activate-cursor-row' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectActivateCursorRow to remove it.
*/
func (recv *ListBox) ConnectActivateCursorRow(callback ListBoxSignalActivateCursorRowCallback) int {
	signalListBoxActivateCursorRowLock.Lock()
	defer signalListBoxActivateCursorRowLock.Unlock()

	signalListBoxActivateCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_activate_cursor_row(instance, C.gpointer(uintptr(signalListBoxActivateCursorRowId)))

	detail := signalListBoxActivateCursorRowDetail{callback, handlerID}
	signalListBoxActivateCursorRowMap[signalListBoxActivateCursorRowId] = detail

	return signalListBoxActivateCursorRowId
}

/*
DisconnectActivateCursorRow disconnects a callback from the 'activate-cursor-row' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectActivateCursorRow.
*/
func (recv *ListBox) DisconnectActivateCursorRow(connectionID int) {
	signalListBoxActivateCursorRowLock.Lock()
	defer signalListBoxActivateCursorRowLock.Unlock()

	detail, exists := signalListBoxActivateCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxActivateCursorRowMap, connectionID)
}

//export listbox_activateCursorRowHandler
func listbox_activateCursorRowHandler(_ *C.GObject, data C.gpointer) {
	signalListBoxActivateCursorRowLock.RLock()
	defer signalListBoxActivateCursorRowLock.RUnlock()

	index := int(uintptr(data))
	callback := signalListBoxActivateCursorRowMap[index].callback
	callback()
}

type signalListBoxMoveCursorDetail struct {
	callback  ListBoxSignalMoveCursorCallback
	handlerID C.gulong
}

var signalListBoxMoveCursorId int
var signalListBoxMoveCursorMap = make(map[int]signalListBoxMoveCursorDetail)
var signalListBoxMoveCursorLock sync.RWMutex

// ListBoxSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a ListBox.
type ListBoxSignalMoveCursorCallback func(object MovementStep, p0 int32)

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *ListBox) ConnectMoveCursor(callback ListBoxSignalMoveCursorCallback) int {
	signalListBoxMoveCursorLock.Lock()
	defer signalListBoxMoveCursorLock.Unlock()

	signalListBoxMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalListBoxMoveCursorId)))

	detail := signalListBoxMoveCursorDetail{callback, handlerID}
	signalListBoxMoveCursorMap[signalListBoxMoveCursorId] = detail

	return signalListBoxMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *ListBox) DisconnectMoveCursor(connectionID int) {
	signalListBoxMoveCursorLock.Lock()
	defer signalListBoxMoveCursorLock.Unlock()

	detail, exists := signalListBoxMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxMoveCursorMap, connectionID)
}

//export listbox_moveCursorHandler
func listbox_moveCursorHandler(_ *C.GObject, c_object C.GtkMovementStep, c_p0 C.gint, data C.gpointer) {
	signalListBoxMoveCursorLock.RLock()
	defer signalListBoxMoveCursorLock.RUnlock()

	object := MovementStep(c_object)

	p0 := int32(c_p0)

	index := int(uintptr(data))
	callback := signalListBoxMoveCursorMap[index].callback
	callback(object, p0)
}

type signalListBoxToggleCursorRowDetail struct {
	callback  ListBoxSignalToggleCursorRowCallback
	handlerID C.gulong
}

var signalListBoxToggleCursorRowId int
var signalListBoxToggleCursorRowMap = make(map[int]signalListBoxToggleCursorRowDetail)
var signalListBoxToggleCursorRowLock sync.RWMutex

// ListBoxSignalToggleCursorRowCallback is a callback function for a 'toggle-cursor-row' signal emitted from a ListBox.
type ListBoxSignalToggleCursorRowCallback func()

/*
ConnectToggleCursorRow connects the callback to the 'toggle-cursor-row' signal for the ListBox.

The returned value represents the connection, and may be passed to DisconnectToggleCursorRow to remove it.
*/
func (recv *ListBox) ConnectToggleCursorRow(callback ListBoxSignalToggleCursorRowCallback) int {
	signalListBoxToggleCursorRowLock.Lock()
	defer signalListBoxToggleCursorRowLock.Unlock()

	signalListBoxToggleCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.ListBox_signal_connect_toggle_cursor_row(instance, C.gpointer(uintptr(signalListBoxToggleCursorRowId)))

	detail := signalListBoxToggleCursorRowDetail{callback, handlerID}
	signalListBoxToggleCursorRowMap[signalListBoxToggleCursorRowId] = detail

	return signalListBoxToggleCursorRowId
}

/*
DisconnectToggleCursorRow disconnects a callback from the 'toggle-cursor-row' signal for the ListBox.

The connectionID should be a value returned from a call to ConnectToggleCursorRow.
*/
func (recv *ListBox) DisconnectToggleCursorRow(connectionID int) {
	signalListBoxToggleCursorRowLock.Lock()
	defer signalListBoxToggleCursorRowLock.Unlock()

	detail, exists := signalListBoxToggleCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalListBoxToggleCursorRowMap, connectionID)
}

//export listbox_toggleCursorRowHandler
func listbox_toggleCursorRowHandler(_ *C.GObject, data C.gpointer) {
	signalListBoxToggleCursorRowLock.RLock()
	defer signalListBoxToggleCursorRowLock.RUnlock()

	index := int(uintptr(data))
	callback := signalListBoxToggleCursorRowMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by ListBox
func (recv *ListBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ListBox
func (recv *ListBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ListBoxAccessible is a wrapper around the C record GtkListBoxAccessible.
type ListBoxAccessible struct {
	native *C.GtkListBoxAccessible
	// parent : record
	// priv : record
}

func ListBoxAccessibleNewFromC(u unsafe.Pointer) *ListBoxAccessible {
	c := (*C.GtkListBoxAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListBoxAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListBoxAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxAccessible with another ListBoxAccessible, and returns true if they represent the same GObject.
func (recv *ListBoxAccessible) Equals(other *ListBoxAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ListBoxAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ListBoxAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ListBoxAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ListBoxAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ListBoxAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxAccessible.
func CastToListBoxAccessible(object *gobject.Object) *ListBoxAccessible {
	return ListBoxAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ListBoxAccessible
func (recv *ListBoxAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by ListBoxAccessible
func (recv *ListBoxAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// ListBoxRow is a wrapper around the C record GtkListBoxRow.
type ListBoxRow struct {
	native *C.GtkListBoxRow
	// parent_instance : record
}

func ListBoxRowNewFromC(u unsafe.Pointer) *ListBoxRow {
	c := (*C.GtkListBoxRow)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListBoxRow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListBoxRow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxRow with another ListBoxRow, and returns true if they represent the same GObject.
func (recv *ListBoxRow) Equals(other *ListBoxRow) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ListBoxRow) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ListBoxRow) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ListBoxRow) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ListBoxRow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ListBoxRow) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ListBoxRow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxRow.
func CastToListBoxRow(object *gobject.Object) *ListBoxRow {
	return ListBoxRowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ListBoxRow
func (recv *ListBoxRow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ListBoxRow
func (recv *ListBoxRow) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ListBoxRow
func (recv *ListBoxRow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ListBoxRowAccessible is a wrapper around the C record GtkListBoxRowAccessible.
type ListBoxRowAccessible struct {
	native *C.GtkListBoxRowAccessible
	// parent : record
}

func ListBoxRowAccessibleNewFromC(u unsafe.Pointer) *ListBoxRowAccessible {
	c := (*C.GtkListBoxRowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRowAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListBoxRowAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListBoxRowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxRowAccessible with another ListBoxRowAccessible, and returns true if they represent the same GObject.
func (recv *ListBoxRowAccessible) Equals(other *ListBoxRowAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ListBoxRowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ListBoxRowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ListBoxRowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ListBoxRowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ListBoxRowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListBoxRowAccessible.
func CastToListBoxRowAccessible(object *gobject.Object) *ListBoxRowAccessible {
	return ListBoxRowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ListBoxRowAccessible
func (recv *ListBoxRowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// ListStore is a wrapper around the C record GtkListStore.
type ListStore struct {
	native *C.GtkListStore
	// parent : record
	// Private : priv
}

func ListStoreNewFromC(u unsafe.Pointer) *ListStore {
	c := (*C.GtkListStore)(u)
	if c == nil {
		return nil
	}

	g := &ListStore{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ListStore) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ListStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListStore with another ListStore, and returns true if they represent the same GObject.
func (recv *ListStore) Equals(other *ListStore) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ListStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ListStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a ListStore.
func CastToListStore(object *gobject.Object) *ListStore {
	return ListStoreNewFromC(object.ToC())
}

// Unsupported : gtk_list_store_new : unsupported parameter ... : varargs

// ListStoreNewv is a wrapper around the C function gtk_list_store_newv.
func ListStoreNewv(types []gobject.Type) *ListStore {
	c_n_columns := (C.gint)(len(types))

	c_types_array := make([]C.GType, len(types)+1, len(types)+1)
	for i, item := range types {
		c := (C.GType)(item)
		c_types_array[i] = c
	}
	c_types_array[len(types)] = 0
	c_types_arrayPtr := &c_types_array[0]
	c_types := (*C.GType)(unsafe.Pointer(c_types_arrayPtr))

	retC := C.gtk_list_store_newv(c_n_columns, c_types)
	retGo := ListStoreNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Append is a wrapper around the C function gtk_list_store_append.
func (recv *ListStore) Append() *TreeIter {
	var c_iter C.GtkTreeIter

	C.gtk_list_store_append((*C.GtkListStore)(recv.native), &c_iter)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Clear is a wrapper around the C function gtk_list_store_clear.
func (recv *ListStore) Clear() {
	C.gtk_list_store_clear((*C.GtkListStore)(recv.native))

	return
}

// Insert is a wrapper around the C function gtk_list_store_insert.
func (recv *ListStore) Insert(position int32) *TreeIter {
	var c_iter C.GtkTreeIter

	c_position := (C.gint)(position)

	C.gtk_list_store_insert((*C.GtkListStore)(recv.native), &c_iter, c_position)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// InsertAfter is a wrapper around the C function gtk_list_store_insert_after.
func (recv *ListStore) InsertAfter(sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_list_store_insert_after((*C.GtkListStore)(recv.native), &c_iter, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// InsertBefore is a wrapper around the C function gtk_list_store_insert_before.
func (recv *ListStore) InsertBefore(sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_list_store_insert_before((*C.GtkListStore)(recv.native), &c_iter, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Unsupported : gtk_list_store_insert_with_values : unsupported parameter ... : varargs

// Unsupported : gtk_list_store_insert_with_valuesv : unsupported parameter values :

// IterIsValid is a wrapper around the C function gtk_list_store_iter_is_valid.
func (recv *ListStore) IterIsValid(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_list_store_iter_is_valid((*C.GtkListStore)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// MoveAfter is a wrapper around the C function gtk_list_store_move_after.
func (recv *ListStore) MoveAfter(iter *TreeIter, position *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_position := (*C.GtkTreeIter)(C.NULL)
	if position != nil {
		c_position = (*C.GtkTreeIter)(position.ToC())
	}

	C.gtk_list_store_move_after((*C.GtkListStore)(recv.native), c_iter, c_position)

	return
}

// MoveBefore is a wrapper around the C function gtk_list_store_move_before.
func (recv *ListStore) MoveBefore(iter *TreeIter, position *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_position := (*C.GtkTreeIter)(C.NULL)
	if position != nil {
		c_position = (*C.GtkTreeIter)(position.ToC())
	}

	C.gtk_list_store_move_before((*C.GtkListStore)(recv.native), c_iter, c_position)

	return
}

// Prepend is a wrapper around the C function gtk_list_store_prepend.
func (recv *ListStore) Prepend() *TreeIter {
	var c_iter C.GtkTreeIter

	C.gtk_list_store_prepend((*C.GtkListStore)(recv.native), &c_iter)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Remove is a wrapper around the C function gtk_list_store_remove.
func (recv *ListStore) Remove(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_list_store_remove((*C.GtkListStore)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Reorder is a wrapper around the C function gtk_list_store_reorder.
func (recv *ListStore) Reorder(newOrder []int32) {
	c_new_order_array := make([]C.gint, len(newOrder)+1, len(newOrder)+1)
	for i, item := range newOrder {
		c := (C.gint)(item)
		c_new_order_array[i] = c
	}
	c_new_order_array[len(newOrder)] = 0
	c_new_order_arrayPtr := &c_new_order_array[0]
	c_new_order := (*C.gint)(unsafe.Pointer(c_new_order_arrayPtr))

	C.gtk_list_store_reorder((*C.GtkListStore)(recv.native), c_new_order)

	return
}

// Unsupported : gtk_list_store_set : unsupported parameter ... : varargs

// SetColumnTypes is a wrapper around the C function gtk_list_store_set_column_types.
func (recv *ListStore) SetColumnTypes(types []gobject.Type) {
	c_n_columns := (C.gint)(len(types))

	c_types_array := make([]C.GType, len(types)+1, len(types)+1)
	for i, item := range types {
		c := (C.GType)(item)
		c_types_array[i] = c
	}
	c_types_array[len(types)] = 0
	c_types_arrayPtr := &c_types_array[0]
	c_types := (*C.GType)(unsafe.Pointer(c_types_arrayPtr))

	C.gtk_list_store_set_column_types((*C.GtkListStore)(recv.native), c_n_columns, c_types)

	return
}

// Unsupported : gtk_list_store_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// SetValue is a wrapper around the C function gtk_list_store_set_value.
func (recv *ListStore) SetValue(iter *TreeIter, column int32, value *gobject.Value) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_column := (C.gint)(column)

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_list_store_set_value((*C.GtkListStore)(recv.native), c_iter, c_column, c_value)

	return
}

// Unsupported : gtk_list_store_set_valuesv : unsupported parameter values :

// Swap is a wrapper around the C function gtk_list_store_swap.
func (recv *ListStore) Swap(a *TreeIter, b *TreeIter) {
	c_a := (*C.GtkTreeIter)(C.NULL)
	if a != nil {
		c_a = (*C.GtkTreeIter)(a.ToC())
	}

	c_b := (*C.GtkTreeIter)(C.NULL)
	if b != nil {
		c_b = (*C.GtkTreeIter)(b.ToC())
	}

	C.gtk_list_store_swap((*C.GtkListStore)(recv.native), c_a, c_b)

	return
}

// Buildable returns the Buildable interface implemented by ListStore
func (recv *ListStore) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TreeDragDest returns the TreeDragDest interface implemented by ListStore
func (recv *ListStore) TreeDragDest() *TreeDragDest {
	return TreeDragDestNewFromC(recv.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by ListStore
func (recv *ListStore) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by ListStore
func (recv *ListStore) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by ListStore
func (recv *ListStore) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// LockButton is a wrapper around the C record GtkLockButton.
type LockButton struct {
	native *C.GtkLockButton
	// parent : record
	// priv : record
}

func LockButtonNewFromC(u unsafe.Pointer) *LockButton {
	c := (*C.GtkLockButton)(u)
	if c == nil {
		return nil
	}

	g := &LockButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LockButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LockButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LockButton with another LockButton, and returns true if they represent the same GObject.
func (recv *LockButton) Equals(other *LockButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *LockButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *LockButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *LockButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *LockButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *LockButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *LockButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to LockButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a LockButton.
func CastToLockButton(object *gobject.Object) *LockButton {
	return LockButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by LockButton
func (recv *LockButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by LockButton
func (recv *LockButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by LockButton
func (recv *LockButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by LockButton
func (recv *LockButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// LockButtonAccessible is a wrapper around the C record GtkLockButtonAccessible.
type LockButtonAccessible struct {
	native *C.GtkLockButtonAccessible
	// parent : record
	// priv : record
}

func LockButtonAccessibleNewFromC(u unsafe.Pointer) *LockButtonAccessible {
	c := (*C.GtkLockButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &LockButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *LockButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *LockButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LockButtonAccessible with another LockButtonAccessible, and returns true if they represent the same GObject.
func (recv *LockButtonAccessible) Equals(other *LockButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *LockButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *LockButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *LockButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *LockButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *LockButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to LockButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a LockButtonAccessible.
func CastToLockButtonAccessible(object *gobject.Object) *LockButtonAccessible {
	return LockButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by LockButtonAccessible
func (recv *LockButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Menu is a wrapper around the C record GtkMenu.
type Menu struct {
	native *C.GtkMenu
	// menu_shell : record
	// Private : priv
}

func MenuNewFromC(u unsafe.Pointer) *Menu {
	c := (*C.GtkMenu)(u)
	if c == nil {
		return nil
	}

	g := &Menu{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Menu) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Menu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Menu with another Menu, and returns true if they represent the same GObject.
func (recv *Menu) Equals(other *Menu) bool {
	return other.ToC() == recv.ToC()
}

// MenuShell upcasts to *MenuShell
func (recv *Menu) MenuShell() *MenuShell {
	return MenuShellNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Menu) Container() *Container {
	return recv.MenuShell().Container()
}

// Widget upcasts to *Widget
func (recv *Menu) Widget() *Widget {
	return recv.MenuShell().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Menu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuShell().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Menu) Object() *gobject.Object {
	return recv.MenuShell().Object()
}

// CastToWidget down casts any arbitrary Object to Menu.
// Exercise care, as this is a potentially dangerous function if the Object is not a Menu.
func CastToMenu(object *gobject.Object) *Menu {
	return MenuNewFromC(object.ToC())
}

type signalMenuMoveScrollDetail struct {
	callback  MenuSignalMoveScrollCallback
	handlerID C.gulong
}

var signalMenuMoveScrollId int
var signalMenuMoveScrollMap = make(map[int]signalMenuMoveScrollDetail)
var signalMenuMoveScrollLock sync.RWMutex

// MenuSignalMoveScrollCallback is a callback function for a 'move-scroll' signal emitted from a Menu.
type MenuSignalMoveScrollCallback func(scrollType ScrollType)

/*
ConnectMoveScroll connects the callback to the 'move-scroll' signal for the Menu.

The returned value represents the connection, and may be passed to DisconnectMoveScroll to remove it.
*/
func (recv *Menu) ConnectMoveScroll(callback MenuSignalMoveScrollCallback) int {
	signalMenuMoveScrollLock.Lock()
	defer signalMenuMoveScrollLock.Unlock()

	signalMenuMoveScrollId++
	instance := C.gpointer(recv.native)
	handlerID := C.Menu_signal_connect_move_scroll(instance, C.gpointer(uintptr(signalMenuMoveScrollId)))

	detail := signalMenuMoveScrollDetail{callback, handlerID}
	signalMenuMoveScrollMap[signalMenuMoveScrollId] = detail

	return signalMenuMoveScrollId
}

/*
DisconnectMoveScroll disconnects a callback from the 'move-scroll' signal for the Menu.

The connectionID should be a value returned from a call to ConnectMoveScroll.
*/
func (recv *Menu) DisconnectMoveScroll(connectionID int) {
	signalMenuMoveScrollLock.Lock()
	defer signalMenuMoveScrollLock.Unlock()

	detail, exists := signalMenuMoveScrollMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuMoveScrollMap, connectionID)
}

//export menu_moveScrollHandler
func menu_moveScrollHandler(_ *C.GObject, c_scroll_type C.GtkScrollType, data C.gpointer) {
	signalMenuMoveScrollLock.RLock()
	defer signalMenuMoveScrollLock.RUnlock()

	scrollType := ScrollType(c_scroll_type)

	index := int(uintptr(data))
	callback := signalMenuMoveScrollMap[index].callback
	callback(scrollType)
}

// Unsupported signal 'popped-up' for Menu : param flipped_rect : gpointer

// MenuNew is a wrapper around the C function gtk_menu_new.
func MenuNew() *Menu {
	retC := C.gtk_menu_new()
	retGo := MenuNewFromC(unsafe.Pointer(retC))

	return retGo
}

// MenuGetForAttachWidget is a wrapper around the C function gtk_menu_get_for_attach_widget.
func MenuGetForAttachWidget(widget *Widget) *glib.List {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	retC := C.gtk_menu_get_for_attach_widget(c_widget)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Attach is a wrapper around the C function gtk_menu_attach.
func (recv *Menu) Attach(child *Widget, leftAttach uint32, rightAttach uint32, topAttach uint32, bottomAttach uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_left_attach := (C.guint)(leftAttach)

	c_right_attach := (C.guint)(rightAttach)

	c_top_attach := (C.guint)(topAttach)

	c_bottom_attach := (C.guint)(bottomAttach)

	C.gtk_menu_attach((*C.GtkMenu)(recv.native), c_child, c_left_attach, c_right_attach, c_top_attach, c_bottom_attach)

	return
}

// Unsupported : gtk_menu_attach_to_widget : unsupported parameter detacher : no type generator for MenuDetachFunc (GtkMenuDetachFunc) for param detacher

// Detach is a wrapper around the C function gtk_menu_detach.
func (recv *Menu) Detach() {
	C.gtk_menu_detach((*C.GtkMenu)(recv.native))

	return
}

// GetAccelGroup is a wrapper around the C function gtk_menu_get_accel_group.
func (recv *Menu) GetAccelGroup() *AccelGroup {
	retC := C.gtk_menu_get_accel_group((*C.GtkMenu)(recv.native))
	retGo := AccelGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetActive is a wrapper around the C function gtk_menu_get_active.
func (recv *Menu) GetActive() *Widget {
	retC := C.gtk_menu_get_active((*C.GtkMenu)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAttachWidget is a wrapper around the C function gtk_menu_get_attach_widget.
func (recv *Menu) GetAttachWidget() *Widget {
	retC := C.gtk_menu_get_attach_widget((*C.GtkMenu)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetTearoffState is a wrapper around the C function gtk_menu_get_tearoff_state.
func (recv *Menu) GetTearoffState() bool {
	retC := C.gtk_menu_get_tearoff_state((*C.GtkMenu)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTitle is a wrapper around the C function gtk_menu_get_title.
func (recv *Menu) GetTitle() string {
	retC := C.gtk_menu_get_title((*C.GtkMenu)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Popdown is a wrapper around the C function gtk_menu_popdown.
func (recv *Menu) Popdown() {
	C.gtk_menu_popdown((*C.GtkMenu)(recv.native))

	return
}

// Unsupported : gtk_menu_popup : unsupported parameter func : no type generator for MenuPositionFunc (GtkMenuPositionFunc) for param func

// ReorderChild is a wrapper around the C function gtk_menu_reorder_child.
func (recv *Menu) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_menu_reorder_child((*C.GtkMenu)(recv.native), c_child, c_position)

	return
}

// Reposition is a wrapper around the C function gtk_menu_reposition.
func (recv *Menu) Reposition() {
	C.gtk_menu_reposition((*C.GtkMenu)(recv.native))

	return
}

// SetAccelGroup is a wrapper around the C function gtk_menu_set_accel_group.
func (recv *Menu) SetAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_menu_set_accel_group((*C.GtkMenu)(recv.native), c_accel_group)

	return
}

// SetAccelPath is a wrapper around the C function gtk_menu_set_accel_path.
func (recv *Menu) SetAccelPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_menu_set_accel_path((*C.GtkMenu)(recv.native), c_accel_path)

	return
}

// SetActive is a wrapper around the C function gtk_menu_set_active.
func (recv *Menu) SetActive(index uint32) {
	c_index := (C.guint)(index)

	C.gtk_menu_set_active((*C.GtkMenu)(recv.native), c_index)

	return
}

// SetMonitor is a wrapper around the C function gtk_menu_set_monitor.
func (recv *Menu) SetMonitor(monitorNum int32) {
	c_monitor_num := (C.gint)(monitorNum)

	C.gtk_menu_set_monitor((*C.GtkMenu)(recv.native), c_monitor_num)

	return
}

// SetScreen is a wrapper around the C function gtk_menu_set_screen.
func (recv *Menu) SetScreen(screen *gdk.Screen) {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	C.gtk_menu_set_screen((*C.GtkMenu)(recv.native), c_screen)

	return
}

// SetTearoffState is a wrapper around the C function gtk_menu_set_tearoff_state.
func (recv *Menu) SetTearoffState(tornOff bool) {
	c_torn_off :=
		boolToGboolean(tornOff)

	C.gtk_menu_set_tearoff_state((*C.GtkMenu)(recv.native), c_torn_off)

	return
}

// SetTitle is a wrapper around the C function gtk_menu_set_title.
func (recv *Menu) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_menu_set_title((*C.GtkMenu)(recv.native), c_title)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Menu
func (recv *Menu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Menu
func (recv *Menu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuAccessible is a wrapper around the C record GtkMenuAccessible.
type MenuAccessible struct {
	native *C.GtkMenuAccessible
	// parent : record
	// priv : record
}

func MenuAccessibleNewFromC(u unsafe.Pointer) *MenuAccessible {
	c := (*C.GtkMenuAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuAccessible with another MenuAccessible, and returns true if they represent the same GObject.
func (recv *MenuAccessible) Equals(other *MenuAccessible) bool {
	return other.ToC() == recv.ToC()
}

// MenuShellAccessible upcasts to *MenuShellAccessible
func (recv *MenuAccessible) MenuShellAccessible() *MenuShellAccessible {
	return MenuShellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.MenuShellAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.MenuShellAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuAccessible) Accessible() *Accessible {
	return recv.MenuShellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuAccessible) Object() *atk.Object {
	return recv.MenuShellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to MenuAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuAccessible.
func CastToMenuAccessible(object *gobject.Object) *MenuAccessible {
	return MenuAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by MenuAccessible
func (recv *MenuAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuAccessible
func (recv *MenuAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuBar is a wrapper around the C record GtkMenuBar.
type MenuBar struct {
	native *C.GtkMenuBar
	// menu_shell : record
	// Private : priv
}

func MenuBarNewFromC(u unsafe.Pointer) *MenuBar {
	c := (*C.GtkMenuBar)(u)
	if c == nil {
		return nil
	}

	g := &MenuBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuBar with another MenuBar, and returns true if they represent the same GObject.
func (recv *MenuBar) Equals(other *MenuBar) bool {
	return other.ToC() == recv.ToC()
}

// MenuShell upcasts to *MenuShell
func (recv *MenuBar) MenuShell() *MenuShell {
	return MenuShellNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *MenuBar) Container() *Container {
	return recv.MenuShell().Container()
}

// Widget upcasts to *Widget
func (recv *MenuBar) Widget() *Widget {
	return recv.MenuShell().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuShell().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuBar) Object() *gobject.Object {
	return recv.MenuShell().Object()
}

// CastToWidget down casts any arbitrary Object to MenuBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuBar.
func CastToMenuBar(object *gobject.Object) *MenuBar {
	return MenuBarNewFromC(object.ToC())
}

// MenuBarNew is a wrapper around the C function gtk_menu_bar_new.
func MenuBarNew() *MenuBar {
	retC := C.gtk_menu_bar_new()
	retGo := MenuBarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetChildPackDirection is a wrapper around the C function gtk_menu_bar_get_child_pack_direction.
func (recv *MenuBar) GetChildPackDirection() PackDirection {
	retC := C.gtk_menu_bar_get_child_pack_direction((*C.GtkMenuBar)(recv.native))
	retGo := (PackDirection)(retC)

	return retGo
}

// GetPackDirection is a wrapper around the C function gtk_menu_bar_get_pack_direction.
func (recv *MenuBar) GetPackDirection() PackDirection {
	retC := C.gtk_menu_bar_get_pack_direction((*C.GtkMenuBar)(recv.native))
	retGo := (PackDirection)(retC)

	return retGo
}

// SetChildPackDirection is a wrapper around the C function gtk_menu_bar_set_child_pack_direction.
func (recv *MenuBar) SetChildPackDirection(childPackDir PackDirection) {
	c_child_pack_dir := (C.GtkPackDirection)(childPackDir)

	C.gtk_menu_bar_set_child_pack_direction((*C.GtkMenuBar)(recv.native), c_child_pack_dir)

	return
}

// SetPackDirection is a wrapper around the C function gtk_menu_bar_set_pack_direction.
func (recv *MenuBar) SetPackDirection(packDir PackDirection) {
	c_pack_dir := (C.GtkPackDirection)(packDir)

	C.gtk_menu_bar_set_pack_direction((*C.GtkMenuBar)(recv.native), c_pack_dir)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuBar
func (recv *MenuBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuBar
func (recv *MenuBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuButton is a wrapper around the C record GtkMenuButton.
type MenuButton struct {
	native *C.GtkMenuButton
	// parent : record
	// Private : priv
}

func MenuButtonNewFromC(u unsafe.Pointer) *MenuButton {
	c := (*C.GtkMenuButton)(u)
	if c == nil {
		return nil
	}

	g := &MenuButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuButton with another MenuButton, and returns true if they represent the same GObject.
func (recv *MenuButton) Equals(other *MenuButton) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButton upcasts to *ToggleButton
func (recv *MenuButton) ToggleButton() *ToggleButton {
	return ToggleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *MenuButton) Button() *Button {
	return recv.ToggleButton().Button()
}

// Bin upcasts to *Bin
func (recv *MenuButton) Bin() *Bin {
	return recv.ToggleButton().Bin()
}

// Container upcasts to *Container
func (recv *MenuButton) Container() *Container {
	return recv.ToggleButton().Container()
}

// Widget upcasts to *Widget
func (recv *MenuButton) Widget() *Widget {
	return recv.ToggleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuButton) Object() *gobject.Object {
	return recv.ToggleButton().Object()
}

// CastToWidget down casts any arbitrary Object to MenuButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuButton.
func CastToMenuButton(object *gobject.Object) *MenuButton {
	return MenuButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuButton
func (recv *MenuButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuButton
func (recv *MenuButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuButton
func (recv *MenuButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuButton
func (recv *MenuButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuButtonAccessible is a wrapper around the C record GtkMenuButtonAccessible.
type MenuButtonAccessible struct {
	native *C.GtkMenuButtonAccessible
	// parent : record
	// priv : record
}

func MenuButtonAccessibleNewFromC(u unsafe.Pointer) *MenuButtonAccessible {
	c := (*C.GtkMenuButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuButtonAccessible with another MenuButtonAccessible, and returns true if they represent the same GObject.
func (recv *MenuButtonAccessible) Equals(other *MenuButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButtonAccessible upcasts to *ToggleButtonAccessible
func (recv *MenuButtonAccessible) ToggleButtonAccessible() *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *MenuButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return recv.ToggleButtonAccessible().ButtonAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ToggleButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ToggleButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuButtonAccessible) Accessible() *Accessible {
	return recv.ToggleButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuButtonAccessible) Object() *atk.Object {
	return recv.ToggleButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to MenuButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuButtonAccessible.
func CastToMenuButtonAccessible(object *gobject.Object) *MenuButtonAccessible {
	return MenuButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by MenuButtonAccessible
func (recv *MenuButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// MenuItem is a wrapper around the C record GtkMenuItem.
type MenuItem struct {
	native *C.GtkMenuItem
	// bin : record
	// Private : priv
}

func MenuItemNewFromC(u unsafe.Pointer) *MenuItem {
	c := (*C.GtkMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &MenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItem with another MenuItem, and returns true if they represent the same GObject.
func (recv *MenuItem) Equals(other *MenuItem) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *MenuItem) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *MenuItem) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *MenuItem) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuItem) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to MenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItem.
func CastToMenuItem(object *gobject.Object) *MenuItem {
	return MenuItemNewFromC(object.ToC())
}

type signalMenuItemActivateDetail struct {
	callback  MenuItemSignalActivateCallback
	handlerID C.gulong
}

var signalMenuItemActivateId int
var signalMenuItemActivateMap = make(map[int]signalMenuItemActivateDetail)
var signalMenuItemActivateLock sync.RWMutex

// MenuItemSignalActivateCallback is a callback function for a 'activate' signal emitted from a MenuItem.
type MenuItemSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *MenuItem) ConnectActivate(callback MenuItemSignalActivateCallback) int {
	signalMenuItemActivateLock.Lock()
	defer signalMenuItemActivateLock.Unlock()

	signalMenuItemActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_activate(instance, C.gpointer(uintptr(signalMenuItemActivateId)))

	detail := signalMenuItemActivateDetail{callback, handlerID}
	signalMenuItemActivateMap[signalMenuItemActivateId] = detail

	return signalMenuItemActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *MenuItem) DisconnectActivate(connectionID int) {
	signalMenuItemActivateLock.Lock()
	defer signalMenuItemActivateLock.Unlock()

	detail, exists := signalMenuItemActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemActivateMap, connectionID)
}

//export menuitem_activateHandler
func menuitem_activateHandler(_ *C.GObject, data C.gpointer) {
	signalMenuItemActivateLock.RLock()
	defer signalMenuItemActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuItemActivateMap[index].callback
	callback()
}

type signalMenuItemActivateItemDetail struct {
	callback  MenuItemSignalActivateItemCallback
	handlerID C.gulong
}

var signalMenuItemActivateItemId int
var signalMenuItemActivateItemMap = make(map[int]signalMenuItemActivateItemDetail)
var signalMenuItemActivateItemLock sync.RWMutex

// MenuItemSignalActivateItemCallback is a callback function for a 'activate-item' signal emitted from a MenuItem.
type MenuItemSignalActivateItemCallback func()

/*
ConnectActivateItem connects the callback to the 'activate-item' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectActivateItem to remove it.
*/
func (recv *MenuItem) ConnectActivateItem(callback MenuItemSignalActivateItemCallback) int {
	signalMenuItemActivateItemLock.Lock()
	defer signalMenuItemActivateItemLock.Unlock()

	signalMenuItemActivateItemId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_activate_item(instance, C.gpointer(uintptr(signalMenuItemActivateItemId)))

	detail := signalMenuItemActivateItemDetail{callback, handlerID}
	signalMenuItemActivateItemMap[signalMenuItemActivateItemId] = detail

	return signalMenuItemActivateItemId
}

/*
DisconnectActivateItem disconnects a callback from the 'activate-item' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectActivateItem.
*/
func (recv *MenuItem) DisconnectActivateItem(connectionID int) {
	signalMenuItemActivateItemLock.Lock()
	defer signalMenuItemActivateItemLock.Unlock()

	detail, exists := signalMenuItemActivateItemMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemActivateItemMap, connectionID)
}

//export menuitem_activateItemHandler
func menuitem_activateItemHandler(_ *C.GObject, data C.gpointer) {
	signalMenuItemActivateItemLock.RLock()
	defer signalMenuItemActivateItemLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuItemActivateItemMap[index].callback
	callback()
}

type signalMenuItemDeselectDetail struct {
	callback  MenuItemSignalDeselectCallback
	handlerID C.gulong
}

var signalMenuItemDeselectId int
var signalMenuItemDeselectMap = make(map[int]signalMenuItemDeselectDetail)
var signalMenuItemDeselectLock sync.RWMutex

// MenuItemSignalDeselectCallback is a callback function for a 'deselect' signal emitted from a MenuItem.
type MenuItemSignalDeselectCallback func()

/*
ConnectDeselect connects the callback to the 'deselect' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectDeselect to remove it.
*/
func (recv *MenuItem) ConnectDeselect(callback MenuItemSignalDeselectCallback) int {
	signalMenuItemDeselectLock.Lock()
	defer signalMenuItemDeselectLock.Unlock()

	signalMenuItemDeselectId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_deselect(instance, C.gpointer(uintptr(signalMenuItemDeselectId)))

	detail := signalMenuItemDeselectDetail{callback, handlerID}
	signalMenuItemDeselectMap[signalMenuItemDeselectId] = detail

	return signalMenuItemDeselectId
}

/*
DisconnectDeselect disconnects a callback from the 'deselect' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectDeselect.
*/
func (recv *MenuItem) DisconnectDeselect(connectionID int) {
	signalMenuItemDeselectLock.Lock()
	defer signalMenuItemDeselectLock.Unlock()

	detail, exists := signalMenuItemDeselectMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemDeselectMap, connectionID)
}

//export menuitem_deselectHandler
func menuitem_deselectHandler(_ *C.GObject, data C.gpointer) {
	signalMenuItemDeselectLock.RLock()
	defer signalMenuItemDeselectLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuItemDeselectMap[index].callback
	callback()
}

type signalMenuItemSelectDetail struct {
	callback  MenuItemSignalSelectCallback
	handlerID C.gulong
}

var signalMenuItemSelectId int
var signalMenuItemSelectMap = make(map[int]signalMenuItemSelectDetail)
var signalMenuItemSelectLock sync.RWMutex

// MenuItemSignalSelectCallback is a callback function for a 'select' signal emitted from a MenuItem.
type MenuItemSignalSelectCallback func()

/*
ConnectSelect connects the callback to the 'select' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectSelect to remove it.
*/
func (recv *MenuItem) ConnectSelect(callback MenuItemSignalSelectCallback) int {
	signalMenuItemSelectLock.Lock()
	defer signalMenuItemSelectLock.Unlock()

	signalMenuItemSelectId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_select(instance, C.gpointer(uintptr(signalMenuItemSelectId)))

	detail := signalMenuItemSelectDetail{callback, handlerID}
	signalMenuItemSelectMap[signalMenuItemSelectId] = detail

	return signalMenuItemSelectId
}

/*
DisconnectSelect disconnects a callback from the 'select' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectSelect.
*/
func (recv *MenuItem) DisconnectSelect(connectionID int) {
	signalMenuItemSelectLock.Lock()
	defer signalMenuItemSelectLock.Unlock()

	detail, exists := signalMenuItemSelectMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemSelectMap, connectionID)
}

//export menuitem_selectHandler
func menuitem_selectHandler(_ *C.GObject, data C.gpointer) {
	signalMenuItemSelectLock.RLock()
	defer signalMenuItemSelectLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuItemSelectMap[index].callback
	callback()
}

type signalMenuItemToggleSizeAllocateDetail struct {
	callback  MenuItemSignalToggleSizeAllocateCallback
	handlerID C.gulong
}

var signalMenuItemToggleSizeAllocateId int
var signalMenuItemToggleSizeAllocateMap = make(map[int]signalMenuItemToggleSizeAllocateDetail)
var signalMenuItemToggleSizeAllocateLock sync.RWMutex

// MenuItemSignalToggleSizeAllocateCallback is a callback function for a 'toggle-size-allocate' signal emitted from a MenuItem.
type MenuItemSignalToggleSizeAllocateCallback func(object int32)

/*
ConnectToggleSizeAllocate connects the callback to the 'toggle-size-allocate' signal for the MenuItem.

The returned value represents the connection, and may be passed to DisconnectToggleSizeAllocate to remove it.
*/
func (recv *MenuItem) ConnectToggleSizeAllocate(callback MenuItemSignalToggleSizeAllocateCallback) int {
	signalMenuItemToggleSizeAllocateLock.Lock()
	defer signalMenuItemToggleSizeAllocateLock.Unlock()

	signalMenuItemToggleSizeAllocateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuItem_signal_connect_toggle_size_allocate(instance, C.gpointer(uintptr(signalMenuItemToggleSizeAllocateId)))

	detail := signalMenuItemToggleSizeAllocateDetail{callback, handlerID}
	signalMenuItemToggleSizeAllocateMap[signalMenuItemToggleSizeAllocateId] = detail

	return signalMenuItemToggleSizeAllocateId
}

/*
DisconnectToggleSizeAllocate disconnects a callback from the 'toggle-size-allocate' signal for the MenuItem.

The connectionID should be a value returned from a call to ConnectToggleSizeAllocate.
*/
func (recv *MenuItem) DisconnectToggleSizeAllocate(connectionID int) {
	signalMenuItemToggleSizeAllocateLock.Lock()
	defer signalMenuItemToggleSizeAllocateLock.Unlock()

	detail, exists := signalMenuItemToggleSizeAllocateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuItemToggleSizeAllocateMap, connectionID)
}

//export menuitem_toggleSizeAllocateHandler
func menuitem_toggleSizeAllocateHandler(_ *C.GObject, c_object C.gint, data C.gpointer) {
	signalMenuItemToggleSizeAllocateLock.RLock()
	defer signalMenuItemToggleSizeAllocateLock.RUnlock()

	object := int32(c_object)

	index := int(uintptr(data))
	callback := signalMenuItemToggleSizeAllocateMap[index].callback
	callback(object)
}

// Unsupported signal 'toggle-size-request' for MenuItem : param object : gpointer

// MenuItemNew is a wrapper around the C function gtk_menu_item_new.
func MenuItemNew() *MenuItem {
	retC := C.gtk_menu_item_new()
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// MenuItemNewWithLabel is a wrapper around the C function gtk_menu_item_new_with_label.
func MenuItemNewWithLabel(label string) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_menu_item_new_with_label(c_label)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// MenuItemNewWithMnemonic is a wrapper around the C function gtk_menu_item_new_with_mnemonic.
func MenuItemNewWithMnemonic(label string) *MenuItem {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_menu_item_new_with_mnemonic(c_label)
	retGo := MenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Activate is a wrapper around the C function gtk_menu_item_activate.
func (recv *MenuItem) Activate() {
	C.gtk_menu_item_activate((*C.GtkMenuItem)(recv.native))

	return
}

// Deselect is a wrapper around the C function gtk_menu_item_deselect.
func (recv *MenuItem) Deselect() {
	C.gtk_menu_item_deselect((*C.GtkMenuItem)(recv.native))

	return
}

// GetRightJustified is a wrapper around the C function gtk_menu_item_get_right_justified.
func (recv *MenuItem) GetRightJustified() bool {
	retC := C.gtk_menu_item_get_right_justified((*C.GtkMenuItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSubmenu is a wrapper around the C function gtk_menu_item_get_submenu.
func (recv *MenuItem) GetSubmenu() *Widget {
	retC := C.gtk_menu_item_get_submenu((*C.GtkMenuItem)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Select is a wrapper around the C function gtk_menu_item_select.
func (recv *MenuItem) Select() {
	C.gtk_menu_item_select((*C.GtkMenuItem)(recv.native))

	return
}

// SetAccelPath is a wrapper around the C function gtk_menu_item_set_accel_path.
func (recv *MenuItem) SetAccelPath(accelPath string) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	C.gtk_menu_item_set_accel_path((*C.GtkMenuItem)(recv.native), c_accel_path)

	return
}

// SetRightJustified is a wrapper around the C function gtk_menu_item_set_right_justified.
func (recv *MenuItem) SetRightJustified(rightJustified bool) {
	c_right_justified :=
		boolToGboolean(rightJustified)

	C.gtk_menu_item_set_right_justified((*C.GtkMenuItem)(recv.native), c_right_justified)

	return
}

// SetSubmenu is a wrapper around the C function gtk_menu_item_set_submenu.
func (recv *MenuItem) SetSubmenu(submenu *Menu) {
	c_submenu := (*C.GtkWidget)(C.NULL)
	if submenu != nil {
		c_submenu = (*C.GtkWidget)(submenu.ToC())
	}

	C.gtk_menu_item_set_submenu((*C.GtkMenuItem)(recv.native), c_submenu)

	return
}

// ToggleSizeAllocate is a wrapper around the C function gtk_menu_item_toggle_size_allocate.
func (recv *MenuItem) ToggleSizeAllocate(allocation int32) {
	c_allocation := (C.gint)(allocation)

	C.gtk_menu_item_toggle_size_allocate((*C.GtkMenuItem)(recv.native), c_allocation)

	return
}

// ToggleSizeRequest is a wrapper around the C function gtk_menu_item_toggle_size_request.
func (recv *MenuItem) ToggleSizeRequest(requisition int32) {
	c_requisition := (C.gint)(requisition)

	C.gtk_menu_item_toggle_size_request((*C.GtkMenuItem)(recv.native), &c_requisition)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuItem
func (recv *MenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuItem
func (recv *MenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuItem
func (recv *MenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuItem
func (recv *MenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuItemAccessible is a wrapper around the C record GtkMenuItemAccessible.
type MenuItemAccessible struct {
	native *C.GtkMenuItemAccessible
	// parent : record
	// priv : record
}

func MenuItemAccessibleNewFromC(u unsafe.Pointer) *MenuItemAccessible {
	c := (*C.GtkMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuItemAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuItemAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItemAccessible with another MenuItemAccessible, and returns true if they represent the same GObject.
func (recv *MenuItemAccessible) Equals(other *MenuItemAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuItemAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuItemAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to MenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuItemAccessible.
func CastToMenuItemAccessible(object *gobject.Object) *MenuItemAccessible {
	return MenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuItemAccessible
func (recv *MenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuShell is a wrapper around the C record GtkMenuShell.
type MenuShell struct {
	native *C.GtkMenuShell
	// container : record
	// Private : priv
}

func MenuShellNewFromC(u unsafe.Pointer) *MenuShell {
	c := (*C.GtkMenuShell)(u)
	if c == nil {
		return nil
	}

	g := &MenuShell{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuShell) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuShell) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuShell with another MenuShell, and returns true if they represent the same GObject.
func (recv *MenuShell) Equals(other *MenuShell) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *MenuShell) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *MenuShell) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuShell) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuShell) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to MenuShell.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuShell.
func CastToMenuShell(object *gobject.Object) *MenuShell {
	return MenuShellNewFromC(object.ToC())
}

type signalMenuShellActivateCurrentDetail struct {
	callback  MenuShellSignalActivateCurrentCallback
	handlerID C.gulong
}

var signalMenuShellActivateCurrentId int
var signalMenuShellActivateCurrentMap = make(map[int]signalMenuShellActivateCurrentDetail)
var signalMenuShellActivateCurrentLock sync.RWMutex

// MenuShellSignalActivateCurrentCallback is a callback function for a 'activate-current' signal emitted from a MenuShell.
type MenuShellSignalActivateCurrentCallback func(forceHide bool)

/*
ConnectActivateCurrent connects the callback to the 'activate-current' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectActivateCurrent to remove it.
*/
func (recv *MenuShell) ConnectActivateCurrent(callback MenuShellSignalActivateCurrentCallback) int {
	signalMenuShellActivateCurrentLock.Lock()
	defer signalMenuShellActivateCurrentLock.Unlock()

	signalMenuShellActivateCurrentId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_activate_current(instance, C.gpointer(uintptr(signalMenuShellActivateCurrentId)))

	detail := signalMenuShellActivateCurrentDetail{callback, handlerID}
	signalMenuShellActivateCurrentMap[signalMenuShellActivateCurrentId] = detail

	return signalMenuShellActivateCurrentId
}

/*
DisconnectActivateCurrent disconnects a callback from the 'activate-current' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectActivateCurrent.
*/
func (recv *MenuShell) DisconnectActivateCurrent(connectionID int) {
	signalMenuShellActivateCurrentLock.Lock()
	defer signalMenuShellActivateCurrentLock.Unlock()

	detail, exists := signalMenuShellActivateCurrentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellActivateCurrentMap, connectionID)
}

//export menushell_activateCurrentHandler
func menushell_activateCurrentHandler(_ *C.GObject, c_force_hide C.gboolean, data C.gpointer) {
	signalMenuShellActivateCurrentLock.RLock()
	defer signalMenuShellActivateCurrentLock.RUnlock()

	forceHide := c_force_hide == C.TRUE

	index := int(uintptr(data))
	callback := signalMenuShellActivateCurrentMap[index].callback
	callback(forceHide)
}

type signalMenuShellCancelDetail struct {
	callback  MenuShellSignalCancelCallback
	handlerID C.gulong
}

var signalMenuShellCancelId int
var signalMenuShellCancelMap = make(map[int]signalMenuShellCancelDetail)
var signalMenuShellCancelLock sync.RWMutex

// MenuShellSignalCancelCallback is a callback function for a 'cancel' signal emitted from a MenuShell.
type MenuShellSignalCancelCallback func()

/*
ConnectCancel connects the callback to the 'cancel' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectCancel to remove it.
*/
func (recv *MenuShell) ConnectCancel(callback MenuShellSignalCancelCallback) int {
	signalMenuShellCancelLock.Lock()
	defer signalMenuShellCancelLock.Unlock()

	signalMenuShellCancelId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_cancel(instance, C.gpointer(uintptr(signalMenuShellCancelId)))

	detail := signalMenuShellCancelDetail{callback, handlerID}
	signalMenuShellCancelMap[signalMenuShellCancelId] = detail

	return signalMenuShellCancelId
}

/*
DisconnectCancel disconnects a callback from the 'cancel' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectCancel.
*/
func (recv *MenuShell) DisconnectCancel(connectionID int) {
	signalMenuShellCancelLock.Lock()
	defer signalMenuShellCancelLock.Unlock()

	detail, exists := signalMenuShellCancelMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellCancelMap, connectionID)
}

//export menushell_cancelHandler
func menushell_cancelHandler(_ *C.GObject, data C.gpointer) {
	signalMenuShellCancelLock.RLock()
	defer signalMenuShellCancelLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuShellCancelMap[index].callback
	callback()
}

type signalMenuShellCycleFocusDetail struct {
	callback  MenuShellSignalCycleFocusCallback
	handlerID C.gulong
}

var signalMenuShellCycleFocusId int
var signalMenuShellCycleFocusMap = make(map[int]signalMenuShellCycleFocusDetail)
var signalMenuShellCycleFocusLock sync.RWMutex

// MenuShellSignalCycleFocusCallback is a callback function for a 'cycle-focus' signal emitted from a MenuShell.
type MenuShellSignalCycleFocusCallback func(direction DirectionType)

/*
ConnectCycleFocus connects the callback to the 'cycle-focus' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectCycleFocus to remove it.
*/
func (recv *MenuShell) ConnectCycleFocus(callback MenuShellSignalCycleFocusCallback) int {
	signalMenuShellCycleFocusLock.Lock()
	defer signalMenuShellCycleFocusLock.Unlock()

	signalMenuShellCycleFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_cycle_focus(instance, C.gpointer(uintptr(signalMenuShellCycleFocusId)))

	detail := signalMenuShellCycleFocusDetail{callback, handlerID}
	signalMenuShellCycleFocusMap[signalMenuShellCycleFocusId] = detail

	return signalMenuShellCycleFocusId
}

/*
DisconnectCycleFocus disconnects a callback from the 'cycle-focus' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectCycleFocus.
*/
func (recv *MenuShell) DisconnectCycleFocus(connectionID int) {
	signalMenuShellCycleFocusLock.Lock()
	defer signalMenuShellCycleFocusLock.Unlock()

	detail, exists := signalMenuShellCycleFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellCycleFocusMap, connectionID)
}

//export menushell_cycleFocusHandler
func menushell_cycleFocusHandler(_ *C.GObject, c_direction C.GtkDirectionType, data C.gpointer) {
	signalMenuShellCycleFocusLock.RLock()
	defer signalMenuShellCycleFocusLock.RUnlock()

	direction := DirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalMenuShellCycleFocusMap[index].callback
	callback(direction)
}

type signalMenuShellDeactivateDetail struct {
	callback  MenuShellSignalDeactivateCallback
	handlerID C.gulong
}

var signalMenuShellDeactivateId int
var signalMenuShellDeactivateMap = make(map[int]signalMenuShellDeactivateDetail)
var signalMenuShellDeactivateLock sync.RWMutex

// MenuShellSignalDeactivateCallback is a callback function for a 'deactivate' signal emitted from a MenuShell.
type MenuShellSignalDeactivateCallback func()

/*
ConnectDeactivate connects the callback to the 'deactivate' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectDeactivate to remove it.
*/
func (recv *MenuShell) ConnectDeactivate(callback MenuShellSignalDeactivateCallback) int {
	signalMenuShellDeactivateLock.Lock()
	defer signalMenuShellDeactivateLock.Unlock()

	signalMenuShellDeactivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_deactivate(instance, C.gpointer(uintptr(signalMenuShellDeactivateId)))

	detail := signalMenuShellDeactivateDetail{callback, handlerID}
	signalMenuShellDeactivateMap[signalMenuShellDeactivateId] = detail

	return signalMenuShellDeactivateId
}

/*
DisconnectDeactivate disconnects a callback from the 'deactivate' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectDeactivate.
*/
func (recv *MenuShell) DisconnectDeactivate(connectionID int) {
	signalMenuShellDeactivateLock.Lock()
	defer signalMenuShellDeactivateLock.Unlock()

	detail, exists := signalMenuShellDeactivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellDeactivateMap, connectionID)
}

//export menushell_deactivateHandler
func menushell_deactivateHandler(_ *C.GObject, data C.gpointer) {
	signalMenuShellDeactivateLock.RLock()
	defer signalMenuShellDeactivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuShellDeactivateMap[index].callback
	callback()
}

type signalMenuShellMoveCurrentDetail struct {
	callback  MenuShellSignalMoveCurrentCallback
	handlerID C.gulong
}

var signalMenuShellMoveCurrentId int
var signalMenuShellMoveCurrentMap = make(map[int]signalMenuShellMoveCurrentDetail)
var signalMenuShellMoveCurrentLock sync.RWMutex

// MenuShellSignalMoveCurrentCallback is a callback function for a 'move-current' signal emitted from a MenuShell.
type MenuShellSignalMoveCurrentCallback func(direction MenuDirectionType)

/*
ConnectMoveCurrent connects the callback to the 'move-current' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectMoveCurrent to remove it.
*/
func (recv *MenuShell) ConnectMoveCurrent(callback MenuShellSignalMoveCurrentCallback) int {
	signalMenuShellMoveCurrentLock.Lock()
	defer signalMenuShellMoveCurrentLock.Unlock()

	signalMenuShellMoveCurrentId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_move_current(instance, C.gpointer(uintptr(signalMenuShellMoveCurrentId)))

	detail := signalMenuShellMoveCurrentDetail{callback, handlerID}
	signalMenuShellMoveCurrentMap[signalMenuShellMoveCurrentId] = detail

	return signalMenuShellMoveCurrentId
}

/*
DisconnectMoveCurrent disconnects a callback from the 'move-current' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectMoveCurrent.
*/
func (recv *MenuShell) DisconnectMoveCurrent(connectionID int) {
	signalMenuShellMoveCurrentLock.Lock()
	defer signalMenuShellMoveCurrentLock.Unlock()

	detail, exists := signalMenuShellMoveCurrentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellMoveCurrentMap, connectionID)
}

//export menushell_moveCurrentHandler
func menushell_moveCurrentHandler(_ *C.GObject, c_direction C.GtkMenuDirectionType, data C.gpointer) {
	signalMenuShellMoveCurrentLock.RLock()
	defer signalMenuShellMoveCurrentLock.RUnlock()

	direction := MenuDirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalMenuShellMoveCurrentMap[index].callback
	callback(direction)
}

type signalMenuShellMoveSelectedDetail struct {
	callback  MenuShellSignalMoveSelectedCallback
	handlerID C.gulong
}

var signalMenuShellMoveSelectedId int
var signalMenuShellMoveSelectedMap = make(map[int]signalMenuShellMoveSelectedDetail)
var signalMenuShellMoveSelectedLock sync.RWMutex

// MenuShellSignalMoveSelectedCallback is a callback function for a 'move-selected' signal emitted from a MenuShell.
type MenuShellSignalMoveSelectedCallback func(distance int32) bool

/*
ConnectMoveSelected connects the callback to the 'move-selected' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectMoveSelected to remove it.
*/
func (recv *MenuShell) ConnectMoveSelected(callback MenuShellSignalMoveSelectedCallback) int {
	signalMenuShellMoveSelectedLock.Lock()
	defer signalMenuShellMoveSelectedLock.Unlock()

	signalMenuShellMoveSelectedId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_move_selected(instance, C.gpointer(uintptr(signalMenuShellMoveSelectedId)))

	detail := signalMenuShellMoveSelectedDetail{callback, handlerID}
	signalMenuShellMoveSelectedMap[signalMenuShellMoveSelectedId] = detail

	return signalMenuShellMoveSelectedId
}

/*
DisconnectMoveSelected disconnects a callback from the 'move-selected' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectMoveSelected.
*/
func (recv *MenuShell) DisconnectMoveSelected(connectionID int) {
	signalMenuShellMoveSelectedLock.Lock()
	defer signalMenuShellMoveSelectedLock.Unlock()

	detail, exists := signalMenuShellMoveSelectedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellMoveSelectedMap, connectionID)
}

//export menushell_moveSelectedHandler
func menushell_moveSelectedHandler(_ *C.GObject, c_distance C.gint, data C.gpointer) C.gboolean {
	signalMenuShellMoveSelectedLock.RLock()
	defer signalMenuShellMoveSelectedLock.RUnlock()

	distance := int32(c_distance)

	index := int(uintptr(data))
	callback := signalMenuShellMoveSelectedMap[index].callback
	retGo := callback(distance)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalMenuShellSelectionDoneDetail struct {
	callback  MenuShellSignalSelectionDoneCallback
	handlerID C.gulong
}

var signalMenuShellSelectionDoneId int
var signalMenuShellSelectionDoneMap = make(map[int]signalMenuShellSelectionDoneDetail)
var signalMenuShellSelectionDoneLock sync.RWMutex

// MenuShellSignalSelectionDoneCallback is a callback function for a 'selection-done' signal emitted from a MenuShell.
type MenuShellSignalSelectionDoneCallback func()

/*
ConnectSelectionDone connects the callback to the 'selection-done' signal for the MenuShell.

The returned value represents the connection, and may be passed to DisconnectSelectionDone to remove it.
*/
func (recv *MenuShell) ConnectSelectionDone(callback MenuShellSignalSelectionDoneCallback) int {
	signalMenuShellSelectionDoneLock.Lock()
	defer signalMenuShellSelectionDoneLock.Unlock()

	signalMenuShellSelectionDoneId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuShell_signal_connect_selection_done(instance, C.gpointer(uintptr(signalMenuShellSelectionDoneId)))

	detail := signalMenuShellSelectionDoneDetail{callback, handlerID}
	signalMenuShellSelectionDoneMap[signalMenuShellSelectionDoneId] = detail

	return signalMenuShellSelectionDoneId
}

/*
DisconnectSelectionDone disconnects a callback from the 'selection-done' signal for the MenuShell.

The connectionID should be a value returned from a call to ConnectSelectionDone.
*/
func (recv *MenuShell) DisconnectSelectionDone(connectionID int) {
	signalMenuShellSelectionDoneLock.Lock()
	defer signalMenuShellSelectionDoneLock.Unlock()

	detail, exists := signalMenuShellSelectionDoneMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuShellSelectionDoneMap, connectionID)
}

//export menushell_selectionDoneHandler
func menushell_selectionDoneHandler(_ *C.GObject, data C.gpointer) {
	signalMenuShellSelectionDoneLock.RLock()
	defer signalMenuShellSelectionDoneLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuShellSelectionDoneMap[index].callback
	callback()
}

// ActivateItem is a wrapper around the C function gtk_menu_shell_activate_item.
func (recv *MenuShell) ActivateItem(menuItem *Widget, forceDeactivate bool) {
	c_menu_item := (*C.GtkWidget)(C.NULL)
	if menuItem != nil {
		c_menu_item = (*C.GtkWidget)(menuItem.ToC())
	}

	c_force_deactivate :=
		boolToGboolean(forceDeactivate)

	C.gtk_menu_shell_activate_item((*C.GtkMenuShell)(recv.native), c_menu_item, c_force_deactivate)

	return
}

// Append is a wrapper around the C function gtk_menu_shell_append.
func (recv *MenuShell) Append(child *MenuItem) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_menu_shell_append((*C.GtkMenuShell)(recv.native), c_child)

	return
}

// Cancel is a wrapper around the C function gtk_menu_shell_cancel.
func (recv *MenuShell) Cancel() {
	C.gtk_menu_shell_cancel((*C.GtkMenuShell)(recv.native))

	return
}

// Deactivate is a wrapper around the C function gtk_menu_shell_deactivate.
func (recv *MenuShell) Deactivate() {
	C.gtk_menu_shell_deactivate((*C.GtkMenuShell)(recv.native))

	return
}

// Deselect is a wrapper around the C function gtk_menu_shell_deselect.
func (recv *MenuShell) Deselect() {
	C.gtk_menu_shell_deselect((*C.GtkMenuShell)(recv.native))

	return
}

// GetTakeFocus is a wrapper around the C function gtk_menu_shell_get_take_focus.
func (recv *MenuShell) GetTakeFocus() bool {
	retC := C.gtk_menu_shell_get_take_focus((*C.GtkMenuShell)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Insert is a wrapper around the C function gtk_menu_shell_insert.
func (recv *MenuShell) Insert(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_menu_shell_insert((*C.GtkMenuShell)(recv.native), c_child, c_position)

	return
}

// Prepend is a wrapper around the C function gtk_menu_shell_prepend.
func (recv *MenuShell) Prepend(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_menu_shell_prepend((*C.GtkMenuShell)(recv.native), c_child)

	return
}

// SelectFirst is a wrapper around the C function gtk_menu_shell_select_first.
func (recv *MenuShell) SelectFirst(searchSensitive bool) {
	c_search_sensitive :=
		boolToGboolean(searchSensitive)

	C.gtk_menu_shell_select_first((*C.GtkMenuShell)(recv.native), c_search_sensitive)

	return
}

// SelectItem is a wrapper around the C function gtk_menu_shell_select_item.
func (recv *MenuShell) SelectItem(menuItem *Widget) {
	c_menu_item := (*C.GtkWidget)(C.NULL)
	if menuItem != nil {
		c_menu_item = (*C.GtkWidget)(menuItem.ToC())
	}

	C.gtk_menu_shell_select_item((*C.GtkMenuShell)(recv.native), c_menu_item)

	return
}

// SetTakeFocus is a wrapper around the C function gtk_menu_shell_set_take_focus.
func (recv *MenuShell) SetTakeFocus(takeFocus bool) {
	c_take_focus :=
		boolToGboolean(takeFocus)

	C.gtk_menu_shell_set_take_focus((*C.GtkMenuShell)(recv.native), c_take_focus)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuShell
func (recv *MenuShell) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuShell
func (recv *MenuShell) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MenuShellAccessible is a wrapper around the C record GtkMenuShellAccessible.
type MenuShellAccessible struct {
	native *C.GtkMenuShellAccessible
	// parent : record
	// priv : record
}

func MenuShellAccessibleNewFromC(u unsafe.Pointer) *MenuShellAccessible {
	c := (*C.GtkMenuShellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &MenuShellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuShellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuShellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuShellAccessible with another MenuShellAccessible, and returns true if they represent the same GObject.
func (recv *MenuShellAccessible) Equals(other *MenuShellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *MenuShellAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *MenuShellAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *MenuShellAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *MenuShellAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to MenuShellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuShellAccessible.
func CastToMenuShellAccessible(object *gobject.Object) *MenuShellAccessible {
	return MenuShellAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by MenuShellAccessible
func (recv *MenuShellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by MenuShellAccessible
func (recv *MenuShellAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// MenuToolButton is a wrapper around the C record GtkMenuToolButton.
type MenuToolButton struct {
	native *C.GtkMenuToolButton
	// parent : record
	// Private : priv
}

func MenuToolButtonNewFromC(u unsafe.Pointer) *MenuToolButton {
	c := (*C.GtkMenuToolButton)(u)
	if c == nil {
		return nil
	}

	g := &MenuToolButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MenuToolButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MenuToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuToolButton with another MenuToolButton, and returns true if they represent the same GObject.
func (recv *MenuToolButton) Equals(other *MenuToolButton) bool {
	return other.ToC() == recv.ToC()
}

// ToolButton upcasts to *ToolButton
func (recv *MenuToolButton) ToolButton() *ToolButton {
	return ToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolItem upcasts to *ToolItem
func (recv *MenuToolButton) ToolItem() *ToolItem {
	return recv.ToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *MenuToolButton) Bin() *Bin {
	return recv.ToolButton().Bin()
}

// Container upcasts to *Container
func (recv *MenuToolButton) Container() *Container {
	return recv.ToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *MenuToolButton) Widget() *Widget {
	return recv.ToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MenuToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MenuToolButton) Object() *gobject.Object {
	return recv.ToolButton().Object()
}

// CastToWidget down casts any arbitrary Object to MenuToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a MenuToolButton.
func CastToMenuToolButton(object *gobject.Object) *MenuToolButton {
	return MenuToolButtonNewFromC(object.ToC())
}

type signalMenuToolButtonShowMenuDetail struct {
	callback  MenuToolButtonSignalShowMenuCallback
	handlerID C.gulong
}

var signalMenuToolButtonShowMenuId int
var signalMenuToolButtonShowMenuMap = make(map[int]signalMenuToolButtonShowMenuDetail)
var signalMenuToolButtonShowMenuLock sync.RWMutex

// MenuToolButtonSignalShowMenuCallback is a callback function for a 'show-menu' signal emitted from a MenuToolButton.
type MenuToolButtonSignalShowMenuCallback func()

/*
ConnectShowMenu connects the callback to the 'show-menu' signal for the MenuToolButton.

The returned value represents the connection, and may be passed to DisconnectShowMenu to remove it.
*/
func (recv *MenuToolButton) ConnectShowMenu(callback MenuToolButtonSignalShowMenuCallback) int {
	signalMenuToolButtonShowMenuLock.Lock()
	defer signalMenuToolButtonShowMenuLock.Unlock()

	signalMenuToolButtonShowMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.MenuToolButton_signal_connect_show_menu(instance, C.gpointer(uintptr(signalMenuToolButtonShowMenuId)))

	detail := signalMenuToolButtonShowMenuDetail{callback, handlerID}
	signalMenuToolButtonShowMenuMap[signalMenuToolButtonShowMenuId] = detail

	return signalMenuToolButtonShowMenuId
}

/*
DisconnectShowMenu disconnects a callback from the 'show-menu' signal for the MenuToolButton.

The connectionID should be a value returned from a call to ConnectShowMenu.
*/
func (recv *MenuToolButton) DisconnectShowMenu(connectionID int) {
	signalMenuToolButtonShowMenuLock.Lock()
	defer signalMenuToolButtonShowMenuLock.Unlock()

	detail, exists := signalMenuToolButtonShowMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalMenuToolButtonShowMenuMap, connectionID)
}

//export menutoolbutton_showMenuHandler
func menutoolbutton_showMenuHandler(_ *C.GObject, data C.gpointer) {
	signalMenuToolButtonShowMenuLock.RLock()
	defer signalMenuToolButtonShowMenuLock.RUnlock()

	index := int(uintptr(data))
	callback := signalMenuToolButtonShowMenuMap[index].callback
	callback()
}

// MenuToolButtonNew is a wrapper around the C function gtk_menu_tool_button_new.
func MenuToolButtonNew(iconWidget *Widget, label string) *MenuToolButton {
	c_icon_widget := (*C.GtkWidget)(C.NULL)
	if iconWidget != nil {
		c_icon_widget = (*C.GtkWidget)(iconWidget.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_menu_tool_button_new(c_icon_widget, c_label)
	retGo := MenuToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// MenuToolButtonNewFromStock is a wrapper around the C function gtk_menu_tool_button_new_from_stock.
func MenuToolButtonNewFromStock(stockId string) *MenuToolButton {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_menu_tool_button_new_from_stock(c_stock_id)
	retGo := MenuToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetMenu is a wrapper around the C function gtk_menu_tool_button_get_menu.
func (recv *MenuToolButton) GetMenu() *Widget {
	retC := C.gtk_menu_tool_button_get_menu((*C.GtkMenuToolButton)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetArrowTooltipMarkup is a wrapper around the C function gtk_menu_tool_button_set_arrow_tooltip_markup.
func (recv *MenuToolButton) SetArrowTooltipMarkup(markup string) {
	c_markup := C.CString(markup)
	defer C.free(unsafe.Pointer(c_markup))

	C.gtk_menu_tool_button_set_arrow_tooltip_markup((*C.GtkMenuToolButton)(recv.native), c_markup)

	return
}

// SetArrowTooltipText is a wrapper around the C function gtk_menu_tool_button_set_arrow_tooltip_text.
func (recv *MenuToolButton) SetArrowTooltipText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_menu_tool_button_set_arrow_tooltip_text((*C.GtkMenuToolButton)(recv.native), c_text)

	return
}

// SetMenu is a wrapper around the C function gtk_menu_tool_button_set_menu.
func (recv *MenuToolButton) SetMenu(menu *Widget) {
	c_menu := (*C.GtkWidget)(C.NULL)
	if menu != nil {
		c_menu = (*C.GtkWidget)(menu.ToC())
	}

	C.gtk_menu_tool_button_set_menu((*C.GtkMenuToolButton)(recv.native), c_menu)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MenuToolButton
func (recv *MenuToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by MenuToolButton
func (recv *MenuToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by MenuToolButton
func (recv *MenuToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MenuToolButton
func (recv *MenuToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MessageDialog is a wrapper around the C record GtkMessageDialog.
type MessageDialog struct {
	native *C.GtkMessageDialog
	// parent_instance : record
	// Private : priv
}

func MessageDialogNewFromC(u unsafe.Pointer) *MessageDialog {
	c := (*C.GtkMessageDialog)(u)
	if c == nil {
		return nil
	}

	g := &MessageDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MessageDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MessageDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MessageDialog with another MessageDialog, and returns true if they represent the same GObject.
func (recv *MessageDialog) Equals(other *MessageDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *MessageDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *MessageDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *MessageDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *MessageDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *MessageDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *MessageDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *MessageDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to MessageDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a MessageDialog.
func CastToMessageDialog(object *gobject.Object) *MessageDialog {
	return MessageDialogNewFromC(object.ToC())
}

// MessageDialogNew is a wrapper around the C function gtk_message_dialog_new.
func MessageDialogNew(parent *Window, flags DialogFlags, type_ MessageType, buttons ButtonsType, messageFormat string, args ...interface{}) *MessageDialog {
	c_parent := (*C.GtkWindow)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWindow)(parent.ToC())
	}

	c_flags := (C.GtkDialogFlags)(flags)

	c_type := (C.GtkMessageType)(type_)

	c_buttons := (C.GtkButtonsType)(buttons)

	goFormattedString := fmt.Sprintf(messageFormat, args...)
	c_message_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_message_format))

	retC := C._gtk_message_dialog_new(c_parent, c_flags, c_type, c_buttons, c_message_format)
	retGo := MessageDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// MessageDialogNewWithMarkup is a wrapper around the C function gtk_message_dialog_new_with_markup.
func MessageDialogNewWithMarkup(parent *Window, flags DialogFlags, type_ MessageType, buttons ButtonsType, messageFormat string, args ...interface{}) *MessageDialog {
	c_parent := (*C.GtkWindow)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWindow)(parent.ToC())
	}

	c_flags := (C.GtkDialogFlags)(flags)

	c_type := (C.GtkMessageType)(type_)

	c_buttons := (C.GtkButtonsType)(buttons)

	goFormattedString := fmt.Sprintf(messageFormat, args...)
	c_message_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_message_format))

	retC := C._gtk_message_dialog_new_with_markup(c_parent, c_flags, c_type, c_buttons, c_message_format)
	retGo := MessageDialogNewFromC(unsafe.Pointer(retC))

	return retGo
}

// FormatSecondaryMarkup is a wrapper around the C function gtk_message_dialog_format_secondary_markup.
func (recv *MessageDialog) FormatSecondaryMarkup(messageFormat string, args ...interface{}) {
	goFormattedString := fmt.Sprintf(messageFormat, args...)
	c_message_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_message_format))

	C._gtk_message_dialog_format_secondary_markup((*C.GtkMessageDialog)(recv.native), c_message_format)

	return
}

// FormatSecondaryText is a wrapper around the C function gtk_message_dialog_format_secondary_text.
func (recv *MessageDialog) FormatSecondaryText(messageFormat string, args ...interface{}) {
	goFormattedString := fmt.Sprintf(messageFormat, args...)
	c_message_format := C.CString(goFormattedString)
	defer C.free(unsafe.Pointer(c_message_format))

	C._gtk_message_dialog_format_secondary_text((*C.GtkMessageDialog)(recv.native), c_message_format)

	return
}

// SetImage is a wrapper around the C function gtk_message_dialog_set_image.
func (recv *MessageDialog) SetImage(image *Widget) {
	c_image := (*C.GtkWidget)(C.NULL)
	if image != nil {
		c_image = (*C.GtkWidget)(image.ToC())
	}

	C.gtk_message_dialog_set_image((*C.GtkMessageDialog)(recv.native), c_image)

	return
}

// SetMarkup is a wrapper around the C function gtk_message_dialog_set_markup.
func (recv *MessageDialog) SetMarkup(str string) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	C.gtk_message_dialog_set_markup((*C.GtkMessageDialog)(recv.native), c_str)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by MessageDialog
func (recv *MessageDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by MessageDialog
func (recv *MessageDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Misc is a wrapper around the C record GtkMisc.
type Misc struct {
	native *C.GtkMisc
	// widget : record
	// Private : priv
}

func MiscNewFromC(u unsafe.Pointer) *Misc {
	c := (*C.GtkMisc)(u)
	if c == nil {
		return nil
	}

	g := &Misc{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Misc) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Misc) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Misc with another Misc, and returns true if they represent the same GObject.
func (recv *Misc) Equals(other *Misc) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Misc) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Misc) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Misc) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Misc.
// Exercise care, as this is a potentially dangerous function if the Object is not a Misc.
func CastToMisc(object *gobject.Object) *Misc {
	return MiscNewFromC(object.ToC())
}

// GetAlignment is a wrapper around the C function gtk_misc_get_alignment.
func (recv *Misc) GetAlignment() (float32, float32) {
	var c_xalign C.gfloat

	var c_yalign C.gfloat

	C.gtk_misc_get_alignment((*C.GtkMisc)(recv.native), &c_xalign, &c_yalign)

	xalign := (float32)(c_xalign)

	yalign := (float32)(c_yalign)

	return xalign, yalign
}

// GetPadding is a wrapper around the C function gtk_misc_get_padding.
func (recv *Misc) GetPadding() (int32, int32) {
	var c_xpad C.gint

	var c_ypad C.gint

	C.gtk_misc_get_padding((*C.GtkMisc)(recv.native), &c_xpad, &c_ypad)

	xpad := (int32)(c_xpad)

	ypad := (int32)(c_ypad)

	return xpad, ypad
}

// SetAlignment is a wrapper around the C function gtk_misc_set_alignment.
func (recv *Misc) SetAlignment(xalign float32, yalign float32) {
	c_xalign := (C.gfloat)(xalign)

	c_yalign := (C.gfloat)(yalign)

	C.gtk_misc_set_alignment((*C.GtkMisc)(recv.native), c_xalign, c_yalign)

	return
}

// SetPadding is a wrapper around the C function gtk_misc_set_padding.
func (recv *Misc) SetPadding(xpad int32, ypad int32) {
	c_xpad := (C.gint)(xpad)

	c_ypad := (C.gint)(ypad)

	C.gtk_misc_set_padding((*C.GtkMisc)(recv.native), c_xpad, c_ypad)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Misc
func (recv *Misc) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Misc
func (recv *Misc) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ModelButton is a wrapper around the C record GtkModelButton.
type ModelButton struct {
	native *C.GtkModelButton
}

func ModelButtonNewFromC(u unsafe.Pointer) *ModelButton {
	c := (*C.GtkModelButton)(u)
	if c == nil {
		return nil
	}

	g := &ModelButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ModelButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ModelButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ModelButton with another ModelButton, and returns true if they represent the same GObject.
func (recv *ModelButton) Equals(other *ModelButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *ModelButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ModelButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ModelButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ModelButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ModelButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ModelButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to ModelButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ModelButton.
func CastToModelButton(object *gobject.Object) *ModelButton {
	return ModelButtonNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ModelButton
func (recv *ModelButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ModelButton
func (recv *ModelButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ModelButton
func (recv *ModelButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ModelButton
func (recv *ModelButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// MountOperation is a wrapper around the C record GtkMountOperation.
type MountOperation struct {
	native *C.GtkMountOperation
	// parent_instance : record
	// priv : record
}

func MountOperationNewFromC(u unsafe.Pointer) *MountOperation {
	c := (*C.GtkMountOperation)(u)
	if c == nil {
		return nil
	}

	g := &MountOperation{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *MountOperation) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *MountOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MountOperation with another MountOperation, and returns true if they represent the same GObject.
func (recv *MountOperation) Equals(other *MountOperation) bool {
	return other.ToC() == recv.ToC()
}

// MountOperation upcasts to *MountOperation
func (recv *MountOperation) MountOperation() *gio.MountOperation {
	return gio.MountOperationNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *MountOperation) Object() *gobject.Object {
	return recv.MountOperation().Object()
}

// CastToWidget down casts any arbitrary Object to MountOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a MountOperation.
func CastToMountOperation(object *gobject.Object) *MountOperation {
	return MountOperationNewFromC(object.ToC())
}

// Notebook is a wrapper around the C record GtkNotebook.
type Notebook struct {
	native *C.GtkNotebook
	// Private : container
	// Private : priv
}

func NotebookNewFromC(u unsafe.Pointer) *Notebook {
	c := (*C.GtkNotebook)(u)
	if c == nil {
		return nil
	}

	g := &Notebook{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Notebook) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Notebook) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Notebook with another Notebook, and returns true if they represent the same GObject.
func (recv *Notebook) Equals(other *Notebook) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Notebook) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Notebook) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Notebook) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Notebook) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Notebook.
// Exercise care, as this is a potentially dangerous function if the Object is not a Notebook.
func CastToNotebook(object *gobject.Object) *Notebook {
	return NotebookNewFromC(object.ToC())
}

type signalNotebookChangeCurrentPageDetail struct {
	callback  NotebookSignalChangeCurrentPageCallback
	handlerID C.gulong
}

var signalNotebookChangeCurrentPageId int
var signalNotebookChangeCurrentPageMap = make(map[int]signalNotebookChangeCurrentPageDetail)
var signalNotebookChangeCurrentPageLock sync.RWMutex

// NotebookSignalChangeCurrentPageCallback is a callback function for a 'change-current-page' signal emitted from a Notebook.
type NotebookSignalChangeCurrentPageCallback func(object int32) bool

/*
ConnectChangeCurrentPage connects the callback to the 'change-current-page' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectChangeCurrentPage to remove it.
*/
func (recv *Notebook) ConnectChangeCurrentPage(callback NotebookSignalChangeCurrentPageCallback) int {
	signalNotebookChangeCurrentPageLock.Lock()
	defer signalNotebookChangeCurrentPageLock.Unlock()

	signalNotebookChangeCurrentPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_change_current_page(instance, C.gpointer(uintptr(signalNotebookChangeCurrentPageId)))

	detail := signalNotebookChangeCurrentPageDetail{callback, handlerID}
	signalNotebookChangeCurrentPageMap[signalNotebookChangeCurrentPageId] = detail

	return signalNotebookChangeCurrentPageId
}

/*
DisconnectChangeCurrentPage disconnects a callback from the 'change-current-page' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectChangeCurrentPage.
*/
func (recv *Notebook) DisconnectChangeCurrentPage(connectionID int) {
	signalNotebookChangeCurrentPageLock.Lock()
	defer signalNotebookChangeCurrentPageLock.Unlock()

	detail, exists := signalNotebookChangeCurrentPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookChangeCurrentPageMap, connectionID)
}

//export notebook_changeCurrentPageHandler
func notebook_changeCurrentPageHandler(_ *C.GObject, c_object C.gint, data C.gpointer) C.gboolean {
	signalNotebookChangeCurrentPageLock.RLock()
	defer signalNotebookChangeCurrentPageLock.RUnlock()

	object := int32(c_object)

	index := int(uintptr(data))
	callback := signalNotebookChangeCurrentPageMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalNotebookCreateWindowDetail struct {
	callback  NotebookSignalCreateWindowCallback
	handlerID C.gulong
}

var signalNotebookCreateWindowId int
var signalNotebookCreateWindowMap = make(map[int]signalNotebookCreateWindowDetail)
var signalNotebookCreateWindowLock sync.RWMutex

// NotebookSignalCreateWindowCallback is a callback function for a 'create-window' signal emitted from a Notebook.
type NotebookSignalCreateWindowCallback func(page *Widget, x int32, y int32) Notebook

/*
ConnectCreateWindow connects the callback to the 'create-window' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectCreateWindow to remove it.
*/
func (recv *Notebook) ConnectCreateWindow(callback NotebookSignalCreateWindowCallback) int {
	signalNotebookCreateWindowLock.Lock()
	defer signalNotebookCreateWindowLock.Unlock()

	signalNotebookCreateWindowId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_create_window(instance, C.gpointer(uintptr(signalNotebookCreateWindowId)))

	detail := signalNotebookCreateWindowDetail{callback, handlerID}
	signalNotebookCreateWindowMap[signalNotebookCreateWindowId] = detail

	return signalNotebookCreateWindowId
}

/*
DisconnectCreateWindow disconnects a callback from the 'create-window' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectCreateWindow.
*/
func (recv *Notebook) DisconnectCreateWindow(connectionID int) {
	signalNotebookCreateWindowLock.Lock()
	defer signalNotebookCreateWindowLock.Unlock()

	detail, exists := signalNotebookCreateWindowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookCreateWindowMap, connectionID)
}

//export notebook_createWindowHandler
func notebook_createWindowHandler(_ *C.GObject, c_page *C.GtkWidget, c_x C.gint, c_y C.gint, data C.gpointer) *C.GtkNotebook {
	signalNotebookCreateWindowLock.RLock()
	defer signalNotebookCreateWindowLock.RUnlock()

	page := WidgetNewFromC(unsafe.Pointer(c_page))

	x := int32(c_x)

	y := int32(c_y)

	index := int(uintptr(data))
	callback := signalNotebookCreateWindowMap[index].callback
	retGo := callback(page, x, y)
	retC :=
		(*C.GtkNotebook)(retGo.ToC())
	return retC
}

type signalNotebookFocusTabDetail struct {
	callback  NotebookSignalFocusTabCallback
	handlerID C.gulong
}

var signalNotebookFocusTabId int
var signalNotebookFocusTabMap = make(map[int]signalNotebookFocusTabDetail)
var signalNotebookFocusTabLock sync.RWMutex

// NotebookSignalFocusTabCallback is a callback function for a 'focus-tab' signal emitted from a Notebook.
type NotebookSignalFocusTabCallback func(object NotebookTab) bool

/*
ConnectFocusTab connects the callback to the 'focus-tab' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectFocusTab to remove it.
*/
func (recv *Notebook) ConnectFocusTab(callback NotebookSignalFocusTabCallback) int {
	signalNotebookFocusTabLock.Lock()
	defer signalNotebookFocusTabLock.Unlock()

	signalNotebookFocusTabId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_focus_tab(instance, C.gpointer(uintptr(signalNotebookFocusTabId)))

	detail := signalNotebookFocusTabDetail{callback, handlerID}
	signalNotebookFocusTabMap[signalNotebookFocusTabId] = detail

	return signalNotebookFocusTabId
}

/*
DisconnectFocusTab disconnects a callback from the 'focus-tab' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectFocusTab.
*/
func (recv *Notebook) DisconnectFocusTab(connectionID int) {
	signalNotebookFocusTabLock.Lock()
	defer signalNotebookFocusTabLock.Unlock()

	detail, exists := signalNotebookFocusTabMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookFocusTabMap, connectionID)
}

//export notebook_focusTabHandler
func notebook_focusTabHandler(_ *C.GObject, c_object C.GtkNotebookTab, data C.gpointer) C.gboolean {
	signalNotebookFocusTabLock.RLock()
	defer signalNotebookFocusTabLock.RUnlock()

	object := NotebookTab(c_object)

	index := int(uintptr(data))
	callback := signalNotebookFocusTabMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalNotebookMoveFocusOutDetail struct {
	callback  NotebookSignalMoveFocusOutCallback
	handlerID C.gulong
}

var signalNotebookMoveFocusOutId int
var signalNotebookMoveFocusOutMap = make(map[int]signalNotebookMoveFocusOutDetail)
var signalNotebookMoveFocusOutLock sync.RWMutex

// NotebookSignalMoveFocusOutCallback is a callback function for a 'move-focus-out' signal emitted from a Notebook.
type NotebookSignalMoveFocusOutCallback func(object DirectionType)

/*
ConnectMoveFocusOut connects the callback to the 'move-focus-out' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectMoveFocusOut to remove it.
*/
func (recv *Notebook) ConnectMoveFocusOut(callback NotebookSignalMoveFocusOutCallback) int {
	signalNotebookMoveFocusOutLock.Lock()
	defer signalNotebookMoveFocusOutLock.Unlock()

	signalNotebookMoveFocusOutId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_move_focus_out(instance, C.gpointer(uintptr(signalNotebookMoveFocusOutId)))

	detail := signalNotebookMoveFocusOutDetail{callback, handlerID}
	signalNotebookMoveFocusOutMap[signalNotebookMoveFocusOutId] = detail

	return signalNotebookMoveFocusOutId
}

/*
DisconnectMoveFocusOut disconnects a callback from the 'move-focus-out' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectMoveFocusOut.
*/
func (recv *Notebook) DisconnectMoveFocusOut(connectionID int) {
	signalNotebookMoveFocusOutLock.Lock()
	defer signalNotebookMoveFocusOutLock.Unlock()

	detail, exists := signalNotebookMoveFocusOutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookMoveFocusOutMap, connectionID)
}

//export notebook_moveFocusOutHandler
func notebook_moveFocusOutHandler(_ *C.GObject, c_object C.GtkDirectionType, data C.gpointer) {
	signalNotebookMoveFocusOutLock.RLock()
	defer signalNotebookMoveFocusOutLock.RUnlock()

	object := DirectionType(c_object)

	index := int(uintptr(data))
	callback := signalNotebookMoveFocusOutMap[index].callback
	callback(object)
}

type signalNotebookPageAddedDetail struct {
	callback  NotebookSignalPageAddedCallback
	handlerID C.gulong
}

var signalNotebookPageAddedId int
var signalNotebookPageAddedMap = make(map[int]signalNotebookPageAddedDetail)
var signalNotebookPageAddedLock sync.RWMutex

// NotebookSignalPageAddedCallback is a callback function for a 'page-added' signal emitted from a Notebook.
type NotebookSignalPageAddedCallback func(child *Widget, pageNum uint32)

/*
ConnectPageAdded connects the callback to the 'page-added' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectPageAdded to remove it.
*/
func (recv *Notebook) ConnectPageAdded(callback NotebookSignalPageAddedCallback) int {
	signalNotebookPageAddedLock.Lock()
	defer signalNotebookPageAddedLock.Unlock()

	signalNotebookPageAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_page_added(instance, C.gpointer(uintptr(signalNotebookPageAddedId)))

	detail := signalNotebookPageAddedDetail{callback, handlerID}
	signalNotebookPageAddedMap[signalNotebookPageAddedId] = detail

	return signalNotebookPageAddedId
}

/*
DisconnectPageAdded disconnects a callback from the 'page-added' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectPageAdded.
*/
func (recv *Notebook) DisconnectPageAdded(connectionID int) {
	signalNotebookPageAddedLock.Lock()
	defer signalNotebookPageAddedLock.Unlock()

	detail, exists := signalNotebookPageAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookPageAddedMap, connectionID)
}

//export notebook_pageAddedHandler
func notebook_pageAddedHandler(_ *C.GObject, c_child *C.GtkWidget, c_page_num C.guint, data C.gpointer) {
	signalNotebookPageAddedLock.RLock()
	defer signalNotebookPageAddedLock.RUnlock()

	child := WidgetNewFromC(unsafe.Pointer(c_child))

	pageNum := uint32(c_page_num)

	index := int(uintptr(data))
	callback := signalNotebookPageAddedMap[index].callback
	callback(child, pageNum)
}

type signalNotebookPageRemovedDetail struct {
	callback  NotebookSignalPageRemovedCallback
	handlerID C.gulong
}

var signalNotebookPageRemovedId int
var signalNotebookPageRemovedMap = make(map[int]signalNotebookPageRemovedDetail)
var signalNotebookPageRemovedLock sync.RWMutex

// NotebookSignalPageRemovedCallback is a callback function for a 'page-removed' signal emitted from a Notebook.
type NotebookSignalPageRemovedCallback func(child *Widget, pageNum uint32)

/*
ConnectPageRemoved connects the callback to the 'page-removed' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectPageRemoved to remove it.
*/
func (recv *Notebook) ConnectPageRemoved(callback NotebookSignalPageRemovedCallback) int {
	signalNotebookPageRemovedLock.Lock()
	defer signalNotebookPageRemovedLock.Unlock()

	signalNotebookPageRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_page_removed(instance, C.gpointer(uintptr(signalNotebookPageRemovedId)))

	detail := signalNotebookPageRemovedDetail{callback, handlerID}
	signalNotebookPageRemovedMap[signalNotebookPageRemovedId] = detail

	return signalNotebookPageRemovedId
}

/*
DisconnectPageRemoved disconnects a callback from the 'page-removed' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectPageRemoved.
*/
func (recv *Notebook) DisconnectPageRemoved(connectionID int) {
	signalNotebookPageRemovedLock.Lock()
	defer signalNotebookPageRemovedLock.Unlock()

	detail, exists := signalNotebookPageRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookPageRemovedMap, connectionID)
}

//export notebook_pageRemovedHandler
func notebook_pageRemovedHandler(_ *C.GObject, c_child *C.GtkWidget, c_page_num C.guint, data C.gpointer) {
	signalNotebookPageRemovedLock.RLock()
	defer signalNotebookPageRemovedLock.RUnlock()

	child := WidgetNewFromC(unsafe.Pointer(c_child))

	pageNum := uint32(c_page_num)

	index := int(uintptr(data))
	callback := signalNotebookPageRemovedMap[index].callback
	callback(child, pageNum)
}

type signalNotebookPageReorderedDetail struct {
	callback  NotebookSignalPageReorderedCallback
	handlerID C.gulong
}

var signalNotebookPageReorderedId int
var signalNotebookPageReorderedMap = make(map[int]signalNotebookPageReorderedDetail)
var signalNotebookPageReorderedLock sync.RWMutex

// NotebookSignalPageReorderedCallback is a callback function for a 'page-reordered' signal emitted from a Notebook.
type NotebookSignalPageReorderedCallback func(child *Widget, pageNum uint32)

/*
ConnectPageReordered connects the callback to the 'page-reordered' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectPageReordered to remove it.
*/
func (recv *Notebook) ConnectPageReordered(callback NotebookSignalPageReorderedCallback) int {
	signalNotebookPageReorderedLock.Lock()
	defer signalNotebookPageReorderedLock.Unlock()

	signalNotebookPageReorderedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_page_reordered(instance, C.gpointer(uintptr(signalNotebookPageReorderedId)))

	detail := signalNotebookPageReorderedDetail{callback, handlerID}
	signalNotebookPageReorderedMap[signalNotebookPageReorderedId] = detail

	return signalNotebookPageReorderedId
}

/*
DisconnectPageReordered disconnects a callback from the 'page-reordered' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectPageReordered.
*/
func (recv *Notebook) DisconnectPageReordered(connectionID int) {
	signalNotebookPageReorderedLock.Lock()
	defer signalNotebookPageReorderedLock.Unlock()

	detail, exists := signalNotebookPageReorderedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookPageReorderedMap, connectionID)
}

//export notebook_pageReorderedHandler
func notebook_pageReorderedHandler(_ *C.GObject, c_child *C.GtkWidget, c_page_num C.guint, data C.gpointer) {
	signalNotebookPageReorderedLock.RLock()
	defer signalNotebookPageReorderedLock.RUnlock()

	child := WidgetNewFromC(unsafe.Pointer(c_child))

	pageNum := uint32(c_page_num)

	index := int(uintptr(data))
	callback := signalNotebookPageReorderedMap[index].callback
	callback(child, pageNum)
}

type signalNotebookReorderTabDetail struct {
	callback  NotebookSignalReorderTabCallback
	handlerID C.gulong
}

var signalNotebookReorderTabId int
var signalNotebookReorderTabMap = make(map[int]signalNotebookReorderTabDetail)
var signalNotebookReorderTabLock sync.RWMutex

// NotebookSignalReorderTabCallback is a callback function for a 'reorder-tab' signal emitted from a Notebook.
type NotebookSignalReorderTabCallback func(object DirectionType, p0 bool) bool

/*
ConnectReorderTab connects the callback to the 'reorder-tab' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectReorderTab to remove it.
*/
func (recv *Notebook) ConnectReorderTab(callback NotebookSignalReorderTabCallback) int {
	signalNotebookReorderTabLock.Lock()
	defer signalNotebookReorderTabLock.Unlock()

	signalNotebookReorderTabId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_reorder_tab(instance, C.gpointer(uintptr(signalNotebookReorderTabId)))

	detail := signalNotebookReorderTabDetail{callback, handlerID}
	signalNotebookReorderTabMap[signalNotebookReorderTabId] = detail

	return signalNotebookReorderTabId
}

/*
DisconnectReorderTab disconnects a callback from the 'reorder-tab' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectReorderTab.
*/
func (recv *Notebook) DisconnectReorderTab(connectionID int) {
	signalNotebookReorderTabLock.Lock()
	defer signalNotebookReorderTabLock.Unlock()

	detail, exists := signalNotebookReorderTabMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookReorderTabMap, connectionID)
}

//export notebook_reorderTabHandler
func notebook_reorderTabHandler(_ *C.GObject, c_object C.GtkDirectionType, c_p0 C.gboolean, data C.gpointer) C.gboolean {
	signalNotebookReorderTabLock.RLock()
	defer signalNotebookReorderTabLock.RUnlock()

	object := DirectionType(c_object)

	p0 := c_p0 == C.TRUE

	index := int(uintptr(data))
	callback := signalNotebookReorderTabMap[index].callback
	retGo := callback(object, p0)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalNotebookSelectPageDetail struct {
	callback  NotebookSignalSelectPageCallback
	handlerID C.gulong
}

var signalNotebookSelectPageId int
var signalNotebookSelectPageMap = make(map[int]signalNotebookSelectPageDetail)
var signalNotebookSelectPageLock sync.RWMutex

// NotebookSignalSelectPageCallback is a callback function for a 'select-page' signal emitted from a Notebook.
type NotebookSignalSelectPageCallback func(object bool) bool

/*
ConnectSelectPage connects the callback to the 'select-page' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectSelectPage to remove it.
*/
func (recv *Notebook) ConnectSelectPage(callback NotebookSignalSelectPageCallback) int {
	signalNotebookSelectPageLock.Lock()
	defer signalNotebookSelectPageLock.Unlock()

	signalNotebookSelectPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_select_page(instance, C.gpointer(uintptr(signalNotebookSelectPageId)))

	detail := signalNotebookSelectPageDetail{callback, handlerID}
	signalNotebookSelectPageMap[signalNotebookSelectPageId] = detail

	return signalNotebookSelectPageId
}

/*
DisconnectSelectPage disconnects a callback from the 'select-page' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectSelectPage.
*/
func (recv *Notebook) DisconnectSelectPage(connectionID int) {
	signalNotebookSelectPageLock.Lock()
	defer signalNotebookSelectPageLock.Unlock()

	detail, exists := signalNotebookSelectPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookSelectPageMap, connectionID)
}

//export notebook_selectPageHandler
func notebook_selectPageHandler(_ *C.GObject, c_object C.gboolean, data C.gpointer) C.gboolean {
	signalNotebookSelectPageLock.RLock()
	defer signalNotebookSelectPageLock.RUnlock()

	object := c_object == C.TRUE

	index := int(uintptr(data))
	callback := signalNotebookSelectPageMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalNotebookSwitchPageDetail struct {
	callback  NotebookSignalSwitchPageCallback
	handlerID C.gulong
}

var signalNotebookSwitchPageId int
var signalNotebookSwitchPageMap = make(map[int]signalNotebookSwitchPageDetail)
var signalNotebookSwitchPageLock sync.RWMutex

// NotebookSignalSwitchPageCallback is a callback function for a 'switch-page' signal emitted from a Notebook.
type NotebookSignalSwitchPageCallback func(page *Widget, pageNum uint32)

/*
ConnectSwitchPage connects the callback to the 'switch-page' signal for the Notebook.

The returned value represents the connection, and may be passed to DisconnectSwitchPage to remove it.
*/
func (recv *Notebook) ConnectSwitchPage(callback NotebookSignalSwitchPageCallback) int {
	signalNotebookSwitchPageLock.Lock()
	defer signalNotebookSwitchPageLock.Unlock()

	signalNotebookSwitchPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.Notebook_signal_connect_switch_page(instance, C.gpointer(uintptr(signalNotebookSwitchPageId)))

	detail := signalNotebookSwitchPageDetail{callback, handlerID}
	signalNotebookSwitchPageMap[signalNotebookSwitchPageId] = detail

	return signalNotebookSwitchPageId
}

/*
DisconnectSwitchPage disconnects a callback from the 'switch-page' signal for the Notebook.

The connectionID should be a value returned from a call to ConnectSwitchPage.
*/
func (recv *Notebook) DisconnectSwitchPage(connectionID int) {
	signalNotebookSwitchPageLock.Lock()
	defer signalNotebookSwitchPageLock.Unlock()

	detail, exists := signalNotebookSwitchPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalNotebookSwitchPageMap, connectionID)
}

//export notebook_switchPageHandler
func notebook_switchPageHandler(_ *C.GObject, c_page *C.GtkWidget, c_page_num C.guint, data C.gpointer) {
	signalNotebookSwitchPageLock.RLock()
	defer signalNotebookSwitchPageLock.RUnlock()

	page := WidgetNewFromC(unsafe.Pointer(c_page))

	pageNum := uint32(c_page_num)

	index := int(uintptr(data))
	callback := signalNotebookSwitchPageMap[index].callback
	callback(page, pageNum)
}

// NotebookNew is a wrapper around the C function gtk_notebook_new.
func NotebookNew() *Notebook {
	retC := C.gtk_notebook_new()
	retGo := NotebookNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppendPage is a wrapper around the C function gtk_notebook_append_page.
func (recv *Notebook) AppendPage(child *Widget, tabLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	retC := C.gtk_notebook_append_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label)
	retGo := (int32)(retC)

	return retGo
}

// AppendPageMenu is a wrapper around the C function gtk_notebook_append_page_menu.
func (recv *Notebook) AppendPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	retC := C.gtk_notebook_append_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label)
	retGo := (int32)(retC)

	return retGo
}

// GetCurrentPage is a wrapper around the C function gtk_notebook_get_current_page.
func (recv *Notebook) GetCurrentPage() int32 {
	retC := C.gtk_notebook_get_current_page((*C.GtkNotebook)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMenuLabel is a wrapper around the C function gtk_notebook_get_menu_label.
func (recv *Notebook) GetMenuLabel(child *Widget) *Widget {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_menu_label((*C.GtkNotebook)(recv.native), c_child)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetMenuLabelText is a wrapper around the C function gtk_notebook_get_menu_label_text.
func (recv *Notebook) GetMenuLabelText(child *Widget) string {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_menu_label_text((*C.GtkNotebook)(recv.native), c_child)
	retGo := C.GoString(retC)

	return retGo
}

// GetNPages is a wrapper around the C function gtk_notebook_get_n_pages.
func (recv *Notebook) GetNPages() int32 {
	retC := C.gtk_notebook_get_n_pages((*C.GtkNotebook)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetNthPage is a wrapper around the C function gtk_notebook_get_nth_page.
func (recv *Notebook) GetNthPage(pageNum int32) *Widget {
	c_page_num := (C.gint)(pageNum)

	retC := C.gtk_notebook_get_nth_page((*C.GtkNotebook)(recv.native), c_page_num)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetScrollable is a wrapper around the C function gtk_notebook_get_scrollable.
func (recv *Notebook) GetScrollable() bool {
	retC := C.gtk_notebook_get_scrollable((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowBorder is a wrapper around the C function gtk_notebook_get_show_border.
func (recv *Notebook) GetShowBorder() bool {
	retC := C.gtk_notebook_get_show_border((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowTabs is a wrapper around the C function gtk_notebook_get_show_tabs.
func (recv *Notebook) GetShowTabs() bool {
	retC := C.gtk_notebook_get_show_tabs((*C.GtkNotebook)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTabDetachable is a wrapper around the C function gtk_notebook_get_tab_detachable.
func (recv *Notebook) GetTabDetachable(child *Widget) bool {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_tab_detachable((*C.GtkNotebook)(recv.native), c_child)
	retGo := retC == C.TRUE

	return retGo
}

// GetTabLabel is a wrapper around the C function gtk_notebook_get_tab_label.
func (recv *Notebook) GetTabLabel(child *Widget) *Widget {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_tab_label((*C.GtkNotebook)(recv.native), c_child)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetTabLabelText is a wrapper around the C function gtk_notebook_get_tab_label_text.
func (recv *Notebook) GetTabLabelText(child *Widget) string {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_tab_label_text((*C.GtkNotebook)(recv.native), c_child)
	retGo := C.GoString(retC)

	return retGo
}

// GetTabPos is a wrapper around the C function gtk_notebook_get_tab_pos.
func (recv *Notebook) GetTabPos() PositionType {
	retC := C.gtk_notebook_get_tab_pos((*C.GtkNotebook)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// GetTabReorderable is a wrapper around the C function gtk_notebook_get_tab_reorderable.
func (recv *Notebook) GetTabReorderable(child *Widget) bool {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_get_tab_reorderable((*C.GtkNotebook)(recv.native), c_child)
	retGo := retC == C.TRUE

	return retGo
}

// InsertPage is a wrapper around the C function gtk_notebook_insert_page.
func (recv *Notebook) InsertPage(child *Widget, tabLabel *Widget, position int32) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_notebook_insert_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_position)
	retGo := (int32)(retC)

	return retGo
}

// InsertPageMenu is a wrapper around the C function gtk_notebook_insert_page_menu.
func (recv *Notebook) InsertPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget, position int32) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_notebook_insert_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label, c_position)
	retGo := (int32)(retC)

	return retGo
}

// NextPage is a wrapper around the C function gtk_notebook_next_page.
func (recv *Notebook) NextPage() {
	C.gtk_notebook_next_page((*C.GtkNotebook)(recv.native))

	return
}

// PageNum is a wrapper around the C function gtk_notebook_page_num.
func (recv *Notebook) PageNum(child *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_page_num((*C.GtkNotebook)(recv.native), c_child)
	retGo := (int32)(retC)

	return retGo
}

// PopupDisable is a wrapper around the C function gtk_notebook_popup_disable.
func (recv *Notebook) PopupDisable() {
	C.gtk_notebook_popup_disable((*C.GtkNotebook)(recv.native))

	return
}

// PopupEnable is a wrapper around the C function gtk_notebook_popup_enable.
func (recv *Notebook) PopupEnable() {
	C.gtk_notebook_popup_enable((*C.GtkNotebook)(recv.native))

	return
}

// PrependPage is a wrapper around the C function gtk_notebook_prepend_page.
func (recv *Notebook) PrependPage(child *Widget, tabLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	retC := C.gtk_notebook_prepend_page((*C.GtkNotebook)(recv.native), c_child, c_tab_label)
	retGo := (int32)(retC)

	return retGo
}

// PrependPageMenu is a wrapper around the C function gtk_notebook_prepend_page_menu.
func (recv *Notebook) PrependPageMenu(child *Widget, tabLabel *Widget, menuLabel *Widget) int32 {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	retC := C.gtk_notebook_prepend_page_menu((*C.GtkNotebook)(recv.native), c_child, c_tab_label, c_menu_label)
	retGo := (int32)(retC)

	return retGo
}

// PrevPage is a wrapper around the C function gtk_notebook_prev_page.
func (recv *Notebook) PrevPage() {
	C.gtk_notebook_prev_page((*C.GtkNotebook)(recv.native))

	return
}

// RemovePage is a wrapper around the C function gtk_notebook_remove_page.
func (recv *Notebook) RemovePage(pageNum int32) {
	c_page_num := (C.gint)(pageNum)

	C.gtk_notebook_remove_page((*C.GtkNotebook)(recv.native), c_page_num)

	return
}

// ReorderChild is a wrapper around the C function gtk_notebook_reorder_child.
func (recv *Notebook) ReorderChild(child *Widget, position int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_notebook_reorder_child((*C.GtkNotebook)(recv.native), c_child, c_position)

	return
}

// SetCurrentPage is a wrapper around the C function gtk_notebook_set_current_page.
func (recv *Notebook) SetCurrentPage(pageNum int32) {
	c_page_num := (C.gint)(pageNum)

	C.gtk_notebook_set_current_page((*C.GtkNotebook)(recv.native), c_page_num)

	return
}

// SetMenuLabel is a wrapper around the C function gtk_notebook_set_menu_label.
func (recv *Notebook) SetMenuLabel(child *Widget, menuLabel *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_menu_label := (*C.GtkWidget)(C.NULL)
	if menuLabel != nil {
		c_menu_label = (*C.GtkWidget)(menuLabel.ToC())
	}

	C.gtk_notebook_set_menu_label((*C.GtkNotebook)(recv.native), c_child, c_menu_label)

	return
}

// SetMenuLabelText is a wrapper around the C function gtk_notebook_set_menu_label_text.
func (recv *Notebook) SetMenuLabelText(child *Widget, menuText string) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_menu_text := C.CString(menuText)
	defer C.free(unsafe.Pointer(c_menu_text))

	C.gtk_notebook_set_menu_label_text((*C.GtkNotebook)(recv.native), c_child, c_menu_text)

	return
}

// SetScrollable is a wrapper around the C function gtk_notebook_set_scrollable.
func (recv *Notebook) SetScrollable(scrollable bool) {
	c_scrollable :=
		boolToGboolean(scrollable)

	C.gtk_notebook_set_scrollable((*C.GtkNotebook)(recv.native), c_scrollable)

	return
}

// SetShowBorder is a wrapper around the C function gtk_notebook_set_show_border.
func (recv *Notebook) SetShowBorder(showBorder bool) {
	c_show_border :=
		boolToGboolean(showBorder)

	C.gtk_notebook_set_show_border((*C.GtkNotebook)(recv.native), c_show_border)

	return
}

// SetShowTabs is a wrapper around the C function gtk_notebook_set_show_tabs.
func (recv *Notebook) SetShowTabs(showTabs bool) {
	c_show_tabs :=
		boolToGboolean(showTabs)

	C.gtk_notebook_set_show_tabs((*C.GtkNotebook)(recv.native), c_show_tabs)

	return
}

// SetTabDetachable is a wrapper around the C function gtk_notebook_set_tab_detachable.
func (recv *Notebook) SetTabDetachable(child *Widget, detachable bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_detachable :=
		boolToGboolean(detachable)

	C.gtk_notebook_set_tab_detachable((*C.GtkNotebook)(recv.native), c_child, c_detachable)

	return
}

// SetTabLabel is a wrapper around the C function gtk_notebook_set_tab_label.
func (recv *Notebook) SetTabLabel(child *Widget, tabLabel *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_label := (*C.GtkWidget)(C.NULL)
	if tabLabel != nil {
		c_tab_label = (*C.GtkWidget)(tabLabel.ToC())
	}

	C.gtk_notebook_set_tab_label((*C.GtkNotebook)(recv.native), c_child, c_tab_label)

	return
}

// SetTabLabelText is a wrapper around the C function gtk_notebook_set_tab_label_text.
func (recv *Notebook) SetTabLabelText(child *Widget, tabText string) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_tab_text := C.CString(tabText)
	defer C.free(unsafe.Pointer(c_tab_text))

	C.gtk_notebook_set_tab_label_text((*C.GtkNotebook)(recv.native), c_child, c_tab_text)

	return
}

// SetTabPos is a wrapper around the C function gtk_notebook_set_tab_pos.
func (recv *Notebook) SetTabPos(pos PositionType) {
	c_pos := (C.GtkPositionType)(pos)

	C.gtk_notebook_set_tab_pos((*C.GtkNotebook)(recv.native), c_pos)

	return
}

// SetTabReorderable is a wrapper around the C function gtk_notebook_set_tab_reorderable.
func (recv *Notebook) SetTabReorderable(child *Widget, reorderable bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_reorderable :=
		boolToGboolean(reorderable)

	C.gtk_notebook_set_tab_reorderable((*C.GtkNotebook)(recv.native), c_child, c_reorderable)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Notebook
func (recv *Notebook) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Notebook
func (recv *Notebook) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// NotebookAccessible is a wrapper around the C record GtkNotebookAccessible.
type NotebookAccessible struct {
	native *C.GtkNotebookAccessible
	// parent : record
	// priv : record
}

func NotebookAccessibleNewFromC(u unsafe.Pointer) *NotebookAccessible {
	c := (*C.GtkNotebookAccessible)(u)
	if c == nil {
		return nil
	}

	g := &NotebookAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NotebookAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NotebookAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookAccessible with another NotebookAccessible, and returns true if they represent the same GObject.
func (recv *NotebookAccessible) Equals(other *NotebookAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *NotebookAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *NotebookAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *NotebookAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *NotebookAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to NotebookAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a NotebookAccessible.
func CastToNotebookAccessible(object *gobject.Object) *NotebookAccessible {
	return NotebookAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by NotebookAccessible
func (recv *NotebookAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by NotebookAccessible
func (recv *NotebookAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// NotebookPageAccessible is a wrapper around the C record GtkNotebookPageAccessible.
type NotebookPageAccessible struct {
	native *C.GtkNotebookPageAccessible
	// parent : record
	// priv : record
}

func NotebookPageAccessibleNewFromC(u unsafe.Pointer) *NotebookPageAccessible {
	c := (*C.GtkNotebookPageAccessible)(u)
	if c == nil {
		return nil
	}

	g := &NotebookPageAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NotebookPageAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NotebookPageAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookPageAccessible with another NotebookPageAccessible, and returns true if they represent the same GObject.
func (recv *NotebookPageAccessible) Equals(other *NotebookPageAccessible) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *NotebookPageAccessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to NotebookPageAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a NotebookPageAccessible.
func CastToNotebookPageAccessible(object *gobject.Object) *NotebookPageAccessible {
	return NotebookPageAccessibleNewFromC(object.ToC())
}

// NotebookPageAccessibleNew is a wrapper around the C function gtk_notebook_page_accessible_new.
func NotebookPageAccessibleNew(notebook *NotebookAccessible, child *Widget) *NotebookPageAccessible {
	c_notebook := (*C.GtkNotebookAccessible)(C.NULL)
	if notebook != nil {
		c_notebook = (*C.GtkNotebookAccessible)(notebook.ToC())
	}

	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	retC := C.gtk_notebook_page_accessible_new(c_notebook, c_child)
	retGo := NotebookPageAccessibleNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Invalidate is a wrapper around the C function gtk_notebook_page_accessible_invalidate.
func (recv *NotebookPageAccessible) Invalidate() {
	C.gtk_notebook_page_accessible_invalidate((*C.GtkNotebookPageAccessible)(recv.native))

	return
}

// Component returns the Component interface implemented by NotebookPageAccessible
func (recv *NotebookPageAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// NumerableIcon is a wrapper around the C record GtkNumerableIcon.
type NumerableIcon struct {
	native *C.GtkNumerableIcon
	// parent : record
	// Private : priv
}

func NumerableIconNewFromC(u unsafe.Pointer) *NumerableIcon {
	c := (*C.GtkNumerableIcon)(u)
	if c == nil {
		return nil
	}

	g := &NumerableIcon{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *NumerableIcon) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *NumerableIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NumerableIcon with another NumerableIcon, and returns true if they represent the same GObject.
func (recv *NumerableIcon) Equals(other *NumerableIcon) bool {
	return other.ToC() == recv.ToC()
}

// EmblemedIcon upcasts to *EmblemedIcon
func (recv *NumerableIcon) EmblemedIcon() *gio.EmblemedIcon {
	return gio.EmblemedIconNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *NumerableIcon) Object() *gobject.Object {
	return recv.EmblemedIcon().Object()
}

// CastToWidget down casts any arbitrary Object to NumerableIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a NumerableIcon.
func CastToNumerableIcon(object *gobject.Object) *NumerableIcon {
	return NumerableIconNewFromC(object.ToC())
}

// Icon returns the Icon interface implemented by NumerableIcon
func (recv *NumerableIcon) Icon() *gio.Icon {
	return gio.IconNewFromC(recv.ToC())
}

// OffscreenWindow is a wrapper around the C record GtkOffscreenWindow.
type OffscreenWindow struct {
	native *C.GtkOffscreenWindow
	// parent_object : record
}

func OffscreenWindowNewFromC(u unsafe.Pointer) *OffscreenWindow {
	c := (*C.GtkOffscreenWindow)(u)
	if c == nil {
		return nil
	}

	g := &OffscreenWindow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *OffscreenWindow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *OffscreenWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OffscreenWindow with another OffscreenWindow, and returns true if they represent the same GObject.
func (recv *OffscreenWindow) Equals(other *OffscreenWindow) bool {
	return other.ToC() == recv.ToC()
}

// Window upcasts to *Window
func (recv *OffscreenWindow) Window() *Window {
	return WindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *OffscreenWindow) Bin() *Bin {
	return recv.Window().Bin()
}

// Container upcasts to *Container
func (recv *OffscreenWindow) Container() *Container {
	return recv.Window().Container()
}

// Widget upcasts to *Widget
func (recv *OffscreenWindow) Widget() *Widget {
	return recv.Window().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *OffscreenWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Window().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *OffscreenWindow) Object() *gobject.Object {
	return recv.Window().Object()
}

// CastToWidget down casts any arbitrary Object to OffscreenWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a OffscreenWindow.
func CastToOffscreenWindow(object *gobject.Object) *OffscreenWindow {
	return OffscreenWindowNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by OffscreenWindow
func (recv *OffscreenWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by OffscreenWindow
func (recv *OffscreenWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Overlay is a wrapper around the C record GtkOverlay.
type Overlay struct {
	native *C.GtkOverlay
	// parent : record
	// priv : record
}

func OverlayNewFromC(u unsafe.Pointer) *Overlay {
	c := (*C.GtkOverlay)(u)
	if c == nil {
		return nil
	}

	g := &Overlay{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Overlay) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Overlay) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Overlay with another Overlay, and returns true if they represent the same GObject.
func (recv *Overlay) Equals(other *Overlay) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Overlay) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Overlay) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Overlay) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Overlay) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Overlay) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Overlay.
// Exercise care, as this is a potentially dangerous function if the Object is not a Overlay.
func CastToOverlay(object *gobject.Object) *Overlay {
	return OverlayNewFromC(object.ToC())
}

// Unsupported signal 'get-child-position' for Overlay : unsupported parameter allocation : direction is 'out'

// ImplementorIface returns the ImplementorIface interface implemented by Overlay
func (recv *Overlay) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Overlay
func (recv *Overlay) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PageSetup is a wrapper around the C record GtkPageSetup.
type PageSetup struct {
	native *C.GtkPageSetup
}

func PageSetupNewFromC(u unsafe.Pointer) *PageSetup {
	c := (*C.GtkPageSetup)(u)
	if c == nil {
		return nil
	}

	g := &PageSetup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PageSetup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PageSetup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PageSetup with another PageSetup, and returns true if they represent the same GObject.
func (recv *PageSetup) Equals(other *PageSetup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *PageSetup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to PageSetup.
// Exercise care, as this is a potentially dangerous function if the Object is not a PageSetup.
func CastToPageSetup(object *gobject.Object) *PageSetup {
	return PageSetupNewFromC(object.ToC())
}

// PageSetupNew is a wrapper around the C function gtk_page_setup_new.
func PageSetupNew() *PageSetup {
	retC := C.gtk_page_setup_new()
	retGo := PageSetupNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// PageSetupNewFromFile is a wrapper around the C function gtk_page_setup_new_from_file.
func PageSetupNewFromFile(fileName string) (*PageSetup, error) {
	c_file_name := C.CString(fileName)
	defer C.free(unsafe.Pointer(c_file_name))

	var cThrowableError *C.GError

	retC := C.gtk_page_setup_new_from_file(c_file_name, &cThrowableError)
	retGo := PageSetupNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PageSetupNewFromKeyFile is a wrapper around the C function gtk_page_setup_new_from_key_file.
func PageSetupNewFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PageSetup, error) {
	c_key_file := (*C.GKeyFile)(C.NULL)
	if keyFile != nil {
		c_key_file = (*C.GKeyFile)(keyFile.ToC())
	}

	c_group_name := C.CString(groupName)
	defer C.free(unsafe.Pointer(c_group_name))

	var cThrowableError *C.GError

	retC := C.gtk_page_setup_new_from_key_file(c_key_file, c_group_name, &cThrowableError)
	retGo := PageSetupNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Copy is a wrapper around the C function gtk_page_setup_copy.
func (recv *PageSetup) Copy() *PageSetup {
	retC := C.gtk_page_setup_copy((*C.GtkPageSetup)(recv.native))
	retGo := PageSetupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetBottomMargin is a wrapper around the C function gtk_page_setup_get_bottom_margin.
func (recv *PageSetup) GetBottomMargin(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_page_setup_get_bottom_margin((*C.GtkPageSetup)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetLeftMargin is a wrapper around the C function gtk_page_setup_get_left_margin.
func (recv *PageSetup) GetLeftMargin(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_page_setup_get_left_margin((*C.GtkPageSetup)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetOrientation is a wrapper around the C function gtk_page_setup_get_orientation.
func (recv *PageSetup) GetOrientation() PageOrientation {
	retC := C.gtk_page_setup_get_orientation((*C.GtkPageSetup)(recv.native))
	retGo := (PageOrientation)(retC)

	return retGo
}

// GetPageHeight is a wrapper around the C function gtk_page_setup_get_page_height.
func (recv *PageSetup) GetPageHeight(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_page_setup_get_page_height((*C.GtkPageSetup)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetPageWidth is a wrapper around the C function gtk_page_setup_get_page_width.
func (recv *PageSetup) GetPageWidth(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_page_setup_get_page_width((*C.GtkPageSetup)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetPaperHeight is a wrapper around the C function gtk_page_setup_get_paper_height.
func (recv *PageSetup) GetPaperHeight(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_page_setup_get_paper_height((*C.GtkPageSetup)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetPaperSize is a wrapper around the C function gtk_page_setup_get_paper_size.
func (recv *PageSetup) GetPaperSize() *PaperSize {
	retC := C.gtk_page_setup_get_paper_size((*C.GtkPageSetup)(recv.native))
	retGo := PaperSizeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPaperWidth is a wrapper around the C function gtk_page_setup_get_paper_width.
func (recv *PageSetup) GetPaperWidth(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_page_setup_get_paper_width((*C.GtkPageSetup)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetRightMargin is a wrapper around the C function gtk_page_setup_get_right_margin.
func (recv *PageSetup) GetRightMargin(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_page_setup_get_right_margin((*C.GtkPageSetup)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetTopMargin is a wrapper around the C function gtk_page_setup_get_top_margin.
func (recv *PageSetup) GetTopMargin(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_page_setup_get_top_margin((*C.GtkPageSetup)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// SetBottomMargin is a wrapper around the C function gtk_page_setup_set_bottom_margin.
func (recv *PageSetup) SetBottomMargin(margin float64, unit Unit) {
	c_margin := (C.gdouble)(margin)

	c_unit := (C.GtkUnit)(unit)

	C.gtk_page_setup_set_bottom_margin((*C.GtkPageSetup)(recv.native), c_margin, c_unit)

	return
}

// SetLeftMargin is a wrapper around the C function gtk_page_setup_set_left_margin.
func (recv *PageSetup) SetLeftMargin(margin float64, unit Unit) {
	c_margin := (C.gdouble)(margin)

	c_unit := (C.GtkUnit)(unit)

	C.gtk_page_setup_set_left_margin((*C.GtkPageSetup)(recv.native), c_margin, c_unit)

	return
}

// SetOrientation is a wrapper around the C function gtk_page_setup_set_orientation.
func (recv *PageSetup) SetOrientation(orientation PageOrientation) {
	c_orientation := (C.GtkPageOrientation)(orientation)

	C.gtk_page_setup_set_orientation((*C.GtkPageSetup)(recv.native), c_orientation)

	return
}

// SetPaperSize is a wrapper around the C function gtk_page_setup_set_paper_size.
func (recv *PageSetup) SetPaperSize(size *PaperSize) {
	c_size := (*C.GtkPaperSize)(C.NULL)
	if size != nil {
		c_size = (*C.GtkPaperSize)(size.ToC())
	}

	C.gtk_page_setup_set_paper_size((*C.GtkPageSetup)(recv.native), c_size)

	return
}

// SetPaperSizeAndDefaultMargins is a wrapper around the C function gtk_page_setup_set_paper_size_and_default_margins.
func (recv *PageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize) {
	c_size := (*C.GtkPaperSize)(C.NULL)
	if size != nil {
		c_size = (*C.GtkPaperSize)(size.ToC())
	}

	C.gtk_page_setup_set_paper_size_and_default_margins((*C.GtkPageSetup)(recv.native), c_size)

	return
}

// SetRightMargin is a wrapper around the C function gtk_page_setup_set_right_margin.
func (recv *PageSetup) SetRightMargin(margin float64, unit Unit) {
	c_margin := (C.gdouble)(margin)

	c_unit := (C.GtkUnit)(unit)

	C.gtk_page_setup_set_right_margin((*C.GtkPageSetup)(recv.native), c_margin, c_unit)

	return
}

// SetTopMargin is a wrapper around the C function gtk_page_setup_set_top_margin.
func (recv *PageSetup) SetTopMargin(margin float64, unit Unit) {
	c_margin := (C.gdouble)(margin)

	c_unit := (C.GtkUnit)(unit)

	C.gtk_page_setup_set_top_margin((*C.GtkPageSetup)(recv.native), c_margin, c_unit)

	return
}

// ToFile is a wrapper around the C function gtk_page_setup_to_file.
func (recv *PageSetup) ToFile(fileName string) (bool, error) {
	c_file_name := C.CString(fileName)
	defer C.free(unsafe.Pointer(c_file_name))

	var cThrowableError *C.GError

	retC := C.gtk_page_setup_to_file((*C.GtkPageSetup)(recv.native), c_file_name, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ToKeyFile is a wrapper around the C function gtk_page_setup_to_key_file.
func (recv *PageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	c_key_file := (*C.GKeyFile)(C.NULL)
	if keyFile != nil {
		c_key_file = (*C.GKeyFile)(keyFile.ToC())
	}

	c_group_name := C.CString(groupName)
	defer C.free(unsafe.Pointer(c_group_name))

	C.gtk_page_setup_to_key_file((*C.GtkPageSetup)(recv.native), c_key_file, c_group_name)

	return
}

// Paned is a wrapper around the C record GtkPaned.
type Paned struct {
	native *C.GtkPaned
	// container : record
	// Private : priv
}

func PanedNewFromC(u unsafe.Pointer) *Paned {
	c := (*C.GtkPaned)(u)
	if c == nil {
		return nil
	}

	g := &Paned{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Paned) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Paned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Paned with another Paned, and returns true if they represent the same GObject.
func (recv *Paned) Equals(other *Paned) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Paned) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Paned) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Paned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Paned) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Paned.
// Exercise care, as this is a potentially dangerous function if the Object is not a Paned.
func CastToPaned(object *gobject.Object) *Paned {
	return PanedNewFromC(object.ToC())
}

type signalPanedAcceptPositionDetail struct {
	callback  PanedSignalAcceptPositionCallback
	handlerID C.gulong
}

var signalPanedAcceptPositionId int
var signalPanedAcceptPositionMap = make(map[int]signalPanedAcceptPositionDetail)
var signalPanedAcceptPositionLock sync.RWMutex

// PanedSignalAcceptPositionCallback is a callback function for a 'accept-position' signal emitted from a Paned.
type PanedSignalAcceptPositionCallback func() bool

/*
ConnectAcceptPosition connects the callback to the 'accept-position' signal for the Paned.

The returned value represents the connection, and may be passed to DisconnectAcceptPosition to remove it.
*/
func (recv *Paned) ConnectAcceptPosition(callback PanedSignalAcceptPositionCallback) int {
	signalPanedAcceptPositionLock.Lock()
	defer signalPanedAcceptPositionLock.Unlock()

	signalPanedAcceptPositionId++
	instance := C.gpointer(recv.native)
	handlerID := C.Paned_signal_connect_accept_position(instance, C.gpointer(uintptr(signalPanedAcceptPositionId)))

	detail := signalPanedAcceptPositionDetail{callback, handlerID}
	signalPanedAcceptPositionMap[signalPanedAcceptPositionId] = detail

	return signalPanedAcceptPositionId
}

/*
DisconnectAcceptPosition disconnects a callback from the 'accept-position' signal for the Paned.

The connectionID should be a value returned from a call to ConnectAcceptPosition.
*/
func (recv *Paned) DisconnectAcceptPosition(connectionID int) {
	signalPanedAcceptPositionLock.Lock()
	defer signalPanedAcceptPositionLock.Unlock()

	detail, exists := signalPanedAcceptPositionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPanedAcceptPositionMap, connectionID)
}

//export paned_acceptPositionHandler
func paned_acceptPositionHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalPanedAcceptPositionLock.RLock()
	defer signalPanedAcceptPositionLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPanedAcceptPositionMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalPanedCancelPositionDetail struct {
	callback  PanedSignalCancelPositionCallback
	handlerID C.gulong
}

var signalPanedCancelPositionId int
var signalPanedCancelPositionMap = make(map[int]signalPanedCancelPositionDetail)
var signalPanedCancelPositionLock sync.RWMutex

// PanedSignalCancelPositionCallback is a callback function for a 'cancel-position' signal emitted from a Paned.
type PanedSignalCancelPositionCallback func() bool

/*
ConnectCancelPosition connects the callback to the 'cancel-position' signal for the Paned.

The returned value represents the connection, and may be passed to DisconnectCancelPosition to remove it.
*/
func (recv *Paned) ConnectCancelPosition(callback PanedSignalCancelPositionCallback) int {
	signalPanedCancelPositionLock.Lock()
	defer signalPanedCancelPositionLock.Unlock()

	signalPanedCancelPositionId++
	instance := C.gpointer(recv.native)
	handlerID := C.Paned_signal_connect_cancel_position(instance, C.gpointer(uintptr(signalPanedCancelPositionId)))

	detail := signalPanedCancelPositionDetail{callback, handlerID}
	signalPanedCancelPositionMap[signalPanedCancelPositionId] = detail

	return signalPanedCancelPositionId
}

/*
DisconnectCancelPosition disconnects a callback from the 'cancel-position' signal for the Paned.

The connectionID should be a value returned from a call to ConnectCancelPosition.
*/
func (recv *Paned) DisconnectCancelPosition(connectionID int) {
	signalPanedCancelPositionLock.Lock()
	defer signalPanedCancelPositionLock.Unlock()

	detail, exists := signalPanedCancelPositionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPanedCancelPositionMap, connectionID)
}

//export paned_cancelPositionHandler
func paned_cancelPositionHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalPanedCancelPositionLock.RLock()
	defer signalPanedCancelPositionLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPanedCancelPositionMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalPanedCycleChildFocusDetail struct {
	callback  PanedSignalCycleChildFocusCallback
	handlerID C.gulong
}

var signalPanedCycleChildFocusId int
var signalPanedCycleChildFocusMap = make(map[int]signalPanedCycleChildFocusDetail)
var signalPanedCycleChildFocusLock sync.RWMutex

// PanedSignalCycleChildFocusCallback is a callback function for a 'cycle-child-focus' signal emitted from a Paned.
type PanedSignalCycleChildFocusCallback func(reversed bool) bool

/*
ConnectCycleChildFocus connects the callback to the 'cycle-child-focus' signal for the Paned.

The returned value represents the connection, and may be passed to DisconnectCycleChildFocus to remove it.
*/
func (recv *Paned) ConnectCycleChildFocus(callback PanedSignalCycleChildFocusCallback) int {
	signalPanedCycleChildFocusLock.Lock()
	defer signalPanedCycleChildFocusLock.Unlock()

	signalPanedCycleChildFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Paned_signal_connect_cycle_child_focus(instance, C.gpointer(uintptr(signalPanedCycleChildFocusId)))

	detail := signalPanedCycleChildFocusDetail{callback, handlerID}
	signalPanedCycleChildFocusMap[signalPanedCycleChildFocusId] = detail

	return signalPanedCycleChildFocusId
}

/*
DisconnectCycleChildFocus disconnects a callback from the 'cycle-child-focus' signal for the Paned.

The connectionID should be a value returned from a call to ConnectCycleChildFocus.
*/
func (recv *Paned) DisconnectCycleChildFocus(connectionID int) {
	signalPanedCycleChildFocusLock.Lock()
	defer signalPanedCycleChildFocusLock.Unlock()

	detail, exists := signalPanedCycleChildFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPanedCycleChildFocusMap, connectionID)
}

//export paned_cycleChildFocusHandler
func paned_cycleChildFocusHandler(_ *C.GObject, c_reversed C.gboolean, data C.gpointer) C.gboolean {
	signalPanedCycleChildFocusLock.RLock()
	defer signalPanedCycleChildFocusLock.RUnlock()

	reversed := c_reversed == C.TRUE

	index := int(uintptr(data))
	callback := signalPanedCycleChildFocusMap[index].callback
	retGo := callback(reversed)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalPanedCycleHandleFocusDetail struct {
	callback  PanedSignalCycleHandleFocusCallback
	handlerID C.gulong
}

var signalPanedCycleHandleFocusId int
var signalPanedCycleHandleFocusMap = make(map[int]signalPanedCycleHandleFocusDetail)
var signalPanedCycleHandleFocusLock sync.RWMutex

// PanedSignalCycleHandleFocusCallback is a callback function for a 'cycle-handle-focus' signal emitted from a Paned.
type PanedSignalCycleHandleFocusCallback func(reversed bool) bool

/*
ConnectCycleHandleFocus connects the callback to the 'cycle-handle-focus' signal for the Paned.

The returned value represents the connection, and may be passed to DisconnectCycleHandleFocus to remove it.
*/
func (recv *Paned) ConnectCycleHandleFocus(callback PanedSignalCycleHandleFocusCallback) int {
	signalPanedCycleHandleFocusLock.Lock()
	defer signalPanedCycleHandleFocusLock.Unlock()

	signalPanedCycleHandleFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Paned_signal_connect_cycle_handle_focus(instance, C.gpointer(uintptr(signalPanedCycleHandleFocusId)))

	detail := signalPanedCycleHandleFocusDetail{callback, handlerID}
	signalPanedCycleHandleFocusMap[signalPanedCycleHandleFocusId] = detail

	return signalPanedCycleHandleFocusId
}

/*
DisconnectCycleHandleFocus disconnects a callback from the 'cycle-handle-focus' signal for the Paned.

The connectionID should be a value returned from a call to ConnectCycleHandleFocus.
*/
func (recv *Paned) DisconnectCycleHandleFocus(connectionID int) {
	signalPanedCycleHandleFocusLock.Lock()
	defer signalPanedCycleHandleFocusLock.Unlock()

	detail, exists := signalPanedCycleHandleFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPanedCycleHandleFocusMap, connectionID)
}

//export paned_cycleHandleFocusHandler
func paned_cycleHandleFocusHandler(_ *C.GObject, c_reversed C.gboolean, data C.gpointer) C.gboolean {
	signalPanedCycleHandleFocusLock.RLock()
	defer signalPanedCycleHandleFocusLock.RUnlock()

	reversed := c_reversed == C.TRUE

	index := int(uintptr(data))
	callback := signalPanedCycleHandleFocusMap[index].callback
	retGo := callback(reversed)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalPanedMoveHandleDetail struct {
	callback  PanedSignalMoveHandleCallback
	handlerID C.gulong
}

var signalPanedMoveHandleId int
var signalPanedMoveHandleMap = make(map[int]signalPanedMoveHandleDetail)
var signalPanedMoveHandleLock sync.RWMutex

// PanedSignalMoveHandleCallback is a callback function for a 'move-handle' signal emitted from a Paned.
type PanedSignalMoveHandleCallback func(scrollType ScrollType) bool

/*
ConnectMoveHandle connects the callback to the 'move-handle' signal for the Paned.

The returned value represents the connection, and may be passed to DisconnectMoveHandle to remove it.
*/
func (recv *Paned) ConnectMoveHandle(callback PanedSignalMoveHandleCallback) int {
	signalPanedMoveHandleLock.Lock()
	defer signalPanedMoveHandleLock.Unlock()

	signalPanedMoveHandleId++
	instance := C.gpointer(recv.native)
	handlerID := C.Paned_signal_connect_move_handle(instance, C.gpointer(uintptr(signalPanedMoveHandleId)))

	detail := signalPanedMoveHandleDetail{callback, handlerID}
	signalPanedMoveHandleMap[signalPanedMoveHandleId] = detail

	return signalPanedMoveHandleId
}

/*
DisconnectMoveHandle disconnects a callback from the 'move-handle' signal for the Paned.

The connectionID should be a value returned from a call to ConnectMoveHandle.
*/
func (recv *Paned) DisconnectMoveHandle(connectionID int) {
	signalPanedMoveHandleLock.Lock()
	defer signalPanedMoveHandleLock.Unlock()

	detail, exists := signalPanedMoveHandleMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPanedMoveHandleMap, connectionID)
}

//export paned_moveHandleHandler
func paned_moveHandleHandler(_ *C.GObject, c_scroll_type C.GtkScrollType, data C.gpointer) C.gboolean {
	signalPanedMoveHandleLock.RLock()
	defer signalPanedMoveHandleLock.RUnlock()

	scrollType := ScrollType(c_scroll_type)

	index := int(uintptr(data))
	callback := signalPanedMoveHandleMap[index].callback
	retGo := callback(scrollType)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalPanedToggleHandleFocusDetail struct {
	callback  PanedSignalToggleHandleFocusCallback
	handlerID C.gulong
}

var signalPanedToggleHandleFocusId int
var signalPanedToggleHandleFocusMap = make(map[int]signalPanedToggleHandleFocusDetail)
var signalPanedToggleHandleFocusLock sync.RWMutex

// PanedSignalToggleHandleFocusCallback is a callback function for a 'toggle-handle-focus' signal emitted from a Paned.
type PanedSignalToggleHandleFocusCallback func() bool

/*
ConnectToggleHandleFocus connects the callback to the 'toggle-handle-focus' signal for the Paned.

The returned value represents the connection, and may be passed to DisconnectToggleHandleFocus to remove it.
*/
func (recv *Paned) ConnectToggleHandleFocus(callback PanedSignalToggleHandleFocusCallback) int {
	signalPanedToggleHandleFocusLock.Lock()
	defer signalPanedToggleHandleFocusLock.Unlock()

	signalPanedToggleHandleFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Paned_signal_connect_toggle_handle_focus(instance, C.gpointer(uintptr(signalPanedToggleHandleFocusId)))

	detail := signalPanedToggleHandleFocusDetail{callback, handlerID}
	signalPanedToggleHandleFocusMap[signalPanedToggleHandleFocusId] = detail

	return signalPanedToggleHandleFocusId
}

/*
DisconnectToggleHandleFocus disconnects a callback from the 'toggle-handle-focus' signal for the Paned.

The connectionID should be a value returned from a call to ConnectToggleHandleFocus.
*/
func (recv *Paned) DisconnectToggleHandleFocus(connectionID int) {
	signalPanedToggleHandleFocusLock.Lock()
	defer signalPanedToggleHandleFocusLock.Unlock()

	detail, exists := signalPanedToggleHandleFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPanedToggleHandleFocusMap, connectionID)
}

//export paned_toggleHandleFocusHandler
func paned_toggleHandleFocusHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalPanedToggleHandleFocusLock.RLock()
	defer signalPanedToggleHandleFocusLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPanedToggleHandleFocusMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Add1 is a wrapper around the C function gtk_paned_add1.
func (recv *Paned) Add1(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_paned_add1((*C.GtkPaned)(recv.native), c_child)

	return
}

// Add2 is a wrapper around the C function gtk_paned_add2.
func (recv *Paned) Add2(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_paned_add2((*C.GtkPaned)(recv.native), c_child)

	return
}

// GetChild1 is a wrapper around the C function gtk_paned_get_child1.
func (recv *Paned) GetChild1() *Widget {
	retC := C.gtk_paned_get_child1((*C.GtkPaned)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetChild2 is a wrapper around the C function gtk_paned_get_child2.
func (recv *Paned) GetChild2() *Widget {
	retC := C.gtk_paned_get_child2((*C.GtkPaned)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPosition is a wrapper around the C function gtk_paned_get_position.
func (recv *Paned) GetPosition() int32 {
	retC := C.gtk_paned_get_position((*C.GtkPaned)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Pack1 is a wrapper around the C function gtk_paned_pack1.
func (recv *Paned) Pack1(child *Widget, resize bool, shrink bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_resize :=
		boolToGboolean(resize)

	c_shrink :=
		boolToGboolean(shrink)

	C.gtk_paned_pack1((*C.GtkPaned)(recv.native), c_child, c_resize, c_shrink)

	return
}

// Pack2 is a wrapper around the C function gtk_paned_pack2.
func (recv *Paned) Pack2(child *Widget, resize bool, shrink bool) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_resize :=
		boolToGboolean(resize)

	c_shrink :=
		boolToGboolean(shrink)

	C.gtk_paned_pack2((*C.GtkPaned)(recv.native), c_child, c_resize, c_shrink)

	return
}

// SetPosition is a wrapper around the C function gtk_paned_set_position.
func (recv *Paned) SetPosition(position int32) {
	c_position := (C.gint)(position)

	C.gtk_paned_set_position((*C.GtkPaned)(recv.native), c_position)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Paned
func (recv *Paned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Paned
func (recv *Paned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Paned
func (recv *Paned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// PanedAccessible is a wrapper around the C record GtkPanedAccessible.
type PanedAccessible struct {
	native *C.GtkPanedAccessible
	// parent : record
	// priv : record
}

func PanedAccessibleNewFromC(u unsafe.Pointer) *PanedAccessible {
	c := (*C.GtkPanedAccessible)(u)
	if c == nil {
		return nil
	}

	g := &PanedAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PanedAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PanedAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PanedAccessible with another PanedAccessible, and returns true if they represent the same GObject.
func (recv *PanedAccessible) Equals(other *PanedAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *PanedAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *PanedAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *PanedAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *PanedAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to PanedAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a PanedAccessible.
func CastToPanedAccessible(object *gobject.Object) *PanedAccessible {
	return PanedAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by PanedAccessible
func (recv *PanedAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by PanedAccessible
func (recv *PanedAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// PlacesSidebar is a wrapper around the C record GtkPlacesSidebar.
type PlacesSidebar struct {
	native *C.GtkPlacesSidebar
}

func PlacesSidebarNewFromC(u unsafe.Pointer) *PlacesSidebar {
	c := (*C.GtkPlacesSidebar)(u)
	if c == nil {
		return nil
	}

	g := &PlacesSidebar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PlacesSidebar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PlacesSidebar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PlacesSidebar with another PlacesSidebar, and returns true if they represent the same GObject.
func (recv *PlacesSidebar) Equals(other *PlacesSidebar) bool {
	return other.ToC() == recv.ToC()
}

// ScrolledWindow upcasts to *ScrolledWindow
func (recv *PlacesSidebar) ScrolledWindow() *ScrolledWindow {
	return ScrolledWindowNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *PlacesSidebar) Bin() *Bin {
	return recv.ScrolledWindow().Bin()
}

// Container upcasts to *Container
func (recv *PlacesSidebar) Container() *Container {
	return recv.ScrolledWindow().Container()
}

// Widget upcasts to *Widget
func (recv *PlacesSidebar) Widget() *Widget {
	return recv.ScrolledWindow().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *PlacesSidebar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ScrolledWindow().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *PlacesSidebar) Object() *gobject.Object {
	return recv.ScrolledWindow().Object()
}

// CastToWidget down casts any arbitrary Object to PlacesSidebar.
// Exercise care, as this is a potentially dangerous function if the Object is not a PlacesSidebar.
func CastToPlacesSidebar(object *gobject.Object) *PlacesSidebar {
	return PlacesSidebarNewFromC(object.ToC())
}

// Unsupported signal 'drag-action-requested' for PlacesSidebar : param source_file_list : gpointer

// Unsupported signal 'drag-perform-drop' for PlacesSidebar : param source_file_list : gpointer

type signalPlacesSidebarShowConnectToServerDetail struct {
	callback  PlacesSidebarSignalShowConnectToServerCallback
	handlerID C.gulong
}

var signalPlacesSidebarShowConnectToServerId int
var signalPlacesSidebarShowConnectToServerMap = make(map[int]signalPlacesSidebarShowConnectToServerDetail)
var signalPlacesSidebarShowConnectToServerLock sync.RWMutex

// PlacesSidebarSignalShowConnectToServerCallback is a callback function for a 'show-connect-to-server' signal emitted from a PlacesSidebar.
type PlacesSidebarSignalShowConnectToServerCallback func()

/*
ConnectShowConnectToServer connects the callback to the 'show-connect-to-server' signal for the PlacesSidebar.

The returned value represents the connection, and may be passed to DisconnectShowConnectToServer to remove it.
*/
func (recv *PlacesSidebar) ConnectShowConnectToServer(callback PlacesSidebarSignalShowConnectToServerCallback) int {
	signalPlacesSidebarShowConnectToServerLock.Lock()
	defer signalPlacesSidebarShowConnectToServerLock.Unlock()

	signalPlacesSidebarShowConnectToServerId++
	instance := C.gpointer(recv.native)
	handlerID := C.PlacesSidebar_signal_connect_show_connect_to_server(instance, C.gpointer(uintptr(signalPlacesSidebarShowConnectToServerId)))

	detail := signalPlacesSidebarShowConnectToServerDetail{callback, handlerID}
	signalPlacesSidebarShowConnectToServerMap[signalPlacesSidebarShowConnectToServerId] = detail

	return signalPlacesSidebarShowConnectToServerId
}

/*
DisconnectShowConnectToServer disconnects a callback from the 'show-connect-to-server' signal for the PlacesSidebar.

The connectionID should be a value returned from a call to ConnectShowConnectToServer.
*/
func (recv *PlacesSidebar) DisconnectShowConnectToServer(connectionID int) {
	signalPlacesSidebarShowConnectToServerLock.Lock()
	defer signalPlacesSidebarShowConnectToServerLock.Unlock()

	detail, exists := signalPlacesSidebarShowConnectToServerMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPlacesSidebarShowConnectToServerMap, connectionID)
}

//export placessidebar_showConnectToServerHandler
func placessidebar_showConnectToServerHandler(_ *C.GObject, data C.gpointer) {
	signalPlacesSidebarShowConnectToServerLock.RLock()
	defer signalPlacesSidebarShowConnectToServerLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPlacesSidebarShowConnectToServerMap[index].callback
	callback()
}

// GetShowConnectToServer is a wrapper around the C function gtk_places_sidebar_get_show_connect_to_server.
func (recv *PlacesSidebar) GetShowConnectToServer() bool {
	retC := C.gtk_places_sidebar_get_show_connect_to_server((*C.GtkPlacesSidebar)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by PlacesSidebar
func (recv *PlacesSidebar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by PlacesSidebar
func (recv *PlacesSidebar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkPlug

// Popover is a wrapper around the C record GtkPopover.
type Popover struct {
	native *C.GtkPopover
	// parent_instance : record
	// Private : priv
}

func PopoverNewFromC(u unsafe.Pointer) *Popover {
	c := (*C.GtkPopover)(u)
	if c == nil {
		return nil
	}

	g := &Popover{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Popover) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Popover) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Popover with another Popover, and returns true if they represent the same GObject.
func (recv *Popover) Equals(other *Popover) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Popover) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Popover) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Popover) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Popover) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Popover) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Popover.
// Exercise care, as this is a potentially dangerous function if the Object is not a Popover.
func CastToPopover(object *gobject.Object) *Popover {
	return PopoverNewFromC(object.ToC())
}

type signalPopoverClosedDetail struct {
	callback  PopoverSignalClosedCallback
	handlerID C.gulong
}

var signalPopoverClosedId int
var signalPopoverClosedMap = make(map[int]signalPopoverClosedDetail)
var signalPopoverClosedLock sync.RWMutex

// PopoverSignalClosedCallback is a callback function for a 'closed' signal emitted from a Popover.
type PopoverSignalClosedCallback func()

/*
ConnectClosed connects the callback to the 'closed' signal for the Popover.

The returned value represents the connection, and may be passed to DisconnectClosed to remove it.
*/
func (recv *Popover) ConnectClosed(callback PopoverSignalClosedCallback) int {
	signalPopoverClosedLock.Lock()
	defer signalPopoverClosedLock.Unlock()

	signalPopoverClosedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Popover_signal_connect_closed(instance, C.gpointer(uintptr(signalPopoverClosedId)))

	detail := signalPopoverClosedDetail{callback, handlerID}
	signalPopoverClosedMap[signalPopoverClosedId] = detail

	return signalPopoverClosedId
}

/*
DisconnectClosed disconnects a callback from the 'closed' signal for the Popover.

The connectionID should be a value returned from a call to ConnectClosed.
*/
func (recv *Popover) DisconnectClosed(connectionID int) {
	signalPopoverClosedLock.Lock()
	defer signalPopoverClosedLock.Unlock()

	detail, exists := signalPopoverClosedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPopoverClosedMap, connectionID)
}

//export popover_closedHandler
func popover_closedHandler(_ *C.GObject, data C.gpointer) {
	signalPopoverClosedLock.RLock()
	defer signalPopoverClosedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPopoverClosedMap[index].callback
	callback()
}

// GetPointingTo is a wrapper around the C function gtk_popover_get_pointing_to.
func (recv *Popover) GetPointingTo() (bool, *gdk.Rectangle) {
	var c_rect C.GdkRectangle

	retC := C.gtk_popover_get_pointing_to((*C.GtkPopover)(recv.native), &c_rect)
	retGo := retC == C.TRUE

	rect := gdk.RectangleNewFromC(unsafe.Pointer(&c_rect))

	return retGo, rect
}

// GetPosition is a wrapper around the C function gtk_popover_get_position.
func (recv *Popover) GetPosition() PositionType {
	retC := C.gtk_popover_get_position((*C.GtkPopover)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by Popover
func (recv *Popover) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Popover
func (recv *Popover) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PopoverAccessible is a wrapper around the C record GtkPopoverAccessible.
type PopoverAccessible struct {
	native *C.GtkPopoverAccessible
	// parent : record
}

func PopoverAccessibleNewFromC(u unsafe.Pointer) *PopoverAccessible {
	c := (*C.GtkPopoverAccessible)(u)
	if c == nil {
		return nil
	}

	g := &PopoverAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PopoverAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PopoverAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PopoverAccessible with another PopoverAccessible, and returns true if they represent the same GObject.
func (recv *PopoverAccessible) Equals(other *PopoverAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *PopoverAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *PopoverAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *PopoverAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *PopoverAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to PopoverAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a PopoverAccessible.
func CastToPopoverAccessible(object *gobject.Object) *PopoverAccessible {
	return PopoverAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by PopoverAccessible
func (recv *PopoverAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// PopoverMenu is a wrapper around the C record GtkPopoverMenu.
type PopoverMenu struct {
	native *C.GtkPopoverMenu
}

func PopoverMenuNewFromC(u unsafe.Pointer) *PopoverMenu {
	c := (*C.GtkPopoverMenu)(u)
	if c == nil {
		return nil
	}

	g := &PopoverMenu{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PopoverMenu) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PopoverMenu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PopoverMenu with another PopoverMenu, and returns true if they represent the same GObject.
func (recv *PopoverMenu) Equals(other *PopoverMenu) bool {
	return other.ToC() == recv.ToC()
}

// Popover upcasts to *Popover
func (recv *PopoverMenu) Popover() *Popover {
	return PopoverNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *PopoverMenu) Bin() *Bin {
	return recv.Popover().Bin()
}

// Container upcasts to *Container
func (recv *PopoverMenu) Container() *Container {
	return recv.Popover().Container()
}

// Widget upcasts to *Widget
func (recv *PopoverMenu) Widget() *Widget {
	return recv.Popover().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *PopoverMenu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Popover().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *PopoverMenu) Object() *gobject.Object {
	return recv.Popover().Object()
}

// CastToWidget down casts any arbitrary Object to PopoverMenu.
// Exercise care, as this is a potentially dangerous function if the Object is not a PopoverMenu.
func CastToPopoverMenu(object *gobject.Object) *PopoverMenu {
	return PopoverMenuNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by PopoverMenu
func (recv *PopoverMenu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by PopoverMenu
func (recv *PopoverMenu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// PrintContext is a wrapper around the C record GtkPrintContext.
type PrintContext struct {
	native *C.GtkPrintContext
}

func PrintContextNewFromC(u unsafe.Pointer) *PrintContext {
	c := (*C.GtkPrintContext)(u)
	if c == nil {
		return nil
	}

	g := &PrintContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PrintContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PrintContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintContext with another PrintContext, and returns true if they represent the same GObject.
func (recv *PrintContext) Equals(other *PrintContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *PrintContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to PrintContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintContext.
func CastToPrintContext(object *gobject.Object) *PrintContext {
	return PrintContextNewFromC(object.ToC())
}

// CreatePangoContext is a wrapper around the C function gtk_print_context_create_pango_context.
func (recv *PrintContext) CreatePangoContext() *pango.Context {
	retC := C.gtk_print_context_create_pango_context((*C.GtkPrintContext)(recv.native))
	retGo := pango.ContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CreatePangoLayout is a wrapper around the C function gtk_print_context_create_pango_layout.
func (recv *PrintContext) CreatePangoLayout() *pango.Layout {
	retC := C.gtk_print_context_create_pango_layout((*C.GtkPrintContext)(recv.native))
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCairoContext is a wrapper around the C function gtk_print_context_get_cairo_context.
func (recv *PrintContext) GetCairoContext() *cairo.Context {
	retC := C.gtk_print_context_get_cairo_context((*C.GtkPrintContext)(recv.native))
	retGo := cairo.ContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDpiX is a wrapper around the C function gtk_print_context_get_dpi_x.
func (recv *PrintContext) GetDpiX() float64 {
	retC := C.gtk_print_context_get_dpi_x((*C.GtkPrintContext)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetDpiY is a wrapper around the C function gtk_print_context_get_dpi_y.
func (recv *PrintContext) GetDpiY() float64 {
	retC := C.gtk_print_context_get_dpi_y((*C.GtkPrintContext)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetHeight is a wrapper around the C function gtk_print_context_get_height.
func (recv *PrintContext) GetHeight() float64 {
	retC := C.gtk_print_context_get_height((*C.GtkPrintContext)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetPageSetup is a wrapper around the C function gtk_print_context_get_page_setup.
func (recv *PrintContext) GetPageSetup() *PageSetup {
	retC := C.gtk_print_context_get_page_setup((*C.GtkPrintContext)(recv.native))
	retGo := PageSetupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPangoFontmap is a wrapper around the C function gtk_print_context_get_pango_fontmap.
func (recv *PrintContext) GetPangoFontmap() *pango.FontMap {
	retC := C.gtk_print_context_get_pango_fontmap((*C.GtkPrintContext)(recv.native))
	retGo := pango.FontMapNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetWidth is a wrapper around the C function gtk_print_context_get_width.
func (recv *PrintContext) GetWidth() float64 {
	retC := C.gtk_print_context_get_width((*C.GtkPrintContext)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// SetCairoContext is a wrapper around the C function gtk_print_context_set_cairo_context.
func (recv *PrintContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64) {
	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_dpi_x := (C.double)(dpiX)

	c_dpi_y := (C.double)(dpiY)

	C.gtk_print_context_set_cairo_context((*C.GtkPrintContext)(recv.native), c_cr, c_dpi_x, c_dpi_y)

	return
}

// PrintOperation is a wrapper around the C record GtkPrintOperation.
type PrintOperation struct {
	native *C.GtkPrintOperation
	// parent_instance : record
	// Private : priv
}

func PrintOperationNewFromC(u unsafe.Pointer) *PrintOperation {
	c := (*C.GtkPrintOperation)(u)
	if c == nil {
		return nil
	}

	g := &PrintOperation{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PrintOperation) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PrintOperation) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintOperation with another PrintOperation, and returns true if they represent the same GObject.
func (recv *PrintOperation) Equals(other *PrintOperation) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *PrintOperation) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to PrintOperation.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintOperation.
func CastToPrintOperation(object *gobject.Object) *PrintOperation {
	return PrintOperationNewFromC(object.ToC())
}

type signalPrintOperationBeginPrintDetail struct {
	callback  PrintOperationSignalBeginPrintCallback
	handlerID C.gulong
}

var signalPrintOperationBeginPrintId int
var signalPrintOperationBeginPrintMap = make(map[int]signalPrintOperationBeginPrintDetail)
var signalPrintOperationBeginPrintLock sync.RWMutex

// PrintOperationSignalBeginPrintCallback is a callback function for a 'begin-print' signal emitted from a PrintOperation.
type PrintOperationSignalBeginPrintCallback func(context *PrintContext)

/*
ConnectBeginPrint connects the callback to the 'begin-print' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectBeginPrint to remove it.
*/
func (recv *PrintOperation) ConnectBeginPrint(callback PrintOperationSignalBeginPrintCallback) int {
	signalPrintOperationBeginPrintLock.Lock()
	defer signalPrintOperationBeginPrintLock.Unlock()

	signalPrintOperationBeginPrintId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_begin_print(instance, C.gpointer(uintptr(signalPrintOperationBeginPrintId)))

	detail := signalPrintOperationBeginPrintDetail{callback, handlerID}
	signalPrintOperationBeginPrintMap[signalPrintOperationBeginPrintId] = detail

	return signalPrintOperationBeginPrintId
}

/*
DisconnectBeginPrint disconnects a callback from the 'begin-print' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectBeginPrint.
*/
func (recv *PrintOperation) DisconnectBeginPrint(connectionID int) {
	signalPrintOperationBeginPrintLock.Lock()
	defer signalPrintOperationBeginPrintLock.Unlock()

	detail, exists := signalPrintOperationBeginPrintMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationBeginPrintMap, connectionID)
}

//export printoperation_beginPrintHandler
func printoperation_beginPrintHandler(_ *C.GObject, c_context *C.GtkPrintContext, data C.gpointer) {
	signalPrintOperationBeginPrintLock.RLock()
	defer signalPrintOperationBeginPrintLock.RUnlock()

	context := PrintContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalPrintOperationBeginPrintMap[index].callback
	callback(context)
}

type signalPrintOperationCreateCustomWidgetDetail struct {
	callback  PrintOperationSignalCreateCustomWidgetCallback
	handlerID C.gulong
}

var signalPrintOperationCreateCustomWidgetId int
var signalPrintOperationCreateCustomWidgetMap = make(map[int]signalPrintOperationCreateCustomWidgetDetail)
var signalPrintOperationCreateCustomWidgetLock sync.RWMutex

// PrintOperationSignalCreateCustomWidgetCallback is a callback function for a 'create-custom-widget' signal emitted from a PrintOperation.
type PrintOperationSignalCreateCustomWidgetCallback func() gobject.Object

/*
ConnectCreateCustomWidget connects the callback to the 'create-custom-widget' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectCreateCustomWidget to remove it.
*/
func (recv *PrintOperation) ConnectCreateCustomWidget(callback PrintOperationSignalCreateCustomWidgetCallback) int {
	signalPrintOperationCreateCustomWidgetLock.Lock()
	defer signalPrintOperationCreateCustomWidgetLock.Unlock()

	signalPrintOperationCreateCustomWidgetId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_create_custom_widget(instance, C.gpointer(uintptr(signalPrintOperationCreateCustomWidgetId)))

	detail := signalPrintOperationCreateCustomWidgetDetail{callback, handlerID}
	signalPrintOperationCreateCustomWidgetMap[signalPrintOperationCreateCustomWidgetId] = detail

	return signalPrintOperationCreateCustomWidgetId
}

/*
DisconnectCreateCustomWidget disconnects a callback from the 'create-custom-widget' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectCreateCustomWidget.
*/
func (recv *PrintOperation) DisconnectCreateCustomWidget(connectionID int) {
	signalPrintOperationCreateCustomWidgetLock.Lock()
	defer signalPrintOperationCreateCustomWidgetLock.Unlock()

	detail, exists := signalPrintOperationCreateCustomWidgetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationCreateCustomWidgetMap, connectionID)
}

//export printoperation_createCustomWidgetHandler
func printoperation_createCustomWidgetHandler(_ *C.GObject, data C.gpointer) *C.GObject {
	signalPrintOperationCreateCustomWidgetLock.RLock()
	defer signalPrintOperationCreateCustomWidgetLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPrintOperationCreateCustomWidgetMap[index].callback
	retGo := callback()
	retC :=
		(*C.GObject)(retGo.ToC())
	return retC
}

type signalPrintOperationCustomWidgetApplyDetail struct {
	callback  PrintOperationSignalCustomWidgetApplyCallback
	handlerID C.gulong
}

var signalPrintOperationCustomWidgetApplyId int
var signalPrintOperationCustomWidgetApplyMap = make(map[int]signalPrintOperationCustomWidgetApplyDetail)
var signalPrintOperationCustomWidgetApplyLock sync.RWMutex

// PrintOperationSignalCustomWidgetApplyCallback is a callback function for a 'custom-widget-apply' signal emitted from a PrintOperation.
type PrintOperationSignalCustomWidgetApplyCallback func(widget *Widget)

/*
ConnectCustomWidgetApply connects the callback to the 'custom-widget-apply' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectCustomWidgetApply to remove it.
*/
func (recv *PrintOperation) ConnectCustomWidgetApply(callback PrintOperationSignalCustomWidgetApplyCallback) int {
	signalPrintOperationCustomWidgetApplyLock.Lock()
	defer signalPrintOperationCustomWidgetApplyLock.Unlock()

	signalPrintOperationCustomWidgetApplyId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_custom_widget_apply(instance, C.gpointer(uintptr(signalPrintOperationCustomWidgetApplyId)))

	detail := signalPrintOperationCustomWidgetApplyDetail{callback, handlerID}
	signalPrintOperationCustomWidgetApplyMap[signalPrintOperationCustomWidgetApplyId] = detail

	return signalPrintOperationCustomWidgetApplyId
}

/*
DisconnectCustomWidgetApply disconnects a callback from the 'custom-widget-apply' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectCustomWidgetApply.
*/
func (recv *PrintOperation) DisconnectCustomWidgetApply(connectionID int) {
	signalPrintOperationCustomWidgetApplyLock.Lock()
	defer signalPrintOperationCustomWidgetApplyLock.Unlock()

	detail, exists := signalPrintOperationCustomWidgetApplyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationCustomWidgetApplyMap, connectionID)
}

//export printoperation_customWidgetApplyHandler
func printoperation_customWidgetApplyHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	signalPrintOperationCustomWidgetApplyLock.RLock()
	defer signalPrintOperationCustomWidgetApplyLock.RUnlock()

	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalPrintOperationCustomWidgetApplyMap[index].callback
	callback(widget)
}

type signalPrintOperationDoneDetail struct {
	callback  PrintOperationSignalDoneCallback
	handlerID C.gulong
}

var signalPrintOperationDoneId int
var signalPrintOperationDoneMap = make(map[int]signalPrintOperationDoneDetail)
var signalPrintOperationDoneLock sync.RWMutex

// PrintOperationSignalDoneCallback is a callback function for a 'done' signal emitted from a PrintOperation.
type PrintOperationSignalDoneCallback func(result PrintOperationResult)

/*
ConnectDone connects the callback to the 'done' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectDone to remove it.
*/
func (recv *PrintOperation) ConnectDone(callback PrintOperationSignalDoneCallback) int {
	signalPrintOperationDoneLock.Lock()
	defer signalPrintOperationDoneLock.Unlock()

	signalPrintOperationDoneId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_done(instance, C.gpointer(uintptr(signalPrintOperationDoneId)))

	detail := signalPrintOperationDoneDetail{callback, handlerID}
	signalPrintOperationDoneMap[signalPrintOperationDoneId] = detail

	return signalPrintOperationDoneId
}

/*
DisconnectDone disconnects a callback from the 'done' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectDone.
*/
func (recv *PrintOperation) DisconnectDone(connectionID int) {
	signalPrintOperationDoneLock.Lock()
	defer signalPrintOperationDoneLock.Unlock()

	detail, exists := signalPrintOperationDoneMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationDoneMap, connectionID)
}

//export printoperation_doneHandler
func printoperation_doneHandler(_ *C.GObject, c_result C.GtkPrintOperationResult, data C.gpointer) {
	signalPrintOperationDoneLock.RLock()
	defer signalPrintOperationDoneLock.RUnlock()

	result := PrintOperationResult(c_result)

	index := int(uintptr(data))
	callback := signalPrintOperationDoneMap[index].callback
	callback(result)
}

type signalPrintOperationDrawPageDetail struct {
	callback  PrintOperationSignalDrawPageCallback
	handlerID C.gulong
}

var signalPrintOperationDrawPageId int
var signalPrintOperationDrawPageMap = make(map[int]signalPrintOperationDrawPageDetail)
var signalPrintOperationDrawPageLock sync.RWMutex

// PrintOperationSignalDrawPageCallback is a callback function for a 'draw-page' signal emitted from a PrintOperation.
type PrintOperationSignalDrawPageCallback func(context *PrintContext, pageNr int32)

/*
ConnectDrawPage connects the callback to the 'draw-page' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectDrawPage to remove it.
*/
func (recv *PrintOperation) ConnectDrawPage(callback PrintOperationSignalDrawPageCallback) int {
	signalPrintOperationDrawPageLock.Lock()
	defer signalPrintOperationDrawPageLock.Unlock()

	signalPrintOperationDrawPageId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_draw_page(instance, C.gpointer(uintptr(signalPrintOperationDrawPageId)))

	detail := signalPrintOperationDrawPageDetail{callback, handlerID}
	signalPrintOperationDrawPageMap[signalPrintOperationDrawPageId] = detail

	return signalPrintOperationDrawPageId
}

/*
DisconnectDrawPage disconnects a callback from the 'draw-page' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectDrawPage.
*/
func (recv *PrintOperation) DisconnectDrawPage(connectionID int) {
	signalPrintOperationDrawPageLock.Lock()
	defer signalPrintOperationDrawPageLock.Unlock()

	detail, exists := signalPrintOperationDrawPageMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationDrawPageMap, connectionID)
}

//export printoperation_drawPageHandler
func printoperation_drawPageHandler(_ *C.GObject, c_context *C.GtkPrintContext, c_page_nr C.gint, data C.gpointer) {
	signalPrintOperationDrawPageLock.RLock()
	defer signalPrintOperationDrawPageLock.RUnlock()

	context := PrintContextNewFromC(unsafe.Pointer(c_context))

	pageNr := int32(c_page_nr)

	index := int(uintptr(data))
	callback := signalPrintOperationDrawPageMap[index].callback
	callback(context, pageNr)
}

type signalPrintOperationEndPrintDetail struct {
	callback  PrintOperationSignalEndPrintCallback
	handlerID C.gulong
}

var signalPrintOperationEndPrintId int
var signalPrintOperationEndPrintMap = make(map[int]signalPrintOperationEndPrintDetail)
var signalPrintOperationEndPrintLock sync.RWMutex

// PrintOperationSignalEndPrintCallback is a callback function for a 'end-print' signal emitted from a PrintOperation.
type PrintOperationSignalEndPrintCallback func(context *PrintContext)

/*
ConnectEndPrint connects the callback to the 'end-print' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectEndPrint to remove it.
*/
func (recv *PrintOperation) ConnectEndPrint(callback PrintOperationSignalEndPrintCallback) int {
	signalPrintOperationEndPrintLock.Lock()
	defer signalPrintOperationEndPrintLock.Unlock()

	signalPrintOperationEndPrintId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_end_print(instance, C.gpointer(uintptr(signalPrintOperationEndPrintId)))

	detail := signalPrintOperationEndPrintDetail{callback, handlerID}
	signalPrintOperationEndPrintMap[signalPrintOperationEndPrintId] = detail

	return signalPrintOperationEndPrintId
}

/*
DisconnectEndPrint disconnects a callback from the 'end-print' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectEndPrint.
*/
func (recv *PrintOperation) DisconnectEndPrint(connectionID int) {
	signalPrintOperationEndPrintLock.Lock()
	defer signalPrintOperationEndPrintLock.Unlock()

	detail, exists := signalPrintOperationEndPrintMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationEndPrintMap, connectionID)
}

//export printoperation_endPrintHandler
func printoperation_endPrintHandler(_ *C.GObject, c_context *C.GtkPrintContext, data C.gpointer) {
	signalPrintOperationEndPrintLock.RLock()
	defer signalPrintOperationEndPrintLock.RUnlock()

	context := PrintContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalPrintOperationEndPrintMap[index].callback
	callback(context)
}

type signalPrintOperationPaginateDetail struct {
	callback  PrintOperationSignalPaginateCallback
	handlerID C.gulong
}

var signalPrintOperationPaginateId int
var signalPrintOperationPaginateMap = make(map[int]signalPrintOperationPaginateDetail)
var signalPrintOperationPaginateLock sync.RWMutex

// PrintOperationSignalPaginateCallback is a callback function for a 'paginate' signal emitted from a PrintOperation.
type PrintOperationSignalPaginateCallback func(context *PrintContext) bool

/*
ConnectPaginate connects the callback to the 'paginate' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectPaginate to remove it.
*/
func (recv *PrintOperation) ConnectPaginate(callback PrintOperationSignalPaginateCallback) int {
	signalPrintOperationPaginateLock.Lock()
	defer signalPrintOperationPaginateLock.Unlock()

	signalPrintOperationPaginateId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_paginate(instance, C.gpointer(uintptr(signalPrintOperationPaginateId)))

	detail := signalPrintOperationPaginateDetail{callback, handlerID}
	signalPrintOperationPaginateMap[signalPrintOperationPaginateId] = detail

	return signalPrintOperationPaginateId
}

/*
DisconnectPaginate disconnects a callback from the 'paginate' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectPaginate.
*/
func (recv *PrintOperation) DisconnectPaginate(connectionID int) {
	signalPrintOperationPaginateLock.Lock()
	defer signalPrintOperationPaginateLock.Unlock()

	detail, exists := signalPrintOperationPaginateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationPaginateMap, connectionID)
}

//export printoperation_paginateHandler
func printoperation_paginateHandler(_ *C.GObject, c_context *C.GtkPrintContext, data C.gpointer) C.gboolean {
	signalPrintOperationPaginateLock.RLock()
	defer signalPrintOperationPaginateLock.RUnlock()

	context := PrintContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalPrintOperationPaginateMap[index].callback
	retGo := callback(context)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalPrintOperationPreviewDetail struct {
	callback  PrintOperationSignalPreviewCallback
	handlerID C.gulong
}

var signalPrintOperationPreviewId int
var signalPrintOperationPreviewMap = make(map[int]signalPrintOperationPreviewDetail)
var signalPrintOperationPreviewLock sync.RWMutex

// PrintOperationSignalPreviewCallback is a callback function for a 'preview' signal emitted from a PrintOperation.
type PrintOperationSignalPreviewCallback func(preview *PrintOperationPreview, context *PrintContext, parent *Window) bool

/*
ConnectPreview connects the callback to the 'preview' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectPreview to remove it.
*/
func (recv *PrintOperation) ConnectPreview(callback PrintOperationSignalPreviewCallback) int {
	signalPrintOperationPreviewLock.Lock()
	defer signalPrintOperationPreviewLock.Unlock()

	signalPrintOperationPreviewId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_preview(instance, C.gpointer(uintptr(signalPrintOperationPreviewId)))

	detail := signalPrintOperationPreviewDetail{callback, handlerID}
	signalPrintOperationPreviewMap[signalPrintOperationPreviewId] = detail

	return signalPrintOperationPreviewId
}

/*
DisconnectPreview disconnects a callback from the 'preview' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectPreview.
*/
func (recv *PrintOperation) DisconnectPreview(connectionID int) {
	signalPrintOperationPreviewLock.Lock()
	defer signalPrintOperationPreviewLock.Unlock()

	detail, exists := signalPrintOperationPreviewMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationPreviewMap, connectionID)
}

//export printoperation_previewHandler
func printoperation_previewHandler(_ *C.GObject, c_preview *C.GtkPrintOperationPreview, c_context *C.GtkPrintContext, c_parent *C.GtkWindow, data C.gpointer) C.gboolean {
	signalPrintOperationPreviewLock.RLock()
	defer signalPrintOperationPreviewLock.RUnlock()

	preview := PrintOperationPreviewNewFromC(unsafe.Pointer(c_preview))

	context := PrintContextNewFromC(unsafe.Pointer(c_context))

	parent := WindowNewFromC(unsafe.Pointer(c_parent))

	index := int(uintptr(data))
	callback := signalPrintOperationPreviewMap[index].callback
	retGo := callback(preview, context, parent)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalPrintOperationRequestPageSetupDetail struct {
	callback  PrintOperationSignalRequestPageSetupCallback
	handlerID C.gulong
}

var signalPrintOperationRequestPageSetupId int
var signalPrintOperationRequestPageSetupMap = make(map[int]signalPrintOperationRequestPageSetupDetail)
var signalPrintOperationRequestPageSetupLock sync.RWMutex

// PrintOperationSignalRequestPageSetupCallback is a callback function for a 'request-page-setup' signal emitted from a PrintOperation.
type PrintOperationSignalRequestPageSetupCallback func(context *PrintContext, pageNr int32, setup *PageSetup)

/*
ConnectRequestPageSetup connects the callback to the 'request-page-setup' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectRequestPageSetup to remove it.
*/
func (recv *PrintOperation) ConnectRequestPageSetup(callback PrintOperationSignalRequestPageSetupCallback) int {
	signalPrintOperationRequestPageSetupLock.Lock()
	defer signalPrintOperationRequestPageSetupLock.Unlock()

	signalPrintOperationRequestPageSetupId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_request_page_setup(instance, C.gpointer(uintptr(signalPrintOperationRequestPageSetupId)))

	detail := signalPrintOperationRequestPageSetupDetail{callback, handlerID}
	signalPrintOperationRequestPageSetupMap[signalPrintOperationRequestPageSetupId] = detail

	return signalPrintOperationRequestPageSetupId
}

/*
DisconnectRequestPageSetup disconnects a callback from the 'request-page-setup' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectRequestPageSetup.
*/
func (recv *PrintOperation) DisconnectRequestPageSetup(connectionID int) {
	signalPrintOperationRequestPageSetupLock.Lock()
	defer signalPrintOperationRequestPageSetupLock.Unlock()

	detail, exists := signalPrintOperationRequestPageSetupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationRequestPageSetupMap, connectionID)
}

//export printoperation_requestPageSetupHandler
func printoperation_requestPageSetupHandler(_ *C.GObject, c_context *C.GtkPrintContext, c_page_nr C.gint, c_setup *C.GtkPageSetup, data C.gpointer) {
	signalPrintOperationRequestPageSetupLock.RLock()
	defer signalPrintOperationRequestPageSetupLock.RUnlock()

	context := PrintContextNewFromC(unsafe.Pointer(c_context))

	pageNr := int32(c_page_nr)

	setup := PageSetupNewFromC(unsafe.Pointer(c_setup))

	index := int(uintptr(data))
	callback := signalPrintOperationRequestPageSetupMap[index].callback
	callback(context, pageNr, setup)
}

type signalPrintOperationStatusChangedDetail struct {
	callback  PrintOperationSignalStatusChangedCallback
	handlerID C.gulong
}

var signalPrintOperationStatusChangedId int
var signalPrintOperationStatusChangedMap = make(map[int]signalPrintOperationStatusChangedDetail)
var signalPrintOperationStatusChangedLock sync.RWMutex

// PrintOperationSignalStatusChangedCallback is a callback function for a 'status-changed' signal emitted from a PrintOperation.
type PrintOperationSignalStatusChangedCallback func()

/*
ConnectStatusChanged connects the callback to the 'status-changed' signal for the PrintOperation.

The returned value represents the connection, and may be passed to DisconnectStatusChanged to remove it.
*/
func (recv *PrintOperation) ConnectStatusChanged(callback PrintOperationSignalStatusChangedCallback) int {
	signalPrintOperationStatusChangedLock.Lock()
	defer signalPrintOperationStatusChangedLock.Unlock()

	signalPrintOperationStatusChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperation_signal_connect_status_changed(instance, C.gpointer(uintptr(signalPrintOperationStatusChangedId)))

	detail := signalPrintOperationStatusChangedDetail{callback, handlerID}
	signalPrintOperationStatusChangedMap[signalPrintOperationStatusChangedId] = detail

	return signalPrintOperationStatusChangedId
}

/*
DisconnectStatusChanged disconnects a callback from the 'status-changed' signal for the PrintOperation.

The connectionID should be a value returned from a call to ConnectStatusChanged.
*/
func (recv *PrintOperation) DisconnectStatusChanged(connectionID int) {
	signalPrintOperationStatusChangedLock.Lock()
	defer signalPrintOperationStatusChangedLock.Unlock()

	detail, exists := signalPrintOperationStatusChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationStatusChangedMap, connectionID)
}

//export printoperation_statusChangedHandler
func printoperation_statusChangedHandler(_ *C.GObject, data C.gpointer) {
	signalPrintOperationStatusChangedLock.RLock()
	defer signalPrintOperationStatusChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalPrintOperationStatusChangedMap[index].callback
	callback()
}

// PrintOperationNew is a wrapper around the C function gtk_print_operation_new.
func PrintOperationNew() *PrintOperation {
	retC := C.gtk_print_operation_new()
	retGo := PrintOperationNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Cancel is a wrapper around the C function gtk_print_operation_cancel.
func (recv *PrintOperation) Cancel() {
	C.gtk_print_operation_cancel((*C.GtkPrintOperation)(recv.native))

	return
}

// GetDefaultPageSetup is a wrapper around the C function gtk_print_operation_get_default_page_setup.
func (recv *PrintOperation) GetDefaultPageSetup() *PageSetup {
	retC := C.gtk_print_operation_get_default_page_setup((*C.GtkPrintOperation)(recv.native))
	retGo := PageSetupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetError is a wrapper around the C function gtk_print_operation_get_error.
func (recv *PrintOperation) GetError() error {
	var cThrowableError *C.GError

	C.gtk_print_operation_get_error((*C.GtkPrintOperation)(recv.native), &cThrowableError)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return goError
}

// GetPrintSettings is a wrapper around the C function gtk_print_operation_get_print_settings.
func (recv *PrintOperation) GetPrintSettings() *PrintSettings {
	retC := C.gtk_print_operation_get_print_settings((*C.GtkPrintOperation)(recv.native))
	retGo := PrintSettingsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetStatus is a wrapper around the C function gtk_print_operation_get_status.
func (recv *PrintOperation) GetStatus() PrintStatus {
	retC := C.gtk_print_operation_get_status((*C.GtkPrintOperation)(recv.native))
	retGo := (PrintStatus)(retC)

	return retGo
}

// GetStatusString is a wrapper around the C function gtk_print_operation_get_status_string.
func (recv *PrintOperation) GetStatusString() string {
	retC := C.gtk_print_operation_get_status_string((*C.GtkPrintOperation)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// IsFinished is a wrapper around the C function gtk_print_operation_is_finished.
func (recv *PrintOperation) IsFinished() bool {
	retC := C.gtk_print_operation_is_finished((*C.GtkPrintOperation)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Run is a wrapper around the C function gtk_print_operation_run.
func (recv *PrintOperation) Run(action PrintOperationAction, parent *Window) (PrintOperationResult, error) {
	c_action := (C.GtkPrintOperationAction)(action)

	c_parent := (*C.GtkWindow)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWindow)(parent.ToC())
	}

	var cThrowableError *C.GError

	retC := C.gtk_print_operation_run((*C.GtkPrintOperation)(recv.native), c_action, c_parent, &cThrowableError)
	retGo := (PrintOperationResult)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetAllowAsync is a wrapper around the C function gtk_print_operation_set_allow_async.
func (recv *PrintOperation) SetAllowAsync(allowAsync bool) {
	c_allow_async :=
		boolToGboolean(allowAsync)

	C.gtk_print_operation_set_allow_async((*C.GtkPrintOperation)(recv.native), c_allow_async)

	return
}

// SetCurrentPage is a wrapper around the C function gtk_print_operation_set_current_page.
func (recv *PrintOperation) SetCurrentPage(currentPage int32) {
	c_current_page := (C.gint)(currentPage)

	C.gtk_print_operation_set_current_page((*C.GtkPrintOperation)(recv.native), c_current_page)

	return
}

// SetCustomTabLabel is a wrapper around the C function gtk_print_operation_set_custom_tab_label.
func (recv *PrintOperation) SetCustomTabLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_print_operation_set_custom_tab_label((*C.GtkPrintOperation)(recv.native), c_label)

	return
}

// SetDefaultPageSetup is a wrapper around the C function gtk_print_operation_set_default_page_setup.
func (recv *PrintOperation) SetDefaultPageSetup(defaultPageSetup *PageSetup) {
	c_default_page_setup := (*C.GtkPageSetup)(C.NULL)
	if defaultPageSetup != nil {
		c_default_page_setup = (*C.GtkPageSetup)(defaultPageSetup.ToC())
	}

	C.gtk_print_operation_set_default_page_setup((*C.GtkPrintOperation)(recv.native), c_default_page_setup)

	return
}

// SetExportFilename is a wrapper around the C function gtk_print_operation_set_export_filename.
func (recv *PrintOperation) SetExportFilename(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_print_operation_set_export_filename((*C.GtkPrintOperation)(recv.native), c_filename)

	return
}

// SetJobName is a wrapper around the C function gtk_print_operation_set_job_name.
func (recv *PrintOperation) SetJobName(jobName string) {
	c_job_name := C.CString(jobName)
	defer C.free(unsafe.Pointer(c_job_name))

	C.gtk_print_operation_set_job_name((*C.GtkPrintOperation)(recv.native), c_job_name)

	return
}

// SetNPages is a wrapper around the C function gtk_print_operation_set_n_pages.
func (recv *PrintOperation) SetNPages(nPages int32) {
	c_n_pages := (C.gint)(nPages)

	C.gtk_print_operation_set_n_pages((*C.GtkPrintOperation)(recv.native), c_n_pages)

	return
}

// SetPrintSettings is a wrapper around the C function gtk_print_operation_set_print_settings.
func (recv *PrintOperation) SetPrintSettings(printSettings *PrintSettings) {
	c_print_settings := (*C.GtkPrintSettings)(C.NULL)
	if printSettings != nil {
		c_print_settings = (*C.GtkPrintSettings)(printSettings.ToC())
	}

	C.gtk_print_operation_set_print_settings((*C.GtkPrintOperation)(recv.native), c_print_settings)

	return
}

// SetShowProgress is a wrapper around the C function gtk_print_operation_set_show_progress.
func (recv *PrintOperation) SetShowProgress(showProgress bool) {
	c_show_progress :=
		boolToGboolean(showProgress)

	C.gtk_print_operation_set_show_progress((*C.GtkPrintOperation)(recv.native), c_show_progress)

	return
}

// SetTrackPrintStatus is a wrapper around the C function gtk_print_operation_set_track_print_status.
func (recv *PrintOperation) SetTrackPrintStatus(trackStatus bool) {
	c_track_status :=
		boolToGboolean(trackStatus)

	C.gtk_print_operation_set_track_print_status((*C.GtkPrintOperation)(recv.native), c_track_status)

	return
}

// SetUnit is a wrapper around the C function gtk_print_operation_set_unit.
func (recv *PrintOperation) SetUnit(unit Unit) {
	c_unit := (C.GtkUnit)(unit)

	C.gtk_print_operation_set_unit((*C.GtkPrintOperation)(recv.native), c_unit)

	return
}

// SetUseFullPage is a wrapper around the C function gtk_print_operation_set_use_full_page.
func (recv *PrintOperation) SetUseFullPage(fullPage bool) {
	c_full_page :=
		boolToGboolean(fullPage)

	C.gtk_print_operation_set_use_full_page((*C.GtkPrintOperation)(recv.native), c_full_page)

	return
}

// PrintOperationPreview returns the PrintOperationPreview interface implemented by PrintOperation
func (recv *PrintOperation) PrintOperationPreview() *PrintOperationPreview {
	return PrintOperationPreviewNewFromC(recv.ToC())
}

// PrintSettings is a wrapper around the C record GtkPrintSettings.
type PrintSettings struct {
	native *C.GtkPrintSettings
}

func PrintSettingsNewFromC(u unsafe.Pointer) *PrintSettings {
	c := (*C.GtkPrintSettings)(u)
	if c == nil {
		return nil
	}

	g := &PrintSettings{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *PrintSettings) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *PrintSettings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintSettings with another PrintSettings, and returns true if they represent the same GObject.
func (recv *PrintSettings) Equals(other *PrintSettings) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *PrintSettings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to PrintSettings.
// Exercise care, as this is a potentially dangerous function if the Object is not a PrintSettings.
func CastToPrintSettings(object *gobject.Object) *PrintSettings {
	return PrintSettingsNewFromC(object.ToC())
}

// PrintSettingsNew is a wrapper around the C function gtk_print_settings_new.
func PrintSettingsNew() *PrintSettings {
	retC := C.gtk_print_settings_new()
	retGo := PrintSettingsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// PrintSettingsNewFromFile is a wrapper around the C function gtk_print_settings_new_from_file.
func PrintSettingsNewFromFile(fileName string) (*PrintSettings, error) {
	c_file_name := C.CString(fileName)
	defer C.free(unsafe.Pointer(c_file_name))

	var cThrowableError *C.GError

	retC := C.gtk_print_settings_new_from_file(c_file_name, &cThrowableError)
	retGo := PrintSettingsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PrintSettingsNewFromKeyFile is a wrapper around the C function gtk_print_settings_new_from_key_file.
func PrintSettingsNewFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PrintSettings, error) {
	c_key_file := (*C.GKeyFile)(C.NULL)
	if keyFile != nil {
		c_key_file = (*C.GKeyFile)(keyFile.ToC())
	}

	c_group_name := C.CString(groupName)
	defer C.free(unsafe.Pointer(c_group_name))

	var cThrowableError *C.GError

	retC := C.gtk_print_settings_new_from_key_file(c_key_file, c_group_name, &cThrowableError)
	retGo := PrintSettingsNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Copy is a wrapper around the C function gtk_print_settings_copy.
func (recv *PrintSettings) Copy() *PrintSettings {
	retC := C.gtk_print_settings_copy((*C.GtkPrintSettings)(recv.native))
	retGo := PrintSettingsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_print_settings_foreach : unsupported parameter func : no type generator for PrintSettingsFunc (GtkPrintSettingsFunc) for param func

// Get is a wrapper around the C function gtk_print_settings_get.
func (recv *PrintSettings) Get(key string) string {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.gtk_print_settings_get((*C.GtkPrintSettings)(recv.native), c_key)
	retGo := C.GoString(retC)

	return retGo
}

// GetBool is a wrapper around the C function gtk_print_settings_get_bool.
func (recv *PrintSettings) GetBool(key string) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.gtk_print_settings_get_bool((*C.GtkPrintSettings)(recv.native), c_key)
	retGo := retC == C.TRUE

	return retGo
}

// GetCollate is a wrapper around the C function gtk_print_settings_get_collate.
func (recv *PrintSettings) GetCollate() bool {
	retC := C.gtk_print_settings_get_collate((*C.GtkPrintSettings)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetDefaultSource is a wrapper around the C function gtk_print_settings_get_default_source.
func (recv *PrintSettings) GetDefaultSource() string {
	retC := C.gtk_print_settings_get_default_source((*C.GtkPrintSettings)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDither is a wrapper around the C function gtk_print_settings_get_dither.
func (recv *PrintSettings) GetDither() string {
	retC := C.gtk_print_settings_get_dither((*C.GtkPrintSettings)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDouble is a wrapper around the C function gtk_print_settings_get_double.
func (recv *PrintSettings) GetDouble(key string) float64 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.gtk_print_settings_get_double((*C.GtkPrintSettings)(recv.native), c_key)
	retGo := (float64)(retC)

	return retGo
}

// GetDoubleWithDefault is a wrapper around the C function gtk_print_settings_get_double_with_default.
func (recv *PrintSettings) GetDoubleWithDefault(key string, def float64) float64 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_def := (C.gdouble)(def)

	retC := C.gtk_print_settings_get_double_with_default((*C.GtkPrintSettings)(recv.native), c_key, c_def)
	retGo := (float64)(retC)

	return retGo
}

// GetDuplex is a wrapper around the C function gtk_print_settings_get_duplex.
func (recv *PrintSettings) GetDuplex() PrintDuplex {
	retC := C.gtk_print_settings_get_duplex((*C.GtkPrintSettings)(recv.native))
	retGo := (PrintDuplex)(retC)

	return retGo
}

// GetFinishings is a wrapper around the C function gtk_print_settings_get_finishings.
func (recv *PrintSettings) GetFinishings() string {
	retC := C.gtk_print_settings_get_finishings((*C.GtkPrintSettings)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetInt is a wrapper around the C function gtk_print_settings_get_int.
func (recv *PrintSettings) GetInt(key string) int32 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.gtk_print_settings_get_int((*C.GtkPrintSettings)(recv.native), c_key)
	retGo := (int32)(retC)

	return retGo
}

// GetIntWithDefault is a wrapper around the C function gtk_print_settings_get_int_with_default.
func (recv *PrintSettings) GetIntWithDefault(key string, def int32) int32 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_def := (C.gint)(def)

	retC := C.gtk_print_settings_get_int_with_default((*C.GtkPrintSettings)(recv.native), c_key, c_def)
	retGo := (int32)(retC)

	return retGo
}

// GetLength is a wrapper around the C function gtk_print_settings_get_length.
func (recv *PrintSettings) GetLength(key string, unit Unit) float64 {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_print_settings_get_length((*C.GtkPrintSettings)(recv.native), c_key, c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetMediaType is a wrapper around the C function gtk_print_settings_get_media_type.
func (recv *PrintSettings) GetMediaType() string {
	retC := C.gtk_print_settings_get_media_type((*C.GtkPrintSettings)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetNCopies is a wrapper around the C function gtk_print_settings_get_n_copies.
func (recv *PrintSettings) GetNCopies() int32 {
	retC := C.gtk_print_settings_get_n_copies((*C.GtkPrintSettings)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetNumberUp is a wrapper around the C function gtk_print_settings_get_number_up.
func (recv *PrintSettings) GetNumberUp() int32 {
	retC := C.gtk_print_settings_get_number_up((*C.GtkPrintSettings)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetOrientation is a wrapper around the C function gtk_print_settings_get_orientation.
func (recv *PrintSettings) GetOrientation() PageOrientation {
	retC := C.gtk_print_settings_get_orientation((*C.GtkPrintSettings)(recv.native))
	retGo := (PageOrientation)(retC)

	return retGo
}

// GetOutputBin is a wrapper around the C function gtk_print_settings_get_output_bin.
func (recv *PrintSettings) GetOutputBin() string {
	retC := C.gtk_print_settings_get_output_bin((*C.GtkPrintSettings)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Unsupported : gtk_print_settings_get_page_ranges : array return type :

// GetPageSet is a wrapper around the C function gtk_print_settings_get_page_set.
func (recv *PrintSettings) GetPageSet() PageSet {
	retC := C.gtk_print_settings_get_page_set((*C.GtkPrintSettings)(recv.native))
	retGo := (PageSet)(retC)

	return retGo
}

// GetPaperHeight is a wrapper around the C function gtk_print_settings_get_paper_height.
func (recv *PrintSettings) GetPaperHeight(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_print_settings_get_paper_height((*C.GtkPrintSettings)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetPaperSize is a wrapper around the C function gtk_print_settings_get_paper_size.
func (recv *PrintSettings) GetPaperSize() *PaperSize {
	retC := C.gtk_print_settings_get_paper_size((*C.GtkPrintSettings)(recv.native))
	retGo := PaperSizeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPaperWidth is a wrapper around the C function gtk_print_settings_get_paper_width.
func (recv *PrintSettings) GetPaperWidth(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_print_settings_get_paper_width((*C.GtkPrintSettings)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetPrintPages is a wrapper around the C function gtk_print_settings_get_print_pages.
func (recv *PrintSettings) GetPrintPages() PrintPages {
	retC := C.gtk_print_settings_get_print_pages((*C.GtkPrintSettings)(recv.native))
	retGo := (PrintPages)(retC)

	return retGo
}

// GetPrinter is a wrapper around the C function gtk_print_settings_get_printer.
func (recv *PrintSettings) GetPrinter() string {
	retC := C.gtk_print_settings_get_printer((*C.GtkPrintSettings)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetQuality is a wrapper around the C function gtk_print_settings_get_quality.
func (recv *PrintSettings) GetQuality() PrintQuality {
	retC := C.gtk_print_settings_get_quality((*C.GtkPrintSettings)(recv.native))
	retGo := (PrintQuality)(retC)

	return retGo
}

// GetResolution is a wrapper around the C function gtk_print_settings_get_resolution.
func (recv *PrintSettings) GetResolution() int32 {
	retC := C.gtk_print_settings_get_resolution((*C.GtkPrintSettings)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetReverse is a wrapper around the C function gtk_print_settings_get_reverse.
func (recv *PrintSettings) GetReverse() bool {
	retC := C.gtk_print_settings_get_reverse((*C.GtkPrintSettings)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetScale is a wrapper around the C function gtk_print_settings_get_scale.
func (recv *PrintSettings) GetScale() float64 {
	retC := C.gtk_print_settings_get_scale((*C.GtkPrintSettings)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetUseColor is a wrapper around the C function gtk_print_settings_get_use_color.
func (recv *PrintSettings) GetUseColor() bool {
	retC := C.gtk_print_settings_get_use_color((*C.GtkPrintSettings)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// HasKey is a wrapper around the C function gtk_print_settings_has_key.
func (recv *PrintSettings) HasKey(key string) bool {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	retC := C.gtk_print_settings_has_key((*C.GtkPrintSettings)(recv.native), c_key)
	retGo := retC == C.TRUE

	return retGo
}

// Set is a wrapper around the C function gtk_print_settings_set.
func (recv *PrintSettings) Set(key string, value string) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := C.CString(value)
	defer C.free(unsafe.Pointer(c_value))

	C.gtk_print_settings_set((*C.GtkPrintSettings)(recv.native), c_key, c_value)

	return
}

// SetBool is a wrapper around the C function gtk_print_settings_set_bool.
func (recv *PrintSettings) SetBool(key string, value bool) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value :=
		boolToGboolean(value)

	C.gtk_print_settings_set_bool((*C.GtkPrintSettings)(recv.native), c_key, c_value)

	return
}

// SetCollate is a wrapper around the C function gtk_print_settings_set_collate.
func (recv *PrintSettings) SetCollate(collate bool) {
	c_collate :=
		boolToGboolean(collate)

	C.gtk_print_settings_set_collate((*C.GtkPrintSettings)(recv.native), c_collate)

	return
}

// SetDefaultSource is a wrapper around the C function gtk_print_settings_set_default_source.
func (recv *PrintSettings) SetDefaultSource(defaultSource string) {
	c_default_source := C.CString(defaultSource)
	defer C.free(unsafe.Pointer(c_default_source))

	C.gtk_print_settings_set_default_source((*C.GtkPrintSettings)(recv.native), c_default_source)

	return
}

// SetDither is a wrapper around the C function gtk_print_settings_set_dither.
func (recv *PrintSettings) SetDither(dither string) {
	c_dither := C.CString(dither)
	defer C.free(unsafe.Pointer(c_dither))

	C.gtk_print_settings_set_dither((*C.GtkPrintSettings)(recv.native), c_dither)

	return
}

// SetDouble is a wrapper around the C function gtk_print_settings_set_double.
func (recv *PrintSettings) SetDouble(key string, value float64) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (C.gdouble)(value)

	C.gtk_print_settings_set_double((*C.GtkPrintSettings)(recv.native), c_key, c_value)

	return
}

// SetDuplex is a wrapper around the C function gtk_print_settings_set_duplex.
func (recv *PrintSettings) SetDuplex(duplex PrintDuplex) {
	c_duplex := (C.GtkPrintDuplex)(duplex)

	C.gtk_print_settings_set_duplex((*C.GtkPrintSettings)(recv.native), c_duplex)

	return
}

// SetFinishings is a wrapper around the C function gtk_print_settings_set_finishings.
func (recv *PrintSettings) SetFinishings(finishings string) {
	c_finishings := C.CString(finishings)
	defer C.free(unsafe.Pointer(c_finishings))

	C.gtk_print_settings_set_finishings((*C.GtkPrintSettings)(recv.native), c_finishings)

	return
}

// SetInt is a wrapper around the C function gtk_print_settings_set_int.
func (recv *PrintSettings) SetInt(key string, value int32) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (C.gint)(value)

	C.gtk_print_settings_set_int((*C.GtkPrintSettings)(recv.native), c_key, c_value)

	return
}

// SetLength is a wrapper around the C function gtk_print_settings_set_length.
func (recv *PrintSettings) SetLength(key string, value float64, unit Unit) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	c_value := (C.gdouble)(value)

	c_unit := (C.GtkUnit)(unit)

	C.gtk_print_settings_set_length((*C.GtkPrintSettings)(recv.native), c_key, c_value, c_unit)

	return
}

// SetMediaType is a wrapper around the C function gtk_print_settings_set_media_type.
func (recv *PrintSettings) SetMediaType(mediaType string) {
	c_media_type := C.CString(mediaType)
	defer C.free(unsafe.Pointer(c_media_type))

	C.gtk_print_settings_set_media_type((*C.GtkPrintSettings)(recv.native), c_media_type)

	return
}

// SetNCopies is a wrapper around the C function gtk_print_settings_set_n_copies.
func (recv *PrintSettings) SetNCopies(numCopies int32) {
	c_num_copies := (C.gint)(numCopies)

	C.gtk_print_settings_set_n_copies((*C.GtkPrintSettings)(recv.native), c_num_copies)

	return
}

// SetNumberUp is a wrapper around the C function gtk_print_settings_set_number_up.
func (recv *PrintSettings) SetNumberUp(numberUp int32) {
	c_number_up := (C.gint)(numberUp)

	C.gtk_print_settings_set_number_up((*C.GtkPrintSettings)(recv.native), c_number_up)

	return
}

// SetOrientation is a wrapper around the C function gtk_print_settings_set_orientation.
func (recv *PrintSettings) SetOrientation(orientation PageOrientation) {
	c_orientation := (C.GtkPageOrientation)(orientation)

	C.gtk_print_settings_set_orientation((*C.GtkPrintSettings)(recv.native), c_orientation)

	return
}

// SetOutputBin is a wrapper around the C function gtk_print_settings_set_output_bin.
func (recv *PrintSettings) SetOutputBin(outputBin string) {
	c_output_bin := C.CString(outputBin)
	defer C.free(unsafe.Pointer(c_output_bin))

	C.gtk_print_settings_set_output_bin((*C.GtkPrintSettings)(recv.native), c_output_bin)

	return
}

// Unsupported : gtk_print_settings_set_page_ranges : unsupported parameter page_ranges :

// SetPageSet is a wrapper around the C function gtk_print_settings_set_page_set.
func (recv *PrintSettings) SetPageSet(pageSet PageSet) {
	c_page_set := (C.GtkPageSet)(pageSet)

	C.gtk_print_settings_set_page_set((*C.GtkPrintSettings)(recv.native), c_page_set)

	return
}

// SetPaperHeight is a wrapper around the C function gtk_print_settings_set_paper_height.
func (recv *PrintSettings) SetPaperHeight(height float64, unit Unit) {
	c_height := (C.gdouble)(height)

	c_unit := (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_height((*C.GtkPrintSettings)(recv.native), c_height, c_unit)

	return
}

// SetPaperSize is a wrapper around the C function gtk_print_settings_set_paper_size.
func (recv *PrintSettings) SetPaperSize(paperSize *PaperSize) {
	c_paper_size := (*C.GtkPaperSize)(C.NULL)
	if paperSize != nil {
		c_paper_size = (*C.GtkPaperSize)(paperSize.ToC())
	}

	C.gtk_print_settings_set_paper_size((*C.GtkPrintSettings)(recv.native), c_paper_size)

	return
}

// SetPaperWidth is a wrapper around the C function gtk_print_settings_set_paper_width.
func (recv *PrintSettings) SetPaperWidth(width float64, unit Unit) {
	c_width := (C.gdouble)(width)

	c_unit := (C.GtkUnit)(unit)

	C.gtk_print_settings_set_paper_width((*C.GtkPrintSettings)(recv.native), c_width, c_unit)

	return
}

// SetPrintPages is a wrapper around the C function gtk_print_settings_set_print_pages.
func (recv *PrintSettings) SetPrintPages(pages PrintPages) {
	c_pages := (C.GtkPrintPages)(pages)

	C.gtk_print_settings_set_print_pages((*C.GtkPrintSettings)(recv.native), c_pages)

	return
}

// SetPrinter is a wrapper around the C function gtk_print_settings_set_printer.
func (recv *PrintSettings) SetPrinter(printer string) {
	c_printer := C.CString(printer)
	defer C.free(unsafe.Pointer(c_printer))

	C.gtk_print_settings_set_printer((*C.GtkPrintSettings)(recv.native), c_printer)

	return
}

// SetQuality is a wrapper around the C function gtk_print_settings_set_quality.
func (recv *PrintSettings) SetQuality(quality PrintQuality) {
	c_quality := (C.GtkPrintQuality)(quality)

	C.gtk_print_settings_set_quality((*C.GtkPrintSettings)(recv.native), c_quality)

	return
}

// SetResolution is a wrapper around the C function gtk_print_settings_set_resolution.
func (recv *PrintSettings) SetResolution(resolution int32) {
	c_resolution := (C.gint)(resolution)

	C.gtk_print_settings_set_resolution((*C.GtkPrintSettings)(recv.native), c_resolution)

	return
}

// SetReverse is a wrapper around the C function gtk_print_settings_set_reverse.
func (recv *PrintSettings) SetReverse(reverse bool) {
	c_reverse :=
		boolToGboolean(reverse)

	C.gtk_print_settings_set_reverse((*C.GtkPrintSettings)(recv.native), c_reverse)

	return
}

// SetScale is a wrapper around the C function gtk_print_settings_set_scale.
func (recv *PrintSettings) SetScale(scale float64) {
	c_scale := (C.gdouble)(scale)

	C.gtk_print_settings_set_scale((*C.GtkPrintSettings)(recv.native), c_scale)

	return
}

// SetUseColor is a wrapper around the C function gtk_print_settings_set_use_color.
func (recv *PrintSettings) SetUseColor(useColor bool) {
	c_use_color :=
		boolToGboolean(useColor)

	C.gtk_print_settings_set_use_color((*C.GtkPrintSettings)(recv.native), c_use_color)

	return
}

// ToFile is a wrapper around the C function gtk_print_settings_to_file.
func (recv *PrintSettings) ToFile(fileName string) (bool, error) {
	c_file_name := C.CString(fileName)
	defer C.free(unsafe.Pointer(c_file_name))

	var cThrowableError *C.GError

	retC := C.gtk_print_settings_to_file((*C.GtkPrintSettings)(recv.native), c_file_name, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// ToKeyFile is a wrapper around the C function gtk_print_settings_to_key_file.
func (recv *PrintSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	c_key_file := (*C.GKeyFile)(C.NULL)
	if keyFile != nil {
		c_key_file = (*C.GKeyFile)(keyFile.ToC())
	}

	c_group_name := C.CString(groupName)
	defer C.free(unsafe.Pointer(c_group_name))

	C.gtk_print_settings_to_key_file((*C.GtkPrintSettings)(recv.native), c_key_file, c_group_name)

	return
}

// Unset is a wrapper around the C function gtk_print_settings_unset.
func (recv *PrintSettings) Unset(key string) {
	c_key := C.CString(key)
	defer C.free(unsafe.Pointer(c_key))

	C.gtk_print_settings_unset((*C.GtkPrintSettings)(recv.native), c_key)

	return
}

// ProgressBar is a wrapper around the C record GtkProgressBar.
type ProgressBar struct {
	native *C.GtkProgressBar
	// parent : record
	// Private : priv
}

func ProgressBarNewFromC(u unsafe.Pointer) *ProgressBar {
	c := (*C.GtkProgressBar)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ProgressBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ProgressBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProgressBar with another ProgressBar, and returns true if they represent the same GObject.
func (recv *ProgressBar) Equals(other *ProgressBar) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *ProgressBar) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ProgressBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ProgressBar) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to ProgressBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProgressBar.
func CastToProgressBar(object *gobject.Object) *ProgressBar {
	return ProgressBarNewFromC(object.ToC())
}

// ProgressBarNew is a wrapper around the C function gtk_progress_bar_new.
func ProgressBarNew() *ProgressBar {
	retC := C.gtk_progress_bar_new()
	retGo := ProgressBarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetEllipsize is a wrapper around the C function gtk_progress_bar_get_ellipsize.
func (recv *ProgressBar) GetEllipsize() pango.EllipsizeMode {
	retC := C.gtk_progress_bar_get_ellipsize((*C.GtkProgressBar)(recv.native))
	retGo := (pango.EllipsizeMode)(retC)

	return retGo
}

// GetFraction is a wrapper around the C function gtk_progress_bar_get_fraction.
func (recv *ProgressBar) GetFraction() float64 {
	retC := C.gtk_progress_bar_get_fraction((*C.GtkProgressBar)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetInverted is a wrapper around the C function gtk_progress_bar_get_inverted.
func (recv *ProgressBar) GetInverted() bool {
	retC := C.gtk_progress_bar_get_inverted((*C.GtkProgressBar)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPulseStep is a wrapper around the C function gtk_progress_bar_get_pulse_step.
func (recv *ProgressBar) GetPulseStep() float64 {
	retC := C.gtk_progress_bar_get_pulse_step((*C.GtkProgressBar)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetText is a wrapper around the C function gtk_progress_bar_get_text.
func (recv *ProgressBar) GetText() string {
	retC := C.gtk_progress_bar_get_text((*C.GtkProgressBar)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// Pulse is a wrapper around the C function gtk_progress_bar_pulse.
func (recv *ProgressBar) Pulse() {
	C.gtk_progress_bar_pulse((*C.GtkProgressBar)(recv.native))

	return
}

// SetEllipsize is a wrapper around the C function gtk_progress_bar_set_ellipsize.
func (recv *ProgressBar) SetEllipsize(mode pango.EllipsizeMode) {
	c_mode := (C.PangoEllipsizeMode)(mode)

	C.gtk_progress_bar_set_ellipsize((*C.GtkProgressBar)(recv.native), c_mode)

	return
}

// SetFraction is a wrapper around the C function gtk_progress_bar_set_fraction.
func (recv *ProgressBar) SetFraction(fraction float64) {
	c_fraction := (C.gdouble)(fraction)

	C.gtk_progress_bar_set_fraction((*C.GtkProgressBar)(recv.native), c_fraction)

	return
}

// SetInverted is a wrapper around the C function gtk_progress_bar_set_inverted.
func (recv *ProgressBar) SetInverted(inverted bool) {
	c_inverted :=
		boolToGboolean(inverted)

	C.gtk_progress_bar_set_inverted((*C.GtkProgressBar)(recv.native), c_inverted)

	return
}

// SetPulseStep is a wrapper around the C function gtk_progress_bar_set_pulse_step.
func (recv *ProgressBar) SetPulseStep(fraction float64) {
	c_fraction := (C.gdouble)(fraction)

	C.gtk_progress_bar_set_pulse_step((*C.GtkProgressBar)(recv.native), c_fraction)

	return
}

// SetText is a wrapper around the C function gtk_progress_bar_set_text.
func (recv *ProgressBar) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_progress_bar_set_text((*C.GtkProgressBar)(recv.native), c_text)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ProgressBar
func (recv *ProgressBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ProgressBar
func (recv *ProgressBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ProgressBar
func (recv *ProgressBar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ProgressBarAccessible is a wrapper around the C record GtkProgressBarAccessible.
type ProgressBarAccessible struct {
	native *C.GtkProgressBarAccessible
	// parent : record
	// priv : record
}

func ProgressBarAccessibleNewFromC(u unsafe.Pointer) *ProgressBarAccessible {
	c := (*C.GtkProgressBarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBarAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ProgressBarAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ProgressBarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProgressBarAccessible with another ProgressBarAccessible, and returns true if they represent the same GObject.
func (recv *ProgressBarAccessible) Equals(other *ProgressBarAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ProgressBarAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *ProgressBarAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ProgressBarAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ProgressBarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ProgressBarAccessible.
func CastToProgressBarAccessible(object *gobject.Object) *ProgressBarAccessible {
	return ProgressBarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ProgressBarAccessible
func (recv *ProgressBarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ProgressBarAccessible
func (recv *ProgressBarAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// RadioAction is a wrapper around the C record GtkRadioAction.
type RadioAction struct {
	native *C.GtkRadioAction
	// parent : record
	// Private : private_data
}

func RadioActionNewFromC(u unsafe.Pointer) *RadioAction {
	c := (*C.GtkRadioAction)(u)
	if c == nil {
		return nil
	}

	g := &RadioAction{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioAction) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioAction with another RadioAction, and returns true if they represent the same GObject.
func (recv *RadioAction) Equals(other *RadioAction) bool {
	return other.ToC() == recv.ToC()
}

// ToggleAction upcasts to *ToggleAction
func (recv *RadioAction) ToggleAction() *ToggleAction {
	return ToggleActionNewFromC(unsafe.Pointer(recv.native))
}

// Action upcasts to *Action
func (recv *RadioAction) Action() *Action {
	return recv.ToggleAction().Action()
}

// Object upcasts to *Object
func (recv *RadioAction) Object() *gobject.Object {
	return recv.ToggleAction().Object()
}

// CastToWidget down casts any arbitrary Object to RadioAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioAction.
func CastToRadioAction(object *gobject.Object) *RadioAction {
	return RadioActionNewFromC(object.ToC())
}

type signalRadioActionChangedDetail struct {
	callback  RadioActionSignalChangedCallback
	handlerID C.gulong
}

var signalRadioActionChangedId int
var signalRadioActionChangedMap = make(map[int]signalRadioActionChangedDetail)
var signalRadioActionChangedLock sync.RWMutex

// RadioActionSignalChangedCallback is a callback function for a 'changed' signal emitted from a RadioAction.
type RadioActionSignalChangedCallback func(current *RadioAction)

/*
ConnectChanged connects the callback to the 'changed' signal for the RadioAction.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *RadioAction) ConnectChanged(callback RadioActionSignalChangedCallback) int {
	signalRadioActionChangedLock.Lock()
	defer signalRadioActionChangedLock.Unlock()

	signalRadioActionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RadioAction_signal_connect_changed(instance, C.gpointer(uintptr(signalRadioActionChangedId)))

	detail := signalRadioActionChangedDetail{callback, handlerID}
	signalRadioActionChangedMap[signalRadioActionChangedId] = detail

	return signalRadioActionChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the RadioAction.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *RadioAction) DisconnectChanged(connectionID int) {
	signalRadioActionChangedLock.Lock()
	defer signalRadioActionChangedLock.Unlock()

	detail, exists := signalRadioActionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRadioActionChangedMap, connectionID)
}

//export radioaction_changedHandler
func radioaction_changedHandler(_ *C.GObject, c_current *C.GtkRadioAction, data C.gpointer) {
	signalRadioActionChangedLock.RLock()
	defer signalRadioActionChangedLock.RUnlock()

	current := RadioActionNewFromC(unsafe.Pointer(c_current))

	index := int(uintptr(data))
	callback := signalRadioActionChangedMap[index].callback
	callback(current)
}

// RadioActionNew is a wrapper around the C function gtk_radio_action_new.
func RadioActionNew(name string, label string, tooltip string, stockId string, value int32) *RadioAction {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_tooltip := C.CString(tooltip)
	defer C.free(unsafe.Pointer(c_tooltip))

	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_value := (C.gint)(value)

	retC := C.gtk_radio_action_new(c_name, c_label, c_tooltip, c_stock_id, c_value)
	retGo := RadioActionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetCurrentValue is a wrapper around the C function gtk_radio_action_get_current_value.
func (recv *RadioAction) GetCurrentValue() int32 {
	retC := C.gtk_radio_action_get_current_value((*C.GtkRadioAction)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetGroup is a wrapper around the C function gtk_radio_action_get_group.
func (recv *RadioAction) GetGroup() *glib.SList {
	retC := C.gtk_radio_action_get_group((*C.GtkRadioAction)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetCurrentValue is a wrapper around the C function gtk_radio_action_set_current_value.
func (recv *RadioAction) SetCurrentValue(currentValue int32) {
	c_current_value := (C.gint)(currentValue)

	C.gtk_radio_action_set_current_value((*C.GtkRadioAction)(recv.native), c_current_value)

	return
}

// SetGroup is a wrapper around the C function gtk_radio_action_set_group.
func (recv *RadioAction) SetGroup(group *glib.SList) {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	C.gtk_radio_action_set_group((*C.GtkRadioAction)(recv.native), c_group)

	return
}

// Buildable returns the Buildable interface implemented by RadioAction
func (recv *RadioAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioButton is a wrapper around the C record GtkRadioButton.
type RadioButton struct {
	native *C.GtkRadioButton
	// check_button : record
	// Private : priv
}

func RadioButtonNewFromC(u unsafe.Pointer) *RadioButton {
	c := (*C.GtkRadioButton)(u)
	if c == nil {
		return nil
	}

	g := &RadioButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioButton with another RadioButton, and returns true if they represent the same GObject.
func (recv *RadioButton) Equals(other *RadioButton) bool {
	return other.ToC() == recv.ToC()
}

// CheckButton upcasts to *CheckButton
func (recv *RadioButton) CheckButton() *CheckButton {
	return CheckButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToggleButton upcasts to *ToggleButton
func (recv *RadioButton) ToggleButton() *ToggleButton {
	return recv.CheckButton().ToggleButton()
}

// Button upcasts to *Button
func (recv *RadioButton) Button() *Button {
	return recv.CheckButton().Button()
}

// Bin upcasts to *Bin
func (recv *RadioButton) Bin() *Bin {
	return recv.CheckButton().Bin()
}

// Container upcasts to *Container
func (recv *RadioButton) Container() *Container {
	return recv.CheckButton().Container()
}

// Widget upcasts to *Widget
func (recv *RadioButton) Widget() *Widget {
	return recv.CheckButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CheckButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioButton) Object() *gobject.Object {
	return recv.CheckButton().Object()
}

// CastToWidget down casts any arbitrary Object to RadioButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioButton.
func CastToRadioButton(object *gobject.Object) *RadioButton {
	return RadioButtonNewFromC(object.ToC())
}

type signalRadioButtonGroupChangedDetail struct {
	callback  RadioButtonSignalGroupChangedCallback
	handlerID C.gulong
}

var signalRadioButtonGroupChangedId int
var signalRadioButtonGroupChangedMap = make(map[int]signalRadioButtonGroupChangedDetail)
var signalRadioButtonGroupChangedLock sync.RWMutex

// RadioButtonSignalGroupChangedCallback is a callback function for a 'group-changed' signal emitted from a RadioButton.
type RadioButtonSignalGroupChangedCallback func()

/*
ConnectGroupChanged connects the callback to the 'group-changed' signal for the RadioButton.

The returned value represents the connection, and may be passed to DisconnectGroupChanged to remove it.
*/
func (recv *RadioButton) ConnectGroupChanged(callback RadioButtonSignalGroupChangedCallback) int {
	signalRadioButtonGroupChangedLock.Lock()
	defer signalRadioButtonGroupChangedLock.Unlock()

	signalRadioButtonGroupChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RadioButton_signal_connect_group_changed(instance, C.gpointer(uintptr(signalRadioButtonGroupChangedId)))

	detail := signalRadioButtonGroupChangedDetail{callback, handlerID}
	signalRadioButtonGroupChangedMap[signalRadioButtonGroupChangedId] = detail

	return signalRadioButtonGroupChangedId
}

/*
DisconnectGroupChanged disconnects a callback from the 'group-changed' signal for the RadioButton.

The connectionID should be a value returned from a call to ConnectGroupChanged.
*/
func (recv *RadioButton) DisconnectGroupChanged(connectionID int) {
	signalRadioButtonGroupChangedLock.Lock()
	defer signalRadioButtonGroupChangedLock.Unlock()

	detail, exists := signalRadioButtonGroupChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRadioButtonGroupChangedMap, connectionID)
}

//export radiobutton_groupChangedHandler
func radiobutton_groupChangedHandler(_ *C.GObject, data C.gpointer) {
	signalRadioButtonGroupChangedLock.RLock()
	defer signalRadioButtonGroupChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalRadioButtonGroupChangedMap[index].callback
	callback()
}

// RadioButtonNew is a wrapper around the C function gtk_radio_button_new.
func RadioButtonNew(group *glib.SList) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	retC := C.gtk_radio_button_new(c_group)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioButtonNewFromWidget is a wrapper around the C function gtk_radio_button_new_from_widget.
func RadioButtonNewFromWidget(radioGroupMember *RadioButton) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	retC := C.gtk_radio_button_new_from_widget(c_radio_group_member)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioButtonNewWithLabel is a wrapper around the C function gtk_radio_button_new_with_label.
func RadioButtonNewWithLabel(group *glib.SList, label string) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_label(c_group, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioButtonNewWithLabelFromWidget is a wrapper around the C function gtk_radio_button_new_with_label_from_widget.
func RadioButtonNewWithLabelFromWidget(radioGroupMember *RadioButton, label string) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_label_from_widget(c_radio_group_member, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioButtonNewWithMnemonic is a wrapper around the C function gtk_radio_button_new_with_mnemonic.
func RadioButtonNewWithMnemonic(group *glib.SList, label string) *RadioButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_mnemonic(c_group, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioButtonNewWithMnemonicFromWidget is a wrapper around the C function gtk_radio_button_new_with_mnemonic_from_widget.
func RadioButtonNewWithMnemonicFromWidget(radioGroupMember *RadioButton, label string) *RadioButton {
	c_radio_group_member := (*C.GtkRadioButton)(C.NULL)
	if radioGroupMember != nil {
		c_radio_group_member = (*C.GtkRadioButton)(radioGroupMember.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_button_new_with_mnemonic_from_widget(c_radio_group_member, c_label)
	retGo := RadioButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetGroup is a wrapper around the C function gtk_radio_button_get_group.
func (recv *RadioButton) GetGroup() *glib.SList {
	retC := C.gtk_radio_button_get_group((*C.GtkRadioButton)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetGroup is a wrapper around the C function gtk_radio_button_set_group.
func (recv *RadioButton) SetGroup(group *glib.SList) {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	C.gtk_radio_button_set_group((*C.GtkRadioButton)(recv.native), c_group)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioButton
func (recv *RadioButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioButton
func (recv *RadioButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioButton
func (recv *RadioButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioButton
func (recv *RadioButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioButtonAccessible is a wrapper around the C record GtkRadioButtonAccessible.
type RadioButtonAccessible struct {
	native *C.GtkRadioButtonAccessible
	// parent : record
	// priv : record
}

func RadioButtonAccessibleNewFromC(u unsafe.Pointer) *RadioButtonAccessible {
	c := (*C.GtkRadioButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RadioButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioButtonAccessible with another RadioButtonAccessible, and returns true if they represent the same GObject.
func (recv *RadioButtonAccessible) Equals(other *RadioButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButtonAccessible upcasts to *ToggleButtonAccessible
func (recv *RadioButtonAccessible) ToggleButtonAccessible() *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *RadioButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return recv.ToggleButtonAccessible().ButtonAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *RadioButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ToggleButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RadioButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ToggleButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *RadioButtonAccessible) Accessible() *Accessible {
	return recv.ToggleButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RadioButtonAccessible) Object() *atk.Object {
	return recv.ToggleButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to RadioButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioButtonAccessible.
func CastToRadioButtonAccessible(object *gobject.Object) *RadioButtonAccessible {
	return RadioButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by RadioButtonAccessible
func (recv *RadioButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// RadioMenuItem is a wrapper around the C record GtkRadioMenuItem.
type RadioMenuItem struct {
	native *C.GtkRadioMenuItem
	// check_menu_item : record
	// Private : priv
}

func RadioMenuItemNewFromC(u unsafe.Pointer) *RadioMenuItem {
	c := (*C.GtkRadioMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioMenuItem with another RadioMenuItem, and returns true if they represent the same GObject.
func (recv *RadioMenuItem) Equals(other *RadioMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// CheckMenuItem upcasts to *CheckMenuItem
func (recv *RadioMenuItem) CheckMenuItem() *CheckMenuItem {
	return CheckMenuItemNewFromC(unsafe.Pointer(recv.native))
}

// MenuItem upcasts to *MenuItem
func (recv *RadioMenuItem) MenuItem() *MenuItem {
	return recv.CheckMenuItem().MenuItem()
}

// Bin upcasts to *Bin
func (recv *RadioMenuItem) Bin() *Bin {
	return recv.CheckMenuItem().Bin()
}

// Container upcasts to *Container
func (recv *RadioMenuItem) Container() *Container {
	return recv.CheckMenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *RadioMenuItem) Widget() *Widget {
	return recv.CheckMenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.CheckMenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioMenuItem) Object() *gobject.Object {
	return recv.CheckMenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to RadioMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioMenuItem.
func CastToRadioMenuItem(object *gobject.Object) *RadioMenuItem {
	return RadioMenuItemNewFromC(object.ToC())
}

type signalRadioMenuItemGroupChangedDetail struct {
	callback  RadioMenuItemSignalGroupChangedCallback
	handlerID C.gulong
}

var signalRadioMenuItemGroupChangedId int
var signalRadioMenuItemGroupChangedMap = make(map[int]signalRadioMenuItemGroupChangedDetail)
var signalRadioMenuItemGroupChangedLock sync.RWMutex

// RadioMenuItemSignalGroupChangedCallback is a callback function for a 'group-changed' signal emitted from a RadioMenuItem.
type RadioMenuItemSignalGroupChangedCallback func()

/*
ConnectGroupChanged connects the callback to the 'group-changed' signal for the RadioMenuItem.

The returned value represents the connection, and may be passed to DisconnectGroupChanged to remove it.
*/
func (recv *RadioMenuItem) ConnectGroupChanged(callback RadioMenuItemSignalGroupChangedCallback) int {
	signalRadioMenuItemGroupChangedLock.Lock()
	defer signalRadioMenuItemGroupChangedLock.Unlock()

	signalRadioMenuItemGroupChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RadioMenuItem_signal_connect_group_changed(instance, C.gpointer(uintptr(signalRadioMenuItemGroupChangedId)))

	detail := signalRadioMenuItemGroupChangedDetail{callback, handlerID}
	signalRadioMenuItemGroupChangedMap[signalRadioMenuItemGroupChangedId] = detail

	return signalRadioMenuItemGroupChangedId
}

/*
DisconnectGroupChanged disconnects a callback from the 'group-changed' signal for the RadioMenuItem.

The connectionID should be a value returned from a call to ConnectGroupChanged.
*/
func (recv *RadioMenuItem) DisconnectGroupChanged(connectionID int) {
	signalRadioMenuItemGroupChangedLock.Lock()
	defer signalRadioMenuItemGroupChangedLock.Unlock()

	detail, exists := signalRadioMenuItemGroupChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRadioMenuItemGroupChangedMap, connectionID)
}

//export radiomenuitem_groupChangedHandler
func radiomenuitem_groupChangedHandler(_ *C.GObject, data C.gpointer) {
	signalRadioMenuItemGroupChangedLock.RLock()
	defer signalRadioMenuItemGroupChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalRadioMenuItemGroupChangedMap[index].callback
	callback()
}

// RadioMenuItemNew is a wrapper around the C function gtk_radio_menu_item_new.
func RadioMenuItemNew(group *glib.SList) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	retC := C.gtk_radio_menu_item_new(c_group)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioMenuItemNewFromWidget is a wrapper around the C function gtk_radio_menu_item_new_from_widget.
func RadioMenuItemNewFromWidget(group *RadioMenuItem) *RadioMenuItem {
	c_group := (*C.GtkRadioMenuItem)(C.NULL)
	if group != nil {
		c_group = (*C.GtkRadioMenuItem)(group.ToC())
	}

	retC := C.gtk_radio_menu_item_new_from_widget(c_group)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioMenuItemNewWithLabel is a wrapper around the C function gtk_radio_menu_item_new_with_label.
func RadioMenuItemNewWithLabel(group *glib.SList, label string) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_menu_item_new_with_label(c_group, c_label)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioMenuItemNewWithLabelFromWidget is a wrapper around the C function gtk_radio_menu_item_new_with_label_from_widget.
func RadioMenuItemNewWithLabelFromWidget(group *RadioMenuItem, label string) *RadioMenuItem {
	c_group := (*C.GtkRadioMenuItem)(C.NULL)
	if group != nil {
		c_group = (*C.GtkRadioMenuItem)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_menu_item_new_with_label_from_widget(c_group, c_label)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioMenuItemNewWithMnemonic is a wrapper around the C function gtk_radio_menu_item_new_with_mnemonic.
func RadioMenuItemNewWithMnemonic(group *glib.SList, label string) *RadioMenuItem {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_menu_item_new_with_mnemonic(c_group, c_label)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioMenuItemNewWithMnemonicFromWidget is a wrapper around the C function gtk_radio_menu_item_new_with_mnemonic_from_widget.
func RadioMenuItemNewWithMnemonicFromWidget(group *RadioMenuItem, label string) *RadioMenuItem {
	c_group := (*C.GtkRadioMenuItem)(C.NULL)
	if group != nil {
		c_group = (*C.GtkRadioMenuItem)(group.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_radio_menu_item_new_with_mnemonic_from_widget(c_group, c_label)
	retGo := RadioMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetGroup is a wrapper around the C function gtk_radio_menu_item_get_group.
func (recv *RadioMenuItem) GetGroup() *glib.SList {
	retC := C.gtk_radio_menu_item_get_group((*C.GtkRadioMenuItem)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetGroup is a wrapper around the C function gtk_radio_menu_item_set_group.
func (recv *RadioMenuItem) SetGroup(group *glib.SList) {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	C.gtk_radio_menu_item_set_group((*C.GtkRadioMenuItem)(recv.native), c_group)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioMenuItem
func (recv *RadioMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioMenuItem
func (recv *RadioMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RadioMenuItemAccessible is a wrapper around the C record GtkRadioMenuItemAccessible.
type RadioMenuItemAccessible struct {
	native *C.GtkRadioMenuItemAccessible
	// parent : record
	// priv : record
}

func RadioMenuItemAccessibleNewFromC(u unsafe.Pointer) *RadioMenuItemAccessible {
	c := (*C.GtkRadioMenuItemAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItemAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioMenuItemAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioMenuItemAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioMenuItemAccessible with another RadioMenuItemAccessible, and returns true if they represent the same GObject.
func (recv *RadioMenuItemAccessible) Equals(other *RadioMenuItemAccessible) bool {
	return other.ToC() == recv.ToC()
}

// CheckMenuItemAccessible upcasts to *CheckMenuItemAccessible
func (recv *RadioMenuItemAccessible) CheckMenuItemAccessible() *CheckMenuItemAccessible {
	return CheckMenuItemAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// MenuItemAccessible upcasts to *MenuItemAccessible
func (recv *RadioMenuItemAccessible) MenuItemAccessible() *MenuItemAccessible {
	return recv.CheckMenuItemAccessible().MenuItemAccessible()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *RadioMenuItemAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.CheckMenuItemAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RadioMenuItemAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.CheckMenuItemAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *RadioMenuItemAccessible) Accessible() *Accessible {
	return recv.CheckMenuItemAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RadioMenuItemAccessible) Object() *atk.Object {
	return recv.CheckMenuItemAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to RadioMenuItemAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioMenuItemAccessible.
func CastToRadioMenuItemAccessible(object *gobject.Object) *RadioMenuItemAccessible {
	return RadioMenuItemAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by RadioMenuItemAccessible
func (recv *RadioMenuItemAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// RadioToolButton is a wrapper around the C record GtkRadioToolButton.
type RadioToolButton struct {
	native *C.GtkRadioToolButton
	// parent : record
}

func RadioToolButtonNewFromC(u unsafe.Pointer) *RadioToolButton {
	c := (*C.GtkRadioToolButton)(u)
	if c == nil {
		return nil
	}

	g := &RadioToolButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RadioToolButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RadioToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioToolButton with another RadioToolButton, and returns true if they represent the same GObject.
func (recv *RadioToolButton) Equals(other *RadioToolButton) bool {
	return other.ToC() == recv.ToC()
}

// ToggleToolButton upcasts to *ToggleToolButton
func (recv *RadioToolButton) ToggleToolButton() *ToggleToolButton {
	return ToggleToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolButton upcasts to *ToolButton
func (recv *RadioToolButton) ToolButton() *ToolButton {
	return recv.ToggleToolButton().ToolButton()
}

// ToolItem upcasts to *ToolItem
func (recv *RadioToolButton) ToolItem() *ToolItem {
	return recv.ToggleToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *RadioToolButton) Bin() *Bin {
	return recv.ToggleToolButton().Bin()
}

// Container upcasts to *Container
func (recv *RadioToolButton) Container() *Container {
	return recv.ToggleToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *RadioToolButton) Widget() *Widget {
	return recv.ToggleToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RadioToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToggleToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RadioToolButton) Object() *gobject.Object {
	return recv.ToggleToolButton().Object()
}

// CastToWidget down casts any arbitrary Object to RadioToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a RadioToolButton.
func CastToRadioToolButton(object *gobject.Object) *RadioToolButton {
	return RadioToolButtonNewFromC(object.ToC())
}

// RadioToolButtonNew is a wrapper around the C function gtk_radio_tool_button_new.
func RadioToolButtonNew(group *glib.SList) *RadioToolButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	retC := C.gtk_radio_tool_button_new(c_group)
	retGo := RadioToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioToolButtonNewFromStock is a wrapper around the C function gtk_radio_tool_button_new_from_stock.
func RadioToolButtonNewFromStock(group *glib.SList, stockId string) *RadioToolButton {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_radio_tool_button_new_from_stock(c_group, c_stock_id)
	retGo := RadioToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioToolButtonNewFromWidget is a wrapper around the C function gtk_radio_tool_button_new_from_widget.
func RadioToolButtonNewFromWidget(group *RadioToolButton) *RadioToolButton {
	c_group := (*C.GtkRadioToolButton)(C.NULL)
	if group != nil {
		c_group = (*C.GtkRadioToolButton)(group.ToC())
	}

	retC := C.gtk_radio_tool_button_new_from_widget(c_group)
	retGo := RadioToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RadioToolButtonNewWithStockFromWidget is a wrapper around the C function gtk_radio_tool_button_new_with_stock_from_widget.
func RadioToolButtonNewWithStockFromWidget(group *RadioToolButton, stockId string) *RadioToolButton {
	c_group := (*C.GtkRadioToolButton)(C.NULL)
	if group != nil {
		c_group = (*C.GtkRadioToolButton)(group.ToC())
	}

	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_radio_tool_button_new_with_stock_from_widget(c_group, c_stock_id)
	retGo := RadioToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetGroup is a wrapper around the C function gtk_radio_tool_button_get_group.
func (recv *RadioToolButton) GetGroup() *glib.SList {
	retC := C.gtk_radio_tool_button_get_group((*C.GtkRadioToolButton)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetGroup is a wrapper around the C function gtk_radio_tool_button_set_group.
func (recv *RadioToolButton) SetGroup(group *glib.SList) {
	c_group := (*C.GSList)(C.NULL)
	if group != nil {
		c_group = (*C.GSList)(group.ToC())
	}

	C.gtk_radio_tool_button_set_group((*C.GtkRadioToolButton)(recv.native), c_group)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by RadioToolButton
func (recv *RadioToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by RadioToolButton
func (recv *RadioToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RadioToolButton
func (recv *RadioToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RadioToolButton
func (recv *RadioToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Range is a wrapper around the C record GtkRange.
type Range struct {
	native *C.GtkRange
	// widget : record
	// priv : record
}

func RangeNewFromC(u unsafe.Pointer) *Range {
	c := (*C.GtkRange)(u)
	if c == nil {
		return nil
	}

	g := &Range{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Range) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Range) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Range with another Range, and returns true if they represent the same GObject.
func (recv *Range) Equals(other *Range) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Range) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Range) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Range) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Range.
// Exercise care, as this is a potentially dangerous function if the Object is not a Range.
func CastToRange(object *gobject.Object) *Range {
	return RangeNewFromC(object.ToC())
}

type signalRangeAdjustBoundsDetail struct {
	callback  RangeSignalAdjustBoundsCallback
	handlerID C.gulong
}

var signalRangeAdjustBoundsId int
var signalRangeAdjustBoundsMap = make(map[int]signalRangeAdjustBoundsDetail)
var signalRangeAdjustBoundsLock sync.RWMutex

// RangeSignalAdjustBoundsCallback is a callback function for a 'adjust-bounds' signal emitted from a Range.
type RangeSignalAdjustBoundsCallback func(value float64)

/*
ConnectAdjustBounds connects the callback to the 'adjust-bounds' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectAdjustBounds to remove it.
*/
func (recv *Range) ConnectAdjustBounds(callback RangeSignalAdjustBoundsCallback) int {
	signalRangeAdjustBoundsLock.Lock()
	defer signalRangeAdjustBoundsLock.Unlock()

	signalRangeAdjustBoundsId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_adjust_bounds(instance, C.gpointer(uintptr(signalRangeAdjustBoundsId)))

	detail := signalRangeAdjustBoundsDetail{callback, handlerID}
	signalRangeAdjustBoundsMap[signalRangeAdjustBoundsId] = detail

	return signalRangeAdjustBoundsId
}

/*
DisconnectAdjustBounds disconnects a callback from the 'adjust-bounds' signal for the Range.

The connectionID should be a value returned from a call to ConnectAdjustBounds.
*/
func (recv *Range) DisconnectAdjustBounds(connectionID int) {
	signalRangeAdjustBoundsLock.Lock()
	defer signalRangeAdjustBoundsLock.Unlock()

	detail, exists := signalRangeAdjustBoundsMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeAdjustBoundsMap, connectionID)
}

//export range_adjustBoundsHandler
func range_adjustBoundsHandler(_ *C.GObject, c_value C.gdouble, data C.gpointer) {
	signalRangeAdjustBoundsLock.RLock()
	defer signalRangeAdjustBoundsLock.RUnlock()

	value := float64(c_value)

	index := int(uintptr(data))
	callback := signalRangeAdjustBoundsMap[index].callback
	callback(value)
}

type signalRangeChangeValueDetail struct {
	callback  RangeSignalChangeValueCallback
	handlerID C.gulong
}

var signalRangeChangeValueId int
var signalRangeChangeValueMap = make(map[int]signalRangeChangeValueDetail)
var signalRangeChangeValueLock sync.RWMutex

// RangeSignalChangeValueCallback is a callback function for a 'change-value' signal emitted from a Range.
type RangeSignalChangeValueCallback func(scroll ScrollType, value float64) bool

/*
ConnectChangeValue connects the callback to the 'change-value' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectChangeValue to remove it.
*/
func (recv *Range) ConnectChangeValue(callback RangeSignalChangeValueCallback) int {
	signalRangeChangeValueLock.Lock()
	defer signalRangeChangeValueLock.Unlock()

	signalRangeChangeValueId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_change_value(instance, C.gpointer(uintptr(signalRangeChangeValueId)))

	detail := signalRangeChangeValueDetail{callback, handlerID}
	signalRangeChangeValueMap[signalRangeChangeValueId] = detail

	return signalRangeChangeValueId
}

/*
DisconnectChangeValue disconnects a callback from the 'change-value' signal for the Range.

The connectionID should be a value returned from a call to ConnectChangeValue.
*/
func (recv *Range) DisconnectChangeValue(connectionID int) {
	signalRangeChangeValueLock.Lock()
	defer signalRangeChangeValueLock.Unlock()

	detail, exists := signalRangeChangeValueMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeChangeValueMap, connectionID)
}

//export range_changeValueHandler
func range_changeValueHandler(_ *C.GObject, c_scroll C.GtkScrollType, c_value C.gdouble, data C.gpointer) C.gboolean {
	signalRangeChangeValueLock.RLock()
	defer signalRangeChangeValueLock.RUnlock()

	scroll := ScrollType(c_scroll)

	value := float64(c_value)

	index := int(uintptr(data))
	callback := signalRangeChangeValueMap[index].callback
	retGo := callback(scroll, value)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalRangeMoveSliderDetail struct {
	callback  RangeSignalMoveSliderCallback
	handlerID C.gulong
}

var signalRangeMoveSliderId int
var signalRangeMoveSliderMap = make(map[int]signalRangeMoveSliderDetail)
var signalRangeMoveSliderLock sync.RWMutex

// RangeSignalMoveSliderCallback is a callback function for a 'move-slider' signal emitted from a Range.
type RangeSignalMoveSliderCallback func(step ScrollType)

/*
ConnectMoveSlider connects the callback to the 'move-slider' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectMoveSlider to remove it.
*/
func (recv *Range) ConnectMoveSlider(callback RangeSignalMoveSliderCallback) int {
	signalRangeMoveSliderLock.Lock()
	defer signalRangeMoveSliderLock.Unlock()

	signalRangeMoveSliderId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_move_slider(instance, C.gpointer(uintptr(signalRangeMoveSliderId)))

	detail := signalRangeMoveSliderDetail{callback, handlerID}
	signalRangeMoveSliderMap[signalRangeMoveSliderId] = detail

	return signalRangeMoveSliderId
}

/*
DisconnectMoveSlider disconnects a callback from the 'move-slider' signal for the Range.

The connectionID should be a value returned from a call to ConnectMoveSlider.
*/
func (recv *Range) DisconnectMoveSlider(connectionID int) {
	signalRangeMoveSliderLock.Lock()
	defer signalRangeMoveSliderLock.Unlock()

	detail, exists := signalRangeMoveSliderMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeMoveSliderMap, connectionID)
}

//export range_moveSliderHandler
func range_moveSliderHandler(_ *C.GObject, c_step C.GtkScrollType, data C.gpointer) {
	signalRangeMoveSliderLock.RLock()
	defer signalRangeMoveSliderLock.RUnlock()

	step := ScrollType(c_step)

	index := int(uintptr(data))
	callback := signalRangeMoveSliderMap[index].callback
	callback(step)
}

type signalRangeValueChangedDetail struct {
	callback  RangeSignalValueChangedCallback
	handlerID C.gulong
}

var signalRangeValueChangedId int
var signalRangeValueChangedMap = make(map[int]signalRangeValueChangedDetail)
var signalRangeValueChangedLock sync.RWMutex

// RangeSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a Range.
type RangeSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the Range.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *Range) ConnectValueChanged(callback RangeSignalValueChangedCallback) int {
	signalRangeValueChangedLock.Lock()
	defer signalRangeValueChangedLock.Unlock()

	signalRangeValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Range_signal_connect_value_changed(instance, C.gpointer(uintptr(signalRangeValueChangedId)))

	detail := signalRangeValueChangedDetail{callback, handlerID}
	signalRangeValueChangedMap[signalRangeValueChangedId] = detail

	return signalRangeValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the Range.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *Range) DisconnectValueChanged(connectionID int) {
	signalRangeValueChangedLock.Lock()
	defer signalRangeValueChangedLock.Unlock()

	detail, exists := signalRangeValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRangeValueChangedMap, connectionID)
}

//export range_valueChangedHandler
func range_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	signalRangeValueChangedLock.RLock()
	defer signalRangeValueChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalRangeValueChangedMap[index].callback
	callback()
}

// GetAdjustment is a wrapper around the C function gtk_range_get_adjustment.
func (recv *Range) GetAdjustment() *Adjustment {
	retC := C.gtk_range_get_adjustment((*C.GtkRange)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFillLevel is a wrapper around the C function gtk_range_get_fill_level.
func (recv *Range) GetFillLevel() float64 {
	retC := C.gtk_range_get_fill_level((*C.GtkRange)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetInverted is a wrapper around the C function gtk_range_get_inverted.
func (recv *Range) GetInverted() bool {
	retC := C.gtk_range_get_inverted((*C.GtkRange)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetLowerStepperSensitivity is a wrapper around the C function gtk_range_get_lower_stepper_sensitivity.
func (recv *Range) GetLowerStepperSensitivity() SensitivityType {
	retC := C.gtk_range_get_lower_stepper_sensitivity((*C.GtkRange)(recv.native))
	retGo := (SensitivityType)(retC)

	return retGo
}

// GetRestrictToFillLevel is a wrapper around the C function gtk_range_get_restrict_to_fill_level.
func (recv *Range) GetRestrictToFillLevel() bool {
	retC := C.gtk_range_get_restrict_to_fill_level((*C.GtkRange)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowFillLevel is a wrapper around the C function gtk_range_get_show_fill_level.
func (recv *Range) GetShowFillLevel() bool {
	retC := C.gtk_range_get_show_fill_level((*C.GtkRange)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetUpperStepperSensitivity is a wrapper around the C function gtk_range_get_upper_stepper_sensitivity.
func (recv *Range) GetUpperStepperSensitivity() SensitivityType {
	retC := C.gtk_range_get_upper_stepper_sensitivity((*C.GtkRange)(recv.native))
	retGo := (SensitivityType)(retC)

	return retGo
}

// GetValue is a wrapper around the C function gtk_range_get_value.
func (recv *Range) GetValue() float64 {
	retC := C.gtk_range_get_value((*C.GtkRange)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// SetAdjustment is a wrapper around the C function gtk_range_set_adjustment.
func (recv *Range) SetAdjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_range_set_adjustment((*C.GtkRange)(recv.native), c_adjustment)

	return
}

// SetFillLevel is a wrapper around the C function gtk_range_set_fill_level.
func (recv *Range) SetFillLevel(fillLevel float64) {
	c_fill_level := (C.gdouble)(fillLevel)

	C.gtk_range_set_fill_level((*C.GtkRange)(recv.native), c_fill_level)

	return
}

// SetIncrements is a wrapper around the C function gtk_range_set_increments.
func (recv *Range) SetIncrements(step float64, page float64) {
	c_step := (C.gdouble)(step)

	c_page := (C.gdouble)(page)

	C.gtk_range_set_increments((*C.GtkRange)(recv.native), c_step, c_page)

	return
}

// SetInverted is a wrapper around the C function gtk_range_set_inverted.
func (recv *Range) SetInverted(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_range_set_inverted((*C.GtkRange)(recv.native), c_setting)

	return
}

// SetLowerStepperSensitivity is a wrapper around the C function gtk_range_set_lower_stepper_sensitivity.
func (recv *Range) SetLowerStepperSensitivity(sensitivity SensitivityType) {
	c_sensitivity := (C.GtkSensitivityType)(sensitivity)

	C.gtk_range_set_lower_stepper_sensitivity((*C.GtkRange)(recv.native), c_sensitivity)

	return
}

// SetRange is a wrapper around the C function gtk_range_set_range.
func (recv *Range) SetRange(min float64, max float64) {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	C.gtk_range_set_range((*C.GtkRange)(recv.native), c_min, c_max)

	return
}

// SetRestrictToFillLevel is a wrapper around the C function gtk_range_set_restrict_to_fill_level.
func (recv *Range) SetRestrictToFillLevel(restrictToFillLevel bool) {
	c_restrict_to_fill_level :=
		boolToGboolean(restrictToFillLevel)

	C.gtk_range_set_restrict_to_fill_level((*C.GtkRange)(recv.native), c_restrict_to_fill_level)

	return
}

// SetShowFillLevel is a wrapper around the C function gtk_range_set_show_fill_level.
func (recv *Range) SetShowFillLevel(showFillLevel bool) {
	c_show_fill_level :=
		boolToGboolean(showFillLevel)

	C.gtk_range_set_show_fill_level((*C.GtkRange)(recv.native), c_show_fill_level)

	return
}

// SetUpperStepperSensitivity is a wrapper around the C function gtk_range_set_upper_stepper_sensitivity.
func (recv *Range) SetUpperStepperSensitivity(sensitivity SensitivityType) {
	c_sensitivity := (C.GtkSensitivityType)(sensitivity)

	C.gtk_range_set_upper_stepper_sensitivity((*C.GtkRange)(recv.native), c_sensitivity)

	return
}

// SetValue is a wrapper around the C function gtk_range_set_value.
func (recv *Range) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_range_set_value((*C.GtkRange)(recv.native), c_value)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Range
func (recv *Range) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Range
func (recv *Range) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Range
func (recv *Range) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// RangeAccessible is a wrapper around the C record GtkRangeAccessible.
type RangeAccessible struct {
	native *C.GtkRangeAccessible
	// parent : record
	// priv : record
}

func RangeAccessibleNewFromC(u unsafe.Pointer) *RangeAccessible {
	c := (*C.GtkRangeAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RangeAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RangeAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RangeAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RangeAccessible with another RangeAccessible, and returns true if they represent the same GObject.
func (recv *RangeAccessible) Equals(other *RangeAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *RangeAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *RangeAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RangeAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to RangeAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RangeAccessible.
func CastToRangeAccessible(object *gobject.Object) *RangeAccessible {
	return RangeAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by RangeAccessible
func (recv *RangeAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by RangeAccessible
func (recv *RangeAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// RcStyle is a wrapper around the C record GtkRcStyle.
type RcStyle struct {
	native *C.GtkRcStyle
	// parent_instance : record
	Name string
	// no type for bg_pixmap_name
	// font_desc : record
	// no type for color_flags
	// no type for fg
	// no type for bg
	// no type for text
	// no type for base
	Xthickness int32
	Ythickness int32
	// Private : rc_properties
	// Private : rc_style_lists
	// Private : icon_factories
	// Private : engine_specified
}

func RcStyleNewFromC(u unsafe.Pointer) *RcStyle {
	c := (*C.GtkRcStyle)(u)
	if c == nil {
		return nil
	}

	g := &RcStyle{
		Name:       C.GoString(c.name),
		Xthickness: (int32)(c.xthickness),
		Ythickness: (int32)(c.ythickness),
		native:     c,
	}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RcStyle) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RcStyle) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native.xthickness =
		(C.gint)(recv.Xthickness)
	recv.native.ythickness =
		(C.gint)(recv.Ythickness)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RcStyle with another RcStyle, and returns true if they represent the same GObject.
func (recv *RcStyle) Equals(other *RcStyle) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *RcStyle) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to RcStyle.
// Exercise care, as this is a potentially dangerous function if the Object is not a RcStyle.
func CastToRcStyle(object *gobject.Object) *RcStyle {
	return RcStyleNewFromC(object.ToC())
}

// RcStyleNew is a wrapper around the C function gtk_rc_style_new.
func RcStyleNew() *RcStyle {
	retC := C.gtk_rc_style_new()
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Copy is a wrapper around the C function gtk_rc_style_copy.
func (recv *RcStyle) Copy() *RcStyle {
	retC := C.gtk_rc_style_copy((*C.GtkRcStyle)(recv.native))
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RecentAction is a wrapper around the C record GtkRecentAction.
type RecentAction struct {
	native *C.GtkRecentAction
	// parent_instance : record
	// Private : priv
}

func RecentActionNewFromC(u unsafe.Pointer) *RecentAction {
	c := (*C.GtkRecentAction)(u)
	if c == nil {
		return nil
	}

	g := &RecentAction{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentAction) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentAction with another RecentAction, and returns true if they represent the same GObject.
func (recv *RecentAction) Equals(other *RecentAction) bool {
	return other.ToC() == recv.ToC()
}

// Action upcasts to *Action
func (recv *RecentAction) Action() *Action {
	return ActionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *RecentAction) Object() *gobject.Object {
	return recv.Action().Object()
}

// CastToWidget down casts any arbitrary Object to RecentAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentAction.
func CastToRecentAction(object *gobject.Object) *RecentAction {
	return RecentActionNewFromC(object.ToC())
}

// RecentActionNew is a wrapper around the C function gtk_recent_action_new.
func RecentActionNew(name string, label string, tooltip string, stockId string) *RecentAction {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_tooltip := C.CString(tooltip)
	defer C.free(unsafe.Pointer(c_tooltip))

	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_recent_action_new(c_name, c_label, c_tooltip, c_stock_id)
	retGo := RecentActionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// RecentActionNewForManager is a wrapper around the C function gtk_recent_action_new_for_manager.
func RecentActionNewForManager(name string, label string, tooltip string, stockId string, manager *RecentManager) *RecentAction {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_tooltip := C.CString(tooltip)
	defer C.free(unsafe.Pointer(c_tooltip))

	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_manager := (*C.GtkRecentManager)(C.NULL)
	if manager != nil {
		c_manager = (*C.GtkRecentManager)(manager.ToC())
	}

	retC := C.gtk_recent_action_new_for_manager(c_name, c_label, c_tooltip, c_stock_id, c_manager)
	retGo := RecentActionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetShowNumbers is a wrapper around the C function gtk_recent_action_get_show_numbers.
func (recv *RecentAction) GetShowNumbers() bool {
	retC := C.gtk_recent_action_get_show_numbers((*C.GtkRecentAction)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetShowNumbers is a wrapper around the C function gtk_recent_action_set_show_numbers.
func (recv *RecentAction) SetShowNumbers(showNumbers bool) {
	c_show_numbers :=
		boolToGboolean(showNumbers)

	C.gtk_recent_action_set_show_numbers((*C.GtkRecentAction)(recv.native), c_show_numbers)

	return
}

// Buildable returns the Buildable interface implemented by RecentAction
func (recv *RecentAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentAction
func (recv *RecentAction) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserDialog is a wrapper around the C record GtkRecentChooserDialog.
type RecentChooserDialog struct {
	native *C.GtkRecentChooserDialog
	// parent_instance : record
	// Private : priv
}

func RecentChooserDialogNewFromC(u unsafe.Pointer) *RecentChooserDialog {
	c := (*C.GtkRecentChooserDialog)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserDialog{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentChooserDialog) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentChooserDialog) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserDialog with another RecentChooserDialog, and returns true if they represent the same GObject.
func (recv *RecentChooserDialog) Equals(other *RecentChooserDialog) bool {
	return other.ToC() == recv.ToC()
}

// Dialog upcasts to *Dialog
func (recv *RecentChooserDialog) Dialog() *Dialog {
	return DialogNewFromC(unsafe.Pointer(recv.native))
}

// Window upcasts to *Window
func (recv *RecentChooserDialog) Window() *Window {
	return recv.Dialog().Window()
}

// Bin upcasts to *Bin
func (recv *RecentChooserDialog) Bin() *Bin {
	return recv.Dialog().Bin()
}

// Container upcasts to *Container
func (recv *RecentChooserDialog) Container() *Container {
	return recv.Dialog().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserDialog) Widget() *Widget {
	return recv.Dialog().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserDialog) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Dialog().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserDialog) Object() *gobject.Object {
	return recv.Dialog().Object()
}

// CastToWidget down casts any arbitrary Object to RecentChooserDialog.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserDialog.
func CastToRecentChooserDialog(object *gobject.Object) *RecentChooserDialog {
	return RecentChooserDialogNewFromC(object.ToC())
}

// Unsupported : gtk_recent_chooser_dialog_new : unsupported parameter ... : varargs

// Unsupported : gtk_recent_chooser_dialog_new_for_manager : unsupported parameter ... : varargs

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserDialog
func (recv *RecentChooserDialog) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserMenu is a wrapper around the C record GtkRecentChooserMenu.
type RecentChooserMenu struct {
	native *C.GtkRecentChooserMenu
	// parent_instance : record
	// Private : priv
}

func RecentChooserMenuNewFromC(u unsafe.Pointer) *RecentChooserMenu {
	c := (*C.GtkRecentChooserMenu)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserMenu{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentChooserMenu) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentChooserMenu) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserMenu with another RecentChooserMenu, and returns true if they represent the same GObject.
func (recv *RecentChooserMenu) Equals(other *RecentChooserMenu) bool {
	return other.ToC() == recv.ToC()
}

// Menu upcasts to *Menu
func (recv *RecentChooserMenu) Menu() *Menu {
	return MenuNewFromC(unsafe.Pointer(recv.native))
}

// MenuShell upcasts to *MenuShell
func (recv *RecentChooserMenu) MenuShell() *MenuShell {
	return recv.Menu().MenuShell()
}

// Container upcasts to *Container
func (recv *RecentChooserMenu) Container() *Container {
	return recv.Menu().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserMenu) Widget() *Widget {
	return recv.Menu().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserMenu) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Menu().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserMenu) Object() *gobject.Object {
	return recv.Menu().Object()
}

// CastToWidget down casts any arbitrary Object to RecentChooserMenu.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserMenu.
func CastToRecentChooserMenu(object *gobject.Object) *RecentChooserMenu {
	return RecentChooserMenuNewFromC(object.ToC())
}

// RecentChooserMenuNew is a wrapper around the C function gtk_recent_chooser_menu_new.
func RecentChooserMenuNew() *RecentChooserMenu {
	retC := C.gtk_recent_chooser_menu_new()
	retGo := RecentChooserMenuNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RecentChooserMenuNewForManager is a wrapper around the C function gtk_recent_chooser_menu_new_for_manager.
func RecentChooserMenuNewForManager(manager *RecentManager) *RecentChooserMenu {
	c_manager := (*C.GtkRecentManager)(C.NULL)
	if manager != nil {
		c_manager = (*C.GtkRecentManager)(manager.ToC())
	}

	retC := C.gtk_recent_chooser_menu_new_for_manager(c_manager)
	retGo := RecentChooserMenuNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetShowNumbers is a wrapper around the C function gtk_recent_chooser_menu_get_show_numbers.
func (recv *RecentChooserMenu) GetShowNumbers() bool {
	retC := C.gtk_recent_chooser_menu_get_show_numbers((*C.GtkRecentChooserMenu)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetShowNumbers is a wrapper around the C function gtk_recent_chooser_menu_set_show_numbers.
func (recv *RecentChooserMenu) SetShowNumbers(showNumbers bool) {
	c_show_numbers :=
		boolToGboolean(showNumbers)

	C.gtk_recent_chooser_menu_set_show_numbers((*C.GtkRecentChooserMenu)(recv.native), c_show_numbers)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserMenu
func (recv *RecentChooserMenu) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentChooserWidget is a wrapper around the C record GtkRecentChooserWidget.
type RecentChooserWidget struct {
	native *C.GtkRecentChooserWidget
	// parent_instance : record
	// Private : priv
}

func RecentChooserWidgetNewFromC(u unsafe.Pointer) *RecentChooserWidget {
	c := (*C.GtkRecentChooserWidget)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserWidget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentChooserWidget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentChooserWidget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserWidget with another RecentChooserWidget, and returns true if they represent the same GObject.
func (recv *RecentChooserWidget) Equals(other *RecentChooserWidget) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *RecentChooserWidget) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *RecentChooserWidget) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *RecentChooserWidget) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentChooserWidget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *RecentChooserWidget) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to RecentChooserWidget.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentChooserWidget.
func CastToRecentChooserWidget(object *gobject.Object) *RecentChooserWidget {
	return RecentChooserWidgetNewFromC(object.ToC())
}

// RecentChooserWidgetNew is a wrapper around the C function gtk_recent_chooser_widget_new.
func RecentChooserWidgetNew() *RecentChooserWidget {
	retC := C.gtk_recent_chooser_widget_new()
	retGo := RecentChooserWidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RecentChooserWidgetNewForManager is a wrapper around the C function gtk_recent_chooser_widget_new_for_manager.
func RecentChooserWidgetNewForManager(manager *RecentManager) *RecentChooserWidget {
	c_manager := (*C.GtkRecentManager)(C.NULL)
	if manager != nil {
		c_manager = (*C.GtkRecentManager)(manager.ToC())
	}

	retC := C.gtk_recent_chooser_widget_new_for_manager(c_manager)
	retGo := RecentChooserWidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// RecentChooser returns the RecentChooser interface implemented by RecentChooserWidget
func (recv *RecentChooserWidget) RecentChooser() *RecentChooser {
	return RecentChooserNewFromC(recv.ToC())
}

// RecentFilter is a wrapper around the C record GtkRecentFilter.
type RecentFilter struct {
	native *C.GtkRecentFilter
}

func RecentFilterNewFromC(u unsafe.Pointer) *RecentFilter {
	c := (*C.GtkRecentFilter)(u)
	if c == nil {
		return nil
	}

	g := &RecentFilter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentFilter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentFilter with another RecentFilter, and returns true if they represent the same GObject.
func (recv *RecentFilter) Equals(other *RecentFilter) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *RecentFilter) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *RecentFilter) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to RecentFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentFilter.
func CastToRecentFilter(object *gobject.Object) *RecentFilter {
	return RecentFilterNewFromC(object.ToC())
}

// RecentFilterNew is a wrapper around the C function gtk_recent_filter_new.
func RecentFilterNew() *RecentFilter {
	retC := C.gtk_recent_filter_new()
	retGo := RecentFilterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AddAge is a wrapper around the C function gtk_recent_filter_add_age.
func (recv *RecentFilter) AddAge(days int32) {
	c_days := (C.gint)(days)

	C.gtk_recent_filter_add_age((*C.GtkRecentFilter)(recv.native), c_days)

	return
}

// AddApplication is a wrapper around the C function gtk_recent_filter_add_application.
func (recv *RecentFilter) AddApplication(application string) {
	c_application := C.CString(application)
	defer C.free(unsafe.Pointer(c_application))

	C.gtk_recent_filter_add_application((*C.GtkRecentFilter)(recv.native), c_application)

	return
}

// Unsupported : gtk_recent_filter_add_custom : unsupported parameter func : no type generator for RecentFilterFunc (GtkRecentFilterFunc) for param func

// AddGroup is a wrapper around the C function gtk_recent_filter_add_group.
func (recv *RecentFilter) AddGroup(group string) {
	c_group := C.CString(group)
	defer C.free(unsafe.Pointer(c_group))

	C.gtk_recent_filter_add_group((*C.GtkRecentFilter)(recv.native), c_group)

	return
}

// AddMimeType is a wrapper around the C function gtk_recent_filter_add_mime_type.
func (recv *RecentFilter) AddMimeType(mimeType string) {
	c_mime_type := C.CString(mimeType)
	defer C.free(unsafe.Pointer(c_mime_type))

	C.gtk_recent_filter_add_mime_type((*C.GtkRecentFilter)(recv.native), c_mime_type)

	return
}

// AddPattern is a wrapper around the C function gtk_recent_filter_add_pattern.
func (recv *RecentFilter) AddPattern(pattern string) {
	c_pattern := C.CString(pattern)
	defer C.free(unsafe.Pointer(c_pattern))

	C.gtk_recent_filter_add_pattern((*C.GtkRecentFilter)(recv.native), c_pattern)

	return
}

// AddPixbufFormats is a wrapper around the C function gtk_recent_filter_add_pixbuf_formats.
func (recv *RecentFilter) AddPixbufFormats() {
	C.gtk_recent_filter_add_pixbuf_formats((*C.GtkRecentFilter)(recv.native))

	return
}

// Filter is a wrapper around the C function gtk_recent_filter_filter.
func (recv *RecentFilter) Filter(filterInfo *RecentFilterInfo) bool {
	c_filter_info := (*C.GtkRecentFilterInfo)(C.NULL)
	if filterInfo != nil {
		c_filter_info = (*C.GtkRecentFilterInfo)(filterInfo.ToC())
	}

	retC := C.gtk_recent_filter_filter((*C.GtkRecentFilter)(recv.native), c_filter_info)
	retGo := retC == C.TRUE

	return retGo
}

// GetName is a wrapper around the C function gtk_recent_filter_get_name.
func (recv *RecentFilter) GetName() string {
	retC := C.gtk_recent_filter_get_name((*C.GtkRecentFilter)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetNeeded is a wrapper around the C function gtk_recent_filter_get_needed.
func (recv *RecentFilter) GetNeeded() RecentFilterFlags {
	retC := C.gtk_recent_filter_get_needed((*C.GtkRecentFilter)(recv.native))
	retGo := (RecentFilterFlags)(retC)

	return retGo
}

// SetName is a wrapper around the C function gtk_recent_filter_set_name.
func (recv *RecentFilter) SetName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_recent_filter_set_name((*C.GtkRecentFilter)(recv.native), c_name)

	return
}

// Buildable returns the Buildable interface implemented by RecentFilter
func (recv *RecentFilter) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// RecentManager is a wrapper around the C record GtkRecentManager.
type RecentManager struct {
	native *C.GtkRecentManager
	// Private : parent_instance
	// Private : priv
}

func RecentManagerNewFromC(u unsafe.Pointer) *RecentManager {
	c := (*C.GtkRecentManager)(u)
	if c == nil {
		return nil
	}

	g := &RecentManager{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RecentManager) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RecentManager) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentManager with another RecentManager, and returns true if they represent the same GObject.
func (recv *RecentManager) Equals(other *RecentManager) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *RecentManager) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to RecentManager.
// Exercise care, as this is a potentially dangerous function if the Object is not a RecentManager.
func CastToRecentManager(object *gobject.Object) *RecentManager {
	return RecentManagerNewFromC(object.ToC())
}

type signalRecentManagerChangedDetail struct {
	callback  RecentManagerSignalChangedCallback
	handlerID C.gulong
}

var signalRecentManagerChangedId int
var signalRecentManagerChangedMap = make(map[int]signalRecentManagerChangedDetail)
var signalRecentManagerChangedLock sync.RWMutex

// RecentManagerSignalChangedCallback is a callback function for a 'changed' signal emitted from a RecentManager.
type RecentManagerSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the RecentManager.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *RecentManager) ConnectChanged(callback RecentManagerSignalChangedCallback) int {
	signalRecentManagerChangedLock.Lock()
	defer signalRecentManagerChangedLock.Unlock()

	signalRecentManagerChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RecentManager_signal_connect_changed(instance, C.gpointer(uintptr(signalRecentManagerChangedId)))

	detail := signalRecentManagerChangedDetail{callback, handlerID}
	signalRecentManagerChangedMap[signalRecentManagerChangedId] = detail

	return signalRecentManagerChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the RecentManager.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *RecentManager) DisconnectChanged(connectionID int) {
	signalRecentManagerChangedLock.Lock()
	defer signalRecentManagerChangedLock.Unlock()

	detail, exists := signalRecentManagerChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRecentManagerChangedMap, connectionID)
}

//export recentmanager_changedHandler
func recentmanager_changedHandler(_ *C.GObject, data C.gpointer) {
	signalRecentManagerChangedLock.RLock()
	defer signalRecentManagerChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalRecentManagerChangedMap[index].callback
	callback()
}

// RecentManagerNew is a wrapper around the C function gtk_recent_manager_new.
func RecentManagerNew() *RecentManager {
	retC := C.gtk_recent_manager_new()
	retGo := RecentManagerNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// RecentManagerGetDefault is a wrapper around the C function gtk_recent_manager_get_default.
func RecentManagerGetDefault() *RecentManager {
	retC := C.gtk_recent_manager_get_default()
	retGo := RecentManagerNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AddFull is a wrapper around the C function gtk_recent_manager_add_full.
func (recv *RecentManager) AddFull(uri string, recentData *RecentData) bool {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	c_recent_data := (*C.GtkRecentData)(C.NULL)
	if recentData != nil {
		c_recent_data = (*C.GtkRecentData)(recentData.ToC())
	}

	retC := C.gtk_recent_manager_add_full((*C.GtkRecentManager)(recv.native), c_uri, c_recent_data)
	retGo := retC == C.TRUE

	return retGo
}

// AddItem is a wrapper around the C function gtk_recent_manager_add_item.
func (recv *RecentManager) AddItem(uri string) bool {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	retC := C.gtk_recent_manager_add_item((*C.GtkRecentManager)(recv.native), c_uri)
	retGo := retC == C.TRUE

	return retGo
}

// GetItems is a wrapper around the C function gtk_recent_manager_get_items.
func (recv *RecentManager) GetItems() *glib.List {
	retC := C.gtk_recent_manager_get_items((*C.GtkRecentManager)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// HasItem is a wrapper around the C function gtk_recent_manager_has_item.
func (recv *RecentManager) HasItem(uri string) bool {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	retC := C.gtk_recent_manager_has_item((*C.GtkRecentManager)(recv.native), c_uri)
	retGo := retC == C.TRUE

	return retGo
}

// LookupItem is a wrapper around the C function gtk_recent_manager_lookup_item.
func (recv *RecentManager) LookupItem(uri string) (*RecentInfo, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	var cThrowableError *C.GError

	retC := C.gtk_recent_manager_lookup_item((*C.GtkRecentManager)(recv.native), c_uri, &cThrowableError)
	var retGo (*RecentInfo)
	if retC == nil {
		retGo = nil
	} else {
		retGo = RecentInfoNewFromC(unsafe.Pointer(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// MoveItem is a wrapper around the C function gtk_recent_manager_move_item.
func (recv *RecentManager) MoveItem(uri string, newUri string) (bool, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	c_new_uri := C.CString(newUri)
	defer C.free(unsafe.Pointer(c_new_uri))

	var cThrowableError *C.GError

	retC := C.gtk_recent_manager_move_item((*C.GtkRecentManager)(recv.native), c_uri, c_new_uri, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PurgeItems is a wrapper around the C function gtk_recent_manager_purge_items.
func (recv *RecentManager) PurgeItems() (int32, error) {
	var cThrowableError *C.GError

	retC := C.gtk_recent_manager_purge_items((*C.GtkRecentManager)(recv.native), &cThrowableError)
	retGo := (int32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// RemoveItem is a wrapper around the C function gtk_recent_manager_remove_item.
func (recv *RecentManager) RemoveItem(uri string) (bool, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	var cThrowableError *C.GError

	retC := C.gtk_recent_manager_remove_item((*C.GtkRecentManager)(recv.native), c_uri, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// RendererCellAccessible is a wrapper around the C record GtkRendererCellAccessible.
type RendererCellAccessible struct {
	native *C.GtkRendererCellAccessible
	// parent : record
	// priv : record
}

func RendererCellAccessibleNewFromC(u unsafe.Pointer) *RendererCellAccessible {
	c := (*C.GtkRendererCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &RendererCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *RendererCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *RendererCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RendererCellAccessible with another RendererCellAccessible, and returns true if they represent the same GObject.
func (recv *RendererCellAccessible) Equals(other *RendererCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// CellAccessible upcasts to *CellAccessible
func (recv *RendererCellAccessible) CellAccessible() *CellAccessible {
	return CellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *RendererCellAccessible) Accessible() *Accessible {
	return recv.CellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *RendererCellAccessible) Object() *atk.Object {
	return recv.CellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to RendererCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a RendererCellAccessible.
func CastToRendererCellAccessible(object *gobject.Object) *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(object.ToC())
}

// RendererCellAccessibleNew is a wrapper around the C function gtk_renderer_cell_accessible_new.
func RendererCellAccessibleNew(renderer *CellRenderer) *RendererCellAccessible {
	c_renderer := (*C.GtkCellRenderer)(C.NULL)
	if renderer != nil {
		c_renderer = (*C.GtkCellRenderer)(renderer.ToC())
	}

	retC := C.gtk_renderer_cell_accessible_new(c_renderer)
	retGo := RendererCellAccessibleNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Action returns the Action interface implemented by RendererCellAccessible
func (recv *RendererCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by RendererCellAccessible
func (recv *RendererCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Revealer is a wrapper around the C record GtkRevealer.
type Revealer struct {
	native *C.GtkRevealer
	// parent_instance : record
}

func RevealerNewFromC(u unsafe.Pointer) *Revealer {
	c := (*C.GtkRevealer)(u)
	if c == nil {
		return nil
	}

	g := &Revealer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Revealer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Revealer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Revealer with another Revealer, and returns true if they represent the same GObject.
func (recv *Revealer) Equals(other *Revealer) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Revealer) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Revealer) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Revealer) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Revealer) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Revealer) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Revealer.
// Exercise care, as this is a potentially dangerous function if the Object is not a Revealer.
func CastToRevealer(object *gobject.Object) *Revealer {
	return RevealerNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Revealer
func (recv *Revealer) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Revealer
func (recv *Revealer) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scale is a wrapper around the C record GtkScale.
type Scale struct {
	native *C.GtkScale
	// range : record
	// Private : priv
}

func ScaleNewFromC(u unsafe.Pointer) *Scale {
	c := (*C.GtkScale)(u)
	if c == nil {
		return nil
	}

	g := &Scale{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Scale) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Scale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Scale with another Scale, and returns true if they represent the same GObject.
func (recv *Scale) Equals(other *Scale) bool {
	return other.ToC() == recv.ToC()
}

// Range upcasts to *Range
func (recv *Scale) Range() *Range {
	return RangeNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Scale) Widget() *Widget {
	return recv.Range().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Scale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Range().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Scale) Object() *gobject.Object {
	return recv.Range().Object()
}

// CastToWidget down casts any arbitrary Object to Scale.
// Exercise care, as this is a potentially dangerous function if the Object is not a Scale.
func CastToScale(object *gobject.Object) *Scale {
	return ScaleNewFromC(object.ToC())
}

// Unsupported signal 'format-value' for Scale : return value utf8 :

// GetDigits is a wrapper around the C function gtk_scale_get_digits.
func (recv *Scale) GetDigits() int32 {
	retC := C.gtk_scale_get_digits((*C.GtkScale)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetDrawValue is a wrapper around the C function gtk_scale_get_draw_value.
func (recv *Scale) GetDrawValue() bool {
	retC := C.gtk_scale_get_draw_value((*C.GtkScale)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetLayout is a wrapper around the C function gtk_scale_get_layout.
func (recv *Scale) GetLayout() *pango.Layout {
	retC := C.gtk_scale_get_layout((*C.GtkScale)(recv.native))
	var retGo (*pango.Layout)
	if retC == nil {
		retGo = nil
	} else {
		retGo = pango.LayoutNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetLayoutOffsets is a wrapper around the C function gtk_scale_get_layout_offsets.
func (recv *Scale) GetLayoutOffsets() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_scale_get_layout_offsets((*C.GtkScale)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// GetValuePos is a wrapper around the C function gtk_scale_get_value_pos.
func (recv *Scale) GetValuePos() PositionType {
	retC := C.gtk_scale_get_value_pos((*C.GtkScale)(recv.native))
	retGo := (PositionType)(retC)

	return retGo
}

// SetDigits is a wrapper around the C function gtk_scale_set_digits.
func (recv *Scale) SetDigits(digits int32) {
	c_digits := (C.gint)(digits)

	C.gtk_scale_set_digits((*C.GtkScale)(recv.native), c_digits)

	return
}

// SetDrawValue is a wrapper around the C function gtk_scale_set_draw_value.
func (recv *Scale) SetDrawValue(drawValue bool) {
	c_draw_value :=
		boolToGboolean(drawValue)

	C.gtk_scale_set_draw_value((*C.GtkScale)(recv.native), c_draw_value)

	return
}

// SetValuePos is a wrapper around the C function gtk_scale_set_value_pos.
func (recv *Scale) SetValuePos(pos PositionType) {
	c_pos := (C.GtkPositionType)(pos)

	C.gtk_scale_set_value_pos((*C.GtkScale)(recv.native), c_pos)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Scale
func (recv *Scale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Scale
func (recv *Scale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Scale
func (recv *Scale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScaleAccessible is a wrapper around the C record GtkScaleAccessible.
type ScaleAccessible struct {
	native *C.GtkScaleAccessible
	// parent : record
	// priv : record
}

func ScaleAccessibleNewFromC(u unsafe.Pointer) *ScaleAccessible {
	c := (*C.GtkScaleAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScaleAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScaleAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScaleAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleAccessible with another ScaleAccessible, and returns true if they represent the same GObject.
func (recv *ScaleAccessible) Equals(other *ScaleAccessible) bool {
	return other.ToC() == recv.ToC()
}

// RangeAccessible upcasts to *RangeAccessible
func (recv *ScaleAccessible) RangeAccessible() *RangeAccessible {
	return RangeAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScaleAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.RangeAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScaleAccessible) Accessible() *Accessible {
	return recv.RangeAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScaleAccessible) Object() *atk.Object {
	return recv.RangeAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ScaleAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleAccessible.
func CastToScaleAccessible(object *gobject.Object) *ScaleAccessible {
	return ScaleAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ScaleAccessible
func (recv *ScaleAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ScaleAccessible
func (recv *ScaleAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// ScaleButton is a wrapper around the C record GtkScaleButton.
type ScaleButton struct {
	native *C.GtkScaleButton
	// parent : record
	// Private : priv
}

func ScaleButtonNewFromC(u unsafe.Pointer) *ScaleButton {
	c := (*C.GtkScaleButton)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScaleButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScaleButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleButton with another ScaleButton, and returns true if they represent the same GObject.
func (recv *ScaleButton) Equals(other *ScaleButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *ScaleButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ScaleButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ScaleButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ScaleButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ScaleButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ScaleButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to ScaleButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleButton.
func CastToScaleButton(object *gobject.Object) *ScaleButton {
	return ScaleButtonNewFromC(object.ToC())
}

type signalScaleButtonPopdownDetail struct {
	callback  ScaleButtonSignalPopdownCallback
	handlerID C.gulong
}

var signalScaleButtonPopdownId int
var signalScaleButtonPopdownMap = make(map[int]signalScaleButtonPopdownDetail)
var signalScaleButtonPopdownLock sync.RWMutex

// ScaleButtonSignalPopdownCallback is a callback function for a 'popdown' signal emitted from a ScaleButton.
type ScaleButtonSignalPopdownCallback func()

/*
ConnectPopdown connects the callback to the 'popdown' signal for the ScaleButton.

The returned value represents the connection, and may be passed to DisconnectPopdown to remove it.
*/
func (recv *ScaleButton) ConnectPopdown(callback ScaleButtonSignalPopdownCallback) int {
	signalScaleButtonPopdownLock.Lock()
	defer signalScaleButtonPopdownLock.Unlock()

	signalScaleButtonPopdownId++
	instance := C.gpointer(recv.native)
	handlerID := C.ScaleButton_signal_connect_popdown(instance, C.gpointer(uintptr(signalScaleButtonPopdownId)))

	detail := signalScaleButtonPopdownDetail{callback, handlerID}
	signalScaleButtonPopdownMap[signalScaleButtonPopdownId] = detail

	return signalScaleButtonPopdownId
}

/*
DisconnectPopdown disconnects a callback from the 'popdown' signal for the ScaleButton.

The connectionID should be a value returned from a call to ConnectPopdown.
*/
func (recv *ScaleButton) DisconnectPopdown(connectionID int) {
	signalScaleButtonPopdownLock.Lock()
	defer signalScaleButtonPopdownLock.Unlock()

	detail, exists := signalScaleButtonPopdownMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalScaleButtonPopdownMap, connectionID)
}

//export scalebutton_popdownHandler
func scalebutton_popdownHandler(_ *C.GObject, data C.gpointer) {
	signalScaleButtonPopdownLock.RLock()
	defer signalScaleButtonPopdownLock.RUnlock()

	index := int(uintptr(data))
	callback := signalScaleButtonPopdownMap[index].callback
	callback()
}

type signalScaleButtonPopupDetail struct {
	callback  ScaleButtonSignalPopupCallback
	handlerID C.gulong
}

var signalScaleButtonPopupId int
var signalScaleButtonPopupMap = make(map[int]signalScaleButtonPopupDetail)
var signalScaleButtonPopupLock sync.RWMutex

// ScaleButtonSignalPopupCallback is a callback function for a 'popup' signal emitted from a ScaleButton.
type ScaleButtonSignalPopupCallback func()

/*
ConnectPopup connects the callback to the 'popup' signal for the ScaleButton.

The returned value represents the connection, and may be passed to DisconnectPopup to remove it.
*/
func (recv *ScaleButton) ConnectPopup(callback ScaleButtonSignalPopupCallback) int {
	signalScaleButtonPopupLock.Lock()
	defer signalScaleButtonPopupLock.Unlock()

	signalScaleButtonPopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.ScaleButton_signal_connect_popup(instance, C.gpointer(uintptr(signalScaleButtonPopupId)))

	detail := signalScaleButtonPopupDetail{callback, handlerID}
	signalScaleButtonPopupMap[signalScaleButtonPopupId] = detail

	return signalScaleButtonPopupId
}

/*
DisconnectPopup disconnects a callback from the 'popup' signal for the ScaleButton.

The connectionID should be a value returned from a call to ConnectPopup.
*/
func (recv *ScaleButton) DisconnectPopup(connectionID int) {
	signalScaleButtonPopupLock.Lock()
	defer signalScaleButtonPopupLock.Unlock()

	detail, exists := signalScaleButtonPopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalScaleButtonPopupMap, connectionID)
}

//export scalebutton_popupHandler
func scalebutton_popupHandler(_ *C.GObject, data C.gpointer) {
	signalScaleButtonPopupLock.RLock()
	defer signalScaleButtonPopupLock.RUnlock()

	index := int(uintptr(data))
	callback := signalScaleButtonPopupMap[index].callback
	callback()
}

type signalScaleButtonValueChangedDetail struct {
	callback  ScaleButtonSignalValueChangedCallback
	handlerID C.gulong
}

var signalScaleButtonValueChangedId int
var signalScaleButtonValueChangedMap = make(map[int]signalScaleButtonValueChangedDetail)
var signalScaleButtonValueChangedLock sync.RWMutex

// ScaleButtonSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a ScaleButton.
type ScaleButtonSignalValueChangedCallback func(value float64)

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the ScaleButton.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *ScaleButton) ConnectValueChanged(callback ScaleButtonSignalValueChangedCallback) int {
	signalScaleButtonValueChangedLock.Lock()
	defer signalScaleButtonValueChangedLock.Unlock()

	signalScaleButtonValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ScaleButton_signal_connect_value_changed(instance, C.gpointer(uintptr(signalScaleButtonValueChangedId)))

	detail := signalScaleButtonValueChangedDetail{callback, handlerID}
	signalScaleButtonValueChangedMap[signalScaleButtonValueChangedId] = detail

	return signalScaleButtonValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the ScaleButton.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *ScaleButton) DisconnectValueChanged(connectionID int) {
	signalScaleButtonValueChangedLock.Lock()
	defer signalScaleButtonValueChangedLock.Unlock()

	detail, exists := signalScaleButtonValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalScaleButtonValueChangedMap, connectionID)
}

//export scalebutton_valueChangedHandler
func scalebutton_valueChangedHandler(_ *C.GObject, c_value C.gdouble, data C.gpointer) {
	signalScaleButtonValueChangedLock.RLock()
	defer signalScaleButtonValueChangedLock.RUnlock()

	value := float64(c_value)

	index := int(uintptr(data))
	callback := signalScaleButtonValueChangedMap[index].callback
	callback(value)
}

// ScaleButtonNew is a wrapper around the C function gtk_scale_button_new.
func ScaleButtonNew(size IconSize, min float64, max float64, step float64, icons []string) *ScaleButton {
	c_size := (C.GtkIconSize)(size)

	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	c_icons_array := make([]*C.gchar, len(icons)+1, len(icons)+1)
	for i, item := range icons {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_icons_array[i] = c
	}
	c_icons_array[len(icons)] = nil
	c_icons_arrayPtr := &c_icons_array[0]
	c_icons := (**C.gchar)(unsafe.Pointer(c_icons_arrayPtr))

	retC := C.gtk_scale_button_new(c_size, c_min, c_max, c_step, c_icons)
	retGo := ScaleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAdjustment is a wrapper around the C function gtk_scale_button_get_adjustment.
func (recv *ScaleButton) GetAdjustment() *Adjustment {
	retC := C.gtk_scale_button_get_adjustment((*C.GtkScaleButton)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetValue is a wrapper around the C function gtk_scale_button_get_value.
func (recv *ScaleButton) GetValue() float64 {
	retC := C.gtk_scale_button_get_value((*C.GtkScaleButton)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// SetAdjustment is a wrapper around the C function gtk_scale_button_set_adjustment.
func (recv *ScaleButton) SetAdjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_scale_button_set_adjustment((*C.GtkScaleButton)(recv.native), c_adjustment)

	return
}

// SetIcons is a wrapper around the C function gtk_scale_button_set_icons.
func (recv *ScaleButton) SetIcons(icons []string) {
	c_icons_array := make([]*C.gchar, len(icons)+1, len(icons)+1)
	for i, item := range icons {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_icons_array[i] = c
	}
	c_icons_array[len(icons)] = nil
	c_icons_arrayPtr := &c_icons_array[0]
	c_icons := (**C.gchar)(unsafe.Pointer(c_icons_arrayPtr))

	C.gtk_scale_button_set_icons((*C.GtkScaleButton)(recv.native), c_icons)

	return
}

// SetValue is a wrapper around the C function gtk_scale_button_set_value.
func (recv *ScaleButton) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_scale_button_set_value((*C.GtkScaleButton)(recv.native), c_value)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ScaleButton
func (recv *ScaleButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ScaleButton
func (recv *ScaleButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ScaleButton
func (recv *ScaleButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ScaleButton
func (recv *ScaleButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ScaleButton
func (recv *ScaleButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScaleButtonAccessible is a wrapper around the C record GtkScaleButtonAccessible.
type ScaleButtonAccessible struct {
	native *C.GtkScaleButtonAccessible
	// parent : record
	// priv : record
}

func ScaleButtonAccessibleNewFromC(u unsafe.Pointer) *ScaleButtonAccessible {
	c := (*C.GtkScaleButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScaleButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScaleButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleButtonAccessible with another ScaleButtonAccessible, and returns true if they represent the same GObject.
func (recv *ScaleButtonAccessible) Equals(other *ScaleButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *ScaleButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ScaleButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScaleButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScaleButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScaleButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ScaleButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScaleButtonAccessible.
func CastToScaleButtonAccessible(object *gobject.Object) *ScaleButtonAccessible {
	return ScaleButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by ScaleButtonAccessible
func (recv *ScaleButtonAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// Scrollbar is a wrapper around the C record GtkScrollbar.
type Scrollbar struct {
	native *C.GtkScrollbar
	// range : record
}

func ScrollbarNewFromC(u unsafe.Pointer) *Scrollbar {
	c := (*C.GtkScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &Scrollbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Scrollbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Scrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Scrollbar with another Scrollbar, and returns true if they represent the same GObject.
func (recv *Scrollbar) Equals(other *Scrollbar) bool {
	return other.ToC() == recv.ToC()
}

// Range upcasts to *Range
func (recv *Scrollbar) Range() *Range {
	return RangeNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Scrollbar) Widget() *Widget {
	return recv.Range().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Scrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Range().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Scrollbar) Object() *gobject.Object {
	return recv.Range().Object()
}

// CastToWidget down casts any arbitrary Object to Scrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Scrollbar.
func CastToScrollbar(object *gobject.Object) *Scrollbar {
	return ScrollbarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Scrollbar
func (recv *Scrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Scrollbar
func (recv *Scrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Scrollbar
func (recv *Scrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ScrolledWindow is a wrapper around the C record GtkScrolledWindow.
type ScrolledWindow struct {
	native *C.GtkScrolledWindow
	// container : record
	// priv : record
}

func ScrolledWindowNewFromC(u unsafe.Pointer) *ScrolledWindow {
	c := (*C.GtkScrolledWindow)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindow{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScrolledWindow) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScrolledWindow) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrolledWindow with another ScrolledWindow, and returns true if they represent the same GObject.
func (recv *ScrolledWindow) Equals(other *ScrolledWindow) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ScrolledWindow) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ScrolledWindow) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ScrolledWindow) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ScrolledWindow) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ScrolledWindow) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ScrolledWindow.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScrolledWindow.
func CastToScrolledWindow(object *gobject.Object) *ScrolledWindow {
	return ScrolledWindowNewFromC(object.ToC())
}

type signalScrolledWindowMoveFocusOutDetail struct {
	callback  ScrolledWindowSignalMoveFocusOutCallback
	handlerID C.gulong
}

var signalScrolledWindowMoveFocusOutId int
var signalScrolledWindowMoveFocusOutMap = make(map[int]signalScrolledWindowMoveFocusOutDetail)
var signalScrolledWindowMoveFocusOutLock sync.RWMutex

// ScrolledWindowSignalMoveFocusOutCallback is a callback function for a 'move-focus-out' signal emitted from a ScrolledWindow.
type ScrolledWindowSignalMoveFocusOutCallback func(directionType DirectionType)

/*
ConnectMoveFocusOut connects the callback to the 'move-focus-out' signal for the ScrolledWindow.

The returned value represents the connection, and may be passed to DisconnectMoveFocusOut to remove it.
*/
func (recv *ScrolledWindow) ConnectMoveFocusOut(callback ScrolledWindowSignalMoveFocusOutCallback) int {
	signalScrolledWindowMoveFocusOutLock.Lock()
	defer signalScrolledWindowMoveFocusOutLock.Unlock()

	signalScrolledWindowMoveFocusOutId++
	instance := C.gpointer(recv.native)
	handlerID := C.ScrolledWindow_signal_connect_move_focus_out(instance, C.gpointer(uintptr(signalScrolledWindowMoveFocusOutId)))

	detail := signalScrolledWindowMoveFocusOutDetail{callback, handlerID}
	signalScrolledWindowMoveFocusOutMap[signalScrolledWindowMoveFocusOutId] = detail

	return signalScrolledWindowMoveFocusOutId
}

/*
DisconnectMoveFocusOut disconnects a callback from the 'move-focus-out' signal for the ScrolledWindow.

The connectionID should be a value returned from a call to ConnectMoveFocusOut.
*/
func (recv *ScrolledWindow) DisconnectMoveFocusOut(connectionID int) {
	signalScrolledWindowMoveFocusOutLock.Lock()
	defer signalScrolledWindowMoveFocusOutLock.Unlock()

	detail, exists := signalScrolledWindowMoveFocusOutMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalScrolledWindowMoveFocusOutMap, connectionID)
}

//export scrolledwindow_moveFocusOutHandler
func scrolledwindow_moveFocusOutHandler(_ *C.GObject, c_direction_type C.GtkDirectionType, data C.gpointer) {
	signalScrolledWindowMoveFocusOutLock.RLock()
	defer signalScrolledWindowMoveFocusOutLock.RUnlock()

	directionType := DirectionType(c_direction_type)

	index := int(uintptr(data))
	callback := signalScrolledWindowMoveFocusOutMap[index].callback
	callback(directionType)
}

type signalScrolledWindowScrollChildDetail struct {
	callback  ScrolledWindowSignalScrollChildCallback
	handlerID C.gulong
}

var signalScrolledWindowScrollChildId int
var signalScrolledWindowScrollChildMap = make(map[int]signalScrolledWindowScrollChildDetail)
var signalScrolledWindowScrollChildLock sync.RWMutex

// ScrolledWindowSignalScrollChildCallback is a callback function for a 'scroll-child' signal emitted from a ScrolledWindow.
type ScrolledWindowSignalScrollChildCallback func(scroll ScrollType, horizontal bool) bool

/*
ConnectScrollChild connects the callback to the 'scroll-child' signal for the ScrolledWindow.

The returned value represents the connection, and may be passed to DisconnectScrollChild to remove it.
*/
func (recv *ScrolledWindow) ConnectScrollChild(callback ScrolledWindowSignalScrollChildCallback) int {
	signalScrolledWindowScrollChildLock.Lock()
	defer signalScrolledWindowScrollChildLock.Unlock()

	signalScrolledWindowScrollChildId++
	instance := C.gpointer(recv.native)
	handlerID := C.ScrolledWindow_signal_connect_scroll_child(instance, C.gpointer(uintptr(signalScrolledWindowScrollChildId)))

	detail := signalScrolledWindowScrollChildDetail{callback, handlerID}
	signalScrolledWindowScrollChildMap[signalScrolledWindowScrollChildId] = detail

	return signalScrolledWindowScrollChildId
}

/*
DisconnectScrollChild disconnects a callback from the 'scroll-child' signal for the ScrolledWindow.

The connectionID should be a value returned from a call to ConnectScrollChild.
*/
func (recv *ScrolledWindow) DisconnectScrollChild(connectionID int) {
	signalScrolledWindowScrollChildLock.Lock()
	defer signalScrolledWindowScrollChildLock.Unlock()

	detail, exists := signalScrolledWindowScrollChildMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalScrolledWindowScrollChildMap, connectionID)
}

//export scrolledwindow_scrollChildHandler
func scrolledwindow_scrollChildHandler(_ *C.GObject, c_scroll C.GtkScrollType, c_horizontal C.gboolean, data C.gpointer) C.gboolean {
	signalScrolledWindowScrollChildLock.RLock()
	defer signalScrolledWindowScrollChildLock.RUnlock()

	scroll := ScrollType(c_scroll)

	horizontal := c_horizontal == C.TRUE

	index := int(uintptr(data))
	callback := signalScrolledWindowScrollChildMap[index].callback
	retGo := callback(scroll, horizontal)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// ScrolledWindowNew is a wrapper around the C function gtk_scrolled_window_new.
func ScrolledWindowNew(hadjustment *Adjustment, vadjustment *Adjustment) *ScrolledWindow {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_scrolled_window_new(c_hadjustment, c_vadjustment)
	retGo := ScrolledWindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AddWithViewport is a wrapper around the C function gtk_scrolled_window_add_with_viewport.
func (recv *ScrolledWindow) AddWithViewport(child *Widget) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	C.gtk_scrolled_window_add_with_viewport((*C.GtkScrolledWindow)(recv.native), c_child)

	return
}

// GetHadjustment is a wrapper around the C function gtk_scrolled_window_get_hadjustment.
func (recv *ScrolledWindow) GetHadjustment() *Adjustment {
	retC := C.gtk_scrolled_window_get_hadjustment((*C.GtkScrolledWindow)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetHscrollbar is a wrapper around the C function gtk_scrolled_window_get_hscrollbar.
func (recv *ScrolledWindow) GetHscrollbar() *Widget {
	retC := C.gtk_scrolled_window_get_hscrollbar((*C.GtkScrolledWindow)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPlacement is a wrapper around the C function gtk_scrolled_window_get_placement.
func (recv *ScrolledWindow) GetPlacement() CornerType {
	retC := C.gtk_scrolled_window_get_placement((*C.GtkScrolledWindow)(recv.native))
	retGo := (CornerType)(retC)

	return retGo
}

// GetPolicy is a wrapper around the C function gtk_scrolled_window_get_policy.
func (recv *ScrolledWindow) GetPolicy() (PolicyType, PolicyType) {
	var c_hscrollbar_policy C.GtkPolicyType

	var c_vscrollbar_policy C.GtkPolicyType

	C.gtk_scrolled_window_get_policy((*C.GtkScrolledWindow)(recv.native), &c_hscrollbar_policy, &c_vscrollbar_policy)

	hscrollbarPolicy := (PolicyType)(c_hscrollbar_policy)

	vscrollbarPolicy := (PolicyType)(c_vscrollbar_policy)

	return hscrollbarPolicy, vscrollbarPolicy
}

// GetShadowType is a wrapper around the C function gtk_scrolled_window_get_shadow_type.
func (recv *ScrolledWindow) GetShadowType() ShadowType {
	retC := C.gtk_scrolled_window_get_shadow_type((*C.GtkScrolledWindow)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// GetVadjustment is a wrapper around the C function gtk_scrolled_window_get_vadjustment.
func (recv *ScrolledWindow) GetVadjustment() *Adjustment {
	retC := C.gtk_scrolled_window_get_vadjustment((*C.GtkScrolledWindow)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetVscrollbar is a wrapper around the C function gtk_scrolled_window_get_vscrollbar.
func (recv *ScrolledWindow) GetVscrollbar() *Widget {
	retC := C.gtk_scrolled_window_get_vscrollbar((*C.GtkScrolledWindow)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetHadjustment is a wrapper around the C function gtk_scrolled_window_set_hadjustment.
func (recv *ScrolledWindow) SetHadjustment(hadjustment *Adjustment) {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	C.gtk_scrolled_window_set_hadjustment((*C.GtkScrolledWindow)(recv.native), c_hadjustment)

	return
}

// SetPlacement is a wrapper around the C function gtk_scrolled_window_set_placement.
func (recv *ScrolledWindow) SetPlacement(windowPlacement CornerType) {
	c_window_placement := (C.GtkCornerType)(windowPlacement)

	C.gtk_scrolled_window_set_placement((*C.GtkScrolledWindow)(recv.native), c_window_placement)

	return
}

// SetPolicy is a wrapper around the C function gtk_scrolled_window_set_policy.
func (recv *ScrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
	c_hscrollbar_policy := (C.GtkPolicyType)(hscrollbarPolicy)

	c_vscrollbar_policy := (C.GtkPolicyType)(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy((*C.GtkScrolledWindow)(recv.native), c_hscrollbar_policy, c_vscrollbar_policy)

	return
}

// SetShadowType is a wrapper around the C function gtk_scrolled_window_set_shadow_type.
func (recv *ScrolledWindow) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_scrolled_window_set_shadow_type((*C.GtkScrolledWindow)(recv.native), c_type)

	return
}

// SetVadjustment is a wrapper around the C function gtk_scrolled_window_set_vadjustment.
func (recv *ScrolledWindow) SetVadjustment(vadjustment *Adjustment) {
	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	C.gtk_scrolled_window_set_vadjustment((*C.GtkScrolledWindow)(recv.native), c_vadjustment)

	return
}

// UnsetPlacement is a wrapper around the C function gtk_scrolled_window_unset_placement.
func (recv *ScrolledWindow) UnsetPlacement() {
	C.gtk_scrolled_window_unset_placement((*C.GtkScrolledWindow)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ScrolledWindow
func (recv *ScrolledWindow) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ScrolledWindow
func (recv *ScrolledWindow) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ScrolledWindowAccessible is a wrapper around the C record GtkScrolledWindowAccessible.
type ScrolledWindowAccessible struct {
	native *C.GtkScrolledWindowAccessible
	// parent : record
	// priv : record
}

func ScrolledWindowAccessibleNewFromC(u unsafe.Pointer) *ScrolledWindowAccessible {
	c := (*C.GtkScrolledWindowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindowAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ScrolledWindowAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ScrolledWindowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrolledWindowAccessible with another ScrolledWindowAccessible, and returns true if they represent the same GObject.
func (recv *ScrolledWindowAccessible) Equals(other *ScrolledWindowAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ScrolledWindowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ScrolledWindowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ScrolledWindowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ScrolledWindowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ScrolledWindowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ScrolledWindowAccessible.
func CastToScrolledWindowAccessible(object *gobject.Object) *ScrolledWindowAccessible {
	return ScrolledWindowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by ScrolledWindowAccessible
func (recv *ScrolledWindowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// SearchBar is a wrapper around the C record GtkSearchBar.
type SearchBar struct {
	native *C.GtkSearchBar
	// Private : parent
}

func SearchBarNewFromC(u unsafe.Pointer) *SearchBar {
	c := (*C.GtkSearchBar)(u)
	if c == nil {
		return nil
	}

	g := &SearchBar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SearchBar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SearchBar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SearchBar with another SearchBar, and returns true if they represent the same GObject.
func (recv *SearchBar) Equals(other *SearchBar) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *SearchBar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *SearchBar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *SearchBar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SearchBar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SearchBar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to SearchBar.
// Exercise care, as this is a potentially dangerous function if the Object is not a SearchBar.
func CastToSearchBar(object *gobject.Object) *SearchBar {
	return SearchBarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SearchBar
func (recv *SearchBar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SearchBar
func (recv *SearchBar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SearchEntry is a wrapper around the C record GtkSearchEntry.
type SearchEntry struct {
	native *C.GtkSearchEntry
	// parent : record
}

func SearchEntryNewFromC(u unsafe.Pointer) *SearchEntry {
	c := (*C.GtkSearchEntry)(u)
	if c == nil {
		return nil
	}

	g := &SearchEntry{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SearchEntry) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SearchEntry) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SearchEntry with another SearchEntry, and returns true if they represent the same GObject.
func (recv *SearchEntry) Equals(other *SearchEntry) bool {
	return other.ToC() == recv.ToC()
}

// Entry upcasts to *Entry
func (recv *SearchEntry) Entry() *Entry {
	return EntryNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *SearchEntry) Widget() *Widget {
	return recv.Entry().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SearchEntry) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Entry().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SearchEntry) Object() *gobject.Object {
	return recv.Entry().Object()
}

// CastToWidget down casts any arbitrary Object to SearchEntry.
// Exercise care, as this is a potentially dangerous function if the Object is not a SearchEntry.
func CastToSearchEntry(object *gobject.Object) *SearchEntry {
	return SearchEntryNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by SearchEntry
func (recv *SearchEntry) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SearchEntry
func (recv *SearchEntry) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by SearchEntry
func (recv *SearchEntry) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by SearchEntry
func (recv *SearchEntry) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// Separator is a wrapper around the C record GtkSeparator.
type Separator struct {
	native *C.GtkSeparator
	// widget : record
	// priv : record
}

func SeparatorNewFromC(u unsafe.Pointer) *Separator {
	c := (*C.GtkSeparator)(u)
	if c == nil {
		return nil
	}

	g := &Separator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Separator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Separator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Separator with another Separator, and returns true if they represent the same GObject.
func (recv *Separator) Equals(other *Separator) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Separator) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Separator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Separator) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Separator.
// Exercise care, as this is a potentially dangerous function if the Object is not a Separator.
func CastToSeparator(object *gobject.Object) *Separator {
	return SeparatorNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Separator
func (recv *Separator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Separator
func (recv *Separator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Separator
func (recv *Separator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// SeparatorMenuItem is a wrapper around the C record GtkSeparatorMenuItem.
type SeparatorMenuItem struct {
	native *C.GtkSeparatorMenuItem
	// menu_item : record
}

func SeparatorMenuItemNewFromC(u unsafe.Pointer) *SeparatorMenuItem {
	c := (*C.GtkSeparatorMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SeparatorMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SeparatorMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorMenuItem with another SeparatorMenuItem, and returns true if they represent the same GObject.
func (recv *SeparatorMenuItem) Equals(other *SeparatorMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// MenuItem upcasts to *MenuItem
func (recv *SeparatorMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *SeparatorMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *SeparatorMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *SeparatorMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SeparatorMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SeparatorMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to SeparatorMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a SeparatorMenuItem.
func CastToSeparatorMenuItem(object *gobject.Object) *SeparatorMenuItem {
	return SeparatorMenuItemNewFromC(object.ToC())
}

// SeparatorMenuItemNew is a wrapper around the C function gtk_separator_menu_item_new.
func SeparatorMenuItemNew() *SeparatorMenuItem {
	retC := C.gtk_separator_menu_item_new()
	retGo := SeparatorMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SeparatorMenuItem
func (recv *SeparatorMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SeparatorToolItem is a wrapper around the C record GtkSeparatorToolItem.
type SeparatorToolItem struct {
	native *C.GtkSeparatorToolItem
	// parent : record
	// Private : priv
}

func SeparatorToolItemNewFromC(u unsafe.Pointer) *SeparatorToolItem {
	c := (*C.GtkSeparatorToolItem)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorToolItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SeparatorToolItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SeparatorToolItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorToolItem with another SeparatorToolItem, and returns true if they represent the same GObject.
func (recv *SeparatorToolItem) Equals(other *SeparatorToolItem) bool {
	return other.ToC() == recv.ToC()
}

// ToolItem upcasts to *ToolItem
func (recv *SeparatorToolItem) ToolItem() *ToolItem {
	return ToolItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *SeparatorToolItem) Bin() *Bin {
	return recv.ToolItem().Bin()
}

// Container upcasts to *Container
func (recv *SeparatorToolItem) Container() *Container {
	return recv.ToolItem().Container()
}

// Widget upcasts to *Widget
func (recv *SeparatorToolItem) Widget() *Widget {
	return recv.ToolItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SeparatorToolItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SeparatorToolItem) Object() *gobject.Object {
	return recv.ToolItem().Object()
}

// CastToWidget down casts any arbitrary Object to SeparatorToolItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a SeparatorToolItem.
func CastToSeparatorToolItem(object *gobject.Object) *SeparatorToolItem {
	return SeparatorToolItemNewFromC(object.ToC())
}

// SeparatorToolItemNew is a wrapper around the C function gtk_separator_tool_item_new.
func SeparatorToolItemNew() *SeparatorToolItem {
	retC := C.gtk_separator_tool_item_new()
	retGo := SeparatorToolItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDraw is a wrapper around the C function gtk_separator_tool_item_get_draw.
func (recv *SeparatorToolItem) GetDraw() bool {
	retC := C.gtk_separator_tool_item_get_draw((*C.GtkSeparatorToolItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetDraw is a wrapper around the C function gtk_separator_tool_item_set_draw.
func (recv *SeparatorToolItem) SetDraw(draw bool) {
	c_draw :=
		boolToGboolean(draw)

	C.gtk_separator_tool_item_set_draw((*C.GtkSeparatorToolItem)(recv.native), c_draw)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SeparatorToolItem
func (recv *SeparatorToolItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Settings is a wrapper around the C record GtkSettings.
type Settings struct {
	native *C.GtkSettings
	// parent_instance : record
	// Private : priv
}

func SettingsNewFromC(u unsafe.Pointer) *Settings {
	c := (*C.GtkSettings)(u)
	if c == nil {
		return nil
	}

	g := &Settings{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Settings) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Settings) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Settings with another Settings, and returns true if they represent the same GObject.
func (recv *Settings) Equals(other *Settings) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Settings) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Settings.
// Exercise care, as this is a potentially dangerous function if the Object is not a Settings.
func CastToSettings(object *gobject.Object) *Settings {
	return SettingsNewFromC(object.ToC())
}

// SettingsGetDefault is a wrapper around the C function gtk_settings_get_default.
func SettingsGetDefault() *Settings {
	retC := C.gtk_settings_get_default()
	var retGo (*Settings)
	if retC == nil {
		retGo = nil
	} else {
		retGo = SettingsNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// SettingsGetForScreen is a wrapper around the C function gtk_settings_get_for_screen.
func SettingsGetForScreen(screen *gdk.Screen) *Settings {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	retC := C.gtk_settings_get_for_screen(c_screen)
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SettingsInstallProperty is a wrapper around the C function gtk_settings_install_property.
func SettingsInstallProperty(pspec *gobject.ParamSpec) {
	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	C.gtk_settings_install_property(c_pspec)

	return
}

// gtk_settings_install_property_parser : unsupported parameter parser : no type generator for RcPropertyParser (GtkRcPropertyParser) for param parser
// SetDoubleProperty is a wrapper around the C function gtk_settings_set_double_property.
func (recv *Settings) SetDoubleProperty(name string, vDouble float64, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_double := (C.gdouble)(vDouble)

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_double_property((*C.GtkSettings)(recv.native), c_name, c_v_double, c_origin)

	return
}

// SetLongProperty is a wrapper around the C function gtk_settings_set_long_property.
func (recv *Settings) SetLongProperty(name string, vLong int64, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_long := (C.glong)(vLong)

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_long_property((*C.GtkSettings)(recv.native), c_name, c_v_long, c_origin)

	return
}

// SetPropertyValue is a wrapper around the C function gtk_settings_set_property_value.
func (recv *Settings) SetPropertyValue(name string, svalue *SettingsValue) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_svalue := (*C.GtkSettingsValue)(C.NULL)
	if svalue != nil {
		c_svalue = (*C.GtkSettingsValue)(svalue.ToC())
	}

	C.gtk_settings_set_property_value((*C.GtkSettings)(recv.native), c_name, c_svalue)

	return
}

// SetStringProperty is a wrapper around the C function gtk_settings_set_string_property.
func (recv *Settings) SetStringProperty(name string, vString string, origin string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_v_string := C.CString(vString)
	defer C.free(unsafe.Pointer(c_v_string))

	c_origin := C.CString(origin)
	defer C.free(unsafe.Pointer(c_origin))

	C.gtk_settings_set_string_property((*C.GtkSettings)(recv.native), c_name, c_v_string, c_origin)

	return
}

// StyleProvider returns the StyleProvider interface implemented by Settings
func (recv *Settings) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// SizeGroup is a wrapper around the C record GtkSizeGroup.
type SizeGroup struct {
	native *C.GtkSizeGroup
	// parent_instance : record
	// Private : priv
}

func SizeGroupNewFromC(u unsafe.Pointer) *SizeGroup {
	c := (*C.GtkSizeGroup)(u)
	if c == nil {
		return nil
	}

	g := &SizeGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SizeGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SizeGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SizeGroup with another SizeGroup, and returns true if they represent the same GObject.
func (recv *SizeGroup) Equals(other *SizeGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *SizeGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to SizeGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a SizeGroup.
func CastToSizeGroup(object *gobject.Object) *SizeGroup {
	return SizeGroupNewFromC(object.ToC())
}

// SizeGroupNew is a wrapper around the C function gtk_size_group_new.
func SizeGroupNew(mode SizeGroupMode) *SizeGroup {
	c_mode := (C.GtkSizeGroupMode)(mode)

	retC := C.gtk_size_group_new(c_mode)
	retGo := SizeGroupNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddWidget is a wrapper around the C function gtk_size_group_add_widget.
func (recv *SizeGroup) AddWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_size_group_add_widget((*C.GtkSizeGroup)(recv.native), c_widget)

	return
}

// GetIgnoreHidden is a wrapper around the C function gtk_size_group_get_ignore_hidden.
func (recv *SizeGroup) GetIgnoreHidden() bool {
	retC := C.gtk_size_group_get_ignore_hidden((*C.GtkSizeGroup)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetMode is a wrapper around the C function gtk_size_group_get_mode.
func (recv *SizeGroup) GetMode() SizeGroupMode {
	retC := C.gtk_size_group_get_mode((*C.GtkSizeGroup)(recv.native))
	retGo := (SizeGroupMode)(retC)

	return retGo
}

// GetWidgets is a wrapper around the C function gtk_size_group_get_widgets.
func (recv *SizeGroup) GetWidgets() *glib.SList {
	retC := C.gtk_size_group_get_widgets((*C.GtkSizeGroup)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RemoveWidget is a wrapper around the C function gtk_size_group_remove_widget.
func (recv *SizeGroup) RemoveWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_size_group_remove_widget((*C.GtkSizeGroup)(recv.native), c_widget)

	return
}

// SetIgnoreHidden is a wrapper around the C function gtk_size_group_set_ignore_hidden.
func (recv *SizeGroup) SetIgnoreHidden(ignoreHidden bool) {
	c_ignore_hidden :=
		boolToGboolean(ignoreHidden)

	C.gtk_size_group_set_ignore_hidden((*C.GtkSizeGroup)(recv.native), c_ignore_hidden)

	return
}

// SetMode is a wrapper around the C function gtk_size_group_set_mode.
func (recv *SizeGroup) SetMode(mode SizeGroupMode) {
	c_mode := (C.GtkSizeGroupMode)(mode)

	C.gtk_size_group_set_mode((*C.GtkSizeGroup)(recv.native), c_mode)

	return
}

// Buildable returns the Buildable interface implemented by SizeGroup
func (recv *SizeGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkSocket

// SpinButton is a wrapper around the C record GtkSpinButton.
type SpinButton struct {
	native *C.GtkSpinButton
	// entry : record
	// Private : priv
}

func SpinButtonNewFromC(u unsafe.Pointer) *SpinButton {
	c := (*C.GtkSpinButton)(u)
	if c == nil {
		return nil
	}

	g := &SpinButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SpinButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SpinButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinButton with another SpinButton, and returns true if they represent the same GObject.
func (recv *SpinButton) Equals(other *SpinButton) bool {
	return other.ToC() == recv.ToC()
}

// Entry upcasts to *Entry
func (recv *SpinButton) Entry() *Entry {
	return EntryNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *SpinButton) Widget() *Widget {
	return recv.Entry().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *SpinButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Entry().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *SpinButton) Object() *gobject.Object {
	return recv.Entry().Object()
}

// CastToWidget down casts any arbitrary Object to SpinButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinButton.
func CastToSpinButton(object *gobject.Object) *SpinButton {
	return SpinButtonNewFromC(object.ToC())
}

type signalSpinButtonChangeValueDetail struct {
	callback  SpinButtonSignalChangeValueCallback
	handlerID C.gulong
}

var signalSpinButtonChangeValueId int
var signalSpinButtonChangeValueMap = make(map[int]signalSpinButtonChangeValueDetail)
var signalSpinButtonChangeValueLock sync.RWMutex

// SpinButtonSignalChangeValueCallback is a callback function for a 'change-value' signal emitted from a SpinButton.
type SpinButtonSignalChangeValueCallback func(scroll ScrollType)

/*
ConnectChangeValue connects the callback to the 'change-value' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectChangeValue to remove it.
*/
func (recv *SpinButton) ConnectChangeValue(callback SpinButtonSignalChangeValueCallback) int {
	signalSpinButtonChangeValueLock.Lock()
	defer signalSpinButtonChangeValueLock.Unlock()

	signalSpinButtonChangeValueId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_change_value(instance, C.gpointer(uintptr(signalSpinButtonChangeValueId)))

	detail := signalSpinButtonChangeValueDetail{callback, handlerID}
	signalSpinButtonChangeValueMap[signalSpinButtonChangeValueId] = detail

	return signalSpinButtonChangeValueId
}

/*
DisconnectChangeValue disconnects a callback from the 'change-value' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectChangeValue.
*/
func (recv *SpinButton) DisconnectChangeValue(connectionID int) {
	signalSpinButtonChangeValueLock.Lock()
	defer signalSpinButtonChangeValueLock.Unlock()

	detail, exists := signalSpinButtonChangeValueMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonChangeValueMap, connectionID)
}

//export spinbutton_changeValueHandler
func spinbutton_changeValueHandler(_ *C.GObject, c_scroll C.GtkScrollType, data C.gpointer) {
	signalSpinButtonChangeValueLock.RLock()
	defer signalSpinButtonChangeValueLock.RUnlock()

	scroll := ScrollType(c_scroll)

	index := int(uintptr(data))
	callback := signalSpinButtonChangeValueMap[index].callback
	callback(scroll)
}

// Unsupported signal 'input' for SpinButton : unsupported parameter new_value : direction is 'out'

type signalSpinButtonOutputDetail struct {
	callback  SpinButtonSignalOutputCallback
	handlerID C.gulong
}

var signalSpinButtonOutputId int
var signalSpinButtonOutputMap = make(map[int]signalSpinButtonOutputDetail)
var signalSpinButtonOutputLock sync.RWMutex

// SpinButtonSignalOutputCallback is a callback function for a 'output' signal emitted from a SpinButton.
type SpinButtonSignalOutputCallback func() bool

/*
ConnectOutput connects the callback to the 'output' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectOutput to remove it.
*/
func (recv *SpinButton) ConnectOutput(callback SpinButtonSignalOutputCallback) int {
	signalSpinButtonOutputLock.Lock()
	defer signalSpinButtonOutputLock.Unlock()

	signalSpinButtonOutputId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_output(instance, C.gpointer(uintptr(signalSpinButtonOutputId)))

	detail := signalSpinButtonOutputDetail{callback, handlerID}
	signalSpinButtonOutputMap[signalSpinButtonOutputId] = detail

	return signalSpinButtonOutputId
}

/*
DisconnectOutput disconnects a callback from the 'output' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectOutput.
*/
func (recv *SpinButton) DisconnectOutput(connectionID int) {
	signalSpinButtonOutputLock.Lock()
	defer signalSpinButtonOutputLock.Unlock()

	detail, exists := signalSpinButtonOutputMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonOutputMap, connectionID)
}

//export spinbutton_outputHandler
func spinbutton_outputHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalSpinButtonOutputLock.RLock()
	defer signalSpinButtonOutputLock.RUnlock()

	index := int(uintptr(data))
	callback := signalSpinButtonOutputMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalSpinButtonValueChangedDetail struct {
	callback  SpinButtonSignalValueChangedCallback
	handlerID C.gulong
}

var signalSpinButtonValueChangedId int
var signalSpinButtonValueChangedMap = make(map[int]signalSpinButtonValueChangedDetail)
var signalSpinButtonValueChangedLock sync.RWMutex

// SpinButtonSignalValueChangedCallback is a callback function for a 'value-changed' signal emitted from a SpinButton.
type SpinButtonSignalValueChangedCallback func()

/*
ConnectValueChanged connects the callback to the 'value-changed' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectValueChanged to remove it.
*/
func (recv *SpinButton) ConnectValueChanged(callback SpinButtonSignalValueChangedCallback) int {
	signalSpinButtonValueChangedLock.Lock()
	defer signalSpinButtonValueChangedLock.Unlock()

	signalSpinButtonValueChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_value_changed(instance, C.gpointer(uintptr(signalSpinButtonValueChangedId)))

	detail := signalSpinButtonValueChangedDetail{callback, handlerID}
	signalSpinButtonValueChangedMap[signalSpinButtonValueChangedId] = detail

	return signalSpinButtonValueChangedId
}

/*
DisconnectValueChanged disconnects a callback from the 'value-changed' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectValueChanged.
*/
func (recv *SpinButton) DisconnectValueChanged(connectionID int) {
	signalSpinButtonValueChangedLock.Lock()
	defer signalSpinButtonValueChangedLock.Unlock()

	detail, exists := signalSpinButtonValueChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonValueChangedMap, connectionID)
}

//export spinbutton_valueChangedHandler
func spinbutton_valueChangedHandler(_ *C.GObject, data C.gpointer) {
	signalSpinButtonValueChangedLock.RLock()
	defer signalSpinButtonValueChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalSpinButtonValueChangedMap[index].callback
	callback()
}

type signalSpinButtonWrappedDetail struct {
	callback  SpinButtonSignalWrappedCallback
	handlerID C.gulong
}

var signalSpinButtonWrappedId int
var signalSpinButtonWrappedMap = make(map[int]signalSpinButtonWrappedDetail)
var signalSpinButtonWrappedLock sync.RWMutex

// SpinButtonSignalWrappedCallback is a callback function for a 'wrapped' signal emitted from a SpinButton.
type SpinButtonSignalWrappedCallback func()

/*
ConnectWrapped connects the callback to the 'wrapped' signal for the SpinButton.

The returned value represents the connection, and may be passed to DisconnectWrapped to remove it.
*/
func (recv *SpinButton) ConnectWrapped(callback SpinButtonSignalWrappedCallback) int {
	signalSpinButtonWrappedLock.Lock()
	defer signalSpinButtonWrappedLock.Unlock()

	signalSpinButtonWrappedId++
	instance := C.gpointer(recv.native)
	handlerID := C.SpinButton_signal_connect_wrapped(instance, C.gpointer(uintptr(signalSpinButtonWrappedId)))

	detail := signalSpinButtonWrappedDetail{callback, handlerID}
	signalSpinButtonWrappedMap[signalSpinButtonWrappedId] = detail

	return signalSpinButtonWrappedId
}

/*
DisconnectWrapped disconnects a callback from the 'wrapped' signal for the SpinButton.

The connectionID should be a value returned from a call to ConnectWrapped.
*/
func (recv *SpinButton) DisconnectWrapped(connectionID int) {
	signalSpinButtonWrappedLock.Lock()
	defer signalSpinButtonWrappedLock.Unlock()

	detail, exists := signalSpinButtonWrappedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSpinButtonWrappedMap, connectionID)
}

//export spinbutton_wrappedHandler
func spinbutton_wrappedHandler(_ *C.GObject, data C.gpointer) {
	signalSpinButtonWrappedLock.RLock()
	defer signalSpinButtonWrappedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalSpinButtonWrappedMap[index].callback
	callback()
}

// SpinButtonNew is a wrapper around the C function gtk_spin_button_new.
func SpinButtonNew(adjustment *Adjustment, climbRate float64, digits uint32) *SpinButton {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	c_climb_rate := (C.gdouble)(climbRate)

	c_digits := (C.guint)(digits)

	retC := C.gtk_spin_button_new(c_adjustment, c_climb_rate, c_digits)
	retGo := SpinButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SpinButtonNewWithRange is a wrapper around the C function gtk_spin_button_new_with_range.
func SpinButtonNewWithRange(min float64, max float64, step float64) *SpinButton {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_spin_button_new_with_range(c_min, c_max, c_step)
	retGo := SpinButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Configure is a wrapper around the C function gtk_spin_button_configure.
func (recv *SpinButton) Configure(adjustment *Adjustment, climbRate float64, digits uint32) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	c_climb_rate := (C.gdouble)(climbRate)

	c_digits := (C.guint)(digits)

	C.gtk_spin_button_configure((*C.GtkSpinButton)(recv.native), c_adjustment, c_climb_rate, c_digits)

	return
}

// GetAdjustment is a wrapper around the C function gtk_spin_button_get_adjustment.
func (recv *SpinButton) GetAdjustment() *Adjustment {
	retC := C.gtk_spin_button_get_adjustment((*C.GtkSpinButton)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDigits is a wrapper around the C function gtk_spin_button_get_digits.
func (recv *SpinButton) GetDigits() uint32 {
	retC := C.gtk_spin_button_get_digits((*C.GtkSpinButton)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetIncrements is a wrapper around the C function gtk_spin_button_get_increments.
func (recv *SpinButton) GetIncrements() (float64, float64) {
	var c_step C.gdouble

	var c_page C.gdouble

	C.gtk_spin_button_get_increments((*C.GtkSpinButton)(recv.native), &c_step, &c_page)

	step := (float64)(c_step)

	page := (float64)(c_page)

	return step, page
}

// GetNumeric is a wrapper around the C function gtk_spin_button_get_numeric.
func (recv *SpinButton) GetNumeric() bool {
	retC := C.gtk_spin_button_get_numeric((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetRange is a wrapper around the C function gtk_spin_button_get_range.
func (recv *SpinButton) GetRange() (float64, float64) {
	var c_min C.gdouble

	var c_max C.gdouble

	C.gtk_spin_button_get_range((*C.GtkSpinButton)(recv.native), &c_min, &c_max)

	min := (float64)(c_min)

	max := (float64)(c_max)

	return min, max
}

// GetSnapToTicks is a wrapper around the C function gtk_spin_button_get_snap_to_ticks.
func (recv *SpinButton) GetSnapToTicks() bool {
	retC := C.gtk_spin_button_get_snap_to_ticks((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetUpdatePolicy is a wrapper around the C function gtk_spin_button_get_update_policy.
func (recv *SpinButton) GetUpdatePolicy() SpinButtonUpdatePolicy {
	retC := C.gtk_spin_button_get_update_policy((*C.GtkSpinButton)(recv.native))
	retGo := (SpinButtonUpdatePolicy)(retC)

	return retGo
}

// GetValue is a wrapper around the C function gtk_spin_button_get_value.
func (recv *SpinButton) GetValue() float64 {
	retC := C.gtk_spin_button_get_value((*C.GtkSpinButton)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetValueAsInt is a wrapper around the C function gtk_spin_button_get_value_as_int.
func (recv *SpinButton) GetValueAsInt() int32 {
	retC := C.gtk_spin_button_get_value_as_int((*C.GtkSpinButton)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetWrap is a wrapper around the C function gtk_spin_button_get_wrap.
func (recv *SpinButton) GetWrap() bool {
	retC := C.gtk_spin_button_get_wrap((*C.GtkSpinButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetAdjustment is a wrapper around the C function gtk_spin_button_set_adjustment.
func (recv *SpinButton) SetAdjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_spin_button_set_adjustment((*C.GtkSpinButton)(recv.native), c_adjustment)

	return
}

// SetDigits is a wrapper around the C function gtk_spin_button_set_digits.
func (recv *SpinButton) SetDigits(digits uint32) {
	c_digits := (C.guint)(digits)

	C.gtk_spin_button_set_digits((*C.GtkSpinButton)(recv.native), c_digits)

	return
}

// SetIncrements is a wrapper around the C function gtk_spin_button_set_increments.
func (recv *SpinButton) SetIncrements(step float64, page float64) {
	c_step := (C.gdouble)(step)

	c_page := (C.gdouble)(page)

	C.gtk_spin_button_set_increments((*C.GtkSpinButton)(recv.native), c_step, c_page)

	return
}

// SetNumeric is a wrapper around the C function gtk_spin_button_set_numeric.
func (recv *SpinButton) SetNumeric(numeric bool) {
	c_numeric :=
		boolToGboolean(numeric)

	C.gtk_spin_button_set_numeric((*C.GtkSpinButton)(recv.native), c_numeric)

	return
}

// SetRange is a wrapper around the C function gtk_spin_button_set_range.
func (recv *SpinButton) SetRange(min float64, max float64) {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	C.gtk_spin_button_set_range((*C.GtkSpinButton)(recv.native), c_min, c_max)

	return
}

// SetSnapToTicks is a wrapper around the C function gtk_spin_button_set_snap_to_ticks.
func (recv *SpinButton) SetSnapToTicks(snapToTicks bool) {
	c_snap_to_ticks :=
		boolToGboolean(snapToTicks)

	C.gtk_spin_button_set_snap_to_ticks((*C.GtkSpinButton)(recv.native), c_snap_to_ticks)

	return
}

// SetUpdatePolicy is a wrapper around the C function gtk_spin_button_set_update_policy.
func (recv *SpinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy) {
	c_policy := (C.GtkSpinButtonUpdatePolicy)(policy)

	C.gtk_spin_button_set_update_policy((*C.GtkSpinButton)(recv.native), c_policy)

	return
}

// SetValue is a wrapper around the C function gtk_spin_button_set_value.
func (recv *SpinButton) SetValue(value float64) {
	c_value := (C.gdouble)(value)

	C.gtk_spin_button_set_value((*C.GtkSpinButton)(recv.native), c_value)

	return
}

// SetWrap is a wrapper around the C function gtk_spin_button_set_wrap.
func (recv *SpinButton) SetWrap(wrap bool) {
	c_wrap :=
		boolToGboolean(wrap)

	C.gtk_spin_button_set_wrap((*C.GtkSpinButton)(recv.native), c_wrap)

	return
}

// Spin is a wrapper around the C function gtk_spin_button_spin.
func (recv *SpinButton) Spin(direction SpinType, increment float64) {
	c_direction := (C.GtkSpinType)(direction)

	c_increment := (C.gdouble)(increment)

	C.gtk_spin_button_spin((*C.GtkSpinButton)(recv.native), c_direction, c_increment)

	return
}

// Update is a wrapper around the C function gtk_spin_button_update.
func (recv *SpinButton) Update() {
	C.gtk_spin_button_update((*C.GtkSpinButton)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by SpinButton
func (recv *SpinButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by SpinButton
func (recv *SpinButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellEditable returns the CellEditable interface implemented by SpinButton
func (recv *SpinButton) CellEditable() *CellEditable {
	return CellEditableNewFromC(recv.ToC())
}

// Editable returns the Editable interface implemented by SpinButton
func (recv *SpinButton) Editable() *Editable {
	return EditableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by SpinButton
func (recv *SpinButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// SpinButtonAccessible is a wrapper around the C record GtkSpinButtonAccessible.
type SpinButtonAccessible struct {
	native *C.GtkSpinButtonAccessible
	// parent : record
	// priv : record
}

func SpinButtonAccessibleNewFromC(u unsafe.Pointer) *SpinButtonAccessible {
	c := (*C.GtkSpinButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SpinButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SpinButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SpinButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinButtonAccessible with another SpinButtonAccessible, and returns true if they represent the same GObject.
func (recv *SpinButtonAccessible) Equals(other *SpinButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// EntryAccessible upcasts to *EntryAccessible
func (recv *SpinButtonAccessible) EntryAccessible() *EntryAccessible {
	return EntryAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SpinButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.EntryAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *SpinButtonAccessible) Accessible() *Accessible {
	return recv.EntryAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SpinButtonAccessible) Object() *atk.Object {
	return recv.EntryAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to SpinButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinButtonAccessible.
func CastToSpinButtonAccessible(object *gobject.Object) *SpinButtonAccessible {
	return SpinButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// Value returns the Value interface implemented by SpinButtonAccessible
func (recv *SpinButtonAccessible) Value() *atk.Value {
	return atk.ValueNewFromC(recv.ToC())
}

// Spinner is a wrapper around the C record GtkSpinner.
type Spinner struct {
	native *C.GtkSpinner
	// parent : record
	// Private : priv
}

func SpinnerNewFromC(u unsafe.Pointer) *Spinner {
	c := (*C.GtkSpinner)(u)
	if c == nil {
		return nil
	}

	g := &Spinner{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Spinner) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Spinner) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Spinner with another Spinner, and returns true if they represent the same GObject.
func (recv *Spinner) Equals(other *Spinner) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Spinner) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Spinner) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Spinner) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Spinner.
// Exercise care, as this is a potentially dangerous function if the Object is not a Spinner.
func CastToSpinner(object *gobject.Object) *Spinner {
	return SpinnerNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Spinner
func (recv *Spinner) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Spinner
func (recv *Spinner) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SpinnerAccessible is a wrapper around the C record GtkSpinnerAccessible.
type SpinnerAccessible struct {
	native *C.GtkSpinnerAccessible
	// parent : record
	// priv : record
}

func SpinnerAccessibleNewFromC(u unsafe.Pointer) *SpinnerAccessible {
	c := (*C.GtkSpinnerAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SpinnerAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SpinnerAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SpinnerAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinnerAccessible with another SpinnerAccessible, and returns true if they represent the same GObject.
func (recv *SpinnerAccessible) Equals(other *SpinnerAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SpinnerAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *SpinnerAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SpinnerAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to SpinnerAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SpinnerAccessible.
func CastToSpinnerAccessible(object *gobject.Object) *SpinnerAccessible {
	return SpinnerAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by SpinnerAccessible
func (recv *SpinnerAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by SpinnerAccessible
func (recv *SpinnerAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// Stack is a wrapper around the C record GtkStack.
type Stack struct {
	native *C.GtkStack
	// parent_instance : record
}

func StackNewFromC(u unsafe.Pointer) *Stack {
	c := (*C.GtkStack)(u)
	if c == nil {
		return nil
	}

	g := &Stack{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Stack) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Stack) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Stack with another Stack, and returns true if they represent the same GObject.
func (recv *Stack) Equals(other *Stack) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Stack) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Stack) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Stack) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Stack) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Stack.
// Exercise care, as this is a potentially dangerous function if the Object is not a Stack.
func CastToStack(object *gobject.Object) *Stack {
	return StackNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by Stack
func (recv *Stack) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Stack
func (recv *Stack) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Blacklisted : GtkStackAccessible

// StackSidebar is a wrapper around the C record GtkStackSidebar.
type StackSidebar struct {
	native *C.GtkStackSidebar
	// parent : record
}

func StackSidebarNewFromC(u unsafe.Pointer) *StackSidebar {
	c := (*C.GtkStackSidebar)(u)
	if c == nil {
		return nil
	}

	g := &StackSidebar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StackSidebar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StackSidebar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StackSidebar with another StackSidebar, and returns true if they represent the same GObject.
func (recv *StackSidebar) Equals(other *StackSidebar) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *StackSidebar) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *StackSidebar) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *StackSidebar) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *StackSidebar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *StackSidebar) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to StackSidebar.
// Exercise care, as this is a potentially dangerous function if the Object is not a StackSidebar.
func CastToStackSidebar(object *gobject.Object) *StackSidebar {
	return StackSidebarNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by StackSidebar
func (recv *StackSidebar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by StackSidebar
func (recv *StackSidebar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// StackSwitcher is a wrapper around the C record GtkStackSwitcher.
type StackSwitcher struct {
	native *C.GtkStackSwitcher
	// widget : record
}

func StackSwitcherNewFromC(u unsafe.Pointer) *StackSwitcher {
	c := (*C.GtkStackSwitcher)(u)
	if c == nil {
		return nil
	}

	g := &StackSwitcher{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StackSwitcher) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StackSwitcher) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StackSwitcher with another StackSwitcher, and returns true if they represent the same GObject.
func (recv *StackSwitcher) Equals(other *StackSwitcher) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *StackSwitcher) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *StackSwitcher) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *StackSwitcher) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *StackSwitcher) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *StackSwitcher) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to StackSwitcher.
// Exercise care, as this is a potentially dangerous function if the Object is not a StackSwitcher.
func CastToStackSwitcher(object *gobject.Object) *StackSwitcher {
	return StackSwitcherNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by StackSwitcher
func (recv *StackSwitcher) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by StackSwitcher
func (recv *StackSwitcher) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by StackSwitcher
func (recv *StackSwitcher) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// StatusIcon is a wrapper around the C record GtkStatusIcon.
type StatusIcon struct {
	native *C.GtkStatusIcon
	// parent_instance : record
	// priv : record
}

func StatusIconNewFromC(u unsafe.Pointer) *StatusIcon {
	c := (*C.GtkStatusIcon)(u)
	if c == nil {
		return nil
	}

	g := &StatusIcon{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StatusIcon) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StatusIcon) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusIcon with another StatusIcon, and returns true if they represent the same GObject.
func (recv *StatusIcon) Equals(other *StatusIcon) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *StatusIcon) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to StatusIcon.
// Exercise care, as this is a potentially dangerous function if the Object is not a StatusIcon.
func CastToStatusIcon(object *gobject.Object) *StatusIcon {
	return StatusIconNewFromC(object.ToC())
}

type signalStatusIconActivateDetail struct {
	callback  StatusIconSignalActivateCallback
	handlerID C.gulong
}

var signalStatusIconActivateId int
var signalStatusIconActivateMap = make(map[int]signalStatusIconActivateDetail)
var signalStatusIconActivateLock sync.RWMutex

// StatusIconSignalActivateCallback is a callback function for a 'activate' signal emitted from a StatusIcon.
type StatusIconSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the StatusIcon.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *StatusIcon) ConnectActivate(callback StatusIconSignalActivateCallback) int {
	signalStatusIconActivateLock.Lock()
	defer signalStatusIconActivateLock.Unlock()

	signalStatusIconActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.StatusIcon_signal_connect_activate(instance, C.gpointer(uintptr(signalStatusIconActivateId)))

	detail := signalStatusIconActivateDetail{callback, handlerID}
	signalStatusIconActivateMap[signalStatusIconActivateId] = detail

	return signalStatusIconActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the StatusIcon.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *StatusIcon) DisconnectActivate(connectionID int) {
	signalStatusIconActivateLock.Lock()
	defer signalStatusIconActivateLock.Unlock()

	detail, exists := signalStatusIconActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStatusIconActivateMap, connectionID)
}

//export statusicon_activateHandler
func statusicon_activateHandler(_ *C.GObject, data C.gpointer) {
	signalStatusIconActivateLock.RLock()
	defer signalStatusIconActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalStatusIconActivateMap[index].callback
	callback()
}

type signalStatusIconPopupMenuDetail struct {
	callback  StatusIconSignalPopupMenuCallback
	handlerID C.gulong
}

var signalStatusIconPopupMenuId int
var signalStatusIconPopupMenuMap = make(map[int]signalStatusIconPopupMenuDetail)
var signalStatusIconPopupMenuLock sync.RWMutex

// StatusIconSignalPopupMenuCallback is a callback function for a 'popup-menu' signal emitted from a StatusIcon.
type StatusIconSignalPopupMenuCallback func(button uint32, activateTime uint32)

/*
ConnectPopupMenu connects the callback to the 'popup-menu' signal for the StatusIcon.

The returned value represents the connection, and may be passed to DisconnectPopupMenu to remove it.
*/
func (recv *StatusIcon) ConnectPopupMenu(callback StatusIconSignalPopupMenuCallback) int {
	signalStatusIconPopupMenuLock.Lock()
	defer signalStatusIconPopupMenuLock.Unlock()

	signalStatusIconPopupMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.StatusIcon_signal_connect_popup_menu(instance, C.gpointer(uintptr(signalStatusIconPopupMenuId)))

	detail := signalStatusIconPopupMenuDetail{callback, handlerID}
	signalStatusIconPopupMenuMap[signalStatusIconPopupMenuId] = detail

	return signalStatusIconPopupMenuId
}

/*
DisconnectPopupMenu disconnects a callback from the 'popup-menu' signal for the StatusIcon.

The connectionID should be a value returned from a call to ConnectPopupMenu.
*/
func (recv *StatusIcon) DisconnectPopupMenu(connectionID int) {
	signalStatusIconPopupMenuLock.Lock()
	defer signalStatusIconPopupMenuLock.Unlock()

	detail, exists := signalStatusIconPopupMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStatusIconPopupMenuMap, connectionID)
}

//export statusicon_popupMenuHandler
func statusicon_popupMenuHandler(_ *C.GObject, c_button C.guint, c_activate_time C.guint, data C.gpointer) {
	signalStatusIconPopupMenuLock.RLock()
	defer signalStatusIconPopupMenuLock.RUnlock()

	button := uint32(c_button)

	activateTime := uint32(c_activate_time)

	index := int(uintptr(data))
	callback := signalStatusIconPopupMenuMap[index].callback
	callback(button, activateTime)
}

type signalStatusIconSizeChangedDetail struct {
	callback  StatusIconSignalSizeChangedCallback
	handlerID C.gulong
}

var signalStatusIconSizeChangedId int
var signalStatusIconSizeChangedMap = make(map[int]signalStatusIconSizeChangedDetail)
var signalStatusIconSizeChangedLock sync.RWMutex

// StatusIconSignalSizeChangedCallback is a callback function for a 'size-changed' signal emitted from a StatusIcon.
type StatusIconSignalSizeChangedCallback func(size int32) bool

/*
ConnectSizeChanged connects the callback to the 'size-changed' signal for the StatusIcon.

The returned value represents the connection, and may be passed to DisconnectSizeChanged to remove it.
*/
func (recv *StatusIcon) ConnectSizeChanged(callback StatusIconSignalSizeChangedCallback) int {
	signalStatusIconSizeChangedLock.Lock()
	defer signalStatusIconSizeChangedLock.Unlock()

	signalStatusIconSizeChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.StatusIcon_signal_connect_size_changed(instance, C.gpointer(uintptr(signalStatusIconSizeChangedId)))

	detail := signalStatusIconSizeChangedDetail{callback, handlerID}
	signalStatusIconSizeChangedMap[signalStatusIconSizeChangedId] = detail

	return signalStatusIconSizeChangedId
}

/*
DisconnectSizeChanged disconnects a callback from the 'size-changed' signal for the StatusIcon.

The connectionID should be a value returned from a call to ConnectSizeChanged.
*/
func (recv *StatusIcon) DisconnectSizeChanged(connectionID int) {
	signalStatusIconSizeChangedLock.Lock()
	defer signalStatusIconSizeChangedLock.Unlock()

	detail, exists := signalStatusIconSizeChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStatusIconSizeChangedMap, connectionID)
}

//export statusicon_sizeChangedHandler
func statusicon_sizeChangedHandler(_ *C.GObject, c_size C.gint, data C.gpointer) C.gboolean {
	signalStatusIconSizeChangedLock.RLock()
	defer signalStatusIconSizeChangedLock.RUnlock()

	size := int32(c_size)

	index := int(uintptr(data))
	callback := signalStatusIconSizeChangedMap[index].callback
	retGo := callback(size)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// StatusIconNew is a wrapper around the C function gtk_status_icon_new.
func StatusIconNew() *StatusIcon {
	retC := C.gtk_status_icon_new()
	retGo := StatusIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// StatusIconNewFromFile is a wrapper around the C function gtk_status_icon_new_from_file.
func StatusIconNewFromFile(filename string) *StatusIcon {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.gtk_status_icon_new_from_file(c_filename)
	retGo := StatusIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// StatusIconNewFromIconName is a wrapper around the C function gtk_status_icon_new_from_icon_name.
func StatusIconNewFromIconName(iconName string) *StatusIcon {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	retC := C.gtk_status_icon_new_from_icon_name(c_icon_name)
	retGo := StatusIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// StatusIconNewFromPixbuf is a wrapper around the C function gtk_status_icon_new_from_pixbuf.
func StatusIconNewFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *StatusIcon {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	retC := C.gtk_status_icon_new_from_pixbuf(c_pixbuf)
	retGo := StatusIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// StatusIconNewFromStock is a wrapper around the C function gtk_status_icon_new_from_stock.
func StatusIconNewFromStock(stockId string) *StatusIcon {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_status_icon_new_from_stock(c_stock_id)
	retGo := StatusIconNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// StatusIconPositionMenu is a wrapper around the C function gtk_status_icon_position_menu.
func StatusIconPositionMenu(menu *Menu, x int32, y int32, userData *StatusIcon) bool {
	c_menu := (*C.GtkMenu)(C.NULL)
	if menu != nil {
		c_menu = (*C.GtkMenu)(menu.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	var c_push_in C.gboolean

	c_user_data := (C.gpointer)(C.NULL)
	if userData != nil {
		c_user_data = (C.gpointer)(userData.ToC())
	}

	C.gtk_status_icon_position_menu(c_menu, &c_x, &c_y, &c_push_in, c_user_data)

	pushIn := c_push_in == C.TRUE

	return pushIn
}

// GetGeometry is a wrapper around the C function gtk_status_icon_get_geometry.
func (recv *StatusIcon) GetGeometry() (bool, *gdk.Screen, *gdk.Rectangle, Orientation) {
	var c_screen *C.GdkScreen

	var c_area C.GdkRectangle

	var c_orientation C.GtkOrientation

	retC := C.gtk_status_icon_get_geometry((*C.GtkStatusIcon)(recv.native), &c_screen, &c_area, &c_orientation)
	retGo := retC == C.TRUE

	screen := gdk.ScreenNewFromC(unsafe.Pointer(c_screen))

	area := gdk.RectangleNewFromC(unsafe.Pointer(&c_area))

	orientation := (Orientation)(c_orientation)

	return retGo, screen, area, orientation
}

// GetIconName is a wrapper around the C function gtk_status_icon_get_icon_name.
func (recv *StatusIcon) GetIconName() string {
	retC := C.gtk_status_icon_get_icon_name((*C.GtkStatusIcon)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPixbuf is a wrapper around the C function gtk_status_icon_get_pixbuf.
func (recv *StatusIcon) GetPixbuf() *gdkpixbuf.Pixbuf {
	retC := C.gtk_status_icon_get_pixbuf((*C.GtkStatusIcon)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetScreen is a wrapper around the C function gtk_status_icon_get_screen.
func (recv *StatusIcon) GetScreen() *gdk.Screen {
	retC := C.gtk_status_icon_get_screen((*C.GtkStatusIcon)(recv.native))
	retGo := gdk.ScreenNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSize is a wrapper around the C function gtk_status_icon_get_size.
func (recv *StatusIcon) GetSize() int32 {
	retC := C.gtk_status_icon_get_size((*C.GtkStatusIcon)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetStock is a wrapper around the C function gtk_status_icon_get_stock.
func (recv *StatusIcon) GetStock() string {
	retC := C.gtk_status_icon_get_stock((*C.GtkStatusIcon)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetStorageType is a wrapper around the C function gtk_status_icon_get_storage_type.
func (recv *StatusIcon) GetStorageType() ImageType {
	retC := C.gtk_status_icon_get_storage_type((*C.GtkStatusIcon)(recv.native))
	retGo := (ImageType)(retC)

	return retGo
}

// GetVisible is a wrapper around the C function gtk_status_icon_get_visible.
func (recv *StatusIcon) GetVisible() bool {
	retC := C.gtk_status_icon_get_visible((*C.GtkStatusIcon)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsEmbedded is a wrapper around the C function gtk_status_icon_is_embedded.
func (recv *StatusIcon) IsEmbedded() bool {
	retC := C.gtk_status_icon_is_embedded((*C.GtkStatusIcon)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetFromFile is a wrapper around the C function gtk_status_icon_set_from_file.
func (recv *StatusIcon) SetFromFile(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_status_icon_set_from_file((*C.GtkStatusIcon)(recv.native), c_filename)

	return
}

// SetFromIconName is a wrapper around the C function gtk_status_icon_set_from_icon_name.
func (recv *StatusIcon) SetFromIconName(iconName string) {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	C.gtk_status_icon_set_from_icon_name((*C.GtkStatusIcon)(recv.native), c_icon_name)

	return
}

// SetFromPixbuf is a wrapper around the C function gtk_status_icon_set_from_pixbuf.
func (recv *StatusIcon) SetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_status_icon_set_from_pixbuf((*C.GtkStatusIcon)(recv.native), c_pixbuf)

	return
}

// SetFromStock is a wrapper around the C function gtk_status_icon_set_from_stock.
func (recv *StatusIcon) SetFromStock(stockId string) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	C.gtk_status_icon_set_from_stock((*C.GtkStatusIcon)(recv.native), c_stock_id)

	return
}

// SetScreen is a wrapper around the C function gtk_status_icon_set_screen.
func (recv *StatusIcon) SetScreen(screen *gdk.Screen) {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	C.gtk_status_icon_set_screen((*C.GtkStatusIcon)(recv.native), c_screen)

	return
}

// SetVisible is a wrapper around the C function gtk_status_icon_set_visible.
func (recv *StatusIcon) SetVisible(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_status_icon_set_visible((*C.GtkStatusIcon)(recv.native), c_visible)

	return
}

// Statusbar is a wrapper around the C record GtkStatusbar.
type Statusbar struct {
	native *C.GtkStatusbar
	// parent_widget : record
	// Private : priv
}

func StatusbarNewFromC(u unsafe.Pointer) *Statusbar {
	c := (*C.GtkStatusbar)(u)
	if c == nil {
		return nil
	}

	g := &Statusbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Statusbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Statusbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Statusbar with another Statusbar, and returns true if they represent the same GObject.
func (recv *Statusbar) Equals(other *Statusbar) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *Statusbar) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Statusbar) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *Statusbar) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Statusbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Statusbar) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to Statusbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Statusbar.
func CastToStatusbar(object *gobject.Object) *Statusbar {
	return StatusbarNewFromC(object.ToC())
}

type signalStatusbarTextPoppedDetail struct {
	callback  StatusbarSignalTextPoppedCallback
	handlerID C.gulong
}

var signalStatusbarTextPoppedId int
var signalStatusbarTextPoppedMap = make(map[int]signalStatusbarTextPoppedDetail)
var signalStatusbarTextPoppedLock sync.RWMutex

// StatusbarSignalTextPoppedCallback is a callback function for a 'text-popped' signal emitted from a Statusbar.
type StatusbarSignalTextPoppedCallback func(contextId uint32, text string)

/*
ConnectTextPopped connects the callback to the 'text-popped' signal for the Statusbar.

The returned value represents the connection, and may be passed to DisconnectTextPopped to remove it.
*/
func (recv *Statusbar) ConnectTextPopped(callback StatusbarSignalTextPoppedCallback) int {
	signalStatusbarTextPoppedLock.Lock()
	defer signalStatusbarTextPoppedLock.Unlock()

	signalStatusbarTextPoppedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Statusbar_signal_connect_text_popped(instance, C.gpointer(uintptr(signalStatusbarTextPoppedId)))

	detail := signalStatusbarTextPoppedDetail{callback, handlerID}
	signalStatusbarTextPoppedMap[signalStatusbarTextPoppedId] = detail

	return signalStatusbarTextPoppedId
}

/*
DisconnectTextPopped disconnects a callback from the 'text-popped' signal for the Statusbar.

The connectionID should be a value returned from a call to ConnectTextPopped.
*/
func (recv *Statusbar) DisconnectTextPopped(connectionID int) {
	signalStatusbarTextPoppedLock.Lock()
	defer signalStatusbarTextPoppedLock.Unlock()

	detail, exists := signalStatusbarTextPoppedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStatusbarTextPoppedMap, connectionID)
}

//export statusbar_textPoppedHandler
func statusbar_textPoppedHandler(_ *C.GObject, c_context_id C.guint, c_text *C.gchar, data C.gpointer) {
	signalStatusbarTextPoppedLock.RLock()
	defer signalStatusbarTextPoppedLock.RUnlock()

	contextId := uint32(c_context_id)

	text := C.GoString(c_text)

	index := int(uintptr(data))
	callback := signalStatusbarTextPoppedMap[index].callback
	callback(contextId, text)
}

type signalStatusbarTextPushedDetail struct {
	callback  StatusbarSignalTextPushedCallback
	handlerID C.gulong
}

var signalStatusbarTextPushedId int
var signalStatusbarTextPushedMap = make(map[int]signalStatusbarTextPushedDetail)
var signalStatusbarTextPushedLock sync.RWMutex

// StatusbarSignalTextPushedCallback is a callback function for a 'text-pushed' signal emitted from a Statusbar.
type StatusbarSignalTextPushedCallback func(contextId uint32, text string)

/*
ConnectTextPushed connects the callback to the 'text-pushed' signal for the Statusbar.

The returned value represents the connection, and may be passed to DisconnectTextPushed to remove it.
*/
func (recv *Statusbar) ConnectTextPushed(callback StatusbarSignalTextPushedCallback) int {
	signalStatusbarTextPushedLock.Lock()
	defer signalStatusbarTextPushedLock.Unlock()

	signalStatusbarTextPushedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Statusbar_signal_connect_text_pushed(instance, C.gpointer(uintptr(signalStatusbarTextPushedId)))

	detail := signalStatusbarTextPushedDetail{callback, handlerID}
	signalStatusbarTextPushedMap[signalStatusbarTextPushedId] = detail

	return signalStatusbarTextPushedId
}

/*
DisconnectTextPushed disconnects a callback from the 'text-pushed' signal for the Statusbar.

The connectionID should be a value returned from a call to ConnectTextPushed.
*/
func (recv *Statusbar) DisconnectTextPushed(connectionID int) {
	signalStatusbarTextPushedLock.Lock()
	defer signalStatusbarTextPushedLock.Unlock()

	detail, exists := signalStatusbarTextPushedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStatusbarTextPushedMap, connectionID)
}

//export statusbar_textPushedHandler
func statusbar_textPushedHandler(_ *C.GObject, c_context_id C.guint, c_text *C.gchar, data C.gpointer) {
	signalStatusbarTextPushedLock.RLock()
	defer signalStatusbarTextPushedLock.RUnlock()

	contextId := uint32(c_context_id)

	text := C.GoString(c_text)

	index := int(uintptr(data))
	callback := signalStatusbarTextPushedMap[index].callback
	callback(contextId, text)
}

// StatusbarNew is a wrapper around the C function gtk_statusbar_new.
func StatusbarNew() *Statusbar {
	retC := C.gtk_statusbar_new()
	retGo := StatusbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetContextId is a wrapper around the C function gtk_statusbar_get_context_id.
func (recv *Statusbar) GetContextId(contextDescription string) uint32 {
	c_context_description := C.CString(contextDescription)
	defer C.free(unsafe.Pointer(c_context_description))

	retC := C.gtk_statusbar_get_context_id((*C.GtkStatusbar)(recv.native), c_context_description)
	retGo := (uint32)(retC)

	return retGo
}

// Pop is a wrapper around the C function gtk_statusbar_pop.
func (recv *Statusbar) Pop(contextId uint32) {
	c_context_id := (C.guint)(contextId)

	C.gtk_statusbar_pop((*C.GtkStatusbar)(recv.native), c_context_id)

	return
}

// Push is a wrapper around the C function gtk_statusbar_push.
func (recv *Statusbar) Push(contextId uint32, text string) uint32 {
	c_context_id := (C.guint)(contextId)

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	retC := C.gtk_statusbar_push((*C.GtkStatusbar)(recv.native), c_context_id, c_text)
	retGo := (uint32)(retC)

	return retGo
}

// Remove is a wrapper around the C function gtk_statusbar_remove.
func (recv *Statusbar) Remove(contextId uint32, messageId uint32) {
	c_context_id := (C.guint)(contextId)

	c_message_id := (C.guint)(messageId)

	C.gtk_statusbar_remove((*C.GtkStatusbar)(recv.native), c_context_id, c_message_id)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Statusbar
func (recv *Statusbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Statusbar
func (recv *Statusbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Statusbar
func (recv *Statusbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// StatusbarAccessible is a wrapper around the C record GtkStatusbarAccessible.
type StatusbarAccessible struct {
	native *C.GtkStatusbarAccessible
	// parent : record
	// priv : record
}

func StatusbarAccessibleNewFromC(u unsafe.Pointer) *StatusbarAccessible {
	c := (*C.GtkStatusbarAccessible)(u)
	if c == nil {
		return nil
	}

	g := &StatusbarAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StatusbarAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StatusbarAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusbarAccessible with another StatusbarAccessible, and returns true if they represent the same GObject.
func (recv *StatusbarAccessible) Equals(other *StatusbarAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *StatusbarAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *StatusbarAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *StatusbarAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *StatusbarAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to StatusbarAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a StatusbarAccessible.
func CastToStatusbarAccessible(object *gobject.Object) *StatusbarAccessible {
	return StatusbarAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by StatusbarAccessible
func (recv *StatusbarAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Style is a wrapper around the C record GtkStyle.
type Style struct {
	native *C.GtkStyle
	// Private : parent_instance
	// no type for fg
	// no type for bg
	// no type for light
	// no type for dark
	// no type for mid
	// no type for text
	// no type for base
	// no type for text_aa
	// black : record
	// white : record
	// font_desc : record
	Xthickness int32
	Ythickness int32
	// no type for background
	// Private : attach_count
	// Private : visual
	// Private : private_font_desc
	// Private : rc_style
	// Private : styles
	// Private : property_cache
	// Private : icon_factories
}

func StyleNewFromC(u unsafe.Pointer) *Style {
	c := (*C.GtkStyle)(u)
	if c == nil {
		return nil
	}

	g := &Style{
		Xthickness: (int32)(c.xthickness),
		Ythickness: (int32)(c.ythickness),
		native:     c,
	}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Style) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Style) ToC() unsafe.Pointer {
	recv.native.xthickness =
		(C.gint)(recv.Xthickness)
	recv.native.ythickness =
		(C.gint)(recv.Ythickness)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Style with another Style, and returns true if they represent the same GObject.
func (recv *Style) Equals(other *Style) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Style) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Style.
// Exercise care, as this is a potentially dangerous function if the Object is not a Style.
func CastToStyle(object *gobject.Object) *Style {
	return StyleNewFromC(object.ToC())
}

type signalStyleRealizeDetail struct {
	callback  StyleSignalRealizeCallback
	handlerID C.gulong
}

var signalStyleRealizeId int
var signalStyleRealizeMap = make(map[int]signalStyleRealizeDetail)
var signalStyleRealizeLock sync.RWMutex

// StyleSignalRealizeCallback is a callback function for a 'realize' signal emitted from a Style.
type StyleSignalRealizeCallback func()

/*
ConnectRealize connects the callback to the 'realize' signal for the Style.

The returned value represents the connection, and may be passed to DisconnectRealize to remove it.
*/
func (recv *Style) ConnectRealize(callback StyleSignalRealizeCallback) int {
	signalStyleRealizeLock.Lock()
	defer signalStyleRealizeLock.Unlock()

	signalStyleRealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Style_signal_connect_realize(instance, C.gpointer(uintptr(signalStyleRealizeId)))

	detail := signalStyleRealizeDetail{callback, handlerID}
	signalStyleRealizeMap[signalStyleRealizeId] = detail

	return signalStyleRealizeId
}

/*
DisconnectRealize disconnects a callback from the 'realize' signal for the Style.

The connectionID should be a value returned from a call to ConnectRealize.
*/
func (recv *Style) DisconnectRealize(connectionID int) {
	signalStyleRealizeLock.Lock()
	defer signalStyleRealizeLock.Unlock()

	detail, exists := signalStyleRealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStyleRealizeMap, connectionID)
}

//export style_realizeHandler
func style_realizeHandler(_ *C.GObject, data C.gpointer) {
	signalStyleRealizeLock.RLock()
	defer signalStyleRealizeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalStyleRealizeMap[index].callback
	callback()
}

type signalStyleUnrealizeDetail struct {
	callback  StyleSignalUnrealizeCallback
	handlerID C.gulong
}

var signalStyleUnrealizeId int
var signalStyleUnrealizeMap = make(map[int]signalStyleUnrealizeDetail)
var signalStyleUnrealizeLock sync.RWMutex

// StyleSignalUnrealizeCallback is a callback function for a 'unrealize' signal emitted from a Style.
type StyleSignalUnrealizeCallback func()

/*
ConnectUnrealize connects the callback to the 'unrealize' signal for the Style.

The returned value represents the connection, and may be passed to DisconnectUnrealize to remove it.
*/
func (recv *Style) ConnectUnrealize(callback StyleSignalUnrealizeCallback) int {
	signalStyleUnrealizeLock.Lock()
	defer signalStyleUnrealizeLock.Unlock()

	signalStyleUnrealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Style_signal_connect_unrealize(instance, C.gpointer(uintptr(signalStyleUnrealizeId)))

	detail := signalStyleUnrealizeDetail{callback, handlerID}
	signalStyleUnrealizeMap[signalStyleUnrealizeId] = detail

	return signalStyleUnrealizeId
}

/*
DisconnectUnrealize disconnects a callback from the 'unrealize' signal for the Style.

The connectionID should be a value returned from a call to ConnectUnrealize.
*/
func (recv *Style) DisconnectUnrealize(connectionID int) {
	signalStyleUnrealizeLock.Lock()
	defer signalStyleUnrealizeLock.Unlock()

	detail, exists := signalStyleUnrealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalStyleUnrealizeMap, connectionID)
}

//export style_unrealizeHandler
func style_unrealizeHandler(_ *C.GObject, data C.gpointer) {
	signalStyleUnrealizeLock.RLock()
	defer signalStyleUnrealizeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalStyleUnrealizeMap[index].callback
	callback()
}

// StyleNew is a wrapper around the C function gtk_style_new.
func StyleNew() *Style {
	retC := C.gtk_style_new()
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// ApplyDefaultBackground is a wrapper around the C function gtk_style_apply_default_background.
func (recv *Style) ApplyDefaultBackground(cr *cairo.Context, window *gdk.Window, stateType StateType, x int32, y int32, width int32, height int32) {
	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_style_apply_default_background((*C.GtkStyle)(recv.native), c_cr, c_window, c_state_type, c_x, c_y, c_width, c_height)

	return
}

// Attach is a wrapper around the C function gtk_style_attach.
func (recv *Style) Attach(window *gdk.Window) *Style {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	retC := C.gtk_style_attach((*C.GtkStyle)(recv.native), c_window)
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Copy is a wrapper around the C function gtk_style_copy.
func (recv *Style) Copy() *Style {
	retC := C.gtk_style_copy((*C.GtkStyle)(recv.native))
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Detach is a wrapper around the C function gtk_style_detach.
func (recv *Style) Detach() {
	C.gtk_style_detach((*C.GtkStyle)(recv.native))

	return
}

// LookupColor is a wrapper around the C function gtk_style_lookup_color.
func (recv *Style) LookupColor(colorName string) (bool, *gdk.Color) {
	c_color_name := C.CString(colorName)
	defer C.free(unsafe.Pointer(c_color_name))

	var c_color C.GdkColor

	retC := C.gtk_style_lookup_color((*C.GtkStyle)(recv.native), c_color_name, &c_color)
	retGo := retC == C.TRUE

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return retGo, color
}

// LookupIconSet is a wrapper around the C function gtk_style_lookup_icon_set.
func (recv *Style) LookupIconSet(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_style_lookup_icon_set((*C.GtkStyle)(recv.native), c_stock_id)
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RenderIcon is a wrapper around the C function gtk_style_render_icon.
func (recv *Style) RenderIcon(source *IconSource, direction TextDirection, state StateType, size IconSize, widget *Widget, detail string) *gdkpixbuf.Pixbuf {
	c_source := (*C.GtkIconSource)(C.NULL)
	if source != nil {
		c_source = (*C.GtkIconSource)(source.ToC())
	}

	c_direction := (C.GtkTextDirection)(direction)

	c_state := (C.GtkStateType)(state)

	c_size := (C.GtkIconSize)(size)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	retC := C.gtk_style_render_icon((*C.GtkStyle)(recv.native), c_source, c_direction, c_state, c_size, c_widget, c_detail)
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetBackground is a wrapper around the C function gtk_style_set_background.
func (recv *Style) SetBackground(window *gdk.Window, stateType StateType) {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	C.gtk_style_set_background((*C.GtkStyle)(recv.native), c_window, c_state_type)

	return
}

// StyleContext is a wrapper around the C record GtkStyleContext.
type StyleContext struct {
	native *C.GtkStyleContext
	// parent_object : record
	// priv : record
}

func StyleContextNewFromC(u unsafe.Pointer) *StyleContext {
	c := (*C.GtkStyleContext)(u)
	if c == nil {
		return nil
	}

	g := &StyleContext{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StyleContext) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StyleContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleContext with another StyleContext, and returns true if they represent the same GObject.
func (recv *StyleContext) Equals(other *StyleContext) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *StyleContext) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to StyleContext.
// Exercise care, as this is a potentially dangerous function if the Object is not a StyleContext.
func CastToStyleContext(object *gobject.Object) *StyleContext {
	return StyleContextNewFromC(object.ToC())
}

// StyleContextNew is a wrapper around the C function gtk_style_context_new.
func StyleContextNew() *StyleContext {
	retC := C.gtk_style_context_new()
	retGo := StyleContextNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetScreen is a wrapper around the C function gtk_style_context_get_screen.
func (recv *StyleContext) GetScreen() *gdk.Screen {
	retC := C.gtk_style_context_get_screen((*C.GtkStyleContext)(recv.native))
	retGo := gdk.ScreenNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSection is a wrapper around the C function gtk_style_context_get_section.
func (recv *StyleContext) GetSection(property string) *CssSection {
	c_property := C.CString(property)
	defer C.free(unsafe.Pointer(c_property))

	retC := C.gtk_style_context_get_section((*C.GtkStyleContext)(recv.native), c_property)
	var retGo (*CssSection)
	if retC == nil {
		retGo = nil
	} else {
		retGo = CssSectionNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetStyleProperty is a wrapper around the C function gtk_style_context_get_style_property.
func (recv *StyleContext) GetStyleProperty(propertyName string, value *gobject.Value) {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_style_context_get_style_property((*C.GtkStyleContext)(recv.native), c_property_name, c_value)

	return
}

// LookupColor is a wrapper around the C function gtk_style_context_lookup_color.
func (recv *StyleContext) LookupColor(colorName string) (bool, *gdk.RGBA) {
	c_color_name := C.CString(colorName)
	defer C.free(unsafe.Pointer(c_color_name))

	var c_color C.GdkRGBA

	retC := C.gtk_style_context_lookup_color((*C.GtkStyleContext)(recv.native), c_color_name, &c_color)
	retGo := retC == C.TRUE

	color := gdk.RGBANewFromC(unsafe.Pointer(&c_color))

	return retGo, color
}

// LookupIconSet is a wrapper around the C function gtk_style_context_lookup_icon_set.
func (recv *StyleContext) LookupIconSet(stockId string) *IconSet {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_style_context_lookup_icon_set((*C.GtkStyleContext)(recv.native), c_stock_id)
	var retGo (*IconSet)
	if retC == nil {
		retGo = nil
	} else {
		retGo = IconSetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// StyleProperties is a wrapper around the C record GtkStyleProperties.
type StyleProperties struct {
	native *C.GtkStyleProperties
	// Private : parent_object
	// Private : priv
}

func StylePropertiesNewFromC(u unsafe.Pointer) *StyleProperties {
	c := (*C.GtkStyleProperties)(u)
	if c == nil {
		return nil
	}

	g := &StyleProperties{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *StyleProperties) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *StyleProperties) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleProperties with another StyleProperties, and returns true if they represent the same GObject.
func (recv *StyleProperties) Equals(other *StyleProperties) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *StyleProperties) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to StyleProperties.
// Exercise care, as this is a potentially dangerous function if the Object is not a StyleProperties.
func CastToStyleProperties(object *gobject.Object) *StyleProperties {
	return StylePropertiesNewFromC(object.ToC())
}

// StylePropertiesNew is a wrapper around the C function gtk_style_properties_new.
func StylePropertiesNew() *StyleProperties {
	retC := C.gtk_style_properties_new()
	retGo := StylePropertiesNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Clear is a wrapper around the C function gtk_style_properties_clear.
func (recv *StyleProperties) Clear() {
	C.gtk_style_properties_clear((*C.GtkStyleProperties)(recv.native))

	return
}

// StyleProvider returns the StyleProvider interface implemented by StyleProperties
func (recv *StyleProperties) StyleProvider() *StyleProvider {
	return StyleProviderNewFromC(recv.ToC())
}

// Switch is a wrapper around the C record GtkSwitch.
type Switch struct {
	native *C.GtkSwitch
	// Private : parent_instance
	// Private : priv
}

func SwitchNewFromC(u unsafe.Pointer) *Switch {
	c := (*C.GtkSwitch)(u)
	if c == nil {
		return nil
	}

	g := &Switch{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Switch) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Switch) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Switch with another Switch, and returns true if they represent the same GObject.
func (recv *Switch) Equals(other *Switch) bool {
	return other.ToC() == recv.ToC()
}

// Widget upcasts to *Widget
func (recv *Switch) Widget() *Widget {
	return WidgetNewFromC(unsafe.Pointer(recv.native))
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Switch) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Widget().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Switch) Object() *gobject.Object {
	return recv.Widget().Object()
}

// CastToWidget down casts any arbitrary Object to Switch.
// Exercise care, as this is a potentially dangerous function if the Object is not a Switch.
func CastToSwitch(object *gobject.Object) *Switch {
	return SwitchNewFromC(object.ToC())
}

type signalSwitchActivateDetail struct {
	callback  SwitchSignalActivateCallback
	handlerID C.gulong
}

var signalSwitchActivateId int
var signalSwitchActivateMap = make(map[int]signalSwitchActivateDetail)
var signalSwitchActivateLock sync.RWMutex

// SwitchSignalActivateCallback is a callback function for a 'activate' signal emitted from a Switch.
type SwitchSignalActivateCallback func()

/*
ConnectActivate connects the callback to the 'activate' signal for the Switch.

The returned value represents the connection, and may be passed to DisconnectActivate to remove it.
*/
func (recv *Switch) ConnectActivate(callback SwitchSignalActivateCallback) int {
	signalSwitchActivateLock.Lock()
	defer signalSwitchActivateLock.Unlock()

	signalSwitchActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Switch_signal_connect_activate(instance, C.gpointer(uintptr(signalSwitchActivateId)))

	detail := signalSwitchActivateDetail{callback, handlerID}
	signalSwitchActivateMap[signalSwitchActivateId] = detail

	return signalSwitchActivateId
}

/*
DisconnectActivate disconnects a callback from the 'activate' signal for the Switch.

The connectionID should be a value returned from a call to ConnectActivate.
*/
func (recv *Switch) DisconnectActivate(connectionID int) {
	signalSwitchActivateLock.Lock()
	defer signalSwitchActivateLock.Unlock()

	detail, exists := signalSwitchActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalSwitchActivateMap, connectionID)
}

//export switch_activateHandler
func switch_activateHandler(_ *C.GObject, data C.gpointer) {
	signalSwitchActivateLock.RLock()
	defer signalSwitchActivateLock.RUnlock()

	index := int(uintptr(data))
	callback := signalSwitchActivateMap[index].callback
	callback()
}

// ImplementorIface returns the ImplementorIface interface implemented by Switch
func (recv *Switch) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by Switch
func (recv *Switch) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by Switch
func (recv *Switch) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Switch
func (recv *Switch) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// SwitchAccessible is a wrapper around the C record GtkSwitchAccessible.
type SwitchAccessible struct {
	native *C.GtkSwitchAccessible
	// parent : record
	// priv : record
}

func SwitchAccessibleNewFromC(u unsafe.Pointer) *SwitchAccessible {
	c := (*C.GtkSwitchAccessible)(u)
	if c == nil {
		return nil
	}

	g := &SwitchAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *SwitchAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *SwitchAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SwitchAccessible with another SwitchAccessible, and returns true if they represent the same GObject.
func (recv *SwitchAccessible) Equals(other *SwitchAccessible) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *SwitchAccessible) WidgetAccessible() *WidgetAccessible {
	return WidgetAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Accessible upcasts to *Accessible
func (recv *SwitchAccessible) Accessible() *Accessible {
	return recv.WidgetAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *SwitchAccessible) Object() *atk.Object {
	return recv.WidgetAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to SwitchAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a SwitchAccessible.
func CastToSwitchAccessible(object *gobject.Object) *SwitchAccessible {
	return SwitchAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by SwitchAccessible
func (recv *SwitchAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by SwitchAccessible
func (recv *SwitchAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Table is a wrapper around the C record GtkTable.
type Table struct {
	native *C.GtkTable
	// container : record
	// Private : priv
}

func TableNewFromC(u unsafe.Pointer) *Table {
	c := (*C.GtkTable)(u)
	if c == nil {
		return nil
	}

	g := &Table{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Table) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Table) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Table with another Table, and returns true if they represent the same GObject.
func (recv *Table) Equals(other *Table) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Table) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Table) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Table) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Table) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Table.
// Exercise care, as this is a potentially dangerous function if the Object is not a Table.
func CastToTable(object *gobject.Object) *Table {
	return TableNewFromC(object.ToC())
}

// TableNew is a wrapper around the C function gtk_table_new.
func TableNew(rows uint32, columns uint32, homogeneous bool) *Table {
	c_rows := (C.guint)(rows)

	c_columns := (C.guint)(columns)

	c_homogeneous :=
		boolToGboolean(homogeneous)

	retC := C.gtk_table_new(c_rows, c_columns, c_homogeneous)
	retGo := TableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Attach is a wrapper around the C function gtk_table_attach.
func (recv *Table) Attach(child *Widget, leftAttach uint32, rightAttach uint32, topAttach uint32, bottomAttach uint32, xoptions AttachOptions, yoptions AttachOptions, xpadding uint32, ypadding uint32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_left_attach := (C.guint)(leftAttach)

	c_right_attach := (C.guint)(rightAttach)

	c_top_attach := (C.guint)(topAttach)

	c_bottom_attach := (C.guint)(bottomAttach)

	c_xoptions := (C.GtkAttachOptions)(xoptions)

	c_yoptions := (C.GtkAttachOptions)(yoptions)

	c_xpadding := (C.guint)(xpadding)

	c_ypadding := (C.guint)(ypadding)

	C.gtk_table_attach((*C.GtkTable)(recv.native), c_child, c_left_attach, c_right_attach, c_top_attach, c_bottom_attach, c_xoptions, c_yoptions, c_xpadding, c_ypadding)

	return
}

// AttachDefaults is a wrapper around the C function gtk_table_attach_defaults.
func (recv *Table) AttachDefaults(widget *Widget, leftAttach uint32, rightAttach uint32, topAttach uint32, bottomAttach uint32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_left_attach := (C.guint)(leftAttach)

	c_right_attach := (C.guint)(rightAttach)

	c_top_attach := (C.guint)(topAttach)

	c_bottom_attach := (C.guint)(bottomAttach)

	C.gtk_table_attach_defaults((*C.GtkTable)(recv.native), c_widget, c_left_attach, c_right_attach, c_top_attach, c_bottom_attach)

	return
}

// GetColSpacing is a wrapper around the C function gtk_table_get_col_spacing.
func (recv *Table) GetColSpacing(column uint32) uint32 {
	c_column := (C.guint)(column)

	retC := C.gtk_table_get_col_spacing((*C.GtkTable)(recv.native), c_column)
	retGo := (uint32)(retC)

	return retGo
}

// GetDefaultColSpacing is a wrapper around the C function gtk_table_get_default_col_spacing.
func (recv *Table) GetDefaultColSpacing() uint32 {
	retC := C.gtk_table_get_default_col_spacing((*C.GtkTable)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetDefaultRowSpacing is a wrapper around the C function gtk_table_get_default_row_spacing.
func (recv *Table) GetDefaultRowSpacing() uint32 {
	retC := C.gtk_table_get_default_row_spacing((*C.GtkTable)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// GetHomogeneous is a wrapper around the C function gtk_table_get_homogeneous.
func (recv *Table) GetHomogeneous() bool {
	retC := C.gtk_table_get_homogeneous((*C.GtkTable)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetRowSpacing is a wrapper around the C function gtk_table_get_row_spacing.
func (recv *Table) GetRowSpacing(row uint32) uint32 {
	c_row := (C.guint)(row)

	retC := C.gtk_table_get_row_spacing((*C.GtkTable)(recv.native), c_row)
	retGo := (uint32)(retC)

	return retGo
}

// Resize is a wrapper around the C function gtk_table_resize.
func (recv *Table) Resize(rows uint32, columns uint32) {
	c_rows := (C.guint)(rows)

	c_columns := (C.guint)(columns)

	C.gtk_table_resize((*C.GtkTable)(recv.native), c_rows, c_columns)

	return
}

// SetColSpacing is a wrapper around the C function gtk_table_set_col_spacing.
func (recv *Table) SetColSpacing(column uint32, spacing uint32) {
	c_column := (C.guint)(column)

	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_col_spacing((*C.GtkTable)(recv.native), c_column, c_spacing)

	return
}

// SetColSpacings is a wrapper around the C function gtk_table_set_col_spacings.
func (recv *Table) SetColSpacings(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_col_spacings((*C.GtkTable)(recv.native), c_spacing)

	return
}

// SetHomogeneous is a wrapper around the C function gtk_table_set_homogeneous.
func (recv *Table) SetHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_table_set_homogeneous((*C.GtkTable)(recv.native), c_homogeneous)

	return
}

// SetRowSpacing is a wrapper around the C function gtk_table_set_row_spacing.
func (recv *Table) SetRowSpacing(row uint32, spacing uint32) {
	c_row := (C.guint)(row)

	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_row_spacing((*C.GtkTable)(recv.native), c_row, c_spacing)

	return
}

// SetRowSpacings is a wrapper around the C function gtk_table_set_row_spacings.
func (recv *Table) SetRowSpacings(spacing uint32) {
	c_spacing := (C.guint)(spacing)

	C.gtk_table_set_row_spacings((*C.GtkTable)(recv.native), c_spacing)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Table
func (recv *Table) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Table
func (recv *Table) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TearoffMenuItem is a wrapper around the C record GtkTearoffMenuItem.
type TearoffMenuItem struct {
	native *C.GtkTearoffMenuItem
	// menu_item : record
	// Private : priv
}

func TearoffMenuItemNewFromC(u unsafe.Pointer) *TearoffMenuItem {
	c := (*C.GtkTearoffMenuItem)(u)
	if c == nil {
		return nil
	}

	g := &TearoffMenuItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TearoffMenuItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TearoffMenuItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TearoffMenuItem with another TearoffMenuItem, and returns true if they represent the same GObject.
func (recv *TearoffMenuItem) Equals(other *TearoffMenuItem) bool {
	return other.ToC() == recv.ToC()
}

// MenuItem upcasts to *MenuItem
func (recv *TearoffMenuItem) MenuItem() *MenuItem {
	return MenuItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *TearoffMenuItem) Bin() *Bin {
	return recv.MenuItem().Bin()
}

// Container upcasts to *Container
func (recv *TearoffMenuItem) Container() *Container {
	return recv.MenuItem().Container()
}

// Widget upcasts to *Widget
func (recv *TearoffMenuItem) Widget() *Widget {
	return recv.MenuItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TearoffMenuItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.MenuItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TearoffMenuItem) Object() *gobject.Object {
	return recv.MenuItem().Object()
}

// CastToWidget down casts any arbitrary Object to TearoffMenuItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a TearoffMenuItem.
func CastToTearoffMenuItem(object *gobject.Object) *TearoffMenuItem {
	return TearoffMenuItemNewFromC(object.ToC())
}

// TearoffMenuItemNew is a wrapper around the C function gtk_tearoff_menu_item_new.
func TearoffMenuItemNew() *TearoffMenuItem {
	retC := C.gtk_tearoff_menu_item_new()
	retGo := TearoffMenuItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TearoffMenuItem
func (recv *TearoffMenuItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TextBuffer is a wrapper around the C record GtkTextBuffer.
type TextBuffer struct {
	native *C.GtkTextBuffer
	// parent_instance : record
	// priv : record
}

func TextBufferNewFromC(u unsafe.Pointer) *TextBuffer {
	c := (*C.GtkTextBuffer)(u)
	if c == nil {
		return nil
	}

	g := &TextBuffer{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextBuffer) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextBuffer) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextBuffer with another TextBuffer, and returns true if they represent the same GObject.
func (recv *TextBuffer) Equals(other *TextBuffer) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextBuffer) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextBuffer.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextBuffer.
func CastToTextBuffer(object *gobject.Object) *TextBuffer {
	return TextBufferNewFromC(object.ToC())
}

type signalTextBufferApplyTagDetail struct {
	callback  TextBufferSignalApplyTagCallback
	handlerID C.gulong
}

var signalTextBufferApplyTagId int
var signalTextBufferApplyTagMap = make(map[int]signalTextBufferApplyTagDetail)
var signalTextBufferApplyTagLock sync.RWMutex

// TextBufferSignalApplyTagCallback is a callback function for a 'apply-tag' signal emitted from a TextBuffer.
type TextBufferSignalApplyTagCallback func(tag *TextTag, start *TextIter, end *TextIter)

/*
ConnectApplyTag connects the callback to the 'apply-tag' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectApplyTag to remove it.
*/
func (recv *TextBuffer) ConnectApplyTag(callback TextBufferSignalApplyTagCallback) int {
	signalTextBufferApplyTagLock.Lock()
	defer signalTextBufferApplyTagLock.Unlock()

	signalTextBufferApplyTagId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_apply_tag(instance, C.gpointer(uintptr(signalTextBufferApplyTagId)))

	detail := signalTextBufferApplyTagDetail{callback, handlerID}
	signalTextBufferApplyTagMap[signalTextBufferApplyTagId] = detail

	return signalTextBufferApplyTagId
}

/*
DisconnectApplyTag disconnects a callback from the 'apply-tag' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectApplyTag.
*/
func (recv *TextBuffer) DisconnectApplyTag(connectionID int) {
	signalTextBufferApplyTagLock.Lock()
	defer signalTextBufferApplyTagLock.Unlock()

	detail, exists := signalTextBufferApplyTagMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferApplyTagMap, connectionID)
}

//export textbuffer_applyTagHandler
func textbuffer_applyTagHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	signalTextBufferApplyTagLock.RLock()
	defer signalTextBufferApplyTagLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferApplyTagMap[index].callback
	callback(tag, start, end)
}

type signalTextBufferBeginUserActionDetail struct {
	callback  TextBufferSignalBeginUserActionCallback
	handlerID C.gulong
}

var signalTextBufferBeginUserActionId int
var signalTextBufferBeginUserActionMap = make(map[int]signalTextBufferBeginUserActionDetail)
var signalTextBufferBeginUserActionLock sync.RWMutex

// TextBufferSignalBeginUserActionCallback is a callback function for a 'begin-user-action' signal emitted from a TextBuffer.
type TextBufferSignalBeginUserActionCallback func()

/*
ConnectBeginUserAction connects the callback to the 'begin-user-action' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectBeginUserAction to remove it.
*/
func (recv *TextBuffer) ConnectBeginUserAction(callback TextBufferSignalBeginUserActionCallback) int {
	signalTextBufferBeginUserActionLock.Lock()
	defer signalTextBufferBeginUserActionLock.Unlock()

	signalTextBufferBeginUserActionId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_begin_user_action(instance, C.gpointer(uintptr(signalTextBufferBeginUserActionId)))

	detail := signalTextBufferBeginUserActionDetail{callback, handlerID}
	signalTextBufferBeginUserActionMap[signalTextBufferBeginUserActionId] = detail

	return signalTextBufferBeginUserActionId
}

/*
DisconnectBeginUserAction disconnects a callback from the 'begin-user-action' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectBeginUserAction.
*/
func (recv *TextBuffer) DisconnectBeginUserAction(connectionID int) {
	signalTextBufferBeginUserActionLock.Lock()
	defer signalTextBufferBeginUserActionLock.Unlock()

	detail, exists := signalTextBufferBeginUserActionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferBeginUserActionMap, connectionID)
}

//export textbuffer_beginUserActionHandler
func textbuffer_beginUserActionHandler(_ *C.GObject, data C.gpointer) {
	signalTextBufferBeginUserActionLock.RLock()
	defer signalTextBufferBeginUserActionLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextBufferBeginUserActionMap[index].callback
	callback()
}

type signalTextBufferChangedDetail struct {
	callback  TextBufferSignalChangedCallback
	handlerID C.gulong
}

var signalTextBufferChangedId int
var signalTextBufferChangedMap = make(map[int]signalTextBufferChangedDetail)
var signalTextBufferChangedLock sync.RWMutex

// TextBufferSignalChangedCallback is a callback function for a 'changed' signal emitted from a TextBuffer.
type TextBufferSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *TextBuffer) ConnectChanged(callback TextBufferSignalChangedCallback) int {
	signalTextBufferChangedLock.Lock()
	defer signalTextBufferChangedLock.Unlock()

	signalTextBufferChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_changed(instance, C.gpointer(uintptr(signalTextBufferChangedId)))

	detail := signalTextBufferChangedDetail{callback, handlerID}
	signalTextBufferChangedMap[signalTextBufferChangedId] = detail

	return signalTextBufferChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *TextBuffer) DisconnectChanged(connectionID int) {
	signalTextBufferChangedLock.Lock()
	defer signalTextBufferChangedLock.Unlock()

	detail, exists := signalTextBufferChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferChangedMap, connectionID)
}

//export textbuffer_changedHandler
func textbuffer_changedHandler(_ *C.GObject, data C.gpointer) {
	signalTextBufferChangedLock.RLock()
	defer signalTextBufferChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextBufferChangedMap[index].callback
	callback()
}

type signalTextBufferDeleteRangeDetail struct {
	callback  TextBufferSignalDeleteRangeCallback
	handlerID C.gulong
}

var signalTextBufferDeleteRangeId int
var signalTextBufferDeleteRangeMap = make(map[int]signalTextBufferDeleteRangeDetail)
var signalTextBufferDeleteRangeLock sync.RWMutex

// TextBufferSignalDeleteRangeCallback is a callback function for a 'delete-range' signal emitted from a TextBuffer.
type TextBufferSignalDeleteRangeCallback func(start *TextIter, end *TextIter)

/*
ConnectDeleteRange connects the callback to the 'delete-range' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectDeleteRange to remove it.
*/
func (recv *TextBuffer) ConnectDeleteRange(callback TextBufferSignalDeleteRangeCallback) int {
	signalTextBufferDeleteRangeLock.Lock()
	defer signalTextBufferDeleteRangeLock.Unlock()

	signalTextBufferDeleteRangeId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_delete_range(instance, C.gpointer(uintptr(signalTextBufferDeleteRangeId)))

	detail := signalTextBufferDeleteRangeDetail{callback, handlerID}
	signalTextBufferDeleteRangeMap[signalTextBufferDeleteRangeId] = detail

	return signalTextBufferDeleteRangeId
}

/*
DisconnectDeleteRange disconnects a callback from the 'delete-range' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectDeleteRange.
*/
func (recv *TextBuffer) DisconnectDeleteRange(connectionID int) {
	signalTextBufferDeleteRangeLock.Lock()
	defer signalTextBufferDeleteRangeLock.Unlock()

	detail, exists := signalTextBufferDeleteRangeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferDeleteRangeMap, connectionID)
}

//export textbuffer_deleteRangeHandler
func textbuffer_deleteRangeHandler(_ *C.GObject, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	signalTextBufferDeleteRangeLock.RLock()
	defer signalTextBufferDeleteRangeLock.RUnlock()

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferDeleteRangeMap[index].callback
	callback(start, end)
}

type signalTextBufferEndUserActionDetail struct {
	callback  TextBufferSignalEndUserActionCallback
	handlerID C.gulong
}

var signalTextBufferEndUserActionId int
var signalTextBufferEndUserActionMap = make(map[int]signalTextBufferEndUserActionDetail)
var signalTextBufferEndUserActionLock sync.RWMutex

// TextBufferSignalEndUserActionCallback is a callback function for a 'end-user-action' signal emitted from a TextBuffer.
type TextBufferSignalEndUserActionCallback func()

/*
ConnectEndUserAction connects the callback to the 'end-user-action' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectEndUserAction to remove it.
*/
func (recv *TextBuffer) ConnectEndUserAction(callback TextBufferSignalEndUserActionCallback) int {
	signalTextBufferEndUserActionLock.Lock()
	defer signalTextBufferEndUserActionLock.Unlock()

	signalTextBufferEndUserActionId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_end_user_action(instance, C.gpointer(uintptr(signalTextBufferEndUserActionId)))

	detail := signalTextBufferEndUserActionDetail{callback, handlerID}
	signalTextBufferEndUserActionMap[signalTextBufferEndUserActionId] = detail

	return signalTextBufferEndUserActionId
}

/*
DisconnectEndUserAction disconnects a callback from the 'end-user-action' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectEndUserAction.
*/
func (recv *TextBuffer) DisconnectEndUserAction(connectionID int) {
	signalTextBufferEndUserActionLock.Lock()
	defer signalTextBufferEndUserActionLock.Unlock()

	detail, exists := signalTextBufferEndUserActionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferEndUserActionMap, connectionID)
}

//export textbuffer_endUserActionHandler
func textbuffer_endUserActionHandler(_ *C.GObject, data C.gpointer) {
	signalTextBufferEndUserActionLock.RLock()
	defer signalTextBufferEndUserActionLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextBufferEndUserActionMap[index].callback
	callback()
}

type signalTextBufferInsertChildAnchorDetail struct {
	callback  TextBufferSignalInsertChildAnchorCallback
	handlerID C.gulong
}

var signalTextBufferInsertChildAnchorId int
var signalTextBufferInsertChildAnchorMap = make(map[int]signalTextBufferInsertChildAnchorDetail)
var signalTextBufferInsertChildAnchorLock sync.RWMutex

// TextBufferSignalInsertChildAnchorCallback is a callback function for a 'insert-child-anchor' signal emitted from a TextBuffer.
type TextBufferSignalInsertChildAnchorCallback func(location *TextIter, anchor *TextChildAnchor)

/*
ConnectInsertChildAnchor connects the callback to the 'insert-child-anchor' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertChildAnchor to remove it.
*/
func (recv *TextBuffer) ConnectInsertChildAnchor(callback TextBufferSignalInsertChildAnchorCallback) int {
	signalTextBufferInsertChildAnchorLock.Lock()
	defer signalTextBufferInsertChildAnchorLock.Unlock()

	signalTextBufferInsertChildAnchorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_child_anchor(instance, C.gpointer(uintptr(signalTextBufferInsertChildAnchorId)))

	detail := signalTextBufferInsertChildAnchorDetail{callback, handlerID}
	signalTextBufferInsertChildAnchorMap[signalTextBufferInsertChildAnchorId] = detail

	return signalTextBufferInsertChildAnchorId
}

/*
DisconnectInsertChildAnchor disconnects a callback from the 'insert-child-anchor' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertChildAnchor.
*/
func (recv *TextBuffer) DisconnectInsertChildAnchor(connectionID int) {
	signalTextBufferInsertChildAnchorLock.Lock()
	defer signalTextBufferInsertChildAnchorLock.Unlock()

	detail, exists := signalTextBufferInsertChildAnchorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertChildAnchorMap, connectionID)
}

//export textbuffer_insertChildAnchorHandler
func textbuffer_insertChildAnchorHandler(_ *C.GObject, c_location *C.GtkTextIter, c_anchor *C.GtkTextChildAnchor, data C.gpointer) {
	signalTextBufferInsertChildAnchorLock.RLock()
	defer signalTextBufferInsertChildAnchorLock.RUnlock()

	location := TextIterNewFromC(unsafe.Pointer(c_location))

	anchor := TextChildAnchorNewFromC(unsafe.Pointer(c_anchor))

	index := int(uintptr(data))
	callback := signalTextBufferInsertChildAnchorMap[index].callback
	callback(location, anchor)
}

type signalTextBufferInsertPixbufDetail struct {
	callback  TextBufferSignalInsertPixbufCallback
	handlerID C.gulong
}

var signalTextBufferInsertPixbufId int
var signalTextBufferInsertPixbufMap = make(map[int]signalTextBufferInsertPixbufDetail)
var signalTextBufferInsertPixbufLock sync.RWMutex

// TextBufferSignalInsertPixbufCallback is a callback function for a 'insert-pixbuf' signal emitted from a TextBuffer.
type TextBufferSignalInsertPixbufCallback func(location *TextIter, pixbuf *gdkpixbuf.Pixbuf)

/*
ConnectInsertPixbuf connects the callback to the 'insert-pixbuf' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertPixbuf to remove it.
*/
func (recv *TextBuffer) ConnectInsertPixbuf(callback TextBufferSignalInsertPixbufCallback) int {
	signalTextBufferInsertPixbufLock.Lock()
	defer signalTextBufferInsertPixbufLock.Unlock()

	signalTextBufferInsertPixbufId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_pixbuf(instance, C.gpointer(uintptr(signalTextBufferInsertPixbufId)))

	detail := signalTextBufferInsertPixbufDetail{callback, handlerID}
	signalTextBufferInsertPixbufMap[signalTextBufferInsertPixbufId] = detail

	return signalTextBufferInsertPixbufId
}

/*
DisconnectInsertPixbuf disconnects a callback from the 'insert-pixbuf' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertPixbuf.
*/
func (recv *TextBuffer) DisconnectInsertPixbuf(connectionID int) {
	signalTextBufferInsertPixbufLock.Lock()
	defer signalTextBufferInsertPixbufLock.Unlock()

	detail, exists := signalTextBufferInsertPixbufMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertPixbufMap, connectionID)
}

//export textbuffer_insertPixbufHandler
func textbuffer_insertPixbufHandler(_ *C.GObject, c_location *C.GtkTextIter, c_pixbuf *C.GdkPixbuf, data C.gpointer) {
	signalTextBufferInsertPixbufLock.RLock()
	defer signalTextBufferInsertPixbufLock.RUnlock()

	location := TextIterNewFromC(unsafe.Pointer(c_location))

	pixbuf := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(c_pixbuf))

	index := int(uintptr(data))
	callback := signalTextBufferInsertPixbufMap[index].callback
	callback(location, pixbuf)
}

type signalTextBufferInsertTextDetail struct {
	callback  TextBufferSignalInsertTextCallback
	handlerID C.gulong
}

var signalTextBufferInsertTextId int
var signalTextBufferInsertTextMap = make(map[int]signalTextBufferInsertTextDetail)
var signalTextBufferInsertTextLock sync.RWMutex

// TextBufferSignalInsertTextCallback is a callback function for a 'insert-text' signal emitted from a TextBuffer.
type TextBufferSignalInsertTextCallback func(location *TextIter, text string, len int32)

/*
ConnectInsertText connects the callback to the 'insert-text' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectInsertText to remove it.
*/
func (recv *TextBuffer) ConnectInsertText(callback TextBufferSignalInsertTextCallback) int {
	signalTextBufferInsertTextLock.Lock()
	defer signalTextBufferInsertTextLock.Unlock()

	signalTextBufferInsertTextId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_insert_text(instance, C.gpointer(uintptr(signalTextBufferInsertTextId)))

	detail := signalTextBufferInsertTextDetail{callback, handlerID}
	signalTextBufferInsertTextMap[signalTextBufferInsertTextId] = detail

	return signalTextBufferInsertTextId
}

/*
DisconnectInsertText disconnects a callback from the 'insert-text' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectInsertText.
*/
func (recv *TextBuffer) DisconnectInsertText(connectionID int) {
	signalTextBufferInsertTextLock.Lock()
	defer signalTextBufferInsertTextLock.Unlock()

	detail, exists := signalTextBufferInsertTextMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferInsertTextMap, connectionID)
}

//export textbuffer_insertTextHandler
func textbuffer_insertTextHandler(_ *C.GObject, c_location *C.GtkTextIter, c_text *C.gchar, c_len C.gint, data C.gpointer) {
	signalTextBufferInsertTextLock.RLock()
	defer signalTextBufferInsertTextLock.RUnlock()

	location := TextIterNewFromC(unsafe.Pointer(c_location))

	text := C.GoString(c_text)

	len := int32(c_len)

	index := int(uintptr(data))
	callback := signalTextBufferInsertTextMap[index].callback
	callback(location, text, len)
}

type signalTextBufferMarkDeletedDetail struct {
	callback  TextBufferSignalMarkDeletedCallback
	handlerID C.gulong
}

var signalTextBufferMarkDeletedId int
var signalTextBufferMarkDeletedMap = make(map[int]signalTextBufferMarkDeletedDetail)
var signalTextBufferMarkDeletedLock sync.RWMutex

// TextBufferSignalMarkDeletedCallback is a callback function for a 'mark-deleted' signal emitted from a TextBuffer.
type TextBufferSignalMarkDeletedCallback func(mark *TextMark)

/*
ConnectMarkDeleted connects the callback to the 'mark-deleted' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectMarkDeleted to remove it.
*/
func (recv *TextBuffer) ConnectMarkDeleted(callback TextBufferSignalMarkDeletedCallback) int {
	signalTextBufferMarkDeletedLock.Lock()
	defer signalTextBufferMarkDeletedLock.Unlock()

	signalTextBufferMarkDeletedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_mark_deleted(instance, C.gpointer(uintptr(signalTextBufferMarkDeletedId)))

	detail := signalTextBufferMarkDeletedDetail{callback, handlerID}
	signalTextBufferMarkDeletedMap[signalTextBufferMarkDeletedId] = detail

	return signalTextBufferMarkDeletedId
}

/*
DisconnectMarkDeleted disconnects a callback from the 'mark-deleted' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectMarkDeleted.
*/
func (recv *TextBuffer) DisconnectMarkDeleted(connectionID int) {
	signalTextBufferMarkDeletedLock.Lock()
	defer signalTextBufferMarkDeletedLock.Unlock()

	detail, exists := signalTextBufferMarkDeletedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferMarkDeletedMap, connectionID)
}

//export textbuffer_markDeletedHandler
func textbuffer_markDeletedHandler(_ *C.GObject, c_mark *C.GtkTextMark, data C.gpointer) {
	signalTextBufferMarkDeletedLock.RLock()
	defer signalTextBufferMarkDeletedLock.RUnlock()

	mark := TextMarkNewFromC(unsafe.Pointer(c_mark))

	index := int(uintptr(data))
	callback := signalTextBufferMarkDeletedMap[index].callback
	callback(mark)
}

type signalTextBufferMarkSetDetail struct {
	callback  TextBufferSignalMarkSetCallback
	handlerID C.gulong
}

var signalTextBufferMarkSetId int
var signalTextBufferMarkSetMap = make(map[int]signalTextBufferMarkSetDetail)
var signalTextBufferMarkSetLock sync.RWMutex

// TextBufferSignalMarkSetCallback is a callback function for a 'mark-set' signal emitted from a TextBuffer.
type TextBufferSignalMarkSetCallback func(location *TextIter, mark *TextMark)

/*
ConnectMarkSet connects the callback to the 'mark-set' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectMarkSet to remove it.
*/
func (recv *TextBuffer) ConnectMarkSet(callback TextBufferSignalMarkSetCallback) int {
	signalTextBufferMarkSetLock.Lock()
	defer signalTextBufferMarkSetLock.Unlock()

	signalTextBufferMarkSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_mark_set(instance, C.gpointer(uintptr(signalTextBufferMarkSetId)))

	detail := signalTextBufferMarkSetDetail{callback, handlerID}
	signalTextBufferMarkSetMap[signalTextBufferMarkSetId] = detail

	return signalTextBufferMarkSetId
}

/*
DisconnectMarkSet disconnects a callback from the 'mark-set' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectMarkSet.
*/
func (recv *TextBuffer) DisconnectMarkSet(connectionID int) {
	signalTextBufferMarkSetLock.Lock()
	defer signalTextBufferMarkSetLock.Unlock()

	detail, exists := signalTextBufferMarkSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferMarkSetMap, connectionID)
}

//export textbuffer_markSetHandler
func textbuffer_markSetHandler(_ *C.GObject, c_location *C.GtkTextIter, c_mark *C.GtkTextMark, data C.gpointer) {
	signalTextBufferMarkSetLock.RLock()
	defer signalTextBufferMarkSetLock.RUnlock()

	location := TextIterNewFromC(unsafe.Pointer(c_location))

	mark := TextMarkNewFromC(unsafe.Pointer(c_mark))

	index := int(uintptr(data))
	callback := signalTextBufferMarkSetMap[index].callback
	callback(location, mark)
}

type signalTextBufferModifiedChangedDetail struct {
	callback  TextBufferSignalModifiedChangedCallback
	handlerID C.gulong
}

var signalTextBufferModifiedChangedId int
var signalTextBufferModifiedChangedMap = make(map[int]signalTextBufferModifiedChangedDetail)
var signalTextBufferModifiedChangedLock sync.RWMutex

// TextBufferSignalModifiedChangedCallback is a callback function for a 'modified-changed' signal emitted from a TextBuffer.
type TextBufferSignalModifiedChangedCallback func()

/*
ConnectModifiedChanged connects the callback to the 'modified-changed' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectModifiedChanged to remove it.
*/
func (recv *TextBuffer) ConnectModifiedChanged(callback TextBufferSignalModifiedChangedCallback) int {
	signalTextBufferModifiedChangedLock.Lock()
	defer signalTextBufferModifiedChangedLock.Unlock()

	signalTextBufferModifiedChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_modified_changed(instance, C.gpointer(uintptr(signalTextBufferModifiedChangedId)))

	detail := signalTextBufferModifiedChangedDetail{callback, handlerID}
	signalTextBufferModifiedChangedMap[signalTextBufferModifiedChangedId] = detail

	return signalTextBufferModifiedChangedId
}

/*
DisconnectModifiedChanged disconnects a callback from the 'modified-changed' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectModifiedChanged.
*/
func (recv *TextBuffer) DisconnectModifiedChanged(connectionID int) {
	signalTextBufferModifiedChangedLock.Lock()
	defer signalTextBufferModifiedChangedLock.Unlock()

	detail, exists := signalTextBufferModifiedChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferModifiedChangedMap, connectionID)
}

//export textbuffer_modifiedChangedHandler
func textbuffer_modifiedChangedHandler(_ *C.GObject, data C.gpointer) {
	signalTextBufferModifiedChangedLock.RLock()
	defer signalTextBufferModifiedChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextBufferModifiedChangedMap[index].callback
	callback()
}

type signalTextBufferRemoveTagDetail struct {
	callback  TextBufferSignalRemoveTagCallback
	handlerID C.gulong
}

var signalTextBufferRemoveTagId int
var signalTextBufferRemoveTagMap = make(map[int]signalTextBufferRemoveTagDetail)
var signalTextBufferRemoveTagLock sync.RWMutex

// TextBufferSignalRemoveTagCallback is a callback function for a 'remove-tag' signal emitted from a TextBuffer.
type TextBufferSignalRemoveTagCallback func(tag *TextTag, start *TextIter, end *TextIter)

/*
ConnectRemoveTag connects the callback to the 'remove-tag' signal for the TextBuffer.

The returned value represents the connection, and may be passed to DisconnectRemoveTag to remove it.
*/
func (recv *TextBuffer) ConnectRemoveTag(callback TextBufferSignalRemoveTagCallback) int {
	signalTextBufferRemoveTagLock.Lock()
	defer signalTextBufferRemoveTagLock.Unlock()

	signalTextBufferRemoveTagId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextBuffer_signal_connect_remove_tag(instance, C.gpointer(uintptr(signalTextBufferRemoveTagId)))

	detail := signalTextBufferRemoveTagDetail{callback, handlerID}
	signalTextBufferRemoveTagMap[signalTextBufferRemoveTagId] = detail

	return signalTextBufferRemoveTagId
}

/*
DisconnectRemoveTag disconnects a callback from the 'remove-tag' signal for the TextBuffer.

The connectionID should be a value returned from a call to ConnectRemoveTag.
*/
func (recv *TextBuffer) DisconnectRemoveTag(connectionID int) {
	signalTextBufferRemoveTagLock.Lock()
	defer signalTextBufferRemoveTagLock.Unlock()

	detail, exists := signalTextBufferRemoveTagMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextBufferRemoveTagMap, connectionID)
}

//export textbuffer_removeTagHandler
func textbuffer_removeTagHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_start *C.GtkTextIter, c_end *C.GtkTextIter, data C.gpointer) {
	signalTextBufferRemoveTagLock.RLock()
	defer signalTextBufferRemoveTagLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	start := TextIterNewFromC(unsafe.Pointer(c_start))

	end := TextIterNewFromC(unsafe.Pointer(c_end))

	index := int(uintptr(data))
	callback := signalTextBufferRemoveTagMap[index].callback
	callback(tag, start, end)
}

// TextBufferNew is a wrapper around the C function gtk_text_buffer_new.
func TextBufferNew(table *TextTagTable) *TextBuffer {
	c_table := (*C.GtkTextTagTable)(C.NULL)
	if table != nil {
		c_table = (*C.GtkTextTagTable)(table.ToC())
	}

	retC := C.gtk_text_buffer_new(c_table)
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddMark is a wrapper around the C function gtk_text_buffer_add_mark.
func (recv *TextBuffer) AddMark(mark *TextMark, where *TextIter) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_add_mark((*C.GtkTextBuffer)(recv.native), c_mark, c_where)

	return
}

// AddSelectionClipboard is a wrapper around the C function gtk_text_buffer_add_selection_clipboard.
func (recv *TextBuffer) AddSelectionClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_add_selection_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// ApplyTag is a wrapper around the C function gtk_text_buffer_apply_tag.
func (recv *TextBuffer) ApplyTag(tag *TextTag, start *TextIter, end *TextIter) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_apply_tag((*C.GtkTextBuffer)(recv.native), c_tag, c_start, c_end)

	return
}

// ApplyTagByName is a wrapper around the C function gtk_text_buffer_apply_tag_by_name.
func (recv *TextBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_apply_tag_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_start, c_end)

	return
}

// Backspace is a wrapper around the C function gtk_text_buffer_backspace.
func (recv *TextBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_interactive :=
		boolToGboolean(interactive)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_backspace((*C.GtkTextBuffer)(recv.native), c_iter, c_interactive, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// BeginUserAction is a wrapper around the C function gtk_text_buffer_begin_user_action.
func (recv *TextBuffer) BeginUserAction() {
	C.gtk_text_buffer_begin_user_action((*C.GtkTextBuffer)(recv.native))

	return
}

// CopyClipboard is a wrapper around the C function gtk_text_buffer_copy_clipboard.
func (recv *TextBuffer) CopyClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_copy_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// CreateChildAnchor is a wrapper around the C function gtk_text_buffer_create_child_anchor.
func (recv *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_buffer_create_child_anchor((*C.GtkTextBuffer)(recv.native), c_iter)
	retGo := TextChildAnchorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CreateMark is a wrapper around the C function gtk_text_buffer_create_mark.
func (recv *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	c_mark_name := C.CString(markName)
	defer C.free(unsafe.Pointer(c_mark_name))

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	c_left_gravity :=
		boolToGboolean(leftGravity)

	retC := C.gtk_text_buffer_create_mark((*C.GtkTextBuffer)(recv.native), c_mark_name, c_where, c_left_gravity)
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_text_buffer_create_tag : unsupported parameter ... : varargs

// CutClipboard is a wrapper around the C function gtk_text_buffer_cut_clipboard.
func (recv *TextBuffer) CutClipboard(clipboard *Clipboard, defaultEditable bool) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	C.gtk_text_buffer_cut_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard, c_default_editable)

	return
}

// Delete is a wrapper around the C function gtk_text_buffer_delete.
func (recv *TextBuffer) Delete(start *TextIter, end *TextIter) {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_delete((*C.GtkTextBuffer)(recv.native), c_start, c_end)

	return
}

// DeleteInteractive is a wrapper around the C function gtk_text_buffer_delete_interactive.
func (recv *TextBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	c_start_iter := (*C.GtkTextIter)(C.NULL)
	if startIter != nil {
		c_start_iter = (*C.GtkTextIter)(startIter.ToC())
	}

	c_end_iter := (*C.GtkTextIter)(C.NULL)
	if endIter != nil {
		c_end_iter = (*C.GtkTextIter)(endIter.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_delete_interactive((*C.GtkTextBuffer)(recv.native), c_start_iter, c_end_iter, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// DeleteMark is a wrapper around the C function gtk_text_buffer_delete_mark.
func (recv *TextBuffer) DeleteMark(mark *TextMark) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_buffer_delete_mark((*C.GtkTextBuffer)(recv.native), c_mark)

	return
}

// DeleteMarkByName is a wrapper around the C function gtk_text_buffer_delete_mark_by_name.
func (recv *TextBuffer) DeleteMarkByName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_text_buffer_delete_mark_by_name((*C.GtkTextBuffer)(recv.native), c_name)

	return
}

// DeleteSelection is a wrapper around the C function gtk_text_buffer_delete_selection.
func (recv *TextBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	c_interactive :=
		boolToGboolean(interactive)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_delete_selection((*C.GtkTextBuffer)(recv.native), c_interactive, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Deserialize is a wrapper around the C function gtk_text_buffer_deserialize.
func (recv *TextBuffer) Deserialize(contentBuffer *TextBuffer, format *gdk.Atom, iter *TextIter, data []uint8) (bool, error) {
	c_content_buffer := (*C.GtkTextBuffer)(C.NULL)
	if contentBuffer != nil {
		c_content_buffer = (*C.GtkTextBuffer)(contentBuffer.ToC())
	}

	c_format := (C.GdkAtom)(C.NULL)
	if format != nil {
		c_format = (C.GdkAtom)(format.ToC())
	}

	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_data_array := make([]C.guint8, len(data)+1, len(data)+1)
	for i, item := range data {
		c := (C.guint8)(item)
		c_data_array[i] = c
	}
	c_data_array[len(data)] = 0
	c_data_arrayPtr := &c_data_array[0]
	c_data := (*C.guint8)(unsafe.Pointer(c_data_arrayPtr))

	c_length := (C.gsize)(len(data))

	var cThrowableError *C.GError

	retC := C.gtk_text_buffer_deserialize((*C.GtkTextBuffer)(recv.native), c_content_buffer, c_format, c_iter, c_data, c_length, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// DeserializeGetCanCreateTags is a wrapper around the C function gtk_text_buffer_deserialize_get_can_create_tags.
func (recv *TextBuffer) DeserializeGetCanCreateTags(format *gdk.Atom) bool {
	c_format := (C.GdkAtom)(C.NULL)
	if format != nil {
		c_format = (C.GdkAtom)(format.ToC())
	}

	retC := C.gtk_text_buffer_deserialize_get_can_create_tags((*C.GtkTextBuffer)(recv.native), c_format)
	retGo := retC == C.TRUE

	return retGo
}

// DeserializeSetCanCreateTags is a wrapper around the C function gtk_text_buffer_deserialize_set_can_create_tags.
func (recv *TextBuffer) DeserializeSetCanCreateTags(format *gdk.Atom, canCreateTags bool) {
	c_format := (C.GdkAtom)(C.NULL)
	if format != nil {
		c_format = (C.GdkAtom)(format.ToC())
	}

	c_can_create_tags :=
		boolToGboolean(canCreateTags)

	C.gtk_text_buffer_deserialize_set_can_create_tags((*C.GtkTextBuffer)(recv.native), c_format, c_can_create_tags)

	return
}

// EndUserAction is a wrapper around the C function gtk_text_buffer_end_user_action.
func (recv *TextBuffer) EndUserAction() {
	C.gtk_text_buffer_end_user_action((*C.GtkTextBuffer)(recv.native))

	return
}

// GetBounds is a wrapper around the C function gtk_text_buffer_get_bounds.
func (recv *TextBuffer) GetBounds() (*TextIter, *TextIter) {
	var c_start C.GtkTextIter

	var c_end C.GtkTextIter

	C.gtk_text_buffer_get_bounds((*C.GtkTextBuffer)(recv.native), &c_start, &c_end)

	start := TextIterNewFromC(unsafe.Pointer(&c_start))

	end := TextIterNewFromC(unsafe.Pointer(&c_end))

	return start, end
}

// GetCharCount is a wrapper around the C function gtk_text_buffer_get_char_count.
func (recv *TextBuffer) GetCharCount() int32 {
	retC := C.gtk_text_buffer_get_char_count((*C.GtkTextBuffer)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetCopyTargetList is a wrapper around the C function gtk_text_buffer_get_copy_target_list.
func (recv *TextBuffer) GetCopyTargetList() *TargetList {
	retC := C.gtk_text_buffer_get_copy_target_list((*C.GtkTextBuffer)(recv.native))
	retGo := TargetListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_text_buffer_get_deserialize_formats : array return type :

// GetEndIter is a wrapper around the C function gtk_text_buffer_get_end_iter.
func (recv *TextBuffer) GetEndIter() *TextIter {
	var c_iter C.GtkTextIter

	C.gtk_text_buffer_get_end_iter((*C.GtkTextBuffer)(recv.native), &c_iter)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetHasSelection is a wrapper around the C function gtk_text_buffer_get_has_selection.
func (recv *TextBuffer) GetHasSelection() bool {
	retC := C.gtk_text_buffer_get_has_selection((*C.GtkTextBuffer)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetInsert is a wrapper around the C function gtk_text_buffer_get_insert.
func (recv *TextBuffer) GetInsert() *TextMark {
	retC := C.gtk_text_buffer_get_insert((*C.GtkTextBuffer)(recv.native))
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIterAtChildAnchor is a wrapper around the C function gtk_text_buffer_get_iter_at_child_anchor.
func (recv *TextBuffer) GetIterAtChildAnchor(anchor *TextChildAnchor) *TextIter {
	var c_iter C.GtkTextIter

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_buffer_get_iter_at_child_anchor((*C.GtkTextBuffer)(recv.native), &c_iter, c_anchor)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetIterAtLine is a wrapper around the C function gtk_text_buffer_get_iter_at_line.
func (recv *TextBuffer) GetIterAtLine(lineNumber int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	C.gtk_text_buffer_get_iter_at_line((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetIterAtLineIndex is a wrapper around the C function gtk_text_buffer_get_iter_at_line_index.
func (recv *TextBuffer) GetIterAtLineIndex(lineNumber int32, byteIndex int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	c_byte_index := (C.gint)(byteIndex)

	C.gtk_text_buffer_get_iter_at_line_index((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number, c_byte_index)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetIterAtLineOffset is a wrapper around the C function gtk_text_buffer_get_iter_at_line_offset.
func (recv *TextBuffer) GetIterAtLineOffset(lineNumber int32, charOffset int32) *TextIter {
	var c_iter C.GtkTextIter

	c_line_number := (C.gint)(lineNumber)

	c_char_offset := (C.gint)(charOffset)

	C.gtk_text_buffer_get_iter_at_line_offset((*C.GtkTextBuffer)(recv.native), &c_iter, c_line_number, c_char_offset)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetIterAtMark is a wrapper around the C function gtk_text_buffer_get_iter_at_mark.
func (recv *TextBuffer) GetIterAtMark(mark *TextMark) *TextIter {
	var c_iter C.GtkTextIter

	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_buffer_get_iter_at_mark((*C.GtkTextBuffer)(recv.native), &c_iter, c_mark)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetIterAtOffset is a wrapper around the C function gtk_text_buffer_get_iter_at_offset.
func (recv *TextBuffer) GetIterAtOffset(charOffset int32) *TextIter {
	var c_iter C.GtkTextIter

	c_char_offset := (C.gint)(charOffset)

	C.gtk_text_buffer_get_iter_at_offset((*C.GtkTextBuffer)(recv.native), &c_iter, c_char_offset)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetLineCount is a wrapper around the C function gtk_text_buffer_get_line_count.
func (recv *TextBuffer) GetLineCount() int32 {
	retC := C.gtk_text_buffer_get_line_count((*C.GtkTextBuffer)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMark is a wrapper around the C function gtk_text_buffer_get_mark.
func (recv *TextBuffer) GetMark(name string) *TextMark {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_buffer_get_mark((*C.GtkTextBuffer)(recv.native), c_name)
	var retGo (*TextMark)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TextMarkNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetModified is a wrapper around the C function gtk_text_buffer_get_modified.
func (recv *TextBuffer) GetModified() bool {
	retC := C.gtk_text_buffer_get_modified((*C.GtkTextBuffer)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPasteTargetList is a wrapper around the C function gtk_text_buffer_get_paste_target_list.
func (recv *TextBuffer) GetPasteTargetList() *TargetList {
	retC := C.gtk_text_buffer_get_paste_target_list((*C.GtkTextBuffer)(recv.native))
	retGo := TargetListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSelectionBound is a wrapper around the C function gtk_text_buffer_get_selection_bound.
func (recv *TextBuffer) GetSelectionBound() *TextMark {
	retC := C.gtk_text_buffer_get_selection_bound((*C.GtkTextBuffer)(recv.native))
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSelectionBounds is a wrapper around the C function gtk_text_buffer_get_selection_bounds.
func (recv *TextBuffer) GetSelectionBounds() (bool, *TextIter, *TextIter) {
	var c_start C.GtkTextIter

	var c_end C.GtkTextIter

	retC := C.gtk_text_buffer_get_selection_bounds((*C.GtkTextBuffer)(recv.native), &c_start, &c_end)
	retGo := retC == C.TRUE

	start := TextIterNewFromC(unsafe.Pointer(&c_start))

	end := TextIterNewFromC(unsafe.Pointer(&c_end))

	return retGo, start, end
}

// Unsupported : gtk_text_buffer_get_serialize_formats : array return type :

// GetSlice is a wrapper around the C function gtk_text_buffer_get_slice.
func (recv *TextBuffer) GetSlice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_include_hidden_chars :=
		boolToGboolean(includeHiddenChars)

	retC := C.gtk_text_buffer_get_slice((*C.GtkTextBuffer)(recv.native), c_start, c_end, c_include_hidden_chars)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetStartIter is a wrapper around the C function gtk_text_buffer_get_start_iter.
func (recv *TextBuffer) GetStartIter() *TextIter {
	var c_iter C.GtkTextIter

	C.gtk_text_buffer_get_start_iter((*C.GtkTextBuffer)(recv.native), &c_iter)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetTagTable is a wrapper around the C function gtk_text_buffer_get_tag_table.
func (recv *TextBuffer) GetTagTable() *TextTagTable {
	retC := C.gtk_text_buffer_get_tag_table((*C.GtkTextBuffer)(recv.native))
	retGo := TextTagTableNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetText is a wrapper around the C function gtk_text_buffer_get_text.
func (recv *TextBuffer) GetText(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_include_hidden_chars :=
		boolToGboolean(includeHiddenChars)

	retC := C.gtk_text_buffer_get_text((*C.GtkTextBuffer)(recv.native), c_start, c_end, c_include_hidden_chars)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Insert is a wrapper around the C function gtk_text_buffer_insert.
func (recv *TextBuffer) Insert(iter *TextIter, text string, len int32) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_insert((*C.GtkTextBuffer)(recv.native), c_iter, c_text, c_len)

	return
}

// InsertAtCursor is a wrapper around the C function gtk_text_buffer_insert_at_cursor.
func (recv *TextBuffer) InsertAtCursor(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_insert_at_cursor((*C.GtkTextBuffer)(recv.native), c_text, c_len)

	return
}

// InsertChildAnchor is a wrapper around the C function gtk_text_buffer_insert_child_anchor.
func (recv *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_buffer_insert_child_anchor((*C.GtkTextBuffer)(recv.native), c_iter, c_anchor)

	return
}

// InsertInteractive is a wrapper around the C function gtk_text_buffer_insert_interactive.
func (recv *TextBuffer) InsertInteractive(iter *TextIter, text string, len int32, defaultEditable bool) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_interactive((*C.GtkTextBuffer)(recv.native), c_iter, c_text, c_len, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// InsertInteractiveAtCursor is a wrapper around the C function gtk_text_buffer_insert_interactive_at_cursor.
func (recv *TextBuffer) InsertInteractiveAtCursor(text string, len int32, defaultEditable bool) bool {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_interactive_at_cursor((*C.GtkTextBuffer)(recv.native), c_text, c_len, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// InsertPixbuf is a wrapper around the C function gtk_text_buffer_insert_pixbuf.
func (recv *TextBuffer) InsertPixbuf(iter *TextIter, pixbuf *gdkpixbuf.Pixbuf) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_text_buffer_insert_pixbuf((*C.GtkTextBuffer)(recv.native), c_iter, c_pixbuf)

	return
}

// InsertRange is a wrapper around the C function gtk_text_buffer_insert_range.
func (recv *TextBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_insert_range((*C.GtkTextBuffer)(recv.native), c_iter, c_start, c_end)

	return
}

// InsertRangeInteractive is a wrapper around the C function gtk_text_buffer_insert_range_interactive.
func (recv *TextBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	retC := C.gtk_text_buffer_insert_range_interactive((*C.GtkTextBuffer)(recv.native), c_iter, c_start, c_end, c_default_editable)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_text_buffer_insert_with_tags : unsupported parameter ... : varargs

// Unsupported : gtk_text_buffer_insert_with_tags_by_name : unsupported parameter ... : varargs

// MoveMark is a wrapper around the C function gtk_text_buffer_move_mark.
func (recv *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_move_mark((*C.GtkTextBuffer)(recv.native), c_mark, c_where)

	return
}

// MoveMarkByName is a wrapper around the C function gtk_text_buffer_move_mark_by_name.
func (recv *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_move_mark_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_where)

	return
}

// PasteClipboard is a wrapper around the C function gtk_text_buffer_paste_clipboard.
func (recv *TextBuffer) PasteClipboard(clipboard *Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	c_override_location := (*C.GtkTextIter)(C.NULL)
	if overrideLocation != nil {
		c_override_location = (*C.GtkTextIter)(overrideLocation.ToC())
	}

	c_default_editable :=
		boolToGboolean(defaultEditable)

	C.gtk_text_buffer_paste_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard, c_override_location, c_default_editable)

	return
}

// PlaceCursor is a wrapper around the C function gtk_text_buffer_place_cursor.
func (recv *TextBuffer) PlaceCursor(where *TextIter) {
	c_where := (*C.GtkTextIter)(C.NULL)
	if where != nil {
		c_where = (*C.GtkTextIter)(where.ToC())
	}

	C.gtk_text_buffer_place_cursor((*C.GtkTextBuffer)(recv.native), c_where)

	return
}

// Unsupported : gtk_text_buffer_register_deserialize_format : unsupported parameter function : no type generator for TextBufferDeserializeFunc (GtkTextBufferDeserializeFunc) for param function

// RegisterDeserializeTagset is a wrapper around the C function gtk_text_buffer_register_deserialize_tagset.
func (recv *TextBuffer) RegisterDeserializeTagset(tagsetName string) gdk.Atom {
	c_tagset_name := C.CString(tagsetName)
	defer C.free(unsafe.Pointer(c_tagset_name))

	retC := C.gtk_text_buffer_register_deserialize_tagset((*C.GtkTextBuffer)(recv.native), c_tagset_name)
	retGo := *gdk.AtomNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_text_buffer_register_serialize_format : unsupported parameter function : no type generator for TextBufferSerializeFunc (GtkTextBufferSerializeFunc) for param function

// RegisterSerializeTagset is a wrapper around the C function gtk_text_buffer_register_serialize_tagset.
func (recv *TextBuffer) RegisterSerializeTagset(tagsetName string) gdk.Atom {
	c_tagset_name := C.CString(tagsetName)
	defer C.free(unsafe.Pointer(c_tagset_name))

	retC := C.gtk_text_buffer_register_serialize_tagset((*C.GtkTextBuffer)(recv.native), c_tagset_name)
	retGo := *gdk.AtomNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RemoveAllTags is a wrapper around the C function gtk_text_buffer_remove_all_tags.
func (recv *TextBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_all_tags((*C.GtkTextBuffer)(recv.native), c_start, c_end)

	return
}

// RemoveSelectionClipboard is a wrapper around the C function gtk_text_buffer_remove_selection_clipboard.
func (recv *TextBuffer) RemoveSelectionClipboard(clipboard *Clipboard) {
	c_clipboard := (*C.GtkClipboard)(C.NULL)
	if clipboard != nil {
		c_clipboard = (*C.GtkClipboard)(clipboard.ToC())
	}

	C.gtk_text_buffer_remove_selection_clipboard((*C.GtkTextBuffer)(recv.native), c_clipboard)

	return
}

// RemoveTag is a wrapper around the C function gtk_text_buffer_remove_tag.
func (recv *TextBuffer) RemoveTag(tag *TextTag, start *TextIter, end *TextIter) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_tag((*C.GtkTextBuffer)(recv.native), c_tag, c_start, c_end)

	return
}

// RemoveTagByName is a wrapper around the C function gtk_text_buffer_remove_tag_by_name.
func (recv *TextBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	C.gtk_text_buffer_remove_tag_by_name((*C.GtkTextBuffer)(recv.native), c_name, c_start, c_end)

	return
}

// SelectRange is a wrapper around the C function gtk_text_buffer_select_range.
func (recv *TextBuffer) SelectRange(ins *TextIter, bound *TextIter) {
	c_ins := (*C.GtkTextIter)(C.NULL)
	if ins != nil {
		c_ins = (*C.GtkTextIter)(ins.ToC())
	}

	c_bound := (*C.GtkTextIter)(C.NULL)
	if bound != nil {
		c_bound = (*C.GtkTextIter)(bound.ToC())
	}

	C.gtk_text_buffer_select_range((*C.GtkTextBuffer)(recv.native), c_ins, c_bound)

	return
}

// Unsupported : gtk_text_buffer_serialize : array return type :

// SetModified is a wrapper around the C function gtk_text_buffer_set_modified.
func (recv *TextBuffer) SetModified(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_buffer_set_modified((*C.GtkTextBuffer)(recv.native), c_setting)

	return
}

// SetText is a wrapper around the C function gtk_text_buffer_set_text.
func (recv *TextBuffer) SetText(text string, len int32) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	c_len := (C.gint)(len)

	C.gtk_text_buffer_set_text((*C.GtkTextBuffer)(recv.native), c_text, c_len)

	return
}

// UnregisterDeserializeFormat is a wrapper around the C function gtk_text_buffer_unregister_deserialize_format.
func (recv *TextBuffer) UnregisterDeserializeFormat(format *gdk.Atom) {
	c_format := (C.GdkAtom)(C.NULL)
	if format != nil {
		c_format = (C.GdkAtom)(format.ToC())
	}

	C.gtk_text_buffer_unregister_deserialize_format((*C.GtkTextBuffer)(recv.native), c_format)

	return
}

// UnregisterSerializeFormat is a wrapper around the C function gtk_text_buffer_unregister_serialize_format.
func (recv *TextBuffer) UnregisterSerializeFormat(format *gdk.Atom) {
	c_format := (C.GdkAtom)(C.NULL)
	if format != nil {
		c_format = (C.GdkAtom)(format.ToC())
	}

	C.gtk_text_buffer_unregister_serialize_format((*C.GtkTextBuffer)(recv.native), c_format)

	return
}

// TextCellAccessible is a wrapper around the C record GtkTextCellAccessible.
type TextCellAccessible struct {
	native *C.GtkTextCellAccessible
	// parent : record
	// priv : record
}

func TextCellAccessibleNewFromC(u unsafe.Pointer) *TextCellAccessible {
	c := (*C.GtkTextCellAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TextCellAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextCellAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextCellAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextCellAccessible with another TextCellAccessible, and returns true if they represent the same GObject.
func (recv *TextCellAccessible) Equals(other *TextCellAccessible) bool {
	return other.ToC() == recv.ToC()
}

// RendererCellAccessible upcasts to *RendererCellAccessible
func (recv *TextCellAccessible) RendererCellAccessible() *RendererCellAccessible {
	return RendererCellAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// CellAccessible upcasts to *CellAccessible
func (recv *TextCellAccessible) CellAccessible() *CellAccessible {
	return recv.RendererCellAccessible().CellAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TextCellAccessible) Accessible() *Accessible {
	return recv.RendererCellAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TextCellAccessible) Object() *atk.Object {
	return recv.RendererCellAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to TextCellAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextCellAccessible.
func CastToTextCellAccessible(object *gobject.Object) *TextCellAccessible {
	return TextCellAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by TextCellAccessible
func (recv *TextCellAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// TextChildAnchor is a wrapper around the C record GtkTextChildAnchor.
type TextChildAnchor struct {
	native *C.GtkTextChildAnchor
	// parent_instance : record
	// Private : segment
}

func TextChildAnchorNewFromC(u unsafe.Pointer) *TextChildAnchor {
	c := (*C.GtkTextChildAnchor)(u)
	if c == nil {
		return nil
	}

	g := &TextChildAnchor{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextChildAnchor) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextChildAnchor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextChildAnchor with another TextChildAnchor, and returns true if they represent the same GObject.
func (recv *TextChildAnchor) Equals(other *TextChildAnchor) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextChildAnchor) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextChildAnchor.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextChildAnchor.
func CastToTextChildAnchor(object *gobject.Object) *TextChildAnchor {
	return TextChildAnchorNewFromC(object.ToC())
}

// TextChildAnchorNew is a wrapper around the C function gtk_text_child_anchor_new.
func TextChildAnchorNew() *TextChildAnchor {
	retC := C.gtk_text_child_anchor_new()
	retGo := TextChildAnchorNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetDeleted is a wrapper around the C function gtk_text_child_anchor_get_deleted.
func (recv *TextChildAnchor) GetDeleted() bool {
	retC := C.gtk_text_child_anchor_get_deleted((*C.GtkTextChildAnchor)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetWidgets is a wrapper around the C function gtk_text_child_anchor_get_widgets.
func (recv *TextChildAnchor) GetWidgets() *glib.List {
	retC := C.gtk_text_child_anchor_get_widgets((*C.GtkTextChildAnchor)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TextMark is a wrapper around the C record GtkTextMark.
type TextMark struct {
	native *C.GtkTextMark
	// parent_instance : record
	// Private : segment
}

func TextMarkNewFromC(u unsafe.Pointer) *TextMark {
	c := (*C.GtkTextMark)(u)
	if c == nil {
		return nil
	}

	g := &TextMark{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextMark) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextMark) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextMark with another TextMark, and returns true if they represent the same GObject.
func (recv *TextMark) Equals(other *TextMark) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextMark) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextMark.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextMark.
func CastToTextMark(object *gobject.Object) *TextMark {
	return TextMarkNewFromC(object.ToC())
}

// TextMarkNew is a wrapper around the C function gtk_text_mark_new.
func TextMarkNew(name string, leftGravity bool) *TextMark {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_left_gravity :=
		boolToGboolean(leftGravity)

	retC := C.gtk_text_mark_new(c_name, c_left_gravity)
	retGo := TextMarkNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetBuffer is a wrapper around the C function gtk_text_mark_get_buffer.
func (recv *TextMark) GetBuffer() *TextBuffer {
	retC := C.gtk_text_mark_get_buffer((*C.GtkTextMark)(recv.native))
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDeleted is a wrapper around the C function gtk_text_mark_get_deleted.
func (recv *TextMark) GetDeleted() bool {
	retC := C.gtk_text_mark_get_deleted((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetLeftGravity is a wrapper around the C function gtk_text_mark_get_left_gravity.
func (recv *TextMark) GetLeftGravity() bool {
	retC := C.gtk_text_mark_get_left_gravity((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetName is a wrapper around the C function gtk_text_mark_get_name.
func (recv *TextMark) GetName() string {
	retC := C.gtk_text_mark_get_name((*C.GtkTextMark)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetVisible is a wrapper around the C function gtk_text_mark_get_visible.
func (recv *TextMark) GetVisible() bool {
	retC := C.gtk_text_mark_get_visible((*C.GtkTextMark)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetVisible is a wrapper around the C function gtk_text_mark_set_visible.
func (recv *TextMark) SetVisible(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_mark_set_visible((*C.GtkTextMark)(recv.native), c_setting)

	return
}

// TextTag is a wrapper around the C record GtkTextTag.
type TextTag struct {
	native *C.GtkTextTag
	// parent_instance : record
	// priv : record
}

func TextTagNewFromC(u unsafe.Pointer) *TextTag {
	c := (*C.GtkTextTag)(u)
	if c == nil {
		return nil
	}

	g := &TextTag{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextTag) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextTag) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextTag with another TextTag, and returns true if they represent the same GObject.
func (recv *TextTag) Equals(other *TextTag) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextTag) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextTag.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextTag.
func CastToTextTag(object *gobject.Object) *TextTag {
	return TextTagNewFromC(object.ToC())
}

type signalTextTagEventDetail struct {
	callback  TextTagSignalEventCallback
	handlerID C.gulong
}

var signalTextTagEventId int
var signalTextTagEventMap = make(map[int]signalTextTagEventDetail)
var signalTextTagEventLock sync.RWMutex

// TextTagSignalEventCallback is a callback function for a 'event' signal emitted from a TextTag.
type TextTagSignalEventCallback func(object *gobject.Object, event *gdk.Event, iter *TextIter) bool

/*
ConnectEvent connects the callback to the 'event' signal for the TextTag.

The returned value represents the connection, and may be passed to DisconnectEvent to remove it.
*/
func (recv *TextTag) ConnectEvent(callback TextTagSignalEventCallback) int {
	signalTextTagEventLock.Lock()
	defer signalTextTagEventLock.Unlock()

	signalTextTagEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTag_signal_connect_event(instance, C.gpointer(uintptr(signalTextTagEventId)))

	detail := signalTextTagEventDetail{callback, handlerID}
	signalTextTagEventMap[signalTextTagEventId] = detail

	return signalTextTagEventId
}

/*
DisconnectEvent disconnects a callback from the 'event' signal for the TextTag.

The connectionID should be a value returned from a call to ConnectEvent.
*/
func (recv *TextTag) DisconnectEvent(connectionID int) {
	signalTextTagEventLock.Lock()
	defer signalTextTagEventLock.Unlock()

	detail, exists := signalTextTagEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagEventMap, connectionID)
}

//export texttag_eventHandler
func texttag_eventHandler(_ *C.GObject, c_object *C.GObject, c_event *C.GdkEvent_, c_iter *C.GtkTextIter, data C.gpointer) C.gboolean {
	signalTextTagEventLock.RLock()
	defer signalTextTagEventLock.RUnlock()

	object := gobject.ObjectNewFromC(unsafe.Pointer(c_object))

	event := gdk.EventNewFromC(unsafe.Pointer(c_event))

	iter := TextIterNewFromC(unsafe.Pointer(c_iter))

	index := int(uintptr(data))
	callback := signalTextTagEventMap[index].callback
	retGo := callback(object, event, iter)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// TextTagNew is a wrapper around the C function gtk_text_tag_new.
func TextTagNew(name string) *TextTag {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_tag_new(c_name)
	retGo := TextTagNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Event is a wrapper around the C function gtk_text_tag_event.
func (recv *TextTag) Event(eventObject *gobject.Object, event *gdk.Event, iter *TextIter) bool {
	c_event_object := (*C.GObject)(C.NULL)
	if eventObject != nil {
		c_event_object = (*C.GObject)(eventObject.ToC())
	}

	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_tag_event((*C.GtkTextTag)(recv.native), c_event_object, c_event, c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// GetPriority is a wrapper around the C function gtk_text_tag_get_priority.
func (recv *TextTag) GetPriority() int32 {
	retC := C.gtk_text_tag_get_priority((*C.GtkTextTag)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// SetPriority is a wrapper around the C function gtk_text_tag_set_priority.
func (recv *TextTag) SetPriority(priority int32) {
	c_priority := (C.gint)(priority)

	C.gtk_text_tag_set_priority((*C.GtkTextTag)(recv.native), c_priority)

	return
}

// TextTagTable is a wrapper around the C record GtkTextTagTable.
type TextTagTable struct {
	native *C.GtkTextTagTable
	// parent_instance : record
	// priv : record
}

func TextTagTableNewFromC(u unsafe.Pointer) *TextTagTable {
	c := (*C.GtkTextTagTable)(u)
	if c == nil {
		return nil
	}

	g := &TextTagTable{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextTagTable) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextTagTable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextTagTable with another TextTagTable, and returns true if they represent the same GObject.
func (recv *TextTagTable) Equals(other *TextTagTable) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TextTagTable) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TextTagTable.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextTagTable.
func CastToTextTagTable(object *gobject.Object) *TextTagTable {
	return TextTagTableNewFromC(object.ToC())
}

type signalTextTagTableTagAddedDetail struct {
	callback  TextTagTableSignalTagAddedCallback
	handlerID C.gulong
}

var signalTextTagTableTagAddedId int
var signalTextTagTableTagAddedMap = make(map[int]signalTextTagTableTagAddedDetail)
var signalTextTagTableTagAddedLock sync.RWMutex

// TextTagTableSignalTagAddedCallback is a callback function for a 'tag-added' signal emitted from a TextTagTable.
type TextTagTableSignalTagAddedCallback func(tag *TextTag)

/*
ConnectTagAdded connects the callback to the 'tag-added' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagAdded to remove it.
*/
func (recv *TextTagTable) ConnectTagAdded(callback TextTagTableSignalTagAddedCallback) int {
	signalTextTagTableTagAddedLock.Lock()
	defer signalTextTagTableTagAddedLock.Unlock()

	signalTextTagTableTagAddedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_added(instance, C.gpointer(uintptr(signalTextTagTableTagAddedId)))

	detail := signalTextTagTableTagAddedDetail{callback, handlerID}
	signalTextTagTableTagAddedMap[signalTextTagTableTagAddedId] = detail

	return signalTextTagTableTagAddedId
}

/*
DisconnectTagAdded disconnects a callback from the 'tag-added' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagAdded.
*/
func (recv *TextTagTable) DisconnectTagAdded(connectionID int) {
	signalTextTagTableTagAddedLock.Lock()
	defer signalTextTagTableTagAddedLock.Unlock()

	detail, exists := signalTextTagTableTagAddedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagAddedMap, connectionID)
}

//export texttagtable_tagAddedHandler
func texttagtable_tagAddedHandler(_ *C.GObject, c_tag *C.GtkTextTag, data C.gpointer) {
	signalTextTagTableTagAddedLock.RLock()
	defer signalTextTagTableTagAddedLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	index := int(uintptr(data))
	callback := signalTextTagTableTagAddedMap[index].callback
	callback(tag)
}

type signalTextTagTableTagChangedDetail struct {
	callback  TextTagTableSignalTagChangedCallback
	handlerID C.gulong
}

var signalTextTagTableTagChangedId int
var signalTextTagTableTagChangedMap = make(map[int]signalTextTagTableTagChangedDetail)
var signalTextTagTableTagChangedLock sync.RWMutex

// TextTagTableSignalTagChangedCallback is a callback function for a 'tag-changed' signal emitted from a TextTagTable.
type TextTagTableSignalTagChangedCallback func(tag *TextTag, sizeChanged bool)

/*
ConnectTagChanged connects the callback to the 'tag-changed' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagChanged to remove it.
*/
func (recv *TextTagTable) ConnectTagChanged(callback TextTagTableSignalTagChangedCallback) int {
	signalTextTagTableTagChangedLock.Lock()
	defer signalTextTagTableTagChangedLock.Unlock()

	signalTextTagTableTagChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_changed(instance, C.gpointer(uintptr(signalTextTagTableTagChangedId)))

	detail := signalTextTagTableTagChangedDetail{callback, handlerID}
	signalTextTagTableTagChangedMap[signalTextTagTableTagChangedId] = detail

	return signalTextTagTableTagChangedId
}

/*
DisconnectTagChanged disconnects a callback from the 'tag-changed' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagChanged.
*/
func (recv *TextTagTable) DisconnectTagChanged(connectionID int) {
	signalTextTagTableTagChangedLock.Lock()
	defer signalTextTagTableTagChangedLock.Unlock()

	detail, exists := signalTextTagTableTagChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagChangedMap, connectionID)
}

//export texttagtable_tagChangedHandler
func texttagtable_tagChangedHandler(_ *C.GObject, c_tag *C.GtkTextTag, c_size_changed C.gboolean, data C.gpointer) {
	signalTextTagTableTagChangedLock.RLock()
	defer signalTextTagTableTagChangedLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	sizeChanged := c_size_changed == C.TRUE

	index := int(uintptr(data))
	callback := signalTextTagTableTagChangedMap[index].callback
	callback(tag, sizeChanged)
}

type signalTextTagTableTagRemovedDetail struct {
	callback  TextTagTableSignalTagRemovedCallback
	handlerID C.gulong
}

var signalTextTagTableTagRemovedId int
var signalTextTagTableTagRemovedMap = make(map[int]signalTextTagTableTagRemovedDetail)
var signalTextTagTableTagRemovedLock sync.RWMutex

// TextTagTableSignalTagRemovedCallback is a callback function for a 'tag-removed' signal emitted from a TextTagTable.
type TextTagTableSignalTagRemovedCallback func(tag *TextTag)

/*
ConnectTagRemoved connects the callback to the 'tag-removed' signal for the TextTagTable.

The returned value represents the connection, and may be passed to DisconnectTagRemoved to remove it.
*/
func (recv *TextTagTable) ConnectTagRemoved(callback TextTagTableSignalTagRemovedCallback) int {
	signalTextTagTableTagRemovedLock.Lock()
	defer signalTextTagTableTagRemovedLock.Unlock()

	signalTextTagTableTagRemovedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextTagTable_signal_connect_tag_removed(instance, C.gpointer(uintptr(signalTextTagTableTagRemovedId)))

	detail := signalTextTagTableTagRemovedDetail{callback, handlerID}
	signalTextTagTableTagRemovedMap[signalTextTagTableTagRemovedId] = detail

	return signalTextTagTableTagRemovedId
}

/*
DisconnectTagRemoved disconnects a callback from the 'tag-removed' signal for the TextTagTable.

The connectionID should be a value returned from a call to ConnectTagRemoved.
*/
func (recv *TextTagTable) DisconnectTagRemoved(connectionID int) {
	signalTextTagTableTagRemovedLock.Lock()
	defer signalTextTagTableTagRemovedLock.Unlock()

	detail, exists := signalTextTagTableTagRemovedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextTagTableTagRemovedMap, connectionID)
}

//export texttagtable_tagRemovedHandler
func texttagtable_tagRemovedHandler(_ *C.GObject, c_tag *C.GtkTextTag, data C.gpointer) {
	signalTextTagTableTagRemovedLock.RLock()
	defer signalTextTagTableTagRemovedLock.RUnlock()

	tag := TextTagNewFromC(unsafe.Pointer(c_tag))

	index := int(uintptr(data))
	callback := signalTextTagTableTagRemovedMap[index].callback
	callback(tag)
}

// TextTagTableNew is a wrapper around the C function gtk_text_tag_table_new.
func TextTagTableNew() *TextTagTable {
	retC := C.gtk_text_tag_table_new()
	retGo := TextTagTableNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Add is a wrapper around the C function gtk_text_tag_table_add.
func (recv *TextTagTable) Add(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_tag_table_add((*C.GtkTextTagTable)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_text_tag_table_foreach : unsupported parameter func : no type generator for TextTagTableForeach (GtkTextTagTableForeach) for param func

// GetSize is a wrapper around the C function gtk_text_tag_table_get_size.
func (recv *TextTagTable) GetSize() int32 {
	retC := C.gtk_text_tag_table_get_size((*C.GtkTextTagTable)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Lookup is a wrapper around the C function gtk_text_tag_table_lookup.
func (recv *TextTagTable) Lookup(name string) *TextTag {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_text_tag_table_lookup((*C.GtkTextTagTable)(recv.native), c_name)
	var retGo (*TextTag)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TextTagNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Remove is a wrapper around the C function gtk_text_tag_table_remove.
func (recv *TextTagTable) Remove(tag *TextTag) {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	C.gtk_text_tag_table_remove((*C.GtkTextTagTable)(recv.native), c_tag)

	return
}

// Buildable returns the Buildable interface implemented by TextTagTable
func (recv *TextTagTable) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TextView is a wrapper around the C record GtkTextView.
type TextView struct {
	native *C.GtkTextView
	// parent_instance : record
	// Private : priv
}

func TextViewNewFromC(u unsafe.Pointer) *TextView {
	c := (*C.GtkTextView)(u)
	if c == nil {
		return nil
	}

	g := &TextView{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextView) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextView with another TextView, and returns true if they represent the same GObject.
func (recv *TextView) Equals(other *TextView) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *TextView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *TextView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TextView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TextView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to TextView.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextView.
func CastToTextView(object *gobject.Object) *TextView {
	return TextViewNewFromC(object.ToC())
}

type signalTextViewBackspaceDetail struct {
	callback  TextViewSignalBackspaceCallback
	handlerID C.gulong
}

var signalTextViewBackspaceId int
var signalTextViewBackspaceMap = make(map[int]signalTextViewBackspaceDetail)
var signalTextViewBackspaceLock sync.RWMutex

// TextViewSignalBackspaceCallback is a callback function for a 'backspace' signal emitted from a TextView.
type TextViewSignalBackspaceCallback func()

/*
ConnectBackspace connects the callback to the 'backspace' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectBackspace to remove it.
*/
func (recv *TextView) ConnectBackspace(callback TextViewSignalBackspaceCallback) int {
	signalTextViewBackspaceLock.Lock()
	defer signalTextViewBackspaceLock.Unlock()

	signalTextViewBackspaceId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_backspace(instance, C.gpointer(uintptr(signalTextViewBackspaceId)))

	detail := signalTextViewBackspaceDetail{callback, handlerID}
	signalTextViewBackspaceMap[signalTextViewBackspaceId] = detail

	return signalTextViewBackspaceId
}

/*
DisconnectBackspace disconnects a callback from the 'backspace' signal for the TextView.

The connectionID should be a value returned from a call to ConnectBackspace.
*/
func (recv *TextView) DisconnectBackspace(connectionID int) {
	signalTextViewBackspaceLock.Lock()
	defer signalTextViewBackspaceLock.Unlock()

	detail, exists := signalTextViewBackspaceMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewBackspaceMap, connectionID)
}

//export textview_backspaceHandler
func textview_backspaceHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewBackspaceLock.RLock()
	defer signalTextViewBackspaceLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewBackspaceMap[index].callback
	callback()
}

type signalTextViewCopyClipboardDetail struct {
	callback  TextViewSignalCopyClipboardCallback
	handlerID C.gulong
}

var signalTextViewCopyClipboardId int
var signalTextViewCopyClipboardMap = make(map[int]signalTextViewCopyClipboardDetail)
var signalTextViewCopyClipboardLock sync.RWMutex

// TextViewSignalCopyClipboardCallback is a callback function for a 'copy-clipboard' signal emitted from a TextView.
type TextViewSignalCopyClipboardCallback func()

/*
ConnectCopyClipboard connects the callback to the 'copy-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectCopyClipboard to remove it.
*/
func (recv *TextView) ConnectCopyClipboard(callback TextViewSignalCopyClipboardCallback) int {
	signalTextViewCopyClipboardLock.Lock()
	defer signalTextViewCopyClipboardLock.Unlock()

	signalTextViewCopyClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_copy_clipboard(instance, C.gpointer(uintptr(signalTextViewCopyClipboardId)))

	detail := signalTextViewCopyClipboardDetail{callback, handlerID}
	signalTextViewCopyClipboardMap[signalTextViewCopyClipboardId] = detail

	return signalTextViewCopyClipboardId
}

/*
DisconnectCopyClipboard disconnects a callback from the 'copy-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectCopyClipboard.
*/
func (recv *TextView) DisconnectCopyClipboard(connectionID int) {
	signalTextViewCopyClipboardLock.Lock()
	defer signalTextViewCopyClipboardLock.Unlock()

	detail, exists := signalTextViewCopyClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewCopyClipboardMap, connectionID)
}

//export textview_copyClipboardHandler
func textview_copyClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewCopyClipboardLock.RLock()
	defer signalTextViewCopyClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewCopyClipboardMap[index].callback
	callback()
}

type signalTextViewCutClipboardDetail struct {
	callback  TextViewSignalCutClipboardCallback
	handlerID C.gulong
}

var signalTextViewCutClipboardId int
var signalTextViewCutClipboardMap = make(map[int]signalTextViewCutClipboardDetail)
var signalTextViewCutClipboardLock sync.RWMutex

// TextViewSignalCutClipboardCallback is a callback function for a 'cut-clipboard' signal emitted from a TextView.
type TextViewSignalCutClipboardCallback func()

/*
ConnectCutClipboard connects the callback to the 'cut-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectCutClipboard to remove it.
*/
func (recv *TextView) ConnectCutClipboard(callback TextViewSignalCutClipboardCallback) int {
	signalTextViewCutClipboardLock.Lock()
	defer signalTextViewCutClipboardLock.Unlock()

	signalTextViewCutClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_cut_clipboard(instance, C.gpointer(uintptr(signalTextViewCutClipboardId)))

	detail := signalTextViewCutClipboardDetail{callback, handlerID}
	signalTextViewCutClipboardMap[signalTextViewCutClipboardId] = detail

	return signalTextViewCutClipboardId
}

/*
DisconnectCutClipboard disconnects a callback from the 'cut-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectCutClipboard.
*/
func (recv *TextView) DisconnectCutClipboard(connectionID int) {
	signalTextViewCutClipboardLock.Lock()
	defer signalTextViewCutClipboardLock.Unlock()

	detail, exists := signalTextViewCutClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewCutClipboardMap, connectionID)
}

//export textview_cutClipboardHandler
func textview_cutClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewCutClipboardLock.RLock()
	defer signalTextViewCutClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewCutClipboardMap[index].callback
	callback()
}

type signalTextViewDeleteFromCursorDetail struct {
	callback  TextViewSignalDeleteFromCursorCallback
	handlerID C.gulong
}

var signalTextViewDeleteFromCursorId int
var signalTextViewDeleteFromCursorMap = make(map[int]signalTextViewDeleteFromCursorDetail)
var signalTextViewDeleteFromCursorLock sync.RWMutex

// TextViewSignalDeleteFromCursorCallback is a callback function for a 'delete-from-cursor' signal emitted from a TextView.
type TextViewSignalDeleteFromCursorCallback func(type_ DeleteType, count int32)

/*
ConnectDeleteFromCursor connects the callback to the 'delete-from-cursor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectDeleteFromCursor to remove it.
*/
func (recv *TextView) ConnectDeleteFromCursor(callback TextViewSignalDeleteFromCursorCallback) int {
	signalTextViewDeleteFromCursorLock.Lock()
	defer signalTextViewDeleteFromCursorLock.Unlock()

	signalTextViewDeleteFromCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_delete_from_cursor(instance, C.gpointer(uintptr(signalTextViewDeleteFromCursorId)))

	detail := signalTextViewDeleteFromCursorDetail{callback, handlerID}
	signalTextViewDeleteFromCursorMap[signalTextViewDeleteFromCursorId] = detail

	return signalTextViewDeleteFromCursorId
}

/*
DisconnectDeleteFromCursor disconnects a callback from the 'delete-from-cursor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectDeleteFromCursor.
*/
func (recv *TextView) DisconnectDeleteFromCursor(connectionID int) {
	signalTextViewDeleteFromCursorLock.Lock()
	defer signalTextViewDeleteFromCursorLock.Unlock()

	detail, exists := signalTextViewDeleteFromCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewDeleteFromCursorMap, connectionID)
}

//export textview_deleteFromCursorHandler
func textview_deleteFromCursorHandler(_ *C.GObject, c_type C.GtkDeleteType, c_count C.gint, data C.gpointer) {
	signalTextViewDeleteFromCursorLock.RLock()
	defer signalTextViewDeleteFromCursorLock.RUnlock()

	type_ := DeleteType(c_type)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalTextViewDeleteFromCursorMap[index].callback
	callback(type_, count)
}

type signalTextViewInsertAtCursorDetail struct {
	callback  TextViewSignalInsertAtCursorCallback
	handlerID C.gulong
}

var signalTextViewInsertAtCursorId int
var signalTextViewInsertAtCursorMap = make(map[int]signalTextViewInsertAtCursorDetail)
var signalTextViewInsertAtCursorLock sync.RWMutex

// TextViewSignalInsertAtCursorCallback is a callback function for a 'insert-at-cursor' signal emitted from a TextView.
type TextViewSignalInsertAtCursorCallback func(string_ string)

/*
ConnectInsertAtCursor connects the callback to the 'insert-at-cursor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectInsertAtCursor to remove it.
*/
func (recv *TextView) ConnectInsertAtCursor(callback TextViewSignalInsertAtCursorCallback) int {
	signalTextViewInsertAtCursorLock.Lock()
	defer signalTextViewInsertAtCursorLock.Unlock()

	signalTextViewInsertAtCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_insert_at_cursor(instance, C.gpointer(uintptr(signalTextViewInsertAtCursorId)))

	detail := signalTextViewInsertAtCursorDetail{callback, handlerID}
	signalTextViewInsertAtCursorMap[signalTextViewInsertAtCursorId] = detail

	return signalTextViewInsertAtCursorId
}

/*
DisconnectInsertAtCursor disconnects a callback from the 'insert-at-cursor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectInsertAtCursor.
*/
func (recv *TextView) DisconnectInsertAtCursor(connectionID int) {
	signalTextViewInsertAtCursorLock.Lock()
	defer signalTextViewInsertAtCursorLock.Unlock()

	detail, exists := signalTextViewInsertAtCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewInsertAtCursorMap, connectionID)
}

//export textview_insertAtCursorHandler
func textview_insertAtCursorHandler(_ *C.GObject, c_string *C.gchar, data C.gpointer) {
	signalTextViewInsertAtCursorLock.RLock()
	defer signalTextViewInsertAtCursorLock.RUnlock()

	string_ := C.GoString(c_string)

	index := int(uintptr(data))
	callback := signalTextViewInsertAtCursorMap[index].callback
	callback(string_)
}

type signalTextViewMoveCursorDetail struct {
	callback  TextViewSignalMoveCursorCallback
	handlerID C.gulong
}

var signalTextViewMoveCursorId int
var signalTextViewMoveCursorMap = make(map[int]signalTextViewMoveCursorDetail)
var signalTextViewMoveCursorLock sync.RWMutex

// TextViewSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a TextView.
type TextViewSignalMoveCursorCallback func(step MovementStep, count int32, extendSelection bool)

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *TextView) ConnectMoveCursor(callback TextViewSignalMoveCursorCallback) int {
	signalTextViewMoveCursorLock.Lock()
	defer signalTextViewMoveCursorLock.Unlock()

	signalTextViewMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalTextViewMoveCursorId)))

	detail := signalTextViewMoveCursorDetail{callback, handlerID}
	signalTextViewMoveCursorMap[signalTextViewMoveCursorId] = detail

	return signalTextViewMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *TextView) DisconnectMoveCursor(connectionID int) {
	signalTextViewMoveCursorLock.Lock()
	defer signalTextViewMoveCursorLock.Unlock()

	detail, exists := signalTextViewMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewMoveCursorMap, connectionID)
}

//export textview_moveCursorHandler
func textview_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_count C.gint, c_extend_selection C.gboolean, data C.gpointer) {
	signalTextViewMoveCursorLock.RLock()
	defer signalTextViewMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	count := int32(c_count)

	extendSelection := c_extend_selection == C.TRUE

	index := int(uintptr(data))
	callback := signalTextViewMoveCursorMap[index].callback
	callback(step, count, extendSelection)
}

type signalTextViewMoveViewportDetail struct {
	callback  TextViewSignalMoveViewportCallback
	handlerID C.gulong
}

var signalTextViewMoveViewportId int
var signalTextViewMoveViewportMap = make(map[int]signalTextViewMoveViewportDetail)
var signalTextViewMoveViewportLock sync.RWMutex

// TextViewSignalMoveViewportCallback is a callback function for a 'move-viewport' signal emitted from a TextView.
type TextViewSignalMoveViewportCallback func(step ScrollStep, count int32)

/*
ConnectMoveViewport connects the callback to the 'move-viewport' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectMoveViewport to remove it.
*/
func (recv *TextView) ConnectMoveViewport(callback TextViewSignalMoveViewportCallback) int {
	signalTextViewMoveViewportLock.Lock()
	defer signalTextViewMoveViewportLock.Unlock()

	signalTextViewMoveViewportId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_move_viewport(instance, C.gpointer(uintptr(signalTextViewMoveViewportId)))

	detail := signalTextViewMoveViewportDetail{callback, handlerID}
	signalTextViewMoveViewportMap[signalTextViewMoveViewportId] = detail

	return signalTextViewMoveViewportId
}

/*
DisconnectMoveViewport disconnects a callback from the 'move-viewport' signal for the TextView.

The connectionID should be a value returned from a call to ConnectMoveViewport.
*/
func (recv *TextView) DisconnectMoveViewport(connectionID int) {
	signalTextViewMoveViewportLock.Lock()
	defer signalTextViewMoveViewportLock.Unlock()

	detail, exists := signalTextViewMoveViewportMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewMoveViewportMap, connectionID)
}

//export textview_moveViewportHandler
func textview_moveViewportHandler(_ *C.GObject, c_step C.GtkScrollStep, c_count C.gint, data C.gpointer) {
	signalTextViewMoveViewportLock.RLock()
	defer signalTextViewMoveViewportLock.RUnlock()

	step := ScrollStep(c_step)

	count := int32(c_count)

	index := int(uintptr(data))
	callback := signalTextViewMoveViewportMap[index].callback
	callback(step, count)
}

type signalTextViewPasteClipboardDetail struct {
	callback  TextViewSignalPasteClipboardCallback
	handlerID C.gulong
}

var signalTextViewPasteClipboardId int
var signalTextViewPasteClipboardMap = make(map[int]signalTextViewPasteClipboardDetail)
var signalTextViewPasteClipboardLock sync.RWMutex

// TextViewSignalPasteClipboardCallback is a callback function for a 'paste-clipboard' signal emitted from a TextView.
type TextViewSignalPasteClipboardCallback func()

/*
ConnectPasteClipboard connects the callback to the 'paste-clipboard' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectPasteClipboard to remove it.
*/
func (recv *TextView) ConnectPasteClipboard(callback TextViewSignalPasteClipboardCallback) int {
	signalTextViewPasteClipboardLock.Lock()
	defer signalTextViewPasteClipboardLock.Unlock()

	signalTextViewPasteClipboardId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_paste_clipboard(instance, C.gpointer(uintptr(signalTextViewPasteClipboardId)))

	detail := signalTextViewPasteClipboardDetail{callback, handlerID}
	signalTextViewPasteClipboardMap[signalTextViewPasteClipboardId] = detail

	return signalTextViewPasteClipboardId
}

/*
DisconnectPasteClipboard disconnects a callback from the 'paste-clipboard' signal for the TextView.

The connectionID should be a value returned from a call to ConnectPasteClipboard.
*/
func (recv *TextView) DisconnectPasteClipboard(connectionID int) {
	signalTextViewPasteClipboardLock.Lock()
	defer signalTextViewPasteClipboardLock.Unlock()

	detail, exists := signalTextViewPasteClipboardMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewPasteClipboardMap, connectionID)
}

//export textview_pasteClipboardHandler
func textview_pasteClipboardHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewPasteClipboardLock.RLock()
	defer signalTextViewPasteClipboardLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewPasteClipboardMap[index].callback
	callback()
}

type signalTextViewPopulatePopupDetail struct {
	callback  TextViewSignalPopulatePopupCallback
	handlerID C.gulong
}

var signalTextViewPopulatePopupId int
var signalTextViewPopulatePopupMap = make(map[int]signalTextViewPopulatePopupDetail)
var signalTextViewPopulatePopupLock sync.RWMutex

// TextViewSignalPopulatePopupCallback is a callback function for a 'populate-popup' signal emitted from a TextView.
type TextViewSignalPopulatePopupCallback func(popup *Widget)

/*
ConnectPopulatePopup connects the callback to the 'populate-popup' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectPopulatePopup to remove it.
*/
func (recv *TextView) ConnectPopulatePopup(callback TextViewSignalPopulatePopupCallback) int {
	signalTextViewPopulatePopupLock.Lock()
	defer signalTextViewPopulatePopupLock.Unlock()

	signalTextViewPopulatePopupId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_populate_popup(instance, C.gpointer(uintptr(signalTextViewPopulatePopupId)))

	detail := signalTextViewPopulatePopupDetail{callback, handlerID}
	signalTextViewPopulatePopupMap[signalTextViewPopulatePopupId] = detail

	return signalTextViewPopulatePopupId
}

/*
DisconnectPopulatePopup disconnects a callback from the 'populate-popup' signal for the TextView.

The connectionID should be a value returned from a call to ConnectPopulatePopup.
*/
func (recv *TextView) DisconnectPopulatePopup(connectionID int) {
	signalTextViewPopulatePopupLock.Lock()
	defer signalTextViewPopulatePopupLock.Unlock()

	detail, exists := signalTextViewPopulatePopupMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewPopulatePopupMap, connectionID)
}

//export textview_populatePopupHandler
func textview_populatePopupHandler(_ *C.GObject, c_popup *C.GtkWidget, data C.gpointer) {
	signalTextViewPopulatePopupLock.RLock()
	defer signalTextViewPopulatePopupLock.RUnlock()

	popup := WidgetNewFromC(unsafe.Pointer(c_popup))

	index := int(uintptr(data))
	callback := signalTextViewPopulatePopupMap[index].callback
	callback(popup)
}

type signalTextViewSelectAllDetail struct {
	callback  TextViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalTextViewSelectAllId int
var signalTextViewSelectAllMap = make(map[int]signalTextViewSelectAllDetail)
var signalTextViewSelectAllLock sync.RWMutex

// TextViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a TextView.
type TextViewSignalSelectAllCallback func(select_ bool)

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *TextView) ConnectSelectAll(callback TextViewSignalSelectAllCallback) int {
	signalTextViewSelectAllLock.Lock()
	defer signalTextViewSelectAllLock.Unlock()

	signalTextViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_select_all(instance, C.gpointer(uintptr(signalTextViewSelectAllId)))

	detail := signalTextViewSelectAllDetail{callback, handlerID}
	signalTextViewSelectAllMap[signalTextViewSelectAllId] = detail

	return signalTextViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the TextView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *TextView) DisconnectSelectAll(connectionID int) {
	signalTextViewSelectAllLock.Lock()
	defer signalTextViewSelectAllLock.Unlock()

	detail, exists := signalTextViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewSelectAllMap, connectionID)
}

//export textview_selectAllHandler
func textview_selectAllHandler(_ *C.GObject, c_select C.gboolean, data C.gpointer) {
	signalTextViewSelectAllLock.RLock()
	defer signalTextViewSelectAllLock.RUnlock()

	select_ := c_select == C.TRUE

	index := int(uintptr(data))
	callback := signalTextViewSelectAllMap[index].callback
	callback(select_)
}

type signalTextViewSetAnchorDetail struct {
	callback  TextViewSignalSetAnchorCallback
	handlerID C.gulong
}

var signalTextViewSetAnchorId int
var signalTextViewSetAnchorMap = make(map[int]signalTextViewSetAnchorDetail)
var signalTextViewSetAnchorLock sync.RWMutex

// TextViewSignalSetAnchorCallback is a callback function for a 'set-anchor' signal emitted from a TextView.
type TextViewSignalSetAnchorCallback func()

/*
ConnectSetAnchor connects the callback to the 'set-anchor' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectSetAnchor to remove it.
*/
func (recv *TextView) ConnectSetAnchor(callback TextViewSignalSetAnchorCallback) int {
	signalTextViewSetAnchorLock.Lock()
	defer signalTextViewSetAnchorLock.Unlock()

	signalTextViewSetAnchorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_set_anchor(instance, C.gpointer(uintptr(signalTextViewSetAnchorId)))

	detail := signalTextViewSetAnchorDetail{callback, handlerID}
	signalTextViewSetAnchorMap[signalTextViewSetAnchorId] = detail

	return signalTextViewSetAnchorId
}

/*
DisconnectSetAnchor disconnects a callback from the 'set-anchor' signal for the TextView.

The connectionID should be a value returned from a call to ConnectSetAnchor.
*/
func (recv *TextView) DisconnectSetAnchor(connectionID int) {
	signalTextViewSetAnchorLock.Lock()
	defer signalTextViewSetAnchorLock.Unlock()

	detail, exists := signalTextViewSetAnchorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewSetAnchorMap, connectionID)
}

//export textview_setAnchorHandler
func textview_setAnchorHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewSetAnchorLock.RLock()
	defer signalTextViewSetAnchorLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewSetAnchorMap[index].callback
	callback()
}

type signalTextViewToggleCursorVisibleDetail struct {
	callback  TextViewSignalToggleCursorVisibleCallback
	handlerID C.gulong
}

var signalTextViewToggleCursorVisibleId int
var signalTextViewToggleCursorVisibleMap = make(map[int]signalTextViewToggleCursorVisibleDetail)
var signalTextViewToggleCursorVisibleLock sync.RWMutex

// TextViewSignalToggleCursorVisibleCallback is a callback function for a 'toggle-cursor-visible' signal emitted from a TextView.
type TextViewSignalToggleCursorVisibleCallback func()

/*
ConnectToggleCursorVisible connects the callback to the 'toggle-cursor-visible' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorVisible to remove it.
*/
func (recv *TextView) ConnectToggleCursorVisible(callback TextViewSignalToggleCursorVisibleCallback) int {
	signalTextViewToggleCursorVisibleLock.Lock()
	defer signalTextViewToggleCursorVisibleLock.Unlock()

	signalTextViewToggleCursorVisibleId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_toggle_cursor_visible(instance, C.gpointer(uintptr(signalTextViewToggleCursorVisibleId)))

	detail := signalTextViewToggleCursorVisibleDetail{callback, handlerID}
	signalTextViewToggleCursorVisibleMap[signalTextViewToggleCursorVisibleId] = detail

	return signalTextViewToggleCursorVisibleId
}

/*
DisconnectToggleCursorVisible disconnects a callback from the 'toggle-cursor-visible' signal for the TextView.

The connectionID should be a value returned from a call to ConnectToggleCursorVisible.
*/
func (recv *TextView) DisconnectToggleCursorVisible(connectionID int) {
	signalTextViewToggleCursorVisibleLock.Lock()
	defer signalTextViewToggleCursorVisibleLock.Unlock()

	detail, exists := signalTextViewToggleCursorVisibleMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewToggleCursorVisibleMap, connectionID)
}

//export textview_toggleCursorVisibleHandler
func textview_toggleCursorVisibleHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewToggleCursorVisibleLock.RLock()
	defer signalTextViewToggleCursorVisibleLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewToggleCursorVisibleMap[index].callback
	callback()
}

type signalTextViewToggleOverwriteDetail struct {
	callback  TextViewSignalToggleOverwriteCallback
	handlerID C.gulong
}

var signalTextViewToggleOverwriteId int
var signalTextViewToggleOverwriteMap = make(map[int]signalTextViewToggleOverwriteDetail)
var signalTextViewToggleOverwriteLock sync.RWMutex

// TextViewSignalToggleOverwriteCallback is a callback function for a 'toggle-overwrite' signal emitted from a TextView.
type TextViewSignalToggleOverwriteCallback func()

/*
ConnectToggleOverwrite connects the callback to the 'toggle-overwrite' signal for the TextView.

The returned value represents the connection, and may be passed to DisconnectToggleOverwrite to remove it.
*/
func (recv *TextView) ConnectToggleOverwrite(callback TextViewSignalToggleOverwriteCallback) int {
	signalTextViewToggleOverwriteLock.Lock()
	defer signalTextViewToggleOverwriteLock.Unlock()

	signalTextViewToggleOverwriteId++
	instance := C.gpointer(recv.native)
	handlerID := C.TextView_signal_connect_toggle_overwrite(instance, C.gpointer(uintptr(signalTextViewToggleOverwriteId)))

	detail := signalTextViewToggleOverwriteDetail{callback, handlerID}
	signalTextViewToggleOverwriteMap[signalTextViewToggleOverwriteId] = detail

	return signalTextViewToggleOverwriteId
}

/*
DisconnectToggleOverwrite disconnects a callback from the 'toggle-overwrite' signal for the TextView.

The connectionID should be a value returned from a call to ConnectToggleOverwrite.
*/
func (recv *TextView) DisconnectToggleOverwrite(connectionID int) {
	signalTextViewToggleOverwriteLock.Lock()
	defer signalTextViewToggleOverwriteLock.Unlock()

	detail, exists := signalTextViewToggleOverwriteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTextViewToggleOverwriteMap, connectionID)
}

//export textview_toggleOverwriteHandler
func textview_toggleOverwriteHandler(_ *C.GObject, data C.gpointer) {
	signalTextViewToggleOverwriteLock.RLock()
	defer signalTextViewToggleOverwriteLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTextViewToggleOverwriteMap[index].callback
	callback()
}

// TextViewNew is a wrapper around the C function gtk_text_view_new.
func TextViewNew() *TextView {
	retC := C.gtk_text_view_new()
	retGo := TextViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TextViewNewWithBuffer is a wrapper around the C function gtk_text_view_new_with_buffer.
func TextViewNewWithBuffer(buffer *TextBuffer) *TextView {
	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	retC := C.gtk_text_view_new_with_buffer(c_buffer)
	retGo := TextViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AddChildAtAnchor is a wrapper around the C function gtk_text_view_add_child_at_anchor.
func (recv *TextView) AddChildAtAnchor(child *Widget, anchor *TextChildAnchor) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_anchor := (*C.GtkTextChildAnchor)(C.NULL)
	if anchor != nil {
		c_anchor = (*C.GtkTextChildAnchor)(anchor.ToC())
	}

	C.gtk_text_view_add_child_at_anchor((*C.GtkTextView)(recv.native), c_child, c_anchor)

	return
}

// AddChildInWindow is a wrapper around the C function gtk_text_view_add_child_in_window.
func (recv *TextView) AddChildInWindow(child *Widget, whichWindow TextWindowType, xpos int32, ypos int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_which_window := (C.GtkTextWindowType)(whichWindow)

	c_xpos := (C.gint)(xpos)

	c_ypos := (C.gint)(ypos)

	C.gtk_text_view_add_child_in_window((*C.GtkTextView)(recv.native), c_child, c_which_window, c_xpos, c_ypos)

	return
}

// BackwardDisplayLine is a wrapper around the C function gtk_text_view_backward_display_line.
func (recv *TextView) BackwardDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_backward_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// BackwardDisplayLineStart is a wrapper around the C function gtk_text_view_backward_display_line_start.
func (recv *TextView) BackwardDisplayLineStart(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_backward_display_line_start((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// BufferToWindowCoords is a wrapper around the C function gtk_text_view_buffer_to_window_coords.
func (recv *TextView) BufferToWindowCoords(win TextWindowType, bufferX int32, bufferY int32) (int32, int32) {
	c_win := (C.GtkTextWindowType)(win)

	c_buffer_x := (C.gint)(bufferX)

	c_buffer_y := (C.gint)(bufferY)

	var c_window_x C.gint

	var c_window_y C.gint

	C.gtk_text_view_buffer_to_window_coords((*C.GtkTextView)(recv.native), c_win, c_buffer_x, c_buffer_y, &c_window_x, &c_window_y)

	windowX := (int32)(c_window_x)

	windowY := (int32)(c_window_y)

	return windowX, windowY
}

// ForwardDisplayLine is a wrapper around the C function gtk_text_view_forward_display_line.
func (recv *TextView) ForwardDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_forward_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardDisplayLineEnd is a wrapper around the C function gtk_text_view_forward_display_line_end.
func (recv *TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_forward_display_line_end((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// GetAcceptsTab is a wrapper around the C function gtk_text_view_get_accepts_tab.
func (recv *TextView) GetAcceptsTab() bool {
	retC := C.gtk_text_view_get_accepts_tab((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetBorderWindowSize is a wrapper around the C function gtk_text_view_get_border_window_size.
func (recv *TextView) GetBorderWindowSize(type_ TextWindowType) int32 {
	c_type := (C.GtkTextWindowType)(type_)

	retC := C.gtk_text_view_get_border_window_size((*C.GtkTextView)(recv.native), c_type)
	retGo := (int32)(retC)

	return retGo
}

// GetBuffer is a wrapper around the C function gtk_text_view_get_buffer.
func (recv *TextView) GetBuffer() *TextBuffer {
	retC := C.gtk_text_view_get_buffer((*C.GtkTextView)(recv.native))
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCursorVisible is a wrapper around the C function gtk_text_view_get_cursor_visible.
func (recv *TextView) GetCursorVisible() bool {
	retC := C.gtk_text_view_get_cursor_visible((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetDefaultAttributes is a wrapper around the C function gtk_text_view_get_default_attributes.
func (recv *TextView) GetDefaultAttributes() *TextAttributes {
	retC := C.gtk_text_view_get_default_attributes((*C.GtkTextView)(recv.native))
	retGo := TextAttributesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetEditable is a wrapper around the C function gtk_text_view_get_editable.
func (recv *TextView) GetEditable() bool {
	retC := C.gtk_text_view_get_editable((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIndent is a wrapper around the C function gtk_text_view_get_indent.
func (recv *TextView) GetIndent() int32 {
	retC := C.gtk_text_view_get_indent((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetIterAtLocation is a wrapper around the C function gtk_text_view_get_iter_at_location.
func (recv *TextView) GetIterAtLocation(x int32, y int32) *TextIter {
	var c_iter C.GtkTextIter

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_text_view_get_iter_at_location((*C.GtkTextView)(recv.native), &c_iter, c_x, c_y)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// GetIterAtPosition is a wrapper around the C function gtk_text_view_get_iter_at_position.
func (recv *TextView) GetIterAtPosition(x int32, y int32) (*TextIter, int32) {
	var c_iter C.GtkTextIter

	var c_trailing C.gint

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_text_view_get_iter_at_position((*C.GtkTextView)(recv.native), &c_iter, &c_trailing, c_x, c_y)

	iter := TextIterNewFromC(unsafe.Pointer(&c_iter))

	trailing := (int32)(c_trailing)

	return iter, trailing
}

// GetIterLocation is a wrapper around the C function gtk_text_view_get_iter_location.
func (recv *TextView) GetIterLocation(iter *TextIter) *gdk.Rectangle {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	var c_location C.GdkRectangle

	C.gtk_text_view_get_iter_location((*C.GtkTextView)(recv.native), c_iter, &c_location)

	location := gdk.RectangleNewFromC(unsafe.Pointer(&c_location))

	return location
}

// GetJustification is a wrapper around the C function gtk_text_view_get_justification.
func (recv *TextView) GetJustification() Justification {
	retC := C.gtk_text_view_get_justification((*C.GtkTextView)(recv.native))
	retGo := (Justification)(retC)

	return retGo
}

// GetLeftMargin is a wrapper around the C function gtk_text_view_get_left_margin.
func (recv *TextView) GetLeftMargin() int32 {
	retC := C.gtk_text_view_get_left_margin((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetLineAtY is a wrapper around the C function gtk_text_view_get_line_at_y.
func (recv *TextView) GetLineAtY(y int32) (*TextIter, int32) {
	var c_target_iter C.GtkTextIter

	c_y := (C.gint)(y)

	var c_line_top C.gint

	C.gtk_text_view_get_line_at_y((*C.GtkTextView)(recv.native), &c_target_iter, c_y, &c_line_top)

	targetIter := TextIterNewFromC(unsafe.Pointer(&c_target_iter))

	lineTop := (int32)(c_line_top)

	return targetIter, lineTop
}

// GetLineYrange is a wrapper around the C function gtk_text_view_get_line_yrange.
func (recv *TextView) GetLineYrange(iter *TextIter) (int32, int32) {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	var c_y C.gint

	var c_height C.gint

	C.gtk_text_view_get_line_yrange((*C.GtkTextView)(recv.native), c_iter, &c_y, &c_height)

	y := (int32)(c_y)

	height := (int32)(c_height)

	return y, height
}

// GetOverwrite is a wrapper around the C function gtk_text_view_get_overwrite.
func (recv *TextView) GetOverwrite() bool {
	retC := C.gtk_text_view_get_overwrite((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPixelsAboveLines is a wrapper around the C function gtk_text_view_get_pixels_above_lines.
func (recv *TextView) GetPixelsAboveLines() int32 {
	retC := C.gtk_text_view_get_pixels_above_lines((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetPixelsBelowLines is a wrapper around the C function gtk_text_view_get_pixels_below_lines.
func (recv *TextView) GetPixelsBelowLines() int32 {
	retC := C.gtk_text_view_get_pixels_below_lines((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetPixelsInsideWrap is a wrapper around the C function gtk_text_view_get_pixels_inside_wrap.
func (recv *TextView) GetPixelsInsideWrap() int32 {
	retC := C.gtk_text_view_get_pixels_inside_wrap((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetRightMargin is a wrapper around the C function gtk_text_view_get_right_margin.
func (recv *TextView) GetRightMargin() int32 {
	retC := C.gtk_text_view_get_right_margin((*C.GtkTextView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetTabs is a wrapper around the C function gtk_text_view_get_tabs.
func (recv *TextView) GetTabs() *pango.TabArray {
	retC := C.gtk_text_view_get_tabs((*C.GtkTextView)(recv.native))
	var retGo (*pango.TabArray)
	if retC == nil {
		retGo = nil
	} else {
		retGo = pango.TabArrayNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetVisibleRect is a wrapper around the C function gtk_text_view_get_visible_rect.
func (recv *TextView) GetVisibleRect() *gdk.Rectangle {
	var c_visible_rect C.GdkRectangle

	C.gtk_text_view_get_visible_rect((*C.GtkTextView)(recv.native), &c_visible_rect)

	visibleRect := gdk.RectangleNewFromC(unsafe.Pointer(&c_visible_rect))

	return visibleRect
}

// GetWindow is a wrapper around the C function gtk_text_view_get_window.
func (recv *TextView) GetWindow(win TextWindowType) *gdk.Window {
	c_win := (C.GtkTextWindowType)(win)

	retC := C.gtk_text_view_get_window((*C.GtkTextView)(recv.native), c_win)
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetWindowType is a wrapper around the C function gtk_text_view_get_window_type.
func (recv *TextView) GetWindowType(window *gdk.Window) TextWindowType {
	c_window := (*C.GdkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GdkWindow)(window.ToC())
	}

	retC := C.gtk_text_view_get_window_type((*C.GtkTextView)(recv.native), c_window)
	retGo := (TextWindowType)(retC)

	return retGo
}

// GetWrapMode is a wrapper around the C function gtk_text_view_get_wrap_mode.
func (recv *TextView) GetWrapMode() WrapMode {
	retC := C.gtk_text_view_get_wrap_mode((*C.GtkTextView)(recv.native))
	retGo := (WrapMode)(retC)

	return retGo
}

// MoveChild is a wrapper around the C function gtk_text_view_move_child.
func (recv *TextView) MoveChild(child *Widget, xpos int32, ypos int32) {
	c_child := (*C.GtkWidget)(C.NULL)
	if child != nil {
		c_child = (*C.GtkWidget)(child.ToC())
	}

	c_xpos := (C.gint)(xpos)

	c_ypos := (C.gint)(ypos)

	C.gtk_text_view_move_child((*C.GtkTextView)(recv.native), c_child, c_xpos, c_ypos)

	return
}

// MoveMarkOnscreen is a wrapper around the C function gtk_text_view_move_mark_onscreen.
func (recv *TextView) MoveMarkOnscreen(mark *TextMark) bool {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	retC := C.gtk_text_view_move_mark_onscreen((*C.GtkTextView)(recv.native), c_mark)
	retGo := retC == C.TRUE

	return retGo
}

// MoveVisually is a wrapper around the C function gtk_text_view_move_visually.
func (recv *TextView) MoveVisually(iter *TextIter, count int32) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_count := (C.gint)(count)

	retC := C.gtk_text_view_move_visually((*C.GtkTextView)(recv.native), c_iter, c_count)
	retGo := retC == C.TRUE

	return retGo
}

// PlaceCursorOnscreen is a wrapper around the C function gtk_text_view_place_cursor_onscreen.
func (recv *TextView) PlaceCursorOnscreen() bool {
	retC := C.gtk_text_view_place_cursor_onscreen((*C.GtkTextView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ScrollMarkOnscreen is a wrapper around the C function gtk_text_view_scroll_mark_onscreen.
func (recv *TextView) ScrollMarkOnscreen(mark *TextMark) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	C.gtk_text_view_scroll_mark_onscreen((*C.GtkTextView)(recv.native), c_mark)

	return
}

// ScrollToIter is a wrapper around the C function gtk_text_view_scroll_to_iter.
func (recv *TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	c_within_margin := (C.gdouble)(withinMargin)

	c_use_align :=
		boolToGboolean(useAlign)

	c_xalign := (C.gdouble)(xalign)

	c_yalign := (C.gdouble)(yalign)

	retC := C.gtk_text_view_scroll_to_iter((*C.GtkTextView)(recv.native), c_iter, c_within_margin, c_use_align, c_xalign, c_yalign)
	retGo := retC == C.TRUE

	return retGo
}

// ScrollToMark is a wrapper around the C function gtk_text_view_scroll_to_mark.
func (recv *TextView) ScrollToMark(mark *TextMark, withinMargin float64, useAlign bool, xalign float64, yalign float64) {
	c_mark := (*C.GtkTextMark)(C.NULL)
	if mark != nil {
		c_mark = (*C.GtkTextMark)(mark.ToC())
	}

	c_within_margin := (C.gdouble)(withinMargin)

	c_use_align :=
		boolToGboolean(useAlign)

	c_xalign := (C.gdouble)(xalign)

	c_yalign := (C.gdouble)(yalign)

	C.gtk_text_view_scroll_to_mark((*C.GtkTextView)(recv.native), c_mark, c_within_margin, c_use_align, c_xalign, c_yalign)

	return
}

// SetAcceptsTab is a wrapper around the C function gtk_text_view_set_accepts_tab.
func (recv *TextView) SetAcceptsTab(acceptsTab bool) {
	c_accepts_tab :=
		boolToGboolean(acceptsTab)

	C.gtk_text_view_set_accepts_tab((*C.GtkTextView)(recv.native), c_accepts_tab)

	return
}

// SetBorderWindowSize is a wrapper around the C function gtk_text_view_set_border_window_size.
func (recv *TextView) SetBorderWindowSize(type_ TextWindowType, size int32) {
	c_type := (C.GtkTextWindowType)(type_)

	c_size := (C.gint)(size)

	C.gtk_text_view_set_border_window_size((*C.GtkTextView)(recv.native), c_type, c_size)

	return
}

// SetBuffer is a wrapper around the C function gtk_text_view_set_buffer.
func (recv *TextView) SetBuffer(buffer *TextBuffer) {
	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	C.gtk_text_view_set_buffer((*C.GtkTextView)(recv.native), c_buffer)

	return
}

// SetCursorVisible is a wrapper around the C function gtk_text_view_set_cursor_visible.
func (recv *TextView) SetCursorVisible(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_view_set_cursor_visible((*C.GtkTextView)(recv.native), c_setting)

	return
}

// SetEditable is a wrapper around the C function gtk_text_view_set_editable.
func (recv *TextView) SetEditable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_text_view_set_editable((*C.GtkTextView)(recv.native), c_setting)

	return
}

// SetIndent is a wrapper around the C function gtk_text_view_set_indent.
func (recv *TextView) SetIndent(indent int32) {
	c_indent := (C.gint)(indent)

	C.gtk_text_view_set_indent((*C.GtkTextView)(recv.native), c_indent)

	return
}

// SetJustification is a wrapper around the C function gtk_text_view_set_justification.
func (recv *TextView) SetJustification(justification Justification) {
	c_justification := (C.GtkJustification)(justification)

	C.gtk_text_view_set_justification((*C.GtkTextView)(recv.native), c_justification)

	return
}

// SetLeftMargin is a wrapper around the C function gtk_text_view_set_left_margin.
func (recv *TextView) SetLeftMargin(leftMargin int32) {
	c_left_margin := (C.gint)(leftMargin)

	C.gtk_text_view_set_left_margin((*C.GtkTextView)(recv.native), c_left_margin)

	return
}

// SetOverwrite is a wrapper around the C function gtk_text_view_set_overwrite.
func (recv *TextView) SetOverwrite(overwrite bool) {
	c_overwrite :=
		boolToGboolean(overwrite)

	C.gtk_text_view_set_overwrite((*C.GtkTextView)(recv.native), c_overwrite)

	return
}

// SetPixelsAboveLines is a wrapper around the C function gtk_text_view_set_pixels_above_lines.
func (recv *TextView) SetPixelsAboveLines(pixelsAboveLines int32) {
	c_pixels_above_lines := (C.gint)(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines((*C.GtkTextView)(recv.native), c_pixels_above_lines)

	return
}

// SetPixelsBelowLines is a wrapper around the C function gtk_text_view_set_pixels_below_lines.
func (recv *TextView) SetPixelsBelowLines(pixelsBelowLines int32) {
	c_pixels_below_lines := (C.gint)(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines((*C.GtkTextView)(recv.native), c_pixels_below_lines)

	return
}

// SetPixelsInsideWrap is a wrapper around the C function gtk_text_view_set_pixels_inside_wrap.
func (recv *TextView) SetPixelsInsideWrap(pixelsInsideWrap int32) {
	c_pixels_inside_wrap := (C.gint)(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap((*C.GtkTextView)(recv.native), c_pixels_inside_wrap)

	return
}

// SetRightMargin is a wrapper around the C function gtk_text_view_set_right_margin.
func (recv *TextView) SetRightMargin(rightMargin int32) {
	c_right_margin := (C.gint)(rightMargin)

	C.gtk_text_view_set_right_margin((*C.GtkTextView)(recv.native), c_right_margin)

	return
}

// SetTabs is a wrapper around the C function gtk_text_view_set_tabs.
func (recv *TextView) SetTabs(tabs *pango.TabArray) {
	c_tabs := (*C.PangoTabArray)(C.NULL)
	if tabs != nil {
		c_tabs = (*C.PangoTabArray)(tabs.ToC())
	}

	C.gtk_text_view_set_tabs((*C.GtkTextView)(recv.native), c_tabs)

	return
}

// SetWrapMode is a wrapper around the C function gtk_text_view_set_wrap_mode.
func (recv *TextView) SetWrapMode(wrapMode WrapMode) {
	c_wrap_mode := (C.GtkWrapMode)(wrapMode)

	C.gtk_text_view_set_wrap_mode((*C.GtkTextView)(recv.native), c_wrap_mode)

	return
}

// StartsDisplayLine is a wrapper around the C function gtk_text_view_starts_display_line.
func (recv *TextView) StartsDisplayLine(iter *TextIter) bool {
	c_iter := (*C.GtkTextIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTextIter)(iter.ToC())
	}

	retC := C.gtk_text_view_starts_display_line((*C.GtkTextView)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// WindowToBufferCoords is a wrapper around the C function gtk_text_view_window_to_buffer_coords.
func (recv *TextView) WindowToBufferCoords(win TextWindowType, windowX int32, windowY int32) (int32, int32) {
	c_win := (C.GtkTextWindowType)(win)

	c_window_x := (C.gint)(windowX)

	c_window_y := (C.gint)(windowY)

	var c_buffer_x C.gint

	var c_buffer_y C.gint

	C.gtk_text_view_window_to_buffer_coords((*C.GtkTextView)(recv.native), c_win, c_window_x, c_window_y, &c_buffer_x, &c_buffer_y)

	bufferX := (int32)(c_buffer_x)

	bufferY := (int32)(c_buffer_y)

	return bufferX, bufferY
}

// ImplementorIface returns the ImplementorIface interface implemented by TextView
func (recv *TextView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TextView
func (recv *TextView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by TextView
func (recv *TextView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// TextViewAccessible is a wrapper around the C record GtkTextViewAccessible.
type TextViewAccessible struct {
	native *C.GtkTextViewAccessible
	// parent : record
	// priv : record
}

func TextViewAccessibleNewFromC(u unsafe.Pointer) *TextViewAccessible {
	c := (*C.GtkTextViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TextViewAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TextViewAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TextViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextViewAccessible with another TextViewAccessible, and returns true if they represent the same GObject.
func (recv *TextViewAccessible) Equals(other *TextViewAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *TextViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *TextViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TextViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TextViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to TextViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TextViewAccessible.
func CastToTextViewAccessible(object *gobject.Object) *TextViewAccessible {
	return TextViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by TextViewAccessible
func (recv *TextViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// EditableText returns the EditableText interface implemented by TextViewAccessible
func (recv *TextViewAccessible) EditableText() *atk.EditableText {
	return atk.EditableTextNewFromC(recv.ToC())
}

// StreamableContent returns the StreamableContent interface implemented by TextViewAccessible
func (recv *TextViewAccessible) StreamableContent() *atk.StreamableContent {
	return atk.StreamableContentNewFromC(recv.ToC())
}

// Text returns the Text interface implemented by TextViewAccessible
func (recv *TextViewAccessible) Text() *atk.Text {
	return atk.TextNewFromC(recv.ToC())
}

// ThemingEngine is a wrapper around the C record GtkThemingEngine.
type ThemingEngine struct {
	native *C.GtkThemingEngine
	// parent_object : record
	// priv : record
}

func ThemingEngineNewFromC(u unsafe.Pointer) *ThemingEngine {
	c := (*C.GtkThemingEngine)(u)
	if c == nil {
		return nil
	}

	g := &ThemingEngine{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ThemingEngine) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ThemingEngine) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThemingEngine with another ThemingEngine, and returns true if they represent the same GObject.
func (recv *ThemingEngine) Equals(other *ThemingEngine) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ThemingEngine) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ThemingEngine.
// Exercise care, as this is a potentially dangerous function if the Object is not a ThemingEngine.
func CastToThemingEngine(object *gobject.Object) *ThemingEngine {
	return ThemingEngineNewFromC(object.ToC())
}

// ThemingEngineLoad is a wrapper around the C function gtk_theming_engine_load.
func ThemingEngineLoad(name string) *ThemingEngine {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_theming_engine_load(c_name)
	var retGo (*ThemingEngine)
	if retC == nil {
		retGo = nil
	} else {
		retGo = ThemingEngineNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetScreen is a wrapper around the C function gtk_theming_engine_get_screen.
func (recv *ThemingEngine) GetScreen() *gdk.Screen {
	retC := C.gtk_theming_engine_get_screen((*C.GtkThemingEngine)(recv.native))
	var retGo (*gdk.Screen)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.ScreenNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ToggleAction is a wrapper around the C record GtkToggleAction.
type ToggleAction struct {
	native *C.GtkToggleAction
	// parent : record
	// Private : private_data
}

func ToggleActionNewFromC(u unsafe.Pointer) *ToggleAction {
	c := (*C.GtkToggleAction)(u)
	if c == nil {
		return nil
	}

	g := &ToggleAction{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToggleAction) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToggleAction) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleAction with another ToggleAction, and returns true if they represent the same GObject.
func (recv *ToggleAction) Equals(other *ToggleAction) bool {
	return other.ToC() == recv.ToC()
}

// Action upcasts to *Action
func (recv *ToggleAction) Action() *Action {
	return ActionNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *ToggleAction) Object() *gobject.Object {
	return recv.Action().Object()
}

// CastToWidget down casts any arbitrary Object to ToggleAction.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleAction.
func CastToToggleAction(object *gobject.Object) *ToggleAction {
	return ToggleActionNewFromC(object.ToC())
}

type signalToggleActionToggledDetail struct {
	callback  ToggleActionSignalToggledCallback
	handlerID C.gulong
}

var signalToggleActionToggledId int
var signalToggleActionToggledMap = make(map[int]signalToggleActionToggledDetail)
var signalToggleActionToggledLock sync.RWMutex

// ToggleActionSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleAction.
type ToggleActionSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleAction.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleAction) ConnectToggled(callback ToggleActionSignalToggledCallback) int {
	signalToggleActionToggledLock.Lock()
	defer signalToggleActionToggledLock.Unlock()

	signalToggleActionToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleAction_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleActionToggledId)))

	detail := signalToggleActionToggledDetail{callback, handlerID}
	signalToggleActionToggledMap[signalToggleActionToggledId] = detail

	return signalToggleActionToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleAction.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleAction) DisconnectToggled(connectionID int) {
	signalToggleActionToggledLock.Lock()
	defer signalToggleActionToggledLock.Unlock()

	detail, exists := signalToggleActionToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleActionToggledMap, connectionID)
}

//export toggleaction_toggledHandler
func toggleaction_toggledHandler(_ *C.GObject, data C.gpointer) {
	signalToggleActionToggledLock.RLock()
	defer signalToggleActionToggledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToggleActionToggledMap[index].callback
	callback()
}

// ToggleActionNew is a wrapper around the C function gtk_toggle_action_new.
func ToggleActionNew(name string, label string, tooltip string, stockId string) *ToggleAction {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	c_tooltip := C.CString(tooltip)
	defer C.free(unsafe.Pointer(c_tooltip))

	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_toggle_action_new(c_name, c_label, c_tooltip, c_stock_id)
	retGo := ToggleActionNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// GetActive is a wrapper around the C function gtk_toggle_action_get_active.
func (recv *ToggleAction) GetActive() bool {
	retC := C.gtk_toggle_action_get_active((*C.GtkToggleAction)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetDrawAsRadio is a wrapper around the C function gtk_toggle_action_get_draw_as_radio.
func (recv *ToggleAction) GetDrawAsRadio() bool {
	retC := C.gtk_toggle_action_get_draw_as_radio((*C.GtkToggleAction)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetActive is a wrapper around the C function gtk_toggle_action_set_active.
func (recv *ToggleAction) SetActive(isActive bool) {
	c_is_active :=
		boolToGboolean(isActive)

	C.gtk_toggle_action_set_active((*C.GtkToggleAction)(recv.native), c_is_active)

	return
}

// SetDrawAsRadio is a wrapper around the C function gtk_toggle_action_set_draw_as_radio.
func (recv *ToggleAction) SetDrawAsRadio(drawAsRadio bool) {
	c_draw_as_radio :=
		boolToGboolean(drawAsRadio)

	C.gtk_toggle_action_set_draw_as_radio((*C.GtkToggleAction)(recv.native), c_draw_as_radio)

	return
}

// Toggled is a wrapper around the C function gtk_toggle_action_toggled.
func (recv *ToggleAction) Toggled() {
	C.gtk_toggle_action_toggled((*C.GtkToggleAction)(recv.native))

	return
}

// Buildable returns the Buildable interface implemented by ToggleAction
func (recv *ToggleAction) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToggleButton is a wrapper around the C record GtkToggleButton.
type ToggleButton struct {
	native *C.GtkToggleButton
	// Private : button
	// Private : priv
}

func ToggleButtonNewFromC(u unsafe.Pointer) *ToggleButton {
	c := (*C.GtkToggleButton)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToggleButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToggleButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleButton with another ToggleButton, and returns true if they represent the same GObject.
func (recv *ToggleButton) Equals(other *ToggleButton) bool {
	return other.ToC() == recv.ToC()
}

// Button upcasts to *Button
func (recv *ToggleButton) Button() *Button {
	return ButtonNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ToggleButton) Bin() *Bin {
	return recv.Button().Bin()
}

// Container upcasts to *Container
func (recv *ToggleButton) Container() *Container {
	return recv.Button().Container()
}

// Widget upcasts to *Widget
func (recv *ToggleButton) Widget() *Widget {
	return recv.Button().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToggleButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Button().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToggleButton) Object() *gobject.Object {
	return recv.Button().Object()
}

// CastToWidget down casts any arbitrary Object to ToggleButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleButton.
func CastToToggleButton(object *gobject.Object) *ToggleButton {
	return ToggleButtonNewFromC(object.ToC())
}

type signalToggleButtonToggledDetail struct {
	callback  ToggleButtonSignalToggledCallback
	handlerID C.gulong
}

var signalToggleButtonToggledId int
var signalToggleButtonToggledMap = make(map[int]signalToggleButtonToggledDetail)
var signalToggleButtonToggledLock sync.RWMutex

// ToggleButtonSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleButton.
type ToggleButtonSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleButton.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleButton) ConnectToggled(callback ToggleButtonSignalToggledCallback) int {
	signalToggleButtonToggledLock.Lock()
	defer signalToggleButtonToggledLock.Unlock()

	signalToggleButtonToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleButton_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleButtonToggledId)))

	detail := signalToggleButtonToggledDetail{callback, handlerID}
	signalToggleButtonToggledMap[signalToggleButtonToggledId] = detail

	return signalToggleButtonToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleButton.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleButton) DisconnectToggled(connectionID int) {
	signalToggleButtonToggledLock.Lock()
	defer signalToggleButtonToggledLock.Unlock()

	detail, exists := signalToggleButtonToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleButtonToggledMap, connectionID)
}

//export togglebutton_toggledHandler
func togglebutton_toggledHandler(_ *C.GObject, data C.gpointer) {
	signalToggleButtonToggledLock.RLock()
	defer signalToggleButtonToggledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToggleButtonToggledMap[index].callback
	callback()
}

// ToggleButtonNew is a wrapper around the C function gtk_toggle_button_new.
func ToggleButtonNew() *ToggleButton {
	retC := C.gtk_toggle_button_new()
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ToggleButtonNewWithLabel is a wrapper around the C function gtk_toggle_button_new_with_label.
func ToggleButtonNewWithLabel(label string) *ToggleButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_toggle_button_new_with_label(c_label)
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ToggleButtonNewWithMnemonic is a wrapper around the C function gtk_toggle_button_new_with_mnemonic.
func ToggleButtonNewWithMnemonic(label string) *ToggleButton {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_toggle_button_new_with_mnemonic(c_label)
	retGo := ToggleButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetActive is a wrapper around the C function gtk_toggle_button_get_active.
func (recv *ToggleButton) GetActive() bool {
	retC := C.gtk_toggle_button_get_active((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetInconsistent is a wrapper around the C function gtk_toggle_button_get_inconsistent.
func (recv *ToggleButton) GetInconsistent() bool {
	retC := C.gtk_toggle_button_get_inconsistent((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetMode is a wrapper around the C function gtk_toggle_button_get_mode.
func (recv *ToggleButton) GetMode() bool {
	retC := C.gtk_toggle_button_get_mode((*C.GtkToggleButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetActive is a wrapper around the C function gtk_toggle_button_set_active.
func (recv *ToggleButton) SetActive(isActive bool) {
	c_is_active :=
		boolToGboolean(isActive)

	C.gtk_toggle_button_set_active((*C.GtkToggleButton)(recv.native), c_is_active)

	return
}

// SetInconsistent is a wrapper around the C function gtk_toggle_button_set_inconsistent.
func (recv *ToggleButton) SetInconsistent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_toggle_button_set_inconsistent((*C.GtkToggleButton)(recv.native), c_setting)

	return
}

// SetMode is a wrapper around the C function gtk_toggle_button_set_mode.
func (recv *ToggleButton) SetMode(drawIndicator bool) {
	c_draw_indicator :=
		boolToGboolean(drawIndicator)

	C.gtk_toggle_button_set_mode((*C.GtkToggleButton)(recv.native), c_draw_indicator)

	return
}

// Toggled is a wrapper around the C function gtk_toggle_button_toggled.
func (recv *ToggleButton) Toggled() {
	C.gtk_toggle_button_toggled((*C.GtkToggleButton)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ToggleButton
func (recv *ToggleButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToggleButton
func (recv *ToggleButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToggleButton
func (recv *ToggleButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToggleButton
func (recv *ToggleButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToggleButtonAccessible is a wrapper around the C record GtkToggleButtonAccessible.
type ToggleButtonAccessible struct {
	native *C.GtkToggleButtonAccessible
	// parent : record
	// priv : record
}

func ToggleButtonAccessibleNewFromC(u unsafe.Pointer) *ToggleButtonAccessible {
	c := (*C.GtkToggleButtonAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButtonAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToggleButtonAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToggleButtonAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleButtonAccessible with another ToggleButtonAccessible, and returns true if they represent the same GObject.
func (recv *ToggleButtonAccessible) Equals(other *ToggleButtonAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessible upcasts to *ButtonAccessible
func (recv *ToggleButtonAccessible) ButtonAccessible() *ButtonAccessible {
	return ButtonAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *ToggleButtonAccessible) ContainerAccessible() *ContainerAccessible {
	return recv.ButtonAccessible().ContainerAccessible()
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *ToggleButtonAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ButtonAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *ToggleButtonAccessible) Accessible() *Accessible {
	return recv.ButtonAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *ToggleButtonAccessible) Object() *atk.Object {
	return recv.ButtonAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to ToggleButtonAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleButtonAccessible.
func CastToToggleButtonAccessible(object *gobject.Object) *ToggleButtonAccessible {
	return ToggleButtonAccessibleNewFromC(object.ToC())
}

// Action returns the Action interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Action() *atk.Action {
	return atk.ActionNewFromC(recv.ToC())
}

// Component returns the Component interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Image returns the Image interface implemented by ToggleButtonAccessible
func (recv *ToggleButtonAccessible) Image() *atk.Image {
	return atk.ImageNewFromC(recv.ToC())
}

// ToggleToolButton is a wrapper around the C record GtkToggleToolButton.
type ToggleToolButton struct {
	native *C.GtkToggleToolButton
	// parent : record
	// Private : priv
}

func ToggleToolButtonNewFromC(u unsafe.Pointer) *ToggleToolButton {
	c := (*C.GtkToggleToolButton)(u)
	if c == nil {
		return nil
	}

	g := &ToggleToolButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToggleToolButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToggleToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleToolButton with another ToggleToolButton, and returns true if they represent the same GObject.
func (recv *ToggleToolButton) Equals(other *ToggleToolButton) bool {
	return other.ToC() == recv.ToC()
}

// ToolButton upcasts to *ToolButton
func (recv *ToggleToolButton) ToolButton() *ToolButton {
	return ToolButtonNewFromC(unsafe.Pointer(recv.native))
}

// ToolItem upcasts to *ToolItem
func (recv *ToggleToolButton) ToolItem() *ToolItem {
	return recv.ToolButton().ToolItem()
}

// Bin upcasts to *Bin
func (recv *ToggleToolButton) Bin() *Bin {
	return recv.ToolButton().Bin()
}

// Container upcasts to *Container
func (recv *ToggleToolButton) Container() *Container {
	return recv.ToolButton().Container()
}

// Widget upcasts to *Widget
func (recv *ToggleToolButton) Widget() *Widget {
	return recv.ToolButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToggleToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToggleToolButton) Object() *gobject.Object {
	return recv.ToolButton().Object()
}

// CastToWidget down casts any arbitrary Object to ToggleToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToggleToolButton.
func CastToToggleToolButton(object *gobject.Object) *ToggleToolButton {
	return ToggleToolButtonNewFromC(object.ToC())
}

type signalToggleToolButtonToggledDetail struct {
	callback  ToggleToolButtonSignalToggledCallback
	handlerID C.gulong
}

var signalToggleToolButtonToggledId int
var signalToggleToolButtonToggledMap = make(map[int]signalToggleToolButtonToggledDetail)
var signalToggleToolButtonToggledLock sync.RWMutex

// ToggleToolButtonSignalToggledCallback is a callback function for a 'toggled' signal emitted from a ToggleToolButton.
type ToggleToolButtonSignalToggledCallback func()

/*
ConnectToggled connects the callback to the 'toggled' signal for the ToggleToolButton.

The returned value represents the connection, and may be passed to DisconnectToggled to remove it.
*/
func (recv *ToggleToolButton) ConnectToggled(callback ToggleToolButtonSignalToggledCallback) int {
	signalToggleToolButtonToggledLock.Lock()
	defer signalToggleToolButtonToggledLock.Unlock()

	signalToggleToolButtonToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToggleToolButton_signal_connect_toggled(instance, C.gpointer(uintptr(signalToggleToolButtonToggledId)))

	detail := signalToggleToolButtonToggledDetail{callback, handlerID}
	signalToggleToolButtonToggledMap[signalToggleToolButtonToggledId] = detail

	return signalToggleToolButtonToggledId
}

/*
DisconnectToggled disconnects a callback from the 'toggled' signal for the ToggleToolButton.

The connectionID should be a value returned from a call to ConnectToggled.
*/
func (recv *ToggleToolButton) DisconnectToggled(connectionID int) {
	signalToggleToolButtonToggledLock.Lock()
	defer signalToggleToolButtonToggledLock.Unlock()

	detail, exists := signalToggleToolButtonToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToggleToolButtonToggledMap, connectionID)
}

//export toggletoolbutton_toggledHandler
func toggletoolbutton_toggledHandler(_ *C.GObject, data C.gpointer) {
	signalToggleToolButtonToggledLock.RLock()
	defer signalToggleToolButtonToggledLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToggleToolButtonToggledMap[index].callback
	callback()
}

// ToggleToolButtonNew is a wrapper around the C function gtk_toggle_tool_button_new.
func ToggleToolButtonNew() *ToggleToolButton {
	retC := C.gtk_toggle_tool_button_new()
	retGo := ToggleToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ToggleToolButtonNewFromStock is a wrapper around the C function gtk_toggle_tool_button_new_from_stock.
func ToggleToolButtonNewFromStock(stockId string) *ToggleToolButton {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_toggle_tool_button_new_from_stock(c_stock_id)
	retGo := ToggleToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetActive is a wrapper around the C function gtk_toggle_tool_button_get_active.
func (recv *ToggleToolButton) GetActive() bool {
	retC := C.gtk_toggle_tool_button_get_active((*C.GtkToggleToolButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetActive is a wrapper around the C function gtk_toggle_tool_button_set_active.
func (recv *ToggleToolButton) SetActive(isActive bool) {
	c_is_active :=
		boolToGboolean(isActive)

	C.gtk_toggle_tool_button_set_active((*C.GtkToggleToolButton)(recv.native), c_is_active)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ToggleToolButton
func (recv *ToggleToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToggleToolButton
func (recv *ToggleToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolButton is a wrapper around the C record GtkToolButton.
type ToolButton struct {
	native *C.GtkToolButton
	// parent : record
	// Private : priv
}

func ToolButtonNewFromC(u unsafe.Pointer) *ToolButton {
	c := (*C.GtkToolButton)(u)
	if c == nil {
		return nil
	}

	g := &ToolButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToolButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToolButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolButton with another ToolButton, and returns true if they represent the same GObject.
func (recv *ToolButton) Equals(other *ToolButton) bool {
	return other.ToC() == recv.ToC()
}

// ToolItem upcasts to *ToolItem
func (recv *ToolButton) ToolItem() *ToolItem {
	return ToolItemNewFromC(unsafe.Pointer(recv.native))
}

// Bin upcasts to *Bin
func (recv *ToolButton) Bin() *Bin {
	return recv.ToolItem().Bin()
}

// Container upcasts to *Container
func (recv *ToolButton) Container() *Container {
	return recv.ToolItem().Container()
}

// Widget upcasts to *Widget
func (recv *ToolButton) Widget() *Widget {
	return recv.ToolItem().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ToolItem().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolButton) Object() *gobject.Object {
	return recv.ToolItem().Object()
}

// CastToWidget down casts any arbitrary Object to ToolButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolButton.
func CastToToolButton(object *gobject.Object) *ToolButton {
	return ToolButtonNewFromC(object.ToC())
}

type signalToolButtonClickedDetail struct {
	callback  ToolButtonSignalClickedCallback
	handlerID C.gulong
}

var signalToolButtonClickedId int
var signalToolButtonClickedMap = make(map[int]signalToolButtonClickedDetail)
var signalToolButtonClickedLock sync.RWMutex

// ToolButtonSignalClickedCallback is a callback function for a 'clicked' signal emitted from a ToolButton.
type ToolButtonSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the ToolButton.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *ToolButton) ConnectClicked(callback ToolButtonSignalClickedCallback) int {
	signalToolButtonClickedLock.Lock()
	defer signalToolButtonClickedLock.Unlock()

	signalToolButtonClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolButton_signal_connect_clicked(instance, C.gpointer(uintptr(signalToolButtonClickedId)))

	detail := signalToolButtonClickedDetail{callback, handlerID}
	signalToolButtonClickedMap[signalToolButtonClickedId] = detail

	return signalToolButtonClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the ToolButton.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *ToolButton) DisconnectClicked(connectionID int) {
	signalToolButtonClickedLock.Lock()
	defer signalToolButtonClickedLock.Unlock()

	detail, exists := signalToolButtonClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolButtonClickedMap, connectionID)
}

//export toolbutton_clickedHandler
func toolbutton_clickedHandler(_ *C.GObject, data C.gpointer) {
	signalToolButtonClickedLock.RLock()
	defer signalToolButtonClickedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToolButtonClickedMap[index].callback
	callback()
}

// ToolButtonNew is a wrapper around the C function gtk_tool_button_new.
func ToolButtonNew(iconWidget *Widget, label string) *ToolButton {
	c_icon_widget := (*C.GtkWidget)(C.NULL)
	if iconWidget != nil {
		c_icon_widget = (*C.GtkWidget)(iconWidget.ToC())
	}

	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	retC := C.gtk_tool_button_new(c_icon_widget, c_label)
	retGo := ToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ToolButtonNewFromStock is a wrapper around the C function gtk_tool_button_new_from_stock.
func ToolButtonNewFromStock(stockId string) *ToolButton {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	retC := C.gtk_tool_button_new_from_stock(c_stock_id)
	retGo := ToolButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIconName is a wrapper around the C function gtk_tool_button_get_icon_name.
func (recv *ToolButton) GetIconName() string {
	retC := C.gtk_tool_button_get_icon_name((*C.GtkToolButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetIconWidget is a wrapper around the C function gtk_tool_button_get_icon_widget.
func (recv *ToolButton) GetIconWidget() *Widget {
	retC := C.gtk_tool_button_get_icon_widget((*C.GtkToolButton)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetLabel is a wrapper around the C function gtk_tool_button_get_label.
func (recv *ToolButton) GetLabel() string {
	retC := C.gtk_tool_button_get_label((*C.GtkToolButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetLabelWidget is a wrapper around the C function gtk_tool_button_get_label_widget.
func (recv *ToolButton) GetLabelWidget() *Widget {
	retC := C.gtk_tool_button_get_label_widget((*C.GtkToolButton)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetStockId is a wrapper around the C function gtk_tool_button_get_stock_id.
func (recv *ToolButton) GetStockId() string {
	retC := C.gtk_tool_button_get_stock_id((*C.GtkToolButton)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUseUnderline is a wrapper around the C function gtk_tool_button_get_use_underline.
func (recv *ToolButton) GetUseUnderline() bool {
	retC := C.gtk_tool_button_get_use_underline((*C.GtkToolButton)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetIconName is a wrapper around the C function gtk_tool_button_set_icon_name.
func (recv *ToolButton) SetIconName(iconName string) {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	C.gtk_tool_button_set_icon_name((*C.GtkToolButton)(recv.native), c_icon_name)

	return
}

// SetIconWidget is a wrapper around the C function gtk_tool_button_set_icon_widget.
func (recv *ToolButton) SetIconWidget(iconWidget *Widget) {
	c_icon_widget := (*C.GtkWidget)(C.NULL)
	if iconWidget != nil {
		c_icon_widget = (*C.GtkWidget)(iconWidget.ToC())
	}

	C.gtk_tool_button_set_icon_widget((*C.GtkToolButton)(recv.native), c_icon_widget)

	return
}

// SetLabel is a wrapper around the C function gtk_tool_button_set_label.
func (recv *ToolButton) SetLabel(label string) {
	c_label := C.CString(label)
	defer C.free(unsafe.Pointer(c_label))

	C.gtk_tool_button_set_label((*C.GtkToolButton)(recv.native), c_label)

	return
}

// SetLabelWidget is a wrapper around the C function gtk_tool_button_set_label_widget.
func (recv *ToolButton) SetLabelWidget(labelWidget *Widget) {
	c_label_widget := (*C.GtkWidget)(C.NULL)
	if labelWidget != nil {
		c_label_widget = (*C.GtkWidget)(labelWidget.ToC())
	}

	C.gtk_tool_button_set_label_widget((*C.GtkToolButton)(recv.native), c_label_widget)

	return
}

// SetStockId is a wrapper around the C function gtk_tool_button_set_stock_id.
func (recv *ToolButton) SetStockId(stockId string) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	C.gtk_tool_button_set_stock_id((*C.GtkToolButton)(recv.native), c_stock_id)

	return
}

// SetUseUnderline is a wrapper around the C function gtk_tool_button_set_use_underline.
func (recv *ToolButton) SetUseUnderline(useUnderline bool) {
	c_use_underline :=
		boolToGboolean(useUnderline)

	C.gtk_tool_button_set_use_underline((*C.GtkToolButton)(recv.native), c_use_underline)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolButton
func (recv *ToolButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by ToolButton
func (recv *ToolButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToolButton
func (recv *ToolButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolButton
func (recv *ToolButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolItem is a wrapper around the C record GtkToolItem.
type ToolItem struct {
	native *C.GtkToolItem
	// parent : record
	// Private : priv
}

func ToolItemNewFromC(u unsafe.Pointer) *ToolItem {
	c := (*C.GtkToolItem)(u)
	if c == nil {
		return nil
	}

	g := &ToolItem{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToolItem) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToolItem) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolItem with another ToolItem, and returns true if they represent the same GObject.
func (recv *ToolItem) Equals(other *ToolItem) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *ToolItem) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *ToolItem) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *ToolItem) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolItem) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolItem) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to ToolItem.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolItem.
func CastToToolItem(object *gobject.Object) *ToolItem {
	return ToolItemNewFromC(object.ToC())
}

type signalToolItemCreateMenuProxyDetail struct {
	callback  ToolItemSignalCreateMenuProxyCallback
	handlerID C.gulong
}

var signalToolItemCreateMenuProxyId int
var signalToolItemCreateMenuProxyMap = make(map[int]signalToolItemCreateMenuProxyDetail)
var signalToolItemCreateMenuProxyLock sync.RWMutex

// ToolItemSignalCreateMenuProxyCallback is a callback function for a 'create-menu-proxy' signal emitted from a ToolItem.
type ToolItemSignalCreateMenuProxyCallback func() bool

/*
ConnectCreateMenuProxy connects the callback to the 'create-menu-proxy' signal for the ToolItem.

The returned value represents the connection, and may be passed to DisconnectCreateMenuProxy to remove it.
*/
func (recv *ToolItem) ConnectCreateMenuProxy(callback ToolItemSignalCreateMenuProxyCallback) int {
	signalToolItemCreateMenuProxyLock.Lock()
	defer signalToolItemCreateMenuProxyLock.Unlock()

	signalToolItemCreateMenuProxyId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolItem_signal_connect_create_menu_proxy(instance, C.gpointer(uintptr(signalToolItemCreateMenuProxyId)))

	detail := signalToolItemCreateMenuProxyDetail{callback, handlerID}
	signalToolItemCreateMenuProxyMap[signalToolItemCreateMenuProxyId] = detail

	return signalToolItemCreateMenuProxyId
}

/*
DisconnectCreateMenuProxy disconnects a callback from the 'create-menu-proxy' signal for the ToolItem.

The connectionID should be a value returned from a call to ConnectCreateMenuProxy.
*/
func (recv *ToolItem) DisconnectCreateMenuProxy(connectionID int) {
	signalToolItemCreateMenuProxyLock.Lock()
	defer signalToolItemCreateMenuProxyLock.Unlock()

	detail, exists := signalToolItemCreateMenuProxyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolItemCreateMenuProxyMap, connectionID)
}

//export toolitem_createMenuProxyHandler
func toolitem_createMenuProxyHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalToolItemCreateMenuProxyLock.RLock()
	defer signalToolItemCreateMenuProxyLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToolItemCreateMenuProxyMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalToolItemToolbarReconfiguredDetail struct {
	callback  ToolItemSignalToolbarReconfiguredCallback
	handlerID C.gulong
}

var signalToolItemToolbarReconfiguredId int
var signalToolItemToolbarReconfiguredMap = make(map[int]signalToolItemToolbarReconfiguredDetail)
var signalToolItemToolbarReconfiguredLock sync.RWMutex

// ToolItemSignalToolbarReconfiguredCallback is a callback function for a 'toolbar-reconfigured' signal emitted from a ToolItem.
type ToolItemSignalToolbarReconfiguredCallback func()

/*
ConnectToolbarReconfigured connects the callback to the 'toolbar-reconfigured' signal for the ToolItem.

The returned value represents the connection, and may be passed to DisconnectToolbarReconfigured to remove it.
*/
func (recv *ToolItem) ConnectToolbarReconfigured(callback ToolItemSignalToolbarReconfiguredCallback) int {
	signalToolItemToolbarReconfiguredLock.Lock()
	defer signalToolItemToolbarReconfiguredLock.Unlock()

	signalToolItemToolbarReconfiguredId++
	instance := C.gpointer(recv.native)
	handlerID := C.ToolItem_signal_connect_toolbar_reconfigured(instance, C.gpointer(uintptr(signalToolItemToolbarReconfiguredId)))

	detail := signalToolItemToolbarReconfiguredDetail{callback, handlerID}
	signalToolItemToolbarReconfiguredMap[signalToolItemToolbarReconfiguredId] = detail

	return signalToolItemToolbarReconfiguredId
}

/*
DisconnectToolbarReconfigured disconnects a callback from the 'toolbar-reconfigured' signal for the ToolItem.

The connectionID should be a value returned from a call to ConnectToolbarReconfigured.
*/
func (recv *ToolItem) DisconnectToolbarReconfigured(connectionID int) {
	signalToolItemToolbarReconfiguredLock.Lock()
	defer signalToolItemToolbarReconfiguredLock.Unlock()

	detail, exists := signalToolItemToolbarReconfiguredMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolItemToolbarReconfiguredMap, connectionID)
}

//export toolitem_toolbarReconfiguredHandler
func toolitem_toolbarReconfiguredHandler(_ *C.GObject, data C.gpointer) {
	signalToolItemToolbarReconfiguredLock.RLock()
	defer signalToolItemToolbarReconfiguredLock.RUnlock()

	index := int(uintptr(data))
	callback := signalToolItemToolbarReconfiguredMap[index].callback
	callback()
}

// ToolItemNew is a wrapper around the C function gtk_tool_item_new.
func ToolItemNew() *ToolItem {
	retC := C.gtk_tool_item_new()
	retGo := ToolItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetExpand is a wrapper around the C function gtk_tool_item_get_expand.
func (recv *ToolItem) GetExpand() bool {
	retC := C.gtk_tool_item_get_expand((*C.GtkToolItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetHomogeneous is a wrapper around the C function gtk_tool_item_get_homogeneous.
func (recv *ToolItem) GetHomogeneous() bool {
	retC := C.gtk_tool_item_get_homogeneous((*C.GtkToolItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetIconSize is a wrapper around the C function gtk_tool_item_get_icon_size.
func (recv *ToolItem) GetIconSize() IconSize {
	retC := C.gtk_tool_item_get_icon_size((*C.GtkToolItem)(recv.native))
	retGo := (IconSize)(retC)

	return retGo
}

// GetIsImportant is a wrapper around the C function gtk_tool_item_get_is_important.
func (recv *ToolItem) GetIsImportant() bool {
	retC := C.gtk_tool_item_get_is_important((*C.GtkToolItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetOrientation is a wrapper around the C function gtk_tool_item_get_orientation.
func (recv *ToolItem) GetOrientation() Orientation {
	retC := C.gtk_tool_item_get_orientation((*C.GtkToolItem)(recv.native))
	retGo := (Orientation)(retC)

	return retGo
}

// GetProxyMenuItem is a wrapper around the C function gtk_tool_item_get_proxy_menu_item.
func (recv *ToolItem) GetProxyMenuItem(menuItemId string) *Widget {
	c_menu_item_id := C.CString(menuItemId)
	defer C.free(unsafe.Pointer(c_menu_item_id))

	retC := C.gtk_tool_item_get_proxy_menu_item((*C.GtkToolItem)(recv.native), c_menu_item_id)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetReliefStyle is a wrapper around the C function gtk_tool_item_get_relief_style.
func (recv *ToolItem) GetReliefStyle() ReliefStyle {
	retC := C.gtk_tool_item_get_relief_style((*C.GtkToolItem)(recv.native))
	retGo := (ReliefStyle)(retC)

	return retGo
}

// GetToolbarStyle is a wrapper around the C function gtk_tool_item_get_toolbar_style.
func (recv *ToolItem) GetToolbarStyle() ToolbarStyle {
	retC := C.gtk_tool_item_get_toolbar_style((*C.GtkToolItem)(recv.native))
	retGo := (ToolbarStyle)(retC)

	return retGo
}

// GetUseDragWindow is a wrapper around the C function gtk_tool_item_get_use_drag_window.
func (recv *ToolItem) GetUseDragWindow() bool {
	retC := C.gtk_tool_item_get_use_drag_window((*C.GtkToolItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetVisibleHorizontal is a wrapper around the C function gtk_tool_item_get_visible_horizontal.
func (recv *ToolItem) GetVisibleHorizontal() bool {
	retC := C.gtk_tool_item_get_visible_horizontal((*C.GtkToolItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetVisibleVertical is a wrapper around the C function gtk_tool_item_get_visible_vertical.
func (recv *ToolItem) GetVisibleVertical() bool {
	retC := C.gtk_tool_item_get_visible_vertical((*C.GtkToolItem)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// RebuildMenu is a wrapper around the C function gtk_tool_item_rebuild_menu.
func (recv *ToolItem) RebuildMenu() {
	C.gtk_tool_item_rebuild_menu((*C.GtkToolItem)(recv.native))

	return
}

// RetrieveProxyMenuItem is a wrapper around the C function gtk_tool_item_retrieve_proxy_menu_item.
func (recv *ToolItem) RetrieveProxyMenuItem() *Widget {
	retC := C.gtk_tool_item_retrieve_proxy_menu_item((*C.GtkToolItem)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetExpand is a wrapper around the C function gtk_tool_item_set_expand.
func (recv *ToolItem) SetExpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_tool_item_set_expand((*C.GtkToolItem)(recv.native), c_expand)

	return
}

// SetHomogeneous is a wrapper around the C function gtk_tool_item_set_homogeneous.
func (recv *ToolItem) SetHomogeneous(homogeneous bool) {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	C.gtk_tool_item_set_homogeneous((*C.GtkToolItem)(recv.native), c_homogeneous)

	return
}

// SetIsImportant is a wrapper around the C function gtk_tool_item_set_is_important.
func (recv *ToolItem) SetIsImportant(isImportant bool) {
	c_is_important :=
		boolToGboolean(isImportant)

	C.gtk_tool_item_set_is_important((*C.GtkToolItem)(recv.native), c_is_important)

	return
}

// SetProxyMenuItem is a wrapper around the C function gtk_tool_item_set_proxy_menu_item.
func (recv *ToolItem) SetProxyMenuItem(menuItemId string, menuItem *Widget) {
	c_menu_item_id := C.CString(menuItemId)
	defer C.free(unsafe.Pointer(c_menu_item_id))

	c_menu_item := (*C.GtkWidget)(C.NULL)
	if menuItem != nil {
		c_menu_item = (*C.GtkWidget)(menuItem.ToC())
	}

	C.gtk_tool_item_set_proxy_menu_item((*C.GtkToolItem)(recv.native), c_menu_item_id, c_menu_item)

	return
}

// SetTooltipMarkup is a wrapper around the C function gtk_tool_item_set_tooltip_markup.
func (recv *ToolItem) SetTooltipMarkup(markup string) {
	c_markup := C.CString(markup)
	defer C.free(unsafe.Pointer(c_markup))

	C.gtk_tool_item_set_tooltip_markup((*C.GtkToolItem)(recv.native), c_markup)

	return
}

// SetTooltipText is a wrapper around the C function gtk_tool_item_set_tooltip_text.
func (recv *ToolItem) SetTooltipText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_tool_item_set_tooltip_text((*C.GtkToolItem)(recv.native), c_text)

	return
}

// SetUseDragWindow is a wrapper around the C function gtk_tool_item_set_use_drag_window.
func (recv *ToolItem) SetUseDragWindow(useDragWindow bool) {
	c_use_drag_window :=
		boolToGboolean(useDragWindow)

	C.gtk_tool_item_set_use_drag_window((*C.GtkToolItem)(recv.native), c_use_drag_window)

	return
}

// SetVisibleHorizontal is a wrapper around the C function gtk_tool_item_set_visible_horizontal.
func (recv *ToolItem) SetVisibleHorizontal(visibleHorizontal bool) {
	c_visible_horizontal :=
		boolToGboolean(visibleHorizontal)

	C.gtk_tool_item_set_visible_horizontal((*C.GtkToolItem)(recv.native), c_visible_horizontal)

	return
}

// SetVisibleVertical is a wrapper around the C function gtk_tool_item_set_visible_vertical.
func (recv *ToolItem) SetVisibleVertical(visibleVertical bool) {
	c_visible_vertical :=
		boolToGboolean(visibleVertical)

	C.gtk_tool_item_set_visible_vertical((*C.GtkToolItem)(recv.native), c_visible_vertical)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolItem
func (recv *ToolItem) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by ToolItem
func (recv *ToolItem) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolItem
func (recv *ToolItem) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolItemGroup is a wrapper around the C record GtkToolItemGroup.
type ToolItemGroup struct {
	native *C.GtkToolItemGroup
	// parent_instance : record
	// priv : record
}

func ToolItemGroupNewFromC(u unsafe.Pointer) *ToolItemGroup {
	c := (*C.GtkToolItemGroup)(u)
	if c == nil {
		return nil
	}

	g := &ToolItemGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToolItemGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToolItemGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolItemGroup with another ToolItemGroup, and returns true if they represent the same GObject.
func (recv *ToolItemGroup) Equals(other *ToolItemGroup) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *ToolItemGroup) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ToolItemGroup) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolItemGroup) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolItemGroup) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to ToolItemGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolItemGroup.
func CastToToolItemGroup(object *gobject.Object) *ToolItemGroup {
	return ToolItemGroupNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolItemGroup
func (recv *ToolItemGroup) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolItemGroup
func (recv *ToolItemGroup) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// ToolShell returns the ToolShell interface implemented by ToolItemGroup
func (recv *ToolItemGroup) ToolShell() *ToolShell {
	return ToolShellNewFromC(recv.ToC())
}

// ToolPalette is a wrapper around the C record GtkToolPalette.
type ToolPalette struct {
	native *C.GtkToolPalette
	// parent_instance : record
	// priv : record
}

func ToolPaletteNewFromC(u unsafe.Pointer) *ToolPalette {
	c := (*C.GtkToolPalette)(u)
	if c == nil {
		return nil
	}

	g := &ToolPalette{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToolPalette) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToolPalette) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolPalette with another ToolPalette, and returns true if they represent the same GObject.
func (recv *ToolPalette) Equals(other *ToolPalette) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *ToolPalette) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *ToolPalette) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *ToolPalette) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *ToolPalette) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to ToolPalette.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToolPalette.
func CastToToolPalette(object *gobject.Object) *ToolPalette {
	return ToolPaletteNewFromC(object.ToC())
}

// ImplementorIface returns the ImplementorIface interface implemented by ToolPalette
func (recv *ToolPalette) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by ToolPalette
func (recv *ToolPalette) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by ToolPalette
func (recv *ToolPalette) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by ToolPalette
func (recv *ToolPalette) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// Toolbar is a wrapper around the C record GtkToolbar.
type Toolbar struct {
	native *C.GtkToolbar
	// container : record
	// priv : record
}

func ToolbarNewFromC(u unsafe.Pointer) *Toolbar {
	c := (*C.GtkToolbar)(u)
	if c == nil {
		return nil
	}

	g := &Toolbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Toolbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Toolbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Toolbar with another Toolbar, and returns true if they represent the same GObject.
func (recv *Toolbar) Equals(other *Toolbar) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *Toolbar) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *Toolbar) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Toolbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Toolbar) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to Toolbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a Toolbar.
func CastToToolbar(object *gobject.Object) *Toolbar {
	return ToolbarNewFromC(object.ToC())
}

type signalToolbarFocusHomeOrEndDetail struct {
	callback  ToolbarSignalFocusHomeOrEndCallback
	handlerID C.gulong
}

var signalToolbarFocusHomeOrEndId int
var signalToolbarFocusHomeOrEndMap = make(map[int]signalToolbarFocusHomeOrEndDetail)
var signalToolbarFocusHomeOrEndLock sync.RWMutex

// ToolbarSignalFocusHomeOrEndCallback is a callback function for a 'focus-home-or-end' signal emitted from a Toolbar.
type ToolbarSignalFocusHomeOrEndCallback func(focusHome bool) bool

/*
ConnectFocusHomeOrEnd connects the callback to the 'focus-home-or-end' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectFocusHomeOrEnd to remove it.
*/
func (recv *Toolbar) ConnectFocusHomeOrEnd(callback ToolbarSignalFocusHomeOrEndCallback) int {
	signalToolbarFocusHomeOrEndLock.Lock()
	defer signalToolbarFocusHomeOrEndLock.Unlock()

	signalToolbarFocusHomeOrEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_focus_home_or_end(instance, C.gpointer(uintptr(signalToolbarFocusHomeOrEndId)))

	detail := signalToolbarFocusHomeOrEndDetail{callback, handlerID}
	signalToolbarFocusHomeOrEndMap[signalToolbarFocusHomeOrEndId] = detail

	return signalToolbarFocusHomeOrEndId
}

/*
DisconnectFocusHomeOrEnd disconnects a callback from the 'focus-home-or-end' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectFocusHomeOrEnd.
*/
func (recv *Toolbar) DisconnectFocusHomeOrEnd(connectionID int) {
	signalToolbarFocusHomeOrEndLock.Lock()
	defer signalToolbarFocusHomeOrEndLock.Unlock()

	detail, exists := signalToolbarFocusHomeOrEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarFocusHomeOrEndMap, connectionID)
}

//export toolbar_focusHomeOrEndHandler
func toolbar_focusHomeOrEndHandler(_ *C.GObject, c_focus_home C.gboolean, data C.gpointer) C.gboolean {
	signalToolbarFocusHomeOrEndLock.RLock()
	defer signalToolbarFocusHomeOrEndLock.RUnlock()

	focusHome := c_focus_home == C.TRUE

	index := int(uintptr(data))
	callback := signalToolbarFocusHomeOrEndMap[index].callback
	retGo := callback(focusHome)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalToolbarOrientationChangedDetail struct {
	callback  ToolbarSignalOrientationChangedCallback
	handlerID C.gulong
}

var signalToolbarOrientationChangedId int
var signalToolbarOrientationChangedMap = make(map[int]signalToolbarOrientationChangedDetail)
var signalToolbarOrientationChangedLock sync.RWMutex

// ToolbarSignalOrientationChangedCallback is a callback function for a 'orientation-changed' signal emitted from a Toolbar.
type ToolbarSignalOrientationChangedCallback func(orientation Orientation)

/*
ConnectOrientationChanged connects the callback to the 'orientation-changed' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectOrientationChanged to remove it.
*/
func (recv *Toolbar) ConnectOrientationChanged(callback ToolbarSignalOrientationChangedCallback) int {
	signalToolbarOrientationChangedLock.Lock()
	defer signalToolbarOrientationChangedLock.Unlock()

	signalToolbarOrientationChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_orientation_changed(instance, C.gpointer(uintptr(signalToolbarOrientationChangedId)))

	detail := signalToolbarOrientationChangedDetail{callback, handlerID}
	signalToolbarOrientationChangedMap[signalToolbarOrientationChangedId] = detail

	return signalToolbarOrientationChangedId
}

/*
DisconnectOrientationChanged disconnects a callback from the 'orientation-changed' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectOrientationChanged.
*/
func (recv *Toolbar) DisconnectOrientationChanged(connectionID int) {
	signalToolbarOrientationChangedLock.Lock()
	defer signalToolbarOrientationChangedLock.Unlock()

	detail, exists := signalToolbarOrientationChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarOrientationChangedMap, connectionID)
}

//export toolbar_orientationChangedHandler
func toolbar_orientationChangedHandler(_ *C.GObject, c_orientation C.GtkOrientation, data C.gpointer) {
	signalToolbarOrientationChangedLock.RLock()
	defer signalToolbarOrientationChangedLock.RUnlock()

	orientation := Orientation(c_orientation)

	index := int(uintptr(data))
	callback := signalToolbarOrientationChangedMap[index].callback
	callback(orientation)
}

type signalToolbarPopupContextMenuDetail struct {
	callback  ToolbarSignalPopupContextMenuCallback
	handlerID C.gulong
}

var signalToolbarPopupContextMenuId int
var signalToolbarPopupContextMenuMap = make(map[int]signalToolbarPopupContextMenuDetail)
var signalToolbarPopupContextMenuLock sync.RWMutex

// ToolbarSignalPopupContextMenuCallback is a callback function for a 'popup-context-menu' signal emitted from a Toolbar.
type ToolbarSignalPopupContextMenuCallback func(x int32, y int32, button int32) bool

/*
ConnectPopupContextMenu connects the callback to the 'popup-context-menu' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectPopupContextMenu to remove it.
*/
func (recv *Toolbar) ConnectPopupContextMenu(callback ToolbarSignalPopupContextMenuCallback) int {
	signalToolbarPopupContextMenuLock.Lock()
	defer signalToolbarPopupContextMenuLock.Unlock()

	signalToolbarPopupContextMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_popup_context_menu(instance, C.gpointer(uintptr(signalToolbarPopupContextMenuId)))

	detail := signalToolbarPopupContextMenuDetail{callback, handlerID}
	signalToolbarPopupContextMenuMap[signalToolbarPopupContextMenuId] = detail

	return signalToolbarPopupContextMenuId
}

/*
DisconnectPopupContextMenu disconnects a callback from the 'popup-context-menu' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectPopupContextMenu.
*/
func (recv *Toolbar) DisconnectPopupContextMenu(connectionID int) {
	signalToolbarPopupContextMenuLock.Lock()
	defer signalToolbarPopupContextMenuLock.Unlock()

	detail, exists := signalToolbarPopupContextMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarPopupContextMenuMap, connectionID)
}

//export toolbar_popupContextMenuHandler
func toolbar_popupContextMenuHandler(_ *C.GObject, c_x C.gint, c_y C.gint, c_button C.gint, data C.gpointer) C.gboolean {
	signalToolbarPopupContextMenuLock.RLock()
	defer signalToolbarPopupContextMenuLock.RUnlock()

	x := int32(c_x)

	y := int32(c_y)

	button := int32(c_button)

	index := int(uintptr(data))
	callback := signalToolbarPopupContextMenuMap[index].callback
	retGo := callback(x, y, button)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalToolbarStyleChangedDetail struct {
	callback  ToolbarSignalStyleChangedCallback
	handlerID C.gulong
}

var signalToolbarStyleChangedId int
var signalToolbarStyleChangedMap = make(map[int]signalToolbarStyleChangedDetail)
var signalToolbarStyleChangedLock sync.RWMutex

// ToolbarSignalStyleChangedCallback is a callback function for a 'style-changed' signal emitted from a Toolbar.
type ToolbarSignalStyleChangedCallback func(style ToolbarStyle)

/*
ConnectStyleChanged connects the callback to the 'style-changed' signal for the Toolbar.

The returned value represents the connection, and may be passed to DisconnectStyleChanged to remove it.
*/
func (recv *Toolbar) ConnectStyleChanged(callback ToolbarSignalStyleChangedCallback) int {
	signalToolbarStyleChangedLock.Lock()
	defer signalToolbarStyleChangedLock.Unlock()

	signalToolbarStyleChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Toolbar_signal_connect_style_changed(instance, C.gpointer(uintptr(signalToolbarStyleChangedId)))

	detail := signalToolbarStyleChangedDetail{callback, handlerID}
	signalToolbarStyleChangedMap[signalToolbarStyleChangedId] = detail

	return signalToolbarStyleChangedId
}

/*
DisconnectStyleChanged disconnects a callback from the 'style-changed' signal for the Toolbar.

The connectionID should be a value returned from a call to ConnectStyleChanged.
*/
func (recv *Toolbar) DisconnectStyleChanged(connectionID int) {
	signalToolbarStyleChangedLock.Lock()
	defer signalToolbarStyleChangedLock.Unlock()

	detail, exists := signalToolbarStyleChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalToolbarStyleChangedMap, connectionID)
}

//export toolbar_styleChangedHandler
func toolbar_styleChangedHandler(_ *C.GObject, c_style C.GtkToolbarStyle, data C.gpointer) {
	signalToolbarStyleChangedLock.RLock()
	defer signalToolbarStyleChangedLock.RUnlock()

	style := ToolbarStyle(c_style)

	index := int(uintptr(data))
	callback := signalToolbarStyleChangedMap[index].callback
	callback(style)
}

// ToolbarNew is a wrapper around the C function gtk_toolbar_new.
func ToolbarNew() *Toolbar {
	retC := C.gtk_toolbar_new()
	retGo := ToolbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetDropIndex is a wrapper around the C function gtk_toolbar_get_drop_index.
func (recv *Toolbar) GetDropIndex(x int32, y int32) int32 {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	retC := C.gtk_toolbar_get_drop_index((*C.GtkToolbar)(recv.native), c_x, c_y)
	retGo := (int32)(retC)

	return retGo
}

// GetIconSize is a wrapper around the C function gtk_toolbar_get_icon_size.
func (recv *Toolbar) GetIconSize() IconSize {
	retC := C.gtk_toolbar_get_icon_size((*C.GtkToolbar)(recv.native))
	retGo := (IconSize)(retC)

	return retGo
}

// GetItemIndex is a wrapper around the C function gtk_toolbar_get_item_index.
func (recv *Toolbar) GetItemIndex(item *ToolItem) int32 {
	c_item := (*C.GtkToolItem)(C.NULL)
	if item != nil {
		c_item = (*C.GtkToolItem)(item.ToC())
	}

	retC := C.gtk_toolbar_get_item_index((*C.GtkToolbar)(recv.native), c_item)
	retGo := (int32)(retC)

	return retGo
}

// GetNItems is a wrapper around the C function gtk_toolbar_get_n_items.
func (recv *Toolbar) GetNItems() int32 {
	retC := C.gtk_toolbar_get_n_items((*C.GtkToolbar)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetNthItem is a wrapper around the C function gtk_toolbar_get_nth_item.
func (recv *Toolbar) GetNthItem(n int32) *ToolItem {
	c_n := (C.gint)(n)

	retC := C.gtk_toolbar_get_nth_item((*C.GtkToolbar)(recv.native), c_n)
	var retGo (*ToolItem)
	if retC == nil {
		retGo = nil
	} else {
		retGo = ToolItemNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetReliefStyle is a wrapper around the C function gtk_toolbar_get_relief_style.
func (recv *Toolbar) GetReliefStyle() ReliefStyle {
	retC := C.gtk_toolbar_get_relief_style((*C.GtkToolbar)(recv.native))
	retGo := (ReliefStyle)(retC)

	return retGo
}

// GetShowArrow is a wrapper around the C function gtk_toolbar_get_show_arrow.
func (recv *Toolbar) GetShowArrow() bool {
	retC := C.gtk_toolbar_get_show_arrow((*C.GtkToolbar)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetStyle is a wrapper around the C function gtk_toolbar_get_style.
func (recv *Toolbar) GetStyle() ToolbarStyle {
	retC := C.gtk_toolbar_get_style((*C.GtkToolbar)(recv.native))
	retGo := (ToolbarStyle)(retC)

	return retGo
}

// Insert is a wrapper around the C function gtk_toolbar_insert.
func (recv *Toolbar) Insert(item *ToolItem, pos int32) {
	c_item := (*C.GtkToolItem)(C.NULL)
	if item != nil {
		c_item = (*C.GtkToolItem)(item.ToC())
	}

	c_pos := (C.gint)(pos)

	C.gtk_toolbar_insert((*C.GtkToolbar)(recv.native), c_item, c_pos)

	return
}

// SetDropHighlightItem is a wrapper around the C function gtk_toolbar_set_drop_highlight_item.
func (recv *Toolbar) SetDropHighlightItem(toolItem *ToolItem, index int32) {
	c_tool_item := (*C.GtkToolItem)(C.NULL)
	if toolItem != nil {
		c_tool_item = (*C.GtkToolItem)(toolItem.ToC())
	}

	c_index_ := (C.gint)(index)

	C.gtk_toolbar_set_drop_highlight_item((*C.GtkToolbar)(recv.native), c_tool_item, c_index_)

	return
}

// SetIconSize is a wrapper around the C function gtk_toolbar_set_icon_size.
func (recv *Toolbar) SetIconSize(iconSize IconSize) {
	c_icon_size := (C.GtkIconSize)(iconSize)

	C.gtk_toolbar_set_icon_size((*C.GtkToolbar)(recv.native), c_icon_size)

	return
}

// SetShowArrow is a wrapper around the C function gtk_toolbar_set_show_arrow.
func (recv *Toolbar) SetShowArrow(showArrow bool) {
	c_show_arrow :=
		boolToGboolean(showArrow)

	C.gtk_toolbar_set_show_arrow((*C.GtkToolbar)(recv.native), c_show_arrow)

	return
}

// SetStyle is a wrapper around the C function gtk_toolbar_set_style.
func (recv *Toolbar) SetStyle(style ToolbarStyle) {
	c_style := (C.GtkToolbarStyle)(style)

	C.gtk_toolbar_set_style((*C.GtkToolbar)(recv.native), c_style)

	return
}

// UnsetIconSize is a wrapper around the C function gtk_toolbar_unset_icon_size.
func (recv *Toolbar) UnsetIconSize() {
	C.gtk_toolbar_unset_icon_size((*C.GtkToolbar)(recv.native))

	return
}

// UnsetStyle is a wrapper around the C function gtk_toolbar_unset_style.
func (recv *Toolbar) UnsetStyle() {
	C.gtk_toolbar_unset_style((*C.GtkToolbar)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Toolbar
func (recv *Toolbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Toolbar
func (recv *Toolbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by Toolbar
func (recv *Toolbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// ToolShell returns the ToolShell interface implemented by Toolbar
func (recv *Toolbar) ToolShell() *ToolShell {
	return ToolShellNewFromC(recv.ToC())
}

// Tooltip is a wrapper around the C record GtkTooltip.
type Tooltip struct {
	native *C.GtkTooltip
}

func TooltipNewFromC(u unsafe.Pointer) *Tooltip {
	c := (*C.GtkTooltip)(u)
	if c == nil {
		return nil
	}

	g := &Tooltip{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Tooltip) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Tooltip) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Tooltip with another Tooltip, and returns true if they represent the same GObject.
func (recv *Tooltip) Equals(other *Tooltip) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *Tooltip) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to Tooltip.
// Exercise care, as this is a potentially dangerous function if the Object is not a Tooltip.
func CastToTooltip(object *gobject.Object) *Tooltip {
	return TooltipNewFromC(object.ToC())
}

// TooltipTriggerTooltipQuery is a wrapper around the C function gtk_tooltip_trigger_tooltip_query.
func TooltipTriggerTooltipQuery(display *gdk.Display) {
	c_display := (*C.GdkDisplay)(C.NULL)
	if display != nil {
		c_display = (*C.GdkDisplay)(display.ToC())
	}

	C.gtk_tooltip_trigger_tooltip_query(c_display)

	return
}

// SetCustom is a wrapper around the C function gtk_tooltip_set_custom.
func (recv *Tooltip) SetCustom(customWidget *Widget) {
	c_custom_widget := (*C.GtkWidget)(C.NULL)
	if customWidget != nil {
		c_custom_widget = (*C.GtkWidget)(customWidget.ToC())
	}

	C.gtk_tooltip_set_custom((*C.GtkTooltip)(recv.native), c_custom_widget)

	return
}

// SetIcon is a wrapper around the C function gtk_tooltip_set_icon.
func (recv *Tooltip) SetIcon(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_tooltip_set_icon((*C.GtkTooltip)(recv.native), c_pixbuf)

	return
}

// SetIconFromStock is a wrapper around the C function gtk_tooltip_set_icon_from_stock.
func (recv *Tooltip) SetIconFromStock(stockId string, size IconSize) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	C.gtk_tooltip_set_icon_from_stock((*C.GtkTooltip)(recv.native), c_stock_id, c_size)

	return
}

// SetMarkup is a wrapper around the C function gtk_tooltip_set_markup.
func (recv *Tooltip) SetMarkup(markup string) {
	c_markup := C.CString(markup)
	defer C.free(unsafe.Pointer(c_markup))

	C.gtk_tooltip_set_markup((*C.GtkTooltip)(recv.native), c_markup)

	return
}

// SetText is a wrapper around the C function gtk_tooltip_set_text.
func (recv *Tooltip) SetText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_tooltip_set_text((*C.GtkTooltip)(recv.native), c_text)

	return
}

// SetTipArea is a wrapper around the C function gtk_tooltip_set_tip_area.
func (recv *Tooltip) SetTipArea(rect *gdk.Rectangle) {
	c_rect := (*C.GdkRectangle)(C.NULL)
	if rect != nil {
		c_rect = (*C.GdkRectangle)(rect.ToC())
	}

	C.gtk_tooltip_set_tip_area((*C.GtkTooltip)(recv.native), c_rect)

	return
}

// ToplevelAccessible is a wrapper around the C record GtkToplevelAccessible.
type ToplevelAccessible struct {
	native *C.GtkToplevelAccessible
	// parent : record
	// priv : record
}

func ToplevelAccessibleNewFromC(u unsafe.Pointer) *ToplevelAccessible {
	c := (*C.GtkToplevelAccessible)(u)
	if c == nil {
		return nil
	}

	g := &ToplevelAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *ToplevelAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *ToplevelAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToplevelAccessible with another ToplevelAccessible, and returns true if they represent the same GObject.
func (recv *ToplevelAccessible) Equals(other *ToplevelAccessible) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *ToplevelAccessible) Object() *atk.Object {
	return atk.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to ToplevelAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a ToplevelAccessible.
func CastToToplevelAccessible(object *gobject.Object) *ToplevelAccessible {
	return ToplevelAccessibleNewFromC(object.ToC())
}

// GetChildren is a wrapper around the C function gtk_toplevel_accessible_get_children.
func (recv *ToplevelAccessible) GetChildren() *glib.List {
	retC := C.gtk_toplevel_accessible_get_children((*C.GtkToplevelAccessible)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TreeModelFilter is a wrapper around the C record GtkTreeModelFilter.
type TreeModelFilter struct {
	native *C.GtkTreeModelFilter
	// parent : record
	// Private : priv
}

func TreeModelFilterNewFromC(u unsafe.Pointer) *TreeModelFilter {
	c := (*C.GtkTreeModelFilter)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelFilter{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeModelFilter) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeModelFilter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelFilter with another TreeModelFilter, and returns true if they represent the same GObject.
func (recv *TreeModelFilter) Equals(other *TreeModelFilter) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TreeModelFilter) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TreeModelFilter.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeModelFilter.
func CastToTreeModelFilter(object *gobject.Object) *TreeModelFilter {
	return TreeModelFilterNewFromC(object.ToC())
}

// ClearCache is a wrapper around the C function gtk_tree_model_filter_clear_cache.
func (recv *TreeModelFilter) ClearCache() {
	C.gtk_tree_model_filter_clear_cache((*C.GtkTreeModelFilter)(recv.native))

	return
}

// ConvertChildIterToIter is a wrapper around the C function gtk_tree_model_filter_convert_child_iter_to_iter.
func (recv *TreeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (bool, *TreeIter) {
	var c_filter_iter C.GtkTreeIter

	c_child_iter := (*C.GtkTreeIter)(C.NULL)
	if childIter != nil {
		c_child_iter = (*C.GtkTreeIter)(childIter.ToC())
	}

	retC := C.gtk_tree_model_filter_convert_child_iter_to_iter((*C.GtkTreeModelFilter)(recv.native), &c_filter_iter, c_child_iter)
	retGo := retC == C.TRUE

	filterIter := TreeIterNewFromC(unsafe.Pointer(&c_filter_iter))

	return retGo, filterIter
}

// ConvertChildPathToPath is a wrapper around the C function gtk_tree_model_filter_convert_child_path_to_path.
func (recv *TreeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	c_child_path := (*C.GtkTreePath)(C.NULL)
	if childPath != nil {
		c_child_path = (*C.GtkTreePath)(childPath.ToC())
	}

	retC := C.gtk_tree_model_filter_convert_child_path_to_path((*C.GtkTreeModelFilter)(recv.native), c_child_path)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ConvertIterToChildIter is a wrapper around the C function gtk_tree_model_filter_convert_iter_to_child_iter.
func (recv *TreeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) *TreeIter {
	var c_child_iter C.GtkTreeIter

	c_filter_iter := (*C.GtkTreeIter)(C.NULL)
	if filterIter != nil {
		c_filter_iter = (*C.GtkTreeIter)(filterIter.ToC())
	}

	C.gtk_tree_model_filter_convert_iter_to_child_iter((*C.GtkTreeModelFilter)(recv.native), &c_child_iter, c_filter_iter)

	childIter := TreeIterNewFromC(unsafe.Pointer(&c_child_iter))

	return childIter
}

// ConvertPathToChildPath is a wrapper around the C function gtk_tree_model_filter_convert_path_to_child_path.
func (recv *TreeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
	c_filter_path := (*C.GtkTreePath)(C.NULL)
	if filterPath != nil {
		c_filter_path = (*C.GtkTreePath)(filterPath.ToC())
	}

	retC := C.gtk_tree_model_filter_convert_path_to_child_path((*C.GtkTreeModelFilter)(recv.native), c_filter_path)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetModel is a wrapper around the C function gtk_tree_model_filter_get_model.
func (recv *TreeModelFilter) GetModel() *TreeModel {
	retC := C.gtk_tree_model_filter_get_model((*C.GtkTreeModelFilter)(recv.native))
	retGo := TreeModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Refilter is a wrapper around the C function gtk_tree_model_filter_refilter.
func (recv *TreeModelFilter) Refilter() {
	C.gtk_tree_model_filter_refilter((*C.GtkTreeModelFilter)(recv.native))

	return
}

// Unsupported : gtk_tree_model_filter_set_modify_func : unsupported parameter func : no type generator for TreeModelFilterModifyFunc (GtkTreeModelFilterModifyFunc) for param func

// SetVisibleColumn is a wrapper around the C function gtk_tree_model_filter_set_visible_column.
func (recv *TreeModelFilter) SetVisibleColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_tree_model_filter_set_visible_column((*C.GtkTreeModelFilter)(recv.native), c_column)

	return
}

// Unsupported : gtk_tree_model_filter_set_visible_func : unsupported parameter func : no type generator for TreeModelFilterVisibleFunc (GtkTreeModelFilterVisibleFunc) for param func

// TreeDragSource returns the TreeDragSource interface implemented by TreeModelFilter
func (recv *TreeModelFilter) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeModelFilter
func (recv *TreeModelFilter) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeModelSort is a wrapper around the C record GtkTreeModelSort.
type TreeModelSort struct {
	native *C.GtkTreeModelSort
	// parent : record
	// Private : priv
}

func TreeModelSortNewFromC(u unsafe.Pointer) *TreeModelSort {
	c := (*C.GtkTreeModelSort)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelSort{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeModelSort) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeModelSort) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelSort with another TreeModelSort, and returns true if they represent the same GObject.
func (recv *TreeModelSort) Equals(other *TreeModelSort) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TreeModelSort) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TreeModelSort.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeModelSort.
func CastToTreeModelSort(object *gobject.Object) *TreeModelSort {
	return TreeModelSortNewFromC(object.ToC())
}

// ClearCache is a wrapper around the C function gtk_tree_model_sort_clear_cache.
func (recv *TreeModelSort) ClearCache() {
	C.gtk_tree_model_sort_clear_cache((*C.GtkTreeModelSort)(recv.native))

	return
}

// ConvertChildIterToIter is a wrapper around the C function gtk_tree_model_sort_convert_child_iter_to_iter.
func (recv *TreeModelSort) ConvertChildIterToIter(childIter *TreeIter) (bool, *TreeIter) {
	var c_sort_iter C.GtkTreeIter

	c_child_iter := (*C.GtkTreeIter)(C.NULL)
	if childIter != nil {
		c_child_iter = (*C.GtkTreeIter)(childIter.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_child_iter_to_iter((*C.GtkTreeModelSort)(recv.native), &c_sort_iter, c_child_iter)
	retGo := retC == C.TRUE

	sortIter := TreeIterNewFromC(unsafe.Pointer(&c_sort_iter))

	return retGo, sortIter
}

// ConvertChildPathToPath is a wrapper around the C function gtk_tree_model_sort_convert_child_path_to_path.
func (recv *TreeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	c_child_path := (*C.GtkTreePath)(C.NULL)
	if childPath != nil {
		c_child_path = (*C.GtkTreePath)(childPath.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_child_path_to_path((*C.GtkTreeModelSort)(recv.native), c_child_path)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ConvertIterToChildIter is a wrapper around the C function gtk_tree_model_sort_convert_iter_to_child_iter.
func (recv *TreeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) *TreeIter {
	var c_child_iter C.GtkTreeIter

	c_sorted_iter := (*C.GtkTreeIter)(C.NULL)
	if sortedIter != nil {
		c_sorted_iter = (*C.GtkTreeIter)(sortedIter.ToC())
	}

	C.gtk_tree_model_sort_convert_iter_to_child_iter((*C.GtkTreeModelSort)(recv.native), &c_child_iter, c_sorted_iter)

	childIter := TreeIterNewFromC(unsafe.Pointer(&c_child_iter))

	return childIter
}

// ConvertPathToChildPath is a wrapper around the C function gtk_tree_model_sort_convert_path_to_child_path.
func (recv *TreeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
	c_sorted_path := (*C.GtkTreePath)(C.NULL)
	if sortedPath != nil {
		c_sorted_path = (*C.GtkTreePath)(sortedPath.ToC())
	}

	retC := C.gtk_tree_model_sort_convert_path_to_child_path((*C.GtkTreeModelSort)(recv.native), c_sorted_path)
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetModel is a wrapper around the C function gtk_tree_model_sort_get_model.
func (recv *TreeModelSort) GetModel() *TreeModel {
	retC := C.gtk_tree_model_sort_get_model((*C.GtkTreeModelSort)(recv.native))
	retGo := TreeModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IterIsValid is a wrapper around the C function gtk_tree_model_sort_iter_is_valid.
func (recv *TreeModelSort) IterIsValid(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_model_sort_iter_is_valid((*C.GtkTreeModelSort)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// ResetDefaultSortFunc is a wrapper around the C function gtk_tree_model_sort_reset_default_sort_func.
func (recv *TreeModelSort) ResetDefaultSortFunc() {
	C.gtk_tree_model_sort_reset_default_sort_func((*C.GtkTreeModelSort)(recv.native))

	return
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by TreeModelSort
func (recv *TreeModelSort) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// TreeSelection is a wrapper around the C record GtkTreeSelection.
type TreeSelection struct {
	native *C.GtkTreeSelection
	// Private : parent
	// Private : priv
}

func TreeSelectionNewFromC(u unsafe.Pointer) *TreeSelection {
	c := (*C.GtkTreeSelection)(u)
	if c == nil {
		return nil
	}

	g := &TreeSelection{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeSelection) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeSelection) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeSelection with another TreeSelection, and returns true if they represent the same GObject.
func (recv *TreeSelection) Equals(other *TreeSelection) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TreeSelection) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TreeSelection.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeSelection.
func CastToTreeSelection(object *gobject.Object) *TreeSelection {
	return TreeSelectionNewFromC(object.ToC())
}

type signalTreeSelectionChangedDetail struct {
	callback  TreeSelectionSignalChangedCallback
	handlerID C.gulong
}

var signalTreeSelectionChangedId int
var signalTreeSelectionChangedMap = make(map[int]signalTreeSelectionChangedDetail)
var signalTreeSelectionChangedLock sync.RWMutex

// TreeSelectionSignalChangedCallback is a callback function for a 'changed' signal emitted from a TreeSelection.
type TreeSelectionSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the TreeSelection.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *TreeSelection) ConnectChanged(callback TreeSelectionSignalChangedCallback) int {
	signalTreeSelectionChangedLock.Lock()
	defer signalTreeSelectionChangedLock.Unlock()

	signalTreeSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeSelection_signal_connect_changed(instance, C.gpointer(uintptr(signalTreeSelectionChangedId)))

	detail := signalTreeSelectionChangedDetail{callback, handlerID}
	signalTreeSelectionChangedMap[signalTreeSelectionChangedId] = detail

	return signalTreeSelectionChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the TreeSelection.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *TreeSelection) DisconnectChanged(connectionID int) {
	signalTreeSelectionChangedLock.Lock()
	defer signalTreeSelectionChangedLock.Unlock()

	detail, exists := signalTreeSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeSelectionChangedMap, connectionID)
}

//export treeselection_changedHandler
func treeselection_changedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeSelectionChangedLock.RLock()
	defer signalTreeSelectionChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeSelectionChangedMap[index].callback
	callback()
}

// CountSelectedRows is a wrapper around the C function gtk_tree_selection_count_selected_rows.
func (recv *TreeSelection) CountSelectedRows() int32 {
	retC := C.gtk_tree_selection_count_selected_rows((*C.GtkTreeSelection)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMode is a wrapper around the C function gtk_tree_selection_get_mode.
func (recv *TreeSelection) GetMode() SelectionMode {
	retC := C.gtk_tree_selection_get_mode((*C.GtkTreeSelection)(recv.native))
	retGo := (SelectionMode)(retC)

	return retGo
}

// GetSelected is a wrapper around the C function gtk_tree_selection_get_selected.
func (recv *TreeSelection) GetSelected() (bool, *TreeModel, *TreeIter) {
	var c_model *C.GtkTreeModel

	var c_iter C.GtkTreeIter

	retC := C.gtk_tree_selection_get_selected((*C.GtkTreeSelection)(recv.native), &c_model, &c_iter)
	retGo := retC == C.TRUE

	model := TreeModelNewFromC(unsafe.Pointer(c_model))

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, model, iter
}

// GetSelectedRows is a wrapper around the C function gtk_tree_selection_get_selected_rows.
func (recv *TreeSelection) GetSelectedRows() (*glib.List, *TreeModel) {
	var c_model *C.GtkTreeModel

	retC := C.gtk_tree_selection_get_selected_rows((*C.GtkTreeSelection)(recv.native), &c_model)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	model := TreeModelNewFromC(unsafe.Pointer(c_model))

	return retGo, model
}

// GetTreeView is a wrapper around the C function gtk_tree_selection_get_tree_view.
func (recv *TreeSelection) GetTreeView() *TreeView {
	retC := C.gtk_tree_selection_get_tree_view((*C.GtkTreeSelection)(recv.native))
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetUserData is a wrapper around the C function gtk_tree_selection_get_user_data.
func (recv *TreeSelection) GetUserData() uintptr {
	retC := C.gtk_tree_selection_get_user_data((*C.GtkTreeSelection)(recv.native))
	retGo := (uintptr)(unsafe.Pointer(retC))

	return retGo
}

// IterIsSelected is a wrapper around the C function gtk_tree_selection_iter_is_selected.
func (recv *TreeSelection) IterIsSelected(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_selection_iter_is_selected((*C.GtkTreeSelection)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// PathIsSelected is a wrapper around the C function gtk_tree_selection_path_is_selected.
func (recv *TreeSelection) PathIsSelected(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_selection_path_is_selected((*C.GtkTreeSelection)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// SelectAll is a wrapper around the C function gtk_tree_selection_select_all.
func (recv *TreeSelection) SelectAll() {
	C.gtk_tree_selection_select_all((*C.GtkTreeSelection)(recv.native))

	return
}

// SelectIter is a wrapper around the C function gtk_tree_selection_select_iter.
func (recv *TreeSelection) SelectIter(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_selection_select_iter((*C.GtkTreeSelection)(recv.native), c_iter)

	return
}

// SelectPath is a wrapper around the C function gtk_tree_selection_select_path.
func (recv *TreeSelection) SelectPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_selection_select_path((*C.GtkTreeSelection)(recv.native), c_path)

	return
}

// SelectRange is a wrapper around the C function gtk_tree_selection_select_range.
func (recv *TreeSelection) SelectRange(startPath *TreePath, endPath *TreePath) {
	c_start_path := (*C.GtkTreePath)(C.NULL)
	if startPath != nil {
		c_start_path = (*C.GtkTreePath)(startPath.ToC())
	}

	c_end_path := (*C.GtkTreePath)(C.NULL)
	if endPath != nil {
		c_end_path = (*C.GtkTreePath)(endPath.ToC())
	}

	C.gtk_tree_selection_select_range((*C.GtkTreeSelection)(recv.native), c_start_path, c_end_path)

	return
}

// Unsupported : gtk_tree_selection_selected_foreach : unsupported parameter func : no type generator for TreeSelectionForeachFunc (GtkTreeSelectionForeachFunc) for param func

// SetMode is a wrapper around the C function gtk_tree_selection_set_mode.
func (recv *TreeSelection) SetMode(type_ SelectionMode) {
	c_type := (C.GtkSelectionMode)(type_)

	C.gtk_tree_selection_set_mode((*C.GtkTreeSelection)(recv.native), c_type)

	return
}

// Unsupported : gtk_tree_selection_set_select_function : unsupported parameter func : no type generator for TreeSelectionFunc (GtkTreeSelectionFunc) for param func

// UnselectAll is a wrapper around the C function gtk_tree_selection_unselect_all.
func (recv *TreeSelection) UnselectAll() {
	C.gtk_tree_selection_unselect_all((*C.GtkTreeSelection)(recv.native))

	return
}

// UnselectIter is a wrapper around the C function gtk_tree_selection_unselect_iter.
func (recv *TreeSelection) UnselectIter(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_selection_unselect_iter((*C.GtkTreeSelection)(recv.native), c_iter)

	return
}

// UnselectPath is a wrapper around the C function gtk_tree_selection_unselect_path.
func (recv *TreeSelection) UnselectPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_selection_unselect_path((*C.GtkTreeSelection)(recv.native), c_path)

	return
}

// UnselectRange is a wrapper around the C function gtk_tree_selection_unselect_range.
func (recv *TreeSelection) UnselectRange(startPath *TreePath, endPath *TreePath) {
	c_start_path := (*C.GtkTreePath)(C.NULL)
	if startPath != nil {
		c_start_path = (*C.GtkTreePath)(startPath.ToC())
	}

	c_end_path := (*C.GtkTreePath)(C.NULL)
	if endPath != nil {
		c_end_path = (*C.GtkTreePath)(endPath.ToC())
	}

	C.gtk_tree_selection_unselect_range((*C.GtkTreeSelection)(recv.native), c_start_path, c_end_path)

	return
}

// TreeStore is a wrapper around the C record GtkTreeStore.
type TreeStore struct {
	native *C.GtkTreeStore
	// parent : record
	// priv : record
}

func TreeStoreNewFromC(u unsafe.Pointer) *TreeStore {
	c := (*C.GtkTreeStore)(u)
	if c == nil {
		return nil
	}

	g := &TreeStore{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeStore) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeStore) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeStore with another TreeStore, and returns true if they represent the same GObject.
func (recv *TreeStore) Equals(other *TreeStore) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *TreeStore) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to TreeStore.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeStore.
func CastToTreeStore(object *gobject.Object) *TreeStore {
	return TreeStoreNewFromC(object.ToC())
}

// Unsupported : gtk_tree_store_new : unsupported parameter ... : varargs

// TreeStoreNewv is a wrapper around the C function gtk_tree_store_newv.
func TreeStoreNewv(types []gobject.Type) *TreeStore {
	c_n_columns := (C.gint)(len(types))

	c_types_array := make([]C.GType, len(types)+1, len(types)+1)
	for i, item := range types {
		c := (C.GType)(item)
		c_types_array[i] = c
	}
	c_types_array[len(types)] = 0
	c_types_arrayPtr := &c_types_array[0]
	c_types := (*C.GType)(unsafe.Pointer(c_types_arrayPtr))

	retC := C.gtk_tree_store_newv(c_n_columns, c_types)
	retGo := TreeStoreNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// Append is a wrapper around the C function gtk_tree_store_append.
func (recv *TreeStore) Append(parent *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	C.gtk_tree_store_append((*C.GtkTreeStore)(recv.native), &c_iter, c_parent)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Clear is a wrapper around the C function gtk_tree_store_clear.
func (recv *TreeStore) Clear() {
	C.gtk_tree_store_clear((*C.GtkTreeStore)(recv.native))

	return
}

// Insert is a wrapper around the C function gtk_tree_store_insert.
func (recv *TreeStore) Insert(parent *TreeIter, position int32) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_tree_store_insert((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_position)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// InsertAfter is a wrapper around the C function gtk_tree_store_insert_after.
func (recv *TreeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_tree_store_insert_after((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// InsertBefore is a wrapper around the C function gtk_tree_store_insert_before.
func (recv *TreeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_sibling := (*C.GtkTreeIter)(C.NULL)
	if sibling != nil {
		c_sibling = (*C.GtkTreeIter)(sibling.ToC())
	}

	C.gtk_tree_store_insert_before((*C.GtkTreeStore)(recv.native), &c_iter, c_parent, c_sibling)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Unsupported : gtk_tree_store_insert_with_values : unsupported parameter ... : varargs

// Unsupported : gtk_tree_store_insert_with_valuesv : unsupported parameter values :

// IsAncestor is a wrapper around the C function gtk_tree_store_is_ancestor.
func (recv *TreeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_descendant := (*C.GtkTreeIter)(C.NULL)
	if descendant != nil {
		c_descendant = (*C.GtkTreeIter)(descendant.ToC())
	}

	retC := C.gtk_tree_store_is_ancestor((*C.GtkTreeStore)(recv.native), c_iter, c_descendant)
	retGo := retC == C.TRUE

	return retGo
}

// IterDepth is a wrapper around the C function gtk_tree_store_iter_depth.
func (recv *TreeStore) IterDepth(iter *TreeIter) int32 {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_store_iter_depth((*C.GtkTreeStore)(recv.native), c_iter)
	retGo := (int32)(retC)

	return retGo
}

// IterIsValid is a wrapper around the C function gtk_tree_store_iter_is_valid.
func (recv *TreeStore) IterIsValid(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_store_iter_is_valid((*C.GtkTreeStore)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// MoveAfter is a wrapper around the C function gtk_tree_store_move_after.
func (recv *TreeStore) MoveAfter(iter *TreeIter, position *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_position := (*C.GtkTreeIter)(C.NULL)
	if position != nil {
		c_position = (*C.GtkTreeIter)(position.ToC())
	}

	C.gtk_tree_store_move_after((*C.GtkTreeStore)(recv.native), c_iter, c_position)

	return
}

// MoveBefore is a wrapper around the C function gtk_tree_store_move_before.
func (recv *TreeStore) MoveBefore(iter *TreeIter, position *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_position := (*C.GtkTreeIter)(C.NULL)
	if position != nil {
		c_position = (*C.GtkTreeIter)(position.ToC())
	}

	C.gtk_tree_store_move_before((*C.GtkTreeStore)(recv.native), c_iter, c_position)

	return
}

// Prepend is a wrapper around the C function gtk_tree_store_prepend.
func (recv *TreeStore) Prepend(parent *TreeIter) *TreeIter {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	C.gtk_tree_store_prepend((*C.GtkTreeStore)(recv.native), &c_iter, c_parent)

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return iter
}

// Remove is a wrapper around the C function gtk_tree_store_remove.
func (recv *TreeStore) Remove(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_store_remove((*C.GtkTreeStore)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// Reorder is a wrapper around the C function gtk_tree_store_reorder.
func (recv *TreeStore) Reorder(parent *TreeIter, newOrder []int32) {
	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_new_order_array := make([]C.gint, len(newOrder)+1, len(newOrder)+1)
	for i, item := range newOrder {
		c := (C.gint)(item)
		c_new_order_array[i] = c
	}
	c_new_order_array[len(newOrder)] = 0
	c_new_order_arrayPtr := &c_new_order_array[0]
	c_new_order := (*C.gint)(unsafe.Pointer(c_new_order_arrayPtr))

	C.gtk_tree_store_reorder((*C.GtkTreeStore)(recv.native), c_parent, c_new_order)

	return
}

// Unsupported : gtk_tree_store_set : unsupported parameter ... : varargs

// SetColumnTypes is a wrapper around the C function gtk_tree_store_set_column_types.
func (recv *TreeStore) SetColumnTypes(types []gobject.Type) {
	c_n_columns := (C.gint)(len(types))

	c_types_array := make([]C.GType, len(types)+1, len(types)+1)
	for i, item := range types {
		c := (C.GType)(item)
		c_types_array[i] = c
	}
	c_types_array[len(types)] = 0
	c_types_arrayPtr := &c_types_array[0]
	c_types := (*C.GType)(unsafe.Pointer(c_types_arrayPtr))

	C.gtk_tree_store_set_column_types((*C.GtkTreeStore)(recv.native), c_n_columns, c_types)

	return
}

// Unsupported : gtk_tree_store_set_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// SetValue is a wrapper around the C function gtk_tree_store_set_value.
func (recv *TreeStore) SetValue(iter *TreeIter, column int32, value *gobject.Value) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_column := (C.gint)(column)

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_tree_store_set_value((*C.GtkTreeStore)(recv.native), c_iter, c_column, c_value)

	return
}

// Unsupported : gtk_tree_store_set_valuesv : unsupported parameter values :

// Swap is a wrapper around the C function gtk_tree_store_swap.
func (recv *TreeStore) Swap(a *TreeIter, b *TreeIter) {
	c_a := (*C.GtkTreeIter)(C.NULL)
	if a != nil {
		c_a = (*C.GtkTreeIter)(a.ToC())
	}

	c_b := (*C.GtkTreeIter)(C.NULL)
	if b != nil {
		c_b = (*C.GtkTreeIter)(b.ToC())
	}

	C.gtk_tree_store_swap((*C.GtkTreeStore)(recv.native), c_a, c_b)

	return
}

// Buildable returns the Buildable interface implemented by TreeStore
func (recv *TreeStore) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// TreeDragDest returns the TreeDragDest interface implemented by TreeStore
func (recv *TreeStore) TreeDragDest() *TreeDragDest {
	return TreeDragDestNewFromC(recv.ToC())
}

// TreeDragSource returns the TreeDragSource interface implemented by TreeStore
func (recv *TreeStore) TreeDragSource() *TreeDragSource {
	return TreeDragSourceNewFromC(recv.ToC())
}

// TreeModel returns the TreeModel interface implemented by TreeStore
func (recv *TreeStore) TreeModel() *TreeModel {
	return TreeModelNewFromC(recv.ToC())
}

// TreeSortable returns the TreeSortable interface implemented by TreeStore
func (recv *TreeStore) TreeSortable() *TreeSortable {
	return TreeSortableNewFromC(recv.ToC())
}

// TreeView is a wrapper around the C record GtkTreeView.
type TreeView struct {
	native *C.GtkTreeView
	// parent : record
	// Private : priv
}

func TreeViewNewFromC(u unsafe.Pointer) *TreeView {
	c := (*C.GtkTreeView)(u)
	if c == nil {
		return nil
	}

	g := &TreeView{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeView) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeView) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeView with another TreeView, and returns true if they represent the same GObject.
func (recv *TreeView) Equals(other *TreeView) bool {
	return other.ToC() == recv.ToC()
}

// Container upcasts to *Container
func (recv *TreeView) Container() *Container {
	return ContainerNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *TreeView) Widget() *Widget {
	return recv.Container().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TreeView) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Container().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *TreeView) Object() *gobject.Object {
	return recv.Container().Object()
}

// CastToWidget down casts any arbitrary Object to TreeView.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeView.
func CastToTreeView(object *gobject.Object) *TreeView {
	return TreeViewNewFromC(object.ToC())
}

type signalTreeViewColumnsChangedDetail struct {
	callback  TreeViewSignalColumnsChangedCallback
	handlerID C.gulong
}

var signalTreeViewColumnsChangedId int
var signalTreeViewColumnsChangedMap = make(map[int]signalTreeViewColumnsChangedDetail)
var signalTreeViewColumnsChangedLock sync.RWMutex

// TreeViewSignalColumnsChangedCallback is a callback function for a 'columns-changed' signal emitted from a TreeView.
type TreeViewSignalColumnsChangedCallback func()

/*
ConnectColumnsChanged connects the callback to the 'columns-changed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectColumnsChanged to remove it.
*/
func (recv *TreeView) ConnectColumnsChanged(callback TreeViewSignalColumnsChangedCallback) int {
	signalTreeViewColumnsChangedLock.Lock()
	defer signalTreeViewColumnsChangedLock.Unlock()

	signalTreeViewColumnsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_columns_changed(instance, C.gpointer(uintptr(signalTreeViewColumnsChangedId)))

	detail := signalTreeViewColumnsChangedDetail{callback, handlerID}
	signalTreeViewColumnsChangedMap[signalTreeViewColumnsChangedId] = detail

	return signalTreeViewColumnsChangedId
}

/*
DisconnectColumnsChanged disconnects a callback from the 'columns-changed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectColumnsChanged.
*/
func (recv *TreeView) DisconnectColumnsChanged(connectionID int) {
	signalTreeViewColumnsChangedLock.Lock()
	defer signalTreeViewColumnsChangedLock.Unlock()

	detail, exists := signalTreeViewColumnsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewColumnsChangedMap, connectionID)
}

//export treeview_columnsChangedHandler
func treeview_columnsChangedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeViewColumnsChangedLock.RLock()
	defer signalTreeViewColumnsChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewColumnsChangedMap[index].callback
	callback()
}

type signalTreeViewCursorChangedDetail struct {
	callback  TreeViewSignalCursorChangedCallback
	handlerID C.gulong
}

var signalTreeViewCursorChangedId int
var signalTreeViewCursorChangedMap = make(map[int]signalTreeViewCursorChangedDetail)
var signalTreeViewCursorChangedLock sync.RWMutex

// TreeViewSignalCursorChangedCallback is a callback function for a 'cursor-changed' signal emitted from a TreeView.
type TreeViewSignalCursorChangedCallback func()

/*
ConnectCursorChanged connects the callback to the 'cursor-changed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectCursorChanged to remove it.
*/
func (recv *TreeView) ConnectCursorChanged(callback TreeViewSignalCursorChangedCallback) int {
	signalTreeViewCursorChangedLock.Lock()
	defer signalTreeViewCursorChangedLock.Unlock()

	signalTreeViewCursorChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_cursor_changed(instance, C.gpointer(uintptr(signalTreeViewCursorChangedId)))

	detail := signalTreeViewCursorChangedDetail{callback, handlerID}
	signalTreeViewCursorChangedMap[signalTreeViewCursorChangedId] = detail

	return signalTreeViewCursorChangedId
}

/*
DisconnectCursorChanged disconnects a callback from the 'cursor-changed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectCursorChanged.
*/
func (recv *TreeView) DisconnectCursorChanged(connectionID int) {
	signalTreeViewCursorChangedLock.Lock()
	defer signalTreeViewCursorChangedLock.Unlock()

	detail, exists := signalTreeViewCursorChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewCursorChangedMap, connectionID)
}

//export treeview_cursorChangedHandler
func treeview_cursorChangedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeViewCursorChangedLock.RLock()
	defer signalTreeViewCursorChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewCursorChangedMap[index].callback
	callback()
}

type signalTreeViewExpandCollapseCursorRowDetail struct {
	callback  TreeViewSignalExpandCollapseCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewExpandCollapseCursorRowId int
var signalTreeViewExpandCollapseCursorRowMap = make(map[int]signalTreeViewExpandCollapseCursorRowDetail)
var signalTreeViewExpandCollapseCursorRowLock sync.RWMutex

// TreeViewSignalExpandCollapseCursorRowCallback is a callback function for a 'expand-collapse-cursor-row' signal emitted from a TreeView.
type TreeViewSignalExpandCollapseCursorRowCallback func(object bool, p0 bool, p1 bool) bool

/*
ConnectExpandCollapseCursorRow connects the callback to the 'expand-collapse-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectExpandCollapseCursorRow to remove it.
*/
func (recv *TreeView) ConnectExpandCollapseCursorRow(callback TreeViewSignalExpandCollapseCursorRowCallback) int {
	signalTreeViewExpandCollapseCursorRowLock.Lock()
	defer signalTreeViewExpandCollapseCursorRowLock.Unlock()

	signalTreeViewExpandCollapseCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_expand_collapse_cursor_row(instance, C.gpointer(uintptr(signalTreeViewExpandCollapseCursorRowId)))

	detail := signalTreeViewExpandCollapseCursorRowDetail{callback, handlerID}
	signalTreeViewExpandCollapseCursorRowMap[signalTreeViewExpandCollapseCursorRowId] = detail

	return signalTreeViewExpandCollapseCursorRowId
}

/*
DisconnectExpandCollapseCursorRow disconnects a callback from the 'expand-collapse-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectExpandCollapseCursorRow.
*/
func (recv *TreeView) DisconnectExpandCollapseCursorRow(connectionID int) {
	signalTreeViewExpandCollapseCursorRowLock.Lock()
	defer signalTreeViewExpandCollapseCursorRowLock.Unlock()

	detail, exists := signalTreeViewExpandCollapseCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewExpandCollapseCursorRowMap, connectionID)
}

//export treeview_expandCollapseCursorRowHandler
func treeview_expandCollapseCursorRowHandler(_ *C.GObject, c_object C.gboolean, c_p0 C.gboolean, c_p1 C.gboolean, data C.gpointer) C.gboolean {
	signalTreeViewExpandCollapseCursorRowLock.RLock()
	defer signalTreeViewExpandCollapseCursorRowLock.RUnlock()

	object := c_object == C.TRUE

	p0 := c_p0 == C.TRUE

	p1 := c_p1 == C.TRUE

	index := int(uintptr(data))
	callback := signalTreeViewExpandCollapseCursorRowMap[index].callback
	retGo := callback(object, p0, p1)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewMoveCursorDetail struct {
	callback  TreeViewSignalMoveCursorCallback
	handlerID C.gulong
}

var signalTreeViewMoveCursorId int
var signalTreeViewMoveCursorMap = make(map[int]signalTreeViewMoveCursorDetail)
var signalTreeViewMoveCursorLock sync.RWMutex

// TreeViewSignalMoveCursorCallback is a callback function for a 'move-cursor' signal emitted from a TreeView.
type TreeViewSignalMoveCursorCallback func(step MovementStep, direction int32) bool

/*
ConnectMoveCursor connects the callback to the 'move-cursor' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectMoveCursor to remove it.
*/
func (recv *TreeView) ConnectMoveCursor(callback TreeViewSignalMoveCursorCallback) int {
	signalTreeViewMoveCursorLock.Lock()
	defer signalTreeViewMoveCursorLock.Unlock()

	signalTreeViewMoveCursorId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_move_cursor(instance, C.gpointer(uintptr(signalTreeViewMoveCursorId)))

	detail := signalTreeViewMoveCursorDetail{callback, handlerID}
	signalTreeViewMoveCursorMap[signalTreeViewMoveCursorId] = detail

	return signalTreeViewMoveCursorId
}

/*
DisconnectMoveCursor disconnects a callback from the 'move-cursor' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectMoveCursor.
*/
func (recv *TreeView) DisconnectMoveCursor(connectionID int) {
	signalTreeViewMoveCursorLock.Lock()
	defer signalTreeViewMoveCursorLock.Unlock()

	detail, exists := signalTreeViewMoveCursorMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewMoveCursorMap, connectionID)
}

//export treeview_moveCursorHandler
func treeview_moveCursorHandler(_ *C.GObject, c_step C.GtkMovementStep, c_direction C.gint, data C.gpointer) C.gboolean {
	signalTreeViewMoveCursorLock.RLock()
	defer signalTreeViewMoveCursorLock.RUnlock()

	step := MovementStep(c_step)

	direction := int32(c_direction)

	index := int(uintptr(data))
	callback := signalTreeViewMoveCursorMap[index].callback
	retGo := callback(step, direction)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewRowActivatedDetail struct {
	callback  TreeViewSignalRowActivatedCallback
	handlerID C.gulong
}

var signalTreeViewRowActivatedId int
var signalTreeViewRowActivatedMap = make(map[int]signalTreeViewRowActivatedDetail)
var signalTreeViewRowActivatedLock sync.RWMutex

// TreeViewSignalRowActivatedCallback is a callback function for a 'row-activated' signal emitted from a TreeView.
type TreeViewSignalRowActivatedCallback func(path *TreePath, column *TreeViewColumn)

/*
ConnectRowActivated connects the callback to the 'row-activated' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowActivated to remove it.
*/
func (recv *TreeView) ConnectRowActivated(callback TreeViewSignalRowActivatedCallback) int {
	signalTreeViewRowActivatedLock.Lock()
	defer signalTreeViewRowActivatedLock.Unlock()

	signalTreeViewRowActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_activated(instance, C.gpointer(uintptr(signalTreeViewRowActivatedId)))

	detail := signalTreeViewRowActivatedDetail{callback, handlerID}
	signalTreeViewRowActivatedMap[signalTreeViewRowActivatedId] = detail

	return signalTreeViewRowActivatedId
}

/*
DisconnectRowActivated disconnects a callback from the 'row-activated' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowActivated.
*/
func (recv *TreeView) DisconnectRowActivated(connectionID int) {
	signalTreeViewRowActivatedLock.Lock()
	defer signalTreeViewRowActivatedLock.Unlock()

	detail, exists := signalTreeViewRowActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowActivatedMap, connectionID)
}

//export treeview_rowActivatedHandler
func treeview_rowActivatedHandler(_ *C.GObject, c_path *C.GtkTreePath, c_column *C.GtkTreeViewColumn, data C.gpointer) {
	signalTreeViewRowActivatedLock.RLock()
	defer signalTreeViewRowActivatedLock.RUnlock()

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	column := TreeViewColumnNewFromC(unsafe.Pointer(c_column))

	index := int(uintptr(data))
	callback := signalTreeViewRowActivatedMap[index].callback
	callback(path, column)
}

type signalTreeViewRowCollapsedDetail struct {
	callback  TreeViewSignalRowCollapsedCallback
	handlerID C.gulong
}

var signalTreeViewRowCollapsedId int
var signalTreeViewRowCollapsedMap = make(map[int]signalTreeViewRowCollapsedDetail)
var signalTreeViewRowCollapsedLock sync.RWMutex

// TreeViewSignalRowCollapsedCallback is a callback function for a 'row-collapsed' signal emitted from a TreeView.
type TreeViewSignalRowCollapsedCallback func(iter *TreeIter, path *TreePath)

/*
ConnectRowCollapsed connects the callback to the 'row-collapsed' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowCollapsed to remove it.
*/
func (recv *TreeView) ConnectRowCollapsed(callback TreeViewSignalRowCollapsedCallback) int {
	signalTreeViewRowCollapsedLock.Lock()
	defer signalTreeViewRowCollapsedLock.Unlock()

	signalTreeViewRowCollapsedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_collapsed(instance, C.gpointer(uintptr(signalTreeViewRowCollapsedId)))

	detail := signalTreeViewRowCollapsedDetail{callback, handlerID}
	signalTreeViewRowCollapsedMap[signalTreeViewRowCollapsedId] = detail

	return signalTreeViewRowCollapsedId
}

/*
DisconnectRowCollapsed disconnects a callback from the 'row-collapsed' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowCollapsed.
*/
func (recv *TreeView) DisconnectRowCollapsed(connectionID int) {
	signalTreeViewRowCollapsedLock.Lock()
	defer signalTreeViewRowCollapsedLock.Unlock()

	detail, exists := signalTreeViewRowCollapsedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowCollapsedMap, connectionID)
}

//export treeview_rowCollapsedHandler
func treeview_rowCollapsedHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) {
	signalTreeViewRowCollapsedLock.RLock()
	defer signalTreeViewRowCollapsedLock.RUnlock()

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewRowCollapsedMap[index].callback
	callback(iter, path)
}

type signalTreeViewRowExpandedDetail struct {
	callback  TreeViewSignalRowExpandedCallback
	handlerID C.gulong
}

var signalTreeViewRowExpandedId int
var signalTreeViewRowExpandedMap = make(map[int]signalTreeViewRowExpandedDetail)
var signalTreeViewRowExpandedLock sync.RWMutex

// TreeViewSignalRowExpandedCallback is a callback function for a 'row-expanded' signal emitted from a TreeView.
type TreeViewSignalRowExpandedCallback func(iter *TreeIter, path *TreePath)

/*
ConnectRowExpanded connects the callback to the 'row-expanded' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectRowExpanded to remove it.
*/
func (recv *TreeView) ConnectRowExpanded(callback TreeViewSignalRowExpandedCallback) int {
	signalTreeViewRowExpandedLock.Lock()
	defer signalTreeViewRowExpandedLock.Unlock()

	signalTreeViewRowExpandedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_row_expanded(instance, C.gpointer(uintptr(signalTreeViewRowExpandedId)))

	detail := signalTreeViewRowExpandedDetail{callback, handlerID}
	signalTreeViewRowExpandedMap[signalTreeViewRowExpandedId] = detail

	return signalTreeViewRowExpandedId
}

/*
DisconnectRowExpanded disconnects a callback from the 'row-expanded' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectRowExpanded.
*/
func (recv *TreeView) DisconnectRowExpanded(connectionID int) {
	signalTreeViewRowExpandedLock.Lock()
	defer signalTreeViewRowExpandedLock.Unlock()

	detail, exists := signalTreeViewRowExpandedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewRowExpandedMap, connectionID)
}

//export treeview_rowExpandedHandler
func treeview_rowExpandedHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) {
	signalTreeViewRowExpandedLock.RLock()
	defer signalTreeViewRowExpandedLock.RUnlock()

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewRowExpandedMap[index].callback
	callback(iter, path)
}

type signalTreeViewSelectAllDetail struct {
	callback  TreeViewSignalSelectAllCallback
	handlerID C.gulong
}

var signalTreeViewSelectAllId int
var signalTreeViewSelectAllMap = make(map[int]signalTreeViewSelectAllDetail)
var signalTreeViewSelectAllLock sync.RWMutex

// TreeViewSignalSelectAllCallback is a callback function for a 'select-all' signal emitted from a TreeView.
type TreeViewSignalSelectAllCallback func() bool

/*
ConnectSelectAll connects the callback to the 'select-all' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectAll to remove it.
*/
func (recv *TreeView) ConnectSelectAll(callback TreeViewSignalSelectAllCallback) int {
	signalTreeViewSelectAllLock.Lock()
	defer signalTreeViewSelectAllLock.Unlock()

	signalTreeViewSelectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_all(instance, C.gpointer(uintptr(signalTreeViewSelectAllId)))

	detail := signalTreeViewSelectAllDetail{callback, handlerID}
	signalTreeViewSelectAllMap[signalTreeViewSelectAllId] = detail

	return signalTreeViewSelectAllId
}

/*
DisconnectSelectAll disconnects a callback from the 'select-all' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectAll.
*/
func (recv *TreeView) DisconnectSelectAll(connectionID int) {
	signalTreeViewSelectAllLock.Lock()
	defer signalTreeViewSelectAllLock.Unlock()

	detail, exists := signalTreeViewSelectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectAllMap, connectionID)
}

//export treeview_selectAllHandler
func treeview_selectAllHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewSelectAllLock.RLock()
	defer signalTreeViewSelectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewSelectAllMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewSelectCursorParentDetail struct {
	callback  TreeViewSignalSelectCursorParentCallback
	handlerID C.gulong
}

var signalTreeViewSelectCursorParentId int
var signalTreeViewSelectCursorParentMap = make(map[int]signalTreeViewSelectCursorParentDetail)
var signalTreeViewSelectCursorParentLock sync.RWMutex

// TreeViewSignalSelectCursorParentCallback is a callback function for a 'select-cursor-parent' signal emitted from a TreeView.
type TreeViewSignalSelectCursorParentCallback func() bool

/*
ConnectSelectCursorParent connects the callback to the 'select-cursor-parent' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorParent to remove it.
*/
func (recv *TreeView) ConnectSelectCursorParent(callback TreeViewSignalSelectCursorParentCallback) int {
	signalTreeViewSelectCursorParentLock.Lock()
	defer signalTreeViewSelectCursorParentLock.Unlock()

	signalTreeViewSelectCursorParentId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_cursor_parent(instance, C.gpointer(uintptr(signalTreeViewSelectCursorParentId)))

	detail := signalTreeViewSelectCursorParentDetail{callback, handlerID}
	signalTreeViewSelectCursorParentMap[signalTreeViewSelectCursorParentId] = detail

	return signalTreeViewSelectCursorParentId
}

/*
DisconnectSelectCursorParent disconnects a callback from the 'select-cursor-parent' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectCursorParent.
*/
func (recv *TreeView) DisconnectSelectCursorParent(connectionID int) {
	signalTreeViewSelectCursorParentLock.Lock()
	defer signalTreeViewSelectCursorParentLock.Unlock()

	detail, exists := signalTreeViewSelectCursorParentMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectCursorParentMap, connectionID)
}

//export treeview_selectCursorParentHandler
func treeview_selectCursorParentHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewSelectCursorParentLock.RLock()
	defer signalTreeViewSelectCursorParentLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewSelectCursorParentMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewSelectCursorRowDetail struct {
	callback  TreeViewSignalSelectCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewSelectCursorRowId int
var signalTreeViewSelectCursorRowMap = make(map[int]signalTreeViewSelectCursorRowDetail)
var signalTreeViewSelectCursorRowLock sync.RWMutex

// TreeViewSignalSelectCursorRowCallback is a callback function for a 'select-cursor-row' signal emitted from a TreeView.
type TreeViewSignalSelectCursorRowCallback func(object bool) bool

/*
ConnectSelectCursorRow connects the callback to the 'select-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectSelectCursorRow to remove it.
*/
func (recv *TreeView) ConnectSelectCursorRow(callback TreeViewSignalSelectCursorRowCallback) int {
	signalTreeViewSelectCursorRowLock.Lock()
	defer signalTreeViewSelectCursorRowLock.Unlock()

	signalTreeViewSelectCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_select_cursor_row(instance, C.gpointer(uintptr(signalTreeViewSelectCursorRowId)))

	detail := signalTreeViewSelectCursorRowDetail{callback, handlerID}
	signalTreeViewSelectCursorRowMap[signalTreeViewSelectCursorRowId] = detail

	return signalTreeViewSelectCursorRowId
}

/*
DisconnectSelectCursorRow disconnects a callback from the 'select-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectSelectCursorRow.
*/
func (recv *TreeView) DisconnectSelectCursorRow(connectionID int) {
	signalTreeViewSelectCursorRowLock.Lock()
	defer signalTreeViewSelectCursorRowLock.Unlock()

	detail, exists := signalTreeViewSelectCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewSelectCursorRowMap, connectionID)
}

//export treeview_selectCursorRowHandler
func treeview_selectCursorRowHandler(_ *C.GObject, c_object C.gboolean, data C.gpointer) C.gboolean {
	signalTreeViewSelectCursorRowLock.RLock()
	defer signalTreeViewSelectCursorRowLock.RUnlock()

	object := c_object == C.TRUE

	index := int(uintptr(data))
	callback := signalTreeViewSelectCursorRowMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewStartInteractiveSearchDetail struct {
	callback  TreeViewSignalStartInteractiveSearchCallback
	handlerID C.gulong
}

var signalTreeViewStartInteractiveSearchId int
var signalTreeViewStartInteractiveSearchMap = make(map[int]signalTreeViewStartInteractiveSearchDetail)
var signalTreeViewStartInteractiveSearchLock sync.RWMutex

// TreeViewSignalStartInteractiveSearchCallback is a callback function for a 'start-interactive-search' signal emitted from a TreeView.
type TreeViewSignalStartInteractiveSearchCallback func() bool

/*
ConnectStartInteractiveSearch connects the callback to the 'start-interactive-search' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectStartInteractiveSearch to remove it.
*/
func (recv *TreeView) ConnectStartInteractiveSearch(callback TreeViewSignalStartInteractiveSearchCallback) int {
	signalTreeViewStartInteractiveSearchLock.Lock()
	defer signalTreeViewStartInteractiveSearchLock.Unlock()

	signalTreeViewStartInteractiveSearchId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_start_interactive_search(instance, C.gpointer(uintptr(signalTreeViewStartInteractiveSearchId)))

	detail := signalTreeViewStartInteractiveSearchDetail{callback, handlerID}
	signalTreeViewStartInteractiveSearchMap[signalTreeViewStartInteractiveSearchId] = detail

	return signalTreeViewStartInteractiveSearchId
}

/*
DisconnectStartInteractiveSearch disconnects a callback from the 'start-interactive-search' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectStartInteractiveSearch.
*/
func (recv *TreeView) DisconnectStartInteractiveSearch(connectionID int) {
	signalTreeViewStartInteractiveSearchLock.Lock()
	defer signalTreeViewStartInteractiveSearchLock.Unlock()

	detail, exists := signalTreeViewStartInteractiveSearchMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewStartInteractiveSearchMap, connectionID)
}

//export treeview_startInteractiveSearchHandler
func treeview_startInteractiveSearchHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewStartInteractiveSearchLock.RLock()
	defer signalTreeViewStartInteractiveSearchLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewStartInteractiveSearchMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewTestCollapseRowDetail struct {
	callback  TreeViewSignalTestCollapseRowCallback
	handlerID C.gulong
}

var signalTreeViewTestCollapseRowId int
var signalTreeViewTestCollapseRowMap = make(map[int]signalTreeViewTestCollapseRowDetail)
var signalTreeViewTestCollapseRowLock sync.RWMutex

// TreeViewSignalTestCollapseRowCallback is a callback function for a 'test-collapse-row' signal emitted from a TreeView.
type TreeViewSignalTestCollapseRowCallback func(iter *TreeIter, path *TreePath) bool

/*
ConnectTestCollapseRow connects the callback to the 'test-collapse-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectTestCollapseRow to remove it.
*/
func (recv *TreeView) ConnectTestCollapseRow(callback TreeViewSignalTestCollapseRowCallback) int {
	signalTreeViewTestCollapseRowLock.Lock()
	defer signalTreeViewTestCollapseRowLock.Unlock()

	signalTreeViewTestCollapseRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_test_collapse_row(instance, C.gpointer(uintptr(signalTreeViewTestCollapseRowId)))

	detail := signalTreeViewTestCollapseRowDetail{callback, handlerID}
	signalTreeViewTestCollapseRowMap[signalTreeViewTestCollapseRowId] = detail

	return signalTreeViewTestCollapseRowId
}

/*
DisconnectTestCollapseRow disconnects a callback from the 'test-collapse-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectTestCollapseRow.
*/
func (recv *TreeView) DisconnectTestCollapseRow(connectionID int) {
	signalTreeViewTestCollapseRowLock.Lock()
	defer signalTreeViewTestCollapseRowLock.Unlock()

	detail, exists := signalTreeViewTestCollapseRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewTestCollapseRowMap, connectionID)
}

//export treeview_testCollapseRowHandler
func treeview_testCollapseRowHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) C.gboolean {
	signalTreeViewTestCollapseRowLock.RLock()
	defer signalTreeViewTestCollapseRowLock.RUnlock()

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewTestCollapseRowMap[index].callback
	retGo := callback(iter, path)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewTestExpandRowDetail struct {
	callback  TreeViewSignalTestExpandRowCallback
	handlerID C.gulong
}

var signalTreeViewTestExpandRowId int
var signalTreeViewTestExpandRowMap = make(map[int]signalTreeViewTestExpandRowDetail)
var signalTreeViewTestExpandRowLock sync.RWMutex

// TreeViewSignalTestExpandRowCallback is a callback function for a 'test-expand-row' signal emitted from a TreeView.
type TreeViewSignalTestExpandRowCallback func(iter *TreeIter, path *TreePath) bool

/*
ConnectTestExpandRow connects the callback to the 'test-expand-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectTestExpandRow to remove it.
*/
func (recv *TreeView) ConnectTestExpandRow(callback TreeViewSignalTestExpandRowCallback) int {
	signalTreeViewTestExpandRowLock.Lock()
	defer signalTreeViewTestExpandRowLock.Unlock()

	signalTreeViewTestExpandRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_test_expand_row(instance, C.gpointer(uintptr(signalTreeViewTestExpandRowId)))

	detail := signalTreeViewTestExpandRowDetail{callback, handlerID}
	signalTreeViewTestExpandRowMap[signalTreeViewTestExpandRowId] = detail

	return signalTreeViewTestExpandRowId
}

/*
DisconnectTestExpandRow disconnects a callback from the 'test-expand-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectTestExpandRow.
*/
func (recv *TreeView) DisconnectTestExpandRow(connectionID int) {
	signalTreeViewTestExpandRowLock.Lock()
	defer signalTreeViewTestExpandRowLock.Unlock()

	detail, exists := signalTreeViewTestExpandRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewTestExpandRowMap, connectionID)
}

//export treeview_testExpandRowHandler
func treeview_testExpandRowHandler(_ *C.GObject, c_iter *C.GtkTreeIter, c_path *C.GtkTreePath, data C.gpointer) C.gboolean {
	signalTreeViewTestExpandRowLock.RLock()
	defer signalTreeViewTestExpandRowLock.RUnlock()

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeViewTestExpandRowMap[index].callback
	retGo := callback(iter, path)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewToggleCursorRowDetail struct {
	callback  TreeViewSignalToggleCursorRowCallback
	handlerID C.gulong
}

var signalTreeViewToggleCursorRowId int
var signalTreeViewToggleCursorRowMap = make(map[int]signalTreeViewToggleCursorRowDetail)
var signalTreeViewToggleCursorRowLock sync.RWMutex

// TreeViewSignalToggleCursorRowCallback is a callback function for a 'toggle-cursor-row' signal emitted from a TreeView.
type TreeViewSignalToggleCursorRowCallback func() bool

/*
ConnectToggleCursorRow connects the callback to the 'toggle-cursor-row' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectToggleCursorRow to remove it.
*/
func (recv *TreeView) ConnectToggleCursorRow(callback TreeViewSignalToggleCursorRowCallback) int {
	signalTreeViewToggleCursorRowLock.Lock()
	defer signalTreeViewToggleCursorRowLock.Unlock()

	signalTreeViewToggleCursorRowId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_toggle_cursor_row(instance, C.gpointer(uintptr(signalTreeViewToggleCursorRowId)))

	detail := signalTreeViewToggleCursorRowDetail{callback, handlerID}
	signalTreeViewToggleCursorRowMap[signalTreeViewToggleCursorRowId] = detail

	return signalTreeViewToggleCursorRowId
}

/*
DisconnectToggleCursorRow disconnects a callback from the 'toggle-cursor-row' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectToggleCursorRow.
*/
func (recv *TreeView) DisconnectToggleCursorRow(connectionID int) {
	signalTreeViewToggleCursorRowLock.Lock()
	defer signalTreeViewToggleCursorRowLock.Unlock()

	detail, exists := signalTreeViewToggleCursorRowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewToggleCursorRowMap, connectionID)
}

//export treeview_toggleCursorRowHandler
func treeview_toggleCursorRowHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewToggleCursorRowLock.RLock()
	defer signalTreeViewToggleCursorRowLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewToggleCursorRowMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalTreeViewUnselectAllDetail struct {
	callback  TreeViewSignalUnselectAllCallback
	handlerID C.gulong
}

var signalTreeViewUnselectAllId int
var signalTreeViewUnselectAllMap = make(map[int]signalTreeViewUnselectAllDetail)
var signalTreeViewUnselectAllLock sync.RWMutex

// TreeViewSignalUnselectAllCallback is a callback function for a 'unselect-all' signal emitted from a TreeView.
type TreeViewSignalUnselectAllCallback func() bool

/*
ConnectUnselectAll connects the callback to the 'unselect-all' signal for the TreeView.

The returned value represents the connection, and may be passed to DisconnectUnselectAll to remove it.
*/
func (recv *TreeView) ConnectUnselectAll(callback TreeViewSignalUnselectAllCallback) int {
	signalTreeViewUnselectAllLock.Lock()
	defer signalTreeViewUnselectAllLock.Unlock()

	signalTreeViewUnselectAllId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeView_signal_connect_unselect_all(instance, C.gpointer(uintptr(signalTreeViewUnselectAllId)))

	detail := signalTreeViewUnselectAllDetail{callback, handlerID}
	signalTreeViewUnselectAllMap[signalTreeViewUnselectAllId] = detail

	return signalTreeViewUnselectAllId
}

/*
DisconnectUnselectAll disconnects a callback from the 'unselect-all' signal for the TreeView.

The connectionID should be a value returned from a call to ConnectUnselectAll.
*/
func (recv *TreeView) DisconnectUnselectAll(connectionID int) {
	signalTreeViewUnselectAllLock.Lock()
	defer signalTreeViewUnselectAllLock.Unlock()

	detail, exists := signalTreeViewUnselectAllMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewUnselectAllMap, connectionID)
}

//export treeview_unselectAllHandler
func treeview_unselectAllHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalTreeViewUnselectAllLock.RLock()
	defer signalTreeViewUnselectAllLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewUnselectAllMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

// TreeViewNew is a wrapper around the C function gtk_tree_view_new.
func TreeViewNew() *TreeView {
	retC := C.gtk_tree_view_new()
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TreeViewNewWithModel is a wrapper around the C function gtk_tree_view_new_with_model.
func TreeViewNewWithModel(model *TreeModel) *TreeView {
	c_model := (*C.GtkTreeModel)(model.ToC())

	retC := C.gtk_tree_view_new_with_model(c_model)
	retGo := TreeViewNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppendColumn is a wrapper around the C function gtk_tree_view_append_column.
func (recv *TreeView) AppendColumn(column *TreeViewColumn) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	retC := C.gtk_tree_view_append_column((*C.GtkTreeView)(recv.native), c_column)
	retGo := (int32)(retC)

	return retGo
}

// CollapseAll is a wrapper around the C function gtk_tree_view_collapse_all.
func (recv *TreeView) CollapseAll() {
	C.gtk_tree_view_collapse_all((*C.GtkTreeView)(recv.native))

	return
}

// CollapseRow is a wrapper around the C function gtk_tree_view_collapse_row.
func (recv *TreeView) CollapseRow(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_collapse_row((*C.GtkTreeView)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// ColumnsAutosize is a wrapper around the C function gtk_tree_view_columns_autosize.
func (recv *TreeView) ColumnsAutosize() {
	C.gtk_tree_view_columns_autosize((*C.GtkTreeView)(recv.native))

	return
}

// ConvertBinWindowToTreeCoords is a wrapper around the C function gtk_tree_view_convert_bin_window_to_tree_coords.
func (recv *TreeView) ConvertBinWindowToTreeCoords(bx int32, by int32) (int32, int32) {
	c_bx := (C.gint)(bx)

	c_by := (C.gint)(by)

	var c_tx C.gint

	var c_ty C.gint

	C.gtk_tree_view_convert_bin_window_to_tree_coords((*C.GtkTreeView)(recv.native), c_bx, c_by, &c_tx, &c_ty)

	tx := (int32)(c_tx)

	ty := (int32)(c_ty)

	return tx, ty
}

// ConvertBinWindowToWidgetCoords is a wrapper around the C function gtk_tree_view_convert_bin_window_to_widget_coords.
func (recv *TreeView) ConvertBinWindowToWidgetCoords(bx int32, by int32) (int32, int32) {
	c_bx := (C.gint)(bx)

	c_by := (C.gint)(by)

	var c_wx C.gint

	var c_wy C.gint

	C.gtk_tree_view_convert_bin_window_to_widget_coords((*C.GtkTreeView)(recv.native), c_bx, c_by, &c_wx, &c_wy)

	wx := (int32)(c_wx)

	wy := (int32)(c_wy)

	return wx, wy
}

// ConvertTreeToBinWindowCoords is a wrapper around the C function gtk_tree_view_convert_tree_to_bin_window_coords.
func (recv *TreeView) ConvertTreeToBinWindowCoords(tx int32, ty int32) (int32, int32) {
	c_tx := (C.gint)(tx)

	c_ty := (C.gint)(ty)

	var c_bx C.gint

	var c_by C.gint

	C.gtk_tree_view_convert_tree_to_bin_window_coords((*C.GtkTreeView)(recv.native), c_tx, c_ty, &c_bx, &c_by)

	bx := (int32)(c_bx)

	by := (int32)(c_by)

	return bx, by
}

// ConvertTreeToWidgetCoords is a wrapper around the C function gtk_tree_view_convert_tree_to_widget_coords.
func (recv *TreeView) ConvertTreeToWidgetCoords(tx int32, ty int32) (int32, int32) {
	c_tx := (C.gint)(tx)

	c_ty := (C.gint)(ty)

	var c_wx C.gint

	var c_wy C.gint

	C.gtk_tree_view_convert_tree_to_widget_coords((*C.GtkTreeView)(recv.native), c_tx, c_ty, &c_wx, &c_wy)

	wx := (int32)(c_wx)

	wy := (int32)(c_wy)

	return wx, wy
}

// ConvertWidgetToBinWindowCoords is a wrapper around the C function gtk_tree_view_convert_widget_to_bin_window_coords.
func (recv *TreeView) ConvertWidgetToBinWindowCoords(wx int32, wy int32) (int32, int32) {
	c_wx := (C.gint)(wx)

	c_wy := (C.gint)(wy)

	var c_bx C.gint

	var c_by C.gint

	C.gtk_tree_view_convert_widget_to_bin_window_coords((*C.GtkTreeView)(recv.native), c_wx, c_wy, &c_bx, &c_by)

	bx := (int32)(c_bx)

	by := (int32)(c_by)

	return bx, by
}

// ConvertWidgetToTreeCoords is a wrapper around the C function gtk_tree_view_convert_widget_to_tree_coords.
func (recv *TreeView) ConvertWidgetToTreeCoords(wx int32, wy int32) (int32, int32) {
	c_wx := (C.gint)(wx)

	c_wy := (C.gint)(wy)

	var c_tx C.gint

	var c_ty C.gint

	C.gtk_tree_view_convert_widget_to_tree_coords((*C.GtkTreeView)(recv.native), c_wx, c_wy, &c_tx, &c_ty)

	tx := (int32)(c_tx)

	ty := (int32)(c_ty)

	return tx, ty
}

// CreateRowDragIcon is a wrapper around the C function gtk_tree_view_create_row_drag_icon.
func (recv *TreeView) CreateRowDragIcon(path *TreePath) *cairo.Surface {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_create_row_drag_icon((*C.GtkTreeView)(recv.native), c_path)
	retGo := cairo.SurfaceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_enable_model_drag_dest : unsupported parameter targets :

// Unsupported : gtk_tree_view_enable_model_drag_source : unsupported parameter targets :

// ExpandAll is a wrapper around the C function gtk_tree_view_expand_all.
func (recv *TreeView) ExpandAll() {
	C.gtk_tree_view_expand_all((*C.GtkTreeView)(recv.native))

	return
}

// ExpandRow is a wrapper around the C function gtk_tree_view_expand_row.
func (recv *TreeView) ExpandRow(path *TreePath, openAll bool) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_open_all :=
		boolToGboolean(openAll)

	retC := C.gtk_tree_view_expand_row((*C.GtkTreeView)(recv.native), c_path, c_open_all)
	retGo := retC == C.TRUE

	return retGo
}

// ExpandToPath is a wrapper around the C function gtk_tree_view_expand_to_path.
func (recv *TreeView) ExpandToPath(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_view_expand_to_path((*C.GtkTreeView)(recv.native), c_path)

	return
}

// GetBackgroundArea is a wrapper around the C function gtk_tree_view_get_background_area.
func (recv *TreeView) GetBackgroundArea(path *TreePath, column *TreeViewColumn) *gdk.Rectangle {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	var c_rect C.GdkRectangle

	C.gtk_tree_view_get_background_area((*C.GtkTreeView)(recv.native), c_path, c_column, &c_rect)

	rect := gdk.RectangleNewFromC(unsafe.Pointer(&c_rect))

	return rect
}

// GetBinWindow is a wrapper around the C function gtk_tree_view_get_bin_window.
func (recv *TreeView) GetBinWindow() *gdk.Window {
	retC := C.gtk_tree_view_get_bin_window((*C.GtkTreeView)(recv.native))
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetCellArea is a wrapper around the C function gtk_tree_view_get_cell_area.
func (recv *TreeView) GetCellArea(path *TreePath, column *TreeViewColumn) *gdk.Rectangle {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	var c_rect C.GdkRectangle

	C.gtk_tree_view_get_cell_area((*C.GtkTreeView)(recv.native), c_path, c_column, &c_rect)

	rect := gdk.RectangleNewFromC(unsafe.Pointer(&c_rect))

	return rect
}

// GetColumn is a wrapper around the C function gtk_tree_view_get_column.
func (recv *TreeView) GetColumn(n int32) *TreeViewColumn {
	c_n := (C.gint)(n)

	retC := C.gtk_tree_view_get_column((*C.GtkTreeView)(recv.native), c_n)
	var retGo (*TreeViewColumn)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreeViewColumnNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetColumns is a wrapper around the C function gtk_tree_view_get_columns.
func (recv *TreeView) GetColumns() *glib.List {
	retC := C.gtk_tree_view_get_columns((*C.GtkTreeView)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCursor is a wrapper around the C function gtk_tree_view_get_cursor.
func (recv *TreeView) GetCursor() (*TreePath, *TreeViewColumn) {
	var c_path *C.GtkTreePath

	var c_focus_column *C.GtkTreeViewColumn

	C.gtk_tree_view_get_cursor((*C.GtkTreeView)(recv.native), &c_path, &c_focus_column)

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	focusColumn := TreeViewColumnNewFromC(unsafe.Pointer(c_focus_column))

	return path, focusColumn
}

// GetDestRowAtPos is a wrapper around the C function gtk_tree_view_get_dest_row_at_pos.
func (recv *TreeView) GetDestRowAtPos(dragX int32, dragY int32) (bool, *TreePath, TreeViewDropPosition) {
	c_drag_x := (C.gint)(dragX)

	c_drag_y := (C.gint)(dragY)

	var c_path *C.GtkTreePath

	var c_pos C.GtkTreeViewDropPosition

	retC := C.gtk_tree_view_get_dest_row_at_pos((*C.GtkTreeView)(recv.native), c_drag_x, c_drag_y, &c_path, &c_pos)
	retGo := retC == C.TRUE

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	pos := (TreeViewDropPosition)(c_pos)

	return retGo, path, pos
}

// GetDragDestRow is a wrapper around the C function gtk_tree_view_get_drag_dest_row.
func (recv *TreeView) GetDragDestRow() (*TreePath, TreeViewDropPosition) {
	var c_path *C.GtkTreePath

	var c_pos C.GtkTreeViewDropPosition

	C.gtk_tree_view_get_drag_dest_row((*C.GtkTreeView)(recv.native), &c_path, &c_pos)

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	pos := (TreeViewDropPosition)(c_pos)

	return path, pos
}

// GetEnableSearch is a wrapper around the C function gtk_tree_view_get_enable_search.
func (recv *TreeView) GetEnableSearch() bool {
	retC := C.gtk_tree_view_get_enable_search((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetEnableTreeLines is a wrapper around the C function gtk_tree_view_get_enable_tree_lines.
func (recv *TreeView) GetEnableTreeLines() bool {
	retC := C.gtk_tree_view_get_enable_tree_lines((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetExpanderColumn is a wrapper around the C function gtk_tree_view_get_expander_column.
func (recv *TreeView) GetExpanderColumn() *TreeViewColumn {
	retC := C.gtk_tree_view_get_expander_column((*C.GtkTreeView)(recv.native))
	retGo := TreeViewColumnNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFixedHeightMode is a wrapper around the C function gtk_tree_view_get_fixed_height_mode.
func (recv *TreeView) GetFixedHeightMode() bool {
	retC := C.gtk_tree_view_get_fixed_height_mode((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetGridLines is a wrapper around the C function gtk_tree_view_get_grid_lines.
func (recv *TreeView) GetGridLines() TreeViewGridLines {
	retC := C.gtk_tree_view_get_grid_lines((*C.GtkTreeView)(recv.native))
	retGo := (TreeViewGridLines)(retC)

	return retGo
}

// GetHadjustment is a wrapper around the C function gtk_tree_view_get_hadjustment.
func (recv *TreeView) GetHadjustment() *Adjustment {
	retC := C.gtk_tree_view_get_hadjustment((*C.GtkTreeView)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetHeadersClickable is a wrapper around the C function gtk_tree_view_get_headers_clickable.
func (recv *TreeView) GetHeadersClickable() bool {
	retC := C.gtk_tree_view_get_headers_clickable((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetHeadersVisible is a wrapper around the C function gtk_tree_view_get_headers_visible.
func (recv *TreeView) GetHeadersVisible() bool {
	retC := C.gtk_tree_view_get_headers_visible((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetHoverExpand is a wrapper around the C function gtk_tree_view_get_hover_expand.
func (recv *TreeView) GetHoverExpand() bool {
	retC := C.gtk_tree_view_get_hover_expand((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetHoverSelection is a wrapper around the C function gtk_tree_view_get_hover_selection.
func (recv *TreeView) GetHoverSelection() bool {
	retC := C.gtk_tree_view_get_hover_selection((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetLevelIndentation is a wrapper around the C function gtk_tree_view_get_level_indentation.
func (recv *TreeView) GetLevelIndentation() int32 {
	retC := C.gtk_tree_view_get_level_indentation((*C.GtkTreeView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetModel is a wrapper around the C function gtk_tree_view_get_model.
func (recv *TreeView) GetModel() *TreeModel {
	retC := C.gtk_tree_view_get_model((*C.GtkTreeView)(recv.native))
	var retGo (*TreeModel)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreeModelNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPathAtPos is a wrapper around the C function gtk_tree_view_get_path_at_pos.
func (recv *TreeView) GetPathAtPos(x int32, y int32) (bool, *TreePath, *TreeViewColumn, int32, int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	var c_path *C.GtkTreePath

	var c_column *C.GtkTreeViewColumn

	var c_cell_x C.gint

	var c_cell_y C.gint

	retC := C.gtk_tree_view_get_path_at_pos((*C.GtkTreeView)(recv.native), c_x, c_y, &c_path, &c_column, &c_cell_x, &c_cell_y)
	retGo := retC == C.TRUE

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	column := TreeViewColumnNewFromC(unsafe.Pointer(c_column))

	cellX := (int32)(c_cell_x)

	cellY := (int32)(c_cell_y)

	return retGo, path, column, cellX, cellY
}

// GetReorderable is a wrapper around the C function gtk_tree_view_get_reorderable.
func (recv *TreeView) GetReorderable() bool {
	retC := C.gtk_tree_view_get_reorderable((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_tree_view_get_row_separator_func : no return generator

// GetRubberBanding is a wrapper around the C function gtk_tree_view_get_rubber_banding.
func (recv *TreeView) GetRubberBanding() bool {
	retC := C.gtk_tree_view_get_rubber_banding((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetRulesHint is a wrapper around the C function gtk_tree_view_get_rules_hint.
func (recv *TreeView) GetRulesHint() bool {
	retC := C.gtk_tree_view_get_rules_hint((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSearchColumn is a wrapper around the C function gtk_tree_view_get_search_column.
func (recv *TreeView) GetSearchColumn() int32 {
	retC := C.gtk_tree_view_get_search_column((*C.GtkTreeView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetSearchEntry is a wrapper around the C function gtk_tree_view_get_search_entry.
func (recv *TreeView) GetSearchEntry() *Entry {
	retC := C.gtk_tree_view_get_search_entry((*C.GtkTreeView)(recv.native))
	retGo := EntryNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_get_search_equal_func : no return generator

// Unsupported : gtk_tree_view_get_search_position_func : no return generator

// GetSelection is a wrapper around the C function gtk_tree_view_get_selection.
func (recv *TreeView) GetSelection() *TreeSelection {
	retC := C.gtk_tree_view_get_selection((*C.GtkTreeView)(recv.native))
	retGo := TreeSelectionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetShowExpanders is a wrapper around the C function gtk_tree_view_get_show_expanders.
func (recv *TreeView) GetShowExpanders() bool {
	retC := C.gtk_tree_view_get_show_expanders((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTooltipColumn is a wrapper around the C function gtk_tree_view_get_tooltip_column.
func (recv *TreeView) GetTooltipColumn() int32 {
	retC := C.gtk_tree_view_get_tooltip_column((*C.GtkTreeView)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetTooltipContext is a wrapper around the C function gtk_tree_view_get_tooltip_context.
func (recv *TreeView) GetTooltipContext(x int32, y int32, keyboardTip bool) (bool, *TreeModel, *TreePath, *TreeIter) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_keyboard_tip :=
		boolToGboolean(keyboardTip)

	var c_model *C.GtkTreeModel

	var c_path *C.GtkTreePath

	var c_iter C.GtkTreeIter

	retC := C.gtk_tree_view_get_tooltip_context((*C.GtkTreeView)(recv.native), &c_x, &c_y, c_keyboard_tip, &c_model, &c_path, &c_iter)
	retGo := retC == C.TRUE

	model := TreeModelNewFromC(unsafe.Pointer(c_model))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, model, path, iter
}

// GetVadjustment is a wrapper around the C function gtk_tree_view_get_vadjustment.
func (recv *TreeView) GetVadjustment() *Adjustment {
	retC := C.gtk_tree_view_get_vadjustment((*C.GtkTreeView)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetVisibleRange is a wrapper around the C function gtk_tree_view_get_visible_range.
func (recv *TreeView) GetVisibleRange() (bool, *TreePath, *TreePath) {
	var c_start_path *C.GtkTreePath

	var c_end_path *C.GtkTreePath

	retC := C.gtk_tree_view_get_visible_range((*C.GtkTreeView)(recv.native), &c_start_path, &c_end_path)
	retGo := retC == C.TRUE

	startPath := TreePathNewFromC(unsafe.Pointer(c_start_path))

	endPath := TreePathNewFromC(unsafe.Pointer(c_end_path))

	return retGo, startPath, endPath
}

// GetVisibleRect is a wrapper around the C function gtk_tree_view_get_visible_rect.
func (recv *TreeView) GetVisibleRect() *gdk.Rectangle {
	var c_visible_rect C.GdkRectangle

	C.gtk_tree_view_get_visible_rect((*C.GtkTreeView)(recv.native), &c_visible_rect)

	visibleRect := gdk.RectangleNewFromC(unsafe.Pointer(&c_visible_rect))

	return visibleRect
}

// InsertColumn is a wrapper around the C function gtk_tree_view_insert_column.
func (recv *TreeView) InsertColumn(column *TreeViewColumn, position int32) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_position := (C.gint)(position)

	retC := C.gtk_tree_view_insert_column((*C.GtkTreeView)(recv.native), c_column, c_position)
	retGo := (int32)(retC)

	return retGo
}

// Unsupported : gtk_tree_view_insert_column_with_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_tree_view_insert_column_with_data_func : unsupported parameter func : no type generator for TreeCellDataFunc (GtkTreeCellDataFunc) for param func

// IsRubberBandingActive is a wrapper around the C function gtk_tree_view_is_rubber_banding_active.
func (recv *TreeView) IsRubberBandingActive() bool {
	retC := C.gtk_tree_view_is_rubber_banding_active((*C.GtkTreeView)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_tree_view_map_expanded_rows : unsupported parameter func : no type generator for TreeViewMappingFunc (GtkTreeViewMappingFunc) for param func

// MoveColumnAfter is a wrapper around the C function gtk_tree_view_move_column_after.
func (recv *TreeView) MoveColumnAfter(column *TreeViewColumn, baseColumn *TreeViewColumn) {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_base_column := (*C.GtkTreeViewColumn)(C.NULL)
	if baseColumn != nil {
		c_base_column = (*C.GtkTreeViewColumn)(baseColumn.ToC())
	}

	C.gtk_tree_view_move_column_after((*C.GtkTreeView)(recv.native), c_column, c_base_column)

	return
}

// RemoveColumn is a wrapper around the C function gtk_tree_view_remove_column.
func (recv *TreeView) RemoveColumn(column *TreeViewColumn) int32 {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	retC := C.gtk_tree_view_remove_column((*C.GtkTreeView)(recv.native), c_column)
	retGo := (int32)(retC)

	return retGo
}

// RowActivated is a wrapper around the C function gtk_tree_view_row_activated.
func (recv *TreeView) RowActivated(path *TreePath, column *TreeViewColumn) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	C.gtk_tree_view_row_activated((*C.GtkTreeView)(recv.native), c_path, c_column)

	return
}

// RowExpanded is a wrapper around the C function gtk_tree_view_row_expanded.
func (recv *TreeView) RowExpanded(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_view_row_expanded((*C.GtkTreeView)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// ScrollToCell is a wrapper around the C function gtk_tree_view_scroll_to_cell.
func (recv *TreeView) ScrollToCell(path *TreePath, column *TreeViewColumn, useAlign bool, rowAlign float32, colAlign float32) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_use_align :=
		boolToGboolean(useAlign)

	c_row_align := (C.gfloat)(rowAlign)

	c_col_align := (C.gfloat)(colAlign)

	C.gtk_tree_view_scroll_to_cell((*C.GtkTreeView)(recv.native), c_path, c_column, c_use_align, c_row_align, c_col_align)

	return
}

// ScrollToPoint is a wrapper around the C function gtk_tree_view_scroll_to_point.
func (recv *TreeView) ScrollToPoint(treeX int32, treeY int32) {
	c_tree_x := (C.gint)(treeX)

	c_tree_y := (C.gint)(treeY)

	C.gtk_tree_view_scroll_to_point((*C.GtkTreeView)(recv.native), c_tree_x, c_tree_y)

	return
}

// Unsupported : gtk_tree_view_set_column_drag_function : unsupported parameter func : no type generator for TreeViewColumnDropFunc (GtkTreeViewColumnDropFunc) for param func

// SetCursor is a wrapper around the C function gtk_tree_view_set_cursor.
func (recv *TreeView) SetCursor(path *TreePath, focusColumn *TreeViewColumn, startEditing bool) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_focus_column := (*C.GtkTreeViewColumn)(C.NULL)
	if focusColumn != nil {
		c_focus_column = (*C.GtkTreeViewColumn)(focusColumn.ToC())
	}

	c_start_editing :=
		boolToGboolean(startEditing)

	C.gtk_tree_view_set_cursor((*C.GtkTreeView)(recv.native), c_path, c_focus_column, c_start_editing)

	return
}

// SetCursorOnCell is a wrapper around the C function gtk_tree_view_set_cursor_on_cell.
func (recv *TreeView) SetCursorOnCell(path *TreePath, focusColumn *TreeViewColumn, focusCell *CellRenderer, startEditing bool) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_focus_column := (*C.GtkTreeViewColumn)(C.NULL)
	if focusColumn != nil {
		c_focus_column = (*C.GtkTreeViewColumn)(focusColumn.ToC())
	}

	c_focus_cell := (*C.GtkCellRenderer)(C.NULL)
	if focusCell != nil {
		c_focus_cell = (*C.GtkCellRenderer)(focusCell.ToC())
	}

	c_start_editing :=
		boolToGboolean(startEditing)

	C.gtk_tree_view_set_cursor_on_cell((*C.GtkTreeView)(recv.native), c_path, c_focus_column, c_focus_cell, c_start_editing)

	return
}

// Unsupported : gtk_tree_view_set_destroy_count_func : unsupported parameter func : no type generator for TreeDestroyCountFunc (GtkTreeDestroyCountFunc) for param func

// SetDragDestRow is a wrapper around the C function gtk_tree_view_set_drag_dest_row.
func (recv *TreeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_pos := (C.GtkTreeViewDropPosition)(pos)

	C.gtk_tree_view_set_drag_dest_row((*C.GtkTreeView)(recv.native), c_path, c_pos)

	return
}

// SetEnableSearch is a wrapper around the C function gtk_tree_view_set_enable_search.
func (recv *TreeView) SetEnableSearch(enableSearch bool) {
	c_enable_search :=
		boolToGboolean(enableSearch)

	C.gtk_tree_view_set_enable_search((*C.GtkTreeView)(recv.native), c_enable_search)

	return
}

// SetEnableTreeLines is a wrapper around the C function gtk_tree_view_set_enable_tree_lines.
func (recv *TreeView) SetEnableTreeLines(enabled bool) {
	c_enabled :=
		boolToGboolean(enabled)

	C.gtk_tree_view_set_enable_tree_lines((*C.GtkTreeView)(recv.native), c_enabled)

	return
}

// SetExpanderColumn is a wrapper around the C function gtk_tree_view_set_expander_column.
func (recv *TreeView) SetExpanderColumn(column *TreeViewColumn) {
	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	C.gtk_tree_view_set_expander_column((*C.GtkTreeView)(recv.native), c_column)

	return
}

// SetFixedHeightMode is a wrapper around the C function gtk_tree_view_set_fixed_height_mode.
func (recv *TreeView) SetFixedHeightMode(enable bool) {
	c_enable :=
		boolToGboolean(enable)

	C.gtk_tree_view_set_fixed_height_mode((*C.GtkTreeView)(recv.native), c_enable)

	return
}

// SetGridLines is a wrapper around the C function gtk_tree_view_set_grid_lines.
func (recv *TreeView) SetGridLines(gridLines TreeViewGridLines) {
	c_grid_lines := (C.GtkTreeViewGridLines)(gridLines)

	C.gtk_tree_view_set_grid_lines((*C.GtkTreeView)(recv.native), c_grid_lines)

	return
}

// SetHadjustment is a wrapper around the C function gtk_tree_view_set_hadjustment.
func (recv *TreeView) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_tree_view_set_hadjustment((*C.GtkTreeView)(recv.native), c_adjustment)

	return
}

// SetHeadersClickable is a wrapper around the C function gtk_tree_view_set_headers_clickable.
func (recv *TreeView) SetHeadersClickable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_set_headers_clickable((*C.GtkTreeView)(recv.native), c_setting)

	return
}

// SetHeadersVisible is a wrapper around the C function gtk_tree_view_set_headers_visible.
func (recv *TreeView) SetHeadersVisible(headersVisible bool) {
	c_headers_visible :=
		boolToGboolean(headersVisible)

	C.gtk_tree_view_set_headers_visible((*C.GtkTreeView)(recv.native), c_headers_visible)

	return
}

// SetHoverExpand is a wrapper around the C function gtk_tree_view_set_hover_expand.
func (recv *TreeView) SetHoverExpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_tree_view_set_hover_expand((*C.GtkTreeView)(recv.native), c_expand)

	return
}

// SetHoverSelection is a wrapper around the C function gtk_tree_view_set_hover_selection.
func (recv *TreeView) SetHoverSelection(hover bool) {
	c_hover :=
		boolToGboolean(hover)

	C.gtk_tree_view_set_hover_selection((*C.GtkTreeView)(recv.native), c_hover)

	return
}

// SetLevelIndentation is a wrapper around the C function gtk_tree_view_set_level_indentation.
func (recv *TreeView) SetLevelIndentation(indentation int32) {
	c_indentation := (C.gint)(indentation)

	C.gtk_tree_view_set_level_indentation((*C.GtkTreeView)(recv.native), c_indentation)

	return
}

// SetModel is a wrapper around the C function gtk_tree_view_set_model.
func (recv *TreeView) SetModel(model *TreeModel) {
	c_model := (*C.GtkTreeModel)(model.ToC())

	C.gtk_tree_view_set_model((*C.GtkTreeView)(recv.native), c_model)

	return
}

// SetReorderable is a wrapper around the C function gtk_tree_view_set_reorderable.
func (recv *TreeView) SetReorderable(reorderable bool) {
	c_reorderable :=
		boolToGboolean(reorderable)

	C.gtk_tree_view_set_reorderable((*C.GtkTreeView)(recv.native), c_reorderable)

	return
}

// Unsupported : gtk_tree_view_set_row_separator_func : unsupported parameter func : no type generator for TreeViewRowSeparatorFunc (GtkTreeViewRowSeparatorFunc) for param func

// SetRubberBanding is a wrapper around the C function gtk_tree_view_set_rubber_banding.
func (recv *TreeView) SetRubberBanding(enable bool) {
	c_enable :=
		boolToGboolean(enable)

	C.gtk_tree_view_set_rubber_banding((*C.GtkTreeView)(recv.native), c_enable)

	return
}

// SetRulesHint is a wrapper around the C function gtk_tree_view_set_rules_hint.
func (recv *TreeView) SetRulesHint(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_set_rules_hint((*C.GtkTreeView)(recv.native), c_setting)

	return
}

// SetSearchColumn is a wrapper around the C function gtk_tree_view_set_search_column.
func (recv *TreeView) SetSearchColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_tree_view_set_search_column((*C.GtkTreeView)(recv.native), c_column)

	return
}

// SetSearchEntry is a wrapper around the C function gtk_tree_view_set_search_entry.
func (recv *TreeView) SetSearchEntry(entry *Entry) {
	c_entry := (*C.GtkEntry)(C.NULL)
	if entry != nil {
		c_entry = (*C.GtkEntry)(entry.ToC())
	}

	C.gtk_tree_view_set_search_entry((*C.GtkTreeView)(recv.native), c_entry)

	return
}

// Unsupported : gtk_tree_view_set_search_equal_func : unsupported parameter search_equal_func : no type generator for TreeViewSearchEqualFunc (GtkTreeViewSearchEqualFunc) for param search_equal_func

// Unsupported : gtk_tree_view_set_search_position_func : unsupported parameter func : no type generator for TreeViewSearchPositionFunc (GtkTreeViewSearchPositionFunc) for param func

// SetShowExpanders is a wrapper around the C function gtk_tree_view_set_show_expanders.
func (recv *TreeView) SetShowExpanders(enabled bool) {
	c_enabled :=
		boolToGboolean(enabled)

	C.gtk_tree_view_set_show_expanders((*C.GtkTreeView)(recv.native), c_enabled)

	return
}

// SetTooltipCell is a wrapper around the C function gtk_tree_view_set_tooltip_cell.
func (recv *TreeView) SetTooltipCell(tooltip *Tooltip, path *TreePath, column *TreeViewColumn, cell *CellRenderer) {
	c_tooltip := (*C.GtkTooltip)(C.NULL)
	if tooltip != nil {
		c_tooltip = (*C.GtkTooltip)(tooltip.ToC())
	}

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_column := (*C.GtkTreeViewColumn)(C.NULL)
	if column != nil {
		c_column = (*C.GtkTreeViewColumn)(column.ToC())
	}

	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	C.gtk_tree_view_set_tooltip_cell((*C.GtkTreeView)(recv.native), c_tooltip, c_path, c_column, c_cell)

	return
}

// SetTooltipColumn is a wrapper around the C function gtk_tree_view_set_tooltip_column.
func (recv *TreeView) SetTooltipColumn(column int32) {
	c_column := (C.gint)(column)

	C.gtk_tree_view_set_tooltip_column((*C.GtkTreeView)(recv.native), c_column)

	return
}

// SetTooltipRow is a wrapper around the C function gtk_tree_view_set_tooltip_row.
func (recv *TreeView) SetTooltipRow(tooltip *Tooltip, path *TreePath) {
	c_tooltip := (*C.GtkTooltip)(C.NULL)
	if tooltip != nil {
		c_tooltip = (*C.GtkTooltip)(tooltip.ToC())
	}

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_view_set_tooltip_row((*C.GtkTreeView)(recv.native), c_tooltip, c_path)

	return
}

// SetVadjustment is a wrapper around the C function gtk_tree_view_set_vadjustment.
func (recv *TreeView) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_tree_view_set_vadjustment((*C.GtkTreeView)(recv.native), c_adjustment)

	return
}

// UnsetRowsDragDest is a wrapper around the C function gtk_tree_view_unset_rows_drag_dest.
func (recv *TreeView) UnsetRowsDragDest() {
	C.gtk_tree_view_unset_rows_drag_dest((*C.GtkTreeView)(recv.native))

	return
}

// UnsetRowsDragSource is a wrapper around the C function gtk_tree_view_unset_rows_drag_source.
func (recv *TreeView) UnsetRowsDragSource() {
	C.gtk_tree_view_unset_rows_drag_source((*C.GtkTreeView)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by TreeView
func (recv *TreeView) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by TreeView
func (recv *TreeView) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by TreeView
func (recv *TreeView) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// TreeViewAccessible is a wrapper around the C record GtkTreeViewAccessible.
type TreeViewAccessible struct {
	native *C.GtkTreeViewAccessible
	// parent : record
	// priv : record
}

func TreeViewAccessibleNewFromC(u unsafe.Pointer) *TreeViewAccessible {
	c := (*C.GtkTreeViewAccessible)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeViewAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeViewAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewAccessible with another TreeViewAccessible, and returns true if they represent the same GObject.
func (recv *TreeViewAccessible) Equals(other *TreeViewAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *TreeViewAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *TreeViewAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *TreeViewAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *TreeViewAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to TreeViewAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeViewAccessible.
func CastToTreeViewAccessible(object *gobject.Object) *TreeViewAccessible {
	return TreeViewAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Selection returns the Selection interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Selection() *atk.Selection {
	return atk.SelectionNewFromC(recv.ToC())
}

// Table returns the Table interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) Table() *atk.Table {
	return atk.TableNewFromC(recv.ToC())
}

// CellAccessibleParent returns the CellAccessibleParent interface implemented by TreeViewAccessible
func (recv *TreeViewAccessible) CellAccessibleParent() *CellAccessibleParent {
	return CellAccessibleParentNewFromC(recv.ToC())
}

// TreeViewColumn is a wrapper around the C record GtkTreeViewColumn.
type TreeViewColumn struct {
	native *C.GtkTreeViewColumn
	// parent_instance : record
	// priv : record
}

func TreeViewColumnNewFromC(u unsafe.Pointer) *TreeViewColumn {
	c := (*C.GtkTreeViewColumn)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewColumn{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *TreeViewColumn) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *TreeViewColumn) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewColumn with another TreeViewColumn, and returns true if they represent the same GObject.
func (recv *TreeViewColumn) Equals(other *TreeViewColumn) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *TreeViewColumn) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *TreeViewColumn) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to TreeViewColumn.
// Exercise care, as this is a potentially dangerous function if the Object is not a TreeViewColumn.
func CastToTreeViewColumn(object *gobject.Object) *TreeViewColumn {
	return TreeViewColumnNewFromC(object.ToC())
}

type signalTreeViewColumnClickedDetail struct {
	callback  TreeViewColumnSignalClickedCallback
	handlerID C.gulong
}

var signalTreeViewColumnClickedId int
var signalTreeViewColumnClickedMap = make(map[int]signalTreeViewColumnClickedDetail)
var signalTreeViewColumnClickedLock sync.RWMutex

// TreeViewColumnSignalClickedCallback is a callback function for a 'clicked' signal emitted from a TreeViewColumn.
type TreeViewColumnSignalClickedCallback func()

/*
ConnectClicked connects the callback to the 'clicked' signal for the TreeViewColumn.

The returned value represents the connection, and may be passed to DisconnectClicked to remove it.
*/
func (recv *TreeViewColumn) ConnectClicked(callback TreeViewColumnSignalClickedCallback) int {
	signalTreeViewColumnClickedLock.Lock()
	defer signalTreeViewColumnClickedLock.Unlock()

	signalTreeViewColumnClickedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeViewColumn_signal_connect_clicked(instance, C.gpointer(uintptr(signalTreeViewColumnClickedId)))

	detail := signalTreeViewColumnClickedDetail{callback, handlerID}
	signalTreeViewColumnClickedMap[signalTreeViewColumnClickedId] = detail

	return signalTreeViewColumnClickedId
}

/*
DisconnectClicked disconnects a callback from the 'clicked' signal for the TreeViewColumn.

The connectionID should be a value returned from a call to ConnectClicked.
*/
func (recv *TreeViewColumn) DisconnectClicked(connectionID int) {
	signalTreeViewColumnClickedLock.Lock()
	defer signalTreeViewColumnClickedLock.Unlock()

	detail, exists := signalTreeViewColumnClickedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeViewColumnClickedMap, connectionID)
}

//export treeviewcolumn_clickedHandler
func treeviewcolumn_clickedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeViewColumnClickedLock.RLock()
	defer signalTreeViewColumnClickedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeViewColumnClickedMap[index].callback
	callback()
}

// TreeViewColumnNew is a wrapper around the C function gtk_tree_view_column_new.
func TreeViewColumnNew() *TreeViewColumn {
	retC := C.gtk_tree_view_column_new()
	retGo := TreeViewColumnNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_view_column_new_with_attributes : unsupported parameter ... : varargs

// AddAttribute is a wrapper around the C function gtk_tree_view_column_add_attribute.
func (recv *TreeViewColumn) AddAttribute(cellRenderer *CellRenderer, attribute string, column int32) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_column := (C.gint)(column)

	C.gtk_tree_view_column_add_attribute((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer, c_attribute, c_column)

	return
}

// CellGetPosition is a wrapper around the C function gtk_tree_view_column_cell_get_position.
func (recv *TreeViewColumn) CellGetPosition(cellRenderer *CellRenderer) (bool, int32, int32) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	var c_x_offset C.gint

	var c_width C.gint

	retC := C.gtk_tree_view_column_cell_get_position((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer, &c_x_offset, &c_width)
	retGo := retC == C.TRUE

	xOffset := (int32)(c_x_offset)

	width := (int32)(c_width)

	return retGo, xOffset, width
}

// CellGetSize is a wrapper around the C function gtk_tree_view_column_cell_get_size.
func (recv *TreeViewColumn) CellGetSize(cellArea *gdk.Rectangle) (int32, int32, int32, int32) {
	c_cell_area := (*C.GdkRectangle)(C.NULL)
	if cellArea != nil {
		c_cell_area = (*C.GdkRectangle)(cellArea.ToC())
	}

	var c_x_offset C.gint

	var c_y_offset C.gint

	var c_width C.gint

	var c_height C.gint

	C.gtk_tree_view_column_cell_get_size((*C.GtkTreeViewColumn)(recv.native), c_cell_area, &c_x_offset, &c_y_offset, &c_width, &c_height)

	xOffset := (int32)(c_x_offset)

	yOffset := (int32)(c_y_offset)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return xOffset, yOffset, width, height
}

// CellIsVisible is a wrapper around the C function gtk_tree_view_column_cell_is_visible.
func (recv *TreeViewColumn) CellIsVisible() bool {
	retC := C.gtk_tree_view_column_cell_is_visible((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// CellSetCellData is a wrapper around the C function gtk_tree_view_column_cell_set_cell_data.
func (recv *TreeViewColumn) CellSetCellData(treeModel *TreeModel, iter *TreeIter, isExpander bool, isExpanded bool) {
	c_tree_model := (*C.GtkTreeModel)(treeModel.ToC())

	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_is_expander :=
		boolToGboolean(isExpander)

	c_is_expanded :=
		boolToGboolean(isExpanded)

	C.gtk_tree_view_column_cell_set_cell_data((*C.GtkTreeViewColumn)(recv.native), c_tree_model, c_iter, c_is_expander, c_is_expanded)

	return
}

// Clear is a wrapper around the C function gtk_tree_view_column_clear.
func (recv *TreeViewColumn) Clear() {
	C.gtk_tree_view_column_clear((*C.GtkTreeViewColumn)(recv.native))

	return
}

// ClearAttributes is a wrapper around the C function gtk_tree_view_column_clear_attributes.
func (recv *TreeViewColumn) ClearAttributes(cellRenderer *CellRenderer) {
	c_cell_renderer := (*C.GtkCellRenderer)(C.NULL)
	if cellRenderer != nil {
		c_cell_renderer = (*C.GtkCellRenderer)(cellRenderer.ToC())
	}

	C.gtk_tree_view_column_clear_attributes((*C.GtkTreeViewColumn)(recv.native), c_cell_renderer)

	return
}

// Clicked is a wrapper around the C function gtk_tree_view_column_clicked.
func (recv *TreeViewColumn) Clicked() {
	C.gtk_tree_view_column_clicked((*C.GtkTreeViewColumn)(recv.native))

	return
}

// FocusCell is a wrapper around the C function gtk_tree_view_column_focus_cell.
func (recv *TreeViewColumn) FocusCell(cell *CellRenderer) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	C.gtk_tree_view_column_focus_cell((*C.GtkTreeViewColumn)(recv.native), c_cell)

	return
}

// GetAlignment is a wrapper around the C function gtk_tree_view_column_get_alignment.
func (recv *TreeViewColumn) GetAlignment() float32 {
	retC := C.gtk_tree_view_column_get_alignment((*C.GtkTreeViewColumn)(recv.native))
	retGo := (float32)(retC)

	return retGo
}

// GetClickable is a wrapper around the C function gtk_tree_view_column_get_clickable.
func (recv *TreeViewColumn) GetClickable() bool {
	retC := C.gtk_tree_view_column_get_clickable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetExpand is a wrapper around the C function gtk_tree_view_column_get_expand.
func (recv *TreeViewColumn) GetExpand() bool {
	retC := C.gtk_tree_view_column_get_expand((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetFixedWidth is a wrapper around the C function gtk_tree_view_column_get_fixed_width.
func (recv *TreeViewColumn) GetFixedWidth() int32 {
	retC := C.gtk_tree_view_column_get_fixed_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMaxWidth is a wrapper around the C function gtk_tree_view_column_get_max_width.
func (recv *TreeViewColumn) GetMaxWidth() int32 {
	retC := C.gtk_tree_view_column_get_max_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMinWidth is a wrapper around the C function gtk_tree_view_column_get_min_width.
func (recv *TreeViewColumn) GetMinWidth() int32 {
	retC := C.gtk_tree_view_column_get_min_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetReorderable is a wrapper around the C function gtk_tree_view_column_get_reorderable.
func (recv *TreeViewColumn) GetReorderable() bool {
	retC := C.gtk_tree_view_column_get_reorderable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetResizable is a wrapper around the C function gtk_tree_view_column_get_resizable.
func (recv *TreeViewColumn) GetResizable() bool {
	retC := C.gtk_tree_view_column_get_resizable((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSizing is a wrapper around the C function gtk_tree_view_column_get_sizing.
func (recv *TreeViewColumn) GetSizing() TreeViewColumnSizing {
	retC := C.gtk_tree_view_column_get_sizing((*C.GtkTreeViewColumn)(recv.native))
	retGo := (TreeViewColumnSizing)(retC)

	return retGo
}

// GetSortColumnId is a wrapper around the C function gtk_tree_view_column_get_sort_column_id.
func (recv *TreeViewColumn) GetSortColumnId() int32 {
	retC := C.gtk_tree_view_column_get_sort_column_id((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetSortIndicator is a wrapper around the C function gtk_tree_view_column_get_sort_indicator.
func (recv *TreeViewColumn) GetSortIndicator() bool {
	retC := C.gtk_tree_view_column_get_sort_indicator((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSortOrder is a wrapper around the C function gtk_tree_view_column_get_sort_order.
func (recv *TreeViewColumn) GetSortOrder() SortType {
	retC := C.gtk_tree_view_column_get_sort_order((*C.GtkTreeViewColumn)(recv.native))
	retGo := (SortType)(retC)

	return retGo
}

// GetSpacing is a wrapper around the C function gtk_tree_view_column_get_spacing.
func (recv *TreeViewColumn) GetSpacing() int32 {
	retC := C.gtk_tree_view_column_get_spacing((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetTitle is a wrapper around the C function gtk_tree_view_column_get_title.
func (recv *TreeViewColumn) GetTitle() string {
	retC := C.gtk_tree_view_column_get_title((*C.GtkTreeViewColumn)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetTreeView is a wrapper around the C function gtk_tree_view_column_get_tree_view.
func (recv *TreeViewColumn) GetTreeView() *Widget {
	retC := C.gtk_tree_view_column_get_tree_view((*C.GtkTreeViewColumn)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetVisible is a wrapper around the C function gtk_tree_view_column_get_visible.
func (recv *TreeViewColumn) GetVisible() bool {
	retC := C.gtk_tree_view_column_get_visible((*C.GtkTreeViewColumn)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetWidget is a wrapper around the C function gtk_tree_view_column_get_widget.
func (recv *TreeViewColumn) GetWidget() *Widget {
	retC := C.gtk_tree_view_column_get_widget((*C.GtkTreeViewColumn)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetWidth is a wrapper around the C function gtk_tree_view_column_get_width.
func (recv *TreeViewColumn) GetWidth() int32 {
	retC := C.gtk_tree_view_column_get_width((*C.GtkTreeViewColumn)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// PackEnd is a wrapper around the C function gtk_tree_view_column_pack_end.
func (recv *TreeViewColumn) PackEnd(cell *CellRenderer, expand bool) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	C.gtk_tree_view_column_pack_end((*C.GtkTreeViewColumn)(recv.native), c_cell, c_expand)

	return
}

// PackStart is a wrapper around the C function gtk_tree_view_column_pack_start.
func (recv *TreeViewColumn) PackStart(cell *CellRenderer, expand bool) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	C.gtk_tree_view_column_pack_start((*C.GtkTreeViewColumn)(recv.native), c_cell, c_expand)

	return
}

// QueueResize is a wrapper around the C function gtk_tree_view_column_queue_resize.
func (recv *TreeViewColumn) QueueResize() {
	C.gtk_tree_view_column_queue_resize((*C.GtkTreeViewColumn)(recv.native))

	return
}

// SetAlignment is a wrapper around the C function gtk_tree_view_column_set_alignment.
func (recv *TreeViewColumn) SetAlignment(xalign float32) {
	c_xalign := (C.gfloat)(xalign)

	C.gtk_tree_view_column_set_alignment((*C.GtkTreeViewColumn)(recv.native), c_xalign)

	return
}

// Unsupported : gtk_tree_view_column_set_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_tree_view_column_set_cell_data_func : unsupported parameter func : no type generator for TreeCellDataFunc (GtkTreeCellDataFunc) for param func

// SetClickable is a wrapper around the C function gtk_tree_view_column_set_clickable.
func (recv *TreeViewColumn) SetClickable(clickable bool) {
	c_clickable :=
		boolToGboolean(clickable)

	C.gtk_tree_view_column_set_clickable((*C.GtkTreeViewColumn)(recv.native), c_clickable)

	return
}

// SetExpand is a wrapper around the C function gtk_tree_view_column_set_expand.
func (recv *TreeViewColumn) SetExpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_tree_view_column_set_expand((*C.GtkTreeViewColumn)(recv.native), c_expand)

	return
}

// SetFixedWidth is a wrapper around the C function gtk_tree_view_column_set_fixed_width.
func (recv *TreeViewColumn) SetFixedWidth(fixedWidth int32) {
	c_fixed_width := (C.gint)(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width((*C.GtkTreeViewColumn)(recv.native), c_fixed_width)

	return
}

// SetMaxWidth is a wrapper around the C function gtk_tree_view_column_set_max_width.
func (recv *TreeViewColumn) SetMaxWidth(maxWidth int32) {
	c_max_width := (C.gint)(maxWidth)

	C.gtk_tree_view_column_set_max_width((*C.GtkTreeViewColumn)(recv.native), c_max_width)

	return
}

// SetMinWidth is a wrapper around the C function gtk_tree_view_column_set_min_width.
func (recv *TreeViewColumn) SetMinWidth(minWidth int32) {
	c_min_width := (C.gint)(minWidth)

	C.gtk_tree_view_column_set_min_width((*C.GtkTreeViewColumn)(recv.native), c_min_width)

	return
}

// SetReorderable is a wrapper around the C function gtk_tree_view_column_set_reorderable.
func (recv *TreeViewColumn) SetReorderable(reorderable bool) {
	c_reorderable :=
		boolToGboolean(reorderable)

	C.gtk_tree_view_column_set_reorderable((*C.GtkTreeViewColumn)(recv.native), c_reorderable)

	return
}

// SetResizable is a wrapper around the C function gtk_tree_view_column_set_resizable.
func (recv *TreeViewColumn) SetResizable(resizable bool) {
	c_resizable :=
		boolToGboolean(resizable)

	C.gtk_tree_view_column_set_resizable((*C.GtkTreeViewColumn)(recv.native), c_resizable)

	return
}

// SetSizing is a wrapper around the C function gtk_tree_view_column_set_sizing.
func (recv *TreeViewColumn) SetSizing(type_ TreeViewColumnSizing) {
	c_type := (C.GtkTreeViewColumnSizing)(type_)

	C.gtk_tree_view_column_set_sizing((*C.GtkTreeViewColumn)(recv.native), c_type)

	return
}

// SetSortColumnId is a wrapper around the C function gtk_tree_view_column_set_sort_column_id.
func (recv *TreeViewColumn) SetSortColumnId(sortColumnId int32) {
	c_sort_column_id := (C.gint)(sortColumnId)

	C.gtk_tree_view_column_set_sort_column_id((*C.GtkTreeViewColumn)(recv.native), c_sort_column_id)

	return
}

// SetSortIndicator is a wrapper around the C function gtk_tree_view_column_set_sort_indicator.
func (recv *TreeViewColumn) SetSortIndicator(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_tree_view_column_set_sort_indicator((*C.GtkTreeViewColumn)(recv.native), c_setting)

	return
}

// SetSortOrder is a wrapper around the C function gtk_tree_view_column_set_sort_order.
func (recv *TreeViewColumn) SetSortOrder(order SortType) {
	c_order := (C.GtkSortType)(order)

	C.gtk_tree_view_column_set_sort_order((*C.GtkTreeViewColumn)(recv.native), c_order)

	return
}

// SetSpacing is a wrapper around the C function gtk_tree_view_column_set_spacing.
func (recv *TreeViewColumn) SetSpacing(spacing int32) {
	c_spacing := (C.gint)(spacing)

	C.gtk_tree_view_column_set_spacing((*C.GtkTreeViewColumn)(recv.native), c_spacing)

	return
}

// SetTitle is a wrapper around the C function gtk_tree_view_column_set_title.
func (recv *TreeViewColumn) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_tree_view_column_set_title((*C.GtkTreeViewColumn)(recv.native), c_title)

	return
}

// SetVisible is a wrapper around the C function gtk_tree_view_column_set_visible.
func (recv *TreeViewColumn) SetVisible(visible bool) {
	c_visible :=
		boolToGboolean(visible)

	C.gtk_tree_view_column_set_visible((*C.GtkTreeViewColumn)(recv.native), c_visible)

	return
}

// SetWidget is a wrapper around the C function gtk_tree_view_column_set_widget.
func (recv *TreeViewColumn) SetWidget(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_tree_view_column_set_widget((*C.GtkTreeViewColumn)(recv.native), c_widget)

	return
}

// Buildable returns the Buildable interface implemented by TreeViewColumn
func (recv *TreeViewColumn) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// CellLayout returns the CellLayout interface implemented by TreeViewColumn
func (recv *TreeViewColumn) CellLayout() *CellLayout {
	return CellLayoutNewFromC(recv.ToC())
}

// UIManager is a wrapper around the C record GtkUIManager.
type UIManager struct {
	native *C.GtkUIManager
	// parent : record
	// Private : private_data
}

func UIManagerNewFromC(u unsafe.Pointer) *UIManager {
	c := (*C.GtkUIManager)(u)
	if c == nil {
		return nil
	}

	g := &UIManager{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *UIManager) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *UIManager) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UIManager with another UIManager, and returns true if they represent the same GObject.
func (recv *UIManager) Equals(other *UIManager) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *UIManager) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to UIManager.
// Exercise care, as this is a potentially dangerous function if the Object is not a UIManager.
func CastToUIManager(object *gobject.Object) *UIManager {
	return UIManagerNewFromC(object.ToC())
}

type signalUIManagerActionsChangedDetail struct {
	callback  UIManagerSignalActionsChangedCallback
	handlerID C.gulong
}

var signalUIManagerActionsChangedId int
var signalUIManagerActionsChangedMap = make(map[int]signalUIManagerActionsChangedDetail)
var signalUIManagerActionsChangedLock sync.RWMutex

// UIManagerSignalActionsChangedCallback is a callback function for a 'actions-changed' signal emitted from a UIManager.
type UIManagerSignalActionsChangedCallback func()

/*
ConnectActionsChanged connects the callback to the 'actions-changed' signal for the UIManager.

The returned value represents the connection, and may be passed to DisconnectActionsChanged to remove it.
*/
func (recv *UIManager) ConnectActionsChanged(callback UIManagerSignalActionsChangedCallback) int {
	signalUIManagerActionsChangedLock.Lock()
	defer signalUIManagerActionsChangedLock.Unlock()

	signalUIManagerActionsChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.UIManager_signal_connect_actions_changed(instance, C.gpointer(uintptr(signalUIManagerActionsChangedId)))

	detail := signalUIManagerActionsChangedDetail{callback, handlerID}
	signalUIManagerActionsChangedMap[signalUIManagerActionsChangedId] = detail

	return signalUIManagerActionsChangedId
}

/*
DisconnectActionsChanged disconnects a callback from the 'actions-changed' signal for the UIManager.

The connectionID should be a value returned from a call to ConnectActionsChanged.
*/
func (recv *UIManager) DisconnectActionsChanged(connectionID int) {
	signalUIManagerActionsChangedLock.Lock()
	defer signalUIManagerActionsChangedLock.Unlock()

	detail, exists := signalUIManagerActionsChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalUIManagerActionsChangedMap, connectionID)
}

//export uimanager_actionsChangedHandler
func uimanager_actionsChangedHandler(_ *C.GObject, data C.gpointer) {
	signalUIManagerActionsChangedLock.RLock()
	defer signalUIManagerActionsChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalUIManagerActionsChangedMap[index].callback
	callback()
}

type signalUIManagerAddWidgetDetail struct {
	callback  UIManagerSignalAddWidgetCallback
	handlerID C.gulong
}

var signalUIManagerAddWidgetId int
var signalUIManagerAddWidgetMap = make(map[int]signalUIManagerAddWidgetDetail)
var signalUIManagerAddWidgetLock sync.RWMutex

// UIManagerSignalAddWidgetCallback is a callback function for a 'add-widget' signal emitted from a UIManager.
type UIManagerSignalAddWidgetCallback func(widget *Widget)

/*
ConnectAddWidget connects the callback to the 'add-widget' signal for the UIManager.

The returned value represents the connection, and may be passed to DisconnectAddWidget to remove it.
*/
func (recv *UIManager) ConnectAddWidget(callback UIManagerSignalAddWidgetCallback) int {
	signalUIManagerAddWidgetLock.Lock()
	defer signalUIManagerAddWidgetLock.Unlock()

	signalUIManagerAddWidgetId++
	instance := C.gpointer(recv.native)
	handlerID := C.UIManager_signal_connect_add_widget(instance, C.gpointer(uintptr(signalUIManagerAddWidgetId)))

	detail := signalUIManagerAddWidgetDetail{callback, handlerID}
	signalUIManagerAddWidgetMap[signalUIManagerAddWidgetId] = detail

	return signalUIManagerAddWidgetId
}

/*
DisconnectAddWidget disconnects a callback from the 'add-widget' signal for the UIManager.

The connectionID should be a value returned from a call to ConnectAddWidget.
*/
func (recv *UIManager) DisconnectAddWidget(connectionID int) {
	signalUIManagerAddWidgetLock.Lock()
	defer signalUIManagerAddWidgetLock.Unlock()

	detail, exists := signalUIManagerAddWidgetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalUIManagerAddWidgetMap, connectionID)
}

//export uimanager_addWidgetHandler
func uimanager_addWidgetHandler(_ *C.GObject, c_widget *C.GtkWidget, data C.gpointer) {
	signalUIManagerAddWidgetLock.RLock()
	defer signalUIManagerAddWidgetLock.RUnlock()

	widget := WidgetNewFromC(unsafe.Pointer(c_widget))

	index := int(uintptr(data))
	callback := signalUIManagerAddWidgetMap[index].callback
	callback(widget)
}

type signalUIManagerConnectProxyDetail struct {
	callback  UIManagerSignalConnectProxyCallback
	handlerID C.gulong
}

var signalUIManagerConnectProxyId int
var signalUIManagerConnectProxyMap = make(map[int]signalUIManagerConnectProxyDetail)
var signalUIManagerConnectProxyLock sync.RWMutex

// UIManagerSignalConnectProxyCallback is a callback function for a 'connect-proxy' signal emitted from a UIManager.
type UIManagerSignalConnectProxyCallback func(action *Action, proxy *Widget)

/*
ConnectConnectProxy connects the callback to the 'connect-proxy' signal for the UIManager.

The returned value represents the connection, and may be passed to DisconnectConnectProxy to remove it.
*/
func (recv *UIManager) ConnectConnectProxy(callback UIManagerSignalConnectProxyCallback) int {
	signalUIManagerConnectProxyLock.Lock()
	defer signalUIManagerConnectProxyLock.Unlock()

	signalUIManagerConnectProxyId++
	instance := C.gpointer(recv.native)
	handlerID := C.UIManager_signal_connect_connect_proxy(instance, C.gpointer(uintptr(signalUIManagerConnectProxyId)))

	detail := signalUIManagerConnectProxyDetail{callback, handlerID}
	signalUIManagerConnectProxyMap[signalUIManagerConnectProxyId] = detail

	return signalUIManagerConnectProxyId
}

/*
DisconnectConnectProxy disconnects a callback from the 'connect-proxy' signal for the UIManager.

The connectionID should be a value returned from a call to ConnectConnectProxy.
*/
func (recv *UIManager) DisconnectConnectProxy(connectionID int) {
	signalUIManagerConnectProxyLock.Lock()
	defer signalUIManagerConnectProxyLock.Unlock()

	detail, exists := signalUIManagerConnectProxyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalUIManagerConnectProxyMap, connectionID)
}

//export uimanager_connectProxyHandler
func uimanager_connectProxyHandler(_ *C.GObject, c_action *C.GtkAction, c_proxy *C.GtkWidget, data C.gpointer) {
	signalUIManagerConnectProxyLock.RLock()
	defer signalUIManagerConnectProxyLock.RUnlock()

	action := ActionNewFromC(unsafe.Pointer(c_action))

	proxy := WidgetNewFromC(unsafe.Pointer(c_proxy))

	index := int(uintptr(data))
	callback := signalUIManagerConnectProxyMap[index].callback
	callback(action, proxy)
}

type signalUIManagerDisconnectProxyDetail struct {
	callback  UIManagerSignalDisconnectProxyCallback
	handlerID C.gulong
}

var signalUIManagerDisconnectProxyId int
var signalUIManagerDisconnectProxyMap = make(map[int]signalUIManagerDisconnectProxyDetail)
var signalUIManagerDisconnectProxyLock sync.RWMutex

// UIManagerSignalDisconnectProxyCallback is a callback function for a 'disconnect-proxy' signal emitted from a UIManager.
type UIManagerSignalDisconnectProxyCallback func(action *Action, proxy *Widget)

/*
ConnectDisconnectProxy connects the callback to the 'disconnect-proxy' signal for the UIManager.

The returned value represents the connection, and may be passed to DisconnectDisconnectProxy to remove it.
*/
func (recv *UIManager) ConnectDisconnectProxy(callback UIManagerSignalDisconnectProxyCallback) int {
	signalUIManagerDisconnectProxyLock.Lock()
	defer signalUIManagerDisconnectProxyLock.Unlock()

	signalUIManagerDisconnectProxyId++
	instance := C.gpointer(recv.native)
	handlerID := C.UIManager_signal_connect_disconnect_proxy(instance, C.gpointer(uintptr(signalUIManagerDisconnectProxyId)))

	detail := signalUIManagerDisconnectProxyDetail{callback, handlerID}
	signalUIManagerDisconnectProxyMap[signalUIManagerDisconnectProxyId] = detail

	return signalUIManagerDisconnectProxyId
}

/*
DisconnectDisconnectProxy disconnects a callback from the 'disconnect-proxy' signal for the UIManager.

The connectionID should be a value returned from a call to ConnectDisconnectProxy.
*/
func (recv *UIManager) DisconnectDisconnectProxy(connectionID int) {
	signalUIManagerDisconnectProxyLock.Lock()
	defer signalUIManagerDisconnectProxyLock.Unlock()

	detail, exists := signalUIManagerDisconnectProxyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalUIManagerDisconnectProxyMap, connectionID)
}

//export uimanager_disconnectProxyHandler
func uimanager_disconnectProxyHandler(_ *C.GObject, c_action *C.GtkAction, c_proxy *C.GtkWidget, data C.gpointer) {
	signalUIManagerDisconnectProxyLock.RLock()
	defer signalUIManagerDisconnectProxyLock.RUnlock()

	action := ActionNewFromC(unsafe.Pointer(c_action))

	proxy := WidgetNewFromC(unsafe.Pointer(c_proxy))

	index := int(uintptr(data))
	callback := signalUIManagerDisconnectProxyMap[index].callback
	callback(action, proxy)
}

type signalUIManagerPostActivateDetail struct {
	callback  UIManagerSignalPostActivateCallback
	handlerID C.gulong
}

var signalUIManagerPostActivateId int
var signalUIManagerPostActivateMap = make(map[int]signalUIManagerPostActivateDetail)
var signalUIManagerPostActivateLock sync.RWMutex

// UIManagerSignalPostActivateCallback is a callback function for a 'post-activate' signal emitted from a UIManager.
type UIManagerSignalPostActivateCallback func(action *Action)

/*
ConnectPostActivate connects the callback to the 'post-activate' signal for the UIManager.

The returned value represents the connection, and may be passed to DisconnectPostActivate to remove it.
*/
func (recv *UIManager) ConnectPostActivate(callback UIManagerSignalPostActivateCallback) int {
	signalUIManagerPostActivateLock.Lock()
	defer signalUIManagerPostActivateLock.Unlock()

	signalUIManagerPostActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.UIManager_signal_connect_post_activate(instance, C.gpointer(uintptr(signalUIManagerPostActivateId)))

	detail := signalUIManagerPostActivateDetail{callback, handlerID}
	signalUIManagerPostActivateMap[signalUIManagerPostActivateId] = detail

	return signalUIManagerPostActivateId
}

/*
DisconnectPostActivate disconnects a callback from the 'post-activate' signal for the UIManager.

The connectionID should be a value returned from a call to ConnectPostActivate.
*/
func (recv *UIManager) DisconnectPostActivate(connectionID int) {
	signalUIManagerPostActivateLock.Lock()
	defer signalUIManagerPostActivateLock.Unlock()

	detail, exists := signalUIManagerPostActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalUIManagerPostActivateMap, connectionID)
}

//export uimanager_postActivateHandler
func uimanager_postActivateHandler(_ *C.GObject, c_action *C.GtkAction, data C.gpointer) {
	signalUIManagerPostActivateLock.RLock()
	defer signalUIManagerPostActivateLock.RUnlock()

	action := ActionNewFromC(unsafe.Pointer(c_action))

	index := int(uintptr(data))
	callback := signalUIManagerPostActivateMap[index].callback
	callback(action)
}

type signalUIManagerPreActivateDetail struct {
	callback  UIManagerSignalPreActivateCallback
	handlerID C.gulong
}

var signalUIManagerPreActivateId int
var signalUIManagerPreActivateMap = make(map[int]signalUIManagerPreActivateDetail)
var signalUIManagerPreActivateLock sync.RWMutex

// UIManagerSignalPreActivateCallback is a callback function for a 'pre-activate' signal emitted from a UIManager.
type UIManagerSignalPreActivateCallback func(action *Action)

/*
ConnectPreActivate connects the callback to the 'pre-activate' signal for the UIManager.

The returned value represents the connection, and may be passed to DisconnectPreActivate to remove it.
*/
func (recv *UIManager) ConnectPreActivate(callback UIManagerSignalPreActivateCallback) int {
	signalUIManagerPreActivateLock.Lock()
	defer signalUIManagerPreActivateLock.Unlock()

	signalUIManagerPreActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.UIManager_signal_connect_pre_activate(instance, C.gpointer(uintptr(signalUIManagerPreActivateId)))

	detail := signalUIManagerPreActivateDetail{callback, handlerID}
	signalUIManagerPreActivateMap[signalUIManagerPreActivateId] = detail

	return signalUIManagerPreActivateId
}

/*
DisconnectPreActivate disconnects a callback from the 'pre-activate' signal for the UIManager.

The connectionID should be a value returned from a call to ConnectPreActivate.
*/
func (recv *UIManager) DisconnectPreActivate(connectionID int) {
	signalUIManagerPreActivateLock.Lock()
	defer signalUIManagerPreActivateLock.Unlock()

	detail, exists := signalUIManagerPreActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalUIManagerPreActivateMap, connectionID)
}

//export uimanager_preActivateHandler
func uimanager_preActivateHandler(_ *C.GObject, c_action *C.GtkAction, data C.gpointer) {
	signalUIManagerPreActivateLock.RLock()
	defer signalUIManagerPreActivateLock.RUnlock()

	action := ActionNewFromC(unsafe.Pointer(c_action))

	index := int(uintptr(data))
	callback := signalUIManagerPreActivateMap[index].callback
	callback(action)
}

// UIManagerNew is a wrapper around the C function gtk_ui_manager_new.
func UIManagerNew() *UIManager {
	retC := C.gtk_ui_manager_new()
	retGo := UIManagerNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddUi is a wrapper around the C function gtk_ui_manager_add_ui.
func (recv *UIManager) AddUi(mergeId uint32, path string, name string, action string, type_ UIManagerItemType, top bool) {
	c_merge_id := (C.guint)(mergeId)

	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_action := C.CString(action)
	defer C.free(unsafe.Pointer(c_action))

	c_type := (C.GtkUIManagerItemType)(type_)

	c_top :=
		boolToGboolean(top)

	C.gtk_ui_manager_add_ui((*C.GtkUIManager)(recv.native), c_merge_id, c_path, c_name, c_action, c_type, c_top)

	return
}

// AddUiFromFile is a wrapper around the C function gtk_ui_manager_add_ui_from_file.
func (recv *UIManager) AddUiFromFile(filename string) (uint32, error) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	var cThrowableError *C.GError

	retC := C.gtk_ui_manager_add_ui_from_file((*C.GtkUIManager)(recv.native), c_filename, &cThrowableError)
	retGo := (uint32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// AddUiFromString is a wrapper around the C function gtk_ui_manager_add_ui_from_string.
func (recv *UIManager) AddUiFromString(buffer string) (uint32, error) {
	c_buffer := C.CString(buffer)
	defer C.free(unsafe.Pointer(c_buffer))

	c_length := (C.gssize)(len(buffer))

	var cThrowableError *C.GError

	retC := C.gtk_ui_manager_add_ui_from_string((*C.GtkUIManager)(recv.native), c_buffer, c_length, &cThrowableError)
	retGo := (uint32)(retC)

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// EnsureUpdate is a wrapper around the C function gtk_ui_manager_ensure_update.
func (recv *UIManager) EnsureUpdate() {
	C.gtk_ui_manager_ensure_update((*C.GtkUIManager)(recv.native))

	return
}

// GetAccelGroup is a wrapper around the C function gtk_ui_manager_get_accel_group.
func (recv *UIManager) GetAccelGroup() *AccelGroup {
	retC := C.gtk_ui_manager_get_accel_group((*C.GtkUIManager)(recv.native))
	retGo := AccelGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAction is a wrapper around the C function gtk_ui_manager_get_action.
func (recv *UIManager) GetAction(path string) *Action {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.gtk_ui_manager_get_action((*C.GtkUIManager)(recv.native), c_path)
	retGo := ActionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetActionGroups is a wrapper around the C function gtk_ui_manager_get_action_groups.
func (recv *UIManager) GetActionGroups() *glib.List {
	retC := C.gtk_ui_manager_get_action_groups((*C.GtkUIManager)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAddTearoffs is a wrapper around the C function gtk_ui_manager_get_add_tearoffs.
func (recv *UIManager) GetAddTearoffs() bool {
	retC := C.gtk_ui_manager_get_add_tearoffs((*C.GtkUIManager)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetToplevels is a wrapper around the C function gtk_ui_manager_get_toplevels.
func (recv *UIManager) GetToplevels(types UIManagerItemType) *glib.SList {
	c_types := (C.GtkUIManagerItemType)(types)

	retC := C.gtk_ui_manager_get_toplevels((*C.GtkUIManager)(recv.native), c_types)
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetUi is a wrapper around the C function gtk_ui_manager_get_ui.
func (recv *UIManager) GetUi() string {
	retC := C.gtk_ui_manager_get_ui((*C.GtkUIManager)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetWidget is a wrapper around the C function gtk_ui_manager_get_widget.
func (recv *UIManager) GetWidget(path string) *Widget {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.gtk_ui_manager_get_widget((*C.GtkUIManager)(recv.native), c_path)
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// InsertActionGroup is a wrapper around the C function gtk_ui_manager_insert_action_group.
func (recv *UIManager) InsertActionGroup(actionGroup *ActionGroup, pos int32) {
	c_action_group := (*C.GtkActionGroup)(C.NULL)
	if actionGroup != nil {
		c_action_group = (*C.GtkActionGroup)(actionGroup.ToC())
	}

	c_pos := (C.gint)(pos)

	C.gtk_ui_manager_insert_action_group((*C.GtkUIManager)(recv.native), c_action_group, c_pos)

	return
}

// NewMergeId is a wrapper around the C function gtk_ui_manager_new_merge_id.
func (recv *UIManager) NewMergeId() uint32 {
	retC := C.gtk_ui_manager_new_merge_id((*C.GtkUIManager)(recv.native))
	retGo := (uint32)(retC)

	return retGo
}

// RemoveActionGroup is a wrapper around the C function gtk_ui_manager_remove_action_group.
func (recv *UIManager) RemoveActionGroup(actionGroup *ActionGroup) {
	c_action_group := (*C.GtkActionGroup)(C.NULL)
	if actionGroup != nil {
		c_action_group = (*C.GtkActionGroup)(actionGroup.ToC())
	}

	C.gtk_ui_manager_remove_action_group((*C.GtkUIManager)(recv.native), c_action_group)

	return
}

// RemoveUi is a wrapper around the C function gtk_ui_manager_remove_ui.
func (recv *UIManager) RemoveUi(mergeId uint32) {
	c_merge_id := (C.guint)(mergeId)

	C.gtk_ui_manager_remove_ui((*C.GtkUIManager)(recv.native), c_merge_id)

	return
}

// SetAddTearoffs is a wrapper around the C function gtk_ui_manager_set_add_tearoffs.
func (recv *UIManager) SetAddTearoffs(addTearoffs bool) {
	c_add_tearoffs :=
		boolToGboolean(addTearoffs)

	C.gtk_ui_manager_set_add_tearoffs((*C.GtkUIManager)(recv.native), c_add_tearoffs)

	return
}

// Buildable returns the Buildable interface implemented by UIManager
func (recv *UIManager) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// VBox is a wrapper around the C record GtkVBox.
type VBox struct {
	native *C.GtkVBox
	// box : record
}

func VBoxNewFromC(u unsafe.Pointer) *VBox {
	c := (*C.GtkVBox)(u)
	if c == nil {
		return nil
	}

	g := &VBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VBox with another VBox, and returns true if they represent the same GObject.
func (recv *VBox) Equals(other *VBox) bool {
	return other.ToC() == recv.ToC()
}

// Box upcasts to *Box
func (recv *VBox) Box() *Box {
	return BoxNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *VBox) Container() *Container {
	return recv.Box().Container()
}

// Widget upcasts to *Widget
func (recv *VBox) Widget() *Widget {
	return recv.Box().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Box().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VBox) Object() *gobject.Object {
	return recv.Box().Object()
}

// CastToWidget down casts any arbitrary Object to VBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a VBox.
func CastToVBox(object *gobject.Object) *VBox {
	return VBoxNewFromC(object.ToC())
}

// VBoxNew is a wrapper around the C function gtk_vbox_new.
func VBoxNew(homogeneous bool, spacing int32) *VBox {
	c_homogeneous :=
		boolToGboolean(homogeneous)

	c_spacing := (C.gint)(spacing)

	retC := C.gtk_vbox_new(c_homogeneous, c_spacing)
	retGo := VBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VBox
func (recv *VBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VBox
func (recv *VBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VBox
func (recv *VBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VButtonBox is a wrapper around the C record GtkVButtonBox.
type VButtonBox struct {
	native *C.GtkVButtonBox
	// button_box : record
}

func VButtonBoxNewFromC(u unsafe.Pointer) *VButtonBox {
	c := (*C.GtkVButtonBox)(u)
	if c == nil {
		return nil
	}

	g := &VButtonBox{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VButtonBox) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VButtonBox) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VButtonBox with another VButtonBox, and returns true if they represent the same GObject.
func (recv *VButtonBox) Equals(other *VButtonBox) bool {
	return other.ToC() == recv.ToC()
}

// ButtonBox upcasts to *ButtonBox
func (recv *VButtonBox) ButtonBox() *ButtonBox {
	return ButtonBoxNewFromC(unsafe.Pointer(recv.native))
}

// Box upcasts to *Box
func (recv *VButtonBox) Box() *Box {
	return recv.ButtonBox().Box()
}

// Container upcasts to *Container
func (recv *VButtonBox) Container() *Container {
	return recv.ButtonBox().Container()
}

// Widget upcasts to *Widget
func (recv *VButtonBox) Widget() *Widget {
	return recv.ButtonBox().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VButtonBox) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ButtonBox().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VButtonBox) Object() *gobject.Object {
	return recv.ButtonBox().Object()
}

// CastToWidget down casts any arbitrary Object to VButtonBox.
// Exercise care, as this is a potentially dangerous function if the Object is not a VButtonBox.
func CastToVButtonBox(object *gobject.Object) *VButtonBox {
	return VButtonBoxNewFromC(object.ToC())
}

// VButtonBoxNew is a wrapper around the C function gtk_vbutton_box_new.
func VButtonBoxNew() *VButtonBox {
	retC := C.gtk_vbutton_box_new()
	retGo := VButtonBoxNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VButtonBox
func (recv *VButtonBox) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VButtonBox
func (recv *VButtonBox) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VButtonBox
func (recv *VButtonBox) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VPaned is a wrapper around the C record GtkVPaned.
type VPaned struct {
	native *C.GtkVPaned
	// paned : record
}

func VPanedNewFromC(u unsafe.Pointer) *VPaned {
	c := (*C.GtkVPaned)(u)
	if c == nil {
		return nil
	}

	g := &VPaned{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VPaned) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VPaned) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VPaned with another VPaned, and returns true if they represent the same GObject.
func (recv *VPaned) Equals(other *VPaned) bool {
	return other.ToC() == recv.ToC()
}

// Paned upcasts to *Paned
func (recv *VPaned) Paned() *Paned {
	return PanedNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *VPaned) Container() *Container {
	return recv.Paned().Container()
}

// Widget upcasts to *Widget
func (recv *VPaned) Widget() *Widget {
	return recv.Paned().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VPaned) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Paned().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VPaned) Object() *gobject.Object {
	return recv.Paned().Object()
}

// CastToWidget down casts any arbitrary Object to VPaned.
// Exercise care, as this is a potentially dangerous function if the Object is not a VPaned.
func CastToVPaned(object *gobject.Object) *VPaned {
	return VPanedNewFromC(object.ToC())
}

// VPanedNew is a wrapper around the C function gtk_vpaned_new.
func VPanedNew() *VPaned {
	retC := C.gtk_vpaned_new()
	retGo := VPanedNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VPaned
func (recv *VPaned) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VPaned
func (recv *VPaned) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VPaned
func (recv *VPaned) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VScale is a wrapper around the C record GtkVScale.
type VScale struct {
	native *C.GtkVScale
	// scale : record
}

func VScaleNewFromC(u unsafe.Pointer) *VScale {
	c := (*C.GtkVScale)(u)
	if c == nil {
		return nil
	}

	g := &VScale{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VScale) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VScale) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VScale with another VScale, and returns true if they represent the same GObject.
func (recv *VScale) Equals(other *VScale) bool {
	return other.ToC() == recv.ToC()
}

// Scale upcasts to *Scale
func (recv *VScale) Scale() *Scale {
	return ScaleNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *VScale) Range() *Range {
	return recv.Scale().Range()
}

// Widget upcasts to *Widget
func (recv *VScale) Widget() *Widget {
	return recv.Scale().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VScale) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scale().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VScale) Object() *gobject.Object {
	return recv.Scale().Object()
}

// CastToWidget down casts any arbitrary Object to VScale.
// Exercise care, as this is a potentially dangerous function if the Object is not a VScale.
func CastToVScale(object *gobject.Object) *VScale {
	return VScaleNewFromC(object.ToC())
}

// VScaleNew is a wrapper around the C function gtk_vscale_new.
func VScaleNew(adjustment *Adjustment) *VScale {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_vscale_new(c_adjustment)
	retGo := VScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// VScaleNewWithRange is a wrapper around the C function gtk_vscale_new_with_range.
func VScaleNewWithRange(min float64, max float64, step float64) *VScale {
	c_min := (C.gdouble)(min)

	c_max := (C.gdouble)(max)

	c_step := (C.gdouble)(step)

	retC := C.gtk_vscale_new_with_range(c_min, c_max, c_step)
	retGo := VScaleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VScale
func (recv *VScale) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VScale
func (recv *VScale) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VScale
func (recv *VScale) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VScrollbar is a wrapper around the C record GtkVScrollbar.
type VScrollbar struct {
	native *C.GtkVScrollbar
	// scrollbar : record
}

func VScrollbarNewFromC(u unsafe.Pointer) *VScrollbar {
	c := (*C.GtkVScrollbar)(u)
	if c == nil {
		return nil
	}

	g := &VScrollbar{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VScrollbar) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VScrollbar) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VScrollbar with another VScrollbar, and returns true if they represent the same GObject.
func (recv *VScrollbar) Equals(other *VScrollbar) bool {
	return other.ToC() == recv.ToC()
}

// Scrollbar upcasts to *Scrollbar
func (recv *VScrollbar) Scrollbar() *Scrollbar {
	return ScrollbarNewFromC(unsafe.Pointer(recv.native))
}

// Range upcasts to *Range
func (recv *VScrollbar) Range() *Range {
	return recv.Scrollbar().Range()
}

// Widget upcasts to *Widget
func (recv *VScrollbar) Widget() *Widget {
	return recv.Scrollbar().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VScrollbar) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Scrollbar().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VScrollbar) Object() *gobject.Object {
	return recv.Scrollbar().Object()
}

// CastToWidget down casts any arbitrary Object to VScrollbar.
// Exercise care, as this is a potentially dangerous function if the Object is not a VScrollbar.
func CastToVScrollbar(object *gobject.Object) *VScrollbar {
	return VScrollbarNewFromC(object.ToC())
}

// VScrollbarNew is a wrapper around the C function gtk_vscrollbar_new.
func VScrollbarNew(adjustment *Adjustment) *VScrollbar {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	retC := C.gtk_vscrollbar_new(c_adjustment)
	retGo := VScrollbarNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VScrollbar
func (recv *VScrollbar) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VScrollbar
func (recv *VScrollbar) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VScrollbar
func (recv *VScrollbar) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// VSeparator is a wrapper around the C record GtkVSeparator.
type VSeparator struct {
	native *C.GtkVSeparator
	// separator : record
}

func VSeparatorNewFromC(u unsafe.Pointer) *VSeparator {
	c := (*C.GtkVSeparator)(u)
	if c == nil {
		return nil
	}

	g := &VSeparator{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VSeparator) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VSeparator) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VSeparator with another VSeparator, and returns true if they represent the same GObject.
func (recv *VSeparator) Equals(other *VSeparator) bool {
	return other.ToC() == recv.ToC()
}

// Separator upcasts to *Separator
func (recv *VSeparator) Separator() *Separator {
	return SeparatorNewFromC(unsafe.Pointer(recv.native))
}

// Widget upcasts to *Widget
func (recv *VSeparator) Widget() *Widget {
	return recv.Separator().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VSeparator) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Separator().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VSeparator) Object() *gobject.Object {
	return recv.Separator().Object()
}

// CastToWidget down casts any arbitrary Object to VSeparator.
// Exercise care, as this is a potentially dangerous function if the Object is not a VSeparator.
func CastToVSeparator(object *gobject.Object) *VSeparator {
	return VSeparatorNewFromC(object.ToC())
}

// VSeparatorNew is a wrapper around the C function gtk_vseparator_new.
func VSeparatorNew() *VSeparator {
	retC := C.gtk_vseparator_new()
	retGo := VSeparatorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VSeparator
func (recv *VSeparator) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VSeparator
func (recv *VSeparator) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VSeparator
func (recv *VSeparator) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Viewport is a wrapper around the C record GtkViewport.
type Viewport struct {
	native *C.GtkViewport
	// bin : record
	// Private : priv
}

func ViewportNewFromC(u unsafe.Pointer) *Viewport {
	c := (*C.GtkViewport)(u)
	if c == nil {
		return nil
	}

	g := &Viewport{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Viewport) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Viewport) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Viewport with another Viewport, and returns true if they represent the same GObject.
func (recv *Viewport) Equals(other *Viewport) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Viewport) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Viewport) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Viewport) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Viewport) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Viewport) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Viewport.
// Exercise care, as this is a potentially dangerous function if the Object is not a Viewport.
func CastToViewport(object *gobject.Object) *Viewport {
	return ViewportNewFromC(object.ToC())
}

// ViewportNew is a wrapper around the C function gtk_viewport_new.
func ViewportNew(hadjustment *Adjustment, vadjustment *Adjustment) *Viewport {
	c_hadjustment := (*C.GtkAdjustment)(C.NULL)
	if hadjustment != nil {
		c_hadjustment = (*C.GtkAdjustment)(hadjustment.ToC())
	}

	c_vadjustment := (*C.GtkAdjustment)(C.NULL)
	if vadjustment != nil {
		c_vadjustment = (*C.GtkAdjustment)(vadjustment.ToC())
	}

	retC := C.gtk_viewport_new(c_hadjustment, c_vadjustment)
	retGo := ViewportNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetHadjustment is a wrapper around the C function gtk_viewport_get_hadjustment.
func (recv *Viewport) GetHadjustment() *Adjustment {
	retC := C.gtk_viewport_get_hadjustment((*C.GtkViewport)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetShadowType is a wrapper around the C function gtk_viewport_get_shadow_type.
func (recv *Viewport) GetShadowType() ShadowType {
	retC := C.gtk_viewport_get_shadow_type((*C.GtkViewport)(recv.native))
	retGo := (ShadowType)(retC)

	return retGo
}

// GetVadjustment is a wrapper around the C function gtk_viewport_get_vadjustment.
func (recv *Viewport) GetVadjustment() *Adjustment {
	retC := C.gtk_viewport_get_vadjustment((*C.GtkViewport)(recv.native))
	retGo := AdjustmentNewFromC(unsafe.Pointer(retC))

	return retGo
}

// SetHadjustment is a wrapper around the C function gtk_viewport_set_hadjustment.
func (recv *Viewport) SetHadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_viewport_set_hadjustment((*C.GtkViewport)(recv.native), c_adjustment)

	return
}

// SetShadowType is a wrapper around the C function gtk_viewport_set_shadow_type.
func (recv *Viewport) SetShadowType(type_ ShadowType) {
	c_type := (C.GtkShadowType)(type_)

	C.gtk_viewport_set_shadow_type((*C.GtkViewport)(recv.native), c_type)

	return
}

// SetVadjustment is a wrapper around the C function gtk_viewport_set_vadjustment.
func (recv *Viewport) SetVadjustment(adjustment *Adjustment) {
	c_adjustment := (*C.GtkAdjustment)(C.NULL)
	if adjustment != nil {
		c_adjustment = (*C.GtkAdjustment)(adjustment.ToC())
	}

	C.gtk_viewport_set_vadjustment((*C.GtkViewport)(recv.native), c_adjustment)

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Viewport
func (recv *Viewport) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Viewport
func (recv *Viewport) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Scrollable returns the Scrollable interface implemented by Viewport
func (recv *Viewport) Scrollable() *Scrollable {
	return ScrollableNewFromC(recv.ToC())
}

// VolumeButton is a wrapper around the C record GtkVolumeButton.
type VolumeButton struct {
	native *C.GtkVolumeButton
	// parent : record
}

func VolumeButtonNewFromC(u unsafe.Pointer) *VolumeButton {
	c := (*C.GtkVolumeButton)(u)
	if c == nil {
		return nil
	}

	g := &VolumeButton{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *VolumeButton) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *VolumeButton) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VolumeButton with another VolumeButton, and returns true if they represent the same GObject.
func (recv *VolumeButton) Equals(other *VolumeButton) bool {
	return other.ToC() == recv.ToC()
}

// ScaleButton upcasts to *ScaleButton
func (recv *VolumeButton) ScaleButton() *ScaleButton {
	return ScaleButtonNewFromC(unsafe.Pointer(recv.native))
}

// Button upcasts to *Button
func (recv *VolumeButton) Button() *Button {
	return recv.ScaleButton().Button()
}

// Bin upcasts to *Bin
func (recv *VolumeButton) Bin() *Bin {
	return recv.ScaleButton().Bin()
}

// Container upcasts to *Container
func (recv *VolumeButton) Container() *Container {
	return recv.ScaleButton().Container()
}

// Widget upcasts to *Widget
func (recv *VolumeButton) Widget() *Widget {
	return recv.ScaleButton().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *VolumeButton) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.ScaleButton().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *VolumeButton) Object() *gobject.Object {
	return recv.ScaleButton().Object()
}

// CastToWidget down casts any arbitrary Object to VolumeButton.
// Exercise care, as this is a potentially dangerous function if the Object is not a VolumeButton.
func CastToVolumeButton(object *gobject.Object) *VolumeButton {
	return VolumeButtonNewFromC(object.ToC())
}

// VolumeButtonNew is a wrapper around the C function gtk_volume_button_new.
func VolumeButtonNew() *VolumeButton {
	retC := C.gtk_volume_button_new()
	retGo := VolumeButtonNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ImplementorIface returns the ImplementorIface interface implemented by VolumeButton
func (recv *VolumeButton) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Actionable returns the Actionable interface implemented by VolumeButton
func (recv *VolumeButton) Actionable() *Actionable {
	return ActionableNewFromC(recv.ToC())
}

// Activatable returns the Activatable interface implemented by VolumeButton
func (recv *VolumeButton) Activatable() *Activatable {
	return ActivatableNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by VolumeButton
func (recv *VolumeButton) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// Orientable returns the Orientable interface implemented by VolumeButton
func (recv *VolumeButton) Orientable() *Orientable {
	return OrientableNewFromC(recv.ToC())
}

// Widget is a wrapper around the C record GtkWidget.
type Widget struct {
	native *C.GtkWidget
	// parent_instance : record
	// Private : priv
}

func WidgetNewFromC(u unsafe.Pointer) *Widget {
	c := (*C.GtkWidget)(u)
	if c == nil {
		return nil
	}

	g := &Widget{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Widget) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Widget) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Widget with another Widget, and returns true if they represent the same GObject.
func (recv *Widget) Equals(other *Widget) bool {
	return other.ToC() == recv.ToC()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Widget) InitiallyUnowned() *gobject.InitiallyUnowned {
	return gobject.InitiallyUnownedNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *Widget) Object() *gobject.Object {
	return recv.InitiallyUnowned().Object()
}

// CastToWidget down casts any arbitrary Object to Widget.
// Exercise care, as this is a potentially dangerous function if the Object is not a Widget.
func CastToWidget(object *gobject.Object) *Widget {
	return WidgetNewFromC(object.ToC())
}

type signalWidgetAccelClosuresChangedDetail struct {
	callback  WidgetSignalAccelClosuresChangedCallback
	handlerID C.gulong
}

var signalWidgetAccelClosuresChangedId int
var signalWidgetAccelClosuresChangedMap = make(map[int]signalWidgetAccelClosuresChangedDetail)
var signalWidgetAccelClosuresChangedLock sync.RWMutex

// WidgetSignalAccelClosuresChangedCallback is a callback function for a 'accel-closures-changed' signal emitted from a Widget.
type WidgetSignalAccelClosuresChangedCallback func()

/*
ConnectAccelClosuresChanged connects the callback to the 'accel-closures-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectAccelClosuresChanged to remove it.
*/
func (recv *Widget) ConnectAccelClosuresChanged(callback WidgetSignalAccelClosuresChangedCallback) int {
	signalWidgetAccelClosuresChangedLock.Lock()
	defer signalWidgetAccelClosuresChangedLock.Unlock()

	signalWidgetAccelClosuresChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_accel_closures_changed(instance, C.gpointer(uintptr(signalWidgetAccelClosuresChangedId)))

	detail := signalWidgetAccelClosuresChangedDetail{callback, handlerID}
	signalWidgetAccelClosuresChangedMap[signalWidgetAccelClosuresChangedId] = detail

	return signalWidgetAccelClosuresChangedId
}

/*
DisconnectAccelClosuresChanged disconnects a callback from the 'accel-closures-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectAccelClosuresChanged.
*/
func (recv *Widget) DisconnectAccelClosuresChanged(connectionID int) {
	signalWidgetAccelClosuresChangedLock.Lock()
	defer signalWidgetAccelClosuresChangedLock.Unlock()

	detail, exists := signalWidgetAccelClosuresChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetAccelClosuresChangedMap, connectionID)
}

//export widget_accelClosuresChangedHandler
func widget_accelClosuresChangedHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetAccelClosuresChangedLock.RLock()
	defer signalWidgetAccelClosuresChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetAccelClosuresChangedMap[index].callback
	callback()
}

type signalWidgetButtonPressEventDetail struct {
	callback  WidgetSignalButtonPressEventCallback
	handlerID C.gulong
}

var signalWidgetButtonPressEventId int
var signalWidgetButtonPressEventMap = make(map[int]signalWidgetButtonPressEventDetail)
var signalWidgetButtonPressEventLock sync.RWMutex

// WidgetSignalButtonPressEventCallback is a callback function for a 'button-press-event' signal emitted from a Widget.
type WidgetSignalButtonPressEventCallback func(event *gdk.EventButton) bool

/*
ConnectButtonPressEvent connects the callback to the 'button-press-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectButtonPressEvent to remove it.
*/
func (recv *Widget) ConnectButtonPressEvent(callback WidgetSignalButtonPressEventCallback) int {
	signalWidgetButtonPressEventLock.Lock()
	defer signalWidgetButtonPressEventLock.Unlock()

	signalWidgetButtonPressEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_button_press_event(instance, C.gpointer(uintptr(signalWidgetButtonPressEventId)))

	detail := signalWidgetButtonPressEventDetail{callback, handlerID}
	signalWidgetButtonPressEventMap[signalWidgetButtonPressEventId] = detail

	return signalWidgetButtonPressEventId
}

/*
DisconnectButtonPressEvent disconnects a callback from the 'button-press-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectButtonPressEvent.
*/
func (recv *Widget) DisconnectButtonPressEvent(connectionID int) {
	signalWidgetButtonPressEventLock.Lock()
	defer signalWidgetButtonPressEventLock.Unlock()

	detail, exists := signalWidgetButtonPressEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetButtonPressEventMap, connectionID)
}

//export widget_buttonPressEventHandler
func widget_buttonPressEventHandler(_ *C.GObject, c_event *C.GdkEventButton, data C.gpointer) C.gboolean {
	signalWidgetButtonPressEventLock.RLock()
	defer signalWidgetButtonPressEventLock.RUnlock()

	event := gdk.EventButtonNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetButtonPressEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetButtonReleaseEventDetail struct {
	callback  WidgetSignalButtonReleaseEventCallback
	handlerID C.gulong
}

var signalWidgetButtonReleaseEventId int
var signalWidgetButtonReleaseEventMap = make(map[int]signalWidgetButtonReleaseEventDetail)
var signalWidgetButtonReleaseEventLock sync.RWMutex

// WidgetSignalButtonReleaseEventCallback is a callback function for a 'button-release-event' signal emitted from a Widget.
type WidgetSignalButtonReleaseEventCallback func(event *gdk.EventButton) bool

/*
ConnectButtonReleaseEvent connects the callback to the 'button-release-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectButtonReleaseEvent to remove it.
*/
func (recv *Widget) ConnectButtonReleaseEvent(callback WidgetSignalButtonReleaseEventCallback) int {
	signalWidgetButtonReleaseEventLock.Lock()
	defer signalWidgetButtonReleaseEventLock.Unlock()

	signalWidgetButtonReleaseEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_button_release_event(instance, C.gpointer(uintptr(signalWidgetButtonReleaseEventId)))

	detail := signalWidgetButtonReleaseEventDetail{callback, handlerID}
	signalWidgetButtonReleaseEventMap[signalWidgetButtonReleaseEventId] = detail

	return signalWidgetButtonReleaseEventId
}

/*
DisconnectButtonReleaseEvent disconnects a callback from the 'button-release-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectButtonReleaseEvent.
*/
func (recv *Widget) DisconnectButtonReleaseEvent(connectionID int) {
	signalWidgetButtonReleaseEventLock.Lock()
	defer signalWidgetButtonReleaseEventLock.Unlock()

	detail, exists := signalWidgetButtonReleaseEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetButtonReleaseEventMap, connectionID)
}

//export widget_buttonReleaseEventHandler
func widget_buttonReleaseEventHandler(_ *C.GObject, c_event *C.GdkEventButton, data C.gpointer) C.gboolean {
	signalWidgetButtonReleaseEventLock.RLock()
	defer signalWidgetButtonReleaseEventLock.RUnlock()

	event := gdk.EventButtonNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetButtonReleaseEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetCanActivateAccelDetail struct {
	callback  WidgetSignalCanActivateAccelCallback
	handlerID C.gulong
}

var signalWidgetCanActivateAccelId int
var signalWidgetCanActivateAccelMap = make(map[int]signalWidgetCanActivateAccelDetail)
var signalWidgetCanActivateAccelLock sync.RWMutex

// WidgetSignalCanActivateAccelCallback is a callback function for a 'can-activate-accel' signal emitted from a Widget.
type WidgetSignalCanActivateAccelCallback func(signalId uint32) bool

/*
ConnectCanActivateAccel connects the callback to the 'can-activate-accel' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectCanActivateAccel to remove it.
*/
func (recv *Widget) ConnectCanActivateAccel(callback WidgetSignalCanActivateAccelCallback) int {
	signalWidgetCanActivateAccelLock.Lock()
	defer signalWidgetCanActivateAccelLock.Unlock()

	signalWidgetCanActivateAccelId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_can_activate_accel(instance, C.gpointer(uintptr(signalWidgetCanActivateAccelId)))

	detail := signalWidgetCanActivateAccelDetail{callback, handlerID}
	signalWidgetCanActivateAccelMap[signalWidgetCanActivateAccelId] = detail

	return signalWidgetCanActivateAccelId
}

/*
DisconnectCanActivateAccel disconnects a callback from the 'can-activate-accel' signal for the Widget.

The connectionID should be a value returned from a call to ConnectCanActivateAccel.
*/
func (recv *Widget) DisconnectCanActivateAccel(connectionID int) {
	signalWidgetCanActivateAccelLock.Lock()
	defer signalWidgetCanActivateAccelLock.Unlock()

	detail, exists := signalWidgetCanActivateAccelMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetCanActivateAccelMap, connectionID)
}

//export widget_canActivateAccelHandler
func widget_canActivateAccelHandler(_ *C.GObject, c_signal_id C.guint, data C.gpointer) C.gboolean {
	signalWidgetCanActivateAccelLock.RLock()
	defer signalWidgetCanActivateAccelLock.RUnlock()

	signalId := uint32(c_signal_id)

	index := int(uintptr(data))
	callback := signalWidgetCanActivateAccelMap[index].callback
	retGo := callback(signalId)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetChildNotifyDetail struct {
	callback  WidgetSignalChildNotifyCallback
	handlerID C.gulong
}

var signalWidgetChildNotifyId int
var signalWidgetChildNotifyMap = make(map[int]signalWidgetChildNotifyDetail)
var signalWidgetChildNotifyLock sync.RWMutex

// WidgetSignalChildNotifyCallback is a callback function for a 'child-notify' signal emitted from a Widget.
type WidgetSignalChildNotifyCallback func(childProperty *gobject.ParamSpec)

/*
ConnectChildNotify connects the callback to the 'child-notify' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectChildNotify to remove it.
*/
func (recv *Widget) ConnectChildNotify(callback WidgetSignalChildNotifyCallback) int {
	signalWidgetChildNotifyLock.Lock()
	defer signalWidgetChildNotifyLock.Unlock()

	signalWidgetChildNotifyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_child_notify(instance, C.gpointer(uintptr(signalWidgetChildNotifyId)))

	detail := signalWidgetChildNotifyDetail{callback, handlerID}
	signalWidgetChildNotifyMap[signalWidgetChildNotifyId] = detail

	return signalWidgetChildNotifyId
}

/*
DisconnectChildNotify disconnects a callback from the 'child-notify' signal for the Widget.

The connectionID should be a value returned from a call to ConnectChildNotify.
*/
func (recv *Widget) DisconnectChildNotify(connectionID int) {
	signalWidgetChildNotifyLock.Lock()
	defer signalWidgetChildNotifyLock.Unlock()

	detail, exists := signalWidgetChildNotifyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetChildNotifyMap, connectionID)
}

//export widget_childNotifyHandler
func widget_childNotifyHandler(_ *C.GObject, c_child_property *C.GParamSpec, data C.gpointer) {
	signalWidgetChildNotifyLock.RLock()
	defer signalWidgetChildNotifyLock.RUnlock()

	childProperty := gobject.ParamSpecNewFromC(unsafe.Pointer(c_child_property))

	index := int(uintptr(data))
	callback := signalWidgetChildNotifyMap[index].callback
	callback(childProperty)
}

type signalWidgetCompositedChangedDetail struct {
	callback  WidgetSignalCompositedChangedCallback
	handlerID C.gulong
}

var signalWidgetCompositedChangedId int
var signalWidgetCompositedChangedMap = make(map[int]signalWidgetCompositedChangedDetail)
var signalWidgetCompositedChangedLock sync.RWMutex

// WidgetSignalCompositedChangedCallback is a callback function for a 'composited-changed' signal emitted from a Widget.
type WidgetSignalCompositedChangedCallback func()

/*
ConnectCompositedChanged connects the callback to the 'composited-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectCompositedChanged to remove it.
*/
func (recv *Widget) ConnectCompositedChanged(callback WidgetSignalCompositedChangedCallback) int {
	signalWidgetCompositedChangedLock.Lock()
	defer signalWidgetCompositedChangedLock.Unlock()

	signalWidgetCompositedChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_composited_changed(instance, C.gpointer(uintptr(signalWidgetCompositedChangedId)))

	detail := signalWidgetCompositedChangedDetail{callback, handlerID}
	signalWidgetCompositedChangedMap[signalWidgetCompositedChangedId] = detail

	return signalWidgetCompositedChangedId
}

/*
DisconnectCompositedChanged disconnects a callback from the 'composited-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectCompositedChanged.
*/
func (recv *Widget) DisconnectCompositedChanged(connectionID int) {
	signalWidgetCompositedChangedLock.Lock()
	defer signalWidgetCompositedChangedLock.Unlock()

	detail, exists := signalWidgetCompositedChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetCompositedChangedMap, connectionID)
}

//export widget_compositedChangedHandler
func widget_compositedChangedHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetCompositedChangedLock.RLock()
	defer signalWidgetCompositedChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetCompositedChangedMap[index].callback
	callback()
}

type signalWidgetConfigureEventDetail struct {
	callback  WidgetSignalConfigureEventCallback
	handlerID C.gulong
}

var signalWidgetConfigureEventId int
var signalWidgetConfigureEventMap = make(map[int]signalWidgetConfigureEventDetail)
var signalWidgetConfigureEventLock sync.RWMutex

// WidgetSignalConfigureEventCallback is a callback function for a 'configure-event' signal emitted from a Widget.
type WidgetSignalConfigureEventCallback func(event *gdk.EventConfigure) bool

/*
ConnectConfigureEvent connects the callback to the 'configure-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectConfigureEvent to remove it.
*/
func (recv *Widget) ConnectConfigureEvent(callback WidgetSignalConfigureEventCallback) int {
	signalWidgetConfigureEventLock.Lock()
	defer signalWidgetConfigureEventLock.Unlock()

	signalWidgetConfigureEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_configure_event(instance, C.gpointer(uintptr(signalWidgetConfigureEventId)))

	detail := signalWidgetConfigureEventDetail{callback, handlerID}
	signalWidgetConfigureEventMap[signalWidgetConfigureEventId] = detail

	return signalWidgetConfigureEventId
}

/*
DisconnectConfigureEvent disconnects a callback from the 'configure-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectConfigureEvent.
*/
func (recv *Widget) DisconnectConfigureEvent(connectionID int) {
	signalWidgetConfigureEventLock.Lock()
	defer signalWidgetConfigureEventLock.Unlock()

	detail, exists := signalWidgetConfigureEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetConfigureEventMap, connectionID)
}

//export widget_configureEventHandler
func widget_configureEventHandler(_ *C.GObject, c_event *C.GdkEventConfigure, data C.gpointer) C.gboolean {
	signalWidgetConfigureEventLock.RLock()
	defer signalWidgetConfigureEventLock.RUnlock()

	event := gdk.EventConfigureNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetConfigureEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetDeleteEventDetail struct {
	callback  WidgetSignalDeleteEventCallback
	handlerID C.gulong
}

var signalWidgetDeleteEventId int
var signalWidgetDeleteEventMap = make(map[int]signalWidgetDeleteEventDetail)
var signalWidgetDeleteEventLock sync.RWMutex

// WidgetSignalDeleteEventCallback is a callback function for a 'delete-event' signal emitted from a Widget.
type WidgetSignalDeleteEventCallback func(event *gdk.Event) bool

/*
ConnectDeleteEvent connects the callback to the 'delete-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDeleteEvent to remove it.
*/
func (recv *Widget) ConnectDeleteEvent(callback WidgetSignalDeleteEventCallback) int {
	signalWidgetDeleteEventLock.Lock()
	defer signalWidgetDeleteEventLock.Unlock()

	signalWidgetDeleteEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_delete_event(instance, C.gpointer(uintptr(signalWidgetDeleteEventId)))

	detail := signalWidgetDeleteEventDetail{callback, handlerID}
	signalWidgetDeleteEventMap[signalWidgetDeleteEventId] = detail

	return signalWidgetDeleteEventId
}

/*
DisconnectDeleteEvent disconnects a callback from the 'delete-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDeleteEvent.
*/
func (recv *Widget) DisconnectDeleteEvent(connectionID int) {
	signalWidgetDeleteEventLock.Lock()
	defer signalWidgetDeleteEventLock.Unlock()

	detail, exists := signalWidgetDeleteEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDeleteEventMap, connectionID)
}

//export widget_deleteEventHandler
func widget_deleteEventHandler(_ *C.GObject, c_event *C.GdkEvent_, data C.gpointer) C.gboolean {
	signalWidgetDeleteEventLock.RLock()
	defer signalWidgetDeleteEventLock.RUnlock()

	event := gdk.EventNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetDeleteEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetDestroyDetail struct {
	callback  WidgetSignalDestroyCallback
	handlerID C.gulong
}

var signalWidgetDestroyId int
var signalWidgetDestroyMap = make(map[int]signalWidgetDestroyDetail)
var signalWidgetDestroyLock sync.RWMutex

// WidgetSignalDestroyCallback is a callback function for a 'destroy' signal emitted from a Widget.
type WidgetSignalDestroyCallback func()

/*
ConnectDestroy connects the callback to the 'destroy' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDestroy to remove it.
*/
func (recv *Widget) ConnectDestroy(callback WidgetSignalDestroyCallback) int {
	signalWidgetDestroyLock.Lock()
	defer signalWidgetDestroyLock.Unlock()

	signalWidgetDestroyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_destroy(instance, C.gpointer(uintptr(signalWidgetDestroyId)))

	detail := signalWidgetDestroyDetail{callback, handlerID}
	signalWidgetDestroyMap[signalWidgetDestroyId] = detail

	return signalWidgetDestroyId
}

/*
DisconnectDestroy disconnects a callback from the 'destroy' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDestroy.
*/
func (recv *Widget) DisconnectDestroy(connectionID int) {
	signalWidgetDestroyLock.Lock()
	defer signalWidgetDestroyLock.Unlock()

	detail, exists := signalWidgetDestroyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDestroyMap, connectionID)
}

//export widget_destroyHandler
func widget_destroyHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetDestroyLock.RLock()
	defer signalWidgetDestroyLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetDestroyMap[index].callback
	callback()
}

type signalWidgetDestroyEventDetail struct {
	callback  WidgetSignalDestroyEventCallback
	handlerID C.gulong
}

var signalWidgetDestroyEventId int
var signalWidgetDestroyEventMap = make(map[int]signalWidgetDestroyEventDetail)
var signalWidgetDestroyEventLock sync.RWMutex

// WidgetSignalDestroyEventCallback is a callback function for a 'destroy-event' signal emitted from a Widget.
type WidgetSignalDestroyEventCallback func(event *gdk.Event) bool

/*
ConnectDestroyEvent connects the callback to the 'destroy-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDestroyEvent to remove it.
*/
func (recv *Widget) ConnectDestroyEvent(callback WidgetSignalDestroyEventCallback) int {
	signalWidgetDestroyEventLock.Lock()
	defer signalWidgetDestroyEventLock.Unlock()

	signalWidgetDestroyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_destroy_event(instance, C.gpointer(uintptr(signalWidgetDestroyEventId)))

	detail := signalWidgetDestroyEventDetail{callback, handlerID}
	signalWidgetDestroyEventMap[signalWidgetDestroyEventId] = detail

	return signalWidgetDestroyEventId
}

/*
DisconnectDestroyEvent disconnects a callback from the 'destroy-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDestroyEvent.
*/
func (recv *Widget) DisconnectDestroyEvent(connectionID int) {
	signalWidgetDestroyEventLock.Lock()
	defer signalWidgetDestroyEventLock.Unlock()

	detail, exists := signalWidgetDestroyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDestroyEventMap, connectionID)
}

//export widget_destroyEventHandler
func widget_destroyEventHandler(_ *C.GObject, c_event *C.GdkEvent_, data C.gpointer) C.gboolean {
	signalWidgetDestroyEventLock.RLock()
	defer signalWidgetDestroyEventLock.RUnlock()

	event := gdk.EventNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetDestroyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetDirectionChangedDetail struct {
	callback  WidgetSignalDirectionChangedCallback
	handlerID C.gulong
}

var signalWidgetDirectionChangedId int
var signalWidgetDirectionChangedMap = make(map[int]signalWidgetDirectionChangedDetail)
var signalWidgetDirectionChangedLock sync.RWMutex

// WidgetSignalDirectionChangedCallback is a callback function for a 'direction-changed' signal emitted from a Widget.
type WidgetSignalDirectionChangedCallback func(previousDirection TextDirection)

/*
ConnectDirectionChanged connects the callback to the 'direction-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDirectionChanged to remove it.
*/
func (recv *Widget) ConnectDirectionChanged(callback WidgetSignalDirectionChangedCallback) int {
	signalWidgetDirectionChangedLock.Lock()
	defer signalWidgetDirectionChangedLock.Unlock()

	signalWidgetDirectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_direction_changed(instance, C.gpointer(uintptr(signalWidgetDirectionChangedId)))

	detail := signalWidgetDirectionChangedDetail{callback, handlerID}
	signalWidgetDirectionChangedMap[signalWidgetDirectionChangedId] = detail

	return signalWidgetDirectionChangedId
}

/*
DisconnectDirectionChanged disconnects a callback from the 'direction-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDirectionChanged.
*/
func (recv *Widget) DisconnectDirectionChanged(connectionID int) {
	signalWidgetDirectionChangedLock.Lock()
	defer signalWidgetDirectionChangedLock.Unlock()

	detail, exists := signalWidgetDirectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDirectionChangedMap, connectionID)
}

//export widget_directionChangedHandler
func widget_directionChangedHandler(_ *C.GObject, c_previous_direction C.GtkTextDirection, data C.gpointer) {
	signalWidgetDirectionChangedLock.RLock()
	defer signalWidgetDirectionChangedLock.RUnlock()

	previousDirection := TextDirection(c_previous_direction)

	index := int(uintptr(data))
	callback := signalWidgetDirectionChangedMap[index].callback
	callback(previousDirection)
}

type signalWidgetDragBeginDetail struct {
	callback  WidgetSignalDragBeginCallback
	handlerID C.gulong
}

var signalWidgetDragBeginId int
var signalWidgetDragBeginMap = make(map[int]signalWidgetDragBeginDetail)
var signalWidgetDragBeginLock sync.RWMutex

// WidgetSignalDragBeginCallback is a callback function for a 'drag-begin' signal emitted from a Widget.
type WidgetSignalDragBeginCallback func(context *gdk.DragContext)

/*
ConnectDragBegin connects the callback to the 'drag-begin' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragBegin to remove it.
*/
func (recv *Widget) ConnectDragBegin(callback WidgetSignalDragBeginCallback) int {
	signalWidgetDragBeginLock.Lock()
	defer signalWidgetDragBeginLock.Unlock()

	signalWidgetDragBeginId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_begin(instance, C.gpointer(uintptr(signalWidgetDragBeginId)))

	detail := signalWidgetDragBeginDetail{callback, handlerID}
	signalWidgetDragBeginMap[signalWidgetDragBeginId] = detail

	return signalWidgetDragBeginId
}

/*
DisconnectDragBegin disconnects a callback from the 'drag-begin' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragBegin.
*/
func (recv *Widget) DisconnectDragBegin(connectionID int) {
	signalWidgetDragBeginLock.Lock()
	defer signalWidgetDragBeginLock.Unlock()

	detail, exists := signalWidgetDragBeginMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragBeginMap, connectionID)
}

//export widget_dragBeginHandler
func widget_dragBeginHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	signalWidgetDragBeginLock.RLock()
	defer signalWidgetDragBeginLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragBeginMap[index].callback
	callback(context)
}

type signalWidgetDragDataDeleteDetail struct {
	callback  WidgetSignalDragDataDeleteCallback
	handlerID C.gulong
}

var signalWidgetDragDataDeleteId int
var signalWidgetDragDataDeleteMap = make(map[int]signalWidgetDragDataDeleteDetail)
var signalWidgetDragDataDeleteLock sync.RWMutex

// WidgetSignalDragDataDeleteCallback is a callback function for a 'drag-data-delete' signal emitted from a Widget.
type WidgetSignalDragDataDeleteCallback func(context *gdk.DragContext)

/*
ConnectDragDataDelete connects the callback to the 'drag-data-delete' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDataDelete to remove it.
*/
func (recv *Widget) ConnectDragDataDelete(callback WidgetSignalDragDataDeleteCallback) int {
	signalWidgetDragDataDeleteLock.Lock()
	defer signalWidgetDragDataDeleteLock.Unlock()

	signalWidgetDragDataDeleteId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_data_delete(instance, C.gpointer(uintptr(signalWidgetDragDataDeleteId)))

	detail := signalWidgetDragDataDeleteDetail{callback, handlerID}
	signalWidgetDragDataDeleteMap[signalWidgetDragDataDeleteId] = detail

	return signalWidgetDragDataDeleteId
}

/*
DisconnectDragDataDelete disconnects a callback from the 'drag-data-delete' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDataDelete.
*/
func (recv *Widget) DisconnectDragDataDelete(connectionID int) {
	signalWidgetDragDataDeleteLock.Lock()
	defer signalWidgetDragDataDeleteLock.Unlock()

	detail, exists := signalWidgetDragDataDeleteMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDataDeleteMap, connectionID)
}

//export widget_dragDataDeleteHandler
func widget_dragDataDeleteHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	signalWidgetDragDataDeleteLock.RLock()
	defer signalWidgetDragDataDeleteLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragDataDeleteMap[index].callback
	callback(context)
}

type signalWidgetDragDataGetDetail struct {
	callback  WidgetSignalDragDataGetCallback
	handlerID C.gulong
}

var signalWidgetDragDataGetId int
var signalWidgetDragDataGetMap = make(map[int]signalWidgetDragDataGetDetail)
var signalWidgetDragDataGetLock sync.RWMutex

// WidgetSignalDragDataGetCallback is a callback function for a 'drag-data-get' signal emitted from a Widget.
type WidgetSignalDragDataGetCallback func(context *gdk.DragContext, Data *SelectionData, info uint32, time uint32)

/*
ConnectDragDataGet connects the callback to the 'drag-data-get' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDataGet to remove it.
*/
func (recv *Widget) ConnectDragDataGet(callback WidgetSignalDragDataGetCallback) int {
	signalWidgetDragDataGetLock.Lock()
	defer signalWidgetDragDataGetLock.Unlock()

	signalWidgetDragDataGetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_data_get(instance, C.gpointer(uintptr(signalWidgetDragDataGetId)))

	detail := signalWidgetDragDataGetDetail{callback, handlerID}
	signalWidgetDragDataGetMap[signalWidgetDragDataGetId] = detail

	return signalWidgetDragDataGetId
}

/*
DisconnectDragDataGet disconnects a callback from the 'drag-data-get' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDataGet.
*/
func (recv *Widget) DisconnectDragDataGet(connectionID int) {
	signalWidgetDragDataGetLock.Lock()
	defer signalWidgetDragDataGetLock.Unlock()

	detail, exists := signalWidgetDragDataGetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDataGetMap, connectionID)
}

//export widget_dragDataGetHandler
func widget_dragDataGetHandler(_ *C.GObject, c_context *C.GdkDragContext, c__data *C.GtkSelectionData, c_info C.guint, c_time C.guint, data C.gpointer) {
	signalWidgetDragDataGetLock.RLock()
	defer signalWidgetDragDataGetLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	Data := SelectionDataNewFromC(unsafe.Pointer(c__data))

	info := uint32(c_info)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragDataGetMap[index].callback
	callback(context, Data, info, time)
}

type signalWidgetDragDataReceivedDetail struct {
	callback  WidgetSignalDragDataReceivedCallback
	handlerID C.gulong
}

var signalWidgetDragDataReceivedId int
var signalWidgetDragDataReceivedMap = make(map[int]signalWidgetDragDataReceivedDetail)
var signalWidgetDragDataReceivedLock sync.RWMutex

// WidgetSignalDragDataReceivedCallback is a callback function for a 'drag-data-received' signal emitted from a Widget.
type WidgetSignalDragDataReceivedCallback func(context *gdk.DragContext, x int32, y int32, Data *SelectionData, info uint32, time uint32)

/*
ConnectDragDataReceived connects the callback to the 'drag-data-received' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDataReceived to remove it.
*/
func (recv *Widget) ConnectDragDataReceived(callback WidgetSignalDragDataReceivedCallback) int {
	signalWidgetDragDataReceivedLock.Lock()
	defer signalWidgetDragDataReceivedLock.Unlock()

	signalWidgetDragDataReceivedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_data_received(instance, C.gpointer(uintptr(signalWidgetDragDataReceivedId)))

	detail := signalWidgetDragDataReceivedDetail{callback, handlerID}
	signalWidgetDragDataReceivedMap[signalWidgetDragDataReceivedId] = detail

	return signalWidgetDragDataReceivedId
}

/*
DisconnectDragDataReceived disconnects a callback from the 'drag-data-received' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDataReceived.
*/
func (recv *Widget) DisconnectDragDataReceived(connectionID int) {
	signalWidgetDragDataReceivedLock.Lock()
	defer signalWidgetDragDataReceivedLock.Unlock()

	detail, exists := signalWidgetDragDataReceivedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDataReceivedMap, connectionID)
}

//export widget_dragDataReceivedHandler
func widget_dragDataReceivedHandler(_ *C.GObject, c_context *C.GdkDragContext, c_x C.gint, c_y C.gint, c__data *C.GtkSelectionData, c_info C.guint, c_time C.guint, data C.gpointer) {
	signalWidgetDragDataReceivedLock.RLock()
	defer signalWidgetDragDataReceivedLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	x := int32(c_x)

	y := int32(c_y)

	Data := SelectionDataNewFromC(unsafe.Pointer(c__data))

	info := uint32(c_info)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragDataReceivedMap[index].callback
	callback(context, x, y, Data, info, time)
}

type signalWidgetDragDropDetail struct {
	callback  WidgetSignalDragDropCallback
	handlerID C.gulong
}

var signalWidgetDragDropId int
var signalWidgetDragDropMap = make(map[int]signalWidgetDragDropDetail)
var signalWidgetDragDropLock sync.RWMutex

// WidgetSignalDragDropCallback is a callback function for a 'drag-drop' signal emitted from a Widget.
type WidgetSignalDragDropCallback func(context *gdk.DragContext, x int32, y int32, time uint32) bool

/*
ConnectDragDrop connects the callback to the 'drag-drop' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragDrop to remove it.
*/
func (recv *Widget) ConnectDragDrop(callback WidgetSignalDragDropCallback) int {
	signalWidgetDragDropLock.Lock()
	defer signalWidgetDragDropLock.Unlock()

	signalWidgetDragDropId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_drop(instance, C.gpointer(uintptr(signalWidgetDragDropId)))

	detail := signalWidgetDragDropDetail{callback, handlerID}
	signalWidgetDragDropMap[signalWidgetDragDropId] = detail

	return signalWidgetDragDropId
}

/*
DisconnectDragDrop disconnects a callback from the 'drag-drop' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragDrop.
*/
func (recv *Widget) DisconnectDragDrop(connectionID int) {
	signalWidgetDragDropLock.Lock()
	defer signalWidgetDragDropLock.Unlock()

	detail, exists := signalWidgetDragDropMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragDropMap, connectionID)
}

//export widget_dragDropHandler
func widget_dragDropHandler(_ *C.GObject, c_context *C.GdkDragContext, c_x C.gint, c_y C.gint, c_time C.guint, data C.gpointer) C.gboolean {
	signalWidgetDragDropLock.RLock()
	defer signalWidgetDragDropLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	x := int32(c_x)

	y := int32(c_y)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragDropMap[index].callback
	retGo := callback(context, x, y, time)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetDragEndDetail struct {
	callback  WidgetSignalDragEndCallback
	handlerID C.gulong
}

var signalWidgetDragEndId int
var signalWidgetDragEndMap = make(map[int]signalWidgetDragEndDetail)
var signalWidgetDragEndLock sync.RWMutex

// WidgetSignalDragEndCallback is a callback function for a 'drag-end' signal emitted from a Widget.
type WidgetSignalDragEndCallback func(context *gdk.DragContext)

/*
ConnectDragEnd connects the callback to the 'drag-end' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragEnd to remove it.
*/
func (recv *Widget) ConnectDragEnd(callback WidgetSignalDragEndCallback) int {
	signalWidgetDragEndLock.Lock()
	defer signalWidgetDragEndLock.Unlock()

	signalWidgetDragEndId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_end(instance, C.gpointer(uintptr(signalWidgetDragEndId)))

	detail := signalWidgetDragEndDetail{callback, handlerID}
	signalWidgetDragEndMap[signalWidgetDragEndId] = detail

	return signalWidgetDragEndId
}

/*
DisconnectDragEnd disconnects a callback from the 'drag-end' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragEnd.
*/
func (recv *Widget) DisconnectDragEnd(connectionID int) {
	signalWidgetDragEndLock.Lock()
	defer signalWidgetDragEndLock.Unlock()

	detail, exists := signalWidgetDragEndMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragEndMap, connectionID)
}

//export widget_dragEndHandler
func widget_dragEndHandler(_ *C.GObject, c_context *C.GdkDragContext, data C.gpointer) {
	signalWidgetDragEndLock.RLock()
	defer signalWidgetDragEndLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalWidgetDragEndMap[index].callback
	callback(context)
}

type signalWidgetDragFailedDetail struct {
	callback  WidgetSignalDragFailedCallback
	handlerID C.gulong
}

var signalWidgetDragFailedId int
var signalWidgetDragFailedMap = make(map[int]signalWidgetDragFailedDetail)
var signalWidgetDragFailedLock sync.RWMutex

// WidgetSignalDragFailedCallback is a callback function for a 'drag-failed' signal emitted from a Widget.
type WidgetSignalDragFailedCallback func(context *gdk.DragContext, result DragResult) bool

/*
ConnectDragFailed connects the callback to the 'drag-failed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragFailed to remove it.
*/
func (recv *Widget) ConnectDragFailed(callback WidgetSignalDragFailedCallback) int {
	signalWidgetDragFailedLock.Lock()
	defer signalWidgetDragFailedLock.Unlock()

	signalWidgetDragFailedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_failed(instance, C.gpointer(uintptr(signalWidgetDragFailedId)))

	detail := signalWidgetDragFailedDetail{callback, handlerID}
	signalWidgetDragFailedMap[signalWidgetDragFailedId] = detail

	return signalWidgetDragFailedId
}

/*
DisconnectDragFailed disconnects a callback from the 'drag-failed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragFailed.
*/
func (recv *Widget) DisconnectDragFailed(connectionID int) {
	signalWidgetDragFailedLock.Lock()
	defer signalWidgetDragFailedLock.Unlock()

	detail, exists := signalWidgetDragFailedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragFailedMap, connectionID)
}

//export widget_dragFailedHandler
func widget_dragFailedHandler(_ *C.GObject, c_context *C.GdkDragContext, c_result C.GtkDragResult, data C.gpointer) C.gboolean {
	signalWidgetDragFailedLock.RLock()
	defer signalWidgetDragFailedLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	result := DragResult(c_result)

	index := int(uintptr(data))
	callback := signalWidgetDragFailedMap[index].callback
	retGo := callback(context, result)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetDragLeaveDetail struct {
	callback  WidgetSignalDragLeaveCallback
	handlerID C.gulong
}

var signalWidgetDragLeaveId int
var signalWidgetDragLeaveMap = make(map[int]signalWidgetDragLeaveDetail)
var signalWidgetDragLeaveLock sync.RWMutex

// WidgetSignalDragLeaveCallback is a callback function for a 'drag-leave' signal emitted from a Widget.
type WidgetSignalDragLeaveCallback func(context *gdk.DragContext, time uint32)

/*
ConnectDragLeave connects the callback to the 'drag-leave' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragLeave to remove it.
*/
func (recv *Widget) ConnectDragLeave(callback WidgetSignalDragLeaveCallback) int {
	signalWidgetDragLeaveLock.Lock()
	defer signalWidgetDragLeaveLock.Unlock()

	signalWidgetDragLeaveId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_leave(instance, C.gpointer(uintptr(signalWidgetDragLeaveId)))

	detail := signalWidgetDragLeaveDetail{callback, handlerID}
	signalWidgetDragLeaveMap[signalWidgetDragLeaveId] = detail

	return signalWidgetDragLeaveId
}

/*
DisconnectDragLeave disconnects a callback from the 'drag-leave' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragLeave.
*/
func (recv *Widget) DisconnectDragLeave(connectionID int) {
	signalWidgetDragLeaveLock.Lock()
	defer signalWidgetDragLeaveLock.Unlock()

	detail, exists := signalWidgetDragLeaveMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragLeaveMap, connectionID)
}

//export widget_dragLeaveHandler
func widget_dragLeaveHandler(_ *C.GObject, c_context *C.GdkDragContext, c_time C.guint, data C.gpointer) {
	signalWidgetDragLeaveLock.RLock()
	defer signalWidgetDragLeaveLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragLeaveMap[index].callback
	callback(context, time)
}

type signalWidgetDragMotionDetail struct {
	callback  WidgetSignalDragMotionCallback
	handlerID C.gulong
}

var signalWidgetDragMotionId int
var signalWidgetDragMotionMap = make(map[int]signalWidgetDragMotionDetail)
var signalWidgetDragMotionLock sync.RWMutex

// WidgetSignalDragMotionCallback is a callback function for a 'drag-motion' signal emitted from a Widget.
type WidgetSignalDragMotionCallback func(context *gdk.DragContext, x int32, y int32, time uint32) bool

/*
ConnectDragMotion connects the callback to the 'drag-motion' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectDragMotion to remove it.
*/
func (recv *Widget) ConnectDragMotion(callback WidgetSignalDragMotionCallback) int {
	signalWidgetDragMotionLock.Lock()
	defer signalWidgetDragMotionLock.Unlock()

	signalWidgetDragMotionId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_drag_motion(instance, C.gpointer(uintptr(signalWidgetDragMotionId)))

	detail := signalWidgetDragMotionDetail{callback, handlerID}
	signalWidgetDragMotionMap[signalWidgetDragMotionId] = detail

	return signalWidgetDragMotionId
}

/*
DisconnectDragMotion disconnects a callback from the 'drag-motion' signal for the Widget.

The connectionID should be a value returned from a call to ConnectDragMotion.
*/
func (recv *Widget) DisconnectDragMotion(connectionID int) {
	signalWidgetDragMotionLock.Lock()
	defer signalWidgetDragMotionLock.Unlock()

	detail, exists := signalWidgetDragMotionMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetDragMotionMap, connectionID)
}

//export widget_dragMotionHandler
func widget_dragMotionHandler(_ *C.GObject, c_context *C.GdkDragContext, c_x C.gint, c_y C.gint, c_time C.guint, data C.gpointer) C.gboolean {
	signalWidgetDragMotionLock.RLock()
	defer signalWidgetDragMotionLock.RUnlock()

	context := gdk.DragContextNewFromC(unsafe.Pointer(c_context))

	x := int32(c_x)

	y := int32(c_y)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetDragMotionMap[index].callback
	retGo := callback(context, x, y, time)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetEnterNotifyEventDetail struct {
	callback  WidgetSignalEnterNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetEnterNotifyEventId int
var signalWidgetEnterNotifyEventMap = make(map[int]signalWidgetEnterNotifyEventDetail)
var signalWidgetEnterNotifyEventLock sync.RWMutex

// WidgetSignalEnterNotifyEventCallback is a callback function for a 'enter-notify-event' signal emitted from a Widget.
type WidgetSignalEnterNotifyEventCallback func(event *gdk.EventCrossing) bool

/*
ConnectEnterNotifyEvent connects the callback to the 'enter-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectEnterNotifyEvent to remove it.
*/
func (recv *Widget) ConnectEnterNotifyEvent(callback WidgetSignalEnterNotifyEventCallback) int {
	signalWidgetEnterNotifyEventLock.Lock()
	defer signalWidgetEnterNotifyEventLock.Unlock()

	signalWidgetEnterNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_enter_notify_event(instance, C.gpointer(uintptr(signalWidgetEnterNotifyEventId)))

	detail := signalWidgetEnterNotifyEventDetail{callback, handlerID}
	signalWidgetEnterNotifyEventMap[signalWidgetEnterNotifyEventId] = detail

	return signalWidgetEnterNotifyEventId
}

/*
DisconnectEnterNotifyEvent disconnects a callback from the 'enter-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectEnterNotifyEvent.
*/
func (recv *Widget) DisconnectEnterNotifyEvent(connectionID int) {
	signalWidgetEnterNotifyEventLock.Lock()
	defer signalWidgetEnterNotifyEventLock.Unlock()

	detail, exists := signalWidgetEnterNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetEnterNotifyEventMap, connectionID)
}

//export widget_enterNotifyEventHandler
func widget_enterNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventCrossing, data C.gpointer) C.gboolean {
	signalWidgetEnterNotifyEventLock.RLock()
	defer signalWidgetEnterNotifyEventLock.RUnlock()

	event := gdk.EventCrossingNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetEnterNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetEventDetail struct {
	callback  WidgetSignalEventCallback
	handlerID C.gulong
}

var signalWidgetEventId int
var signalWidgetEventMap = make(map[int]signalWidgetEventDetail)
var signalWidgetEventLock sync.RWMutex

// WidgetSignalEventCallback is a callback function for a 'event' signal emitted from a Widget.
type WidgetSignalEventCallback func(event *gdk.Event) bool

/*
ConnectEvent connects the callback to the 'event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectEvent to remove it.
*/
func (recv *Widget) ConnectEvent(callback WidgetSignalEventCallback) int {
	signalWidgetEventLock.Lock()
	defer signalWidgetEventLock.Unlock()

	signalWidgetEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_event(instance, C.gpointer(uintptr(signalWidgetEventId)))

	detail := signalWidgetEventDetail{callback, handlerID}
	signalWidgetEventMap[signalWidgetEventId] = detail

	return signalWidgetEventId
}

/*
DisconnectEvent disconnects a callback from the 'event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectEvent.
*/
func (recv *Widget) DisconnectEvent(connectionID int) {
	signalWidgetEventLock.Lock()
	defer signalWidgetEventLock.Unlock()

	detail, exists := signalWidgetEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetEventMap, connectionID)
}

//export widget_eventHandler
func widget_eventHandler(_ *C.GObject, c_event *C.GdkEvent_, data C.gpointer) C.gboolean {
	signalWidgetEventLock.RLock()
	defer signalWidgetEventLock.RUnlock()

	event := gdk.EventNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetEventAfterDetail struct {
	callback  WidgetSignalEventAfterCallback
	handlerID C.gulong
}

var signalWidgetEventAfterId int
var signalWidgetEventAfterMap = make(map[int]signalWidgetEventAfterDetail)
var signalWidgetEventAfterLock sync.RWMutex

// WidgetSignalEventAfterCallback is a callback function for a 'event-after' signal emitted from a Widget.
type WidgetSignalEventAfterCallback func(event *gdk.Event)

/*
ConnectEventAfter connects the callback to the 'event-after' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectEventAfter to remove it.
*/
func (recv *Widget) ConnectEventAfter(callback WidgetSignalEventAfterCallback) int {
	signalWidgetEventAfterLock.Lock()
	defer signalWidgetEventAfterLock.Unlock()

	signalWidgetEventAfterId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_event_after(instance, C.gpointer(uintptr(signalWidgetEventAfterId)))

	detail := signalWidgetEventAfterDetail{callback, handlerID}
	signalWidgetEventAfterMap[signalWidgetEventAfterId] = detail

	return signalWidgetEventAfterId
}

/*
DisconnectEventAfter disconnects a callback from the 'event-after' signal for the Widget.

The connectionID should be a value returned from a call to ConnectEventAfter.
*/
func (recv *Widget) DisconnectEventAfter(connectionID int) {
	signalWidgetEventAfterLock.Lock()
	defer signalWidgetEventAfterLock.Unlock()

	detail, exists := signalWidgetEventAfterMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetEventAfterMap, connectionID)
}

//export widget_eventAfterHandler
func widget_eventAfterHandler(_ *C.GObject, c_event *C.GdkEvent_, data C.gpointer) {
	signalWidgetEventAfterLock.RLock()
	defer signalWidgetEventAfterLock.RUnlock()

	event := gdk.EventNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetEventAfterMap[index].callback
	callback(event)
}

type signalWidgetFocusDetail struct {
	callback  WidgetSignalFocusCallback
	handlerID C.gulong
}

var signalWidgetFocusId int
var signalWidgetFocusMap = make(map[int]signalWidgetFocusDetail)
var signalWidgetFocusLock sync.RWMutex

// WidgetSignalFocusCallback is a callback function for a 'focus' signal emitted from a Widget.
type WidgetSignalFocusCallback func(direction DirectionType) bool

/*
ConnectFocus connects the callback to the 'focus' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocus to remove it.
*/
func (recv *Widget) ConnectFocus(callback WidgetSignalFocusCallback) int {
	signalWidgetFocusLock.Lock()
	defer signalWidgetFocusLock.Unlock()

	signalWidgetFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus(instance, C.gpointer(uintptr(signalWidgetFocusId)))

	detail := signalWidgetFocusDetail{callback, handlerID}
	signalWidgetFocusMap[signalWidgetFocusId] = detail

	return signalWidgetFocusId
}

/*
DisconnectFocus disconnects a callback from the 'focus' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocus.
*/
func (recv *Widget) DisconnectFocus(connectionID int) {
	signalWidgetFocusLock.Lock()
	defer signalWidgetFocusLock.Unlock()

	detail, exists := signalWidgetFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusMap, connectionID)
}

//export widget_focusHandler
func widget_focusHandler(_ *C.GObject, c_direction C.GtkDirectionType, data C.gpointer) C.gboolean {
	signalWidgetFocusLock.RLock()
	defer signalWidgetFocusLock.RUnlock()

	direction := DirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalWidgetFocusMap[index].callback
	retGo := callback(direction)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetFocusInEventDetail struct {
	callback  WidgetSignalFocusInEventCallback
	handlerID C.gulong
}

var signalWidgetFocusInEventId int
var signalWidgetFocusInEventMap = make(map[int]signalWidgetFocusInEventDetail)
var signalWidgetFocusInEventLock sync.RWMutex

// WidgetSignalFocusInEventCallback is a callback function for a 'focus-in-event' signal emitted from a Widget.
type WidgetSignalFocusInEventCallback func(event *gdk.EventFocus) bool

/*
ConnectFocusInEvent connects the callback to the 'focus-in-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocusInEvent to remove it.
*/
func (recv *Widget) ConnectFocusInEvent(callback WidgetSignalFocusInEventCallback) int {
	signalWidgetFocusInEventLock.Lock()
	defer signalWidgetFocusInEventLock.Unlock()

	signalWidgetFocusInEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus_in_event(instance, C.gpointer(uintptr(signalWidgetFocusInEventId)))

	detail := signalWidgetFocusInEventDetail{callback, handlerID}
	signalWidgetFocusInEventMap[signalWidgetFocusInEventId] = detail

	return signalWidgetFocusInEventId
}

/*
DisconnectFocusInEvent disconnects a callback from the 'focus-in-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocusInEvent.
*/
func (recv *Widget) DisconnectFocusInEvent(connectionID int) {
	signalWidgetFocusInEventLock.Lock()
	defer signalWidgetFocusInEventLock.Unlock()

	detail, exists := signalWidgetFocusInEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusInEventMap, connectionID)
}

//export widget_focusInEventHandler
func widget_focusInEventHandler(_ *C.GObject, c_event *C.GdkEventFocus, data C.gpointer) C.gboolean {
	signalWidgetFocusInEventLock.RLock()
	defer signalWidgetFocusInEventLock.RUnlock()

	event := gdk.EventFocusNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetFocusInEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetFocusOutEventDetail struct {
	callback  WidgetSignalFocusOutEventCallback
	handlerID C.gulong
}

var signalWidgetFocusOutEventId int
var signalWidgetFocusOutEventMap = make(map[int]signalWidgetFocusOutEventDetail)
var signalWidgetFocusOutEventLock sync.RWMutex

// WidgetSignalFocusOutEventCallback is a callback function for a 'focus-out-event' signal emitted from a Widget.
type WidgetSignalFocusOutEventCallback func(event *gdk.EventFocus) bool

/*
ConnectFocusOutEvent connects the callback to the 'focus-out-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectFocusOutEvent to remove it.
*/
func (recv *Widget) ConnectFocusOutEvent(callback WidgetSignalFocusOutEventCallback) int {
	signalWidgetFocusOutEventLock.Lock()
	defer signalWidgetFocusOutEventLock.Unlock()

	signalWidgetFocusOutEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_focus_out_event(instance, C.gpointer(uintptr(signalWidgetFocusOutEventId)))

	detail := signalWidgetFocusOutEventDetail{callback, handlerID}
	signalWidgetFocusOutEventMap[signalWidgetFocusOutEventId] = detail

	return signalWidgetFocusOutEventId
}

/*
DisconnectFocusOutEvent disconnects a callback from the 'focus-out-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectFocusOutEvent.
*/
func (recv *Widget) DisconnectFocusOutEvent(connectionID int) {
	signalWidgetFocusOutEventLock.Lock()
	defer signalWidgetFocusOutEventLock.Unlock()

	detail, exists := signalWidgetFocusOutEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetFocusOutEventMap, connectionID)
}

//export widget_focusOutEventHandler
func widget_focusOutEventHandler(_ *C.GObject, c_event *C.GdkEventFocus, data C.gpointer) C.gboolean {
	signalWidgetFocusOutEventLock.RLock()
	defer signalWidgetFocusOutEventLock.RUnlock()

	event := gdk.EventFocusNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetFocusOutEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetGrabBrokenEventDetail struct {
	callback  WidgetSignalGrabBrokenEventCallback
	handlerID C.gulong
}

var signalWidgetGrabBrokenEventId int
var signalWidgetGrabBrokenEventMap = make(map[int]signalWidgetGrabBrokenEventDetail)
var signalWidgetGrabBrokenEventLock sync.RWMutex

// WidgetSignalGrabBrokenEventCallback is a callback function for a 'grab-broken-event' signal emitted from a Widget.
type WidgetSignalGrabBrokenEventCallback func(event *gdk.EventGrabBroken) bool

/*
ConnectGrabBrokenEvent connects the callback to the 'grab-broken-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabBrokenEvent to remove it.
*/
func (recv *Widget) ConnectGrabBrokenEvent(callback WidgetSignalGrabBrokenEventCallback) int {
	signalWidgetGrabBrokenEventLock.Lock()
	defer signalWidgetGrabBrokenEventLock.Unlock()

	signalWidgetGrabBrokenEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_broken_event(instance, C.gpointer(uintptr(signalWidgetGrabBrokenEventId)))

	detail := signalWidgetGrabBrokenEventDetail{callback, handlerID}
	signalWidgetGrabBrokenEventMap[signalWidgetGrabBrokenEventId] = detail

	return signalWidgetGrabBrokenEventId
}

/*
DisconnectGrabBrokenEvent disconnects a callback from the 'grab-broken-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabBrokenEvent.
*/
func (recv *Widget) DisconnectGrabBrokenEvent(connectionID int) {
	signalWidgetGrabBrokenEventLock.Lock()
	defer signalWidgetGrabBrokenEventLock.Unlock()

	detail, exists := signalWidgetGrabBrokenEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabBrokenEventMap, connectionID)
}

//export widget_grabBrokenEventHandler
func widget_grabBrokenEventHandler(_ *C.GObject, c_event *C.GdkEventGrabBroken, data C.gpointer) C.gboolean {
	signalWidgetGrabBrokenEventLock.RLock()
	defer signalWidgetGrabBrokenEventLock.RUnlock()

	event := gdk.EventGrabBrokenNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetGrabBrokenEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetGrabFocusDetail struct {
	callback  WidgetSignalGrabFocusCallback
	handlerID C.gulong
}

var signalWidgetGrabFocusId int
var signalWidgetGrabFocusMap = make(map[int]signalWidgetGrabFocusDetail)
var signalWidgetGrabFocusLock sync.RWMutex

// WidgetSignalGrabFocusCallback is a callback function for a 'grab-focus' signal emitted from a Widget.
type WidgetSignalGrabFocusCallback func()

/*
ConnectGrabFocus connects the callback to the 'grab-focus' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabFocus to remove it.
*/
func (recv *Widget) ConnectGrabFocus(callback WidgetSignalGrabFocusCallback) int {
	signalWidgetGrabFocusLock.Lock()
	defer signalWidgetGrabFocusLock.Unlock()

	signalWidgetGrabFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_focus(instance, C.gpointer(uintptr(signalWidgetGrabFocusId)))

	detail := signalWidgetGrabFocusDetail{callback, handlerID}
	signalWidgetGrabFocusMap[signalWidgetGrabFocusId] = detail

	return signalWidgetGrabFocusId
}

/*
DisconnectGrabFocus disconnects a callback from the 'grab-focus' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabFocus.
*/
func (recv *Widget) DisconnectGrabFocus(connectionID int) {
	signalWidgetGrabFocusLock.Lock()
	defer signalWidgetGrabFocusLock.Unlock()

	detail, exists := signalWidgetGrabFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabFocusMap, connectionID)
}

//export widget_grabFocusHandler
func widget_grabFocusHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetGrabFocusLock.RLock()
	defer signalWidgetGrabFocusLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetGrabFocusMap[index].callback
	callback()
}

type signalWidgetGrabNotifyDetail struct {
	callback  WidgetSignalGrabNotifyCallback
	handlerID C.gulong
}

var signalWidgetGrabNotifyId int
var signalWidgetGrabNotifyMap = make(map[int]signalWidgetGrabNotifyDetail)
var signalWidgetGrabNotifyLock sync.RWMutex

// WidgetSignalGrabNotifyCallback is a callback function for a 'grab-notify' signal emitted from a Widget.
type WidgetSignalGrabNotifyCallback func(wasGrabbed bool)

/*
ConnectGrabNotify connects the callback to the 'grab-notify' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectGrabNotify to remove it.
*/
func (recv *Widget) ConnectGrabNotify(callback WidgetSignalGrabNotifyCallback) int {
	signalWidgetGrabNotifyLock.Lock()
	defer signalWidgetGrabNotifyLock.Unlock()

	signalWidgetGrabNotifyId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_grab_notify(instance, C.gpointer(uintptr(signalWidgetGrabNotifyId)))

	detail := signalWidgetGrabNotifyDetail{callback, handlerID}
	signalWidgetGrabNotifyMap[signalWidgetGrabNotifyId] = detail

	return signalWidgetGrabNotifyId
}

/*
DisconnectGrabNotify disconnects a callback from the 'grab-notify' signal for the Widget.

The connectionID should be a value returned from a call to ConnectGrabNotify.
*/
func (recv *Widget) DisconnectGrabNotify(connectionID int) {
	signalWidgetGrabNotifyLock.Lock()
	defer signalWidgetGrabNotifyLock.Unlock()

	detail, exists := signalWidgetGrabNotifyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetGrabNotifyMap, connectionID)
}

//export widget_grabNotifyHandler
func widget_grabNotifyHandler(_ *C.GObject, c_was_grabbed C.gboolean, data C.gpointer) {
	signalWidgetGrabNotifyLock.RLock()
	defer signalWidgetGrabNotifyLock.RUnlock()

	wasGrabbed := c_was_grabbed == C.TRUE

	index := int(uintptr(data))
	callback := signalWidgetGrabNotifyMap[index].callback
	callback(wasGrabbed)
}

type signalWidgetHideDetail struct {
	callback  WidgetSignalHideCallback
	handlerID C.gulong
}

var signalWidgetHideId int
var signalWidgetHideMap = make(map[int]signalWidgetHideDetail)
var signalWidgetHideLock sync.RWMutex

// WidgetSignalHideCallback is a callback function for a 'hide' signal emitted from a Widget.
type WidgetSignalHideCallback func()

/*
ConnectHide connects the callback to the 'hide' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectHide to remove it.
*/
func (recv *Widget) ConnectHide(callback WidgetSignalHideCallback) int {
	signalWidgetHideLock.Lock()
	defer signalWidgetHideLock.Unlock()

	signalWidgetHideId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_hide(instance, C.gpointer(uintptr(signalWidgetHideId)))

	detail := signalWidgetHideDetail{callback, handlerID}
	signalWidgetHideMap[signalWidgetHideId] = detail

	return signalWidgetHideId
}

/*
DisconnectHide disconnects a callback from the 'hide' signal for the Widget.

The connectionID should be a value returned from a call to ConnectHide.
*/
func (recv *Widget) DisconnectHide(connectionID int) {
	signalWidgetHideLock.Lock()
	defer signalWidgetHideLock.Unlock()

	detail, exists := signalWidgetHideMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetHideMap, connectionID)
}

//export widget_hideHandler
func widget_hideHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetHideLock.RLock()
	defer signalWidgetHideLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetHideMap[index].callback
	callback()
}

type signalWidgetHierarchyChangedDetail struct {
	callback  WidgetSignalHierarchyChangedCallback
	handlerID C.gulong
}

var signalWidgetHierarchyChangedId int
var signalWidgetHierarchyChangedMap = make(map[int]signalWidgetHierarchyChangedDetail)
var signalWidgetHierarchyChangedLock sync.RWMutex

// WidgetSignalHierarchyChangedCallback is a callback function for a 'hierarchy-changed' signal emitted from a Widget.
type WidgetSignalHierarchyChangedCallback func(previousToplevel *Widget)

/*
ConnectHierarchyChanged connects the callback to the 'hierarchy-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectHierarchyChanged to remove it.
*/
func (recv *Widget) ConnectHierarchyChanged(callback WidgetSignalHierarchyChangedCallback) int {
	signalWidgetHierarchyChangedLock.Lock()
	defer signalWidgetHierarchyChangedLock.Unlock()

	signalWidgetHierarchyChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_hierarchy_changed(instance, C.gpointer(uintptr(signalWidgetHierarchyChangedId)))

	detail := signalWidgetHierarchyChangedDetail{callback, handlerID}
	signalWidgetHierarchyChangedMap[signalWidgetHierarchyChangedId] = detail

	return signalWidgetHierarchyChangedId
}

/*
DisconnectHierarchyChanged disconnects a callback from the 'hierarchy-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectHierarchyChanged.
*/
func (recv *Widget) DisconnectHierarchyChanged(connectionID int) {
	signalWidgetHierarchyChangedLock.Lock()
	defer signalWidgetHierarchyChangedLock.Unlock()

	detail, exists := signalWidgetHierarchyChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetHierarchyChangedMap, connectionID)
}

//export widget_hierarchyChangedHandler
func widget_hierarchyChangedHandler(_ *C.GObject, c_previous_toplevel *C.GtkWidget, data C.gpointer) {
	signalWidgetHierarchyChangedLock.RLock()
	defer signalWidgetHierarchyChangedLock.RUnlock()

	previousToplevel := WidgetNewFromC(unsafe.Pointer(c_previous_toplevel))

	index := int(uintptr(data))
	callback := signalWidgetHierarchyChangedMap[index].callback
	callback(previousToplevel)
}

type signalWidgetKeyPressEventDetail struct {
	callback  WidgetSignalKeyPressEventCallback
	handlerID C.gulong
}

var signalWidgetKeyPressEventId int
var signalWidgetKeyPressEventMap = make(map[int]signalWidgetKeyPressEventDetail)
var signalWidgetKeyPressEventLock sync.RWMutex

// WidgetSignalKeyPressEventCallback is a callback function for a 'key-press-event' signal emitted from a Widget.
type WidgetSignalKeyPressEventCallback func(event *gdk.EventKey) bool

/*
ConnectKeyPressEvent connects the callback to the 'key-press-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeyPressEvent to remove it.
*/
func (recv *Widget) ConnectKeyPressEvent(callback WidgetSignalKeyPressEventCallback) int {
	signalWidgetKeyPressEventLock.Lock()
	defer signalWidgetKeyPressEventLock.Unlock()

	signalWidgetKeyPressEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_key_press_event(instance, C.gpointer(uintptr(signalWidgetKeyPressEventId)))

	detail := signalWidgetKeyPressEventDetail{callback, handlerID}
	signalWidgetKeyPressEventMap[signalWidgetKeyPressEventId] = detail

	return signalWidgetKeyPressEventId
}

/*
DisconnectKeyPressEvent disconnects a callback from the 'key-press-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeyPressEvent.
*/
func (recv *Widget) DisconnectKeyPressEvent(connectionID int) {
	signalWidgetKeyPressEventLock.Lock()
	defer signalWidgetKeyPressEventLock.Unlock()

	detail, exists := signalWidgetKeyPressEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeyPressEventMap, connectionID)
}

//export widget_keyPressEventHandler
func widget_keyPressEventHandler(_ *C.GObject, c_event *C.GdkEventKey, data C.gpointer) C.gboolean {
	signalWidgetKeyPressEventLock.RLock()
	defer signalWidgetKeyPressEventLock.RUnlock()

	event := gdk.EventKeyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetKeyPressEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetKeyReleaseEventDetail struct {
	callback  WidgetSignalKeyReleaseEventCallback
	handlerID C.gulong
}

var signalWidgetKeyReleaseEventId int
var signalWidgetKeyReleaseEventMap = make(map[int]signalWidgetKeyReleaseEventDetail)
var signalWidgetKeyReleaseEventLock sync.RWMutex

// WidgetSignalKeyReleaseEventCallback is a callback function for a 'key-release-event' signal emitted from a Widget.
type WidgetSignalKeyReleaseEventCallback func(event *gdk.EventKey) bool

/*
ConnectKeyReleaseEvent connects the callback to the 'key-release-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeyReleaseEvent to remove it.
*/
func (recv *Widget) ConnectKeyReleaseEvent(callback WidgetSignalKeyReleaseEventCallback) int {
	signalWidgetKeyReleaseEventLock.Lock()
	defer signalWidgetKeyReleaseEventLock.Unlock()

	signalWidgetKeyReleaseEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_key_release_event(instance, C.gpointer(uintptr(signalWidgetKeyReleaseEventId)))

	detail := signalWidgetKeyReleaseEventDetail{callback, handlerID}
	signalWidgetKeyReleaseEventMap[signalWidgetKeyReleaseEventId] = detail

	return signalWidgetKeyReleaseEventId
}

/*
DisconnectKeyReleaseEvent disconnects a callback from the 'key-release-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeyReleaseEvent.
*/
func (recv *Widget) DisconnectKeyReleaseEvent(connectionID int) {
	signalWidgetKeyReleaseEventLock.Lock()
	defer signalWidgetKeyReleaseEventLock.Unlock()

	detail, exists := signalWidgetKeyReleaseEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeyReleaseEventMap, connectionID)
}

//export widget_keyReleaseEventHandler
func widget_keyReleaseEventHandler(_ *C.GObject, c_event *C.GdkEventKey, data C.gpointer) C.gboolean {
	signalWidgetKeyReleaseEventLock.RLock()
	defer signalWidgetKeyReleaseEventLock.RUnlock()

	event := gdk.EventKeyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetKeyReleaseEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetKeynavFailedDetail struct {
	callback  WidgetSignalKeynavFailedCallback
	handlerID C.gulong
}

var signalWidgetKeynavFailedId int
var signalWidgetKeynavFailedMap = make(map[int]signalWidgetKeynavFailedDetail)
var signalWidgetKeynavFailedLock sync.RWMutex

// WidgetSignalKeynavFailedCallback is a callback function for a 'keynav-failed' signal emitted from a Widget.
type WidgetSignalKeynavFailedCallback func(direction DirectionType) bool

/*
ConnectKeynavFailed connects the callback to the 'keynav-failed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectKeynavFailed to remove it.
*/
func (recv *Widget) ConnectKeynavFailed(callback WidgetSignalKeynavFailedCallback) int {
	signalWidgetKeynavFailedLock.Lock()
	defer signalWidgetKeynavFailedLock.Unlock()

	signalWidgetKeynavFailedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_keynav_failed(instance, C.gpointer(uintptr(signalWidgetKeynavFailedId)))

	detail := signalWidgetKeynavFailedDetail{callback, handlerID}
	signalWidgetKeynavFailedMap[signalWidgetKeynavFailedId] = detail

	return signalWidgetKeynavFailedId
}

/*
DisconnectKeynavFailed disconnects a callback from the 'keynav-failed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectKeynavFailed.
*/
func (recv *Widget) DisconnectKeynavFailed(connectionID int) {
	signalWidgetKeynavFailedLock.Lock()
	defer signalWidgetKeynavFailedLock.Unlock()

	detail, exists := signalWidgetKeynavFailedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetKeynavFailedMap, connectionID)
}

//export widget_keynavFailedHandler
func widget_keynavFailedHandler(_ *C.GObject, c_direction C.GtkDirectionType, data C.gpointer) C.gboolean {
	signalWidgetKeynavFailedLock.RLock()
	defer signalWidgetKeynavFailedLock.RUnlock()

	direction := DirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalWidgetKeynavFailedMap[index].callback
	retGo := callback(direction)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetLeaveNotifyEventDetail struct {
	callback  WidgetSignalLeaveNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetLeaveNotifyEventId int
var signalWidgetLeaveNotifyEventMap = make(map[int]signalWidgetLeaveNotifyEventDetail)
var signalWidgetLeaveNotifyEventLock sync.RWMutex

// WidgetSignalLeaveNotifyEventCallback is a callback function for a 'leave-notify-event' signal emitted from a Widget.
type WidgetSignalLeaveNotifyEventCallback func(event *gdk.EventCrossing) bool

/*
ConnectLeaveNotifyEvent connects the callback to the 'leave-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectLeaveNotifyEvent to remove it.
*/
func (recv *Widget) ConnectLeaveNotifyEvent(callback WidgetSignalLeaveNotifyEventCallback) int {
	signalWidgetLeaveNotifyEventLock.Lock()
	defer signalWidgetLeaveNotifyEventLock.Unlock()

	signalWidgetLeaveNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_leave_notify_event(instance, C.gpointer(uintptr(signalWidgetLeaveNotifyEventId)))

	detail := signalWidgetLeaveNotifyEventDetail{callback, handlerID}
	signalWidgetLeaveNotifyEventMap[signalWidgetLeaveNotifyEventId] = detail

	return signalWidgetLeaveNotifyEventId
}

/*
DisconnectLeaveNotifyEvent disconnects a callback from the 'leave-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectLeaveNotifyEvent.
*/
func (recv *Widget) DisconnectLeaveNotifyEvent(connectionID int) {
	signalWidgetLeaveNotifyEventLock.Lock()
	defer signalWidgetLeaveNotifyEventLock.Unlock()

	detail, exists := signalWidgetLeaveNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetLeaveNotifyEventMap, connectionID)
}

//export widget_leaveNotifyEventHandler
func widget_leaveNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventCrossing, data C.gpointer) C.gboolean {
	signalWidgetLeaveNotifyEventLock.RLock()
	defer signalWidgetLeaveNotifyEventLock.RUnlock()

	event := gdk.EventCrossingNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetLeaveNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMapDetail struct {
	callback  WidgetSignalMapCallback
	handlerID C.gulong
}

var signalWidgetMapId int
var signalWidgetMapMap = make(map[int]signalWidgetMapDetail)
var signalWidgetMapLock sync.RWMutex

// WidgetSignalMapCallback is a callback function for a 'map' signal emitted from a Widget.
type WidgetSignalMapCallback func()

/*
ConnectMap connects the callback to the 'map' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMap to remove it.
*/
func (recv *Widget) ConnectMap(callback WidgetSignalMapCallback) int {
	signalWidgetMapLock.Lock()
	defer signalWidgetMapLock.Unlock()

	signalWidgetMapId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_map(instance, C.gpointer(uintptr(signalWidgetMapId)))

	detail := signalWidgetMapDetail{callback, handlerID}
	signalWidgetMapMap[signalWidgetMapId] = detail

	return signalWidgetMapId
}

/*
DisconnectMap disconnects a callback from the 'map' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMap.
*/
func (recv *Widget) DisconnectMap(connectionID int) {
	signalWidgetMapLock.Lock()
	defer signalWidgetMapLock.Unlock()

	detail, exists := signalWidgetMapMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMapMap, connectionID)
}

//export widget_mapHandler
func widget_mapHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetMapLock.RLock()
	defer signalWidgetMapLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetMapMap[index].callback
	callback()
}

type signalWidgetMapEventDetail struct {
	callback  WidgetSignalMapEventCallback
	handlerID C.gulong
}

var signalWidgetMapEventId int
var signalWidgetMapEventMap = make(map[int]signalWidgetMapEventDetail)
var signalWidgetMapEventLock sync.RWMutex

// WidgetSignalMapEventCallback is a callback function for a 'map-event' signal emitted from a Widget.
type WidgetSignalMapEventCallback func(event *gdk.EventAny) bool

/*
ConnectMapEvent connects the callback to the 'map-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMapEvent to remove it.
*/
func (recv *Widget) ConnectMapEvent(callback WidgetSignalMapEventCallback) int {
	signalWidgetMapEventLock.Lock()
	defer signalWidgetMapEventLock.Unlock()

	signalWidgetMapEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_map_event(instance, C.gpointer(uintptr(signalWidgetMapEventId)))

	detail := signalWidgetMapEventDetail{callback, handlerID}
	signalWidgetMapEventMap[signalWidgetMapEventId] = detail

	return signalWidgetMapEventId
}

/*
DisconnectMapEvent disconnects a callback from the 'map-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMapEvent.
*/
func (recv *Widget) DisconnectMapEvent(connectionID int) {
	signalWidgetMapEventLock.Lock()
	defer signalWidgetMapEventLock.Unlock()

	detail, exists := signalWidgetMapEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMapEventMap, connectionID)
}

//export widget_mapEventHandler
func widget_mapEventHandler(_ *C.GObject, c_event *C.GdkEventAny, data C.gpointer) C.gboolean {
	signalWidgetMapEventLock.RLock()
	defer signalWidgetMapEventLock.RUnlock()

	event := gdk.EventAnyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetMapEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMnemonicActivateDetail struct {
	callback  WidgetSignalMnemonicActivateCallback
	handlerID C.gulong
}

var signalWidgetMnemonicActivateId int
var signalWidgetMnemonicActivateMap = make(map[int]signalWidgetMnemonicActivateDetail)
var signalWidgetMnemonicActivateLock sync.RWMutex

// WidgetSignalMnemonicActivateCallback is a callback function for a 'mnemonic-activate' signal emitted from a Widget.
type WidgetSignalMnemonicActivateCallback func(groupCycling bool) bool

/*
ConnectMnemonicActivate connects the callback to the 'mnemonic-activate' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMnemonicActivate to remove it.
*/
func (recv *Widget) ConnectMnemonicActivate(callback WidgetSignalMnemonicActivateCallback) int {
	signalWidgetMnemonicActivateLock.Lock()
	defer signalWidgetMnemonicActivateLock.Unlock()

	signalWidgetMnemonicActivateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_mnemonic_activate(instance, C.gpointer(uintptr(signalWidgetMnemonicActivateId)))

	detail := signalWidgetMnemonicActivateDetail{callback, handlerID}
	signalWidgetMnemonicActivateMap[signalWidgetMnemonicActivateId] = detail

	return signalWidgetMnemonicActivateId
}

/*
DisconnectMnemonicActivate disconnects a callback from the 'mnemonic-activate' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMnemonicActivate.
*/
func (recv *Widget) DisconnectMnemonicActivate(connectionID int) {
	signalWidgetMnemonicActivateLock.Lock()
	defer signalWidgetMnemonicActivateLock.Unlock()

	detail, exists := signalWidgetMnemonicActivateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMnemonicActivateMap, connectionID)
}

//export widget_mnemonicActivateHandler
func widget_mnemonicActivateHandler(_ *C.GObject, c_group_cycling C.gboolean, data C.gpointer) C.gboolean {
	signalWidgetMnemonicActivateLock.RLock()
	defer signalWidgetMnemonicActivateLock.RUnlock()

	groupCycling := c_group_cycling == C.TRUE

	index := int(uintptr(data))
	callback := signalWidgetMnemonicActivateMap[index].callback
	retGo := callback(groupCycling)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMotionNotifyEventDetail struct {
	callback  WidgetSignalMotionNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetMotionNotifyEventId int
var signalWidgetMotionNotifyEventMap = make(map[int]signalWidgetMotionNotifyEventDetail)
var signalWidgetMotionNotifyEventLock sync.RWMutex

// WidgetSignalMotionNotifyEventCallback is a callback function for a 'motion-notify-event' signal emitted from a Widget.
type WidgetSignalMotionNotifyEventCallback func(event *gdk.EventMotion) bool

/*
ConnectMotionNotifyEvent connects the callback to the 'motion-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMotionNotifyEvent to remove it.
*/
func (recv *Widget) ConnectMotionNotifyEvent(callback WidgetSignalMotionNotifyEventCallback) int {
	signalWidgetMotionNotifyEventLock.Lock()
	defer signalWidgetMotionNotifyEventLock.Unlock()

	signalWidgetMotionNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_motion_notify_event(instance, C.gpointer(uintptr(signalWidgetMotionNotifyEventId)))

	detail := signalWidgetMotionNotifyEventDetail{callback, handlerID}
	signalWidgetMotionNotifyEventMap[signalWidgetMotionNotifyEventId] = detail

	return signalWidgetMotionNotifyEventId
}

/*
DisconnectMotionNotifyEvent disconnects a callback from the 'motion-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMotionNotifyEvent.
*/
func (recv *Widget) DisconnectMotionNotifyEvent(connectionID int) {
	signalWidgetMotionNotifyEventLock.Lock()
	defer signalWidgetMotionNotifyEventLock.Unlock()

	detail, exists := signalWidgetMotionNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMotionNotifyEventMap, connectionID)
}

//export widget_motionNotifyEventHandler
func widget_motionNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventMotion, data C.gpointer) C.gboolean {
	signalWidgetMotionNotifyEventLock.RLock()
	defer signalWidgetMotionNotifyEventLock.RUnlock()

	event := gdk.EventMotionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetMotionNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetMoveFocusDetail struct {
	callback  WidgetSignalMoveFocusCallback
	handlerID C.gulong
}

var signalWidgetMoveFocusId int
var signalWidgetMoveFocusMap = make(map[int]signalWidgetMoveFocusDetail)
var signalWidgetMoveFocusLock sync.RWMutex

// WidgetSignalMoveFocusCallback is a callback function for a 'move-focus' signal emitted from a Widget.
type WidgetSignalMoveFocusCallback func(direction DirectionType)

/*
ConnectMoveFocus connects the callback to the 'move-focus' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectMoveFocus to remove it.
*/
func (recv *Widget) ConnectMoveFocus(callback WidgetSignalMoveFocusCallback) int {
	signalWidgetMoveFocusLock.Lock()
	defer signalWidgetMoveFocusLock.Unlock()

	signalWidgetMoveFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_move_focus(instance, C.gpointer(uintptr(signalWidgetMoveFocusId)))

	detail := signalWidgetMoveFocusDetail{callback, handlerID}
	signalWidgetMoveFocusMap[signalWidgetMoveFocusId] = detail

	return signalWidgetMoveFocusId
}

/*
DisconnectMoveFocus disconnects a callback from the 'move-focus' signal for the Widget.

The connectionID should be a value returned from a call to ConnectMoveFocus.
*/
func (recv *Widget) DisconnectMoveFocus(connectionID int) {
	signalWidgetMoveFocusLock.Lock()
	defer signalWidgetMoveFocusLock.Unlock()

	detail, exists := signalWidgetMoveFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetMoveFocusMap, connectionID)
}

//export widget_moveFocusHandler
func widget_moveFocusHandler(_ *C.GObject, c_direction C.GtkDirectionType, data C.gpointer) {
	signalWidgetMoveFocusLock.RLock()
	defer signalWidgetMoveFocusLock.RUnlock()

	direction := DirectionType(c_direction)

	index := int(uintptr(data))
	callback := signalWidgetMoveFocusMap[index].callback
	callback(direction)
}

type signalWidgetParentSetDetail struct {
	callback  WidgetSignalParentSetCallback
	handlerID C.gulong
}

var signalWidgetParentSetId int
var signalWidgetParentSetMap = make(map[int]signalWidgetParentSetDetail)
var signalWidgetParentSetLock sync.RWMutex

// WidgetSignalParentSetCallback is a callback function for a 'parent-set' signal emitted from a Widget.
type WidgetSignalParentSetCallback func(oldParent *Widget)

/*
ConnectParentSet connects the callback to the 'parent-set' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectParentSet to remove it.
*/
func (recv *Widget) ConnectParentSet(callback WidgetSignalParentSetCallback) int {
	signalWidgetParentSetLock.Lock()
	defer signalWidgetParentSetLock.Unlock()

	signalWidgetParentSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_parent_set(instance, C.gpointer(uintptr(signalWidgetParentSetId)))

	detail := signalWidgetParentSetDetail{callback, handlerID}
	signalWidgetParentSetMap[signalWidgetParentSetId] = detail

	return signalWidgetParentSetId
}

/*
DisconnectParentSet disconnects a callback from the 'parent-set' signal for the Widget.

The connectionID should be a value returned from a call to ConnectParentSet.
*/
func (recv *Widget) DisconnectParentSet(connectionID int) {
	signalWidgetParentSetLock.Lock()
	defer signalWidgetParentSetLock.Unlock()

	detail, exists := signalWidgetParentSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetParentSetMap, connectionID)
}

//export widget_parentSetHandler
func widget_parentSetHandler(_ *C.GObject, c_old_parent *C.GtkWidget, data C.gpointer) {
	signalWidgetParentSetLock.RLock()
	defer signalWidgetParentSetLock.RUnlock()

	oldParent := WidgetNewFromC(unsafe.Pointer(c_old_parent))

	index := int(uintptr(data))
	callback := signalWidgetParentSetMap[index].callback
	callback(oldParent)
}

type signalWidgetPopupMenuDetail struct {
	callback  WidgetSignalPopupMenuCallback
	handlerID C.gulong
}

var signalWidgetPopupMenuId int
var signalWidgetPopupMenuMap = make(map[int]signalWidgetPopupMenuDetail)
var signalWidgetPopupMenuLock sync.RWMutex

// WidgetSignalPopupMenuCallback is a callback function for a 'popup-menu' signal emitted from a Widget.
type WidgetSignalPopupMenuCallback func() bool

/*
ConnectPopupMenu connects the callback to the 'popup-menu' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectPopupMenu to remove it.
*/
func (recv *Widget) ConnectPopupMenu(callback WidgetSignalPopupMenuCallback) int {
	signalWidgetPopupMenuLock.Lock()
	defer signalWidgetPopupMenuLock.Unlock()

	signalWidgetPopupMenuId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_popup_menu(instance, C.gpointer(uintptr(signalWidgetPopupMenuId)))

	detail := signalWidgetPopupMenuDetail{callback, handlerID}
	signalWidgetPopupMenuMap[signalWidgetPopupMenuId] = detail

	return signalWidgetPopupMenuId
}

/*
DisconnectPopupMenu disconnects a callback from the 'popup-menu' signal for the Widget.

The connectionID should be a value returned from a call to ConnectPopupMenu.
*/
func (recv *Widget) DisconnectPopupMenu(connectionID int) {
	signalWidgetPopupMenuLock.Lock()
	defer signalWidgetPopupMenuLock.Unlock()

	detail, exists := signalWidgetPopupMenuMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetPopupMenuMap, connectionID)
}

//export widget_popupMenuHandler
func widget_popupMenuHandler(_ *C.GObject, data C.gpointer) C.gboolean {
	signalWidgetPopupMenuLock.RLock()
	defer signalWidgetPopupMenuLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetPopupMenuMap[index].callback
	retGo := callback()
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetPropertyNotifyEventDetail struct {
	callback  WidgetSignalPropertyNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetPropertyNotifyEventId int
var signalWidgetPropertyNotifyEventMap = make(map[int]signalWidgetPropertyNotifyEventDetail)
var signalWidgetPropertyNotifyEventLock sync.RWMutex

// WidgetSignalPropertyNotifyEventCallback is a callback function for a 'property-notify-event' signal emitted from a Widget.
type WidgetSignalPropertyNotifyEventCallback func(event *gdk.EventProperty) bool

/*
ConnectPropertyNotifyEvent connects the callback to the 'property-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectPropertyNotifyEvent to remove it.
*/
func (recv *Widget) ConnectPropertyNotifyEvent(callback WidgetSignalPropertyNotifyEventCallback) int {
	signalWidgetPropertyNotifyEventLock.Lock()
	defer signalWidgetPropertyNotifyEventLock.Unlock()

	signalWidgetPropertyNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_property_notify_event(instance, C.gpointer(uintptr(signalWidgetPropertyNotifyEventId)))

	detail := signalWidgetPropertyNotifyEventDetail{callback, handlerID}
	signalWidgetPropertyNotifyEventMap[signalWidgetPropertyNotifyEventId] = detail

	return signalWidgetPropertyNotifyEventId
}

/*
DisconnectPropertyNotifyEvent disconnects a callback from the 'property-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectPropertyNotifyEvent.
*/
func (recv *Widget) DisconnectPropertyNotifyEvent(connectionID int) {
	signalWidgetPropertyNotifyEventLock.Lock()
	defer signalWidgetPropertyNotifyEventLock.Unlock()

	detail, exists := signalWidgetPropertyNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetPropertyNotifyEventMap, connectionID)
}

//export widget_propertyNotifyEventHandler
func widget_propertyNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventProperty, data C.gpointer) C.gboolean {
	signalWidgetPropertyNotifyEventLock.RLock()
	defer signalWidgetPropertyNotifyEventLock.RUnlock()

	event := gdk.EventPropertyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetPropertyNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetProximityInEventDetail struct {
	callback  WidgetSignalProximityInEventCallback
	handlerID C.gulong
}

var signalWidgetProximityInEventId int
var signalWidgetProximityInEventMap = make(map[int]signalWidgetProximityInEventDetail)
var signalWidgetProximityInEventLock sync.RWMutex

// WidgetSignalProximityInEventCallback is a callback function for a 'proximity-in-event' signal emitted from a Widget.
type WidgetSignalProximityInEventCallback func(event *gdk.EventProximity) bool

/*
ConnectProximityInEvent connects the callback to the 'proximity-in-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectProximityInEvent to remove it.
*/
func (recv *Widget) ConnectProximityInEvent(callback WidgetSignalProximityInEventCallback) int {
	signalWidgetProximityInEventLock.Lock()
	defer signalWidgetProximityInEventLock.Unlock()

	signalWidgetProximityInEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_proximity_in_event(instance, C.gpointer(uintptr(signalWidgetProximityInEventId)))

	detail := signalWidgetProximityInEventDetail{callback, handlerID}
	signalWidgetProximityInEventMap[signalWidgetProximityInEventId] = detail

	return signalWidgetProximityInEventId
}

/*
DisconnectProximityInEvent disconnects a callback from the 'proximity-in-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectProximityInEvent.
*/
func (recv *Widget) DisconnectProximityInEvent(connectionID int) {
	signalWidgetProximityInEventLock.Lock()
	defer signalWidgetProximityInEventLock.Unlock()

	detail, exists := signalWidgetProximityInEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetProximityInEventMap, connectionID)
}

//export widget_proximityInEventHandler
func widget_proximityInEventHandler(_ *C.GObject, c_event *C.GdkEventProximity, data C.gpointer) C.gboolean {
	signalWidgetProximityInEventLock.RLock()
	defer signalWidgetProximityInEventLock.RUnlock()

	event := gdk.EventProximityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetProximityInEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetProximityOutEventDetail struct {
	callback  WidgetSignalProximityOutEventCallback
	handlerID C.gulong
}

var signalWidgetProximityOutEventId int
var signalWidgetProximityOutEventMap = make(map[int]signalWidgetProximityOutEventDetail)
var signalWidgetProximityOutEventLock sync.RWMutex

// WidgetSignalProximityOutEventCallback is a callback function for a 'proximity-out-event' signal emitted from a Widget.
type WidgetSignalProximityOutEventCallback func(event *gdk.EventProximity) bool

/*
ConnectProximityOutEvent connects the callback to the 'proximity-out-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectProximityOutEvent to remove it.
*/
func (recv *Widget) ConnectProximityOutEvent(callback WidgetSignalProximityOutEventCallback) int {
	signalWidgetProximityOutEventLock.Lock()
	defer signalWidgetProximityOutEventLock.Unlock()

	signalWidgetProximityOutEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_proximity_out_event(instance, C.gpointer(uintptr(signalWidgetProximityOutEventId)))

	detail := signalWidgetProximityOutEventDetail{callback, handlerID}
	signalWidgetProximityOutEventMap[signalWidgetProximityOutEventId] = detail

	return signalWidgetProximityOutEventId
}

/*
DisconnectProximityOutEvent disconnects a callback from the 'proximity-out-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectProximityOutEvent.
*/
func (recv *Widget) DisconnectProximityOutEvent(connectionID int) {
	signalWidgetProximityOutEventLock.Lock()
	defer signalWidgetProximityOutEventLock.Unlock()

	detail, exists := signalWidgetProximityOutEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetProximityOutEventMap, connectionID)
}

//export widget_proximityOutEventHandler
func widget_proximityOutEventHandler(_ *C.GObject, c_event *C.GdkEventProximity, data C.gpointer) C.gboolean {
	signalWidgetProximityOutEventLock.RLock()
	defer signalWidgetProximityOutEventLock.RUnlock()

	event := gdk.EventProximityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetProximityOutEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetQueryTooltipDetail struct {
	callback  WidgetSignalQueryTooltipCallback
	handlerID C.gulong
}

var signalWidgetQueryTooltipId int
var signalWidgetQueryTooltipMap = make(map[int]signalWidgetQueryTooltipDetail)
var signalWidgetQueryTooltipLock sync.RWMutex

// WidgetSignalQueryTooltipCallback is a callback function for a 'query-tooltip' signal emitted from a Widget.
type WidgetSignalQueryTooltipCallback func(x int32, y int32, keyboardMode bool, tooltip *Tooltip) bool

/*
ConnectQueryTooltip connects the callback to the 'query-tooltip' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectQueryTooltip to remove it.
*/
func (recv *Widget) ConnectQueryTooltip(callback WidgetSignalQueryTooltipCallback) int {
	signalWidgetQueryTooltipLock.Lock()
	defer signalWidgetQueryTooltipLock.Unlock()

	signalWidgetQueryTooltipId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_query_tooltip(instance, C.gpointer(uintptr(signalWidgetQueryTooltipId)))

	detail := signalWidgetQueryTooltipDetail{callback, handlerID}
	signalWidgetQueryTooltipMap[signalWidgetQueryTooltipId] = detail

	return signalWidgetQueryTooltipId
}

/*
DisconnectQueryTooltip disconnects a callback from the 'query-tooltip' signal for the Widget.

The connectionID should be a value returned from a call to ConnectQueryTooltip.
*/
func (recv *Widget) DisconnectQueryTooltip(connectionID int) {
	signalWidgetQueryTooltipLock.Lock()
	defer signalWidgetQueryTooltipLock.Unlock()

	detail, exists := signalWidgetQueryTooltipMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetQueryTooltipMap, connectionID)
}

//export widget_queryTooltipHandler
func widget_queryTooltipHandler(_ *C.GObject, c_x C.gint, c_y C.gint, c_keyboard_mode C.gboolean, c_tooltip *C.GtkTooltip, data C.gpointer) C.gboolean {
	signalWidgetQueryTooltipLock.RLock()
	defer signalWidgetQueryTooltipLock.RUnlock()

	x := int32(c_x)

	y := int32(c_y)

	keyboardMode := c_keyboard_mode == C.TRUE

	tooltip := TooltipNewFromC(unsafe.Pointer(c_tooltip))

	index := int(uintptr(data))
	callback := signalWidgetQueryTooltipMap[index].callback
	retGo := callback(x, y, keyboardMode, tooltip)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetRealizeDetail struct {
	callback  WidgetSignalRealizeCallback
	handlerID C.gulong
}

var signalWidgetRealizeId int
var signalWidgetRealizeMap = make(map[int]signalWidgetRealizeDetail)
var signalWidgetRealizeLock sync.RWMutex

// WidgetSignalRealizeCallback is a callback function for a 'realize' signal emitted from a Widget.
type WidgetSignalRealizeCallback func()

/*
ConnectRealize connects the callback to the 'realize' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectRealize to remove it.
*/
func (recv *Widget) ConnectRealize(callback WidgetSignalRealizeCallback) int {
	signalWidgetRealizeLock.Lock()
	defer signalWidgetRealizeLock.Unlock()

	signalWidgetRealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_realize(instance, C.gpointer(uintptr(signalWidgetRealizeId)))

	detail := signalWidgetRealizeDetail{callback, handlerID}
	signalWidgetRealizeMap[signalWidgetRealizeId] = detail

	return signalWidgetRealizeId
}

/*
DisconnectRealize disconnects a callback from the 'realize' signal for the Widget.

The connectionID should be a value returned from a call to ConnectRealize.
*/
func (recv *Widget) DisconnectRealize(connectionID int) {
	signalWidgetRealizeLock.Lock()
	defer signalWidgetRealizeLock.Unlock()

	detail, exists := signalWidgetRealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetRealizeMap, connectionID)
}

//export widget_realizeHandler
func widget_realizeHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetRealizeLock.RLock()
	defer signalWidgetRealizeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetRealizeMap[index].callback
	callback()
}

type signalWidgetScreenChangedDetail struct {
	callback  WidgetSignalScreenChangedCallback
	handlerID C.gulong
}

var signalWidgetScreenChangedId int
var signalWidgetScreenChangedMap = make(map[int]signalWidgetScreenChangedDetail)
var signalWidgetScreenChangedLock sync.RWMutex

// WidgetSignalScreenChangedCallback is a callback function for a 'screen-changed' signal emitted from a Widget.
type WidgetSignalScreenChangedCallback func(previousScreen *gdk.Screen)

/*
ConnectScreenChanged connects the callback to the 'screen-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectScreenChanged to remove it.
*/
func (recv *Widget) ConnectScreenChanged(callback WidgetSignalScreenChangedCallback) int {
	signalWidgetScreenChangedLock.Lock()
	defer signalWidgetScreenChangedLock.Unlock()

	signalWidgetScreenChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_screen_changed(instance, C.gpointer(uintptr(signalWidgetScreenChangedId)))

	detail := signalWidgetScreenChangedDetail{callback, handlerID}
	signalWidgetScreenChangedMap[signalWidgetScreenChangedId] = detail

	return signalWidgetScreenChangedId
}

/*
DisconnectScreenChanged disconnects a callback from the 'screen-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectScreenChanged.
*/
func (recv *Widget) DisconnectScreenChanged(connectionID int) {
	signalWidgetScreenChangedLock.Lock()
	defer signalWidgetScreenChangedLock.Unlock()

	detail, exists := signalWidgetScreenChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetScreenChangedMap, connectionID)
}

//export widget_screenChangedHandler
func widget_screenChangedHandler(_ *C.GObject, c_previous_screen *C.GdkScreen, data C.gpointer) {
	signalWidgetScreenChangedLock.RLock()
	defer signalWidgetScreenChangedLock.RUnlock()

	previousScreen := gdk.ScreenNewFromC(unsafe.Pointer(c_previous_screen))

	index := int(uintptr(data))
	callback := signalWidgetScreenChangedMap[index].callback
	callback(previousScreen)
}

type signalWidgetScrollEventDetail struct {
	callback  WidgetSignalScrollEventCallback
	handlerID C.gulong
}

var signalWidgetScrollEventId int
var signalWidgetScrollEventMap = make(map[int]signalWidgetScrollEventDetail)
var signalWidgetScrollEventLock sync.RWMutex

// WidgetSignalScrollEventCallback is a callback function for a 'scroll-event' signal emitted from a Widget.
type WidgetSignalScrollEventCallback func(event *gdk.EventScroll) bool

/*
ConnectScrollEvent connects the callback to the 'scroll-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectScrollEvent to remove it.
*/
func (recv *Widget) ConnectScrollEvent(callback WidgetSignalScrollEventCallback) int {
	signalWidgetScrollEventLock.Lock()
	defer signalWidgetScrollEventLock.Unlock()

	signalWidgetScrollEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_scroll_event(instance, C.gpointer(uintptr(signalWidgetScrollEventId)))

	detail := signalWidgetScrollEventDetail{callback, handlerID}
	signalWidgetScrollEventMap[signalWidgetScrollEventId] = detail

	return signalWidgetScrollEventId
}

/*
DisconnectScrollEvent disconnects a callback from the 'scroll-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectScrollEvent.
*/
func (recv *Widget) DisconnectScrollEvent(connectionID int) {
	signalWidgetScrollEventLock.Lock()
	defer signalWidgetScrollEventLock.Unlock()

	detail, exists := signalWidgetScrollEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetScrollEventMap, connectionID)
}

//export widget_scrollEventHandler
func widget_scrollEventHandler(_ *C.GObject, c_event *C.GdkEventScroll, data C.gpointer) C.gboolean {
	signalWidgetScrollEventLock.RLock()
	defer signalWidgetScrollEventLock.RUnlock()

	event := gdk.EventScrollNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetScrollEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSelectionClearEventDetail struct {
	callback  WidgetSignalSelectionClearEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionClearEventId int
var signalWidgetSelectionClearEventMap = make(map[int]signalWidgetSelectionClearEventDetail)
var signalWidgetSelectionClearEventLock sync.RWMutex

// WidgetSignalSelectionClearEventCallback is a callback function for a 'selection-clear-event' signal emitted from a Widget.
type WidgetSignalSelectionClearEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionClearEvent connects the callback to the 'selection-clear-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionClearEvent to remove it.
*/
func (recv *Widget) ConnectSelectionClearEvent(callback WidgetSignalSelectionClearEventCallback) int {
	signalWidgetSelectionClearEventLock.Lock()
	defer signalWidgetSelectionClearEventLock.Unlock()

	signalWidgetSelectionClearEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_clear_event(instance, C.gpointer(uintptr(signalWidgetSelectionClearEventId)))

	detail := signalWidgetSelectionClearEventDetail{callback, handlerID}
	signalWidgetSelectionClearEventMap[signalWidgetSelectionClearEventId] = detail

	return signalWidgetSelectionClearEventId
}

/*
DisconnectSelectionClearEvent disconnects a callback from the 'selection-clear-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionClearEvent.
*/
func (recv *Widget) DisconnectSelectionClearEvent(connectionID int) {
	signalWidgetSelectionClearEventLock.Lock()
	defer signalWidgetSelectionClearEventLock.Unlock()

	detail, exists := signalWidgetSelectionClearEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionClearEventMap, connectionID)
}

//export widget_selectionClearEventHandler
func widget_selectionClearEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	signalWidgetSelectionClearEventLock.RLock()
	defer signalWidgetSelectionClearEventLock.RUnlock()

	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionClearEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSelectionGetDetail struct {
	callback  WidgetSignalSelectionGetCallback
	handlerID C.gulong
}

var signalWidgetSelectionGetId int
var signalWidgetSelectionGetMap = make(map[int]signalWidgetSelectionGetDetail)
var signalWidgetSelectionGetLock sync.RWMutex

// WidgetSignalSelectionGetCallback is a callback function for a 'selection-get' signal emitted from a Widget.
type WidgetSignalSelectionGetCallback func(Data *SelectionData, info uint32, time uint32)

/*
ConnectSelectionGet connects the callback to the 'selection-get' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionGet to remove it.
*/
func (recv *Widget) ConnectSelectionGet(callback WidgetSignalSelectionGetCallback) int {
	signalWidgetSelectionGetLock.Lock()
	defer signalWidgetSelectionGetLock.Unlock()

	signalWidgetSelectionGetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_get(instance, C.gpointer(uintptr(signalWidgetSelectionGetId)))

	detail := signalWidgetSelectionGetDetail{callback, handlerID}
	signalWidgetSelectionGetMap[signalWidgetSelectionGetId] = detail

	return signalWidgetSelectionGetId
}

/*
DisconnectSelectionGet disconnects a callback from the 'selection-get' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionGet.
*/
func (recv *Widget) DisconnectSelectionGet(connectionID int) {
	signalWidgetSelectionGetLock.Lock()
	defer signalWidgetSelectionGetLock.Unlock()

	detail, exists := signalWidgetSelectionGetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionGetMap, connectionID)
}

//export widget_selectionGetHandler
func widget_selectionGetHandler(_ *C.GObject, c__data *C.GtkSelectionData, c_info C.guint, c_time C.guint, data C.gpointer) {
	signalWidgetSelectionGetLock.RLock()
	defer signalWidgetSelectionGetLock.RUnlock()

	Data := SelectionDataNewFromC(unsafe.Pointer(c__data))

	info := uint32(c_info)

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetSelectionGetMap[index].callback
	callback(Data, info, time)
}

type signalWidgetSelectionNotifyEventDetail struct {
	callback  WidgetSignalSelectionNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionNotifyEventId int
var signalWidgetSelectionNotifyEventMap = make(map[int]signalWidgetSelectionNotifyEventDetail)
var signalWidgetSelectionNotifyEventLock sync.RWMutex

// WidgetSignalSelectionNotifyEventCallback is a callback function for a 'selection-notify-event' signal emitted from a Widget.
type WidgetSignalSelectionNotifyEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionNotifyEvent connects the callback to the 'selection-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionNotifyEvent to remove it.
*/
func (recv *Widget) ConnectSelectionNotifyEvent(callback WidgetSignalSelectionNotifyEventCallback) int {
	signalWidgetSelectionNotifyEventLock.Lock()
	defer signalWidgetSelectionNotifyEventLock.Unlock()

	signalWidgetSelectionNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_notify_event(instance, C.gpointer(uintptr(signalWidgetSelectionNotifyEventId)))

	detail := signalWidgetSelectionNotifyEventDetail{callback, handlerID}
	signalWidgetSelectionNotifyEventMap[signalWidgetSelectionNotifyEventId] = detail

	return signalWidgetSelectionNotifyEventId
}

/*
DisconnectSelectionNotifyEvent disconnects a callback from the 'selection-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionNotifyEvent.
*/
func (recv *Widget) DisconnectSelectionNotifyEvent(connectionID int) {
	signalWidgetSelectionNotifyEventLock.Lock()
	defer signalWidgetSelectionNotifyEventLock.Unlock()

	detail, exists := signalWidgetSelectionNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionNotifyEventMap, connectionID)
}

//export widget_selectionNotifyEventHandler
func widget_selectionNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	signalWidgetSelectionNotifyEventLock.RLock()
	defer signalWidgetSelectionNotifyEventLock.RUnlock()

	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSelectionReceivedDetail struct {
	callback  WidgetSignalSelectionReceivedCallback
	handlerID C.gulong
}

var signalWidgetSelectionReceivedId int
var signalWidgetSelectionReceivedMap = make(map[int]signalWidgetSelectionReceivedDetail)
var signalWidgetSelectionReceivedLock sync.RWMutex

// WidgetSignalSelectionReceivedCallback is a callback function for a 'selection-received' signal emitted from a Widget.
type WidgetSignalSelectionReceivedCallback func(Data *SelectionData, time uint32)

/*
ConnectSelectionReceived connects the callback to the 'selection-received' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionReceived to remove it.
*/
func (recv *Widget) ConnectSelectionReceived(callback WidgetSignalSelectionReceivedCallback) int {
	signalWidgetSelectionReceivedLock.Lock()
	defer signalWidgetSelectionReceivedLock.Unlock()

	signalWidgetSelectionReceivedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_received(instance, C.gpointer(uintptr(signalWidgetSelectionReceivedId)))

	detail := signalWidgetSelectionReceivedDetail{callback, handlerID}
	signalWidgetSelectionReceivedMap[signalWidgetSelectionReceivedId] = detail

	return signalWidgetSelectionReceivedId
}

/*
DisconnectSelectionReceived disconnects a callback from the 'selection-received' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionReceived.
*/
func (recv *Widget) DisconnectSelectionReceived(connectionID int) {
	signalWidgetSelectionReceivedLock.Lock()
	defer signalWidgetSelectionReceivedLock.Unlock()

	detail, exists := signalWidgetSelectionReceivedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionReceivedMap, connectionID)
}

//export widget_selectionReceivedHandler
func widget_selectionReceivedHandler(_ *C.GObject, c__data *C.GtkSelectionData, c_time C.guint, data C.gpointer) {
	signalWidgetSelectionReceivedLock.RLock()
	defer signalWidgetSelectionReceivedLock.RUnlock()

	Data := SelectionDataNewFromC(unsafe.Pointer(c__data))

	time := uint32(c_time)

	index := int(uintptr(data))
	callback := signalWidgetSelectionReceivedMap[index].callback
	callback(Data, time)
}

type signalWidgetSelectionRequestEventDetail struct {
	callback  WidgetSignalSelectionRequestEventCallback
	handlerID C.gulong
}

var signalWidgetSelectionRequestEventId int
var signalWidgetSelectionRequestEventMap = make(map[int]signalWidgetSelectionRequestEventDetail)
var signalWidgetSelectionRequestEventLock sync.RWMutex

// WidgetSignalSelectionRequestEventCallback is a callback function for a 'selection-request-event' signal emitted from a Widget.
type WidgetSignalSelectionRequestEventCallback func(event *gdk.EventSelection) bool

/*
ConnectSelectionRequestEvent connects the callback to the 'selection-request-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSelectionRequestEvent to remove it.
*/
func (recv *Widget) ConnectSelectionRequestEvent(callback WidgetSignalSelectionRequestEventCallback) int {
	signalWidgetSelectionRequestEventLock.Lock()
	defer signalWidgetSelectionRequestEventLock.Unlock()

	signalWidgetSelectionRequestEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_selection_request_event(instance, C.gpointer(uintptr(signalWidgetSelectionRequestEventId)))

	detail := signalWidgetSelectionRequestEventDetail{callback, handlerID}
	signalWidgetSelectionRequestEventMap[signalWidgetSelectionRequestEventId] = detail

	return signalWidgetSelectionRequestEventId
}

/*
DisconnectSelectionRequestEvent disconnects a callback from the 'selection-request-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSelectionRequestEvent.
*/
func (recv *Widget) DisconnectSelectionRequestEvent(connectionID int) {
	signalWidgetSelectionRequestEventLock.Lock()
	defer signalWidgetSelectionRequestEventLock.Unlock()

	detail, exists := signalWidgetSelectionRequestEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSelectionRequestEventMap, connectionID)
}

//export widget_selectionRequestEventHandler
func widget_selectionRequestEventHandler(_ *C.GObject, c_event *C.GdkEventSelection, data C.gpointer) C.gboolean {
	signalWidgetSelectionRequestEventLock.RLock()
	defer signalWidgetSelectionRequestEventLock.RUnlock()

	event := gdk.EventSelectionNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetSelectionRequestEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetShowDetail struct {
	callback  WidgetSignalShowCallback
	handlerID C.gulong
}

var signalWidgetShowId int
var signalWidgetShowMap = make(map[int]signalWidgetShowDetail)
var signalWidgetShowLock sync.RWMutex

// WidgetSignalShowCallback is a callback function for a 'show' signal emitted from a Widget.
type WidgetSignalShowCallback func()

/*
ConnectShow connects the callback to the 'show' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectShow to remove it.
*/
func (recv *Widget) ConnectShow(callback WidgetSignalShowCallback) int {
	signalWidgetShowLock.Lock()
	defer signalWidgetShowLock.Unlock()

	signalWidgetShowId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_show(instance, C.gpointer(uintptr(signalWidgetShowId)))

	detail := signalWidgetShowDetail{callback, handlerID}
	signalWidgetShowMap[signalWidgetShowId] = detail

	return signalWidgetShowId
}

/*
DisconnectShow disconnects a callback from the 'show' signal for the Widget.

The connectionID should be a value returned from a call to ConnectShow.
*/
func (recv *Widget) DisconnectShow(connectionID int) {
	signalWidgetShowLock.Lock()
	defer signalWidgetShowLock.Unlock()

	detail, exists := signalWidgetShowMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetShowMap, connectionID)
}

//export widget_showHandler
func widget_showHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetShowLock.RLock()
	defer signalWidgetShowLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetShowMap[index].callback
	callback()
}

type signalWidgetShowHelpDetail struct {
	callback  WidgetSignalShowHelpCallback
	handlerID C.gulong
}

var signalWidgetShowHelpId int
var signalWidgetShowHelpMap = make(map[int]signalWidgetShowHelpDetail)
var signalWidgetShowHelpLock sync.RWMutex

// WidgetSignalShowHelpCallback is a callback function for a 'show-help' signal emitted from a Widget.
type WidgetSignalShowHelpCallback func(helpType WidgetHelpType) bool

/*
ConnectShowHelp connects the callback to the 'show-help' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectShowHelp to remove it.
*/
func (recv *Widget) ConnectShowHelp(callback WidgetSignalShowHelpCallback) int {
	signalWidgetShowHelpLock.Lock()
	defer signalWidgetShowHelpLock.Unlock()

	signalWidgetShowHelpId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_show_help(instance, C.gpointer(uintptr(signalWidgetShowHelpId)))

	detail := signalWidgetShowHelpDetail{callback, handlerID}
	signalWidgetShowHelpMap[signalWidgetShowHelpId] = detail

	return signalWidgetShowHelpId
}

/*
DisconnectShowHelp disconnects a callback from the 'show-help' signal for the Widget.

The connectionID should be a value returned from a call to ConnectShowHelp.
*/
func (recv *Widget) DisconnectShowHelp(connectionID int) {
	signalWidgetShowHelpLock.Lock()
	defer signalWidgetShowHelpLock.Unlock()

	detail, exists := signalWidgetShowHelpMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetShowHelpMap, connectionID)
}

//export widget_showHelpHandler
func widget_showHelpHandler(_ *C.GObject, c_help_type C.GtkWidgetHelpType, data C.gpointer) C.gboolean {
	signalWidgetShowHelpLock.RLock()
	defer signalWidgetShowHelpLock.RUnlock()

	helpType := WidgetHelpType(c_help_type)

	index := int(uintptr(data))
	callback := signalWidgetShowHelpMap[index].callback
	retGo := callback(helpType)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetSizeAllocateDetail struct {
	callback  WidgetSignalSizeAllocateCallback
	handlerID C.gulong
}

var signalWidgetSizeAllocateId int
var signalWidgetSizeAllocateMap = make(map[int]signalWidgetSizeAllocateDetail)
var signalWidgetSizeAllocateLock sync.RWMutex

// WidgetSignalSizeAllocateCallback is a callback function for a 'size-allocate' signal emitted from a Widget.
type WidgetSignalSizeAllocateCallback func(allocation *gdk.Rectangle)

/*
ConnectSizeAllocate connects the callback to the 'size-allocate' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectSizeAllocate to remove it.
*/
func (recv *Widget) ConnectSizeAllocate(callback WidgetSignalSizeAllocateCallback) int {
	signalWidgetSizeAllocateLock.Lock()
	defer signalWidgetSizeAllocateLock.Unlock()

	signalWidgetSizeAllocateId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_size_allocate(instance, C.gpointer(uintptr(signalWidgetSizeAllocateId)))

	detail := signalWidgetSizeAllocateDetail{callback, handlerID}
	signalWidgetSizeAllocateMap[signalWidgetSizeAllocateId] = detail

	return signalWidgetSizeAllocateId
}

/*
DisconnectSizeAllocate disconnects a callback from the 'size-allocate' signal for the Widget.

The connectionID should be a value returned from a call to ConnectSizeAllocate.
*/
func (recv *Widget) DisconnectSizeAllocate(connectionID int) {
	signalWidgetSizeAllocateLock.Lock()
	defer signalWidgetSizeAllocateLock.Unlock()

	detail, exists := signalWidgetSizeAllocateMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetSizeAllocateMap, connectionID)
}

//export widget_sizeAllocateHandler
func widget_sizeAllocateHandler(_ *C.GObject, c_allocation *C.GdkRectangle, data C.gpointer) {
	signalWidgetSizeAllocateLock.RLock()
	defer signalWidgetSizeAllocateLock.RUnlock()

	allocation := gdk.RectangleNewFromC(unsafe.Pointer(c_allocation))

	index := int(uintptr(data))
	callback := signalWidgetSizeAllocateMap[index].callback
	callback(allocation)
}

type signalWidgetStateChangedDetail struct {
	callback  WidgetSignalStateChangedCallback
	handlerID C.gulong
}

var signalWidgetStateChangedId int
var signalWidgetStateChangedMap = make(map[int]signalWidgetStateChangedDetail)
var signalWidgetStateChangedLock sync.RWMutex

// WidgetSignalStateChangedCallback is a callback function for a 'state-changed' signal emitted from a Widget.
type WidgetSignalStateChangedCallback func(state StateType)

/*
ConnectStateChanged connects the callback to the 'state-changed' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectStateChanged to remove it.
*/
func (recv *Widget) ConnectStateChanged(callback WidgetSignalStateChangedCallback) int {
	signalWidgetStateChangedLock.Lock()
	defer signalWidgetStateChangedLock.Unlock()

	signalWidgetStateChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_state_changed(instance, C.gpointer(uintptr(signalWidgetStateChangedId)))

	detail := signalWidgetStateChangedDetail{callback, handlerID}
	signalWidgetStateChangedMap[signalWidgetStateChangedId] = detail

	return signalWidgetStateChangedId
}

/*
DisconnectStateChanged disconnects a callback from the 'state-changed' signal for the Widget.

The connectionID should be a value returned from a call to ConnectStateChanged.
*/
func (recv *Widget) DisconnectStateChanged(connectionID int) {
	signalWidgetStateChangedLock.Lock()
	defer signalWidgetStateChangedLock.Unlock()

	detail, exists := signalWidgetStateChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetStateChangedMap, connectionID)
}

//export widget_stateChangedHandler
func widget_stateChangedHandler(_ *C.GObject, c_state C.GtkStateType, data C.gpointer) {
	signalWidgetStateChangedLock.RLock()
	defer signalWidgetStateChangedLock.RUnlock()

	state := StateType(c_state)

	index := int(uintptr(data))
	callback := signalWidgetStateChangedMap[index].callback
	callback(state)
}

type signalWidgetStyleSetDetail struct {
	callback  WidgetSignalStyleSetCallback
	handlerID C.gulong
}

var signalWidgetStyleSetId int
var signalWidgetStyleSetMap = make(map[int]signalWidgetStyleSetDetail)
var signalWidgetStyleSetLock sync.RWMutex

// WidgetSignalStyleSetCallback is a callback function for a 'style-set' signal emitted from a Widget.
type WidgetSignalStyleSetCallback func(previousStyle *Style)

/*
ConnectStyleSet connects the callback to the 'style-set' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectStyleSet to remove it.
*/
func (recv *Widget) ConnectStyleSet(callback WidgetSignalStyleSetCallback) int {
	signalWidgetStyleSetLock.Lock()
	defer signalWidgetStyleSetLock.Unlock()

	signalWidgetStyleSetId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_style_set(instance, C.gpointer(uintptr(signalWidgetStyleSetId)))

	detail := signalWidgetStyleSetDetail{callback, handlerID}
	signalWidgetStyleSetMap[signalWidgetStyleSetId] = detail

	return signalWidgetStyleSetId
}

/*
DisconnectStyleSet disconnects a callback from the 'style-set' signal for the Widget.

The connectionID should be a value returned from a call to ConnectStyleSet.
*/
func (recv *Widget) DisconnectStyleSet(connectionID int) {
	signalWidgetStyleSetLock.Lock()
	defer signalWidgetStyleSetLock.Unlock()

	detail, exists := signalWidgetStyleSetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetStyleSetMap, connectionID)
}

//export widget_styleSetHandler
func widget_styleSetHandler(_ *C.GObject, c_previous_style *C.GtkStyle, data C.gpointer) {
	signalWidgetStyleSetLock.RLock()
	defer signalWidgetStyleSetLock.RUnlock()

	previousStyle := StyleNewFromC(unsafe.Pointer(c_previous_style))

	index := int(uintptr(data))
	callback := signalWidgetStyleSetMap[index].callback
	callback(previousStyle)
}

type signalWidgetTouchEventDetail struct {
	callback  WidgetSignalTouchEventCallback
	handlerID C.gulong
}

var signalWidgetTouchEventId int
var signalWidgetTouchEventMap = make(map[int]signalWidgetTouchEventDetail)
var signalWidgetTouchEventLock sync.RWMutex

// WidgetSignalTouchEventCallback is a callback function for a 'touch-event' signal emitted from a Widget.
type WidgetSignalTouchEventCallback func(object *gdk.Event) bool

/*
ConnectTouchEvent connects the callback to the 'touch-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectTouchEvent to remove it.
*/
func (recv *Widget) ConnectTouchEvent(callback WidgetSignalTouchEventCallback) int {
	signalWidgetTouchEventLock.Lock()
	defer signalWidgetTouchEventLock.Unlock()

	signalWidgetTouchEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_touch_event(instance, C.gpointer(uintptr(signalWidgetTouchEventId)))

	detail := signalWidgetTouchEventDetail{callback, handlerID}
	signalWidgetTouchEventMap[signalWidgetTouchEventId] = detail

	return signalWidgetTouchEventId
}

/*
DisconnectTouchEvent disconnects a callback from the 'touch-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectTouchEvent.
*/
func (recv *Widget) DisconnectTouchEvent(connectionID int) {
	signalWidgetTouchEventLock.Lock()
	defer signalWidgetTouchEventLock.Unlock()

	detail, exists := signalWidgetTouchEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetTouchEventMap, connectionID)
}

//export widget_touchEventHandler
func widget_touchEventHandler(_ *C.GObject, c_object *C.GdkEvent_, data C.gpointer) C.gboolean {
	signalWidgetTouchEventLock.RLock()
	defer signalWidgetTouchEventLock.RUnlock()

	object := gdk.EventNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalWidgetTouchEventMap[index].callback
	retGo := callback(object)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetUnmapDetail struct {
	callback  WidgetSignalUnmapCallback
	handlerID C.gulong
}

var signalWidgetUnmapId int
var signalWidgetUnmapMap = make(map[int]signalWidgetUnmapDetail)
var signalWidgetUnmapLock sync.RWMutex

// WidgetSignalUnmapCallback is a callback function for a 'unmap' signal emitted from a Widget.
type WidgetSignalUnmapCallback func()

/*
ConnectUnmap connects the callback to the 'unmap' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnmap to remove it.
*/
func (recv *Widget) ConnectUnmap(callback WidgetSignalUnmapCallback) int {
	signalWidgetUnmapLock.Lock()
	defer signalWidgetUnmapLock.Unlock()

	signalWidgetUnmapId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unmap(instance, C.gpointer(uintptr(signalWidgetUnmapId)))

	detail := signalWidgetUnmapDetail{callback, handlerID}
	signalWidgetUnmapMap[signalWidgetUnmapId] = detail

	return signalWidgetUnmapId
}

/*
DisconnectUnmap disconnects a callback from the 'unmap' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnmap.
*/
func (recv *Widget) DisconnectUnmap(connectionID int) {
	signalWidgetUnmapLock.Lock()
	defer signalWidgetUnmapLock.Unlock()

	detail, exists := signalWidgetUnmapMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnmapMap, connectionID)
}

//export widget_unmapHandler
func widget_unmapHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetUnmapLock.RLock()
	defer signalWidgetUnmapLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetUnmapMap[index].callback
	callback()
}

type signalWidgetUnmapEventDetail struct {
	callback  WidgetSignalUnmapEventCallback
	handlerID C.gulong
}

var signalWidgetUnmapEventId int
var signalWidgetUnmapEventMap = make(map[int]signalWidgetUnmapEventDetail)
var signalWidgetUnmapEventLock sync.RWMutex

// WidgetSignalUnmapEventCallback is a callback function for a 'unmap-event' signal emitted from a Widget.
type WidgetSignalUnmapEventCallback func(event *gdk.EventAny) bool

/*
ConnectUnmapEvent connects the callback to the 'unmap-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnmapEvent to remove it.
*/
func (recv *Widget) ConnectUnmapEvent(callback WidgetSignalUnmapEventCallback) int {
	signalWidgetUnmapEventLock.Lock()
	defer signalWidgetUnmapEventLock.Unlock()

	signalWidgetUnmapEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unmap_event(instance, C.gpointer(uintptr(signalWidgetUnmapEventId)))

	detail := signalWidgetUnmapEventDetail{callback, handlerID}
	signalWidgetUnmapEventMap[signalWidgetUnmapEventId] = detail

	return signalWidgetUnmapEventId
}

/*
DisconnectUnmapEvent disconnects a callback from the 'unmap-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnmapEvent.
*/
func (recv *Widget) DisconnectUnmapEvent(connectionID int) {
	signalWidgetUnmapEventLock.Lock()
	defer signalWidgetUnmapEventLock.Unlock()

	detail, exists := signalWidgetUnmapEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnmapEventMap, connectionID)
}

//export widget_unmapEventHandler
func widget_unmapEventHandler(_ *C.GObject, c_event *C.GdkEventAny, data C.gpointer) C.gboolean {
	signalWidgetUnmapEventLock.RLock()
	defer signalWidgetUnmapEventLock.RUnlock()

	event := gdk.EventAnyNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetUnmapEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetUnrealizeDetail struct {
	callback  WidgetSignalUnrealizeCallback
	handlerID C.gulong
}

var signalWidgetUnrealizeId int
var signalWidgetUnrealizeMap = make(map[int]signalWidgetUnrealizeDetail)
var signalWidgetUnrealizeLock sync.RWMutex

// WidgetSignalUnrealizeCallback is a callback function for a 'unrealize' signal emitted from a Widget.
type WidgetSignalUnrealizeCallback func()

/*
ConnectUnrealize connects the callback to the 'unrealize' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectUnrealize to remove it.
*/
func (recv *Widget) ConnectUnrealize(callback WidgetSignalUnrealizeCallback) int {
	signalWidgetUnrealizeLock.Lock()
	defer signalWidgetUnrealizeLock.Unlock()

	signalWidgetUnrealizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_unrealize(instance, C.gpointer(uintptr(signalWidgetUnrealizeId)))

	detail := signalWidgetUnrealizeDetail{callback, handlerID}
	signalWidgetUnrealizeMap[signalWidgetUnrealizeId] = detail

	return signalWidgetUnrealizeId
}

/*
DisconnectUnrealize disconnects a callback from the 'unrealize' signal for the Widget.

The connectionID should be a value returned from a call to ConnectUnrealize.
*/
func (recv *Widget) DisconnectUnrealize(connectionID int) {
	signalWidgetUnrealizeLock.Lock()
	defer signalWidgetUnrealizeLock.Unlock()

	detail, exists := signalWidgetUnrealizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetUnrealizeMap, connectionID)
}

//export widget_unrealizeHandler
func widget_unrealizeHandler(_ *C.GObject, data C.gpointer) {
	signalWidgetUnrealizeLock.RLock()
	defer signalWidgetUnrealizeLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWidgetUnrealizeMap[index].callback
	callback()
}

type signalWidgetVisibilityNotifyEventDetail struct {
	callback  WidgetSignalVisibilityNotifyEventCallback
	handlerID C.gulong
}

var signalWidgetVisibilityNotifyEventId int
var signalWidgetVisibilityNotifyEventMap = make(map[int]signalWidgetVisibilityNotifyEventDetail)
var signalWidgetVisibilityNotifyEventLock sync.RWMutex

// WidgetSignalVisibilityNotifyEventCallback is a callback function for a 'visibility-notify-event' signal emitted from a Widget.
type WidgetSignalVisibilityNotifyEventCallback func(event *gdk.EventVisibility) bool

/*
ConnectVisibilityNotifyEvent connects the callback to the 'visibility-notify-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectVisibilityNotifyEvent to remove it.
*/
func (recv *Widget) ConnectVisibilityNotifyEvent(callback WidgetSignalVisibilityNotifyEventCallback) int {
	signalWidgetVisibilityNotifyEventLock.Lock()
	defer signalWidgetVisibilityNotifyEventLock.Unlock()

	signalWidgetVisibilityNotifyEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_visibility_notify_event(instance, C.gpointer(uintptr(signalWidgetVisibilityNotifyEventId)))

	detail := signalWidgetVisibilityNotifyEventDetail{callback, handlerID}
	signalWidgetVisibilityNotifyEventMap[signalWidgetVisibilityNotifyEventId] = detail

	return signalWidgetVisibilityNotifyEventId
}

/*
DisconnectVisibilityNotifyEvent disconnects a callback from the 'visibility-notify-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectVisibilityNotifyEvent.
*/
func (recv *Widget) DisconnectVisibilityNotifyEvent(connectionID int) {
	signalWidgetVisibilityNotifyEventLock.Lock()
	defer signalWidgetVisibilityNotifyEventLock.Unlock()

	detail, exists := signalWidgetVisibilityNotifyEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetVisibilityNotifyEventMap, connectionID)
}

//export widget_visibilityNotifyEventHandler
func widget_visibilityNotifyEventHandler(_ *C.GObject, c_event *C.GdkEventVisibility, data C.gpointer) C.gboolean {
	signalWidgetVisibilityNotifyEventLock.RLock()
	defer signalWidgetVisibilityNotifyEventLock.RUnlock()

	event := gdk.EventVisibilityNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetVisibilityNotifyEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWidgetWindowStateEventDetail struct {
	callback  WidgetSignalWindowStateEventCallback
	handlerID C.gulong
}

var signalWidgetWindowStateEventId int
var signalWidgetWindowStateEventMap = make(map[int]signalWidgetWindowStateEventDetail)
var signalWidgetWindowStateEventLock sync.RWMutex

// WidgetSignalWindowStateEventCallback is a callback function for a 'window-state-event' signal emitted from a Widget.
type WidgetSignalWindowStateEventCallback func(event *gdk.EventWindowState) bool

/*
ConnectWindowStateEvent connects the callback to the 'window-state-event' signal for the Widget.

The returned value represents the connection, and may be passed to DisconnectWindowStateEvent to remove it.
*/
func (recv *Widget) ConnectWindowStateEvent(callback WidgetSignalWindowStateEventCallback) int {
	signalWidgetWindowStateEventLock.Lock()
	defer signalWidgetWindowStateEventLock.Unlock()

	signalWidgetWindowStateEventId++
	instance := C.gpointer(recv.native)
	handlerID := C.Widget_signal_connect_window_state_event(instance, C.gpointer(uintptr(signalWidgetWindowStateEventId)))

	detail := signalWidgetWindowStateEventDetail{callback, handlerID}
	signalWidgetWindowStateEventMap[signalWidgetWindowStateEventId] = detail

	return signalWidgetWindowStateEventId
}

/*
DisconnectWindowStateEvent disconnects a callback from the 'window-state-event' signal for the Widget.

The connectionID should be a value returned from a call to ConnectWindowStateEvent.
*/
func (recv *Widget) DisconnectWindowStateEvent(connectionID int) {
	signalWidgetWindowStateEventLock.Lock()
	defer signalWidgetWindowStateEventLock.Unlock()

	detail, exists := signalWidgetWindowStateEventMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWidgetWindowStateEventMap, connectionID)
}

//export widget_windowStateEventHandler
func widget_windowStateEventHandler(_ *C.GObject, c_event *C.GdkEventWindowState, data C.gpointer) C.gboolean {
	signalWidgetWindowStateEventLock.RLock()
	defer signalWidgetWindowStateEventLock.RUnlock()

	event := gdk.EventWindowStateNewFromC(unsafe.Pointer(c_event))

	index := int(uintptr(data))
	callback := signalWidgetWindowStateEventMap[index].callback
	retGo := callback(event)
	retC :=
		boolToGboolean(retGo)
	return retC
}

// Unsupported : gtk_widget_new : unsupported parameter ... : varargs

// WidgetGetDefaultDirection is a wrapper around the C function gtk_widget_get_default_direction.
func WidgetGetDefaultDirection() TextDirection {
	retC := C.gtk_widget_get_default_direction()
	retGo := (TextDirection)(retC)

	return retGo
}

// WidgetGetDefaultStyle is a wrapper around the C function gtk_widget_get_default_style.
func WidgetGetDefaultStyle() *Style {
	retC := C.gtk_widget_get_default_style()
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// WidgetPopCompositeChild is a wrapper around the C function gtk_widget_pop_composite_child.
func WidgetPopCompositeChild() {
	C.gtk_widget_pop_composite_child()

	return
}

// WidgetPushCompositeChild is a wrapper around the C function gtk_widget_push_composite_child.
func WidgetPushCompositeChild() {
	C.gtk_widget_push_composite_child()

	return
}

// WidgetSetDefaultDirection is a wrapper around the C function gtk_widget_set_default_direction.
func WidgetSetDefaultDirection(dir TextDirection) {
	c_dir := (C.GtkTextDirection)(dir)

	C.gtk_widget_set_default_direction(c_dir)

	return
}

// Activate is a wrapper around the C function gtk_widget_activate.
func (recv *Widget) Activate() bool {
	retC := C.gtk_widget_activate((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// AddAccelerator is a wrapper around the C function gtk_widget_add_accelerator.
func (recv *Widget) AddAccelerator(accelSignal string, accelGroup *AccelGroup, accelKey uint32, accelMods gdk.ModifierType, accelFlags AccelFlags) {
	c_accel_signal := C.CString(accelSignal)
	defer C.free(unsafe.Pointer(c_accel_signal))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	c_accel_flags := (C.GtkAccelFlags)(accelFlags)

	C.gtk_widget_add_accelerator((*C.GtkWidget)(recv.native), c_accel_signal, c_accel_group, c_accel_key, c_accel_mods, c_accel_flags)

	return
}

// AddEvents is a wrapper around the C function gtk_widget_add_events.
func (recv *Widget) AddEvents(events int32) {
	c_events := (C.gint)(events)

	C.gtk_widget_add_events((*C.GtkWidget)(recv.native), c_events)

	return
}

// AddMnemonicLabel is a wrapper around the C function gtk_widget_add_mnemonic_label.
func (recv *Widget) AddMnemonicLabel(label *Widget) {
	c_label := (*C.GtkWidget)(C.NULL)
	if label != nil {
		c_label = (*C.GtkWidget)(label.ToC())
	}

	C.gtk_widget_add_mnemonic_label((*C.GtkWidget)(recv.native), c_label)

	return
}

// CanActivateAccel is a wrapper around the C function gtk_widget_can_activate_accel.
func (recv *Widget) CanActivateAccel(signalId uint32) bool {
	c_signal_id := (C.guint)(signalId)

	retC := C.gtk_widget_can_activate_accel((*C.GtkWidget)(recv.native), c_signal_id)
	retGo := retC == C.TRUE

	return retGo
}

// ChildFocus is a wrapper around the C function gtk_widget_child_focus.
func (recv *Widget) ChildFocus(direction DirectionType) bool {
	c_direction := (C.GtkDirectionType)(direction)

	retC := C.gtk_widget_child_focus((*C.GtkWidget)(recv.native), c_direction)
	retGo := retC == C.TRUE

	return retGo
}

// ChildNotify is a wrapper around the C function gtk_widget_child_notify.
func (recv *Widget) ChildNotify(childProperty string) {
	c_child_property := C.CString(childProperty)
	defer C.free(unsafe.Pointer(c_child_property))

	C.gtk_widget_child_notify((*C.GtkWidget)(recv.native), c_child_property)

	return
}

// ClassPath is a wrapper around the C function gtk_widget_class_path.
func (recv *Widget) ClassPath() (uint32, string, string) {
	var c_path_length C.guint

	var c_path *C.gchar

	var c_path_reversed *C.gchar

	C.gtk_widget_class_path((*C.GtkWidget)(recv.native), &c_path_length, &c_path, &c_path_reversed)

	pathLength := (uint32)(c_path_length)

	path := C.GoString(c_path)
	defer C.free(unsafe.Pointer(c_path))

	pathReversed := C.GoString(c_path_reversed)
	defer C.free(unsafe.Pointer(c_path_reversed))

	return pathLength, path, pathReversed
}

// ComputeExpand is a wrapper around the C function gtk_widget_compute_expand.
func (recv *Widget) ComputeExpand(orientation Orientation) bool {
	c_orientation := (C.GtkOrientation)(orientation)

	retC := C.gtk_widget_compute_expand((*C.GtkWidget)(recv.native), c_orientation)
	retGo := retC == C.TRUE

	return retGo
}

// CreatePangoContext is a wrapper around the C function gtk_widget_create_pango_context.
func (recv *Widget) CreatePangoContext() *pango.Context {
	retC := C.gtk_widget_create_pango_context((*C.GtkWidget)(recv.native))
	retGo := pango.ContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CreatePangoLayout is a wrapper around the C function gtk_widget_create_pango_layout.
func (recv *Widget) CreatePangoLayout(text string) *pango.Layout {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	retC := C.gtk_widget_create_pango_layout((*C.GtkWidget)(recv.native), c_text)
	retGo := pango.LayoutNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Destroy is a wrapper around the C function gtk_widget_destroy.
func (recv *Widget) Destroy() {
	C.gtk_widget_destroy((*C.GtkWidget)(recv.native))

	return
}

// Destroyed is a wrapper around the C function gtk_widget_destroyed.
func (recv *Widget) Destroyed(widgetPointer *Widget) {
	c_widget_pointer := (**C.GtkWidget)(C.NULL)
	if widgetPointer != nil {
		c_widget_pointer = (**C.GtkWidget)(widgetPointer.ToC())
	}

	C.gtk_widget_destroyed((*C.GtkWidget)(recv.native), c_widget_pointer)

	return
}

// DragBegin is a wrapper around the C function gtk_drag_begin.
func (recv *Widget) DragBegin(targets *TargetList, actions gdk.DragAction, button int32, event *gdk.Event) *gdk.DragContext {
	c_targets := (*C.GtkTargetList)(C.NULL)
	if targets != nil {
		c_targets = (*C.GtkTargetList)(targets.ToC())
	}

	c_actions := (C.GdkDragAction)(actions)

	c_button := (C.gint)(button)

	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	retC := C.gtk_drag_begin((*C.GtkWidget)(recv.native), c_targets, c_actions, c_button, c_event)
	retGo := gdk.DragContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DragCheckThreshold is a wrapper around the C function gtk_drag_check_threshold.
func (recv *Widget) DragCheckThreshold(startX int32, startY int32, currentX int32, currentY int32) bool {
	c_start_x := (C.gint)(startX)

	c_start_y := (C.gint)(startY)

	c_current_x := (C.gint)(currentX)

	c_current_y := (C.gint)(currentY)

	retC := C.gtk_drag_check_threshold((*C.GtkWidget)(recv.native), c_start_x, c_start_y, c_current_x, c_current_y)
	retGo := retC == C.TRUE

	return retGo
}

// DragDestAddImageTargets is a wrapper around the C function gtk_drag_dest_add_image_targets.
func (recv *Widget) DragDestAddImageTargets() {
	C.gtk_drag_dest_add_image_targets((*C.GtkWidget)(recv.native))

	return
}

// DragDestAddTextTargets is a wrapper around the C function gtk_drag_dest_add_text_targets.
func (recv *Widget) DragDestAddTextTargets() {
	C.gtk_drag_dest_add_text_targets((*C.GtkWidget)(recv.native))

	return
}

// DragDestAddUriTargets is a wrapper around the C function gtk_drag_dest_add_uri_targets.
func (recv *Widget) DragDestAddUriTargets() {
	C.gtk_drag_dest_add_uri_targets((*C.GtkWidget)(recv.native))

	return
}

// DragDestFindTarget is a wrapper around the C function gtk_drag_dest_find_target.
func (recv *Widget) DragDestFindTarget(context *gdk.DragContext, targetList *TargetList) gdk.Atom {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	c_target_list := (*C.GtkTargetList)(C.NULL)
	if targetList != nil {
		c_target_list = (*C.GtkTargetList)(targetList.ToC())
	}

	retC := C.gtk_drag_dest_find_target((*C.GtkWidget)(recv.native), c_context, c_target_list)
	retGo := *gdk.AtomNewFromC(unsafe.Pointer(retC))

	return retGo
}

// DragDestGetTargetList is a wrapper around the C function gtk_drag_dest_get_target_list.
func (recv *Widget) DragDestGetTargetList() *TargetList {
	retC := C.gtk_drag_dest_get_target_list((*C.GtkWidget)(recv.native))
	var retGo (*TargetList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TargetListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// DragDestGetTrackMotion is a wrapper around the C function gtk_drag_dest_get_track_motion.
func (recv *Widget) DragDestGetTrackMotion() bool {
	retC := C.gtk_drag_dest_get_track_motion((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_drag_dest_set : unsupported parameter targets :

// DragDestSetProxy is a wrapper around the C function gtk_drag_dest_set_proxy.
func (recv *Widget) DragDestSetProxy(proxyWindow *gdk.Window, protocol gdk.DragProtocol, useCoordinates bool) {
	c_proxy_window := (*C.GdkWindow)(C.NULL)
	if proxyWindow != nil {
		c_proxy_window = (*C.GdkWindow)(proxyWindow.ToC())
	}

	c_protocol := (C.GdkDragProtocol)(protocol)

	c_use_coordinates :=
		boolToGboolean(useCoordinates)

	C.gtk_drag_dest_set_proxy((*C.GtkWidget)(recv.native), c_proxy_window, c_protocol, c_use_coordinates)

	return
}

// DragDestSetTargetList is a wrapper around the C function gtk_drag_dest_set_target_list.
func (recv *Widget) DragDestSetTargetList(targetList *TargetList) {
	c_target_list := (*C.GtkTargetList)(C.NULL)
	if targetList != nil {
		c_target_list = (*C.GtkTargetList)(targetList.ToC())
	}

	C.gtk_drag_dest_set_target_list((*C.GtkWidget)(recv.native), c_target_list)

	return
}

// DragDestSetTrackMotion is a wrapper around the C function gtk_drag_dest_set_track_motion.
func (recv *Widget) DragDestSetTrackMotion(trackMotion bool) {
	c_track_motion :=
		boolToGboolean(trackMotion)

	C.gtk_drag_dest_set_track_motion((*C.GtkWidget)(recv.native), c_track_motion)

	return
}

// DragDestUnset is a wrapper around the C function gtk_drag_dest_unset.
func (recv *Widget) DragDestUnset() {
	C.gtk_drag_dest_unset((*C.GtkWidget)(recv.native))

	return
}

// DragGetData is a wrapper around the C function gtk_drag_get_data.
func (recv *Widget) DragGetData(context *gdk.DragContext, target *gdk.Atom, time uint32) {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	c_target := (C.GdkAtom)(C.NULL)
	if target != nil {
		c_target = (C.GdkAtom)(target.ToC())
	}

	c_time_ := (C.guint32)(time)

	C.gtk_drag_get_data((*C.GtkWidget)(recv.native), c_context, c_target, c_time_)

	return
}

// DragHighlight is a wrapper around the C function gtk_drag_highlight.
func (recv *Widget) DragHighlight() {
	C.gtk_drag_highlight((*C.GtkWidget)(recv.native))

	return
}

// DragSourceAddImageTargets is a wrapper around the C function gtk_drag_source_add_image_targets.
func (recv *Widget) DragSourceAddImageTargets() {
	C.gtk_drag_source_add_image_targets((*C.GtkWidget)(recv.native))

	return
}

// DragSourceAddTextTargets is a wrapper around the C function gtk_drag_source_add_text_targets.
func (recv *Widget) DragSourceAddTextTargets() {
	C.gtk_drag_source_add_text_targets((*C.GtkWidget)(recv.native))

	return
}

// DragSourceAddUriTargets is a wrapper around the C function gtk_drag_source_add_uri_targets.
func (recv *Widget) DragSourceAddUriTargets() {
	C.gtk_drag_source_add_uri_targets((*C.GtkWidget)(recv.native))

	return
}

// DragSourceGetTargetList is a wrapper around the C function gtk_drag_source_get_target_list.
func (recv *Widget) DragSourceGetTargetList() *TargetList {
	retC := C.gtk_drag_source_get_target_list((*C.GtkWidget)(recv.native))
	var retGo (*TargetList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TargetListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_drag_source_set : unsupported parameter targets :

// DragSourceSetIconName is a wrapper around the C function gtk_drag_source_set_icon_name.
func (recv *Widget) DragSourceSetIconName(iconName string) {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	C.gtk_drag_source_set_icon_name((*C.GtkWidget)(recv.native), c_icon_name)

	return
}

// DragSourceSetIconPixbuf is a wrapper around the C function gtk_drag_source_set_icon_pixbuf.
func (recv *Widget) DragSourceSetIconPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_drag_source_set_icon_pixbuf((*C.GtkWidget)(recv.native), c_pixbuf)

	return
}

// DragSourceSetIconStock is a wrapper around the C function gtk_drag_source_set_icon_stock.
func (recv *Widget) DragSourceSetIconStock(stockId string) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	C.gtk_drag_source_set_icon_stock((*C.GtkWidget)(recv.native), c_stock_id)

	return
}

// DragSourceSetTargetList is a wrapper around the C function gtk_drag_source_set_target_list.
func (recv *Widget) DragSourceSetTargetList(targetList *TargetList) {
	c_target_list := (*C.GtkTargetList)(C.NULL)
	if targetList != nil {
		c_target_list = (*C.GtkTargetList)(targetList.ToC())
	}

	C.gtk_drag_source_set_target_list((*C.GtkWidget)(recv.native), c_target_list)

	return
}

// DragSourceUnset is a wrapper around the C function gtk_drag_source_unset.
func (recv *Widget) DragSourceUnset() {
	C.gtk_drag_source_unset((*C.GtkWidget)(recv.native))

	return
}

// DragUnhighlight is a wrapper around the C function gtk_drag_unhighlight.
func (recv *Widget) DragUnhighlight() {
	C.gtk_drag_unhighlight((*C.GtkWidget)(recv.native))

	return
}

// EnsureStyle is a wrapper around the C function gtk_widget_ensure_style.
func (recv *Widget) EnsureStyle() {
	C.gtk_widget_ensure_style((*C.GtkWidget)(recv.native))

	return
}

// ErrorBell is a wrapper around the C function gtk_widget_error_bell.
func (recv *Widget) ErrorBell() {
	C.gtk_widget_error_bell((*C.GtkWidget)(recv.native))

	return
}

// Event is a wrapper around the C function gtk_widget_event.
func (recv *Widget) Event(event *gdk.Event) bool {
	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	retC := C.gtk_widget_event((*C.GtkWidget)(recv.native), c_event)
	retGo := retC == C.TRUE

	return retGo
}

// FreezeChildNotify is a wrapper around the C function gtk_widget_freeze_child_notify.
func (recv *Widget) FreezeChildNotify() {
	C.gtk_widget_freeze_child_notify((*C.GtkWidget)(recv.native))

	return
}

// GetAccessible is a wrapper around the C function gtk_widget_get_accessible.
func (recv *Widget) GetAccessible() *atk.Object {
	retC := C.gtk_widget_get_accessible((*C.GtkWidget)(recv.native))
	retGo := atk.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetAllocatedHeight is a wrapper around the C function gtk_widget_get_allocated_height.
func (recv *Widget) GetAllocatedHeight() int32 {
	retC := C.gtk_widget_get_allocated_height((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetAllocatedWidth is a wrapper around the C function gtk_widget_get_allocated_width.
func (recv *Widget) GetAllocatedWidth() int32 {
	retC := C.gtk_widget_get_allocated_width((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetAncestor is a wrapper around the C function gtk_widget_get_ancestor.
func (recv *Widget) GetAncestor(widgetType gobject.Type) *Widget {
	c_widget_type := (C.GType)(widgetType)

	retC := C.gtk_widget_get_ancestor((*C.GtkWidget)(recv.native), c_widget_type)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetChildRequisition is a wrapper around the C function gtk_widget_get_child_requisition.
func (recv *Widget) GetChildRequisition() *Requisition {
	var c_requisition C.GtkRequisition

	C.gtk_widget_get_child_requisition((*C.GtkWidget)(recv.native), &c_requisition)

	requisition := RequisitionNewFromC(unsafe.Pointer(&c_requisition))

	return requisition
}

// GetChildVisible is a wrapper around the C function gtk_widget_get_child_visible.
func (recv *Widget) GetChildVisible() bool {
	retC := C.gtk_widget_get_child_visible((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetClipboard is a wrapper around the C function gtk_widget_get_clipboard.
func (recv *Widget) GetClipboard(selection *gdk.Atom) *Clipboard {
	c_selection := (C.GdkAtom)(C.NULL)
	if selection != nil {
		c_selection = (C.GdkAtom)(selection.ToC())
	}

	retC := C.gtk_widget_get_clipboard((*C.GtkWidget)(recv.native), c_selection)
	retGo := ClipboardNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCompositeName is a wrapper around the C function gtk_widget_get_composite_name.
func (recv *Widget) GetCompositeName() string {
	retC := C.gtk_widget_get_composite_name((*C.GtkWidget)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetDirection is a wrapper around the C function gtk_widget_get_direction.
func (recv *Widget) GetDirection() TextDirection {
	retC := C.gtk_widget_get_direction((*C.GtkWidget)(recv.native))
	retGo := (TextDirection)(retC)

	return retGo
}

// GetDisplay is a wrapper around the C function gtk_widget_get_display.
func (recv *Widget) GetDisplay() *gdk.Display {
	retC := C.gtk_widget_get_display((*C.GtkWidget)(recv.native))
	retGo := gdk.DisplayNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetEvents is a wrapper around the C function gtk_widget_get_events.
func (recv *Widget) GetEvents() int32 {
	retC := C.gtk_widget_get_events((*C.GtkWidget)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetHalign is a wrapper around the C function gtk_widget_get_halign.
func (recv *Widget) GetHalign() Align {
	retC := C.gtk_widget_get_halign((*C.GtkWidget)(recv.native))
	retGo := (Align)(retC)

	return retGo
}

// GetHasTooltip is a wrapper around the C function gtk_widget_get_has_tooltip.
func (recv *Widget) GetHasTooltip() bool {
	retC := C.gtk_widget_get_has_tooltip((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetHexpand is a wrapper around the C function gtk_widget_get_hexpand.
func (recv *Widget) GetHexpand() bool {
	retC := C.gtk_widget_get_hexpand((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetHexpandSet is a wrapper around the C function gtk_widget_get_hexpand_set.
func (recv *Widget) GetHexpandSet() bool {
	retC := C.gtk_widget_get_hexpand_set((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetModifierStyle is a wrapper around the C function gtk_widget_get_modifier_style.
func (recv *Widget) GetModifierStyle() *RcStyle {
	retC := C.gtk_widget_get_modifier_style((*C.GtkWidget)(recv.native))
	retGo := RcStyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetName is a wrapper around the C function gtk_widget_get_name.
func (recv *Widget) GetName() string {
	retC := C.gtk_widget_get_name((*C.GtkWidget)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetNoShowAll is a wrapper around the C function gtk_widget_get_no_show_all.
func (recv *Widget) GetNoShowAll() bool {
	retC := C.gtk_widget_get_no_show_all((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPangoContext is a wrapper around the C function gtk_widget_get_pango_context.
func (recv *Widget) GetPangoContext() *pango.Context {
	retC := C.gtk_widget_get_pango_context((*C.GtkWidget)(recv.native))
	retGo := pango.ContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetParent is a wrapper around the C function gtk_widget_get_parent.
func (recv *Widget) GetParent() *Widget {
	retC := C.gtk_widget_get_parent((*C.GtkWidget)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetParentWindow is a wrapper around the C function gtk_widget_get_parent_window.
func (recv *Widget) GetParentWindow() *gdk.Window {
	retC := C.gtk_widget_get_parent_window((*C.GtkWidget)(recv.native))
	var retGo (*gdk.Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPath is a wrapper around the C function gtk_widget_get_path.
func (recv *Widget) GetPath() *WidgetPath {
	retC := C.gtk_widget_get_path((*C.GtkWidget)(recv.native))
	retGo := WidgetPathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPointer is a wrapper around the C function gtk_widget_get_pointer.
func (recv *Widget) GetPointer() (int32, int32) {
	var c_x C.gint

	var c_y C.gint

	C.gtk_widget_get_pointer((*C.GtkWidget)(recv.native), &c_x, &c_y)

	x := (int32)(c_x)

	y := (int32)(c_y)

	return x, y
}

// GetRootWindow is a wrapper around the C function gtk_widget_get_root_window.
func (recv *Widget) GetRootWindow() *gdk.Window {
	retC := C.gtk_widget_get_root_window((*C.GtkWidget)(recv.native))
	retGo := gdk.WindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetScreen is a wrapper around the C function gtk_widget_get_screen.
func (recv *Widget) GetScreen() *gdk.Screen {
	retC := C.gtk_widget_get_screen((*C.GtkWidget)(recv.native))
	retGo := gdk.ScreenNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSettings is a wrapper around the C function gtk_widget_get_settings.
func (recv *Widget) GetSettings() *Settings {
	retC := C.gtk_widget_get_settings((*C.GtkWidget)(recv.native))
	retGo := SettingsNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSizeRequest is a wrapper around the C function gtk_widget_get_size_request.
func (recv *Widget) GetSizeRequest() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_widget_get_size_request((*C.GtkWidget)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// GetStyle is a wrapper around the C function gtk_widget_get_style.
func (recv *Widget) GetStyle() *Style {
	retC := C.gtk_widget_get_style((*C.GtkWidget)(recv.native))
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetStyleContext is a wrapper around the C function gtk_widget_get_style_context.
func (recv *Widget) GetStyleContext() *StyleContext {
	retC := C.gtk_widget_get_style_context((*C.GtkWidget)(recv.native))
	retGo := StyleContextNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSupportMultidevice is a wrapper around the C function gtk_widget_get_support_multidevice.
func (recv *Widget) GetSupportMultidevice() bool {
	retC := C.gtk_widget_get_support_multidevice((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTemplateChild is a wrapper around the C function gtk_widget_get_template_child.
func (recv *Widget) GetTemplateChild(widgetType gobject.Type, name string) *gobject.Object {
	c_widget_type := (C.GType)(widgetType)

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_widget_get_template_child((*C.GtkWidget)(recv.native), c_widget_type, c_name)
	retGo := gobject.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetTooltipMarkup is a wrapper around the C function gtk_widget_get_tooltip_markup.
func (recv *Widget) GetTooltipMarkup() string {
	retC := C.gtk_widget_get_tooltip_markup((*C.GtkWidget)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetTooltipText is a wrapper around the C function gtk_widget_get_tooltip_text.
func (recv *Widget) GetTooltipText() string {
	retC := C.gtk_widget_get_tooltip_text((*C.GtkWidget)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetTooltipWindow is a wrapper around the C function gtk_widget_get_tooltip_window.
func (recv *Widget) GetTooltipWindow() *Window {
	retC := C.gtk_widget_get_tooltip_window((*C.GtkWidget)(recv.native))
	retGo := WindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetToplevel is a wrapper around the C function gtk_widget_get_toplevel.
func (recv *Widget) GetToplevel() *Widget {
	retC := C.gtk_widget_get_toplevel((*C.GtkWidget)(recv.native))
	retGo := WidgetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetValign is a wrapper around the C function gtk_widget_get_valign.
func (recv *Widget) GetValign() Align {
	retC := C.gtk_widget_get_valign((*C.GtkWidget)(recv.native))
	retGo := (Align)(retC)

	return retGo
}

// GetVexpand is a wrapper around the C function gtk_widget_get_vexpand.
func (recv *Widget) GetVexpand() bool {
	retC := C.gtk_widget_get_vexpand((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetVexpandSet is a wrapper around the C function gtk_widget_get_vexpand_set.
func (recv *Widget) GetVexpandSet() bool {
	retC := C.gtk_widget_get_vexpand_set((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetVisual is a wrapper around the C function gtk_widget_get_visual.
func (recv *Widget) GetVisual() *gdk.Visual {
	retC := C.gtk_widget_get_visual((*C.GtkWidget)(recv.native))
	retGo := gdk.VisualNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GrabAdd is a wrapper around the C function gtk_grab_add.
func (recv *Widget) GrabAdd() {
	C.gtk_grab_add((*C.GtkWidget)(recv.native))

	return
}

// GrabDefault is a wrapper around the C function gtk_widget_grab_default.
func (recv *Widget) GrabDefault() {
	C.gtk_widget_grab_default((*C.GtkWidget)(recv.native))

	return
}

// GrabFocus is a wrapper around the C function gtk_widget_grab_focus.
func (recv *Widget) GrabFocus() {
	C.gtk_widget_grab_focus((*C.GtkWidget)(recv.native))

	return
}

// GrabRemove is a wrapper around the C function gtk_grab_remove.
func (recv *Widget) GrabRemove() {
	C.gtk_grab_remove((*C.GtkWidget)(recv.native))

	return
}

// HasScreen is a wrapper around the C function gtk_widget_has_screen.
func (recv *Widget) HasScreen() bool {
	retC := C.gtk_widget_has_screen((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Hide is a wrapper around the C function gtk_widget_hide.
func (recv *Widget) Hide() {
	C.gtk_widget_hide((*C.GtkWidget)(recv.native))

	return
}

// HideOnDelete is a wrapper around the C function gtk_widget_hide_on_delete.
func (recv *Widget) HideOnDelete() bool {
	retC := C.gtk_widget_hide_on_delete((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// InDestruction is a wrapper around the C function gtk_widget_in_destruction.
func (recv *Widget) InDestruction() bool {
	retC := C.gtk_widget_in_destruction((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Intersect is a wrapper around the C function gtk_widget_intersect.
func (recv *Widget) Intersect(area *gdk.Rectangle) (bool, *gdk.Rectangle) {
	c_area := (*C.GdkRectangle)(C.NULL)
	if area != nil {
		c_area = (*C.GdkRectangle)(area.ToC())
	}

	var c_intersection C.GdkRectangle

	retC := C.gtk_widget_intersect((*C.GtkWidget)(recv.native), c_area, &c_intersection)
	retGo := retC == C.TRUE

	intersection := gdk.RectangleNewFromC(unsafe.Pointer(&c_intersection))

	return retGo, intersection
}

// IsAncestor is a wrapper around the C function gtk_widget_is_ancestor.
func (recv *Widget) IsAncestor(ancestor *Widget) bool {
	c_ancestor := (*C.GtkWidget)(C.NULL)
	if ancestor != nil {
		c_ancestor = (*C.GtkWidget)(ancestor.ToC())
	}

	retC := C.gtk_widget_is_ancestor((*C.GtkWidget)(recv.native), c_ancestor)
	retGo := retC == C.TRUE

	return retGo
}

// IsComposited is a wrapper around the C function gtk_widget_is_composited.
func (recv *Widget) IsComposited() bool {
	retC := C.gtk_widget_is_composited((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsFocus is a wrapper around the C function gtk_widget_is_focus.
func (recv *Widget) IsFocus() bool {
	retC := C.gtk_widget_is_focus((*C.GtkWidget)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// KeynavFailed is a wrapper around the C function gtk_widget_keynav_failed.
func (recv *Widget) KeynavFailed(direction DirectionType) bool {
	c_direction := (C.GtkDirectionType)(direction)

	retC := C.gtk_widget_keynav_failed((*C.GtkWidget)(recv.native), c_direction)
	retGo := retC == C.TRUE

	return retGo
}

// ListAccelClosures is a wrapper around the C function gtk_widget_list_accel_closures.
func (recv *Widget) ListAccelClosures() *glib.List {
	retC := C.gtk_widget_list_accel_closures((*C.GtkWidget)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ListMnemonicLabels is a wrapper around the C function gtk_widget_list_mnemonic_labels.
func (recv *Widget) ListMnemonicLabels() *glib.List {
	retC := C.gtk_widget_list_mnemonic_labels((*C.GtkWidget)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Map is a wrapper around the C function gtk_widget_map.
func (recv *Widget) Map() {
	C.gtk_widget_map((*C.GtkWidget)(recv.native))

	return
}

// MnemonicActivate is a wrapper around the C function gtk_widget_mnemonic_activate.
func (recv *Widget) MnemonicActivate(groupCycling bool) bool {
	c_group_cycling :=
		boolToGboolean(groupCycling)

	retC := C.gtk_widget_mnemonic_activate((*C.GtkWidget)(recv.native), c_group_cycling)
	retGo := retC == C.TRUE

	return retGo
}

// ModifyBase is a wrapper around the C function gtk_widget_modify_base.
func (recv *Widget) ModifyBase(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_base((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// ModifyBg is a wrapper around the C function gtk_widget_modify_bg.
func (recv *Widget) ModifyBg(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_bg((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// ModifyCursor is a wrapper around the C function gtk_widget_modify_cursor.
func (recv *Widget) ModifyCursor(primary *gdk.Color, secondary *gdk.Color) {
	c_primary := (*C.GdkColor)(C.NULL)
	if primary != nil {
		c_primary = (*C.GdkColor)(primary.ToC())
	}

	c_secondary := (*C.GdkColor)(C.NULL)
	if secondary != nil {
		c_secondary = (*C.GdkColor)(secondary.ToC())
	}

	C.gtk_widget_modify_cursor((*C.GtkWidget)(recv.native), c_primary, c_secondary)

	return
}

// ModifyFg is a wrapper around the C function gtk_widget_modify_fg.
func (recv *Widget) ModifyFg(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_fg((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// ModifyFont is a wrapper around the C function gtk_widget_modify_font.
func (recv *Widget) ModifyFont(fontDesc *pango.FontDescription) {
	c_font_desc := (*C.PangoFontDescription)(C.NULL)
	if fontDesc != nil {
		c_font_desc = (*C.PangoFontDescription)(fontDesc.ToC())
	}

	C.gtk_widget_modify_font((*C.GtkWidget)(recv.native), c_font_desc)

	return
}

// ModifyStyle is a wrapper around the C function gtk_widget_modify_style.
func (recv *Widget) ModifyStyle(style *RcStyle) {
	c_style := (*C.GtkRcStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkRcStyle)(style.ToC())
	}

	C.gtk_widget_modify_style((*C.GtkWidget)(recv.native), c_style)

	return
}

// ModifyText is a wrapper around the C function gtk_widget_modify_text.
func (recv *Widget) ModifyText(state StateType, color *gdk.Color) {
	c_state := (C.GtkStateType)(state)

	c_color := (*C.GdkColor)(C.NULL)
	if color != nil {
		c_color = (*C.GdkColor)(color.ToC())
	}

	C.gtk_widget_modify_text((*C.GtkWidget)(recv.native), c_state, c_color)

	return
}

// Path is a wrapper around the C function gtk_widget_path.
func (recv *Widget) Path() (uint32, string, string) {
	var c_path_length C.guint

	var c_path *C.gchar

	var c_path_reversed *C.gchar

	C.gtk_widget_path((*C.GtkWidget)(recv.native), &c_path_length, &c_path, &c_path_reversed)

	pathLength := (uint32)(c_path_length)

	path := C.GoString(c_path)
	defer C.free(unsafe.Pointer(c_path))

	pathReversed := C.GoString(c_path_reversed)
	defer C.free(unsafe.Pointer(c_path_reversed))

	return pathLength, path, pathReversed
}

// QueueComputeExpand is a wrapper around the C function gtk_widget_queue_compute_expand.
func (recv *Widget) QueueComputeExpand() {
	C.gtk_widget_queue_compute_expand((*C.GtkWidget)(recv.native))

	return
}

// QueueDraw is a wrapper around the C function gtk_widget_queue_draw.
func (recv *Widget) QueueDraw() {
	C.gtk_widget_queue_draw((*C.GtkWidget)(recv.native))

	return
}

// QueueDrawArea is a wrapper around the C function gtk_widget_queue_draw_area.
func (recv *Widget) QueueDrawArea(x int32, y int32, width int32, height int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_widget_queue_draw_area((*C.GtkWidget)(recv.native), c_x, c_y, c_width, c_height)

	return
}

// QueueResize is a wrapper around the C function gtk_widget_queue_resize.
func (recv *Widget) QueueResize() {
	C.gtk_widget_queue_resize((*C.GtkWidget)(recv.native))

	return
}

// QueueResizeNoRedraw is a wrapper around the C function gtk_widget_queue_resize_no_redraw.
func (recv *Widget) QueueResizeNoRedraw() {
	C.gtk_widget_queue_resize_no_redraw((*C.GtkWidget)(recv.native))

	return
}

// Realize is a wrapper around the C function gtk_widget_realize.
func (recv *Widget) Realize() {
	C.gtk_widget_realize((*C.GtkWidget)(recv.native))

	return
}

// RegionIntersect is a wrapper around the C function gtk_widget_region_intersect.
func (recv *Widget) RegionIntersect(region *cairo.Region) *cairo.Region {
	c_region := (*C.cairo_region_t)(C.NULL)
	if region != nil {
		c_region = (*C.cairo_region_t)(region.ToC())
	}

	retC := C.gtk_widget_region_intersect((*C.GtkWidget)(recv.native), c_region)
	retGo := cairo.RegionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RemoveAccelerator is a wrapper around the C function gtk_widget_remove_accelerator.
func (recv *Widget) RemoveAccelerator(accelGroup *AccelGroup, accelKey uint32, accelMods gdk.ModifierType) bool {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_widget_remove_accelerator((*C.GtkWidget)(recv.native), c_accel_group, c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// RemoveMnemonicLabel is a wrapper around the C function gtk_widget_remove_mnemonic_label.
func (recv *Widget) RemoveMnemonicLabel(label *Widget) {
	c_label := (*C.GtkWidget)(C.NULL)
	if label != nil {
		c_label = (*C.GtkWidget)(label.ToC())
	}

	C.gtk_widget_remove_mnemonic_label((*C.GtkWidget)(recv.native), c_label)

	return
}

// RenderIcon is a wrapper around the C function gtk_widget_render_icon.
func (recv *Widget) RenderIcon(stockId string, size IconSize, detail string) *gdkpixbuf.Pixbuf {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_size := (C.GtkIconSize)(size)

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	retC := C.gtk_widget_render_icon((*C.GtkWidget)(recv.native), c_stock_id, c_size, c_detail)
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Reparent is a wrapper around the C function gtk_widget_reparent.
func (recv *Widget) Reparent(newParent *Widget) {
	c_new_parent := (*C.GtkWidget)(C.NULL)
	if newParent != nil {
		c_new_parent = (*C.GtkWidget)(newParent.ToC())
	}

	C.gtk_widget_reparent((*C.GtkWidget)(recv.native), c_new_parent)

	return
}

// ResetRcStyles is a wrapper around the C function gtk_widget_reset_rc_styles.
func (recv *Widget) ResetRcStyles() {
	C.gtk_widget_reset_rc_styles((*C.GtkWidget)(recv.native))

	return
}

// SendExpose is a wrapper around the C function gtk_widget_send_expose.
func (recv *Widget) SendExpose(event *gdk.Event) int32 {
	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	retC := C.gtk_widget_send_expose((*C.GtkWidget)(recv.native), c_event)
	retGo := (int32)(retC)

	return retGo
}

// SetAccelPath is a wrapper around the C function gtk_widget_set_accel_path.
func (recv *Widget) SetAccelPath(accelPath string, accelGroup *AccelGroup) {
	c_accel_path := C.CString(accelPath)
	defer C.free(unsafe.Pointer(c_accel_path))

	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_widget_set_accel_path((*C.GtkWidget)(recv.native), c_accel_path, c_accel_group)

	return
}

// SetAppPaintable is a wrapper around the C function gtk_widget_set_app_paintable.
func (recv *Widget) SetAppPaintable(appPaintable bool) {
	c_app_paintable :=
		boolToGboolean(appPaintable)

	C.gtk_widget_set_app_paintable((*C.GtkWidget)(recv.native), c_app_paintable)

	return
}

// SetChildVisible is a wrapper around the C function gtk_widget_set_child_visible.
func (recv *Widget) SetChildVisible(isVisible bool) {
	c_is_visible :=
		boolToGboolean(isVisible)

	C.gtk_widget_set_child_visible((*C.GtkWidget)(recv.native), c_is_visible)

	return
}

// SetCompositeName is a wrapper around the C function gtk_widget_set_composite_name.
func (recv *Widget) SetCompositeName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_widget_set_composite_name((*C.GtkWidget)(recv.native), c_name)

	return
}

// SetDirection is a wrapper around the C function gtk_widget_set_direction.
func (recv *Widget) SetDirection(dir TextDirection) {
	c_dir := (C.GtkTextDirection)(dir)

	C.gtk_widget_set_direction((*C.GtkWidget)(recv.native), c_dir)

	return
}

// SetDoubleBuffered is a wrapper around the C function gtk_widget_set_double_buffered.
func (recv *Widget) SetDoubleBuffered(doubleBuffered bool) {
	c_double_buffered :=
		boolToGboolean(doubleBuffered)

	C.gtk_widget_set_double_buffered((*C.GtkWidget)(recv.native), c_double_buffered)

	return
}

// SetEvents is a wrapper around the C function gtk_widget_set_events.
func (recv *Widget) SetEvents(events int32) {
	c_events := (C.gint)(events)

	C.gtk_widget_set_events((*C.GtkWidget)(recv.native), c_events)

	return
}

// SetHalign is a wrapper around the C function gtk_widget_set_halign.
func (recv *Widget) SetHalign(align Align) {
	c_align := (C.GtkAlign)(align)

	C.gtk_widget_set_halign((*C.GtkWidget)(recv.native), c_align)

	return
}

// SetHasTooltip is a wrapper around the C function gtk_widget_set_has_tooltip.
func (recv *Widget) SetHasTooltip(hasTooltip bool) {
	c_has_tooltip :=
		boolToGboolean(hasTooltip)

	C.gtk_widget_set_has_tooltip((*C.GtkWidget)(recv.native), c_has_tooltip)

	return
}

// SetHexpand is a wrapper around the C function gtk_widget_set_hexpand.
func (recv *Widget) SetHexpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_widget_set_hexpand((*C.GtkWidget)(recv.native), c_expand)

	return
}

// SetHexpandSet is a wrapper around the C function gtk_widget_set_hexpand_set.
func (recv *Widget) SetHexpandSet(set bool) {
	c_set :=
		boolToGboolean(set)

	C.gtk_widget_set_hexpand_set((*C.GtkWidget)(recv.native), c_set)

	return
}

// SetName is a wrapper around the C function gtk_widget_set_name.
func (recv *Widget) SetName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_widget_set_name((*C.GtkWidget)(recv.native), c_name)

	return
}

// SetNoShowAll is a wrapper around the C function gtk_widget_set_no_show_all.
func (recv *Widget) SetNoShowAll(noShowAll bool) {
	c_no_show_all :=
		boolToGboolean(noShowAll)

	C.gtk_widget_set_no_show_all((*C.GtkWidget)(recv.native), c_no_show_all)

	return
}

// SetParent is a wrapper around the C function gtk_widget_set_parent.
func (recv *Widget) SetParent(parent *Widget) {
	c_parent := (*C.GtkWidget)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWidget)(parent.ToC())
	}

	C.gtk_widget_set_parent((*C.GtkWidget)(recv.native), c_parent)

	return
}

// SetParentWindow is a wrapper around the C function gtk_widget_set_parent_window.
func (recv *Widget) SetParentWindow(parentWindow *gdk.Window) {
	c_parent_window := (*C.GdkWindow)(C.NULL)
	if parentWindow != nil {
		c_parent_window = (*C.GdkWindow)(parentWindow.ToC())
	}

	C.gtk_widget_set_parent_window((*C.GtkWidget)(recv.native), c_parent_window)

	return
}

// SetRedrawOnAllocate is a wrapper around the C function gtk_widget_set_redraw_on_allocate.
func (recv *Widget) SetRedrawOnAllocate(redrawOnAllocate bool) {
	c_redraw_on_allocate :=
		boolToGboolean(redrawOnAllocate)

	C.gtk_widget_set_redraw_on_allocate((*C.GtkWidget)(recv.native), c_redraw_on_allocate)

	return
}

// SetSensitive is a wrapper around the C function gtk_widget_set_sensitive.
func (recv *Widget) SetSensitive(sensitive bool) {
	c_sensitive :=
		boolToGboolean(sensitive)

	C.gtk_widget_set_sensitive((*C.GtkWidget)(recv.native), c_sensitive)

	return
}

// SetSizeRequest is a wrapper around the C function gtk_widget_set_size_request.
func (recv *Widget) SetSizeRequest(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_widget_set_size_request((*C.GtkWidget)(recv.native), c_width, c_height)

	return
}

// SetState is a wrapper around the C function gtk_widget_set_state.
func (recv *Widget) SetState(state StateType) {
	c_state := (C.GtkStateType)(state)

	C.gtk_widget_set_state((*C.GtkWidget)(recv.native), c_state)

	return
}

// SetStyle is a wrapper around the C function gtk_widget_set_style.
func (recv *Widget) SetStyle(style *Style) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	C.gtk_widget_set_style((*C.GtkWidget)(recv.native), c_style)

	return
}

// SetTooltipMarkup is a wrapper around the C function gtk_widget_set_tooltip_markup.
func (recv *Widget) SetTooltipMarkup(markup string) {
	c_markup := C.CString(markup)
	defer C.free(unsafe.Pointer(c_markup))

	C.gtk_widget_set_tooltip_markup((*C.GtkWidget)(recv.native), c_markup)

	return
}

// SetTooltipText is a wrapper around the C function gtk_widget_set_tooltip_text.
func (recv *Widget) SetTooltipText(text string) {
	c_text := C.CString(text)
	defer C.free(unsafe.Pointer(c_text))

	C.gtk_widget_set_tooltip_text((*C.GtkWidget)(recv.native), c_text)

	return
}

// SetTooltipWindow is a wrapper around the C function gtk_widget_set_tooltip_window.
func (recv *Widget) SetTooltipWindow(customWindow *Window) {
	c_custom_window := (*C.GtkWindow)(C.NULL)
	if customWindow != nil {
		c_custom_window = (*C.GtkWindow)(customWindow.ToC())
	}

	C.gtk_widget_set_tooltip_window((*C.GtkWidget)(recv.native), c_custom_window)

	return
}

// SetValign is a wrapper around the C function gtk_widget_set_valign.
func (recv *Widget) SetValign(align Align) {
	c_align := (C.GtkAlign)(align)

	C.gtk_widget_set_valign((*C.GtkWidget)(recv.native), c_align)

	return
}

// SetVexpand is a wrapper around the C function gtk_widget_set_vexpand.
func (recv *Widget) SetVexpand(expand bool) {
	c_expand :=
		boolToGboolean(expand)

	C.gtk_widget_set_vexpand((*C.GtkWidget)(recv.native), c_expand)

	return
}

// SetVexpandSet is a wrapper around the C function gtk_widget_set_vexpand_set.
func (recv *Widget) SetVexpandSet(set bool) {
	c_set :=
		boolToGboolean(set)

	C.gtk_widget_set_vexpand_set((*C.GtkWidget)(recv.native), c_set)

	return
}

// SetVisual is a wrapper around the C function gtk_widget_set_visual.
func (recv *Widget) SetVisual(visual *gdk.Visual) {
	c_visual := (*C.GdkVisual)(C.NULL)
	if visual != nil {
		c_visual = (*C.GdkVisual)(visual.ToC())
	}

	C.gtk_widget_set_visual((*C.GtkWidget)(recv.native), c_visual)

	return
}

// Show is a wrapper around the C function gtk_widget_show.
func (recv *Widget) Show() {
	C.gtk_widget_show((*C.GtkWidget)(recv.native))

	return
}

// ShowAll is a wrapper around the C function gtk_widget_show_all.
func (recv *Widget) ShowAll() {
	C.gtk_widget_show_all((*C.GtkWidget)(recv.native))

	return
}

// ShowNow is a wrapper around the C function gtk_widget_show_now.
func (recv *Widget) ShowNow() {
	C.gtk_widget_show_now((*C.GtkWidget)(recv.native))

	return
}

// SizeAllocate is a wrapper around the C function gtk_widget_size_allocate.
func (recv *Widget) SizeAllocate(allocation *gdk.Rectangle) {
	c_allocation := (*C.GdkRectangle)(C.NULL)
	if allocation != nil {
		c_allocation = (*C.GdkRectangle)(allocation.ToC())
	}

	C.gtk_widget_size_allocate((*C.GtkWidget)(recv.native), c_allocation)

	return
}

// SizeRequest is a wrapper around the C function gtk_widget_size_request.
func (recv *Widget) SizeRequest() *Requisition {
	var c_requisition C.GtkRequisition

	C.gtk_widget_size_request((*C.GtkWidget)(recv.native), &c_requisition)

	requisition := RequisitionNewFromC(unsafe.Pointer(&c_requisition))

	return requisition
}

// Unsupported : gtk_widget_style_get : unsupported parameter ... : varargs

// StyleGetProperty is a wrapper around the C function gtk_widget_style_get_property.
func (recv *Widget) StyleGetProperty(propertyName string, value *gobject.Value) {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_widget_style_get_property((*C.GtkWidget)(recv.native), c_property_name, c_value)

	return
}

// Unsupported : gtk_widget_style_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// ThawChildNotify is a wrapper around the C function gtk_widget_thaw_child_notify.
func (recv *Widget) ThawChildNotify() {
	C.gtk_widget_thaw_child_notify((*C.GtkWidget)(recv.native))

	return
}

// TranslateCoordinates is a wrapper around the C function gtk_widget_translate_coordinates.
func (recv *Widget) TranslateCoordinates(destWidget *Widget, srcX int32, srcY int32) (bool, int32, int32) {
	c_dest_widget := (*C.GtkWidget)(C.NULL)
	if destWidget != nil {
		c_dest_widget = (*C.GtkWidget)(destWidget.ToC())
	}

	c_src_x := (C.gint)(srcX)

	c_src_y := (C.gint)(srcY)

	var c_dest_x C.gint

	var c_dest_y C.gint

	retC := C.gtk_widget_translate_coordinates((*C.GtkWidget)(recv.native), c_dest_widget, c_src_x, c_src_y, &c_dest_x, &c_dest_y)
	retGo := retC == C.TRUE

	destX := (int32)(c_dest_x)

	destY := (int32)(c_dest_y)

	return retGo, destX, destY
}

// TriggerTooltipQuery is a wrapper around the C function gtk_widget_trigger_tooltip_query.
func (recv *Widget) TriggerTooltipQuery() {
	C.gtk_widget_trigger_tooltip_query((*C.GtkWidget)(recv.native))

	return
}

// Unmap is a wrapper around the C function gtk_widget_unmap.
func (recv *Widget) Unmap() {
	C.gtk_widget_unmap((*C.GtkWidget)(recv.native))

	return
}

// Unparent is a wrapper around the C function gtk_widget_unparent.
func (recv *Widget) Unparent() {
	C.gtk_widget_unparent((*C.GtkWidget)(recv.native))

	return
}

// Unrealize is a wrapper around the C function gtk_widget_unrealize.
func (recv *Widget) Unrealize() {
	C.gtk_widget_unrealize((*C.GtkWidget)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Widget
func (recv *Widget) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Widget
func (recv *Widget) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// WidgetAccessible is a wrapper around the C record GtkWidgetAccessible.
type WidgetAccessible struct {
	native *C.GtkWidgetAccessible
	// parent : record
	// priv : record
}

func WidgetAccessibleNewFromC(u unsafe.Pointer) *WidgetAccessible {
	c := (*C.GtkWidgetAccessible)(u)
	if c == nil {
		return nil
	}

	g := &WidgetAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *WidgetAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *WidgetAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WidgetAccessible with another WidgetAccessible, and returns true if they represent the same GObject.
func (recv *WidgetAccessible) Equals(other *WidgetAccessible) bool {
	return other.ToC() == recv.ToC()
}

// Accessible upcasts to *Accessible
func (recv *WidgetAccessible) Accessible() *Accessible {
	return AccessibleNewFromC(unsafe.Pointer(recv.native))
}

// Object upcasts to *Object
func (recv *WidgetAccessible) Object() *atk.Object {
	return recv.Accessible().Object()
}

// CastToWidget down casts any arbitrary Object to WidgetAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a WidgetAccessible.
func CastToWidgetAccessible(object *gobject.Object) *WidgetAccessible {
	return WidgetAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by WidgetAccessible
func (recv *WidgetAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Window is a wrapper around the C record GtkWindow.
type Window struct {
	native *C.GtkWindow
	// bin : record
	// priv : record
}

func WindowNewFromC(u unsafe.Pointer) *Window {
	c := (*C.GtkWindow)(u)
	if c == nil {
		return nil
	}

	g := &Window{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *Window) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *Window) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Window with another Window, and returns true if they represent the same GObject.
func (recv *Window) Equals(other *Window) bool {
	return other.ToC() == recv.ToC()
}

// Bin upcasts to *Bin
func (recv *Window) Bin() *Bin {
	return BinNewFromC(unsafe.Pointer(recv.native))
}

// Container upcasts to *Container
func (recv *Window) Container() *Container {
	return recv.Bin().Container()
}

// Widget upcasts to *Widget
func (recv *Window) Widget() *Widget {
	return recv.Bin().Widget()
}

// InitiallyUnowned upcasts to *InitiallyUnowned
func (recv *Window) InitiallyUnowned() *gobject.InitiallyUnowned {
	return recv.Bin().InitiallyUnowned()
}

// Object upcasts to *Object
func (recv *Window) Object() *gobject.Object {
	return recv.Bin().Object()
}

// CastToWidget down casts any arbitrary Object to Window.
// Exercise care, as this is a potentially dangerous function if the Object is not a Window.
func CastToWindow(object *gobject.Object) *Window {
	return WindowNewFromC(object.ToC())
}

type signalWindowActivateDefaultDetail struct {
	callback  WindowSignalActivateDefaultCallback
	handlerID C.gulong
}

var signalWindowActivateDefaultId int
var signalWindowActivateDefaultMap = make(map[int]signalWindowActivateDefaultDetail)
var signalWindowActivateDefaultLock sync.RWMutex

// WindowSignalActivateDefaultCallback is a callback function for a 'activate-default' signal emitted from a Window.
type WindowSignalActivateDefaultCallback func()

/*
ConnectActivateDefault connects the callback to the 'activate-default' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectActivateDefault to remove it.
*/
func (recv *Window) ConnectActivateDefault(callback WindowSignalActivateDefaultCallback) int {
	signalWindowActivateDefaultLock.Lock()
	defer signalWindowActivateDefaultLock.Unlock()

	signalWindowActivateDefaultId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_activate_default(instance, C.gpointer(uintptr(signalWindowActivateDefaultId)))

	detail := signalWindowActivateDefaultDetail{callback, handlerID}
	signalWindowActivateDefaultMap[signalWindowActivateDefaultId] = detail

	return signalWindowActivateDefaultId
}

/*
DisconnectActivateDefault disconnects a callback from the 'activate-default' signal for the Window.

The connectionID should be a value returned from a call to ConnectActivateDefault.
*/
func (recv *Window) DisconnectActivateDefault(connectionID int) {
	signalWindowActivateDefaultLock.Lock()
	defer signalWindowActivateDefaultLock.Unlock()

	detail, exists := signalWindowActivateDefaultMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowActivateDefaultMap, connectionID)
}

//export window_activateDefaultHandler
func window_activateDefaultHandler(_ *C.GObject, data C.gpointer) {
	signalWindowActivateDefaultLock.RLock()
	defer signalWindowActivateDefaultLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWindowActivateDefaultMap[index].callback
	callback()
}

type signalWindowActivateFocusDetail struct {
	callback  WindowSignalActivateFocusCallback
	handlerID C.gulong
}

var signalWindowActivateFocusId int
var signalWindowActivateFocusMap = make(map[int]signalWindowActivateFocusDetail)
var signalWindowActivateFocusLock sync.RWMutex

// WindowSignalActivateFocusCallback is a callback function for a 'activate-focus' signal emitted from a Window.
type WindowSignalActivateFocusCallback func()

/*
ConnectActivateFocus connects the callback to the 'activate-focus' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectActivateFocus to remove it.
*/
func (recv *Window) ConnectActivateFocus(callback WindowSignalActivateFocusCallback) int {
	signalWindowActivateFocusLock.Lock()
	defer signalWindowActivateFocusLock.Unlock()

	signalWindowActivateFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_activate_focus(instance, C.gpointer(uintptr(signalWindowActivateFocusId)))

	detail := signalWindowActivateFocusDetail{callback, handlerID}
	signalWindowActivateFocusMap[signalWindowActivateFocusId] = detail

	return signalWindowActivateFocusId
}

/*
DisconnectActivateFocus disconnects a callback from the 'activate-focus' signal for the Window.

The connectionID should be a value returned from a call to ConnectActivateFocus.
*/
func (recv *Window) DisconnectActivateFocus(connectionID int) {
	signalWindowActivateFocusLock.Lock()
	defer signalWindowActivateFocusLock.Unlock()

	detail, exists := signalWindowActivateFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowActivateFocusMap, connectionID)
}

//export window_activateFocusHandler
func window_activateFocusHandler(_ *C.GObject, data C.gpointer) {
	signalWindowActivateFocusLock.RLock()
	defer signalWindowActivateFocusLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWindowActivateFocusMap[index].callback
	callback()
}

type signalWindowEnableDebuggingDetail struct {
	callback  WindowSignalEnableDebuggingCallback
	handlerID C.gulong
}

var signalWindowEnableDebuggingId int
var signalWindowEnableDebuggingMap = make(map[int]signalWindowEnableDebuggingDetail)
var signalWindowEnableDebuggingLock sync.RWMutex

// WindowSignalEnableDebuggingCallback is a callback function for a 'enable-debugging' signal emitted from a Window.
type WindowSignalEnableDebuggingCallback func(toggle bool) bool

/*
ConnectEnableDebugging connects the callback to the 'enable-debugging' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectEnableDebugging to remove it.
*/
func (recv *Window) ConnectEnableDebugging(callback WindowSignalEnableDebuggingCallback) int {
	signalWindowEnableDebuggingLock.Lock()
	defer signalWindowEnableDebuggingLock.Unlock()

	signalWindowEnableDebuggingId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_enable_debugging(instance, C.gpointer(uintptr(signalWindowEnableDebuggingId)))

	detail := signalWindowEnableDebuggingDetail{callback, handlerID}
	signalWindowEnableDebuggingMap[signalWindowEnableDebuggingId] = detail

	return signalWindowEnableDebuggingId
}

/*
DisconnectEnableDebugging disconnects a callback from the 'enable-debugging' signal for the Window.

The connectionID should be a value returned from a call to ConnectEnableDebugging.
*/
func (recv *Window) DisconnectEnableDebugging(connectionID int) {
	signalWindowEnableDebuggingLock.Lock()
	defer signalWindowEnableDebuggingLock.Unlock()

	detail, exists := signalWindowEnableDebuggingMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowEnableDebuggingMap, connectionID)
}

//export window_enableDebuggingHandler
func window_enableDebuggingHandler(_ *C.GObject, c_toggle C.gboolean, data C.gpointer) C.gboolean {
	signalWindowEnableDebuggingLock.RLock()
	defer signalWindowEnableDebuggingLock.RUnlock()

	toggle := c_toggle == C.TRUE

	index := int(uintptr(data))
	callback := signalWindowEnableDebuggingMap[index].callback
	retGo := callback(toggle)
	retC :=
		boolToGboolean(retGo)
	return retC
}

type signalWindowKeysChangedDetail struct {
	callback  WindowSignalKeysChangedCallback
	handlerID C.gulong
}

var signalWindowKeysChangedId int
var signalWindowKeysChangedMap = make(map[int]signalWindowKeysChangedDetail)
var signalWindowKeysChangedLock sync.RWMutex

// WindowSignalKeysChangedCallback is a callback function for a 'keys-changed' signal emitted from a Window.
type WindowSignalKeysChangedCallback func()

/*
ConnectKeysChanged connects the callback to the 'keys-changed' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectKeysChanged to remove it.
*/
func (recv *Window) ConnectKeysChanged(callback WindowSignalKeysChangedCallback) int {
	signalWindowKeysChangedLock.Lock()
	defer signalWindowKeysChangedLock.Unlock()

	signalWindowKeysChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_keys_changed(instance, C.gpointer(uintptr(signalWindowKeysChangedId)))

	detail := signalWindowKeysChangedDetail{callback, handlerID}
	signalWindowKeysChangedMap[signalWindowKeysChangedId] = detail

	return signalWindowKeysChangedId
}

/*
DisconnectKeysChanged disconnects a callback from the 'keys-changed' signal for the Window.

The connectionID should be a value returned from a call to ConnectKeysChanged.
*/
func (recv *Window) DisconnectKeysChanged(connectionID int) {
	signalWindowKeysChangedLock.Lock()
	defer signalWindowKeysChangedLock.Unlock()

	detail, exists := signalWindowKeysChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowKeysChangedMap, connectionID)
}

//export window_keysChangedHandler
func window_keysChangedHandler(_ *C.GObject, data C.gpointer) {
	signalWindowKeysChangedLock.RLock()
	defer signalWindowKeysChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalWindowKeysChangedMap[index].callback
	callback()
}

type signalWindowSetFocusDetail struct {
	callback  WindowSignalSetFocusCallback
	handlerID C.gulong
}

var signalWindowSetFocusId int
var signalWindowSetFocusMap = make(map[int]signalWindowSetFocusDetail)
var signalWindowSetFocusLock sync.RWMutex

// WindowSignalSetFocusCallback is a callback function for a 'set-focus' signal emitted from a Window.
type WindowSignalSetFocusCallback func(object *Widget)

/*
ConnectSetFocus connects the callback to the 'set-focus' signal for the Window.

The returned value represents the connection, and may be passed to DisconnectSetFocus to remove it.
*/
func (recv *Window) ConnectSetFocus(callback WindowSignalSetFocusCallback) int {
	signalWindowSetFocusLock.Lock()
	defer signalWindowSetFocusLock.Unlock()

	signalWindowSetFocusId++
	instance := C.gpointer(recv.native)
	handlerID := C.Window_signal_connect_set_focus(instance, C.gpointer(uintptr(signalWindowSetFocusId)))

	detail := signalWindowSetFocusDetail{callback, handlerID}
	signalWindowSetFocusMap[signalWindowSetFocusId] = detail

	return signalWindowSetFocusId
}

/*
DisconnectSetFocus disconnects a callback from the 'set-focus' signal for the Window.

The connectionID should be a value returned from a call to ConnectSetFocus.
*/
func (recv *Window) DisconnectSetFocus(connectionID int) {
	signalWindowSetFocusLock.Lock()
	defer signalWindowSetFocusLock.Unlock()

	detail, exists := signalWindowSetFocusMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalWindowSetFocusMap, connectionID)
}

//export window_setFocusHandler
func window_setFocusHandler(_ *C.GObject, c_object *C.GtkWidget, data C.gpointer) {
	signalWindowSetFocusLock.RLock()
	defer signalWindowSetFocusLock.RUnlock()

	object := WidgetNewFromC(unsafe.Pointer(c_object))

	index := int(uintptr(data))
	callback := signalWindowSetFocusMap[index].callback
	callback(object)
}

// WindowNew is a wrapper around the C function gtk_window_new.
func WindowNew(type_ WindowType) *Window {
	c_type := (C.GtkWindowType)(type_)

	retC := C.gtk_window_new(c_type)
	retGo := WindowNewFromC(unsafe.Pointer(retC))

	return retGo
}

// WindowGetDefaultIconList is a wrapper around the C function gtk_window_get_default_icon_list.
func WindowGetDefaultIconList() *glib.List {
	retC := C.gtk_window_get_default_icon_list()
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// WindowListToplevels is a wrapper around the C function gtk_window_list_toplevels.
func WindowListToplevels() *glib.List {
	retC := C.gtk_window_list_toplevels()
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// WindowSetAutoStartupNotification is a wrapper around the C function gtk_window_set_auto_startup_notification.
func WindowSetAutoStartupNotification(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_auto_startup_notification(c_setting)

	return
}

// WindowSetDefaultIcon is a wrapper around the C function gtk_window_set_default_icon.
func WindowSetDefaultIcon(icon *gdkpixbuf.Pixbuf) {
	c_icon := (*C.GdkPixbuf)(C.NULL)
	if icon != nil {
		c_icon = (*C.GdkPixbuf)(icon.ToC())
	}

	C.gtk_window_set_default_icon(c_icon)

	return
}

// WindowSetDefaultIconFromFile is a wrapper around the C function gtk_window_set_default_icon_from_file.
func WindowSetDefaultIconFromFile(filename string) (bool, error) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	var cThrowableError *C.GError

	retC := C.gtk_window_set_default_icon_from_file(c_filename, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// WindowSetDefaultIconList is a wrapper around the C function gtk_window_set_default_icon_list.
func WindowSetDefaultIconList(list *glib.List) {
	c_list := (*C.GList)(C.NULL)
	if list != nil {
		c_list = (*C.GList)(list.ToC())
	}

	C.gtk_window_set_default_icon_list(c_list)

	return
}

// WindowSetDefaultIconName is a wrapper around the C function gtk_window_set_default_icon_name.
func WindowSetDefaultIconName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_window_set_default_icon_name(c_name)

	return
}

// ActivateDefault is a wrapper around the C function gtk_window_activate_default.
func (recv *Window) ActivateDefault() bool {
	retC := C.gtk_window_activate_default((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ActivateFocus is a wrapper around the C function gtk_window_activate_focus.
func (recv *Window) ActivateFocus() bool {
	retC := C.gtk_window_activate_focus((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ActivateKey is a wrapper around the C function gtk_window_activate_key.
func (recv *Window) ActivateKey(event *gdk.EventKey) bool {
	c_event := (*C.GdkEventKey)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEventKey)(event.ToC())
	}

	retC := C.gtk_window_activate_key((*C.GtkWindow)(recv.native), c_event)
	retGo := retC == C.TRUE

	return retGo
}

// AddAccelGroup is a wrapper around the C function gtk_window_add_accel_group.
func (recv *Window) AddAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_window_add_accel_group((*C.GtkWindow)(recv.native), c_accel_group)

	return
}

// AddMnemonic is a wrapper around the C function gtk_window_add_mnemonic.
func (recv *Window) AddMnemonic(keyval uint32, target *Widget) {
	c_keyval := (C.guint)(keyval)

	c_target := (*C.GtkWidget)(C.NULL)
	if target != nil {
		c_target = (*C.GtkWidget)(target.ToC())
	}

	C.gtk_window_add_mnemonic((*C.GtkWindow)(recv.native), c_keyval, c_target)

	return
}

// BeginMoveDrag is a wrapper around the C function gtk_window_begin_move_drag.
func (recv *Window) BeginMoveDrag(button int32, rootX int32, rootY int32, timestamp uint32) {
	c_button := (C.gint)(button)

	c_root_x := (C.gint)(rootX)

	c_root_y := (C.gint)(rootY)

	c_timestamp := (C.guint32)(timestamp)

	C.gtk_window_begin_move_drag((*C.GtkWindow)(recv.native), c_button, c_root_x, c_root_y, c_timestamp)

	return
}

// BeginResizeDrag is a wrapper around the C function gtk_window_begin_resize_drag.
func (recv *Window) BeginResizeDrag(edge gdk.WindowEdge, button int32, rootX int32, rootY int32, timestamp uint32) {
	c_edge := (C.GdkWindowEdge)(edge)

	c_button := (C.gint)(button)

	c_root_x := (C.gint)(rootX)

	c_root_y := (C.gint)(rootY)

	c_timestamp := (C.guint32)(timestamp)

	C.gtk_window_begin_resize_drag((*C.GtkWindow)(recv.native), c_edge, c_button, c_root_x, c_root_y, c_timestamp)

	return
}

// Deiconify is a wrapper around the C function gtk_window_deiconify.
func (recv *Window) Deiconify() {
	C.gtk_window_deiconify((*C.GtkWindow)(recv.native))

	return
}

// Fullscreen is a wrapper around the C function gtk_window_fullscreen.
func (recv *Window) Fullscreen() {
	C.gtk_window_fullscreen((*C.GtkWindow)(recv.native))

	return
}

// GetAcceptFocus is a wrapper around the C function gtk_window_get_accept_focus.
func (recv *Window) GetAcceptFocus() bool {
	retC := C.gtk_window_get_accept_focus((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetDecorated is a wrapper around the C function gtk_window_get_decorated.
func (recv *Window) GetDecorated() bool {
	retC := C.gtk_window_get_decorated((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetDefaultSize is a wrapper around the C function gtk_window_get_default_size.
func (recv *Window) GetDefaultSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_window_get_default_size((*C.GtkWindow)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// GetDeletable is a wrapper around the C function gtk_window_get_deletable.
func (recv *Window) GetDeletable() bool {
	retC := C.gtk_window_get_deletable((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetDestroyWithParent is a wrapper around the C function gtk_window_get_destroy_with_parent.
func (recv *Window) GetDestroyWithParent() bool {
	retC := C.gtk_window_get_destroy_with_parent((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetFocus is a wrapper around the C function gtk_window_get_focus.
func (recv *Window) GetFocus() *Widget {
	retC := C.gtk_window_get_focus((*C.GtkWindow)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetFocusOnMap is a wrapper around the C function gtk_window_get_focus_on_map.
func (recv *Window) GetFocusOnMap() bool {
	retC := C.gtk_window_get_focus_on_map((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetGravity is a wrapper around the C function gtk_window_get_gravity.
func (recv *Window) GetGravity() gdk.Gravity {
	retC := C.gtk_window_get_gravity((*C.GtkWindow)(recv.native))
	retGo := (gdk.Gravity)(retC)

	return retGo
}

// GetGroup is a wrapper around the C function gtk_window_get_group.
func (recv *Window) GetGroup() *WindowGroup {
	retC := C.gtk_window_get_group((*C.GtkWindow)(recv.native))
	retGo := WindowGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIcon is a wrapper around the C function gtk_window_get_icon.
func (recv *Window) GetIcon() *gdkpixbuf.Pixbuf {
	retC := C.gtk_window_get_icon((*C.GtkWindow)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetIconList is a wrapper around the C function gtk_window_get_icon_list.
func (recv *Window) GetIconList() *glib.List {
	retC := C.gtk_window_get_icon_list((*C.GtkWindow)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetIconName is a wrapper around the C function gtk_window_get_icon_name.
func (recv *Window) GetIconName() string {
	retC := C.gtk_window_get_icon_name((*C.GtkWindow)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetMnemonicModifier is a wrapper around the C function gtk_window_get_mnemonic_modifier.
func (recv *Window) GetMnemonicModifier() gdk.ModifierType {
	retC := C.gtk_window_get_mnemonic_modifier((*C.GtkWindow)(recv.native))
	retGo := (gdk.ModifierType)(retC)

	return retGo
}

// GetModal is a wrapper around the C function gtk_window_get_modal.
func (recv *Window) GetModal() bool {
	retC := C.gtk_window_get_modal((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetOpacity is a wrapper around the C function gtk_window_get_opacity.
func (recv *Window) GetOpacity() float64 {
	retC := C.gtk_window_get_opacity((*C.GtkWindow)(recv.native))
	retGo := (float64)(retC)

	return retGo
}

// GetPosition is a wrapper around the C function gtk_window_get_position.
func (recv *Window) GetPosition() (int32, int32) {
	var c_root_x C.gint

	var c_root_y C.gint

	C.gtk_window_get_position((*C.GtkWindow)(recv.native), &c_root_x, &c_root_y)

	rootX := (int32)(c_root_x)

	rootY := (int32)(c_root_y)

	return rootX, rootY
}

// GetResizable is a wrapper around the C function gtk_window_get_resizable.
func (recv *Window) GetResizable() bool {
	retC := C.gtk_window_get_resizable((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetRole is a wrapper around the C function gtk_window_get_role.
func (recv *Window) GetRole() string {
	retC := C.gtk_window_get_role((*C.GtkWindow)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetScreen is a wrapper around the C function gtk_window_get_screen.
func (recv *Window) GetScreen() *gdk.Screen {
	retC := C.gtk_window_get_screen((*C.GtkWindow)(recv.native))
	retGo := gdk.ScreenNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSize is a wrapper around the C function gtk_window_get_size.
func (recv *Window) GetSize() (int32, int32) {
	var c_width C.gint

	var c_height C.gint

	C.gtk_window_get_size((*C.GtkWindow)(recv.native), &c_width, &c_height)

	width := (int32)(c_width)

	height := (int32)(c_height)

	return width, height
}

// GetSkipPagerHint is a wrapper around the C function gtk_window_get_skip_pager_hint.
func (recv *Window) GetSkipPagerHint() bool {
	retC := C.gtk_window_get_skip_pager_hint((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSkipTaskbarHint is a wrapper around the C function gtk_window_get_skip_taskbar_hint.
func (recv *Window) GetSkipTaskbarHint() bool {
	retC := C.gtk_window_get_skip_taskbar_hint((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetTitle is a wrapper around the C function gtk_window_get_title.
func (recv *Window) GetTitle() string {
	retC := C.gtk_window_get_title((*C.GtkWindow)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetTransientFor is a wrapper around the C function gtk_window_get_transient_for.
func (recv *Window) GetTransientFor() *Window {
	retC := C.gtk_window_get_transient_for((*C.GtkWindow)(recv.native))
	var retGo (*Window)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WindowNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetTypeHint is a wrapper around the C function gtk_window_get_type_hint.
func (recv *Window) GetTypeHint() gdk.WindowTypeHint {
	retC := C.gtk_window_get_type_hint((*C.GtkWindow)(recv.native))
	retGo := (gdk.WindowTypeHint)(retC)

	return retGo
}

// GetUrgencyHint is a wrapper around the C function gtk_window_get_urgency_hint.
func (recv *Window) GetUrgencyHint() bool {
	retC := C.gtk_window_get_urgency_hint((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// HasGroup is a wrapper around the C function gtk_window_has_group.
func (recv *Window) HasGroup() bool {
	retC := C.gtk_window_has_group((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// HasToplevelFocus is a wrapper around the C function gtk_window_has_toplevel_focus.
func (recv *Window) HasToplevelFocus() bool {
	retC := C.gtk_window_has_toplevel_focus((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Iconify is a wrapper around the C function gtk_window_iconify.
func (recv *Window) Iconify() {
	C.gtk_window_iconify((*C.GtkWindow)(recv.native))

	return
}

// IsActive is a wrapper around the C function gtk_window_is_active.
func (recv *Window) IsActive() bool {
	retC := C.gtk_window_is_active((*C.GtkWindow)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Maximize is a wrapper around the C function gtk_window_maximize.
func (recv *Window) Maximize() {
	C.gtk_window_maximize((*C.GtkWindow)(recv.native))

	return
}

// MnemonicActivate is a wrapper around the C function gtk_window_mnemonic_activate.
func (recv *Window) MnemonicActivate(keyval uint32, modifier gdk.ModifierType) bool {
	c_keyval := (C.guint)(keyval)

	c_modifier := (C.GdkModifierType)(modifier)

	retC := C.gtk_window_mnemonic_activate((*C.GtkWindow)(recv.native), c_keyval, c_modifier)
	retGo := retC == C.TRUE

	return retGo
}

// Move is a wrapper around the C function gtk_window_move.
func (recv *Window) Move(x int32, y int32) {
	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	C.gtk_window_move((*C.GtkWindow)(recv.native), c_x, c_y)

	return
}

// ParseGeometry is a wrapper around the C function gtk_window_parse_geometry.
func (recv *Window) ParseGeometry(geometry string) bool {
	c_geometry := C.CString(geometry)
	defer C.free(unsafe.Pointer(c_geometry))

	retC := C.gtk_window_parse_geometry((*C.GtkWindow)(recv.native), c_geometry)
	retGo := retC == C.TRUE

	return retGo
}

// Present is a wrapper around the C function gtk_window_present.
func (recv *Window) Present() {
	C.gtk_window_present((*C.GtkWindow)(recv.native))

	return
}

// PresentWithTime is a wrapper around the C function gtk_window_present_with_time.
func (recv *Window) PresentWithTime(timestamp uint32) {
	c_timestamp := (C.guint32)(timestamp)

	C.gtk_window_present_with_time((*C.GtkWindow)(recv.native), c_timestamp)

	return
}

// PropagateKeyEvent is a wrapper around the C function gtk_window_propagate_key_event.
func (recv *Window) PropagateKeyEvent(event *gdk.EventKey) bool {
	c_event := (*C.GdkEventKey)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEventKey)(event.ToC())
	}

	retC := C.gtk_window_propagate_key_event((*C.GtkWindow)(recv.native), c_event)
	retGo := retC == C.TRUE

	return retGo
}

// RemoveAccelGroup is a wrapper around the C function gtk_window_remove_accel_group.
func (recv *Window) RemoveAccelGroup(accelGroup *AccelGroup) {
	c_accel_group := (*C.GtkAccelGroup)(C.NULL)
	if accelGroup != nil {
		c_accel_group = (*C.GtkAccelGroup)(accelGroup.ToC())
	}

	C.gtk_window_remove_accel_group((*C.GtkWindow)(recv.native), c_accel_group)

	return
}

// RemoveMnemonic is a wrapper around the C function gtk_window_remove_mnemonic.
func (recv *Window) RemoveMnemonic(keyval uint32, target *Widget) {
	c_keyval := (C.guint)(keyval)

	c_target := (*C.GtkWidget)(C.NULL)
	if target != nil {
		c_target = (*C.GtkWidget)(target.ToC())
	}

	C.gtk_window_remove_mnemonic((*C.GtkWindow)(recv.native), c_keyval, c_target)

	return
}

// ReshowWithInitialSize is a wrapper around the C function gtk_window_reshow_with_initial_size.
func (recv *Window) ReshowWithInitialSize() {
	C.gtk_window_reshow_with_initial_size((*C.GtkWindow)(recv.native))

	return
}

// Resize is a wrapper around the C function gtk_window_resize.
func (recv *Window) Resize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_window_resize((*C.GtkWindow)(recv.native), c_width, c_height)

	return
}

// SetAcceptFocus is a wrapper around the C function gtk_window_set_accept_focus.
func (recv *Window) SetAcceptFocus(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_accept_focus((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetDecorated is a wrapper around the C function gtk_window_set_decorated.
func (recv *Window) SetDecorated(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_decorated((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetDefault is a wrapper around the C function gtk_window_set_default.
func (recv *Window) SetDefault(defaultWidget *Widget) {
	c_default_widget := (*C.GtkWidget)(C.NULL)
	if defaultWidget != nil {
		c_default_widget = (*C.GtkWidget)(defaultWidget.ToC())
	}

	C.gtk_window_set_default((*C.GtkWindow)(recv.native), c_default_widget)

	return
}

// SetDefaultSize is a wrapper around the C function gtk_window_set_default_size.
func (recv *Window) SetDefaultSize(width int32, height int32) {
	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_window_set_default_size((*C.GtkWindow)(recv.native), c_width, c_height)

	return
}

// SetDeletable is a wrapper around the C function gtk_window_set_deletable.
func (recv *Window) SetDeletable(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_deletable((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetDestroyWithParent is a wrapper around the C function gtk_window_set_destroy_with_parent.
func (recv *Window) SetDestroyWithParent(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_destroy_with_parent((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetFocus is a wrapper around the C function gtk_window_set_focus.
func (recv *Window) SetFocus(focus *Widget) {
	c_focus := (*C.GtkWidget)(C.NULL)
	if focus != nil {
		c_focus = (*C.GtkWidget)(focus.ToC())
	}

	C.gtk_window_set_focus((*C.GtkWindow)(recv.native), c_focus)

	return
}

// SetFocusOnMap is a wrapper around the C function gtk_window_set_focus_on_map.
func (recv *Window) SetFocusOnMap(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_focus_on_map((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetGeometryHints is a wrapper around the C function gtk_window_set_geometry_hints.
func (recv *Window) SetGeometryHints(geometryWidget *Widget, geometry *gdk.Geometry, geomMask gdk.WindowHints) {
	c_geometry_widget := (*C.GtkWidget)(C.NULL)
	if geometryWidget != nil {
		c_geometry_widget = (*C.GtkWidget)(geometryWidget.ToC())
	}

	c_geometry := (*C.GdkGeometry)(C.NULL)
	if geometry != nil {
		c_geometry = (*C.GdkGeometry)(geometry.ToC())
	}

	c_geom_mask := (C.GdkWindowHints)(geomMask)

	C.gtk_window_set_geometry_hints((*C.GtkWindow)(recv.native), c_geometry_widget, c_geometry, c_geom_mask)

	return
}

// SetGravity is a wrapper around the C function gtk_window_set_gravity.
func (recv *Window) SetGravity(gravity gdk.Gravity) {
	c_gravity := (C.GdkGravity)(gravity)

	C.gtk_window_set_gravity((*C.GtkWindow)(recv.native), c_gravity)

	return
}

// SetIcon is a wrapper around the C function gtk_window_set_icon.
func (recv *Window) SetIcon(icon *gdkpixbuf.Pixbuf) {
	c_icon := (*C.GdkPixbuf)(C.NULL)
	if icon != nil {
		c_icon = (*C.GdkPixbuf)(icon.ToC())
	}

	C.gtk_window_set_icon((*C.GtkWindow)(recv.native), c_icon)

	return
}

// SetIconFromFile is a wrapper around the C function gtk_window_set_icon_from_file.
func (recv *Window) SetIconFromFile(filename string) (bool, error) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	var cThrowableError *C.GError

	retC := C.gtk_window_set_icon_from_file((*C.GtkWindow)(recv.native), c_filename, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetIconList is a wrapper around the C function gtk_window_set_icon_list.
func (recv *Window) SetIconList(list *glib.List) {
	c_list := (*C.GList)(C.NULL)
	if list != nil {
		c_list = (*C.GList)(list.ToC())
	}

	C.gtk_window_set_icon_list((*C.GtkWindow)(recv.native), c_list)

	return
}

// SetIconName is a wrapper around the C function gtk_window_set_icon_name.
func (recv *Window) SetIconName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_window_set_icon_name((*C.GtkWindow)(recv.native), c_name)

	return
}

// SetKeepAbove is a wrapper around the C function gtk_window_set_keep_above.
func (recv *Window) SetKeepAbove(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_keep_above((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetKeepBelow is a wrapper around the C function gtk_window_set_keep_below.
func (recv *Window) SetKeepBelow(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_keep_below((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetMnemonicModifier is a wrapper around the C function gtk_window_set_mnemonic_modifier.
func (recv *Window) SetMnemonicModifier(modifier gdk.ModifierType) {
	c_modifier := (C.GdkModifierType)(modifier)

	C.gtk_window_set_mnemonic_modifier((*C.GtkWindow)(recv.native), c_modifier)

	return
}

// SetModal is a wrapper around the C function gtk_window_set_modal.
func (recv *Window) SetModal(modal bool) {
	c_modal :=
		boolToGboolean(modal)

	C.gtk_window_set_modal((*C.GtkWindow)(recv.native), c_modal)

	return
}

// SetOpacity is a wrapper around the C function gtk_window_set_opacity.
func (recv *Window) SetOpacity(opacity float64) {
	c_opacity := (C.gdouble)(opacity)

	C.gtk_window_set_opacity((*C.GtkWindow)(recv.native), c_opacity)

	return
}

// SetPosition is a wrapper around the C function gtk_window_set_position.
func (recv *Window) SetPosition(position WindowPosition) {
	c_position := (C.GtkWindowPosition)(position)

	C.gtk_window_set_position((*C.GtkWindow)(recv.native), c_position)

	return
}

// SetResizable is a wrapper around the C function gtk_window_set_resizable.
func (recv *Window) SetResizable(resizable bool) {
	c_resizable :=
		boolToGboolean(resizable)

	C.gtk_window_set_resizable((*C.GtkWindow)(recv.native), c_resizable)

	return
}

// SetRole is a wrapper around the C function gtk_window_set_role.
func (recv *Window) SetRole(role string) {
	c_role := C.CString(role)
	defer C.free(unsafe.Pointer(c_role))

	C.gtk_window_set_role((*C.GtkWindow)(recv.native), c_role)

	return
}

// SetScreen is a wrapper around the C function gtk_window_set_screen.
func (recv *Window) SetScreen(screen *gdk.Screen) {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	C.gtk_window_set_screen((*C.GtkWindow)(recv.native), c_screen)

	return
}

// SetSkipPagerHint is a wrapper around the C function gtk_window_set_skip_pager_hint.
func (recv *Window) SetSkipPagerHint(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_skip_pager_hint((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetSkipTaskbarHint is a wrapper around the C function gtk_window_set_skip_taskbar_hint.
func (recv *Window) SetSkipTaskbarHint(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_skip_taskbar_hint((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetStartupId is a wrapper around the C function gtk_window_set_startup_id.
func (recv *Window) SetStartupId(startupId string) {
	c_startup_id := C.CString(startupId)
	defer C.free(unsafe.Pointer(c_startup_id))

	C.gtk_window_set_startup_id((*C.GtkWindow)(recv.native), c_startup_id)

	return
}

// SetTitle is a wrapper around the C function gtk_window_set_title.
func (recv *Window) SetTitle(title string) {
	c_title := C.CString(title)
	defer C.free(unsafe.Pointer(c_title))

	C.gtk_window_set_title((*C.GtkWindow)(recv.native), c_title)

	return
}

// SetTransientFor is a wrapper around the C function gtk_window_set_transient_for.
func (recv *Window) SetTransientFor(parent *Window) {
	c_parent := (*C.GtkWindow)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWindow)(parent.ToC())
	}

	C.gtk_window_set_transient_for((*C.GtkWindow)(recv.native), c_parent)

	return
}

// SetTypeHint is a wrapper around the C function gtk_window_set_type_hint.
func (recv *Window) SetTypeHint(hint gdk.WindowTypeHint) {
	c_hint := (C.GdkWindowTypeHint)(hint)

	C.gtk_window_set_type_hint((*C.GtkWindow)(recv.native), c_hint)

	return
}

// SetUrgencyHint is a wrapper around the C function gtk_window_set_urgency_hint.
func (recv *Window) SetUrgencyHint(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_window_set_urgency_hint((*C.GtkWindow)(recv.native), c_setting)

	return
}

// SetWmclass is a wrapper around the C function gtk_window_set_wmclass.
func (recv *Window) SetWmclass(wmclassName string, wmclassClass string) {
	c_wmclass_name := C.CString(wmclassName)
	defer C.free(unsafe.Pointer(c_wmclass_name))

	c_wmclass_class := C.CString(wmclassClass)
	defer C.free(unsafe.Pointer(c_wmclass_class))

	C.gtk_window_set_wmclass((*C.GtkWindow)(recv.native), c_wmclass_name, c_wmclass_class)

	return
}

// Stick is a wrapper around the C function gtk_window_stick.
func (recv *Window) Stick() {
	C.gtk_window_stick((*C.GtkWindow)(recv.native))

	return
}

// Unfullscreen is a wrapper around the C function gtk_window_unfullscreen.
func (recv *Window) Unfullscreen() {
	C.gtk_window_unfullscreen((*C.GtkWindow)(recv.native))

	return
}

// Unmaximize is a wrapper around the C function gtk_window_unmaximize.
func (recv *Window) Unmaximize() {
	C.gtk_window_unmaximize((*C.GtkWindow)(recv.native))

	return
}

// Unstick is a wrapper around the C function gtk_window_unstick.
func (recv *Window) Unstick() {
	C.gtk_window_unstick((*C.GtkWindow)(recv.native))

	return
}

// ImplementorIface returns the ImplementorIface interface implemented by Window
func (recv *Window) ImplementorIface() *atk.ImplementorIface {
	return atk.ImplementorIfaceNewFromC(recv.ToC())
}

// Buildable returns the Buildable interface implemented by Window
func (recv *Window) Buildable() *Buildable {
	return BuildableNewFromC(recv.ToC())
}

// WindowAccessible is a wrapper around the C record GtkWindowAccessible.
type WindowAccessible struct {
	native *C.GtkWindowAccessible
	// parent : record
	// priv : record
}

func WindowAccessibleNewFromC(u unsafe.Pointer) *WindowAccessible {
	c := (*C.GtkWindowAccessible)(u)
	if c == nil {
		return nil
	}

	g := &WindowAccessible{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *WindowAccessible) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *WindowAccessible) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowAccessible with another WindowAccessible, and returns true if they represent the same GObject.
func (recv *WindowAccessible) Equals(other *WindowAccessible) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessible upcasts to *ContainerAccessible
func (recv *WindowAccessible) ContainerAccessible() *ContainerAccessible {
	return ContainerAccessibleNewFromC(unsafe.Pointer(recv.native))
}

// WidgetAccessible upcasts to *WidgetAccessible
func (recv *WindowAccessible) WidgetAccessible() *WidgetAccessible {
	return recv.ContainerAccessible().WidgetAccessible()
}

// Accessible upcasts to *Accessible
func (recv *WindowAccessible) Accessible() *Accessible {
	return recv.ContainerAccessible().Accessible()
}

// Object upcasts to *Object
func (recv *WindowAccessible) Object() *atk.Object {
	return recv.ContainerAccessible().Object()
}

// CastToWidget down casts any arbitrary Object to WindowAccessible.
// Exercise care, as this is a potentially dangerous function if the Object is not a WindowAccessible.
func CastToWindowAccessible(object *gobject.Object) *WindowAccessible {
	return WindowAccessibleNewFromC(object.ToC())
}

// Component returns the Component interface implemented by WindowAccessible
func (recv *WindowAccessible) Component() *atk.Component {
	return atk.ComponentNewFromC(recv.ToC())
}

// Window returns the Window interface implemented by WindowAccessible
func (recv *WindowAccessible) Window() *atk.Window {
	return atk.WindowNewFromC(recv.ToC())
}

// WindowGroup is a wrapper around the C record GtkWindowGroup.
type WindowGroup struct {
	native *C.GtkWindowGroup
	// parent_instance : record
	// priv : record
}

func WindowGroupNewFromC(u unsafe.Pointer) *WindowGroup {
	c := (*C.GtkWindowGroup)(u)
	if c == nil {
		return nil
	}

	g := &WindowGroup{native: c}

	ug := (C.gpointer)(u)
	if C.g_object_is_floating(ug) == C.TRUE {
		C.g_object_ref_sink(ug)
	} else {
		C.g_object_ref(ug)
	}
	runtime.SetFinalizer(g, func(o *WindowGroup) {
		C.g_object_unref((C.gpointer)(o.native))
	})

	return g
}

func (recv *WindowGroup) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowGroup with another WindowGroup, and returns true if they represent the same GObject.
func (recv *WindowGroup) Equals(other *WindowGroup) bool {
	return other.ToC() == recv.ToC()
}

// Object upcasts to *Object
func (recv *WindowGroup) Object() *gobject.Object {
	return gobject.ObjectNewFromC(unsafe.Pointer(recv.native))
}

// CastToWidget down casts any arbitrary Object to WindowGroup.
// Exercise care, as this is a potentially dangerous function if the Object is not a WindowGroup.
func CastToWindowGroup(object *gobject.Object) *WindowGroup {
	return WindowGroupNewFromC(object.ToC())
}

// WindowGroupNew is a wrapper around the C function gtk_window_group_new.
func WindowGroupNew() *WindowGroup {
	retC := C.gtk_window_group_new()
	retGo := WindowGroupNewFromC(unsafe.Pointer(retC))

	if retC != nil {
		C.g_object_unref((C.gpointer)(retC))
	}

	return retGo
}

// AddWindow is a wrapper around the C function gtk_window_group_add_window.
func (recv *WindowGroup) AddWindow(window *Window) {
	c_window := (*C.GtkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GtkWindow)(window.ToC())
	}

	C.gtk_window_group_add_window((*C.GtkWindowGroup)(recv.native), c_window)

	return
}

// RemoveWindow is a wrapper around the C function gtk_window_group_remove_window.
func (recv *WindowGroup) RemoveWindow(window *Window) {
	c_window := (*C.GtkWindow)(C.NULL)
	if window != nil {
		c_window = (*C.GtkWindow)(window.ToC())
	}

	C.gtk_window_group_remove_window((*C.GtkWindowGroup)(recv.native), c_window)

	return
}

const BINARY_AGE int32 = C.GTK_BINARY_AGE
const INPUT_ERROR int32 = C.GTK_INPUT_ERROR
const INTERFACE_AGE int32 = C.GTK_INTERFACE_AGE
const MAJOR_VERSION int32 = C.GTK_MAJOR_VERSION
const MAX_COMPOSE_LEN int32 = C.GTK_MAX_COMPOSE_LEN
const MICRO_VERSION int32 = C.GTK_MICRO_VERSION
const MINOR_VERSION int32 = C.GTK_MINOR_VERSION
const PAPER_NAME_A3 string = C.GTK_PAPER_NAME_A3
const PAPER_NAME_A4 string = C.GTK_PAPER_NAME_A4
const PAPER_NAME_A5 string = C.GTK_PAPER_NAME_A5
const PAPER_NAME_B5 string = C.GTK_PAPER_NAME_B5
const PAPER_NAME_EXECUTIVE string = C.GTK_PAPER_NAME_EXECUTIVE
const PAPER_NAME_LEGAL string = C.GTK_PAPER_NAME_LEGAL
const PAPER_NAME_LETTER string = C.GTK_PAPER_NAME_LETTER
const PATH_PRIO_MASK int32 = C.GTK_PATH_PRIO_MASK
const PRINT_SETTINGS_COLLATE string = C.GTK_PRINT_SETTINGS_COLLATE
const PRINT_SETTINGS_DEFAULT_SOURCE string = C.GTK_PRINT_SETTINGS_DEFAULT_SOURCE
const PRINT_SETTINGS_DITHER string = C.GTK_PRINT_SETTINGS_DITHER
const PRINT_SETTINGS_DUPLEX string = C.GTK_PRINT_SETTINGS_DUPLEX
const PRINT_SETTINGS_FINISHINGS string = C.GTK_PRINT_SETTINGS_FINISHINGS
const PRINT_SETTINGS_MEDIA_TYPE string = C.GTK_PRINT_SETTINGS_MEDIA_TYPE
const PRINT_SETTINGS_NUMBER_UP string = C.GTK_PRINT_SETTINGS_NUMBER_UP
const PRINT_SETTINGS_NUMBER_UP_LAYOUT string = C.GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT
const PRINT_SETTINGS_N_COPIES string = C.GTK_PRINT_SETTINGS_N_COPIES
const PRINT_SETTINGS_ORIENTATION string = C.GTK_PRINT_SETTINGS_ORIENTATION
const PRINT_SETTINGS_OUTPUT_BIN string = C.GTK_PRINT_SETTINGS_OUTPUT_BIN
const PRINT_SETTINGS_OUTPUT_FILE_FORMAT string = C.GTK_PRINT_SETTINGS_OUTPUT_FILE_FORMAT
const PRINT_SETTINGS_OUTPUT_URI string = C.GTK_PRINT_SETTINGS_OUTPUT_URI
const PRINT_SETTINGS_PAGE_RANGES string = C.GTK_PRINT_SETTINGS_PAGE_RANGES
const PRINT_SETTINGS_PAGE_SET string = C.GTK_PRINT_SETTINGS_PAGE_SET
const PRINT_SETTINGS_PAPER_FORMAT string = C.GTK_PRINT_SETTINGS_PAPER_FORMAT
const PRINT_SETTINGS_PAPER_HEIGHT string = C.GTK_PRINT_SETTINGS_PAPER_HEIGHT
const PRINT_SETTINGS_PAPER_WIDTH string = C.GTK_PRINT_SETTINGS_PAPER_WIDTH
const PRINT_SETTINGS_PRINTER string = C.GTK_PRINT_SETTINGS_PRINTER
const PRINT_SETTINGS_PRINTER_LPI string = C.GTK_PRINT_SETTINGS_PRINTER_LPI
const PRINT_SETTINGS_PRINT_PAGES string = C.GTK_PRINT_SETTINGS_PRINT_PAGES
const PRINT_SETTINGS_QUALITY string = C.GTK_PRINT_SETTINGS_QUALITY
const PRINT_SETTINGS_RESOLUTION string = C.GTK_PRINT_SETTINGS_RESOLUTION
const PRINT_SETTINGS_RESOLUTION_X string = C.GTK_PRINT_SETTINGS_RESOLUTION_X
const PRINT_SETTINGS_RESOLUTION_Y string = C.GTK_PRINT_SETTINGS_RESOLUTION_Y
const PRINT_SETTINGS_REVERSE string = C.GTK_PRINT_SETTINGS_REVERSE
const PRINT_SETTINGS_SCALE string = C.GTK_PRINT_SETTINGS_SCALE
const PRINT_SETTINGS_USE_COLOR string = C.GTK_PRINT_SETTINGS_USE_COLOR
const PRINT_SETTINGS_WIN32_DRIVER_EXTRA string = C.GTK_PRINT_SETTINGS_WIN32_DRIVER_EXTRA
const PRINT_SETTINGS_WIN32_DRIVER_VERSION string = C.GTK_PRINT_SETTINGS_WIN32_DRIVER_VERSION
const PRIORITY_RESIZE int32 = C.GTK_PRIORITY_RESIZE

// Blacklisted : STOCK_ABOUT

// Blacklisted : STOCK_ADD

// Blacklisted : STOCK_APPLY

// Blacklisted : STOCK_BOLD

// Blacklisted : STOCK_CANCEL

// Blacklisted : STOCK_CDROM

// Blacklisted : STOCK_CLEAR

// Blacklisted : STOCK_CLOSE

// Blacklisted : STOCK_COLOR_PICKER

// Blacklisted : STOCK_CONNECT

// Blacklisted : STOCK_CONVERT

// Blacklisted : STOCK_COPY

// Blacklisted : STOCK_CUT

// Blacklisted : STOCK_DELETE

// Blacklisted : STOCK_DIALOG_AUTHENTICATION

// Blacklisted : STOCK_DIALOG_ERROR

// Blacklisted : STOCK_DIALOG_INFO

// Blacklisted : STOCK_DIALOG_QUESTION

// Blacklisted : STOCK_DIALOG_WARNING

// Blacklisted : STOCK_DIRECTORY

// Blacklisted : STOCK_DISCARD

// Blacklisted : STOCK_DISCONNECT

// Blacklisted : STOCK_DND

// Blacklisted : STOCK_DND_MULTIPLE

// Blacklisted : STOCK_EDIT

// Blacklisted : STOCK_EXECUTE

// Blacklisted : STOCK_FILE

// Blacklisted : STOCK_FIND

// Blacklisted : STOCK_FIND_AND_REPLACE

// Blacklisted : STOCK_FLOPPY

// Blacklisted : STOCK_FULLSCREEN

// Blacklisted : STOCK_GOTO_BOTTOM

// Blacklisted : STOCK_GOTO_FIRST

// Blacklisted : STOCK_GOTO_LAST

// Blacklisted : STOCK_GOTO_TOP

// Blacklisted : STOCK_GO_BACK

// Blacklisted : STOCK_GO_DOWN

// Blacklisted : STOCK_GO_FORWARD

// Blacklisted : STOCK_GO_UP

// Blacklisted : STOCK_HARDDISK

// Blacklisted : STOCK_HELP

// Blacklisted : STOCK_HOME

// Blacklisted : STOCK_INDENT

// Blacklisted : STOCK_INDEX

// Blacklisted : STOCK_INFO

// Blacklisted : STOCK_ITALIC

// Blacklisted : STOCK_JUMP_TO

// Blacklisted : STOCK_JUSTIFY_CENTER

// Blacklisted : STOCK_JUSTIFY_FILL

// Blacklisted : STOCK_JUSTIFY_LEFT

// Blacklisted : STOCK_JUSTIFY_RIGHT

// Blacklisted : STOCK_LEAVE_FULLSCREEN

// Blacklisted : STOCK_MEDIA_FORWARD

// Blacklisted : STOCK_MEDIA_NEXT

// Blacklisted : STOCK_MEDIA_PAUSE

// Blacklisted : STOCK_MEDIA_PLAY

// Blacklisted : STOCK_MEDIA_PREVIOUS

// Blacklisted : STOCK_MEDIA_RECORD

// Blacklisted : STOCK_MEDIA_REWIND

// Blacklisted : STOCK_MEDIA_STOP

// Blacklisted : STOCK_MISSING_IMAGE

// Blacklisted : STOCK_NETWORK

// Blacklisted : STOCK_NEW

// Blacklisted : STOCK_NO

// Blacklisted : STOCK_OK

// Blacklisted : STOCK_OPEN

// Blacklisted : STOCK_ORIENTATION_LANDSCAPE

// Blacklisted : STOCK_ORIENTATION_PORTRAIT

// Blacklisted : STOCK_ORIENTATION_REVERSE_LANDSCAPE

// Blacklisted : STOCK_ORIENTATION_REVERSE_PORTRAIT

// Blacklisted : STOCK_PASTE

// Blacklisted : STOCK_PREFERENCES

// Blacklisted : STOCK_PRINT

// Blacklisted : STOCK_PRINT_PREVIEW

// Blacklisted : STOCK_PROPERTIES

// Blacklisted : STOCK_QUIT

// Blacklisted : STOCK_REDO

// Blacklisted : STOCK_REFRESH

// Blacklisted : STOCK_REMOVE

// Blacklisted : STOCK_REVERT_TO_SAVED

// Blacklisted : STOCK_SAVE

// Blacklisted : STOCK_SAVE_AS

// Blacklisted : STOCK_SELECT_ALL

// Blacklisted : STOCK_SELECT_COLOR

// Blacklisted : STOCK_SELECT_FONT

// Blacklisted : STOCK_SORT_ASCENDING

// Blacklisted : STOCK_SORT_DESCENDING

// Blacklisted : STOCK_SPELL_CHECK

// Blacklisted : STOCK_STOP

// Blacklisted : STOCK_STRIKETHROUGH

// Blacklisted : STOCK_UNDELETE

// Blacklisted : STOCK_UNDERLINE

// Blacklisted : STOCK_UNDO

// Blacklisted : STOCK_UNINDENT

// Blacklisted : STOCK_YES

// Blacklisted : STOCK_ZOOM_100

// Blacklisted : STOCK_ZOOM_FIT

// Blacklisted : STOCK_ZOOM_IN

// Blacklisted : STOCK_ZOOM_OUT

const STYLE_CLASS_ACCELERATOR string = C.GTK_STYLE_CLASS_ACCELERATOR
const STYLE_CLASS_ARROW string = C.GTK_STYLE_CLASS_ARROW
const STYLE_CLASS_BACKGROUND string = C.GTK_STYLE_CLASS_BACKGROUND
const STYLE_CLASS_BOTTOM string = C.GTK_STYLE_CLASS_BOTTOM
const STYLE_CLASS_BUTTON string = C.GTK_STYLE_CLASS_BUTTON
const STYLE_CLASS_CALENDAR string = C.GTK_STYLE_CLASS_CALENDAR
const STYLE_CLASS_CELL string = C.GTK_STYLE_CLASS_CELL
const STYLE_CLASS_CHECK string = C.GTK_STYLE_CLASS_CHECK
const STYLE_CLASS_COMBOBOX_ENTRY string = C.GTK_STYLE_CLASS_COMBOBOX_ENTRY
const STYLE_CLASS_CONTEXT_MENU string = C.GTK_STYLE_CLASS_CONTEXT_MENU
const STYLE_CLASS_CURSOR_HANDLE string = C.GTK_STYLE_CLASS_CURSOR_HANDLE
const STYLE_CLASS_DEFAULT string = C.GTK_STYLE_CLASS_DEFAULT
const STYLE_CLASS_DIM_LABEL string = C.GTK_STYLE_CLASS_DIM_LABEL
const STYLE_CLASS_DND string = C.GTK_STYLE_CLASS_DND
const STYLE_CLASS_DOCK string = C.GTK_STYLE_CLASS_DOCK
const STYLE_CLASS_ENTRY string = C.GTK_STYLE_CLASS_ENTRY
const STYLE_CLASS_ERROR string = C.GTK_STYLE_CLASS_ERROR
const STYLE_CLASS_EXPANDER string = C.GTK_STYLE_CLASS_EXPANDER
const STYLE_CLASS_FRAME string = C.GTK_STYLE_CLASS_FRAME
const STYLE_CLASS_GRIP string = C.GTK_STYLE_CLASS_GRIP
const STYLE_CLASS_HEADER string = C.GTK_STYLE_CLASS_HEADER
const STYLE_CLASS_HIGHLIGHT string = C.GTK_STYLE_CLASS_HIGHLIGHT
const STYLE_CLASS_HORIZONTAL string = C.GTK_STYLE_CLASS_HORIZONTAL
const STYLE_CLASS_IMAGE string = C.GTK_STYLE_CLASS_IMAGE
const STYLE_CLASS_INFO string = C.GTK_STYLE_CLASS_INFO
const STYLE_CLASS_INLINE_TOOLBAR string = C.GTK_STYLE_CLASS_INLINE_TOOLBAR
const STYLE_CLASS_INSERTION_CURSOR string = C.GTK_STYLE_CLASS_INSERTION_CURSOR
const STYLE_CLASS_LEFT string = C.GTK_STYLE_CLASS_LEFT
const STYLE_CLASS_LEVEL_BAR string = C.GTK_STYLE_CLASS_LEVEL_BAR
const STYLE_CLASS_LINKED string = C.GTK_STYLE_CLASS_LINKED
const STYLE_CLASS_LIST string = C.GTK_STYLE_CLASS_LIST
const STYLE_CLASS_LIST_ROW string = C.GTK_STYLE_CLASS_LIST_ROW
const STYLE_CLASS_MARK string = C.GTK_STYLE_CLASS_MARK
const STYLE_CLASS_MENU string = C.GTK_STYLE_CLASS_MENU
const STYLE_CLASS_MENUBAR string = C.GTK_STYLE_CLASS_MENUBAR
const STYLE_CLASS_MENUITEM string = C.GTK_STYLE_CLASS_MENUITEM
const STYLE_CLASS_NOTEBOOK string = C.GTK_STYLE_CLASS_NOTEBOOK
const STYLE_CLASS_OSD string = C.GTK_STYLE_CLASS_OSD
const STYLE_CLASS_PANE_SEPARATOR string = C.GTK_STYLE_CLASS_PANE_SEPARATOR
const STYLE_CLASS_PRIMARY_TOOLBAR string = C.GTK_STYLE_CLASS_PRIMARY_TOOLBAR
const STYLE_CLASS_PROGRESSBAR string = C.GTK_STYLE_CLASS_PROGRESSBAR
const STYLE_CLASS_PULSE string = C.GTK_STYLE_CLASS_PULSE
const STYLE_CLASS_QUESTION string = C.GTK_STYLE_CLASS_QUESTION
const STYLE_CLASS_RADIO string = C.GTK_STYLE_CLASS_RADIO
const STYLE_CLASS_RAISED string = C.GTK_STYLE_CLASS_RAISED
const STYLE_CLASS_READ_ONLY string = C.GTK_STYLE_CLASS_READ_ONLY
const STYLE_CLASS_RIGHT string = C.GTK_STYLE_CLASS_RIGHT
const STYLE_CLASS_RUBBERBAND string = C.GTK_STYLE_CLASS_RUBBERBAND
const STYLE_CLASS_SCALE string = C.GTK_STYLE_CLASS_SCALE
const STYLE_CLASS_SCALE_HAS_MARKS_ABOVE string = C.GTK_STYLE_CLASS_SCALE_HAS_MARKS_ABOVE
const STYLE_CLASS_SCALE_HAS_MARKS_BELOW string = C.GTK_STYLE_CLASS_SCALE_HAS_MARKS_BELOW
const STYLE_CLASS_SCROLLBAR string = C.GTK_STYLE_CLASS_SCROLLBAR
const STYLE_CLASS_SCROLLBARS_JUNCTION string = C.GTK_STYLE_CLASS_SCROLLBARS_JUNCTION
const STYLE_CLASS_SEPARATOR string = C.GTK_STYLE_CLASS_SEPARATOR
const STYLE_CLASS_SIDEBAR string = C.GTK_STYLE_CLASS_SIDEBAR
const STYLE_CLASS_SLIDER string = C.GTK_STYLE_CLASS_SLIDER
const STYLE_CLASS_SPINBUTTON string = C.GTK_STYLE_CLASS_SPINBUTTON
const STYLE_CLASS_SPINNER string = C.GTK_STYLE_CLASS_SPINNER
const STYLE_CLASS_TITLEBAR string = C.GTK_STYLE_CLASS_TITLEBAR
const STYLE_CLASS_TOOLBAR string = C.GTK_STYLE_CLASS_TOOLBAR
const STYLE_CLASS_TOOLTIP string = C.GTK_STYLE_CLASS_TOOLTIP
const STYLE_CLASS_TOP string = C.GTK_STYLE_CLASS_TOP
const STYLE_CLASS_TROUGH string = C.GTK_STYLE_CLASS_TROUGH
const STYLE_CLASS_VERTICAL string = C.GTK_STYLE_CLASS_VERTICAL
const STYLE_CLASS_VIEW string = C.GTK_STYLE_CLASS_VIEW
const STYLE_CLASS_WARNING string = C.GTK_STYLE_CLASS_WARNING
const STYLE_PROPERTY_BACKGROUND_COLOR string = C.GTK_STYLE_PROPERTY_BACKGROUND_COLOR
const STYLE_PROPERTY_BACKGROUND_IMAGE string = C.GTK_STYLE_PROPERTY_BACKGROUND_IMAGE
const STYLE_PROPERTY_BORDER_COLOR string = C.GTK_STYLE_PROPERTY_BORDER_COLOR
const STYLE_PROPERTY_BORDER_RADIUS string = C.GTK_STYLE_PROPERTY_BORDER_RADIUS
const STYLE_PROPERTY_BORDER_STYLE string = C.GTK_STYLE_PROPERTY_BORDER_STYLE
const STYLE_PROPERTY_BORDER_WIDTH string = C.GTK_STYLE_PROPERTY_BORDER_WIDTH
const STYLE_PROPERTY_COLOR string = C.GTK_STYLE_PROPERTY_COLOR
const STYLE_PROPERTY_FONT string = C.GTK_STYLE_PROPERTY_FONT
const STYLE_PROPERTY_MARGIN string = C.GTK_STYLE_PROPERTY_MARGIN
const STYLE_PROPERTY_PADDING string = C.GTK_STYLE_PROPERTY_PADDING
const STYLE_PROVIDER_PRIORITY_APPLICATION int32 = C.GTK_STYLE_PROVIDER_PRIORITY_APPLICATION
const STYLE_PROVIDER_PRIORITY_FALLBACK int32 = C.GTK_STYLE_PROVIDER_PRIORITY_FALLBACK
const STYLE_PROVIDER_PRIORITY_SETTINGS int32 = C.GTK_STYLE_PROVIDER_PRIORITY_SETTINGS
const STYLE_PROVIDER_PRIORITY_THEME int32 = C.GTK_STYLE_PROVIDER_PRIORITY_THEME
const STYLE_PROVIDER_PRIORITY_USER int32 = C.GTK_STYLE_PROVIDER_PRIORITY_USER
const STYLE_REGION_COLUMN string = C.GTK_STYLE_REGION_COLUMN
const STYLE_REGION_COLUMN_HEADER string = C.GTK_STYLE_REGION_COLUMN_HEADER
const STYLE_REGION_ROW string = C.GTK_STYLE_REGION_ROW
const STYLE_REGION_TAB string = C.GTK_STYLE_REGION_TAB
const TEXT_VIEW_PRIORITY_VALIDATE int32 = C.GTK_TEXT_VIEW_PRIORITY_VALIDATE
const TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID int32 = C.GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID
const TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID int32 = C.GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID

type Align C.GtkAlign

const (
	GTK_ALIGN_FILL     Align = 0
	GTK_ALIGN_START    Align = 1
	GTK_ALIGN_END      Align = 2
	GTK_ALIGN_CENTER   Align = 3
	GTK_ALIGN_BASELINE Align = 4
)

type ArrowPlacement C.GtkArrowPlacement

const (
	GTK_ARROWS_BOTH  ArrowPlacement = 0
	GTK_ARROWS_START ArrowPlacement = 1
	GTK_ARROWS_END   ArrowPlacement = 2
)

type ArrowType C.GtkArrowType

const (
	GTK_ARROW_UP    ArrowType = 0
	GTK_ARROW_DOWN  ArrowType = 1
	GTK_ARROW_LEFT  ArrowType = 2
	GTK_ARROW_RIGHT ArrowType = 3
	GTK_ARROW_NONE  ArrowType = 4
)

type AssistantPageType C.GtkAssistantPageType

const (
	GTK_ASSISTANT_PAGE_CONTENT  AssistantPageType = 0
	GTK_ASSISTANT_PAGE_INTRO    AssistantPageType = 1
	GTK_ASSISTANT_PAGE_CONFIRM  AssistantPageType = 2
	GTK_ASSISTANT_PAGE_SUMMARY  AssistantPageType = 3
	GTK_ASSISTANT_PAGE_PROGRESS AssistantPageType = 4
	GTK_ASSISTANT_PAGE_CUSTOM   AssistantPageType = 5
)

type BorderStyle C.GtkBorderStyle

const (
	GTK_BORDER_STYLE_NONE   BorderStyle = 0
	GTK_BORDER_STYLE_SOLID  BorderStyle = 1
	GTK_BORDER_STYLE_INSET  BorderStyle = 2
	GTK_BORDER_STYLE_OUTSET BorderStyle = 3
	GTK_BORDER_STYLE_HIDDEN BorderStyle = 4
	GTK_BORDER_STYLE_DOTTED BorderStyle = 5
	GTK_BORDER_STYLE_DASHED BorderStyle = 6
	GTK_BORDER_STYLE_DOUBLE BorderStyle = 7
	GTK_BORDER_STYLE_GROOVE BorderStyle = 8
	GTK_BORDER_STYLE_RIDGE  BorderStyle = 9
)

type BuilderError C.GtkBuilderError

const (
	GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION  BuilderError = 0
	GTK_BUILDER_ERROR_UNHANDLED_TAG          BuilderError = 1
	GTK_BUILDER_ERROR_MISSING_ATTRIBUTE      BuilderError = 2
	GTK_BUILDER_ERROR_INVALID_ATTRIBUTE      BuilderError = 3
	GTK_BUILDER_ERROR_INVALID_TAG            BuilderError = 4
	GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE BuilderError = 5
	GTK_BUILDER_ERROR_INVALID_VALUE          BuilderError = 6
	GTK_BUILDER_ERROR_VERSION_MISMATCH       BuilderError = 7
	GTK_BUILDER_ERROR_DUPLICATE_ID           BuilderError = 8
	GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED    BuilderError = 9
	GTK_BUILDER_ERROR_TEMPLATE_MISMATCH      BuilderError = 10
	GTK_BUILDER_ERROR_INVALID_PROPERTY       BuilderError = 11
	GTK_BUILDER_ERROR_INVALID_SIGNAL         BuilderError = 12
	GTK_BUILDER_ERROR_INVALID_ID             BuilderError = 13
)

// BuilderErrorQuark is a wrapper around the C function gtk_builder_error_quark.
func BuilderErrorQuark() glib.Quark {
	retC := C.gtk_builder_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type ButtonBoxStyle C.GtkButtonBoxStyle

const (
	GTK_BUTTONBOX_SPREAD ButtonBoxStyle = 1
	GTK_BUTTONBOX_EDGE   ButtonBoxStyle = 2
	GTK_BUTTONBOX_START  ButtonBoxStyle = 3
	GTK_BUTTONBOX_END    ButtonBoxStyle = 4
	GTK_BUTTONBOX_CENTER ButtonBoxStyle = 5
	GTK_BUTTONBOX_EXPAND ButtonBoxStyle = 6
)

type ButtonRole C.GtkButtonRole

const (
	GTK_BUTTON_ROLE_NORMAL ButtonRole = 0
	GTK_BUTTON_ROLE_CHECK  ButtonRole = 1
	GTK_BUTTON_ROLE_RADIO  ButtonRole = 2
)

type ButtonsType C.GtkButtonsType

const (
	GTK_BUTTONS_NONE      ButtonsType = 0
	GTK_BUTTONS_OK        ButtonsType = 1
	GTK_BUTTONS_CLOSE     ButtonsType = 2
	GTK_BUTTONS_CANCEL    ButtonsType = 3
	GTK_BUTTONS_YES_NO    ButtonsType = 4
	GTK_BUTTONS_OK_CANCEL ButtonsType = 5
)

type CellRendererAccelMode C.GtkCellRendererAccelMode

const (
	GTK_CELL_RENDERER_ACCEL_MODE_GTK          CellRendererAccelMode = 0
	GTK_CELL_RENDERER_ACCEL_MODE_OTHER        CellRendererAccelMode = 1
	GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP CellRendererAccelMode = 2
)

type CellRendererMode C.GtkCellRendererMode

const (
	GTK_CELL_RENDERER_MODE_INERT       CellRendererMode = 0
	GTK_CELL_RENDERER_MODE_ACTIVATABLE CellRendererMode = 1
	GTK_CELL_RENDERER_MODE_EDITABLE    CellRendererMode = 2
)

type CornerType C.GtkCornerType

const (
	GTK_CORNER_TOP_LEFT     CornerType = 0
	GTK_CORNER_BOTTOM_LEFT  CornerType = 1
	GTK_CORNER_TOP_RIGHT    CornerType = 2
	GTK_CORNER_BOTTOM_RIGHT CornerType = 3
)

type CssProviderError C.GtkCssProviderError

const (
	GTK_CSS_PROVIDER_ERROR_FAILED        CssProviderError = 0
	GTK_CSS_PROVIDER_ERROR_SYNTAX        CssProviderError = 1
	GTK_CSS_PROVIDER_ERROR_IMPORT        CssProviderError = 2
	GTK_CSS_PROVIDER_ERROR_NAME          CssProviderError = 3
	GTK_CSS_PROVIDER_ERROR_DEPRECATED    CssProviderError = 4
	GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE CssProviderError = 5
)

// CssProviderErrorQuark is a wrapper around the C function gtk_css_provider_error_quark.
func CssProviderErrorQuark() glib.Quark {
	retC := C.gtk_css_provider_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type DeleteType C.GtkDeleteType

const (
	GTK_DELETE_CHARS             DeleteType = 0
	GTK_DELETE_WORD_ENDS         DeleteType = 1
	GTK_DELETE_WORDS             DeleteType = 2
	GTK_DELETE_DISPLAY_LINES     DeleteType = 3
	GTK_DELETE_DISPLAY_LINE_ENDS DeleteType = 4
	GTK_DELETE_PARAGRAPH_ENDS    DeleteType = 5
	GTK_DELETE_PARAGRAPHS        DeleteType = 6
	GTK_DELETE_WHITESPACE        DeleteType = 7
)

type DirectionType C.GtkDirectionType

const (
	GTK_DIR_TAB_FORWARD  DirectionType = 0
	GTK_DIR_TAB_BACKWARD DirectionType = 1
	GTK_DIR_UP           DirectionType = 2
	GTK_DIR_DOWN         DirectionType = 3
	GTK_DIR_LEFT         DirectionType = 4
	GTK_DIR_RIGHT        DirectionType = 5
)

type DragResult C.GtkDragResult

const (
	GTK_DRAG_RESULT_SUCCESS         DragResult = 0
	GTK_DRAG_RESULT_NO_TARGET       DragResult = 1
	GTK_DRAG_RESULT_USER_CANCELLED  DragResult = 2
	GTK_DRAG_RESULT_TIMEOUT_EXPIRED DragResult = 3
	GTK_DRAG_RESULT_GRAB_BROKEN     DragResult = 4
	GTK_DRAG_RESULT_ERROR           DragResult = 5
)

type ExpanderStyle C.GtkExpanderStyle

const (
	GTK_EXPANDER_COLLAPSED      ExpanderStyle = 0
	GTK_EXPANDER_SEMI_COLLAPSED ExpanderStyle = 1
	GTK_EXPANDER_SEMI_EXPANDED  ExpanderStyle = 2
	GTK_EXPANDER_EXPANDED       ExpanderStyle = 3
)

type FileChooserAction C.GtkFileChooserAction

const (
	GTK_FILE_CHOOSER_ACTION_OPEN          FileChooserAction = 0
	GTK_FILE_CHOOSER_ACTION_SAVE          FileChooserAction = 1
	GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER FileChooserAction = 2
	GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER FileChooserAction = 3
)

type FileChooserConfirmation C.GtkFileChooserConfirmation

const (
	GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM         FileChooserConfirmation = 0
	GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME FileChooserConfirmation = 1
	GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN    FileChooserConfirmation = 2
)

type FileChooserError C.GtkFileChooserError

const (
	GTK_FILE_CHOOSER_ERROR_NONEXISTENT         FileChooserError = 0
	GTK_FILE_CHOOSER_ERROR_BAD_FILENAME        FileChooserError = 1
	GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS      FileChooserError = 2
	GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME FileChooserError = 3
)

// FileChooserErrorQuark is a wrapper around the C function gtk_file_chooser_error_quark.
func FileChooserErrorQuark() glib.Quark {
	retC := C.gtk_file_chooser_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type IMPreeditStyle C.GtkIMPreeditStyle

const (
	GTK_IM_PREEDIT_NOTHING  IMPreeditStyle = 0
	GTK_IM_PREEDIT_CALLBACK IMPreeditStyle = 1
	GTK_IM_PREEDIT_NONE     IMPreeditStyle = 2
)

type IMStatusStyle C.GtkIMStatusStyle

const (
	GTK_IM_STATUS_NOTHING  IMStatusStyle = 0
	GTK_IM_STATUS_CALLBACK IMStatusStyle = 1
	GTK_IM_STATUS_NONE     IMStatusStyle = 2
)

type IconSize C.GtkIconSize

const (
	GTK_ICON_SIZE_INVALID       IconSize = 0
	GTK_ICON_SIZE_MENU          IconSize = 1
	GTK_ICON_SIZE_SMALL_TOOLBAR IconSize = 2
	GTK_ICON_SIZE_LARGE_TOOLBAR IconSize = 3
	GTK_ICON_SIZE_BUTTON        IconSize = 4
	GTK_ICON_SIZE_DND           IconSize = 5
	GTK_ICON_SIZE_DIALOG        IconSize = 6
)

// IconSizeFromName is a wrapper around the C function gtk_icon_size_from_name.
func IconSizeFromName(name string) IconSize {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_icon_size_from_name(c_name)
	retGo := (IconSize)(retC)

	return retGo
}

// IconSizeGetName is a wrapper around the C function gtk_icon_size_get_name.
func IconSizeGetName(size IconSize) string {
	c_size := (C.GtkIconSize)(size)

	retC := C.gtk_icon_size_get_name(c_size)
	retGo := C.GoString(retC)

	return retGo
}

// IconSizeLookup is a wrapper around the C function gtk_icon_size_lookup.
func IconSizeLookup(size IconSize) (bool, int32, int32) {
	c_size := (C.GtkIconSize)(size)

	var c_width C.gint

	var c_height C.gint

	retC := C.gtk_icon_size_lookup(c_size, &c_width, &c_height)
	retGo := retC == C.TRUE

	width := (int32)(c_width)

	height := (int32)(c_height)

	return retGo, width, height
}

// IconSizeLookupForSettings is a wrapper around the C function gtk_icon_size_lookup_for_settings.
func IconSizeLookupForSettings(settings *Settings, size IconSize) (bool, int32, int32) {
	c_settings := (*C.GtkSettings)(C.NULL)
	if settings != nil {
		c_settings = (*C.GtkSettings)(settings.ToC())
	}

	c_size := (C.GtkIconSize)(size)

	var c_width C.gint

	var c_height C.gint

	retC := C.gtk_icon_size_lookup_for_settings(c_settings, c_size, &c_width, &c_height)
	retGo := retC == C.TRUE

	width := (int32)(c_width)

	height := (int32)(c_height)

	return retGo, width, height
}

// IconSizeRegister is a wrapper around the C function gtk_icon_size_register.
func IconSizeRegister(name string, width int32, height int32) IconSize {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	retC := C.gtk_icon_size_register(c_name, c_width, c_height)
	retGo := (IconSize)(retC)

	return retGo
}

// IconSizeRegisterAlias is a wrapper around the C function gtk_icon_size_register_alias.
func IconSizeRegisterAlias(alias string, target IconSize) {
	c_alias := C.CString(alias)
	defer C.free(unsafe.Pointer(c_alias))

	c_target := (C.GtkIconSize)(target)

	C.gtk_icon_size_register_alias(c_alias, c_target)

	return
}

type IconThemeError C.GtkIconThemeError

const (
	GTK_ICON_THEME_NOT_FOUND IconThemeError = 0
	GTK_ICON_THEME_FAILED    IconThemeError = 1
)

// IconThemeErrorQuark is a wrapper around the C function gtk_icon_theme_error_quark.
func IconThemeErrorQuark() glib.Quark {
	retC := C.gtk_icon_theme_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type IconViewDropPosition C.GtkIconViewDropPosition

const (
	GTK_ICON_VIEW_NO_DROP    IconViewDropPosition = 0
	GTK_ICON_VIEW_DROP_INTO  IconViewDropPosition = 1
	GTK_ICON_VIEW_DROP_LEFT  IconViewDropPosition = 2
	GTK_ICON_VIEW_DROP_RIGHT IconViewDropPosition = 3
	GTK_ICON_VIEW_DROP_ABOVE IconViewDropPosition = 4
	GTK_ICON_VIEW_DROP_BELOW IconViewDropPosition = 5
)

type ImageType C.GtkImageType

const (
	GTK_IMAGE_EMPTY     ImageType = 0
	GTK_IMAGE_PIXBUF    ImageType = 1
	GTK_IMAGE_STOCK     ImageType = 2
	GTK_IMAGE_ICON_SET  ImageType = 3
	GTK_IMAGE_ANIMATION ImageType = 4
	GTK_IMAGE_ICON_NAME ImageType = 5
	GTK_IMAGE_GICON     ImageType = 6
	GTK_IMAGE_SURFACE   ImageType = 7
)

type Justification C.GtkJustification

const (
	GTK_JUSTIFY_LEFT   Justification = 0
	GTK_JUSTIFY_RIGHT  Justification = 1
	GTK_JUSTIFY_CENTER Justification = 2
	GTK_JUSTIFY_FILL   Justification = 3
)

type MenuDirectionType C.GtkMenuDirectionType

const (
	GTK_MENU_DIR_PARENT MenuDirectionType = 0
	GTK_MENU_DIR_CHILD  MenuDirectionType = 1
	GTK_MENU_DIR_NEXT   MenuDirectionType = 2
	GTK_MENU_DIR_PREV   MenuDirectionType = 3
)

type MessageType C.GtkMessageType

const (
	GTK_MESSAGE_INFO     MessageType = 0
	GTK_MESSAGE_WARNING  MessageType = 1
	GTK_MESSAGE_QUESTION MessageType = 2
	GTK_MESSAGE_ERROR    MessageType = 3
	GTK_MESSAGE_OTHER    MessageType = 4
)

type MovementStep C.GtkMovementStep

const (
	GTK_MOVEMENT_LOGICAL_POSITIONS MovementStep = 0
	GTK_MOVEMENT_VISUAL_POSITIONS  MovementStep = 1
	GTK_MOVEMENT_WORDS             MovementStep = 2
	GTK_MOVEMENT_DISPLAY_LINES     MovementStep = 3
	GTK_MOVEMENT_DISPLAY_LINE_ENDS MovementStep = 4
	GTK_MOVEMENT_PARAGRAPHS        MovementStep = 5
	GTK_MOVEMENT_PARAGRAPH_ENDS    MovementStep = 6
	GTK_MOVEMENT_PAGES             MovementStep = 7
	GTK_MOVEMENT_BUFFER_ENDS       MovementStep = 8
	GTK_MOVEMENT_HORIZONTAL_PAGES  MovementStep = 9
)

type NotebookTab C.GtkNotebookTab

const (
	GTK_NOTEBOOK_TAB_FIRST NotebookTab = 0
	GTK_NOTEBOOK_TAB_LAST  NotebookTab = 1
)

type NumberUpLayout C.GtkNumberUpLayout

const (
	GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM NumberUpLayout = 0
	GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP NumberUpLayout = 1
	GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM NumberUpLayout = 2
	GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP NumberUpLayout = 3
	GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT NumberUpLayout = 4
	GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT NumberUpLayout = 5
	GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT NumberUpLayout = 6
	GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT NumberUpLayout = 7
)

type Orientation C.GtkOrientation

const (
	GTK_ORIENTATION_HORIZONTAL Orientation = 0
	GTK_ORIENTATION_VERTICAL   Orientation = 1
)

type PackDirection C.GtkPackDirection

const (
	GTK_PACK_DIRECTION_LTR PackDirection = 0
	GTK_PACK_DIRECTION_RTL PackDirection = 1
	GTK_PACK_DIRECTION_TTB PackDirection = 2
	GTK_PACK_DIRECTION_BTT PackDirection = 3
)

type PackType C.GtkPackType

const (
	GTK_PACK_START PackType = 0
	GTK_PACK_END   PackType = 1
)

type PageOrientation C.GtkPageOrientation

const (
	GTK_PAGE_ORIENTATION_PORTRAIT          PageOrientation = 0
	GTK_PAGE_ORIENTATION_LANDSCAPE         PageOrientation = 1
	GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT  PageOrientation = 2
	GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE PageOrientation = 3
)

type PageSet C.GtkPageSet

const (
	GTK_PAGE_SET_ALL  PageSet = 0
	GTK_PAGE_SET_EVEN PageSet = 1
	GTK_PAGE_SET_ODD  PageSet = 2
)

type PathPriorityType C.GtkPathPriorityType

const (
	GTK_PATH_PRIO_LOWEST      PathPriorityType = 0
	GTK_PATH_PRIO_GTK         PathPriorityType = 4
	GTK_PATH_PRIO_APPLICATION PathPriorityType = 8
	GTK_PATH_PRIO_THEME       PathPriorityType = 10
	GTK_PATH_PRIO_RC          PathPriorityType = 12
	GTK_PATH_PRIO_HIGHEST     PathPriorityType = 15
)

type PathType C.GtkPathType

const (
	GTK_PATH_WIDGET       PathType = 0
	GTK_PATH_WIDGET_CLASS PathType = 1
	GTK_PATH_CLASS        PathType = 2
)

type PolicyType C.GtkPolicyType

const (
	GTK_POLICY_ALWAYS    PolicyType = 0
	GTK_POLICY_AUTOMATIC PolicyType = 1
	GTK_POLICY_NEVER     PolicyType = 2
	GTK_POLICY_EXTERNAL  PolicyType = 3
)

type PositionType C.GtkPositionType

const (
	GTK_POS_LEFT   PositionType = 0
	GTK_POS_RIGHT  PositionType = 1
	GTK_POS_TOP    PositionType = 2
	GTK_POS_BOTTOM PositionType = 3
)

type PrintDuplex C.GtkPrintDuplex

const (
	GTK_PRINT_DUPLEX_SIMPLEX    PrintDuplex = 0
	GTK_PRINT_DUPLEX_HORIZONTAL PrintDuplex = 1
	GTK_PRINT_DUPLEX_VERTICAL   PrintDuplex = 2
)

type PrintError C.GtkPrintError

const (
	GTK_PRINT_ERROR_GENERAL        PrintError = 0
	GTK_PRINT_ERROR_INTERNAL_ERROR PrintError = 1
	GTK_PRINT_ERROR_NOMEM          PrintError = 2
	GTK_PRINT_ERROR_INVALID_FILE   PrintError = 3
)

// PrintErrorQuark is a wrapper around the C function gtk_print_error_quark.
func PrintErrorQuark() glib.Quark {
	retC := C.gtk_print_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type PrintOperationAction C.GtkPrintOperationAction

const (
	GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG PrintOperationAction = 0
	GTK_PRINT_OPERATION_ACTION_PRINT        PrintOperationAction = 1
	GTK_PRINT_OPERATION_ACTION_PREVIEW      PrintOperationAction = 2
	GTK_PRINT_OPERATION_ACTION_EXPORT       PrintOperationAction = 3
)

type PrintOperationResult C.GtkPrintOperationResult

const (
	GTK_PRINT_OPERATION_RESULT_ERROR       PrintOperationResult = 0
	GTK_PRINT_OPERATION_RESULT_APPLY       PrintOperationResult = 1
	GTK_PRINT_OPERATION_RESULT_CANCEL      PrintOperationResult = 2
	GTK_PRINT_OPERATION_RESULT_IN_PROGRESS PrintOperationResult = 3
)

type PrintPages C.GtkPrintPages

const (
	GTK_PRINT_PAGES_ALL       PrintPages = 0
	GTK_PRINT_PAGES_CURRENT   PrintPages = 1
	GTK_PRINT_PAGES_RANGES    PrintPages = 2
	GTK_PRINT_PAGES_SELECTION PrintPages = 3
)

type PrintQuality C.GtkPrintQuality

const (
	GTK_PRINT_QUALITY_LOW    PrintQuality = 0
	GTK_PRINT_QUALITY_NORMAL PrintQuality = 1
	GTK_PRINT_QUALITY_HIGH   PrintQuality = 2
	GTK_PRINT_QUALITY_DRAFT  PrintQuality = 3
)

type PrintStatus C.GtkPrintStatus

const (
	GTK_PRINT_STATUS_INITIAL          PrintStatus = 0
	GTK_PRINT_STATUS_PREPARING        PrintStatus = 1
	GTK_PRINT_STATUS_GENERATING_DATA  PrintStatus = 2
	GTK_PRINT_STATUS_SENDING_DATA     PrintStatus = 3
	GTK_PRINT_STATUS_PENDING          PrintStatus = 4
	GTK_PRINT_STATUS_PENDING_ISSUE    PrintStatus = 5
	GTK_PRINT_STATUS_PRINTING         PrintStatus = 6
	GTK_PRINT_STATUS_FINISHED         PrintStatus = 7
	GTK_PRINT_STATUS_FINISHED_ABORTED PrintStatus = 8
)

type RcTokenType C.GtkRcTokenType

const (
	GTK_RC_TOKEN_INVALID        RcTokenType = 270
	GTK_RC_TOKEN_INCLUDE        RcTokenType = 271
	GTK_RC_TOKEN_NORMAL         RcTokenType = 272
	GTK_RC_TOKEN_ACTIVE         RcTokenType = 273
	GTK_RC_TOKEN_PRELIGHT       RcTokenType = 274
	GTK_RC_TOKEN_SELECTED       RcTokenType = 275
	GTK_RC_TOKEN_INSENSITIVE    RcTokenType = 276
	GTK_RC_TOKEN_FG             RcTokenType = 277
	GTK_RC_TOKEN_BG             RcTokenType = 278
	GTK_RC_TOKEN_TEXT           RcTokenType = 279
	GTK_RC_TOKEN_BASE           RcTokenType = 280
	GTK_RC_TOKEN_XTHICKNESS     RcTokenType = 281
	GTK_RC_TOKEN_YTHICKNESS     RcTokenType = 282
	GTK_RC_TOKEN_FONT           RcTokenType = 283
	GTK_RC_TOKEN_FONTSET        RcTokenType = 284
	GTK_RC_TOKEN_FONT_NAME      RcTokenType = 285
	GTK_RC_TOKEN_BG_PIXMAP      RcTokenType = 286
	GTK_RC_TOKEN_PIXMAP_PATH    RcTokenType = 287
	GTK_RC_TOKEN_STYLE          RcTokenType = 288
	GTK_RC_TOKEN_BINDING        RcTokenType = 289
	GTK_RC_TOKEN_BIND           RcTokenType = 290
	GTK_RC_TOKEN_WIDGET         RcTokenType = 291
	GTK_RC_TOKEN_WIDGET_CLASS   RcTokenType = 292
	GTK_RC_TOKEN_CLASS          RcTokenType = 293
	GTK_RC_TOKEN_LOWEST         RcTokenType = 294
	GTK_RC_TOKEN_GTK            RcTokenType = 295
	GTK_RC_TOKEN_APPLICATION    RcTokenType = 296
	GTK_RC_TOKEN_THEME          RcTokenType = 297
	GTK_RC_TOKEN_RC             RcTokenType = 298
	GTK_RC_TOKEN_HIGHEST        RcTokenType = 299
	GTK_RC_TOKEN_ENGINE         RcTokenType = 300
	GTK_RC_TOKEN_MODULE_PATH    RcTokenType = 301
	GTK_RC_TOKEN_IM_MODULE_PATH RcTokenType = 302
	GTK_RC_TOKEN_IM_MODULE_FILE RcTokenType = 303
	GTK_RC_TOKEN_STOCK          RcTokenType = 304
	GTK_RC_TOKEN_LTR            RcTokenType = 305
	GTK_RC_TOKEN_RTL            RcTokenType = 306
	GTK_RC_TOKEN_COLOR          RcTokenType = 307
	GTK_RC_TOKEN_UNBIND         RcTokenType = 308
	GTK_RC_TOKEN_LAST           RcTokenType = 309
)

type RecentChooserError C.GtkRecentChooserError

const (
	GTK_RECENT_CHOOSER_ERROR_NOT_FOUND   RecentChooserError = 0
	GTK_RECENT_CHOOSER_ERROR_INVALID_URI RecentChooserError = 1
)

// RecentChooserErrorQuark is a wrapper around the C function gtk_recent_chooser_error_quark.
func RecentChooserErrorQuark() glib.Quark {
	retC := C.gtk_recent_chooser_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type RecentManagerError C.GtkRecentManagerError

const (
	GTK_RECENT_MANAGER_ERROR_NOT_FOUND        RecentManagerError = 0
	GTK_RECENT_MANAGER_ERROR_INVALID_URI      RecentManagerError = 1
	GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING RecentManagerError = 2
	GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED   RecentManagerError = 3
	GTK_RECENT_MANAGER_ERROR_READ             RecentManagerError = 4
	GTK_RECENT_MANAGER_ERROR_WRITE            RecentManagerError = 5
	GTK_RECENT_MANAGER_ERROR_UNKNOWN          RecentManagerError = 6
)

// RecentManagerErrorQuark is a wrapper around the C function gtk_recent_manager_error_quark.
func RecentManagerErrorQuark() glib.Quark {
	retC := C.gtk_recent_manager_error_quark()
	retGo := (glib.Quark)(retC)

	return retGo
}

type RecentSortType C.GtkRecentSortType

const (
	GTK_RECENT_SORT_NONE   RecentSortType = 0
	GTK_RECENT_SORT_MRU    RecentSortType = 1
	GTK_RECENT_SORT_LRU    RecentSortType = 2
	GTK_RECENT_SORT_CUSTOM RecentSortType = 3
)

type ReliefStyle C.GtkReliefStyle

const (
	GTK_RELIEF_NORMAL ReliefStyle = 0
	GTK_RELIEF_HALF   ReliefStyle = 1
	GTK_RELIEF_NONE   ReliefStyle = 2
)

type ResizeMode C.GtkResizeMode

const (
	GTK_RESIZE_PARENT    ResizeMode = 0
	GTK_RESIZE_QUEUE     ResizeMode = 1
	GTK_RESIZE_IMMEDIATE ResizeMode = 2
)

type ResponseType C.GtkResponseType

const (
	GTK_RESPONSE_NONE         ResponseType = -1
	GTK_RESPONSE_REJECT       ResponseType = -2
	GTK_RESPONSE_ACCEPT       ResponseType = -3
	GTK_RESPONSE_DELETE_EVENT ResponseType = -4
	GTK_RESPONSE_OK           ResponseType = -5
	GTK_RESPONSE_CANCEL       ResponseType = -6
	GTK_RESPONSE_CLOSE        ResponseType = -7
	GTK_RESPONSE_YES          ResponseType = -8
	GTK_RESPONSE_NO           ResponseType = -9
	GTK_RESPONSE_APPLY        ResponseType = -10
	GTK_RESPONSE_HELP         ResponseType = -11
)

type RevealerTransitionType C.GtkRevealerTransitionType

const (
	GTK_REVEALER_TRANSITION_TYPE_NONE        RevealerTransitionType = 0
	GTK_REVEALER_TRANSITION_TYPE_CROSSFADE   RevealerTransitionType = 1
	GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT RevealerTransitionType = 2
	GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT  RevealerTransitionType = 3
	GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP    RevealerTransitionType = 4
	GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN  RevealerTransitionType = 5
)

type ScrollStep C.GtkScrollStep

const (
	GTK_SCROLL_STEPS            ScrollStep = 0
	GTK_SCROLL_PAGES            ScrollStep = 1
	GTK_SCROLL_ENDS             ScrollStep = 2
	GTK_SCROLL_HORIZONTAL_STEPS ScrollStep = 3
	GTK_SCROLL_HORIZONTAL_PAGES ScrollStep = 4
	GTK_SCROLL_HORIZONTAL_ENDS  ScrollStep = 5
)

type ScrollType C.GtkScrollType

const (
	GTK_SCROLL_NONE          ScrollType = 0
	GTK_SCROLL_JUMP          ScrollType = 1
	GTK_SCROLL_STEP_BACKWARD ScrollType = 2
	GTK_SCROLL_STEP_FORWARD  ScrollType = 3
	GTK_SCROLL_PAGE_BACKWARD ScrollType = 4
	GTK_SCROLL_PAGE_FORWARD  ScrollType = 5
	GTK_SCROLL_STEP_UP       ScrollType = 6
	GTK_SCROLL_STEP_DOWN     ScrollType = 7
	GTK_SCROLL_PAGE_UP       ScrollType = 8
	GTK_SCROLL_PAGE_DOWN     ScrollType = 9
	GTK_SCROLL_STEP_LEFT     ScrollType = 10
	GTK_SCROLL_STEP_RIGHT    ScrollType = 11
	GTK_SCROLL_PAGE_LEFT     ScrollType = 12
	GTK_SCROLL_PAGE_RIGHT    ScrollType = 13
	GTK_SCROLL_START         ScrollType = 14
	GTK_SCROLL_END           ScrollType = 15
)

type ScrollablePolicy C.GtkScrollablePolicy

const (
	GTK_SCROLL_MINIMUM ScrollablePolicy = 0
	GTK_SCROLL_NATURAL ScrollablePolicy = 1
)

type SelectionMode C.GtkSelectionMode

const (
	GTK_SELECTION_NONE     SelectionMode = 0
	GTK_SELECTION_SINGLE   SelectionMode = 1
	GTK_SELECTION_BROWSE   SelectionMode = 2
	GTK_SELECTION_MULTIPLE SelectionMode = 3
)

type SensitivityType C.GtkSensitivityType

const (
	GTK_SENSITIVITY_AUTO SensitivityType = 0
	GTK_SENSITIVITY_ON   SensitivityType = 1
	GTK_SENSITIVITY_OFF  SensitivityType = 2
)

type ShadowType C.GtkShadowType

const (
	GTK_SHADOW_NONE       ShadowType = 0
	GTK_SHADOW_IN         ShadowType = 1
	GTK_SHADOW_OUT        ShadowType = 2
	GTK_SHADOW_ETCHED_IN  ShadowType = 3
	GTK_SHADOW_ETCHED_OUT ShadowType = 4
)

type SizeGroupMode C.GtkSizeGroupMode

const (
	GTK_SIZE_GROUP_NONE       SizeGroupMode = 0
	GTK_SIZE_GROUP_HORIZONTAL SizeGroupMode = 1
	GTK_SIZE_GROUP_VERTICAL   SizeGroupMode = 2
	GTK_SIZE_GROUP_BOTH       SizeGroupMode = 3
)

type SizeRequestMode C.GtkSizeRequestMode

const (
	GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH SizeRequestMode = 0
	GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT SizeRequestMode = 1
	GTK_SIZE_REQUEST_CONSTANT_SIZE    SizeRequestMode = 2
)

type SortType C.GtkSortType

const (
	GTK_SORT_ASCENDING  SortType = 0
	GTK_SORT_DESCENDING SortType = 1
)

type SpinButtonUpdatePolicy C.GtkSpinButtonUpdatePolicy

const (
	GTK_UPDATE_ALWAYS   SpinButtonUpdatePolicy = 0
	GTK_UPDATE_IF_VALID SpinButtonUpdatePolicy = 1
)

type SpinType C.GtkSpinType

const (
	GTK_SPIN_STEP_FORWARD  SpinType = 0
	GTK_SPIN_STEP_BACKWARD SpinType = 1
	GTK_SPIN_PAGE_FORWARD  SpinType = 2
	GTK_SPIN_PAGE_BACKWARD SpinType = 3
	GTK_SPIN_HOME          SpinType = 4
	GTK_SPIN_END           SpinType = 5
	GTK_SPIN_USER_DEFINED  SpinType = 6
)

type StackTransitionType C.GtkStackTransitionType

const (
	GTK_STACK_TRANSITION_TYPE_NONE             StackTransitionType = 0
	GTK_STACK_TRANSITION_TYPE_CROSSFADE        StackTransitionType = 1
	GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT      StackTransitionType = 2
	GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT       StackTransitionType = 3
	GTK_STACK_TRANSITION_TYPE_SLIDE_UP         StackTransitionType = 4
	GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN       StackTransitionType = 5
	GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT StackTransitionType = 6
	GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN    StackTransitionType = 7
	GTK_STACK_TRANSITION_TYPE_OVER_UP          StackTransitionType = 8
	GTK_STACK_TRANSITION_TYPE_OVER_DOWN        StackTransitionType = 9
	GTK_STACK_TRANSITION_TYPE_OVER_LEFT        StackTransitionType = 10
	GTK_STACK_TRANSITION_TYPE_OVER_RIGHT       StackTransitionType = 11
	GTK_STACK_TRANSITION_TYPE_UNDER_UP         StackTransitionType = 12
	GTK_STACK_TRANSITION_TYPE_UNDER_DOWN       StackTransitionType = 13
	GTK_STACK_TRANSITION_TYPE_UNDER_LEFT       StackTransitionType = 14
	GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT      StackTransitionType = 15
	GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN     StackTransitionType = 16
	GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP     StackTransitionType = 17
	GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT  StackTransitionType = 18
	GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT  StackTransitionType = 19
)

type StateType C.GtkStateType

const (
	GTK_STATE_NORMAL       StateType = 0
	GTK_STATE_ACTIVE       StateType = 1
	GTK_STATE_PRELIGHT     StateType = 2
	GTK_STATE_SELECTED     StateType = 3
	GTK_STATE_INSENSITIVE  StateType = 4
	GTK_STATE_INCONSISTENT StateType = 5
	GTK_STATE_FOCUSED      StateType = 6
)

type TextBufferTargetInfo C.GtkTextBufferTargetInfo

const (
	GTK_TEXT_BUFFER_TARGET_INFO_BUFFER_CONTENTS TextBufferTargetInfo = -1
	GTK_TEXT_BUFFER_TARGET_INFO_RICH_TEXT       TextBufferTargetInfo = -2
	GTK_TEXT_BUFFER_TARGET_INFO_TEXT            TextBufferTargetInfo = -3
)

type TextDirection C.GtkTextDirection

const (
	GTK_TEXT_DIR_NONE TextDirection = 0
	GTK_TEXT_DIR_LTR  TextDirection = 1
	GTK_TEXT_DIR_RTL  TextDirection = 2
)

type TextViewLayer C.GtkTextViewLayer

const (
	GTK_TEXT_VIEW_LAYER_BELOW      TextViewLayer = 0
	GTK_TEXT_VIEW_LAYER_ABOVE      TextViewLayer = 1
	GTK_TEXT_VIEW_LAYER_BELOW_TEXT TextViewLayer = 2
	GTK_TEXT_VIEW_LAYER_ABOVE_TEXT TextViewLayer = 3
)

type TextWindowType C.GtkTextWindowType

const (
	GTK_TEXT_WINDOW_PRIVATE TextWindowType = 0
	GTK_TEXT_WINDOW_WIDGET  TextWindowType = 1
	GTK_TEXT_WINDOW_TEXT    TextWindowType = 2
	GTK_TEXT_WINDOW_LEFT    TextWindowType = 3
	GTK_TEXT_WINDOW_RIGHT   TextWindowType = 4
	GTK_TEXT_WINDOW_TOP     TextWindowType = 5
	GTK_TEXT_WINDOW_BOTTOM  TextWindowType = 6
)

type ToolbarSpaceStyle C.GtkToolbarSpaceStyle

const (
	GTK_TOOLBAR_SPACE_EMPTY ToolbarSpaceStyle = 0
	GTK_TOOLBAR_SPACE_LINE  ToolbarSpaceStyle = 1
)

type ToolbarStyle C.GtkToolbarStyle

const (
	GTK_TOOLBAR_ICONS      ToolbarStyle = 0
	GTK_TOOLBAR_TEXT       ToolbarStyle = 1
	GTK_TOOLBAR_BOTH       ToolbarStyle = 2
	GTK_TOOLBAR_BOTH_HORIZ ToolbarStyle = 3
)

type TreeViewColumnSizing C.GtkTreeViewColumnSizing

const (
	GTK_TREE_VIEW_COLUMN_GROW_ONLY TreeViewColumnSizing = 0
	GTK_TREE_VIEW_COLUMN_AUTOSIZE  TreeViewColumnSizing = 1
	GTK_TREE_VIEW_COLUMN_FIXED     TreeViewColumnSizing = 2
)

type TreeViewDropPosition C.GtkTreeViewDropPosition

const (
	GTK_TREE_VIEW_DROP_BEFORE         TreeViewDropPosition = 0
	GTK_TREE_VIEW_DROP_AFTER          TreeViewDropPosition = 1
	GTK_TREE_VIEW_DROP_INTO_OR_BEFORE TreeViewDropPosition = 2
	GTK_TREE_VIEW_DROP_INTO_OR_AFTER  TreeViewDropPosition = 3
)

type TreeViewGridLines C.GtkTreeViewGridLines

const (
	GTK_TREE_VIEW_GRID_LINES_NONE       TreeViewGridLines = 0
	GTK_TREE_VIEW_GRID_LINES_HORIZONTAL TreeViewGridLines = 1
	GTK_TREE_VIEW_GRID_LINES_VERTICAL   TreeViewGridLines = 2
	GTK_TREE_VIEW_GRID_LINES_BOTH       TreeViewGridLines = 3
)

type Unit C.GtkUnit

const (
	GTK_UNIT_NONE   Unit = 0
	GTK_UNIT_POINTS Unit = 1
	GTK_UNIT_INCH   Unit = 2
	GTK_UNIT_MM     Unit = 3
)

type WidgetHelpType C.GtkWidgetHelpType

const (
	GTK_WIDGET_HELP_TOOLTIP    WidgetHelpType = 0
	GTK_WIDGET_HELP_WHATS_THIS WidgetHelpType = 1
)

type WindowPosition C.GtkWindowPosition

const (
	GTK_WIN_POS_NONE             WindowPosition = 0
	GTK_WIN_POS_CENTER           WindowPosition = 1
	GTK_WIN_POS_MOUSE            WindowPosition = 2
	GTK_WIN_POS_CENTER_ALWAYS    WindowPosition = 3
	GTK_WIN_POS_CENTER_ON_PARENT WindowPosition = 4
)

type WindowType C.GtkWindowType

const (
	GTK_WINDOW_TOPLEVEL WindowType = 0
	GTK_WINDOW_POPUP    WindowType = 1
)

type WrapMode C.GtkWrapMode

const (
	GTK_WRAP_NONE      WrapMode = 0
	GTK_WRAP_CHAR      WrapMode = 1
	GTK_WRAP_WORD      WrapMode = 2
	GTK_WRAP_WORD_CHAR WrapMode = 3
)

// AccelGroupsActivate is a wrapper around the C function gtk_accel_groups_activate.
func AccelGroupsActivate(object *gobject.Object, accelKey uint32, accelMods gdk.ModifierType) bool {
	c_object := (*C.GObject)(C.NULL)
	if object != nil {
		c_object = (*C.GObject)(object.ToC())
	}

	c_accel_key := (C.guint)(accelKey)

	c_accel_mods := (C.GdkModifierType)(accelMods)

	retC := C.gtk_accel_groups_activate(c_object, c_accel_key, c_accel_mods)
	retGo := retC == C.TRUE

	return retGo
}

// AccelGroupsFromObject is a wrapper around the C function gtk_accel_groups_from_object.
func AccelGroupsFromObject(object *gobject.Object) *glib.SList {
	c_object := (*C.GObject)(C.NULL)
	if object != nil {
		c_object = (*C.GObject)(object.ToC())
	}

	retC := C.gtk_accel_groups_from_object(c_object)
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AcceleratorGetDefaultModMask is a wrapper around the C function gtk_accelerator_get_default_mod_mask.
func AcceleratorGetDefaultModMask() gdk.ModifierType {
	retC := C.gtk_accelerator_get_default_mod_mask()
	retGo := (gdk.ModifierType)(retC)

	return retGo
}

// AcceleratorGetLabel is a wrapper around the C function gtk_accelerator_get_label.
func AcceleratorGetLabel(acceleratorKey uint32, acceleratorMods gdk.ModifierType) string {
	c_accelerator_key := (C.guint)(acceleratorKey)

	c_accelerator_mods := (C.GdkModifierType)(acceleratorMods)

	retC := C.gtk_accelerator_get_label(c_accelerator_key, c_accelerator_mods)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// AcceleratorName is a wrapper around the C function gtk_accelerator_name.
func AcceleratorName(acceleratorKey uint32, acceleratorMods gdk.ModifierType) string {
	c_accelerator_key := (C.guint)(acceleratorKey)

	c_accelerator_mods := (C.GdkModifierType)(acceleratorMods)

	retC := C.gtk_accelerator_name(c_accelerator_key, c_accelerator_mods)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// AcceleratorParse is a wrapper around the C function gtk_accelerator_parse.
func AcceleratorParse(accelerator string) (uint32, gdk.ModifierType) {
	c_accelerator := C.CString(accelerator)
	defer C.free(unsafe.Pointer(c_accelerator))

	var c_accelerator_key C.guint

	var c_accelerator_mods C.GdkModifierType

	C.gtk_accelerator_parse(c_accelerator, &c_accelerator_key, &c_accelerator_mods)

	acceleratorKey := (uint32)(c_accelerator_key)

	acceleratorMods := (gdk.ModifierType)(c_accelerator_mods)

	return acceleratorKey, acceleratorMods
}

// AcceleratorSetDefaultModMask is a wrapper around the C function gtk_accelerator_set_default_mod_mask.
func AcceleratorSetDefaultModMask(defaultModMask gdk.ModifierType) {
	c_default_mod_mask := (C.GdkModifierType)(defaultModMask)

	C.gtk_accelerator_set_default_mod_mask(c_default_mod_mask)

	return
}

// AcceleratorValid is a wrapper around the C function gtk_accelerator_valid.
func AcceleratorValid(keyval uint32, modifiers gdk.ModifierType) bool {
	c_keyval := (C.guint)(keyval)

	c_modifiers := (C.GdkModifierType)(modifiers)

	retC := C.gtk_accelerator_valid(c_keyval, c_modifiers)
	retGo := retC == C.TRUE

	return retGo
}

// AlternativeDialogButtonOrder is a wrapper around the C function gtk_alternative_dialog_button_order.
func AlternativeDialogButtonOrder(screen *gdk.Screen) bool {
	c_screen := (*C.GdkScreen)(C.NULL)
	if screen != nil {
		c_screen = (*C.GdkScreen)(screen.ToC())
	}

	retC := C.gtk_alternative_dialog_button_order(c_screen)
	retGo := retC == C.TRUE

	return retGo
}

// BindingsActivate is a wrapper around the C function gtk_bindings_activate.
func BindingsActivate(object *gobject.Object, keyval uint32, modifiers gdk.ModifierType) bool {
	c_object := (*C.GObject)(C.NULL)
	if object != nil {
		c_object = (*C.GObject)(object.ToC())
	}

	c_keyval := (C.guint)(keyval)

	c_modifiers := (C.GdkModifierType)(modifiers)

	retC := C.gtk_bindings_activate(c_object, c_keyval, c_modifiers)
	retGo := retC == C.TRUE

	return retGo
}

// BindingsActivateEvent is a wrapper around the C function gtk_bindings_activate_event.
func BindingsActivateEvent(object *gobject.Object, event *gdk.EventKey) bool {
	c_object := (*C.GObject)(C.NULL)
	if object != nil {
		c_object = (*C.GObject)(object.ToC())
	}

	c_event := (*C.GdkEventKey)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEventKey)(event.ToC())
	}

	retC := C.gtk_bindings_activate_event(c_object, c_event)
	retGo := retC == C.TRUE

	return retGo
}

// CheckVersion is a wrapper around the C function gtk_check_version.
func CheckVersion(requiredMajor uint32, requiredMinor uint32, requiredMicro uint32) string {
	c_required_major := (C.guint)(requiredMajor)

	c_required_minor := (C.guint)(requiredMinor)

	c_required_micro := (C.guint)(requiredMicro)

	retC := C.gtk_check_version(c_required_major, c_required_minor, c_required_micro)
	retGo := C.GoString(retC)

	return retGo
}

// DisableSetlocale is a wrapper around the C function gtk_disable_setlocale.
func DisableSetlocale() {
	C.gtk_disable_setlocale()

	return
}

// DistributeNaturalAllocation is a wrapper around the C function gtk_distribute_natural_allocation.
func DistributeNaturalAllocation(extraSpace int32, nRequestedSizes uint32, sizes *RequestedSize) int32 {
	c_extra_space := (C.gint)(extraSpace)

	c_n_requested_sizes := (C.guint)(nRequestedSizes)

	c_sizes := (*C.GtkRequestedSize)(C.NULL)
	if sizes != nil {
		c_sizes = (*C.GtkRequestedSize)(sizes.ToC())
	}

	retC := C.gtk_distribute_natural_allocation(c_extra_space, c_n_requested_sizes, c_sizes)
	retGo := (int32)(retC)

	return retGo
}

// DragFinish is a wrapper around the C function gtk_drag_finish.
func DragFinish(context *gdk.DragContext, success bool, del bool, time uint32) {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	c_success :=
		boolToGboolean(success)

	c_del :=
		boolToGboolean(del)

	c_time_ := (C.guint32)(time)

	C.gtk_drag_finish(c_context, c_success, c_del, c_time_)

	return
}

// DragGetSourceWidget is a wrapper around the C function gtk_drag_get_source_widget.
func DragGetSourceWidget(context *gdk.DragContext) *Widget {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	retC := C.gtk_drag_get_source_widget(c_context)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// DragSetIconDefault is a wrapper around the C function gtk_drag_set_icon_default.
func DragSetIconDefault(context *gdk.DragContext) {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	C.gtk_drag_set_icon_default(c_context)

	return
}

// DragSetIconName is a wrapper around the C function gtk_drag_set_icon_name.
func DragSetIconName(context *gdk.DragContext, iconName string, hotX int32, hotY int32) {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	c_hot_x := (C.gint)(hotX)

	c_hot_y := (C.gint)(hotY)

	C.gtk_drag_set_icon_name(c_context, c_icon_name, c_hot_x, c_hot_y)

	return
}

// DragSetIconPixbuf is a wrapper around the C function gtk_drag_set_icon_pixbuf.
func DragSetIconPixbuf(context *gdk.DragContext, pixbuf *gdkpixbuf.Pixbuf, hotX int32, hotY int32) {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	c_hot_x := (C.gint)(hotX)

	c_hot_y := (C.gint)(hotY)

	C.gtk_drag_set_icon_pixbuf(c_context, c_pixbuf, c_hot_x, c_hot_y)

	return
}

// DragSetIconStock is a wrapper around the C function gtk_drag_set_icon_stock.
func DragSetIconStock(context *gdk.DragContext, stockId string, hotX int32, hotY int32) {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	c_hot_x := (C.gint)(hotX)

	c_hot_y := (C.gint)(hotY)

	C.gtk_drag_set_icon_stock(c_context, c_stock_id, c_hot_x, c_hot_y)

	return
}

// DragSetIconSurface is a wrapper around the C function gtk_drag_set_icon_surface.
func DragSetIconSurface(context *gdk.DragContext, surface *cairo.Surface) {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	c_surface := (*C.cairo_surface_t)(C.NULL)
	if surface != nil {
		c_surface = (*C.cairo_surface_t)(surface.ToC())
	}

	C.gtk_drag_set_icon_surface(c_context, c_surface)

	return
}

// DragSetIconWidget is a wrapper around the C function gtk_drag_set_icon_widget.
func DragSetIconWidget(context *gdk.DragContext, widget *Widget, hotX int32, hotY int32) {
	c_context := (*C.GdkDragContext)(C.NULL)
	if context != nil {
		c_context = (*C.GdkDragContext)(context.ToC())
	}

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_hot_x := (C.gint)(hotX)

	c_hot_y := (C.gint)(hotY)

	C.gtk_drag_set_icon_widget(c_context, c_widget, c_hot_x, c_hot_y)

	return
}

// EventsPending is a wrapper around the C function gtk_events_pending.
func EventsPending() bool {
	retC := C.gtk_events_pending()
	retGo := retC == C.TRUE

	return retGo
}

// False is a wrapper around the C function gtk_false.
func False() bool {
	retC := C.gtk_false()
	retGo := retC == C.TRUE

	return retGo
}

// GetCurrentEvent is a wrapper around the C function gtk_get_current_event.
func GetCurrentEvent() *gdk.Event {
	retC := C.gtk_get_current_event()
	var retGo (*gdk.Event)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.EventNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetCurrentEventDevice is a wrapper around the C function gtk_get_current_event_device.
func GetCurrentEventDevice() *gdk.Device {
	retC := C.gtk_get_current_event_device()
	var retGo (*gdk.Device)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdk.DeviceNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetCurrentEventState is a wrapper around the C function gtk_get_current_event_state.
func GetCurrentEventState() (bool, gdk.ModifierType) {
	var c_state C.GdkModifierType

	retC := C.gtk_get_current_event_state(&c_state)
	retGo := retC == C.TRUE

	state := (gdk.ModifierType)(c_state)

	return retGo, state
}

// GetCurrentEventTime is a wrapper around the C function gtk_get_current_event_time.
func GetCurrentEventTime() uint32 {
	retC := C.gtk_get_current_event_time()
	retGo := (uint32)(retC)

	return retGo
}

// GetDebugFlags is a wrapper around the C function gtk_get_debug_flags.
func GetDebugFlags() uint32 {
	retC := C.gtk_get_debug_flags()
	retGo := (uint32)(retC)

	return retGo
}

// GetDefaultLanguage is a wrapper around the C function gtk_get_default_language.
func GetDefaultLanguage() *pango.Language {
	retC := C.gtk_get_default_language()
	retGo := pango.LanguageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetEventWidget is a wrapper around the C function gtk_get_event_widget.
func GetEventWidget(event *gdk.Event) *Widget {
	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	retC := C.gtk_get_event_widget(c_event)
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetOptionGroup is a wrapper around the C function gtk_get_option_group.
func GetOptionGroup(openDefaultDisplay bool) *glib.OptionGroup {
	c_open_default_display :=
		boolToGboolean(openDefaultDisplay)

	retC := C.gtk_get_option_group(c_open_default_display)
	retGo := glib.OptionGroupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GrabGetCurrent is a wrapper around the C function gtk_grab_get_current.
func GrabGetCurrent() *Widget {
	retC := C.gtk_grab_get_current()
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Init is a wrapper around the C function gtk_init.
func Init(args []string) []string {
	cArgc, cArgv := argsIn(args)

	C.gtk_init(&cArgc, &cArgv)

	args = argsOut(cArgc, cArgv)

	return args
}

// InitCheck is a wrapper around the C function gtk_init_check.
func InitCheck(args []string) (bool, []string) {
	cArgc, cArgv := argsIn(args)

	retC := C.gtk_init_check(&cArgc, &cArgv)
	retGo := retC == C.TRUE

	args = argsOut(cArgc, cArgv)

	return retGo, args
}

// Unsupported : gtk_init_with_args : unsupported parameter entries :

// Unsupported : gtk_key_snooper_install : unsupported parameter snooper : no type generator for KeySnoopFunc (GtkKeySnoopFunc) for param snooper

// KeySnooperRemove is a wrapper around the C function gtk_key_snooper_remove.
func KeySnooperRemove(snooperHandlerId uint32) {
	c_snooper_handler_id := (C.guint)(snooperHandlerId)

	C.gtk_key_snooper_remove(c_snooper_handler_id)

	return
}

// Main is a wrapper around the C function gtk_main.
func Main() {
	C.gtk_main()

	return
}

// MainDoEvent is a wrapper around the C function gtk_main_do_event.
func MainDoEvent(event *gdk.Event) {
	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	C.gtk_main_do_event(c_event)

	return
}

// MainIteration is a wrapper around the C function gtk_main_iteration.
func MainIteration() bool {
	retC := C.gtk_main_iteration()
	retGo := retC == C.TRUE

	return retGo
}

// MainIterationDo is a wrapper around the C function gtk_main_iteration_do.
func MainIterationDo(blocking bool) bool {
	c_blocking :=
		boolToGboolean(blocking)

	retC := C.gtk_main_iteration_do(c_blocking)
	retGo := retC == C.TRUE

	return retGo
}

// MainLevel is a wrapper around the C function gtk_main_level.
func MainLevel() uint32 {
	retC := C.gtk_main_level()
	retGo := (uint32)(retC)

	return retGo
}

// MainQuit is a wrapper around the C function gtk_main_quit.
func MainQuit() {
	C.gtk_main_quit()

	return
}

// PaintArrow is a wrapper around the C function gtk_paint_arrow.
func PaintArrow(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, arrowType ArrowType, fill bool, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_arrow_type := (C.GtkArrowType)(arrowType)

	c_fill :=
		boolToGboolean(fill)

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_arrow(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_arrow_type, c_fill, c_x, c_y, c_width, c_height)

	return
}

// PaintBox is a wrapper around the C function gtk_paint_box.
func PaintBox(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_box(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height)

	return
}

// PaintBoxGap is a wrapper around the C function gtk_paint_box_gap.
func PaintBoxGap(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32, gapSide PositionType, gapX int32, gapWidth int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	c_gap_side := (C.GtkPositionType)(gapSide)

	c_gap_x := (C.gint)(gapX)

	c_gap_width := (C.gint)(gapWidth)

	C.gtk_paint_box_gap(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height, c_gap_side, c_gap_x, c_gap_width)

	return
}

// PaintCheck is a wrapper around the C function gtk_paint_check.
func PaintCheck(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_check(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height)

	return
}

// PaintDiamond is a wrapper around the C function gtk_paint_diamond.
func PaintDiamond(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_diamond(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height)

	return
}

// PaintExpander is a wrapper around the C function gtk_paint_expander.
func PaintExpander(style *Style, cr *cairo.Context, stateType StateType, widget *Widget, detail string, x int32, y int32, expanderStyle ExpanderStyle) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_expander_style := (C.GtkExpanderStyle)(expanderStyle)

	C.gtk_paint_expander(c_style, c_cr, c_state_type, c_widget, c_detail, c_x, c_y, c_expander_style)

	return
}

// PaintExtension is a wrapper around the C function gtk_paint_extension.
func PaintExtension(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32, gapSide PositionType) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	c_gap_side := (C.GtkPositionType)(gapSide)

	C.gtk_paint_extension(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height, c_gap_side)

	return
}

// PaintFlatBox is a wrapper around the C function gtk_paint_flat_box.
func PaintFlatBox(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_flat_box(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height)

	return
}

// PaintFocus is a wrapper around the C function gtk_paint_focus.
func PaintFocus(style *Style, cr *cairo.Context, stateType StateType, widget *Widget, detail string, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_focus(c_style, c_cr, c_state_type, c_widget, c_detail, c_x, c_y, c_width, c_height)

	return
}

// PaintHandle is a wrapper around the C function gtk_paint_handle.
func PaintHandle(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32, orientation Orientation) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	c_orientation := (C.GtkOrientation)(orientation)

	C.gtk_paint_handle(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height, c_orientation)

	return
}

// PaintHline is a wrapper around the C function gtk_paint_hline.
func PaintHline(style *Style, cr *cairo.Context, stateType StateType, widget *Widget, detail string, x1 int32, x2 int32, y int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x1 := (C.gint)(x1)

	c_x2 := (C.gint)(x2)

	c_y := (C.gint)(y)

	C.gtk_paint_hline(c_style, c_cr, c_state_type, c_widget, c_detail, c_x1, c_x2, c_y)

	return
}

// PaintLayout is a wrapper around the C function gtk_paint_layout.
func PaintLayout(style *Style, cr *cairo.Context, stateType StateType, useText bool, widget *Widget, detail string, x int32, y int32, layout *pango.Layout) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_use_text :=
		boolToGboolean(useText)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_layout := (*C.PangoLayout)(C.NULL)
	if layout != nil {
		c_layout = (*C.PangoLayout)(layout.ToC())
	}

	C.gtk_paint_layout(c_style, c_cr, c_state_type, c_use_text, c_widget, c_detail, c_x, c_y, c_layout)

	return
}

// PaintOption is a wrapper around the C function gtk_paint_option.
func PaintOption(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_option(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height)

	return
}

// PaintResizeGrip is a wrapper around the C function gtk_paint_resize_grip.
func PaintResizeGrip(style *Style, cr *cairo.Context, stateType StateType, widget *Widget, detail string, edge gdk.WindowEdge, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_edge := (C.GdkWindowEdge)(edge)

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_resize_grip(c_style, c_cr, c_state_type, c_widget, c_detail, c_edge, c_x, c_y, c_width, c_height)

	return
}

// PaintShadow is a wrapper around the C function gtk_paint_shadow.
func PaintShadow(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_shadow(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height)

	return
}

// PaintShadowGap is a wrapper around the C function gtk_paint_shadow_gap.
func PaintShadowGap(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32, gapSide PositionType, gapX int32, gapWidth int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	c_gap_side := (C.GtkPositionType)(gapSide)

	c_gap_x := (C.gint)(gapX)

	c_gap_width := (C.gint)(gapWidth)

	C.gtk_paint_shadow_gap(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height, c_gap_side, c_gap_x, c_gap_width)

	return
}

// PaintSlider is a wrapper around the C function gtk_paint_slider.
func PaintSlider(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32, orientation Orientation) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	c_orientation := (C.GtkOrientation)(orientation)

	C.gtk_paint_slider(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height, c_orientation)

	return
}

// PaintSpinner is a wrapper around the C function gtk_paint_spinner.
func PaintSpinner(style *Style, cr *cairo.Context, stateType StateType, widget *Widget, detail string, step uint32, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_step := (C.guint)(step)

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_spinner(c_style, c_cr, c_state_type, c_widget, c_detail, c_step, c_x, c_y, c_width, c_height)

	return
}

// PaintTab is a wrapper around the C function gtk_paint_tab.
func PaintTab(style *Style, cr *cairo.Context, stateType StateType, shadowType ShadowType, widget *Widget, detail string, x int32, y int32, width int32, height int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_shadow_type := (C.GtkShadowType)(shadowType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	C.gtk_paint_tab(c_style, c_cr, c_state_type, c_shadow_type, c_widget, c_detail, c_x, c_y, c_width, c_height)

	return
}

// PaintVline is a wrapper around the C function gtk_paint_vline.
func PaintVline(style *Style, cr *cairo.Context, stateType StateType, widget *Widget, detail string, y1 int32, y2 int32, x int32) {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_cr := (*C.cairo_t)(C.NULL)
	if cr != nil {
		c_cr = (*C.cairo_t)(cr.ToC())
	}

	c_state_type := (C.GtkStateType)(stateType)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	c_y1_ := (C.gint)(y1)

	c_y2_ := (C.gint)(y2)

	c_x := (C.gint)(x)

	C.gtk_paint_vline(c_style, c_cr, c_state_type, c_widget, c_detail, c_y1_, c_y2_, c_x)

	return
}

// ParseArgs is a wrapper around the C function gtk_parse_args.
func ParseArgs(args []string) (bool, []string) {
	cArgc, cArgv := argsIn(args)

	retC := C.gtk_parse_args(&cArgc, &cArgv)
	retGo := retC == C.TRUE

	args = argsOut(cArgc, cArgv)

	return retGo, args
}

// PrintRunPageSetupDialog is a wrapper around the C function gtk_print_run_page_setup_dialog.
func PrintRunPageSetupDialog(parent *Window, pageSetup *PageSetup, settings *PrintSettings) *PageSetup {
	c_parent := (*C.GtkWindow)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkWindow)(parent.ToC())
	}

	c_page_setup := (*C.GtkPageSetup)(C.NULL)
	if pageSetup != nil {
		c_page_setup = (*C.GtkPageSetup)(pageSetup.ToC())
	}

	c_settings := (*C.GtkPrintSettings)(C.NULL)
	if settings != nil {
		c_settings = (*C.GtkPrintSettings)(settings.ToC())
	}

	retC := C.gtk_print_run_page_setup_dialog(c_parent, c_page_setup, c_settings)
	retGo := PageSetupNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_print_run_page_setup_dialog_async : unsupported parameter done_cb : no type generator for PageSetupDoneFunc (GtkPageSetupDoneFunc) for param done_cb

// PropagateEvent is a wrapper around the C function gtk_propagate_event.
func PropagateEvent(widget *Widget, event *gdk.Event) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	C.gtk_propagate_event(c_widget, c_event)

	return
}

// RcAddDefaultFile is a wrapper around the C function gtk_rc_add_default_file.
func RcAddDefaultFile(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_rc_add_default_file(c_filename)

	return
}

// RcFindModuleInPath is a wrapper around the C function gtk_rc_find_module_in_path.
func RcFindModuleInPath(moduleFile string) string {
	c_module_file := C.CString(moduleFile)
	defer C.free(unsafe.Pointer(c_module_file))

	retC := C.gtk_rc_find_module_in_path(c_module_file)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// RcFindPixmapInPath is a wrapper around the C function gtk_rc_find_pixmap_in_path.
func RcFindPixmapInPath(settings *Settings, scanner *glib.Scanner, pixmapFile string) string {
	c_settings := (*C.GtkSettings)(C.NULL)
	if settings != nil {
		c_settings = (*C.GtkSettings)(settings.ToC())
	}

	c_scanner := (*C.GScanner)(C.NULL)
	if scanner != nil {
		c_scanner = (*C.GScanner)(scanner.ToC())
	}

	c_pixmap_file := C.CString(pixmapFile)
	defer C.free(unsafe.Pointer(c_pixmap_file))

	retC := C.gtk_rc_find_pixmap_in_path(c_settings, c_scanner, c_pixmap_file)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// RcGetDefaultFiles is a wrapper around the C function gtk_rc_get_default_files.
func RcGetDefaultFiles() []string {
	retC := C.gtk_rc_get_default_files()
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}

	return retGo
}

// RcGetImModuleFile is a wrapper around the C function gtk_rc_get_im_module_file.
func RcGetImModuleFile() string {
	retC := C.gtk_rc_get_im_module_file()
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// RcGetImModulePath is a wrapper around the C function gtk_rc_get_im_module_path.
func RcGetImModulePath() string {
	retC := C.gtk_rc_get_im_module_path()
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// RcGetModuleDir is a wrapper around the C function gtk_rc_get_module_dir.
func RcGetModuleDir() string {
	retC := C.gtk_rc_get_module_dir()
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// RcGetStyle is a wrapper around the C function gtk_rc_get_style.
func RcGetStyle(widget *Widget) *Style {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	retC := C.gtk_rc_get_style(c_widget)
	retGo := StyleNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RcGetStyleByPaths is a wrapper around the C function gtk_rc_get_style_by_paths.
func RcGetStyleByPaths(settings *Settings, widgetPath string, classPath string, type_ gobject.Type) *Style {
	c_settings := (*C.GtkSettings)(C.NULL)
	if settings != nil {
		c_settings = (*C.GtkSettings)(settings.ToC())
	}

	c_widget_path := C.CString(widgetPath)
	defer C.free(unsafe.Pointer(c_widget_path))

	c_class_path := C.CString(classPath)
	defer C.free(unsafe.Pointer(c_class_path))

	c_type := (C.GType)(type_)

	retC := C.gtk_rc_get_style_by_paths(c_settings, c_widget_path, c_class_path, c_type)
	var retGo (*Style)
	if retC == nil {
		retGo = nil
	} else {
		retGo = StyleNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// RcGetThemeDir is a wrapper around the C function gtk_rc_get_theme_dir.
func RcGetThemeDir() string {
	retC := C.gtk_rc_get_theme_dir()
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// RcParse is a wrapper around the C function gtk_rc_parse.
func RcParse(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_rc_parse(c_filename)

	return
}

// RcParseColor is a wrapper around the C function gtk_rc_parse_color.
func RcParseColor(scanner *glib.Scanner) (uint32, *gdk.Color) {
	c_scanner := (*C.GScanner)(C.NULL)
	if scanner != nil {
		c_scanner = (*C.GScanner)(scanner.ToC())
	}

	var c_color C.GdkColor

	retC := C.gtk_rc_parse_color(c_scanner, &c_color)
	retGo := (uint32)(retC)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return retGo, color
}

// RcParseColorFull is a wrapper around the C function gtk_rc_parse_color_full.
func RcParseColorFull(scanner *glib.Scanner, style *RcStyle) (uint32, *gdk.Color) {
	c_scanner := (*C.GScanner)(C.NULL)
	if scanner != nil {
		c_scanner = (*C.GScanner)(scanner.ToC())
	}

	c_style := (*C.GtkRcStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkRcStyle)(style.ToC())
	}

	var c_color C.GdkColor

	retC := C.gtk_rc_parse_color_full(c_scanner, c_style, &c_color)
	retGo := (uint32)(retC)

	color := gdk.ColorNewFromC(unsafe.Pointer(&c_color))

	return retGo, color
}

// RcParsePriority is a wrapper around the C function gtk_rc_parse_priority.
func RcParsePriority(scanner *glib.Scanner, priority PathPriorityType) uint32 {
	c_scanner := (*C.GScanner)(C.NULL)
	if scanner != nil {
		c_scanner = (*C.GScanner)(scanner.ToC())
	}

	c_priority := (C.GtkPathPriorityType)(priority)

	retC := C.gtk_rc_parse_priority(c_scanner, &c_priority)
	retGo := (uint32)(retC)

	return retGo
}

// RcParseState is a wrapper around the C function gtk_rc_parse_state.
func RcParseState(scanner *glib.Scanner) (uint32, StateType) {
	c_scanner := (*C.GScanner)(C.NULL)
	if scanner != nil {
		c_scanner = (*C.GScanner)(scanner.ToC())
	}

	var c_state C.GtkStateType

	retC := C.gtk_rc_parse_state(c_scanner, &c_state)
	retGo := (uint32)(retC)

	state := (StateType)(c_state)

	return retGo, state
}

// RcParseString is a wrapper around the C function gtk_rc_parse_string.
func RcParseString(rcString string) {
	c_rc_string := C.CString(rcString)
	defer C.free(unsafe.Pointer(c_rc_string))

	C.gtk_rc_parse_string(c_rc_string)

	return
}

// RcReparseAll is a wrapper around the C function gtk_rc_reparse_all.
func RcReparseAll() bool {
	retC := C.gtk_rc_reparse_all()
	retGo := retC == C.TRUE

	return retGo
}

// RcReparseAllForSettings is a wrapper around the C function gtk_rc_reparse_all_for_settings.
func RcReparseAllForSettings(settings *Settings, forceLoad bool) bool {
	c_settings := (*C.GtkSettings)(C.NULL)
	if settings != nil {
		c_settings = (*C.GtkSettings)(settings.ToC())
	}

	c_force_load :=
		boolToGboolean(forceLoad)

	retC := C.gtk_rc_reparse_all_for_settings(c_settings, c_force_load)
	retGo := retC == C.TRUE

	return retGo
}

// RcResetStyles is a wrapper around the C function gtk_rc_reset_styles.
func RcResetStyles(settings *Settings) {
	c_settings := (*C.GtkSettings)(C.NULL)
	if settings != nil {
		c_settings = (*C.GtkSettings)(settings.ToC())
	}

	C.gtk_rc_reset_styles(c_settings)

	return
}

// RcScannerNew is a wrapper around the C function gtk_rc_scanner_new.
func RcScannerNew() *glib.Scanner {
	retC := C.gtk_rc_scanner_new()
	retGo := glib.ScannerNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RcSetDefaultFiles is a wrapper around the C function gtk_rc_set_default_files.
func RcSetDefaultFiles(filenames []string) {
	c_filenames_array := make([]*C.gchar, len(filenames)+1, len(filenames)+1)
	for i, item := range filenames {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_filenames_array[i] = c
	}
	c_filenames_array[len(filenames)] = nil
	c_filenames_arrayPtr := &c_filenames_array[0]
	c_filenames := (**C.gchar)(unsafe.Pointer(c_filenames_arrayPtr))

	C.gtk_rc_set_default_files(c_filenames)

	return
}

// SelectionAddTarget is a wrapper around the C function gtk_selection_add_target.
func SelectionAddTarget(widget *Widget, selection *gdk.Atom, target *gdk.Atom, info uint32) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_selection := (C.GdkAtom)(C.NULL)
	if selection != nil {
		c_selection = (C.GdkAtom)(selection.ToC())
	}

	c_target := (C.GdkAtom)(C.NULL)
	if target != nil {
		c_target = (C.GdkAtom)(target.ToC())
	}

	c_info := (C.guint)(info)

	C.gtk_selection_add_target(c_widget, c_selection, c_target, c_info)

	return
}

// Unsupported : gtk_selection_add_targets : unsupported parameter targets :

// SelectionClearTargets is a wrapper around the C function gtk_selection_clear_targets.
func SelectionClearTargets(widget *Widget, selection *gdk.Atom) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_selection := (C.GdkAtom)(C.NULL)
	if selection != nil {
		c_selection = (C.GdkAtom)(selection.ToC())
	}

	C.gtk_selection_clear_targets(c_widget, c_selection)

	return
}

// SelectionConvert is a wrapper around the C function gtk_selection_convert.
func SelectionConvert(widget *Widget, selection *gdk.Atom, target *gdk.Atom, time uint32) bool {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_selection := (C.GdkAtom)(C.NULL)
	if selection != nil {
		c_selection = (C.GdkAtom)(selection.ToC())
	}

	c_target := (C.GdkAtom)(C.NULL)
	if target != nil {
		c_target = (C.GdkAtom)(target.ToC())
	}

	c_time_ := (C.guint32)(time)

	retC := C.gtk_selection_convert(c_widget, c_selection, c_target, c_time_)
	retGo := retC == C.TRUE

	return retGo
}

// SelectionOwnerSet is a wrapper around the C function gtk_selection_owner_set.
func SelectionOwnerSet(widget *Widget, selection *gdk.Atom, time uint32) bool {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_selection := (C.GdkAtom)(C.NULL)
	if selection != nil {
		c_selection = (C.GdkAtom)(selection.ToC())
	}

	c_time_ := (C.guint32)(time)

	retC := C.gtk_selection_owner_set(c_widget, c_selection, c_time_)
	retGo := retC == C.TRUE

	return retGo
}

// SelectionOwnerSetForDisplay is a wrapper around the C function gtk_selection_owner_set_for_display.
func SelectionOwnerSetForDisplay(display *gdk.Display, widget *Widget, selection *gdk.Atom, time uint32) bool {
	c_display := (*C.GdkDisplay)(C.NULL)
	if display != nil {
		c_display = (*C.GdkDisplay)(display.ToC())
	}

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_selection := (C.GdkAtom)(C.NULL)
	if selection != nil {
		c_selection = (C.GdkAtom)(selection.ToC())
	}

	c_time_ := (C.guint32)(time)

	retC := C.gtk_selection_owner_set_for_display(c_display, c_widget, c_selection, c_time_)
	retGo := retC == C.TRUE

	return retGo
}

// SelectionRemoveAll is a wrapper around the C function gtk_selection_remove_all.
func SelectionRemoveAll(widget *Widget) {
	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	C.gtk_selection_remove_all(c_widget)

	return
}

// SetDebugFlags is a wrapper around the C function gtk_set_debug_flags.
func SetDebugFlags(flags uint32) {
	c_flags := (C.guint)(flags)

	C.gtk_set_debug_flags(c_flags)

	return
}

// Unsupported : gtk_show_about_dialog : unsupported parameter ... : varargs

// Unsupported : gtk_stock_add : unsupported parameter items :

// Unsupported : gtk_stock_add_static : unsupported parameter items :

// StockListIds is a wrapper around the C function gtk_stock_list_ids.
func StockListIds() *glib.SList {
	retC := C.gtk_stock_list_ids()
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// StockLookup is a wrapper around the C function gtk_stock_lookup.
func StockLookup(stockId string) (bool, *StockItem) {
	c_stock_id := C.CString(stockId)
	defer C.free(unsafe.Pointer(c_stock_id))

	var c_item C.GtkStockItem

	retC := C.gtk_stock_lookup(c_stock_id, &c_item)
	retGo := retC == C.TRUE

	item := StockItemNewFromC(unsafe.Pointer(&c_item))

	return retGo, item
}

// Unsupported : gtk_stock_set_translate_func : unsupported parameter func : no type generator for TranslateFunc (GtkTranslateFunc) for param func

// Unsupported : gtk_target_table_free : unsupported parameter targets :

// Unsupported : gtk_target_table_new_from_list : array return type :

// Unsupported : gtk_targets_include_image : unsupported parameter targets :

// Unsupported : gtk_targets_include_rich_text : unsupported parameter targets :

// Unsupported : gtk_targets_include_text : unsupported parameter targets :

// Unsupported : gtk_targets_include_uri : unsupported parameter targets :

// TreeGetRowDragData is a wrapper around the C function gtk_tree_get_row_drag_data.
func TreeGetRowDragData(selectionData *SelectionData) (bool, *TreeModel, *TreePath) {
	c_selection_data := (*C.GtkSelectionData)(C.NULL)
	if selectionData != nil {
		c_selection_data = (*C.GtkSelectionData)(selectionData.ToC())
	}

	var c_tree_model *C.GtkTreeModel

	var c_path *C.GtkTreePath

	retC := C.gtk_tree_get_row_drag_data(c_selection_data, &c_tree_model, &c_path)
	retGo := retC == C.TRUE

	treeModel := TreeModelNewFromC(unsafe.Pointer(c_tree_model))

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	return retGo, treeModel, path
}

// TreeSetRowDragData is a wrapper around the C function gtk_tree_set_row_drag_data.
func TreeSetRowDragData(selectionData *SelectionData, treeModel *TreeModel, path *TreePath) bool {
	c_selection_data := (*C.GtkSelectionData)(C.NULL)
	if selectionData != nil {
		c_selection_data = (*C.GtkSelectionData)(selectionData.ToC())
	}

	c_tree_model := (*C.GtkTreeModel)(treeModel.ToC())

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_set_row_drag_data(c_selection_data, c_tree_model, c_path)
	retGo := retC == C.TRUE

	return retGo
}

// True is a wrapper around the C function gtk_true.
func True() bool {
	retC := C.gtk_true()
	retGo := retC == C.TRUE

	return retGo
}

// Actionable is a wrapper around the C record GtkActionable.
type Actionable struct {
	native *C.GtkActionable
}

func ActionableNewFromC(u unsafe.Pointer) *Actionable {
	c := (*C.GtkActionable)(u)
	if c == nil {
		return nil
	}

	g := &Actionable{native: c}

	return g
}

func (recv *Actionable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Actionable with another Actionable, and returns true if they represent the same GObject.
func (recv *Actionable) Equals(other *Actionable) bool {
	return other.ToC() == recv.ToC()
}

// Activatable is a wrapper around the C record GtkActivatable.
type Activatable struct {
	native *C.GtkActivatable
}

func ActivatableNewFromC(u unsafe.Pointer) *Activatable {
	c := (*C.GtkActivatable)(u)
	if c == nil {
		return nil
	}

	g := &Activatable{native: c}

	return g
}

func (recv *Activatable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Activatable with another Activatable, and returns true if they represent the same GObject.
func (recv *Activatable) Equals(other *Activatable) bool {
	return other.ToC() == recv.ToC()
}

// AppChooser is a wrapper around the C record GtkAppChooser.
type AppChooser struct {
	native *C.GtkAppChooser
}

func AppChooserNewFromC(u unsafe.Pointer) *AppChooser {
	c := (*C.GtkAppChooser)(u)
	if c == nil {
		return nil
	}

	g := &AppChooser{native: c}

	return g
}

func (recv *AppChooser) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooser with another AppChooser, and returns true if they represent the same GObject.
func (recv *AppChooser) Equals(other *AppChooser) bool {
	return other.ToC() == recv.ToC()
}

// Buildable is a wrapper around the C record GtkBuildable.
type Buildable struct {
	native *C.GtkBuildable
}

func BuildableNewFromC(u unsafe.Pointer) *Buildable {
	c := (*C.GtkBuildable)(u)
	if c == nil {
		return nil
	}

	g := &Buildable{native: c}

	return g
}

func (recv *Buildable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Buildable with another Buildable, and returns true if they represent the same GObject.
func (recv *Buildable) Equals(other *Buildable) bool {
	return other.ToC() == recv.ToC()
}

// AddChild is a wrapper around the C function gtk_buildable_add_child.
func (recv *Buildable) AddChild(builder *Builder, child *gobject.Object, type_ string) {
	c_builder := (*C.GtkBuilder)(C.NULL)
	if builder != nil {
		c_builder = (*C.GtkBuilder)(builder.ToC())
	}

	c_child := (*C.GObject)(C.NULL)
	if child != nil {
		c_child = (*C.GObject)(child.ToC())
	}

	c_type := C.CString(type_)
	defer C.free(unsafe.Pointer(c_type))

	C.gtk_buildable_add_child((*C.GtkBuildable)(recv.native), c_builder, c_child, c_type)

	return
}

// ConstructChild is a wrapper around the C function gtk_buildable_construct_child.
func (recv *Buildable) ConstructChild(builder *Builder, name string) *gobject.Object {
	c_builder := (*C.GtkBuilder)(C.NULL)
	if builder != nil {
		c_builder = (*C.GtkBuilder)(builder.ToC())
	}

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_buildable_construct_child((*C.GtkBuildable)(recv.native), c_builder, c_name)
	retGo := gobject.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CustomFinished is a wrapper around the C function gtk_buildable_custom_finished.
func (recv *Buildable) CustomFinished(builder *Builder, child *gobject.Object, tagname string, data uintptr) {
	c_builder := (*C.GtkBuilder)(C.NULL)
	if builder != nil {
		c_builder = (*C.GtkBuilder)(builder.ToC())
	}

	c_child := (*C.GObject)(C.NULL)
	if child != nil {
		c_child = (*C.GObject)(child.ToC())
	}

	c_tagname := C.CString(tagname)
	defer C.free(unsafe.Pointer(c_tagname))

	c_data := (C.gpointer)(data)

	C.gtk_buildable_custom_finished((*C.GtkBuildable)(recv.native), c_builder, c_child, c_tagname, c_data)

	return
}

// CustomTagEnd is a wrapper around the C function gtk_buildable_custom_tag_end.
func (recv *Buildable) CustomTagEnd(builder *Builder, child *gobject.Object, tagname string, data uintptr) {
	c_builder := (*C.GtkBuilder)(C.NULL)
	if builder != nil {
		c_builder = (*C.GtkBuilder)(builder.ToC())
	}

	c_child := (*C.GObject)(C.NULL)
	if child != nil {
		c_child = (*C.GObject)(child.ToC())
	}

	c_tagname := C.CString(tagname)
	defer C.free(unsafe.Pointer(c_tagname))

	c_data := (C.gpointer)(data)

	C.gtk_buildable_custom_tag_end((*C.GtkBuildable)(recv.native), c_builder, c_child, c_tagname, &c_data)

	return
}

// CustomTagStart is a wrapper around the C function gtk_buildable_custom_tag_start.
func (recv *Buildable) CustomTagStart(builder *Builder, child *gobject.Object, tagname string) (bool, *glib.MarkupParser, uintptr) {
	c_builder := (*C.GtkBuilder)(C.NULL)
	if builder != nil {
		c_builder = (*C.GtkBuilder)(builder.ToC())
	}

	c_child := (*C.GObject)(C.NULL)
	if child != nil {
		c_child = (*C.GObject)(child.ToC())
	}

	c_tagname := C.CString(tagname)
	defer C.free(unsafe.Pointer(c_tagname))

	var c_parser C.GMarkupParser

	var c_data C.gpointer

	retC := C.gtk_buildable_custom_tag_start((*C.GtkBuildable)(recv.native), c_builder, c_child, c_tagname, &c_parser, &c_data)
	retGo := retC == C.TRUE

	parser := glib.MarkupParserNewFromC(unsafe.Pointer(&c_parser))

	data := (uintptr)(unsafe.Pointer(&c_data))

	return retGo, parser, data
}

// GetInternalChild is a wrapper around the C function gtk_buildable_get_internal_child.
func (recv *Buildable) GetInternalChild(builder *Builder, childname string) *gobject.Object {
	c_builder := (*C.GtkBuilder)(C.NULL)
	if builder != nil {
		c_builder = (*C.GtkBuilder)(builder.ToC())
	}

	c_childname := C.CString(childname)
	defer C.free(unsafe.Pointer(c_childname))

	retC := C.gtk_buildable_get_internal_child((*C.GtkBuildable)(recv.native), c_builder, c_childname)
	retGo := gobject.ObjectNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetName is a wrapper around the C function gtk_buildable_get_name.
func (recv *Buildable) GetName() string {
	retC := C.gtk_buildable_get_name((*C.GtkBuildable)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// ParserFinished is a wrapper around the C function gtk_buildable_parser_finished.
func (recv *Buildable) ParserFinished(builder *Builder) {
	c_builder := (*C.GtkBuilder)(C.NULL)
	if builder != nil {
		c_builder = (*C.GtkBuilder)(builder.ToC())
	}

	C.gtk_buildable_parser_finished((*C.GtkBuildable)(recv.native), c_builder)

	return
}

// SetBuildableProperty is a wrapper around the C function gtk_buildable_set_buildable_property.
func (recv *Buildable) SetBuildableProperty(builder *Builder, name string, value *gobject.Value) {
	c_builder := (*C.GtkBuilder)(C.NULL)
	if builder != nil {
		c_builder = (*C.GtkBuilder)(builder.ToC())
	}

	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_value := (*C.GValue)(C.NULL)
	if value != nil {
		c_value = (*C.GValue)(value.ToC())
	}

	C.gtk_buildable_set_buildable_property((*C.GtkBuildable)(recv.native), c_builder, c_name, c_value)

	return
}

// SetName is a wrapper around the C function gtk_buildable_set_name.
func (recv *Buildable) SetName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_buildable_set_name((*C.GtkBuildable)(recv.native), c_name)

	return
}

// CellAccessibleParent is a wrapper around the C record GtkCellAccessibleParent.
type CellAccessibleParent struct {
	native *C.GtkCellAccessibleParent
}

func CellAccessibleParentNewFromC(u unsafe.Pointer) *CellAccessibleParent {
	c := (*C.GtkCellAccessibleParent)(u)
	if c == nil {
		return nil
	}

	g := &CellAccessibleParent{native: c}

	return g
}

func (recv *CellAccessibleParent) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAccessibleParent with another CellAccessibleParent, and returns true if they represent the same GObject.
func (recv *CellAccessibleParent) Equals(other *CellAccessibleParent) bool {
	return other.ToC() == recv.ToC()
}

// Activate is a wrapper around the C function gtk_cell_accessible_parent_activate.
func (recv *CellAccessibleParent) Activate(cell *CellAccessible) {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	C.gtk_cell_accessible_parent_activate((*C.GtkCellAccessibleParent)(recv.native), c_cell)

	return
}

// Edit is a wrapper around the C function gtk_cell_accessible_parent_edit.
func (recv *CellAccessibleParent) Edit(cell *CellAccessible) {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	C.gtk_cell_accessible_parent_edit((*C.GtkCellAccessibleParent)(recv.native), c_cell)

	return
}

// ExpandCollapse is a wrapper around the C function gtk_cell_accessible_parent_expand_collapse.
func (recv *CellAccessibleParent) ExpandCollapse(cell *CellAccessible) {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	C.gtk_cell_accessible_parent_expand_collapse((*C.GtkCellAccessibleParent)(recv.native), c_cell)

	return
}

// GetCellArea is a wrapper around the C function gtk_cell_accessible_parent_get_cell_area.
func (recv *CellAccessibleParent) GetCellArea(cell *CellAccessible, cellRect *gdk.Rectangle) {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	c_cell_rect := (*C.GdkRectangle)(C.NULL)
	if cellRect != nil {
		c_cell_rect = (*C.GdkRectangle)(cellRect.ToC())
	}

	C.gtk_cell_accessible_parent_get_cell_area((*C.GtkCellAccessibleParent)(recv.native), c_cell, c_cell_rect)

	return
}

// GetCellExtents is a wrapper around the C function gtk_cell_accessible_parent_get_cell_extents.
func (recv *CellAccessibleParent) GetCellExtents(cell *CellAccessible, x int32, y int32, width int32, height int32, coordType atk.CoordType) {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	c_x := (C.gint)(x)

	c_y := (C.gint)(y)

	c_width := (C.gint)(width)

	c_height := (C.gint)(height)

	c_coord_type := (C.AtkCoordType)(coordType)

	C.gtk_cell_accessible_parent_get_cell_extents((*C.GtkCellAccessibleParent)(recv.native), c_cell, &c_x, &c_y, &c_width, &c_height, c_coord_type)

	return
}

// GetChildIndex is a wrapper around the C function gtk_cell_accessible_parent_get_child_index.
func (recv *CellAccessibleParent) GetChildIndex(cell *CellAccessible) int32 {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	retC := C.gtk_cell_accessible_parent_get_child_index((*C.GtkCellAccessibleParent)(recv.native), c_cell)
	retGo := (int32)(retC)

	return retGo
}

// GetRendererState is a wrapper around the C function gtk_cell_accessible_parent_get_renderer_state.
func (recv *CellAccessibleParent) GetRendererState(cell *CellAccessible) CellRendererState {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	retC := C.gtk_cell_accessible_parent_get_renderer_state((*C.GtkCellAccessibleParent)(recv.native), c_cell)
	retGo := (CellRendererState)(retC)

	return retGo
}

// GrabFocus is a wrapper around the C function gtk_cell_accessible_parent_grab_focus.
func (recv *CellAccessibleParent) GrabFocus(cell *CellAccessible) bool {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	retC := C.gtk_cell_accessible_parent_grab_focus((*C.GtkCellAccessibleParent)(recv.native), c_cell)
	retGo := retC == C.TRUE

	return retGo
}

// UpdateRelationset is a wrapper around the C function gtk_cell_accessible_parent_update_relationset.
func (recv *CellAccessibleParent) UpdateRelationset(cell *CellAccessible, relationset *atk.RelationSet) {
	c_cell := (*C.GtkCellAccessible)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellAccessible)(cell.ToC())
	}

	c_relationset := (*C.AtkRelationSet)(C.NULL)
	if relationset != nil {
		c_relationset = (*C.AtkRelationSet)(relationset.ToC())
	}

	C.gtk_cell_accessible_parent_update_relationset((*C.GtkCellAccessibleParent)(recv.native), c_cell, c_relationset)

	return
}

// CellEditable is a wrapper around the C record GtkCellEditable.
type CellEditable struct {
	native *C.GtkCellEditable
}

func CellEditableNewFromC(u unsafe.Pointer) *CellEditable {
	c := (*C.GtkCellEditable)(u)
	if c == nil {
		return nil
	}

	g := &CellEditable{native: c}

	return g
}

func (recv *CellEditable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellEditable with another CellEditable, and returns true if they represent the same GObject.
func (recv *CellEditable) Equals(other *CellEditable) bool {
	return other.ToC() == recv.ToC()
}

type signalCellEditableEditingDoneDetail struct {
	callback  CellEditableSignalEditingDoneCallback
	handlerID C.gulong
}

var signalCellEditableEditingDoneId int
var signalCellEditableEditingDoneMap = make(map[int]signalCellEditableEditingDoneDetail)
var signalCellEditableEditingDoneLock sync.RWMutex

// CellEditableSignalEditingDoneCallback is a callback function for a 'editing-done' signal emitted from a CellEditable.
type CellEditableSignalEditingDoneCallback func()

/*
ConnectEditingDone connects the callback to the 'editing-done' signal for the CellEditable.

The returned value represents the connection, and may be passed to DisconnectEditingDone to remove it.
*/
func (recv *CellEditable) ConnectEditingDone(callback CellEditableSignalEditingDoneCallback) int {
	signalCellEditableEditingDoneLock.Lock()
	defer signalCellEditableEditingDoneLock.Unlock()

	signalCellEditableEditingDoneId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellEditable_signal_connect_editing_done(instance, C.gpointer(uintptr(signalCellEditableEditingDoneId)))

	detail := signalCellEditableEditingDoneDetail{callback, handlerID}
	signalCellEditableEditingDoneMap[signalCellEditableEditingDoneId] = detail

	return signalCellEditableEditingDoneId
}

/*
DisconnectEditingDone disconnects a callback from the 'editing-done' signal for the CellEditable.

The connectionID should be a value returned from a call to ConnectEditingDone.
*/
func (recv *CellEditable) DisconnectEditingDone(connectionID int) {
	signalCellEditableEditingDoneLock.Lock()
	defer signalCellEditableEditingDoneLock.Unlock()

	detail, exists := signalCellEditableEditingDoneMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellEditableEditingDoneMap, connectionID)
}

//export celleditable_editingDoneHandler
func celleditable_editingDoneHandler(_ *C.GObject, data C.gpointer) {
	signalCellEditableEditingDoneLock.RLock()
	defer signalCellEditableEditingDoneLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCellEditableEditingDoneMap[index].callback
	callback()
}

type signalCellEditableRemoveWidgetDetail struct {
	callback  CellEditableSignalRemoveWidgetCallback
	handlerID C.gulong
}

var signalCellEditableRemoveWidgetId int
var signalCellEditableRemoveWidgetMap = make(map[int]signalCellEditableRemoveWidgetDetail)
var signalCellEditableRemoveWidgetLock sync.RWMutex

// CellEditableSignalRemoveWidgetCallback is a callback function for a 'remove-widget' signal emitted from a CellEditable.
type CellEditableSignalRemoveWidgetCallback func()

/*
ConnectRemoveWidget connects the callback to the 'remove-widget' signal for the CellEditable.

The returned value represents the connection, and may be passed to DisconnectRemoveWidget to remove it.
*/
func (recv *CellEditable) ConnectRemoveWidget(callback CellEditableSignalRemoveWidgetCallback) int {
	signalCellEditableRemoveWidgetLock.Lock()
	defer signalCellEditableRemoveWidgetLock.Unlock()

	signalCellEditableRemoveWidgetId++
	instance := C.gpointer(recv.native)
	handlerID := C.CellEditable_signal_connect_remove_widget(instance, C.gpointer(uintptr(signalCellEditableRemoveWidgetId)))

	detail := signalCellEditableRemoveWidgetDetail{callback, handlerID}
	signalCellEditableRemoveWidgetMap[signalCellEditableRemoveWidgetId] = detail

	return signalCellEditableRemoveWidgetId
}

/*
DisconnectRemoveWidget disconnects a callback from the 'remove-widget' signal for the CellEditable.

The connectionID should be a value returned from a call to ConnectRemoveWidget.
*/
func (recv *CellEditable) DisconnectRemoveWidget(connectionID int) {
	signalCellEditableRemoveWidgetLock.Lock()
	defer signalCellEditableRemoveWidgetLock.Unlock()

	detail, exists := signalCellEditableRemoveWidgetMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalCellEditableRemoveWidgetMap, connectionID)
}

//export celleditable_removeWidgetHandler
func celleditable_removeWidgetHandler(_ *C.GObject, data C.gpointer) {
	signalCellEditableRemoveWidgetLock.RLock()
	defer signalCellEditableRemoveWidgetLock.RUnlock()

	index := int(uintptr(data))
	callback := signalCellEditableRemoveWidgetMap[index].callback
	callback()
}

// EditingDone is a wrapper around the C function gtk_cell_editable_editing_done.
func (recv *CellEditable) EditingDone() {
	C.gtk_cell_editable_editing_done((*C.GtkCellEditable)(recv.native))

	return
}

// RemoveWidget is a wrapper around the C function gtk_cell_editable_remove_widget.
func (recv *CellEditable) RemoveWidget() {
	C.gtk_cell_editable_remove_widget((*C.GtkCellEditable)(recv.native))

	return
}

// StartEditing is a wrapper around the C function gtk_cell_editable_start_editing.
func (recv *CellEditable) StartEditing(event *gdk.Event) {
	c_event := (*C.GdkEvent)(C.NULL)
	if event != nil {
		c_event = (*C.GdkEvent)(event.ToC())
	}

	C.gtk_cell_editable_start_editing((*C.GtkCellEditable)(recv.native), c_event)

	return
}

// CellLayout is a wrapper around the C record GtkCellLayout.
type CellLayout struct {
	native *C.GtkCellLayout
}

func CellLayoutNewFromC(u unsafe.Pointer) *CellLayout {
	c := (*C.GtkCellLayout)(u)
	if c == nil {
		return nil
	}

	g := &CellLayout{native: c}

	return g
}

func (recv *CellLayout) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellLayout with another CellLayout, and returns true if they represent the same GObject.
func (recv *CellLayout) Equals(other *CellLayout) bool {
	return other.ToC() == recv.ToC()
}

// AddAttribute is a wrapper around the C function gtk_cell_layout_add_attribute.
func (recv *CellLayout) AddAttribute(cell *CellRenderer, attribute string, column int32) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_attribute := C.CString(attribute)
	defer C.free(unsafe.Pointer(c_attribute))

	c_column := (C.gint)(column)

	C.gtk_cell_layout_add_attribute((*C.GtkCellLayout)(recv.native), c_cell, c_attribute, c_column)

	return
}

// Clear is a wrapper around the C function gtk_cell_layout_clear.
func (recv *CellLayout) Clear() {
	C.gtk_cell_layout_clear((*C.GtkCellLayout)(recv.native))

	return
}

// ClearAttributes is a wrapper around the C function gtk_cell_layout_clear_attributes.
func (recv *CellLayout) ClearAttributes(cell *CellRenderer) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	C.gtk_cell_layout_clear_attributes((*C.GtkCellLayout)(recv.native), c_cell)

	return
}

// GetCells is a wrapper around the C function gtk_cell_layout_get_cells.
func (recv *CellLayout) GetCells() *glib.List {
	retC := C.gtk_cell_layout_get_cells((*C.GtkCellLayout)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// PackEnd is a wrapper around the C function gtk_cell_layout_pack_end.
func (recv *CellLayout) PackEnd(cell *CellRenderer, expand bool) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	C.gtk_cell_layout_pack_end((*C.GtkCellLayout)(recv.native), c_cell, c_expand)

	return
}

// PackStart is a wrapper around the C function gtk_cell_layout_pack_start.
func (recv *CellLayout) PackStart(cell *CellRenderer, expand bool) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_expand :=
		boolToGboolean(expand)

	C.gtk_cell_layout_pack_start((*C.GtkCellLayout)(recv.native), c_cell, c_expand)

	return
}

// Reorder is a wrapper around the C function gtk_cell_layout_reorder.
func (recv *CellLayout) Reorder(cell *CellRenderer, position int32) {
	c_cell := (*C.GtkCellRenderer)(C.NULL)
	if cell != nil {
		c_cell = (*C.GtkCellRenderer)(cell.ToC())
	}

	c_position := (C.gint)(position)

	C.gtk_cell_layout_reorder((*C.GtkCellLayout)(recv.native), c_cell, c_position)

	return
}

// Unsupported : gtk_cell_layout_set_attributes : unsupported parameter ... : varargs

// Unsupported : gtk_cell_layout_set_cell_data_func : unsupported parameter func : no type generator for CellLayoutDataFunc (GtkCellLayoutDataFunc) for param func

// ColorChooser is a wrapper around the C record GtkColorChooser.
type ColorChooser struct {
	native *C.GtkColorChooser
}

func ColorChooserNewFromC(u unsafe.Pointer) *ColorChooser {
	c := (*C.GtkColorChooser)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooser{native: c}

	return g
}

func (recv *ColorChooser) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooser with another ColorChooser, and returns true if they represent the same GObject.
func (recv *ColorChooser) Equals(other *ColorChooser) bool {
	return other.ToC() == recv.ToC()
}

// Editable is a wrapper around the C record GtkEditable.
type Editable struct {
	native *C.GtkEditable
}

func EditableNewFromC(u unsafe.Pointer) *Editable {
	c := (*C.GtkEditable)(u)
	if c == nil {
		return nil
	}

	g := &Editable{native: c}

	return g
}

func (recv *Editable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Editable with another Editable, and returns true if they represent the same GObject.
func (recv *Editable) Equals(other *Editable) bool {
	return other.ToC() == recv.ToC()
}

type signalEditableChangedDetail struct {
	callback  EditableSignalChangedCallback
	handlerID C.gulong
}

var signalEditableChangedId int
var signalEditableChangedMap = make(map[int]signalEditableChangedDetail)
var signalEditableChangedLock sync.RWMutex

// EditableSignalChangedCallback is a callback function for a 'changed' signal emitted from a Editable.
type EditableSignalChangedCallback func()

/*
ConnectChanged connects the callback to the 'changed' signal for the Editable.

The returned value represents the connection, and may be passed to DisconnectChanged to remove it.
*/
func (recv *Editable) ConnectChanged(callback EditableSignalChangedCallback) int {
	signalEditableChangedLock.Lock()
	defer signalEditableChangedLock.Unlock()

	signalEditableChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.Editable_signal_connect_changed(instance, C.gpointer(uintptr(signalEditableChangedId)))

	detail := signalEditableChangedDetail{callback, handlerID}
	signalEditableChangedMap[signalEditableChangedId] = detail

	return signalEditableChangedId
}

/*
DisconnectChanged disconnects a callback from the 'changed' signal for the Editable.

The connectionID should be a value returned from a call to ConnectChanged.
*/
func (recv *Editable) DisconnectChanged(connectionID int) {
	signalEditableChangedLock.Lock()
	defer signalEditableChangedLock.Unlock()

	detail, exists := signalEditableChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEditableChangedMap, connectionID)
}

//export editable_changedHandler
func editable_changedHandler(_ *C.GObject, data C.gpointer) {
	signalEditableChangedLock.RLock()
	defer signalEditableChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalEditableChangedMap[index].callback
	callback()
}

type signalEditableDeleteTextDetail struct {
	callback  EditableSignalDeleteTextCallback
	handlerID C.gulong
}

var signalEditableDeleteTextId int
var signalEditableDeleteTextMap = make(map[int]signalEditableDeleteTextDetail)
var signalEditableDeleteTextLock sync.RWMutex

// EditableSignalDeleteTextCallback is a callback function for a 'delete-text' signal emitted from a Editable.
type EditableSignalDeleteTextCallback func(startPos int32, endPos int32)

/*
ConnectDeleteText connects the callback to the 'delete-text' signal for the Editable.

The returned value represents the connection, and may be passed to DisconnectDeleteText to remove it.
*/
func (recv *Editable) ConnectDeleteText(callback EditableSignalDeleteTextCallback) int {
	signalEditableDeleteTextLock.Lock()
	defer signalEditableDeleteTextLock.Unlock()

	signalEditableDeleteTextId++
	instance := C.gpointer(recv.native)
	handlerID := C.Editable_signal_connect_delete_text(instance, C.gpointer(uintptr(signalEditableDeleteTextId)))

	detail := signalEditableDeleteTextDetail{callback, handlerID}
	signalEditableDeleteTextMap[signalEditableDeleteTextId] = detail

	return signalEditableDeleteTextId
}

/*
DisconnectDeleteText disconnects a callback from the 'delete-text' signal for the Editable.

The connectionID should be a value returned from a call to ConnectDeleteText.
*/
func (recv *Editable) DisconnectDeleteText(connectionID int) {
	signalEditableDeleteTextLock.Lock()
	defer signalEditableDeleteTextLock.Unlock()

	detail, exists := signalEditableDeleteTextMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalEditableDeleteTextMap, connectionID)
}

//export editable_deleteTextHandler
func editable_deleteTextHandler(_ *C.GObject, c_start_pos C.gint, c_end_pos C.gint, data C.gpointer) {
	signalEditableDeleteTextLock.RLock()
	defer signalEditableDeleteTextLock.RUnlock()

	startPos := int32(c_start_pos)

	endPos := int32(c_end_pos)

	index := int(uintptr(data))
	callback := signalEditableDeleteTextMap[index].callback
	callback(startPos, endPos)
}

// Unsupported signal 'insert-text' for Editable : param position : gpointer

// CopyClipboard is a wrapper around the C function gtk_editable_copy_clipboard.
func (recv *Editable) CopyClipboard() {
	C.gtk_editable_copy_clipboard((*C.GtkEditable)(recv.native))

	return
}

// CutClipboard is a wrapper around the C function gtk_editable_cut_clipboard.
func (recv *Editable) CutClipboard() {
	C.gtk_editable_cut_clipboard((*C.GtkEditable)(recv.native))

	return
}

// DeleteSelection is a wrapper around the C function gtk_editable_delete_selection.
func (recv *Editable) DeleteSelection() {
	C.gtk_editable_delete_selection((*C.GtkEditable)(recv.native))

	return
}

// DeleteText is a wrapper around the C function gtk_editable_delete_text.
func (recv *Editable) DeleteText(startPos int32, endPos int32) {
	c_start_pos := (C.gint)(startPos)

	c_end_pos := (C.gint)(endPos)

	C.gtk_editable_delete_text((*C.GtkEditable)(recv.native), c_start_pos, c_end_pos)

	return
}

// GetChars is a wrapper around the C function gtk_editable_get_chars.
func (recv *Editable) GetChars(startPos int32, endPos int32) string {
	c_start_pos := (C.gint)(startPos)

	c_end_pos := (C.gint)(endPos)

	retC := C.gtk_editable_get_chars((*C.GtkEditable)(recv.native), c_start_pos, c_end_pos)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetEditable is a wrapper around the C function gtk_editable_get_editable.
func (recv *Editable) GetEditable() bool {
	retC := C.gtk_editable_get_editable((*C.GtkEditable)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPosition is a wrapper around the C function gtk_editable_get_position.
func (recv *Editable) GetPosition() int32 {
	retC := C.gtk_editable_get_position((*C.GtkEditable)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetSelectionBounds is a wrapper around the C function gtk_editable_get_selection_bounds.
func (recv *Editable) GetSelectionBounds() (bool, int32, int32) {
	var c_start_pos C.gint

	var c_end_pos C.gint

	retC := C.gtk_editable_get_selection_bounds((*C.GtkEditable)(recv.native), &c_start_pos, &c_end_pos)
	retGo := retC == C.TRUE

	startPos := (int32)(c_start_pos)

	endPos := (int32)(c_end_pos)

	return retGo, startPos, endPos
}

// InsertText is a wrapper around the C function gtk_editable_insert_text.
func (recv *Editable) InsertText(newText string, newTextLength int32, position int32) {
	c_new_text := C.CString(newText)
	defer C.free(unsafe.Pointer(c_new_text))

	c_new_text_length := (C.gint)(newTextLength)

	c_position := (C.gint)(position)

	C.gtk_editable_insert_text((*C.GtkEditable)(recv.native), c_new_text, c_new_text_length, &c_position)

	return
}

// PasteClipboard is a wrapper around the C function gtk_editable_paste_clipboard.
func (recv *Editable) PasteClipboard() {
	C.gtk_editable_paste_clipboard((*C.GtkEditable)(recv.native))

	return
}

// SelectRegion is a wrapper around the C function gtk_editable_select_region.
func (recv *Editable) SelectRegion(startPos int32, endPos int32) {
	c_start_pos := (C.gint)(startPos)

	c_end_pos := (C.gint)(endPos)

	C.gtk_editable_select_region((*C.GtkEditable)(recv.native), c_start_pos, c_end_pos)

	return
}

// SetEditable is a wrapper around the C function gtk_editable_set_editable.
func (recv *Editable) SetEditable(isEditable bool) {
	c_is_editable :=
		boolToGboolean(isEditable)

	C.gtk_editable_set_editable((*C.GtkEditable)(recv.native), c_is_editable)

	return
}

// SetPosition is a wrapper around the C function gtk_editable_set_position.
func (recv *Editable) SetPosition(position int32) {
	c_position := (C.gint)(position)

	C.gtk_editable_set_position((*C.GtkEditable)(recv.native), c_position)

	return
}

// FileChooser is a wrapper around the C record GtkFileChooser.
type FileChooser struct {
	native *C.GtkFileChooser
}

func FileChooserNewFromC(u unsafe.Pointer) *FileChooser {
	c := (*C.GtkFileChooser)(u)
	if c == nil {
		return nil
	}

	g := &FileChooser{native: c}

	return g
}

func (recv *FileChooser) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooser with another FileChooser, and returns true if they represent the same GObject.
func (recv *FileChooser) Equals(other *FileChooser) bool {
	return other.ToC() == recv.ToC()
}

// Unsupported signal 'confirm-overwrite' for FileChooser : return value FileChooserConfirmation :

type signalFileChooserCurrentFolderChangedDetail struct {
	callback  FileChooserSignalCurrentFolderChangedCallback
	handlerID C.gulong
}

var signalFileChooserCurrentFolderChangedId int
var signalFileChooserCurrentFolderChangedMap = make(map[int]signalFileChooserCurrentFolderChangedDetail)
var signalFileChooserCurrentFolderChangedLock sync.RWMutex

// FileChooserSignalCurrentFolderChangedCallback is a callback function for a 'current-folder-changed' signal emitted from a FileChooser.
type FileChooserSignalCurrentFolderChangedCallback func()

/*
ConnectCurrentFolderChanged connects the callback to the 'current-folder-changed' signal for the FileChooser.

The returned value represents the connection, and may be passed to DisconnectCurrentFolderChanged to remove it.
*/
func (recv *FileChooser) ConnectCurrentFolderChanged(callback FileChooserSignalCurrentFolderChangedCallback) int {
	signalFileChooserCurrentFolderChangedLock.Lock()
	defer signalFileChooserCurrentFolderChangedLock.Unlock()

	signalFileChooserCurrentFolderChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooser_signal_connect_current_folder_changed(instance, C.gpointer(uintptr(signalFileChooserCurrentFolderChangedId)))

	detail := signalFileChooserCurrentFolderChangedDetail{callback, handlerID}
	signalFileChooserCurrentFolderChangedMap[signalFileChooserCurrentFolderChangedId] = detail

	return signalFileChooserCurrentFolderChangedId
}

/*
DisconnectCurrentFolderChanged disconnects a callback from the 'current-folder-changed' signal for the FileChooser.

The connectionID should be a value returned from a call to ConnectCurrentFolderChanged.
*/
func (recv *FileChooser) DisconnectCurrentFolderChanged(connectionID int) {
	signalFileChooserCurrentFolderChangedLock.Lock()
	defer signalFileChooserCurrentFolderChangedLock.Unlock()

	detail, exists := signalFileChooserCurrentFolderChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserCurrentFolderChangedMap, connectionID)
}

//export filechooser_currentFolderChangedHandler
func filechooser_currentFolderChangedHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserCurrentFolderChangedLock.RLock()
	defer signalFileChooserCurrentFolderChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserCurrentFolderChangedMap[index].callback
	callback()
}

type signalFileChooserFileActivatedDetail struct {
	callback  FileChooserSignalFileActivatedCallback
	handlerID C.gulong
}

var signalFileChooserFileActivatedId int
var signalFileChooserFileActivatedMap = make(map[int]signalFileChooserFileActivatedDetail)
var signalFileChooserFileActivatedLock sync.RWMutex

// FileChooserSignalFileActivatedCallback is a callback function for a 'file-activated' signal emitted from a FileChooser.
type FileChooserSignalFileActivatedCallback func()

/*
ConnectFileActivated connects the callback to the 'file-activated' signal for the FileChooser.

The returned value represents the connection, and may be passed to DisconnectFileActivated to remove it.
*/
func (recv *FileChooser) ConnectFileActivated(callback FileChooserSignalFileActivatedCallback) int {
	signalFileChooserFileActivatedLock.Lock()
	defer signalFileChooserFileActivatedLock.Unlock()

	signalFileChooserFileActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooser_signal_connect_file_activated(instance, C.gpointer(uintptr(signalFileChooserFileActivatedId)))

	detail := signalFileChooserFileActivatedDetail{callback, handlerID}
	signalFileChooserFileActivatedMap[signalFileChooserFileActivatedId] = detail

	return signalFileChooserFileActivatedId
}

/*
DisconnectFileActivated disconnects a callback from the 'file-activated' signal for the FileChooser.

The connectionID should be a value returned from a call to ConnectFileActivated.
*/
func (recv *FileChooser) DisconnectFileActivated(connectionID int) {
	signalFileChooserFileActivatedLock.Lock()
	defer signalFileChooserFileActivatedLock.Unlock()

	detail, exists := signalFileChooserFileActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserFileActivatedMap, connectionID)
}

//export filechooser_fileActivatedHandler
func filechooser_fileActivatedHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserFileActivatedLock.RLock()
	defer signalFileChooserFileActivatedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserFileActivatedMap[index].callback
	callback()
}

type signalFileChooserSelectionChangedDetail struct {
	callback  FileChooserSignalSelectionChangedCallback
	handlerID C.gulong
}

var signalFileChooserSelectionChangedId int
var signalFileChooserSelectionChangedMap = make(map[int]signalFileChooserSelectionChangedDetail)
var signalFileChooserSelectionChangedLock sync.RWMutex

// FileChooserSignalSelectionChangedCallback is a callback function for a 'selection-changed' signal emitted from a FileChooser.
type FileChooserSignalSelectionChangedCallback func()

/*
ConnectSelectionChanged connects the callback to the 'selection-changed' signal for the FileChooser.

The returned value represents the connection, and may be passed to DisconnectSelectionChanged to remove it.
*/
func (recv *FileChooser) ConnectSelectionChanged(callback FileChooserSignalSelectionChangedCallback) int {
	signalFileChooserSelectionChangedLock.Lock()
	defer signalFileChooserSelectionChangedLock.Unlock()

	signalFileChooserSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooser_signal_connect_selection_changed(instance, C.gpointer(uintptr(signalFileChooserSelectionChangedId)))

	detail := signalFileChooserSelectionChangedDetail{callback, handlerID}
	signalFileChooserSelectionChangedMap[signalFileChooserSelectionChangedId] = detail

	return signalFileChooserSelectionChangedId
}

/*
DisconnectSelectionChanged disconnects a callback from the 'selection-changed' signal for the FileChooser.

The connectionID should be a value returned from a call to ConnectSelectionChanged.
*/
func (recv *FileChooser) DisconnectSelectionChanged(connectionID int) {
	signalFileChooserSelectionChangedLock.Lock()
	defer signalFileChooserSelectionChangedLock.Unlock()

	detail, exists := signalFileChooserSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserSelectionChangedMap, connectionID)
}

//export filechooser_selectionChangedHandler
func filechooser_selectionChangedHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserSelectionChangedLock.RLock()
	defer signalFileChooserSelectionChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserSelectionChangedMap[index].callback
	callback()
}

type signalFileChooserUpdatePreviewDetail struct {
	callback  FileChooserSignalUpdatePreviewCallback
	handlerID C.gulong
}

var signalFileChooserUpdatePreviewId int
var signalFileChooserUpdatePreviewMap = make(map[int]signalFileChooserUpdatePreviewDetail)
var signalFileChooserUpdatePreviewLock sync.RWMutex

// FileChooserSignalUpdatePreviewCallback is a callback function for a 'update-preview' signal emitted from a FileChooser.
type FileChooserSignalUpdatePreviewCallback func()

/*
ConnectUpdatePreview connects the callback to the 'update-preview' signal for the FileChooser.

The returned value represents the connection, and may be passed to DisconnectUpdatePreview to remove it.
*/
func (recv *FileChooser) ConnectUpdatePreview(callback FileChooserSignalUpdatePreviewCallback) int {
	signalFileChooserUpdatePreviewLock.Lock()
	defer signalFileChooserUpdatePreviewLock.Unlock()

	signalFileChooserUpdatePreviewId++
	instance := C.gpointer(recv.native)
	handlerID := C.FileChooser_signal_connect_update_preview(instance, C.gpointer(uintptr(signalFileChooserUpdatePreviewId)))

	detail := signalFileChooserUpdatePreviewDetail{callback, handlerID}
	signalFileChooserUpdatePreviewMap[signalFileChooserUpdatePreviewId] = detail

	return signalFileChooserUpdatePreviewId
}

/*
DisconnectUpdatePreview disconnects a callback from the 'update-preview' signal for the FileChooser.

The connectionID should be a value returned from a call to ConnectUpdatePreview.
*/
func (recv *FileChooser) DisconnectUpdatePreview(connectionID int) {
	signalFileChooserUpdatePreviewLock.Lock()
	defer signalFileChooserUpdatePreviewLock.Unlock()

	detail, exists := signalFileChooserUpdatePreviewMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFileChooserUpdatePreviewMap, connectionID)
}

//export filechooser_updatePreviewHandler
func filechooser_updatePreviewHandler(_ *C.GObject, data C.gpointer) {
	signalFileChooserUpdatePreviewLock.RLock()
	defer signalFileChooserUpdatePreviewLock.RUnlock()

	index := int(uintptr(data))
	callback := signalFileChooserUpdatePreviewMap[index].callback
	callback()
}

// AddFilter is a wrapper around the C function gtk_file_chooser_add_filter.
func (recv *FileChooser) AddFilter(filter *FileFilter) {
	c_filter := (*C.GtkFileFilter)(C.NULL)
	if filter != nil {
		c_filter = (*C.GtkFileFilter)(filter.ToC())
	}

	C.gtk_file_chooser_add_filter((*C.GtkFileChooser)(recv.native), c_filter)

	return
}

// AddShortcutFolder is a wrapper around the C function gtk_file_chooser_add_shortcut_folder.
func (recv *FileChooser) AddShortcutFolder(folder string) (bool, error) {
	c_folder := C.CString(folder)
	defer C.free(unsafe.Pointer(c_folder))

	var cThrowableError *C.GError

	retC := C.gtk_file_chooser_add_shortcut_folder((*C.GtkFileChooser)(recv.native), c_folder, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// AddShortcutFolderUri is a wrapper around the C function gtk_file_chooser_add_shortcut_folder_uri.
func (recv *FileChooser) AddShortcutFolderUri(uri string) (bool, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	var cThrowableError *C.GError

	retC := C.gtk_file_chooser_add_shortcut_folder_uri((*C.GtkFileChooser)(recv.native), c_uri, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// GetAction is a wrapper around the C function gtk_file_chooser_get_action.
func (recv *FileChooser) GetAction() FileChooserAction {
	retC := C.gtk_file_chooser_get_action((*C.GtkFileChooser)(recv.native))
	retGo := (FileChooserAction)(retC)

	return retGo
}

// GetCurrentFolder is a wrapper around the C function gtk_file_chooser_get_current_folder.
func (recv *FileChooser) GetCurrentFolder() string {
	retC := C.gtk_file_chooser_get_current_folder((*C.GtkFileChooser)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetCurrentFolderUri is a wrapper around the C function gtk_file_chooser_get_current_folder_uri.
func (recv *FileChooser) GetCurrentFolderUri() string {
	retC := C.gtk_file_chooser_get_current_folder_uri((*C.GtkFileChooser)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetDoOverwriteConfirmation is a wrapper around the C function gtk_file_chooser_get_do_overwrite_confirmation.
func (recv *FileChooser) GetDoOverwriteConfirmation() bool {
	retC := C.gtk_file_chooser_get_do_overwrite_confirmation((*C.GtkFileChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetExtraWidget is a wrapper around the C function gtk_file_chooser_get_extra_widget.
func (recv *FileChooser) GetExtraWidget() *Widget {
	retC := C.gtk_file_chooser_get_extra_widget((*C.GtkFileChooser)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetFilename is a wrapper around the C function gtk_file_chooser_get_filename.
func (recv *FileChooser) GetFilename() string {
	retC := C.gtk_file_chooser_get_filename((*C.GtkFileChooser)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetFilenames is a wrapper around the C function gtk_file_chooser_get_filenames.
func (recv *FileChooser) GetFilenames() *glib.SList {
	retC := C.gtk_file_chooser_get_filenames((*C.GtkFileChooser)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetFilter is a wrapper around the C function gtk_file_chooser_get_filter.
func (recv *FileChooser) GetFilter() *FileFilter {
	retC := C.gtk_file_chooser_get_filter((*C.GtkFileChooser)(recv.native))
	var retGo (*FileFilter)
	if retC == nil {
		retGo = nil
	} else {
		retGo = FileFilterNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetLocalOnly is a wrapper around the C function gtk_file_chooser_get_local_only.
func (recv *FileChooser) GetLocalOnly() bool {
	retC := C.gtk_file_chooser_get_local_only((*C.GtkFileChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetPreviewFilename is a wrapper around the C function gtk_file_chooser_get_preview_filename.
func (recv *FileChooser) GetPreviewFilename() string {
	retC := C.gtk_file_chooser_get_preview_filename((*C.GtkFileChooser)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetPreviewUri is a wrapper around the C function gtk_file_chooser_get_preview_uri.
func (recv *FileChooser) GetPreviewUri() string {
	retC := C.gtk_file_chooser_get_preview_uri((*C.GtkFileChooser)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetPreviewWidget is a wrapper around the C function gtk_file_chooser_get_preview_widget.
func (recv *FileChooser) GetPreviewWidget() *Widget {
	retC := C.gtk_file_chooser_get_preview_widget((*C.GtkFileChooser)(recv.native))
	var retGo (*Widget)
	if retC == nil {
		retGo = nil
	} else {
		retGo = WidgetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetPreviewWidgetActive is a wrapper around the C function gtk_file_chooser_get_preview_widget_active.
func (recv *FileChooser) GetPreviewWidgetActive() bool {
	retC := C.gtk_file_chooser_get_preview_widget_active((*C.GtkFileChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSelectMultiple is a wrapper around the C function gtk_file_chooser_get_select_multiple.
func (recv *FileChooser) GetSelectMultiple() bool {
	retC := C.gtk_file_chooser_get_select_multiple((*C.GtkFileChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowHidden is a wrapper around the C function gtk_file_chooser_get_show_hidden.
func (recv *FileChooser) GetShowHidden() bool {
	retC := C.gtk_file_chooser_get_show_hidden((*C.GtkFileChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetUri is a wrapper around the C function gtk_file_chooser_get_uri.
func (recv *FileChooser) GetUri() string {
	retC := C.gtk_file_chooser_get_uri((*C.GtkFileChooser)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetUris is a wrapper around the C function gtk_file_chooser_get_uris.
func (recv *FileChooser) GetUris() *glib.SList {
	retC := C.gtk_file_chooser_get_uris((*C.GtkFileChooser)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetUsePreviewLabel is a wrapper around the C function gtk_file_chooser_get_use_preview_label.
func (recv *FileChooser) GetUsePreviewLabel() bool {
	retC := C.gtk_file_chooser_get_use_preview_label((*C.GtkFileChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ListFilters is a wrapper around the C function gtk_file_chooser_list_filters.
func (recv *FileChooser) ListFilters() *glib.SList {
	retC := C.gtk_file_chooser_list_filters((*C.GtkFileChooser)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ListShortcutFolderUris is a wrapper around the C function gtk_file_chooser_list_shortcut_folder_uris.
func (recv *FileChooser) ListShortcutFolderUris() *glib.SList {
	retC := C.gtk_file_chooser_list_shortcut_folder_uris((*C.GtkFileChooser)(recv.native))
	var retGo (*glib.SList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.SListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// ListShortcutFolders is a wrapper around the C function gtk_file_chooser_list_shortcut_folders.
func (recv *FileChooser) ListShortcutFolders() *glib.SList {
	retC := C.gtk_file_chooser_list_shortcut_folders((*C.GtkFileChooser)(recv.native))
	var retGo (*glib.SList)
	if retC == nil {
		retGo = nil
	} else {
		retGo = glib.SListNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// RemoveFilter is a wrapper around the C function gtk_file_chooser_remove_filter.
func (recv *FileChooser) RemoveFilter(filter *FileFilter) {
	c_filter := (*C.GtkFileFilter)(C.NULL)
	if filter != nil {
		c_filter = (*C.GtkFileFilter)(filter.ToC())
	}

	C.gtk_file_chooser_remove_filter((*C.GtkFileChooser)(recv.native), c_filter)

	return
}

// RemoveShortcutFolder is a wrapper around the C function gtk_file_chooser_remove_shortcut_folder.
func (recv *FileChooser) RemoveShortcutFolder(folder string) (bool, error) {
	c_folder := C.CString(folder)
	defer C.free(unsafe.Pointer(c_folder))

	var cThrowableError *C.GError

	retC := C.gtk_file_chooser_remove_shortcut_folder((*C.GtkFileChooser)(recv.native), c_folder, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// RemoveShortcutFolderUri is a wrapper around the C function gtk_file_chooser_remove_shortcut_folder_uri.
func (recv *FileChooser) RemoveShortcutFolderUri(uri string) (bool, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	var cThrowableError *C.GError

	retC := C.gtk_file_chooser_remove_shortcut_folder_uri((*C.GtkFileChooser)(recv.native), c_uri, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SelectAll is a wrapper around the C function gtk_file_chooser_select_all.
func (recv *FileChooser) SelectAll() {
	C.gtk_file_chooser_select_all((*C.GtkFileChooser)(recv.native))

	return
}

// SelectFilename is a wrapper around the C function gtk_file_chooser_select_filename.
func (recv *FileChooser) SelectFilename(filename string) bool {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.gtk_file_chooser_select_filename((*C.GtkFileChooser)(recv.native), c_filename)
	retGo := retC == C.TRUE

	return retGo
}

// SelectUri is a wrapper around the C function gtk_file_chooser_select_uri.
func (recv *FileChooser) SelectUri(uri string) bool {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	retC := C.gtk_file_chooser_select_uri((*C.GtkFileChooser)(recv.native), c_uri)
	retGo := retC == C.TRUE

	return retGo
}

// SetAction is a wrapper around the C function gtk_file_chooser_set_action.
func (recv *FileChooser) SetAction(action FileChooserAction) {
	c_action := (C.GtkFileChooserAction)(action)

	C.gtk_file_chooser_set_action((*C.GtkFileChooser)(recv.native), c_action)

	return
}

// SetCurrentFolder is a wrapper around the C function gtk_file_chooser_set_current_folder.
func (recv *FileChooser) SetCurrentFolder(filename string) bool {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.gtk_file_chooser_set_current_folder((*C.GtkFileChooser)(recv.native), c_filename)
	retGo := retC == C.TRUE

	return retGo
}

// SetCurrentFolderUri is a wrapper around the C function gtk_file_chooser_set_current_folder_uri.
func (recv *FileChooser) SetCurrentFolderUri(uri string) bool {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	retC := C.gtk_file_chooser_set_current_folder_uri((*C.GtkFileChooser)(recv.native), c_uri)
	retGo := retC == C.TRUE

	return retGo
}

// SetCurrentName is a wrapper around the C function gtk_file_chooser_set_current_name.
func (recv *FileChooser) SetCurrentName(name string) {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	C.gtk_file_chooser_set_current_name((*C.GtkFileChooser)(recv.native), c_name)

	return
}

// SetDoOverwriteConfirmation is a wrapper around the C function gtk_file_chooser_set_do_overwrite_confirmation.
func (recv *FileChooser) SetDoOverwriteConfirmation(doOverwriteConfirmation bool) {
	c_do_overwrite_confirmation :=
		boolToGboolean(doOverwriteConfirmation)

	C.gtk_file_chooser_set_do_overwrite_confirmation((*C.GtkFileChooser)(recv.native), c_do_overwrite_confirmation)

	return
}

// SetExtraWidget is a wrapper around the C function gtk_file_chooser_set_extra_widget.
func (recv *FileChooser) SetExtraWidget(extraWidget *Widget) {
	c_extra_widget := (*C.GtkWidget)(C.NULL)
	if extraWidget != nil {
		c_extra_widget = (*C.GtkWidget)(extraWidget.ToC())
	}

	C.gtk_file_chooser_set_extra_widget((*C.GtkFileChooser)(recv.native), c_extra_widget)

	return
}

// SetFilename is a wrapper around the C function gtk_file_chooser_set_filename.
func (recv *FileChooser) SetFilename(filename string) bool {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	retC := C.gtk_file_chooser_set_filename((*C.GtkFileChooser)(recv.native), c_filename)
	retGo := retC == C.TRUE

	return retGo
}

// SetFilter is a wrapper around the C function gtk_file_chooser_set_filter.
func (recv *FileChooser) SetFilter(filter *FileFilter) {
	c_filter := (*C.GtkFileFilter)(C.NULL)
	if filter != nil {
		c_filter = (*C.GtkFileFilter)(filter.ToC())
	}

	C.gtk_file_chooser_set_filter((*C.GtkFileChooser)(recv.native), c_filter)

	return
}

// SetLocalOnly is a wrapper around the C function gtk_file_chooser_set_local_only.
func (recv *FileChooser) SetLocalOnly(localOnly bool) {
	c_local_only :=
		boolToGboolean(localOnly)

	C.gtk_file_chooser_set_local_only((*C.GtkFileChooser)(recv.native), c_local_only)

	return
}

// SetPreviewWidget is a wrapper around the C function gtk_file_chooser_set_preview_widget.
func (recv *FileChooser) SetPreviewWidget(previewWidget *Widget) {
	c_preview_widget := (*C.GtkWidget)(C.NULL)
	if previewWidget != nil {
		c_preview_widget = (*C.GtkWidget)(previewWidget.ToC())
	}

	C.gtk_file_chooser_set_preview_widget((*C.GtkFileChooser)(recv.native), c_preview_widget)

	return
}

// SetPreviewWidgetActive is a wrapper around the C function gtk_file_chooser_set_preview_widget_active.
func (recv *FileChooser) SetPreviewWidgetActive(active bool) {
	c_active :=
		boolToGboolean(active)

	C.gtk_file_chooser_set_preview_widget_active((*C.GtkFileChooser)(recv.native), c_active)

	return
}

// SetSelectMultiple is a wrapper around the C function gtk_file_chooser_set_select_multiple.
func (recv *FileChooser) SetSelectMultiple(selectMultiple bool) {
	c_select_multiple :=
		boolToGboolean(selectMultiple)

	C.gtk_file_chooser_set_select_multiple((*C.GtkFileChooser)(recv.native), c_select_multiple)

	return
}

// SetShowHidden is a wrapper around the C function gtk_file_chooser_set_show_hidden.
func (recv *FileChooser) SetShowHidden(showHidden bool) {
	c_show_hidden :=
		boolToGboolean(showHidden)

	C.gtk_file_chooser_set_show_hidden((*C.GtkFileChooser)(recv.native), c_show_hidden)

	return
}

// SetUri is a wrapper around the C function gtk_file_chooser_set_uri.
func (recv *FileChooser) SetUri(uri string) bool {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	retC := C.gtk_file_chooser_set_uri((*C.GtkFileChooser)(recv.native), c_uri)
	retGo := retC == C.TRUE

	return retGo
}

// SetUsePreviewLabel is a wrapper around the C function gtk_file_chooser_set_use_preview_label.
func (recv *FileChooser) SetUsePreviewLabel(useLabel bool) {
	c_use_label :=
		boolToGboolean(useLabel)

	C.gtk_file_chooser_set_use_preview_label((*C.GtkFileChooser)(recv.native), c_use_label)

	return
}

// UnselectAll is a wrapper around the C function gtk_file_chooser_unselect_all.
func (recv *FileChooser) UnselectAll() {
	C.gtk_file_chooser_unselect_all((*C.GtkFileChooser)(recv.native))

	return
}

// UnselectFilename is a wrapper around the C function gtk_file_chooser_unselect_filename.
func (recv *FileChooser) UnselectFilename(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_file_chooser_unselect_filename((*C.GtkFileChooser)(recv.native), c_filename)

	return
}

// UnselectUri is a wrapper around the C function gtk_file_chooser_unselect_uri.
func (recv *FileChooser) UnselectUri(uri string) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	C.gtk_file_chooser_unselect_uri((*C.GtkFileChooser)(recv.native), c_uri)

	return
}

// FontChooser is a wrapper around the C record GtkFontChooser.
type FontChooser struct {
	native *C.GtkFontChooser
}

func FontChooserNewFromC(u unsafe.Pointer) *FontChooser {
	c := (*C.GtkFontChooser)(u)
	if c == nil {
		return nil
	}

	g := &FontChooser{native: c}

	return g
}

func (recv *FontChooser) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooser with another FontChooser, and returns true if they represent the same GObject.
func (recv *FontChooser) Equals(other *FontChooser) bool {
	return other.ToC() == recv.ToC()
}

type signalFontChooserFontActivatedDetail struct {
	callback  FontChooserSignalFontActivatedCallback
	handlerID C.gulong
}

var signalFontChooserFontActivatedId int
var signalFontChooserFontActivatedMap = make(map[int]signalFontChooserFontActivatedDetail)
var signalFontChooserFontActivatedLock sync.RWMutex

// FontChooserSignalFontActivatedCallback is a callback function for a 'font-activated' signal emitted from a FontChooser.
type FontChooserSignalFontActivatedCallback func(fontname string)

/*
ConnectFontActivated connects the callback to the 'font-activated' signal for the FontChooser.

The returned value represents the connection, and may be passed to DisconnectFontActivated to remove it.
*/
func (recv *FontChooser) ConnectFontActivated(callback FontChooserSignalFontActivatedCallback) int {
	signalFontChooserFontActivatedLock.Lock()
	defer signalFontChooserFontActivatedLock.Unlock()

	signalFontChooserFontActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.FontChooser_signal_connect_font_activated(instance, C.gpointer(uintptr(signalFontChooserFontActivatedId)))

	detail := signalFontChooserFontActivatedDetail{callback, handlerID}
	signalFontChooserFontActivatedMap[signalFontChooserFontActivatedId] = detail

	return signalFontChooserFontActivatedId
}

/*
DisconnectFontActivated disconnects a callback from the 'font-activated' signal for the FontChooser.

The connectionID should be a value returned from a call to ConnectFontActivated.
*/
func (recv *FontChooser) DisconnectFontActivated(connectionID int) {
	signalFontChooserFontActivatedLock.Lock()
	defer signalFontChooserFontActivatedLock.Unlock()

	detail, exists := signalFontChooserFontActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalFontChooserFontActivatedMap, connectionID)
}

//export fontchooser_fontActivatedHandler
func fontchooser_fontActivatedHandler(_ *C.GObject, c_fontname *C.gchar, data C.gpointer) {
	signalFontChooserFontActivatedLock.RLock()
	defer signalFontChooserFontActivatedLock.RUnlock()

	fontname := C.GoString(c_fontname)

	index := int(uintptr(data))
	callback := signalFontChooserFontActivatedMap[index].callback
	callback(fontname)
}

// Orientable is a wrapper around the C record GtkOrientable.
type Orientable struct {
	native *C.GtkOrientable
}

func OrientableNewFromC(u unsafe.Pointer) *Orientable {
	c := (*C.GtkOrientable)(u)
	if c == nil {
		return nil
	}

	g := &Orientable{native: c}

	return g
}

func (recv *Orientable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Orientable with another Orientable, and returns true if they represent the same GObject.
func (recv *Orientable) Equals(other *Orientable) bool {
	return other.ToC() == recv.ToC()
}

// PrintOperationPreview is a wrapper around the C record GtkPrintOperationPreview.
type PrintOperationPreview struct {
	native *C.GtkPrintOperationPreview
}

func PrintOperationPreviewNewFromC(u unsafe.Pointer) *PrintOperationPreview {
	c := (*C.GtkPrintOperationPreview)(u)
	if c == nil {
		return nil
	}

	g := &PrintOperationPreview{native: c}

	return g
}

func (recv *PrintOperationPreview) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintOperationPreview with another PrintOperationPreview, and returns true if they represent the same GObject.
func (recv *PrintOperationPreview) Equals(other *PrintOperationPreview) bool {
	return other.ToC() == recv.ToC()
}

type signalPrintOperationPreviewGotPageSizeDetail struct {
	callback  PrintOperationPreviewSignalGotPageSizeCallback
	handlerID C.gulong
}

var signalPrintOperationPreviewGotPageSizeId int
var signalPrintOperationPreviewGotPageSizeMap = make(map[int]signalPrintOperationPreviewGotPageSizeDetail)
var signalPrintOperationPreviewGotPageSizeLock sync.RWMutex

// PrintOperationPreviewSignalGotPageSizeCallback is a callback function for a 'got-page-size' signal emitted from a PrintOperationPreview.
type PrintOperationPreviewSignalGotPageSizeCallback func(context *PrintContext, pageSetup *PageSetup)

/*
ConnectGotPageSize connects the callback to the 'got-page-size' signal for the PrintOperationPreview.

The returned value represents the connection, and may be passed to DisconnectGotPageSize to remove it.
*/
func (recv *PrintOperationPreview) ConnectGotPageSize(callback PrintOperationPreviewSignalGotPageSizeCallback) int {
	signalPrintOperationPreviewGotPageSizeLock.Lock()
	defer signalPrintOperationPreviewGotPageSizeLock.Unlock()

	signalPrintOperationPreviewGotPageSizeId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperationPreview_signal_connect_got_page_size(instance, C.gpointer(uintptr(signalPrintOperationPreviewGotPageSizeId)))

	detail := signalPrintOperationPreviewGotPageSizeDetail{callback, handlerID}
	signalPrintOperationPreviewGotPageSizeMap[signalPrintOperationPreviewGotPageSizeId] = detail

	return signalPrintOperationPreviewGotPageSizeId
}

/*
DisconnectGotPageSize disconnects a callback from the 'got-page-size' signal for the PrintOperationPreview.

The connectionID should be a value returned from a call to ConnectGotPageSize.
*/
func (recv *PrintOperationPreview) DisconnectGotPageSize(connectionID int) {
	signalPrintOperationPreviewGotPageSizeLock.Lock()
	defer signalPrintOperationPreviewGotPageSizeLock.Unlock()

	detail, exists := signalPrintOperationPreviewGotPageSizeMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationPreviewGotPageSizeMap, connectionID)
}

//export printoperationpreview_gotPageSizeHandler
func printoperationpreview_gotPageSizeHandler(_ *C.GObject, c_context *C.GtkPrintContext, c_page_setup *C.GtkPageSetup, data C.gpointer) {
	signalPrintOperationPreviewGotPageSizeLock.RLock()
	defer signalPrintOperationPreviewGotPageSizeLock.RUnlock()

	context := PrintContextNewFromC(unsafe.Pointer(c_context))

	pageSetup := PageSetupNewFromC(unsafe.Pointer(c_page_setup))

	index := int(uintptr(data))
	callback := signalPrintOperationPreviewGotPageSizeMap[index].callback
	callback(context, pageSetup)
}

type signalPrintOperationPreviewReadyDetail struct {
	callback  PrintOperationPreviewSignalReadyCallback
	handlerID C.gulong
}

var signalPrintOperationPreviewReadyId int
var signalPrintOperationPreviewReadyMap = make(map[int]signalPrintOperationPreviewReadyDetail)
var signalPrintOperationPreviewReadyLock sync.RWMutex

// PrintOperationPreviewSignalReadyCallback is a callback function for a 'ready' signal emitted from a PrintOperationPreview.
type PrintOperationPreviewSignalReadyCallback func(context *PrintContext)

/*
ConnectReady connects the callback to the 'ready' signal for the PrintOperationPreview.

The returned value represents the connection, and may be passed to DisconnectReady to remove it.
*/
func (recv *PrintOperationPreview) ConnectReady(callback PrintOperationPreviewSignalReadyCallback) int {
	signalPrintOperationPreviewReadyLock.Lock()
	defer signalPrintOperationPreviewReadyLock.Unlock()

	signalPrintOperationPreviewReadyId++
	instance := C.gpointer(recv.native)
	handlerID := C.PrintOperationPreview_signal_connect_ready(instance, C.gpointer(uintptr(signalPrintOperationPreviewReadyId)))

	detail := signalPrintOperationPreviewReadyDetail{callback, handlerID}
	signalPrintOperationPreviewReadyMap[signalPrintOperationPreviewReadyId] = detail

	return signalPrintOperationPreviewReadyId
}

/*
DisconnectReady disconnects a callback from the 'ready' signal for the PrintOperationPreview.

The connectionID should be a value returned from a call to ConnectReady.
*/
func (recv *PrintOperationPreview) DisconnectReady(connectionID int) {
	signalPrintOperationPreviewReadyLock.Lock()
	defer signalPrintOperationPreviewReadyLock.Unlock()

	detail, exists := signalPrintOperationPreviewReadyMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalPrintOperationPreviewReadyMap, connectionID)
}

//export printoperationpreview_readyHandler
func printoperationpreview_readyHandler(_ *C.GObject, c_context *C.GtkPrintContext, data C.gpointer) {
	signalPrintOperationPreviewReadyLock.RLock()
	defer signalPrintOperationPreviewReadyLock.RUnlock()

	context := PrintContextNewFromC(unsafe.Pointer(c_context))

	index := int(uintptr(data))
	callback := signalPrintOperationPreviewReadyMap[index].callback
	callback(context)
}

// EndPreview is a wrapper around the C function gtk_print_operation_preview_end_preview.
func (recv *PrintOperationPreview) EndPreview() {
	C.gtk_print_operation_preview_end_preview((*C.GtkPrintOperationPreview)(recv.native))

	return
}

// IsSelected is a wrapper around the C function gtk_print_operation_preview_is_selected.
func (recv *PrintOperationPreview) IsSelected(pageNr int32) bool {
	c_page_nr := (C.gint)(pageNr)

	retC := C.gtk_print_operation_preview_is_selected((*C.GtkPrintOperationPreview)(recv.native), c_page_nr)
	retGo := retC == C.TRUE

	return retGo
}

// RenderPage is a wrapper around the C function gtk_print_operation_preview_render_page.
func (recv *PrintOperationPreview) RenderPage(pageNr int32) {
	c_page_nr := (C.gint)(pageNr)

	C.gtk_print_operation_preview_render_page((*C.GtkPrintOperationPreview)(recv.native), c_page_nr)

	return
}

// RecentChooser is a wrapper around the C record GtkRecentChooser.
type RecentChooser struct {
	native *C.GtkRecentChooser
}

func RecentChooserNewFromC(u unsafe.Pointer) *RecentChooser {
	c := (*C.GtkRecentChooser)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooser{native: c}

	return g
}

func (recv *RecentChooser) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooser with another RecentChooser, and returns true if they represent the same GObject.
func (recv *RecentChooser) Equals(other *RecentChooser) bool {
	return other.ToC() == recv.ToC()
}

type signalRecentChooserItemActivatedDetail struct {
	callback  RecentChooserSignalItemActivatedCallback
	handlerID C.gulong
}

var signalRecentChooserItemActivatedId int
var signalRecentChooserItemActivatedMap = make(map[int]signalRecentChooserItemActivatedDetail)
var signalRecentChooserItemActivatedLock sync.RWMutex

// RecentChooserSignalItemActivatedCallback is a callback function for a 'item-activated' signal emitted from a RecentChooser.
type RecentChooserSignalItemActivatedCallback func()

/*
ConnectItemActivated connects the callback to the 'item-activated' signal for the RecentChooser.

The returned value represents the connection, and may be passed to DisconnectItemActivated to remove it.
*/
func (recv *RecentChooser) ConnectItemActivated(callback RecentChooserSignalItemActivatedCallback) int {
	signalRecentChooserItemActivatedLock.Lock()
	defer signalRecentChooserItemActivatedLock.Unlock()

	signalRecentChooserItemActivatedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RecentChooser_signal_connect_item_activated(instance, C.gpointer(uintptr(signalRecentChooserItemActivatedId)))

	detail := signalRecentChooserItemActivatedDetail{callback, handlerID}
	signalRecentChooserItemActivatedMap[signalRecentChooserItemActivatedId] = detail

	return signalRecentChooserItemActivatedId
}

/*
DisconnectItemActivated disconnects a callback from the 'item-activated' signal for the RecentChooser.

The connectionID should be a value returned from a call to ConnectItemActivated.
*/
func (recv *RecentChooser) DisconnectItemActivated(connectionID int) {
	signalRecentChooserItemActivatedLock.Lock()
	defer signalRecentChooserItemActivatedLock.Unlock()

	detail, exists := signalRecentChooserItemActivatedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRecentChooserItemActivatedMap, connectionID)
}

//export recentchooser_itemActivatedHandler
func recentchooser_itemActivatedHandler(_ *C.GObject, data C.gpointer) {
	signalRecentChooserItemActivatedLock.RLock()
	defer signalRecentChooserItemActivatedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalRecentChooserItemActivatedMap[index].callback
	callback()
}

type signalRecentChooserSelectionChangedDetail struct {
	callback  RecentChooserSignalSelectionChangedCallback
	handlerID C.gulong
}

var signalRecentChooserSelectionChangedId int
var signalRecentChooserSelectionChangedMap = make(map[int]signalRecentChooserSelectionChangedDetail)
var signalRecentChooserSelectionChangedLock sync.RWMutex

// RecentChooserSignalSelectionChangedCallback is a callback function for a 'selection-changed' signal emitted from a RecentChooser.
type RecentChooserSignalSelectionChangedCallback func()

/*
ConnectSelectionChanged connects the callback to the 'selection-changed' signal for the RecentChooser.

The returned value represents the connection, and may be passed to DisconnectSelectionChanged to remove it.
*/
func (recv *RecentChooser) ConnectSelectionChanged(callback RecentChooserSignalSelectionChangedCallback) int {
	signalRecentChooserSelectionChangedLock.Lock()
	defer signalRecentChooserSelectionChangedLock.Unlock()

	signalRecentChooserSelectionChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.RecentChooser_signal_connect_selection_changed(instance, C.gpointer(uintptr(signalRecentChooserSelectionChangedId)))

	detail := signalRecentChooserSelectionChangedDetail{callback, handlerID}
	signalRecentChooserSelectionChangedMap[signalRecentChooserSelectionChangedId] = detail

	return signalRecentChooserSelectionChangedId
}

/*
DisconnectSelectionChanged disconnects a callback from the 'selection-changed' signal for the RecentChooser.

The connectionID should be a value returned from a call to ConnectSelectionChanged.
*/
func (recv *RecentChooser) DisconnectSelectionChanged(connectionID int) {
	signalRecentChooserSelectionChangedLock.Lock()
	defer signalRecentChooserSelectionChangedLock.Unlock()

	detail, exists := signalRecentChooserSelectionChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalRecentChooserSelectionChangedMap, connectionID)
}

//export recentchooser_selectionChangedHandler
func recentchooser_selectionChangedHandler(_ *C.GObject, data C.gpointer) {
	signalRecentChooserSelectionChangedLock.RLock()
	defer signalRecentChooserSelectionChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalRecentChooserSelectionChangedMap[index].callback
	callback()
}

// AddFilter is a wrapper around the C function gtk_recent_chooser_add_filter.
func (recv *RecentChooser) AddFilter(filter *RecentFilter) {
	c_filter := (*C.GtkRecentFilter)(C.NULL)
	if filter != nil {
		c_filter = (*C.GtkRecentFilter)(filter.ToC())
	}

	C.gtk_recent_chooser_add_filter((*C.GtkRecentChooser)(recv.native), c_filter)

	return
}

// GetCurrentItem is a wrapper around the C function gtk_recent_chooser_get_current_item.
func (recv *RecentChooser) GetCurrentItem() *RecentInfo {
	retC := C.gtk_recent_chooser_get_current_item((*C.GtkRecentChooser)(recv.native))
	retGo := RecentInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetCurrentUri is a wrapper around the C function gtk_recent_chooser_get_current_uri.
func (recv *RecentChooser) GetCurrentUri() string {
	retC := C.gtk_recent_chooser_get_current_uri((*C.GtkRecentChooser)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetFilter is a wrapper around the C function gtk_recent_chooser_get_filter.
func (recv *RecentChooser) GetFilter() *RecentFilter {
	retC := C.gtk_recent_chooser_get_filter((*C.GtkRecentChooser)(recv.native))
	retGo := RecentFilterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetItems is a wrapper around the C function gtk_recent_chooser_get_items.
func (recv *RecentChooser) GetItems() *glib.List {
	retC := C.gtk_recent_chooser_get_items((*C.GtkRecentChooser)(recv.native))
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLimit is a wrapper around the C function gtk_recent_chooser_get_limit.
func (recv *RecentChooser) GetLimit() int32 {
	retC := C.gtk_recent_chooser_get_limit((*C.GtkRecentChooser)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetLocalOnly is a wrapper around the C function gtk_recent_chooser_get_local_only.
func (recv *RecentChooser) GetLocalOnly() bool {
	retC := C.gtk_recent_chooser_get_local_only((*C.GtkRecentChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSelectMultiple is a wrapper around the C function gtk_recent_chooser_get_select_multiple.
func (recv *RecentChooser) GetSelectMultiple() bool {
	retC := C.gtk_recent_chooser_get_select_multiple((*C.GtkRecentChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowIcons is a wrapper around the C function gtk_recent_chooser_get_show_icons.
func (recv *RecentChooser) GetShowIcons() bool {
	retC := C.gtk_recent_chooser_get_show_icons((*C.GtkRecentChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowNotFound is a wrapper around the C function gtk_recent_chooser_get_show_not_found.
func (recv *RecentChooser) GetShowNotFound() bool {
	retC := C.gtk_recent_chooser_get_show_not_found((*C.GtkRecentChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowPrivate is a wrapper around the C function gtk_recent_chooser_get_show_private.
func (recv *RecentChooser) GetShowPrivate() bool {
	retC := C.gtk_recent_chooser_get_show_private((*C.GtkRecentChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShowTips is a wrapper around the C function gtk_recent_chooser_get_show_tips.
func (recv *RecentChooser) GetShowTips() bool {
	retC := C.gtk_recent_chooser_get_show_tips((*C.GtkRecentChooser)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetSortType is a wrapper around the C function gtk_recent_chooser_get_sort_type.
func (recv *RecentChooser) GetSortType() RecentSortType {
	retC := C.gtk_recent_chooser_get_sort_type((*C.GtkRecentChooser)(recv.native))
	retGo := (RecentSortType)(retC)

	return retGo
}

// GetUris is a wrapper around the C function gtk_recent_chooser_get_uris.
func (recv *RecentChooser) GetUris() ([]string, uint64) {
	var c_length C.gsize

	retC := C.gtk_recent_chooser_get_uris((*C.GtkRecentChooser)(recv.native), &c_length)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	length := (uint64)(c_length)

	return retGo, length
}

// ListFilters is a wrapper around the C function gtk_recent_chooser_list_filters.
func (recv *RecentChooser) ListFilters() *glib.SList {
	retC := C.gtk_recent_chooser_list_filters((*C.GtkRecentChooser)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RemoveFilter is a wrapper around the C function gtk_recent_chooser_remove_filter.
func (recv *RecentChooser) RemoveFilter(filter *RecentFilter) {
	c_filter := (*C.GtkRecentFilter)(C.NULL)
	if filter != nil {
		c_filter = (*C.GtkRecentFilter)(filter.ToC())
	}

	C.gtk_recent_chooser_remove_filter((*C.GtkRecentChooser)(recv.native), c_filter)

	return
}

// SelectAll is a wrapper around the C function gtk_recent_chooser_select_all.
func (recv *RecentChooser) SelectAll() {
	C.gtk_recent_chooser_select_all((*C.GtkRecentChooser)(recv.native))

	return
}

// SelectUri is a wrapper around the C function gtk_recent_chooser_select_uri.
func (recv *RecentChooser) SelectUri(uri string) (bool, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	var cThrowableError *C.GError

	retC := C.gtk_recent_chooser_select_uri((*C.GtkRecentChooser)(recv.native), c_uri, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetCurrentUri is a wrapper around the C function gtk_recent_chooser_set_current_uri.
func (recv *RecentChooser) SetCurrentUri(uri string) (bool, error) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	var cThrowableError *C.GError

	retC := C.gtk_recent_chooser_set_current_uri((*C.GtkRecentChooser)(recv.native), c_uri, &cThrowableError)
	retGo := retC == C.TRUE

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// SetFilter is a wrapper around the C function gtk_recent_chooser_set_filter.
func (recv *RecentChooser) SetFilter(filter *RecentFilter) {
	c_filter := (*C.GtkRecentFilter)(C.NULL)
	if filter != nil {
		c_filter = (*C.GtkRecentFilter)(filter.ToC())
	}

	C.gtk_recent_chooser_set_filter((*C.GtkRecentChooser)(recv.native), c_filter)

	return
}

// SetLimit is a wrapper around the C function gtk_recent_chooser_set_limit.
func (recv *RecentChooser) SetLimit(limit int32) {
	c_limit := (C.gint)(limit)

	C.gtk_recent_chooser_set_limit((*C.GtkRecentChooser)(recv.native), c_limit)

	return
}

// SetLocalOnly is a wrapper around the C function gtk_recent_chooser_set_local_only.
func (recv *RecentChooser) SetLocalOnly(localOnly bool) {
	c_local_only :=
		boolToGboolean(localOnly)

	C.gtk_recent_chooser_set_local_only((*C.GtkRecentChooser)(recv.native), c_local_only)

	return
}

// SetSelectMultiple is a wrapper around the C function gtk_recent_chooser_set_select_multiple.
func (recv *RecentChooser) SetSelectMultiple(selectMultiple bool) {
	c_select_multiple :=
		boolToGboolean(selectMultiple)

	C.gtk_recent_chooser_set_select_multiple((*C.GtkRecentChooser)(recv.native), c_select_multiple)

	return
}

// SetShowIcons is a wrapper around the C function gtk_recent_chooser_set_show_icons.
func (recv *RecentChooser) SetShowIcons(showIcons bool) {
	c_show_icons :=
		boolToGboolean(showIcons)

	C.gtk_recent_chooser_set_show_icons((*C.GtkRecentChooser)(recv.native), c_show_icons)

	return
}

// SetShowNotFound is a wrapper around the C function gtk_recent_chooser_set_show_not_found.
func (recv *RecentChooser) SetShowNotFound(showNotFound bool) {
	c_show_not_found :=
		boolToGboolean(showNotFound)

	C.gtk_recent_chooser_set_show_not_found((*C.GtkRecentChooser)(recv.native), c_show_not_found)

	return
}

// SetShowPrivate is a wrapper around the C function gtk_recent_chooser_set_show_private.
func (recv *RecentChooser) SetShowPrivate(showPrivate bool) {
	c_show_private :=
		boolToGboolean(showPrivate)

	C.gtk_recent_chooser_set_show_private((*C.GtkRecentChooser)(recv.native), c_show_private)

	return
}

// SetShowTips is a wrapper around the C function gtk_recent_chooser_set_show_tips.
func (recv *RecentChooser) SetShowTips(showTips bool) {
	c_show_tips :=
		boolToGboolean(showTips)

	C.gtk_recent_chooser_set_show_tips((*C.GtkRecentChooser)(recv.native), c_show_tips)

	return
}

// Unsupported : gtk_recent_chooser_set_sort_func : unsupported parameter sort_func : no type generator for RecentSortFunc (GtkRecentSortFunc) for param sort_func

// SetSortType is a wrapper around the C function gtk_recent_chooser_set_sort_type.
func (recv *RecentChooser) SetSortType(sortType RecentSortType) {
	c_sort_type := (C.GtkRecentSortType)(sortType)

	C.gtk_recent_chooser_set_sort_type((*C.GtkRecentChooser)(recv.native), c_sort_type)

	return
}

// UnselectAll is a wrapper around the C function gtk_recent_chooser_unselect_all.
func (recv *RecentChooser) UnselectAll() {
	C.gtk_recent_chooser_unselect_all((*C.GtkRecentChooser)(recv.native))

	return
}

// UnselectUri is a wrapper around the C function gtk_recent_chooser_unselect_uri.
func (recv *RecentChooser) UnselectUri(uri string) {
	c_uri := C.CString(uri)
	defer C.free(unsafe.Pointer(c_uri))

	C.gtk_recent_chooser_unselect_uri((*C.GtkRecentChooser)(recv.native), c_uri)

	return
}

// Scrollable is a wrapper around the C record GtkScrollable.
type Scrollable struct {
	native *C.GtkScrollable
}

func ScrollableNewFromC(u unsafe.Pointer) *Scrollable {
	c := (*C.GtkScrollable)(u)
	if c == nil {
		return nil
	}

	g := &Scrollable{native: c}

	return g
}

func (recv *Scrollable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Scrollable with another Scrollable, and returns true if they represent the same GObject.
func (recv *Scrollable) Equals(other *Scrollable) bool {
	return other.ToC() == recv.ToC()
}

// StyleProvider is a wrapper around the C record GtkStyleProvider.
type StyleProvider struct {
	native *C.GtkStyleProvider
}

func StyleProviderNewFromC(u unsafe.Pointer) *StyleProvider {
	c := (*C.GtkStyleProvider)(u)
	if c == nil {
		return nil
	}

	g := &StyleProvider{native: c}

	return g
}

func (recv *StyleProvider) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleProvider with another StyleProvider, and returns true if they represent the same GObject.
func (recv *StyleProvider) Equals(other *StyleProvider) bool {
	return other.ToC() == recv.ToC()
}

// ToolShell is a wrapper around the C record GtkToolShell.
type ToolShell struct {
	native *C.GtkToolShell
}

func ToolShellNewFromC(u unsafe.Pointer) *ToolShell {
	c := (*C.GtkToolShell)(u)
	if c == nil {
		return nil
	}

	g := &ToolShell{native: c}

	return g
}

func (recv *ToolShell) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolShell with another ToolShell, and returns true if they represent the same GObject.
func (recv *ToolShell) Equals(other *ToolShell) bool {
	return other.ToC() == recv.ToC()
}

// TreeDragDest is a wrapper around the C record GtkTreeDragDest.
type TreeDragDest struct {
	native *C.GtkTreeDragDest
}

func TreeDragDestNewFromC(u unsafe.Pointer) *TreeDragDest {
	c := (*C.GtkTreeDragDest)(u)
	if c == nil {
		return nil
	}

	g := &TreeDragDest{native: c}

	return g
}

func (recv *TreeDragDest) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeDragDest with another TreeDragDest, and returns true if they represent the same GObject.
func (recv *TreeDragDest) Equals(other *TreeDragDest) bool {
	return other.ToC() == recv.ToC()
}

// DragDataReceived is a wrapper around the C function gtk_tree_drag_dest_drag_data_received.
func (recv *TreeDragDest) DragDataReceived(dest *TreePath, selectionData *SelectionData) bool {
	c_dest := (*C.GtkTreePath)(C.NULL)
	if dest != nil {
		c_dest = (*C.GtkTreePath)(dest.ToC())
	}

	c_selection_data := (*C.GtkSelectionData)(C.NULL)
	if selectionData != nil {
		c_selection_data = (*C.GtkSelectionData)(selectionData.ToC())
	}

	retC := C.gtk_tree_drag_dest_drag_data_received((*C.GtkTreeDragDest)(recv.native), c_dest, c_selection_data)
	retGo := retC == C.TRUE

	return retGo
}

// RowDropPossible is a wrapper around the C function gtk_tree_drag_dest_row_drop_possible.
func (recv *TreeDragDest) RowDropPossible(destPath *TreePath, selectionData *SelectionData) bool {
	c_dest_path := (*C.GtkTreePath)(C.NULL)
	if destPath != nil {
		c_dest_path = (*C.GtkTreePath)(destPath.ToC())
	}

	c_selection_data := (*C.GtkSelectionData)(C.NULL)
	if selectionData != nil {
		c_selection_data = (*C.GtkSelectionData)(selectionData.ToC())
	}

	retC := C.gtk_tree_drag_dest_row_drop_possible((*C.GtkTreeDragDest)(recv.native), c_dest_path, c_selection_data)
	retGo := retC == C.TRUE

	return retGo
}

// TreeDragSource is a wrapper around the C record GtkTreeDragSource.
type TreeDragSource struct {
	native *C.GtkTreeDragSource
}

func TreeDragSourceNewFromC(u unsafe.Pointer) *TreeDragSource {
	c := (*C.GtkTreeDragSource)(u)
	if c == nil {
		return nil
	}

	g := &TreeDragSource{native: c}

	return g
}

func (recv *TreeDragSource) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeDragSource with another TreeDragSource, and returns true if they represent the same GObject.
func (recv *TreeDragSource) Equals(other *TreeDragSource) bool {
	return other.ToC() == recv.ToC()
}

// DragDataDelete is a wrapper around the C function gtk_tree_drag_source_drag_data_delete.
func (recv *TreeDragSource) DragDataDelete(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_drag_source_drag_data_delete((*C.GtkTreeDragSource)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// DragDataGet is a wrapper around the C function gtk_tree_drag_source_drag_data_get.
func (recv *TreeDragSource) DragDataGet(path *TreePath, selectionData *SelectionData) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_selection_data := (*C.GtkSelectionData)(C.NULL)
	if selectionData != nil {
		c_selection_data = (*C.GtkSelectionData)(selectionData.ToC())
	}

	retC := C.gtk_tree_drag_source_drag_data_get((*C.GtkTreeDragSource)(recv.native), c_path, c_selection_data)
	retGo := retC == C.TRUE

	return retGo
}

// RowDraggable is a wrapper around the C function gtk_tree_drag_source_row_draggable.
func (recv *TreeDragSource) RowDraggable(path *TreePath) bool {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_drag_source_row_draggable((*C.GtkTreeDragSource)(recv.native), c_path)
	retGo := retC == C.TRUE

	return retGo
}

// TreeModel is a wrapper around the C record GtkTreeModel.
type TreeModel struct {
	native *C.GtkTreeModel
}

func TreeModelNewFromC(u unsafe.Pointer) *TreeModel {
	c := (*C.GtkTreeModel)(u)
	if c == nil {
		return nil
	}

	g := &TreeModel{native: c}

	return g
}

func (recv *TreeModel) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModel with another TreeModel, and returns true if they represent the same GObject.
func (recv *TreeModel) Equals(other *TreeModel) bool {
	return other.ToC() == recv.ToC()
}

type signalTreeModelRowChangedDetail struct {
	callback  TreeModelSignalRowChangedCallback
	handlerID C.gulong
}

var signalTreeModelRowChangedId int
var signalTreeModelRowChangedMap = make(map[int]signalTreeModelRowChangedDetail)
var signalTreeModelRowChangedLock sync.RWMutex

// TreeModelSignalRowChangedCallback is a callback function for a 'row-changed' signal emitted from a TreeModel.
type TreeModelSignalRowChangedCallback func(path *TreePath, iter *TreeIter)

/*
ConnectRowChanged connects the callback to the 'row-changed' signal for the TreeModel.

The returned value represents the connection, and may be passed to DisconnectRowChanged to remove it.
*/
func (recv *TreeModel) ConnectRowChanged(callback TreeModelSignalRowChangedCallback) int {
	signalTreeModelRowChangedLock.Lock()
	defer signalTreeModelRowChangedLock.Unlock()

	signalTreeModelRowChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeModel_signal_connect_row_changed(instance, C.gpointer(uintptr(signalTreeModelRowChangedId)))

	detail := signalTreeModelRowChangedDetail{callback, handlerID}
	signalTreeModelRowChangedMap[signalTreeModelRowChangedId] = detail

	return signalTreeModelRowChangedId
}

/*
DisconnectRowChanged disconnects a callback from the 'row-changed' signal for the TreeModel.

The connectionID should be a value returned from a call to ConnectRowChanged.
*/
func (recv *TreeModel) DisconnectRowChanged(connectionID int) {
	signalTreeModelRowChangedLock.Lock()
	defer signalTreeModelRowChangedLock.Unlock()

	detail, exists := signalTreeModelRowChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeModelRowChangedMap, connectionID)
}

//export treemodel_rowChangedHandler
func treemodel_rowChangedHandler(_ *C.GObject, c_path *C.GtkTreePath, c_iter *C.GtkTreeIter, data C.gpointer) {
	signalTreeModelRowChangedLock.RLock()
	defer signalTreeModelRowChangedLock.RUnlock()

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	index := int(uintptr(data))
	callback := signalTreeModelRowChangedMap[index].callback
	callback(path, iter)
}

type signalTreeModelRowDeletedDetail struct {
	callback  TreeModelSignalRowDeletedCallback
	handlerID C.gulong
}

var signalTreeModelRowDeletedId int
var signalTreeModelRowDeletedMap = make(map[int]signalTreeModelRowDeletedDetail)
var signalTreeModelRowDeletedLock sync.RWMutex

// TreeModelSignalRowDeletedCallback is a callback function for a 'row-deleted' signal emitted from a TreeModel.
type TreeModelSignalRowDeletedCallback func(path *TreePath)

/*
ConnectRowDeleted connects the callback to the 'row-deleted' signal for the TreeModel.

The returned value represents the connection, and may be passed to DisconnectRowDeleted to remove it.
*/
func (recv *TreeModel) ConnectRowDeleted(callback TreeModelSignalRowDeletedCallback) int {
	signalTreeModelRowDeletedLock.Lock()
	defer signalTreeModelRowDeletedLock.Unlock()

	signalTreeModelRowDeletedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeModel_signal_connect_row_deleted(instance, C.gpointer(uintptr(signalTreeModelRowDeletedId)))

	detail := signalTreeModelRowDeletedDetail{callback, handlerID}
	signalTreeModelRowDeletedMap[signalTreeModelRowDeletedId] = detail

	return signalTreeModelRowDeletedId
}

/*
DisconnectRowDeleted disconnects a callback from the 'row-deleted' signal for the TreeModel.

The connectionID should be a value returned from a call to ConnectRowDeleted.
*/
func (recv *TreeModel) DisconnectRowDeleted(connectionID int) {
	signalTreeModelRowDeletedLock.Lock()
	defer signalTreeModelRowDeletedLock.Unlock()

	detail, exists := signalTreeModelRowDeletedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeModelRowDeletedMap, connectionID)
}

//export treemodel_rowDeletedHandler
func treemodel_rowDeletedHandler(_ *C.GObject, c_path *C.GtkTreePath, data C.gpointer) {
	signalTreeModelRowDeletedLock.RLock()
	defer signalTreeModelRowDeletedLock.RUnlock()

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	index := int(uintptr(data))
	callback := signalTreeModelRowDeletedMap[index].callback
	callback(path)
}

type signalTreeModelRowHasChildToggledDetail struct {
	callback  TreeModelSignalRowHasChildToggledCallback
	handlerID C.gulong
}

var signalTreeModelRowHasChildToggledId int
var signalTreeModelRowHasChildToggledMap = make(map[int]signalTreeModelRowHasChildToggledDetail)
var signalTreeModelRowHasChildToggledLock sync.RWMutex

// TreeModelSignalRowHasChildToggledCallback is a callback function for a 'row-has-child-toggled' signal emitted from a TreeModel.
type TreeModelSignalRowHasChildToggledCallback func(path *TreePath, iter *TreeIter)

/*
ConnectRowHasChildToggled connects the callback to the 'row-has-child-toggled' signal for the TreeModel.

The returned value represents the connection, and may be passed to DisconnectRowHasChildToggled to remove it.
*/
func (recv *TreeModel) ConnectRowHasChildToggled(callback TreeModelSignalRowHasChildToggledCallback) int {
	signalTreeModelRowHasChildToggledLock.Lock()
	defer signalTreeModelRowHasChildToggledLock.Unlock()

	signalTreeModelRowHasChildToggledId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeModel_signal_connect_row_has_child_toggled(instance, C.gpointer(uintptr(signalTreeModelRowHasChildToggledId)))

	detail := signalTreeModelRowHasChildToggledDetail{callback, handlerID}
	signalTreeModelRowHasChildToggledMap[signalTreeModelRowHasChildToggledId] = detail

	return signalTreeModelRowHasChildToggledId
}

/*
DisconnectRowHasChildToggled disconnects a callback from the 'row-has-child-toggled' signal for the TreeModel.

The connectionID should be a value returned from a call to ConnectRowHasChildToggled.
*/
func (recv *TreeModel) DisconnectRowHasChildToggled(connectionID int) {
	signalTreeModelRowHasChildToggledLock.Lock()
	defer signalTreeModelRowHasChildToggledLock.Unlock()

	detail, exists := signalTreeModelRowHasChildToggledMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeModelRowHasChildToggledMap, connectionID)
}

//export treemodel_rowHasChildToggledHandler
func treemodel_rowHasChildToggledHandler(_ *C.GObject, c_path *C.GtkTreePath, c_iter *C.GtkTreeIter, data C.gpointer) {
	signalTreeModelRowHasChildToggledLock.RLock()
	defer signalTreeModelRowHasChildToggledLock.RUnlock()

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	index := int(uintptr(data))
	callback := signalTreeModelRowHasChildToggledMap[index].callback
	callback(path, iter)
}

type signalTreeModelRowInsertedDetail struct {
	callback  TreeModelSignalRowInsertedCallback
	handlerID C.gulong
}

var signalTreeModelRowInsertedId int
var signalTreeModelRowInsertedMap = make(map[int]signalTreeModelRowInsertedDetail)
var signalTreeModelRowInsertedLock sync.RWMutex

// TreeModelSignalRowInsertedCallback is a callback function for a 'row-inserted' signal emitted from a TreeModel.
type TreeModelSignalRowInsertedCallback func(path *TreePath, iter *TreeIter)

/*
ConnectRowInserted connects the callback to the 'row-inserted' signal for the TreeModel.

The returned value represents the connection, and may be passed to DisconnectRowInserted to remove it.
*/
func (recv *TreeModel) ConnectRowInserted(callback TreeModelSignalRowInsertedCallback) int {
	signalTreeModelRowInsertedLock.Lock()
	defer signalTreeModelRowInsertedLock.Unlock()

	signalTreeModelRowInsertedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeModel_signal_connect_row_inserted(instance, C.gpointer(uintptr(signalTreeModelRowInsertedId)))

	detail := signalTreeModelRowInsertedDetail{callback, handlerID}
	signalTreeModelRowInsertedMap[signalTreeModelRowInsertedId] = detail

	return signalTreeModelRowInsertedId
}

/*
DisconnectRowInserted disconnects a callback from the 'row-inserted' signal for the TreeModel.

The connectionID should be a value returned from a call to ConnectRowInserted.
*/
func (recv *TreeModel) DisconnectRowInserted(connectionID int) {
	signalTreeModelRowInsertedLock.Lock()
	defer signalTreeModelRowInsertedLock.Unlock()

	detail, exists := signalTreeModelRowInsertedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeModelRowInsertedMap, connectionID)
}

//export treemodel_rowInsertedHandler
func treemodel_rowInsertedHandler(_ *C.GObject, c_path *C.GtkTreePath, c_iter *C.GtkTreeIter, data C.gpointer) {
	signalTreeModelRowInsertedLock.RLock()
	defer signalTreeModelRowInsertedLock.RUnlock()

	path := TreePathNewFromC(unsafe.Pointer(c_path))

	iter := TreeIterNewFromC(unsafe.Pointer(c_iter))

	index := int(uintptr(data))
	callback := signalTreeModelRowInsertedMap[index].callback
	callback(path, iter)
}

// Unsupported signal 'rows-reordered' for TreeModel : param new_order : gpointer

// FilterNew is a wrapper around the C function gtk_tree_model_filter_new.
func (recv *TreeModel) FilterNew(root *TreePath) *TreeModel {
	c_root := (*C.GtkTreePath)(C.NULL)
	if root != nil {
		c_root = (*C.GtkTreePath)(root.ToC())
	}

	retC := C.gtk_tree_model_filter_new((*C.GtkTreeModel)(recv.native), c_root)
	retGo := TreeModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_model_foreach : unsupported parameter func : no type generator for TreeModelForeachFunc (GtkTreeModelForeachFunc) for param func

// Unsupported : gtk_tree_model_get : unsupported parameter ... : varargs

// GetColumnType is a wrapper around the C function gtk_tree_model_get_column_type.
func (recv *TreeModel) GetColumnType(index int32) gobject.Type {
	c_index_ := (C.gint)(index)

	retC := C.gtk_tree_model_get_column_type((*C.GtkTreeModel)(recv.native), c_index_)
	retGo := (gobject.Type)(retC)

	return retGo
}

// GetFlags is a wrapper around the C function gtk_tree_model_get_flags.
func (recv *TreeModel) GetFlags() TreeModelFlags {
	retC := C.gtk_tree_model_get_flags((*C.GtkTreeModel)(recv.native))
	retGo := (TreeModelFlags)(retC)

	return retGo
}

// GetIter is a wrapper around the C function gtk_tree_model_get_iter.
func (recv *TreeModel) GetIter(path *TreePath) (bool, *TreeIter) {
	var c_iter C.GtkTreeIter

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_model_get_iter((*C.GtkTreeModel)(recv.native), &c_iter, c_path)
	retGo := retC == C.TRUE

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, iter
}

// GetIterFirst is a wrapper around the C function gtk_tree_model_get_iter_first.
func (recv *TreeModel) GetIterFirst() (bool, *TreeIter) {
	var c_iter C.GtkTreeIter

	retC := C.gtk_tree_model_get_iter_first((*C.GtkTreeModel)(recv.native), &c_iter)
	retGo := retC == C.TRUE

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, iter
}

// GetIterFromString is a wrapper around the C function gtk_tree_model_get_iter_from_string.
func (recv *TreeModel) GetIterFromString(pathString string) (bool, *TreeIter) {
	var c_iter C.GtkTreeIter

	c_path_string := C.CString(pathString)
	defer C.free(unsafe.Pointer(c_path_string))

	retC := C.gtk_tree_model_get_iter_from_string((*C.GtkTreeModel)(recv.native), &c_iter, c_path_string)
	retGo := retC == C.TRUE

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, iter
}

// GetNColumns is a wrapper around the C function gtk_tree_model_get_n_columns.
func (recv *TreeModel) GetNColumns() int32 {
	retC := C.gtk_tree_model_get_n_columns((*C.GtkTreeModel)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetPath is a wrapper around the C function gtk_tree_model_get_path.
func (recv *TreeModel) GetPath(iter *TreeIter) *TreePath {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_model_get_path((*C.GtkTreeModel)(recv.native), c_iter)
	retGo := TreePathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetStringFromIter is a wrapper around the C function gtk_tree_model_get_string_from_iter.
func (recv *TreeModel) GetStringFromIter(iter *TreeIter) string {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_model_get_string_from_iter((*C.GtkTreeModel)(recv.native), c_iter)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_model_get_valist : unsupported parameter var_args : no type generator for va_list (va_list) for param var_args

// GetValue is a wrapper around the C function gtk_tree_model_get_value.
func (recv *TreeModel) GetValue(iter *TreeIter, column int32) *gobject.Value {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_column := (C.gint)(column)

	var c_value C.GValue

	C.gtk_tree_model_get_value((*C.GtkTreeModel)(recv.native), c_iter, c_column, &c_value)

	value := gobject.ValueNewFromC(unsafe.Pointer(&c_value))

	return value
}

// IterChildren is a wrapper around the C function gtk_tree_model_iter_children.
func (recv *TreeModel) IterChildren(parent *TreeIter) (bool, *TreeIter) {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	retC := C.gtk_tree_model_iter_children((*C.GtkTreeModel)(recv.native), &c_iter, c_parent)
	retGo := retC == C.TRUE

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, iter
}

// IterHasChild is a wrapper around the C function gtk_tree_model_iter_has_child.
func (recv *TreeModel) IterHasChild(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_model_iter_has_child((*C.GtkTreeModel)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// IterNChildren is a wrapper around the C function gtk_tree_model_iter_n_children.
func (recv *TreeModel) IterNChildren(iter *TreeIter) int32 {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_model_iter_n_children((*C.GtkTreeModel)(recv.native), c_iter)
	retGo := (int32)(retC)

	return retGo
}

// IterNext is a wrapper around the C function gtk_tree_model_iter_next.
func (recv *TreeModel) IterNext(iter *TreeIter) bool {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	retC := C.gtk_tree_model_iter_next((*C.GtkTreeModel)(recv.native), c_iter)
	retGo := retC == C.TRUE

	return retGo
}

// IterNthChild is a wrapper around the C function gtk_tree_model_iter_nth_child.
func (recv *TreeModel) IterNthChild(parent *TreeIter, n int32) (bool, *TreeIter) {
	var c_iter C.GtkTreeIter

	c_parent := (*C.GtkTreeIter)(C.NULL)
	if parent != nil {
		c_parent = (*C.GtkTreeIter)(parent.ToC())
	}

	c_n := (C.gint)(n)

	retC := C.gtk_tree_model_iter_nth_child((*C.GtkTreeModel)(recv.native), &c_iter, c_parent, c_n)
	retGo := retC == C.TRUE

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, iter
}

// IterParent is a wrapper around the C function gtk_tree_model_iter_parent.
func (recv *TreeModel) IterParent(child *TreeIter) (bool, *TreeIter) {
	var c_iter C.GtkTreeIter

	c_child := (*C.GtkTreeIter)(C.NULL)
	if child != nil {
		c_child = (*C.GtkTreeIter)(child.ToC())
	}

	retC := C.gtk_tree_model_iter_parent((*C.GtkTreeModel)(recv.native), &c_iter, c_child)
	retGo := retC == C.TRUE

	iter := TreeIterNewFromC(unsafe.Pointer(&c_iter))

	return retGo, iter
}

// RefNode is a wrapper around the C function gtk_tree_model_ref_node.
func (recv *TreeModel) RefNode(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_model_ref_node((*C.GtkTreeModel)(recv.native), c_iter)

	return
}

// RowChanged is a wrapper around the C function gtk_tree_model_row_changed.
func (recv *TreeModel) RowChanged(path *TreePath, iter *TreeIter) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_model_row_changed((*C.GtkTreeModel)(recv.native), c_path, c_iter)

	return
}

// RowDeleted is a wrapper around the C function gtk_tree_model_row_deleted.
func (recv *TreeModel) RowDeleted(path *TreePath) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_model_row_deleted((*C.GtkTreeModel)(recv.native), c_path)

	return
}

// RowHasChildToggled is a wrapper around the C function gtk_tree_model_row_has_child_toggled.
func (recv *TreeModel) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_model_row_has_child_toggled((*C.GtkTreeModel)(recv.native), c_path, c_iter)

	return
}

// RowInserted is a wrapper around the C function gtk_tree_model_row_inserted.
func (recv *TreeModel) RowInserted(path *TreePath, iter *TreeIter) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_model_row_inserted((*C.GtkTreeModel)(recv.native), c_path, c_iter)

	return
}

// RowsReordered is a wrapper around the C function gtk_tree_model_rows_reordered.
func (recv *TreeModel) RowsReordered(path *TreePath, iter *TreeIter, newOrder int32) {
	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_new_order := (C.gint)(newOrder)

	C.gtk_tree_model_rows_reordered((*C.GtkTreeModel)(recv.native), c_path, c_iter, &c_new_order)

	return
}

// SortNewWithModel is a wrapper around the C function gtk_tree_model_sort_new_with_model.
func (recv *TreeModel) SortNewWithModel() *TreeModel {
	retC := C.gtk_tree_model_sort_new_with_model((*C.GtkTreeModel)(recv.native))
	retGo := TreeModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// UnrefNode is a wrapper around the C function gtk_tree_model_unref_node.
func (recv *TreeModel) UnrefNode(iter *TreeIter) {
	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	C.gtk_tree_model_unref_node((*C.GtkTreeModel)(recv.native), c_iter)

	return
}

// TreeSortable is a wrapper around the C record GtkTreeSortable.
type TreeSortable struct {
	native *C.GtkTreeSortable
}

func TreeSortableNewFromC(u unsafe.Pointer) *TreeSortable {
	c := (*C.GtkTreeSortable)(u)
	if c == nil {
		return nil
	}

	g := &TreeSortable{native: c}

	return g
}

func (recv *TreeSortable) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeSortable with another TreeSortable, and returns true if they represent the same GObject.
func (recv *TreeSortable) Equals(other *TreeSortable) bool {
	return other.ToC() == recv.ToC()
}

type signalTreeSortableSortColumnChangedDetail struct {
	callback  TreeSortableSignalSortColumnChangedCallback
	handlerID C.gulong
}

var signalTreeSortableSortColumnChangedId int
var signalTreeSortableSortColumnChangedMap = make(map[int]signalTreeSortableSortColumnChangedDetail)
var signalTreeSortableSortColumnChangedLock sync.RWMutex

// TreeSortableSignalSortColumnChangedCallback is a callback function for a 'sort-column-changed' signal emitted from a TreeSortable.
type TreeSortableSignalSortColumnChangedCallback func()

/*
ConnectSortColumnChanged connects the callback to the 'sort-column-changed' signal for the TreeSortable.

The returned value represents the connection, and may be passed to DisconnectSortColumnChanged to remove it.
*/
func (recv *TreeSortable) ConnectSortColumnChanged(callback TreeSortableSignalSortColumnChangedCallback) int {
	signalTreeSortableSortColumnChangedLock.Lock()
	defer signalTreeSortableSortColumnChangedLock.Unlock()

	signalTreeSortableSortColumnChangedId++
	instance := C.gpointer(recv.native)
	handlerID := C.TreeSortable_signal_connect_sort_column_changed(instance, C.gpointer(uintptr(signalTreeSortableSortColumnChangedId)))

	detail := signalTreeSortableSortColumnChangedDetail{callback, handlerID}
	signalTreeSortableSortColumnChangedMap[signalTreeSortableSortColumnChangedId] = detail

	return signalTreeSortableSortColumnChangedId
}

/*
DisconnectSortColumnChanged disconnects a callback from the 'sort-column-changed' signal for the TreeSortable.

The connectionID should be a value returned from a call to ConnectSortColumnChanged.
*/
func (recv *TreeSortable) DisconnectSortColumnChanged(connectionID int) {
	signalTreeSortableSortColumnChangedLock.Lock()
	defer signalTreeSortableSortColumnChangedLock.Unlock()

	detail, exists := signalTreeSortableSortColumnChangedMap[connectionID]
	if !exists {
		return
	}

	instance := C.gpointer(recv.native)
	C.g_signal_handler_disconnect(instance, detail.handlerID)
	delete(signalTreeSortableSortColumnChangedMap, connectionID)
}

//export treesortable_sortColumnChangedHandler
func treesortable_sortColumnChangedHandler(_ *C.GObject, data C.gpointer) {
	signalTreeSortableSortColumnChangedLock.RLock()
	defer signalTreeSortableSortColumnChangedLock.RUnlock()

	index := int(uintptr(data))
	callback := signalTreeSortableSortColumnChangedMap[index].callback
	callback()
}

// GetSortColumnId is a wrapper around the C function gtk_tree_sortable_get_sort_column_id.
func (recv *TreeSortable) GetSortColumnId() (bool, int32, SortType) {
	var c_sort_column_id C.gint

	var c_order C.GtkSortType

	retC := C.gtk_tree_sortable_get_sort_column_id((*C.GtkTreeSortable)(recv.native), &c_sort_column_id, &c_order)
	retGo := retC == C.TRUE

	sortColumnId := (int32)(c_sort_column_id)

	order := (SortType)(c_order)

	return retGo, sortColumnId, order
}

// HasDefaultSortFunc is a wrapper around the C function gtk_tree_sortable_has_default_sort_func.
func (recv *TreeSortable) HasDefaultSortFunc() bool {
	retC := C.gtk_tree_sortable_has_default_sort_func((*C.GtkTreeSortable)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_tree_sortable_set_default_sort_func : unsupported parameter sort_func : no type generator for TreeIterCompareFunc (GtkTreeIterCompareFunc) for param sort_func

// SetSortColumnId is a wrapper around the C function gtk_tree_sortable_set_sort_column_id.
func (recv *TreeSortable) SetSortColumnId(sortColumnId int32, order SortType) {
	c_sort_column_id := (C.gint)(sortColumnId)

	c_order := (C.GtkSortType)(order)

	C.gtk_tree_sortable_set_sort_column_id((*C.GtkTreeSortable)(recv.native), c_sort_column_id, c_order)

	return
}

// Unsupported : gtk_tree_sortable_set_sort_func : unsupported parameter sort_func : no type generator for TreeIterCompareFunc (GtkTreeIterCompareFunc) for param sort_func

// SortColumnChanged is a wrapper around the C function gtk_tree_sortable_sort_column_changed.
func (recv *TreeSortable) SortColumnChanged() {
	C.gtk_tree_sortable_sort_column_changed((*C.GtkTreeSortable)(recv.native))

	return
}

// AboutDialogClass is a wrapper around the C record GtkAboutDialogClass.
type AboutDialogClass struct {
	native *C.GtkAboutDialogClass
	// parent_class : record
	// no type for activate_link
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func AboutDialogClassNewFromC(u unsafe.Pointer) *AboutDialogClass {
	c := (*C.GtkAboutDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &AboutDialogClass{native: c}

	return g
}

func (recv *AboutDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AboutDialogClass with another AboutDialogClass, and returns true if they represent the same GObject.
func (recv *AboutDialogClass) Equals(other *AboutDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// AboutDialogPrivate is a wrapper around the C record GtkAboutDialogPrivate.
type AboutDialogPrivate struct {
	native *C.GtkAboutDialogPrivate
}

func AboutDialogPrivateNewFromC(u unsafe.Pointer) *AboutDialogPrivate {
	c := (*C.GtkAboutDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AboutDialogPrivate{native: c}

	return g
}

func (recv *AboutDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AboutDialogPrivate with another AboutDialogPrivate, and returns true if they represent the same GObject.
func (recv *AboutDialogPrivate) Equals(other *AboutDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AccelGroupClass is a wrapper around the C record GtkAccelGroupClass.
type AccelGroupClass struct {
	native *C.GtkAccelGroupClass
	// parent_class : record
	// no type for accel_changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func AccelGroupClassNewFromC(u unsafe.Pointer) *AccelGroupClass {
	c := (*C.GtkAccelGroupClass)(u)
	if c == nil {
		return nil
	}

	g := &AccelGroupClass{native: c}

	return g
}

func (recv *AccelGroupClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelGroupClass with another AccelGroupClass, and returns true if they represent the same GObject.
func (recv *AccelGroupClass) Equals(other *AccelGroupClass) bool {
	return other.ToC() == recv.ToC()
}

// AccelGroupEntry is a wrapper around the C record GtkAccelGroupEntry.
type AccelGroupEntry struct {
	native *C.GtkAccelGroupEntry
	// key : record
	// closure : record
	AccelPathQuark glib.Quark
}

func AccelGroupEntryNewFromC(u unsafe.Pointer) *AccelGroupEntry {
	c := (*C.GtkAccelGroupEntry)(u)
	if c == nil {
		return nil
	}

	g := &AccelGroupEntry{
		AccelPathQuark: (glib.Quark)(c.accel_path_quark),
		native:         c,
	}

	return g
}

func (recv *AccelGroupEntry) ToC() unsafe.Pointer {
	recv.native.accel_path_quark =
		(C.GQuark)(recv.AccelPathQuark)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelGroupEntry with another AccelGroupEntry, and returns true if they represent the same GObject.
func (recv *AccelGroupEntry) Equals(other *AccelGroupEntry) bool {
	return other.ToC() == recv.ToC()
}

// AccelGroupPrivate is a wrapper around the C record GtkAccelGroupPrivate.
type AccelGroupPrivate struct {
	native *C.GtkAccelGroupPrivate
}

func AccelGroupPrivateNewFromC(u unsafe.Pointer) *AccelGroupPrivate {
	c := (*C.GtkAccelGroupPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AccelGroupPrivate{native: c}

	return g
}

func (recv *AccelGroupPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelGroupPrivate with another AccelGroupPrivate, and returns true if they represent the same GObject.
func (recv *AccelGroupPrivate) Equals(other *AccelGroupPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AccelKey is a wrapper around the C record GtkAccelKey.
type AccelKey struct {
	native    *C.GtkAccelKey
	AccelKey  uint32
	AccelMods gdk.ModifierType
	// Bitfield not supported : 16 accel_flags
}

func AccelKeyNewFromC(u unsafe.Pointer) *AccelKey {
	c := (*C.GtkAccelKey)(u)
	if c == nil {
		return nil
	}

	g := &AccelKey{
		AccelKey:  (uint32)(c.accel_key),
		AccelMods: (gdk.ModifierType)(c.accel_mods),
		native:    c,
	}

	return g
}

func (recv *AccelKey) ToC() unsafe.Pointer {
	recv.native.accel_key =
		(C.guint)(recv.AccelKey)
	recv.native.accel_mods =
		(C.GdkModifierType)(recv.AccelMods)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelKey with another AccelKey, and returns true if they represent the same GObject.
func (recv *AccelKey) Equals(other *AccelKey) bool {
	return other.ToC() == recv.ToC()
}

// AccelLabelClass is a wrapper around the C record GtkAccelLabelClass.
type AccelLabelClass struct {
	native *C.GtkAccelLabelClass
	// parent_class : record
	SignalQuote1   string
	SignalQuote2   string
	ModNameShift   string
	ModNameControl string
	ModNameAlt     string
	ModSeparator   string
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func AccelLabelClassNewFromC(u unsafe.Pointer) *AccelLabelClass {
	c := (*C.GtkAccelLabelClass)(u)
	if c == nil {
		return nil
	}

	g := &AccelLabelClass{
		ModNameAlt:     C.GoString(c.mod_name_alt),
		ModNameControl: C.GoString(c.mod_name_control),
		ModNameShift:   C.GoString(c.mod_name_shift),
		ModSeparator:   C.GoString(c.mod_separator),
		SignalQuote1:   C.GoString(c.signal_quote1),
		SignalQuote2:   C.GoString(c.signal_quote2),
		native:         c,
	}

	return g
}

func (recv *AccelLabelClass) ToC() unsafe.Pointer {
	recv.native.signal_quote1 =
		C.CString(recv.SignalQuote1)
	recv.native.signal_quote2 =
		C.CString(recv.SignalQuote2)
	recv.native.mod_name_shift =
		C.CString(recv.ModNameShift)
	recv.native.mod_name_control =
		C.CString(recv.ModNameControl)
	recv.native.mod_name_alt =
		C.CString(recv.ModNameAlt)
	recv.native.mod_separator =
		C.CString(recv.ModSeparator)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelLabelClass with another AccelLabelClass, and returns true if they represent the same GObject.
func (recv *AccelLabelClass) Equals(other *AccelLabelClass) bool {
	return other.ToC() == recv.ToC()
}

// AccelLabelPrivate is a wrapper around the C record GtkAccelLabelPrivate.
type AccelLabelPrivate struct {
	native *C.GtkAccelLabelPrivate
}

func AccelLabelPrivateNewFromC(u unsafe.Pointer) *AccelLabelPrivate {
	c := (*C.GtkAccelLabelPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AccelLabelPrivate{native: c}

	return g
}

func (recv *AccelLabelPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelLabelPrivate with another AccelLabelPrivate, and returns true if they represent the same GObject.
func (recv *AccelLabelPrivate) Equals(other *AccelLabelPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AccelMapClass is a wrapper around the C record GtkAccelMapClass.
type AccelMapClass struct {
	native *C.GtkAccelMapClass
}

func AccelMapClassNewFromC(u unsafe.Pointer) *AccelMapClass {
	c := (*C.GtkAccelMapClass)(u)
	if c == nil {
		return nil
	}

	g := &AccelMapClass{native: c}

	return g
}

func (recv *AccelMapClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccelMapClass with another AccelMapClass, and returns true if they represent the same GObject.
func (recv *AccelMapClass) Equals(other *AccelMapClass) bool {
	return other.ToC() == recv.ToC()
}

// AccessibleClass is a wrapper around the C record GtkAccessibleClass.
type AccessibleClass struct {
	native *C.GtkAccessibleClass
	// parent_class : record
	// no type for connect_widget_destroyed
	// no type for widget_set
	// no type for widget_unset
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func AccessibleClassNewFromC(u unsafe.Pointer) *AccessibleClass {
	c := (*C.GtkAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &AccessibleClass{native: c}

	return g
}

func (recv *AccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccessibleClass with another AccessibleClass, and returns true if they represent the same GObject.
func (recv *AccessibleClass) Equals(other *AccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// AccessiblePrivate is a wrapper around the C record GtkAccessiblePrivate.
type AccessiblePrivate struct {
	native *C.GtkAccessiblePrivate
}

func AccessiblePrivateNewFromC(u unsafe.Pointer) *AccessiblePrivate {
	c := (*C.GtkAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &AccessiblePrivate{native: c}

	return g
}

func (recv *AccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AccessiblePrivate with another AccessiblePrivate, and returns true if they represent the same GObject.
func (recv *AccessiblePrivate) Equals(other *AccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ActionBarClass is a wrapper around the C record GtkActionBarClass.
type ActionBarClass struct {
	native *C.GtkActionBarClass
	// Private : parent_class
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ActionBarClassNewFromC(u unsafe.Pointer) *ActionBarClass {
	c := (*C.GtkActionBarClass)(u)
	if c == nil {
		return nil
	}

	g := &ActionBarClass{native: c}

	return g
}

func (recv *ActionBarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionBarClass with another ActionBarClass, and returns true if they represent the same GObject.
func (recv *ActionBarClass) Equals(other *ActionBarClass) bool {
	return other.ToC() == recv.ToC()
}

// ActionBarPrivate is a wrapper around the C record GtkActionBarPrivate.
type ActionBarPrivate struct {
	native *C.GtkActionBarPrivate
}

func ActionBarPrivateNewFromC(u unsafe.Pointer) *ActionBarPrivate {
	c := (*C.GtkActionBarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ActionBarPrivate{native: c}

	return g
}

func (recv *ActionBarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionBarPrivate with another ActionBarPrivate, and returns true if they represent the same GObject.
func (recv *ActionBarPrivate) Equals(other *ActionBarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ActionClass is a wrapper around the C record GtkActionClass.
type ActionClass struct {
	native *C.GtkActionClass
	// parent_class : record
	// no type for activate
	// Private : menu_item_type
	// Private : toolbar_item_type
	// no type for create_menu_item
	// no type for create_tool_item
	// no type for connect_proxy
	// no type for disconnect_proxy
	// no type for create_menu
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ActionClassNewFromC(u unsafe.Pointer) *ActionClass {
	c := (*C.GtkActionClass)(u)
	if c == nil {
		return nil
	}

	g := &ActionClass{native: c}

	return g
}

func (recv *ActionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionClass with another ActionClass, and returns true if they represent the same GObject.
func (recv *ActionClass) Equals(other *ActionClass) bool {
	return other.ToC() == recv.ToC()
}

// ActionEntry is a wrapper around the C record GtkActionEntry.
type ActionEntry struct {
	native      *C.GtkActionEntry
	Name        string
	StockId     string
	Label       string
	Accelerator string
	Tooltip     string
	// callback : no type generator for GObject.Callback, GCallback
}

func ActionEntryNewFromC(u unsafe.Pointer) *ActionEntry {
	c := (*C.GtkActionEntry)(u)
	if c == nil {
		return nil
	}

	g := &ActionEntry{
		Accelerator: C.GoString(c.accelerator),
		Label:       C.GoString(c.label),
		Name:        C.GoString(c.name),
		StockId:     C.GoString(c.stock_id),
		Tooltip:     C.GoString(c.tooltip),
		native:      c,
	}

	return g
}

func (recv *ActionEntry) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native.stock_id =
		C.CString(recv.StockId)
	recv.native.label =
		C.CString(recv.Label)
	recv.native.accelerator =
		C.CString(recv.Accelerator)
	recv.native.tooltip =
		C.CString(recv.Tooltip)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionEntry with another ActionEntry, and returns true if they represent the same GObject.
func (recv *ActionEntry) Equals(other *ActionEntry) bool {
	return other.ToC() == recv.ToC()
}

// ActionGroupClass is a wrapper around the C record GtkActionGroupClass.
type ActionGroupClass struct {
	native *C.GtkActionGroupClass
	// parent_class : record
	// no type for get_action
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ActionGroupClassNewFromC(u unsafe.Pointer) *ActionGroupClass {
	c := (*C.GtkActionGroupClass)(u)
	if c == nil {
		return nil
	}

	g := &ActionGroupClass{native: c}

	return g
}

func (recv *ActionGroupClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionGroupClass with another ActionGroupClass, and returns true if they represent the same GObject.
func (recv *ActionGroupClass) Equals(other *ActionGroupClass) bool {
	return other.ToC() == recv.ToC()
}

// ActionGroupPrivate is a wrapper around the C record GtkActionGroupPrivate.
type ActionGroupPrivate struct {
	native *C.GtkActionGroupPrivate
}

func ActionGroupPrivateNewFromC(u unsafe.Pointer) *ActionGroupPrivate {
	c := (*C.GtkActionGroupPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ActionGroupPrivate{native: c}

	return g
}

func (recv *ActionGroupPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionGroupPrivate with another ActionGroupPrivate, and returns true if they represent the same GObject.
func (recv *ActionGroupPrivate) Equals(other *ActionGroupPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ActionPrivate is a wrapper around the C record GtkActionPrivate.
type ActionPrivate struct {
	native *C.GtkActionPrivate
}

func ActionPrivateNewFromC(u unsafe.Pointer) *ActionPrivate {
	c := (*C.GtkActionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ActionPrivate{native: c}

	return g
}

func (recv *ActionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionPrivate with another ActionPrivate, and returns true if they represent the same GObject.
func (recv *ActionPrivate) Equals(other *ActionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ActionableInterface is a wrapper around the C record GtkActionableInterface.
type ActionableInterface struct {
	native *C.GtkActionableInterface
	// Private : g_iface
	// no type for get_action_name
	// no type for set_action_name
	// no type for get_action_target_value
	// no type for set_action_target_value
}

func ActionableInterfaceNewFromC(u unsafe.Pointer) *ActionableInterface {
	c := (*C.GtkActionableInterface)(u)
	if c == nil {
		return nil
	}

	g := &ActionableInterface{native: c}

	return g
}

func (recv *ActionableInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ActionableInterface with another ActionableInterface, and returns true if they represent the same GObject.
func (recv *ActionableInterface) Equals(other *ActionableInterface) bool {
	return other.ToC() == recv.ToC()
}

// AdjustmentClass is a wrapper around the C record GtkAdjustmentClass.
type AdjustmentClass struct {
	native *C.GtkAdjustmentClass
	// parent_class : record
	// no type for changed
	// no type for value_changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func AdjustmentClassNewFromC(u unsafe.Pointer) *AdjustmentClass {
	c := (*C.GtkAdjustmentClass)(u)
	if c == nil {
		return nil
	}

	g := &AdjustmentClass{native: c}

	return g
}

func (recv *AdjustmentClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AdjustmentClass with another AdjustmentClass, and returns true if they represent the same GObject.
func (recv *AdjustmentClass) Equals(other *AdjustmentClass) bool {
	return other.ToC() == recv.ToC()
}

// AdjustmentPrivate is a wrapper around the C record GtkAdjustmentPrivate.
type AdjustmentPrivate struct {
	native *C.GtkAdjustmentPrivate
}

func AdjustmentPrivateNewFromC(u unsafe.Pointer) *AdjustmentPrivate {
	c := (*C.GtkAdjustmentPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AdjustmentPrivate{native: c}

	return g
}

func (recv *AdjustmentPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AdjustmentPrivate with another AdjustmentPrivate, and returns true if they represent the same GObject.
func (recv *AdjustmentPrivate) Equals(other *AdjustmentPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AlignmentClass is a wrapper around the C record GtkAlignmentClass.
type AlignmentClass struct {
	native *C.GtkAlignmentClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func AlignmentClassNewFromC(u unsafe.Pointer) *AlignmentClass {
	c := (*C.GtkAlignmentClass)(u)
	if c == nil {
		return nil
	}

	g := &AlignmentClass{native: c}

	return g
}

func (recv *AlignmentClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AlignmentClass with another AlignmentClass, and returns true if they represent the same GObject.
func (recv *AlignmentClass) Equals(other *AlignmentClass) bool {
	return other.ToC() == recv.ToC()
}

// AlignmentPrivate is a wrapper around the C record GtkAlignmentPrivate.
type AlignmentPrivate struct {
	native *C.GtkAlignmentPrivate
}

func AlignmentPrivateNewFromC(u unsafe.Pointer) *AlignmentPrivate {
	c := (*C.GtkAlignmentPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AlignmentPrivate{native: c}

	return g
}

func (recv *AlignmentPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AlignmentPrivate with another AlignmentPrivate, and returns true if they represent the same GObject.
func (recv *AlignmentPrivate) Equals(other *AlignmentPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AppChooserButtonClass is a wrapper around the C record GtkAppChooserButtonClass.
type AppChooserButtonClass struct {
	native *C.GtkAppChooserButtonClass
	// parent_class : record
	// no type for custom_item_activated
	// Private : padding
}

func AppChooserButtonClassNewFromC(u unsafe.Pointer) *AppChooserButtonClass {
	c := (*C.GtkAppChooserButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserButtonClass{native: c}

	return g
}

func (recv *AppChooserButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserButtonClass with another AppChooserButtonClass, and returns true if they represent the same GObject.
func (recv *AppChooserButtonClass) Equals(other *AppChooserButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// AppChooserButtonPrivate is a wrapper around the C record GtkAppChooserButtonPrivate.
type AppChooserButtonPrivate struct {
	native *C.GtkAppChooserButtonPrivate
}

func AppChooserButtonPrivateNewFromC(u unsafe.Pointer) *AppChooserButtonPrivate {
	c := (*C.GtkAppChooserButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserButtonPrivate{native: c}

	return g
}

func (recv *AppChooserButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserButtonPrivate with another AppChooserButtonPrivate, and returns true if they represent the same GObject.
func (recv *AppChooserButtonPrivate) Equals(other *AppChooserButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AppChooserDialogClass is a wrapper around the C record GtkAppChooserDialogClass.
type AppChooserDialogClass struct {
	native *C.GtkAppChooserDialogClass
	// parent_class : record
	// Private : padding
}

func AppChooserDialogClassNewFromC(u unsafe.Pointer) *AppChooserDialogClass {
	c := (*C.GtkAppChooserDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserDialogClass{native: c}

	return g
}

func (recv *AppChooserDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserDialogClass with another AppChooserDialogClass, and returns true if they represent the same GObject.
func (recv *AppChooserDialogClass) Equals(other *AppChooserDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// AppChooserDialogPrivate is a wrapper around the C record GtkAppChooserDialogPrivate.
type AppChooserDialogPrivate struct {
	native *C.GtkAppChooserDialogPrivate
}

func AppChooserDialogPrivateNewFromC(u unsafe.Pointer) *AppChooserDialogPrivate {
	c := (*C.GtkAppChooserDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserDialogPrivate{native: c}

	return g
}

func (recv *AppChooserDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserDialogPrivate with another AppChooserDialogPrivate, and returns true if they represent the same GObject.
func (recv *AppChooserDialogPrivate) Equals(other *AppChooserDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AppChooserWidgetClass is a wrapper around the C record GtkAppChooserWidgetClass.
type AppChooserWidgetClass struct {
	native *C.GtkAppChooserWidgetClass
	// parent_class : record
	// no type for application_selected
	// no type for application_activated
	// no type for populate_popup
	// Private : padding
}

func AppChooserWidgetClassNewFromC(u unsafe.Pointer) *AppChooserWidgetClass {
	c := (*C.GtkAppChooserWidgetClass)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserWidgetClass{native: c}

	return g
}

func (recv *AppChooserWidgetClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserWidgetClass with another AppChooserWidgetClass, and returns true if they represent the same GObject.
func (recv *AppChooserWidgetClass) Equals(other *AppChooserWidgetClass) bool {
	return other.ToC() == recv.ToC()
}

// AppChooserWidgetPrivate is a wrapper around the C record GtkAppChooserWidgetPrivate.
type AppChooserWidgetPrivate struct {
	native *C.GtkAppChooserWidgetPrivate
}

func AppChooserWidgetPrivateNewFromC(u unsafe.Pointer) *AppChooserWidgetPrivate {
	c := (*C.GtkAppChooserWidgetPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AppChooserWidgetPrivate{native: c}

	return g
}

func (recv *AppChooserWidgetPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AppChooserWidgetPrivate with another AppChooserWidgetPrivate, and returns true if they represent the same GObject.
func (recv *AppChooserWidgetPrivate) Equals(other *AppChooserWidgetPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ApplicationClass is a wrapper around the C record GtkApplicationClass.
type ApplicationClass struct {
	native *C.GtkApplicationClass
	// parent_class : record
	// no type for window_added
	// no type for window_removed
	// Private : padding
}

func ApplicationClassNewFromC(u unsafe.Pointer) *ApplicationClass {
	c := (*C.GtkApplicationClass)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationClass{native: c}

	return g
}

func (recv *ApplicationClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationClass with another ApplicationClass, and returns true if they represent the same GObject.
func (recv *ApplicationClass) Equals(other *ApplicationClass) bool {
	return other.ToC() == recv.ToC()
}

// ApplicationPrivate is a wrapper around the C record GtkApplicationPrivate.
type ApplicationPrivate struct {
	native *C.GtkApplicationPrivate
}

func ApplicationPrivateNewFromC(u unsafe.Pointer) *ApplicationPrivate {
	c := (*C.GtkApplicationPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationPrivate{native: c}

	return g
}

func (recv *ApplicationPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationPrivate with another ApplicationPrivate, and returns true if they represent the same GObject.
func (recv *ApplicationPrivate) Equals(other *ApplicationPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ApplicationWindowClass is a wrapper around the C record GtkApplicationWindowClass.
type ApplicationWindowClass struct {
	native *C.GtkApplicationWindowClass
	// parent_class : record
	// Private : padding
}

func ApplicationWindowClassNewFromC(u unsafe.Pointer) *ApplicationWindowClass {
	c := (*C.GtkApplicationWindowClass)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationWindowClass{native: c}

	return g
}

func (recv *ApplicationWindowClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationWindowClass with another ApplicationWindowClass, and returns true if they represent the same GObject.
func (recv *ApplicationWindowClass) Equals(other *ApplicationWindowClass) bool {
	return other.ToC() == recv.ToC()
}

// ApplicationWindowPrivate is a wrapper around the C record GtkApplicationWindowPrivate.
type ApplicationWindowPrivate struct {
	native *C.GtkApplicationWindowPrivate
}

func ApplicationWindowPrivateNewFromC(u unsafe.Pointer) *ApplicationWindowPrivate {
	c := (*C.GtkApplicationWindowPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ApplicationWindowPrivate{native: c}

	return g
}

func (recv *ApplicationWindowPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ApplicationWindowPrivate with another ApplicationWindowPrivate, and returns true if they represent the same GObject.
func (recv *ApplicationWindowPrivate) Equals(other *ApplicationWindowPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ArrowAccessibleClass is a wrapper around the C record GtkArrowAccessibleClass.
type ArrowAccessibleClass struct {
	native *C.GtkArrowAccessibleClass
	// parent_class : record
}

func ArrowAccessibleClassNewFromC(u unsafe.Pointer) *ArrowAccessibleClass {
	c := (*C.GtkArrowAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ArrowAccessibleClass{native: c}

	return g
}

func (recv *ArrowAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ArrowAccessibleClass with another ArrowAccessibleClass, and returns true if they represent the same GObject.
func (recv *ArrowAccessibleClass) Equals(other *ArrowAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ArrowAccessiblePrivate is a wrapper around the C record GtkArrowAccessiblePrivate.
type ArrowAccessiblePrivate struct {
	native *C.GtkArrowAccessiblePrivate
}

func ArrowAccessiblePrivateNewFromC(u unsafe.Pointer) *ArrowAccessiblePrivate {
	c := (*C.GtkArrowAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ArrowAccessiblePrivate{native: c}

	return g
}

func (recv *ArrowAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ArrowAccessiblePrivate with another ArrowAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ArrowAccessiblePrivate) Equals(other *ArrowAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ArrowClass is a wrapper around the C record GtkArrowClass.
type ArrowClass struct {
	native *C.GtkArrowClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ArrowClassNewFromC(u unsafe.Pointer) *ArrowClass {
	c := (*C.GtkArrowClass)(u)
	if c == nil {
		return nil
	}

	g := &ArrowClass{native: c}

	return g
}

func (recv *ArrowClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ArrowClass with another ArrowClass, and returns true if they represent the same GObject.
func (recv *ArrowClass) Equals(other *ArrowClass) bool {
	return other.ToC() == recv.ToC()
}

// ArrowPrivate is a wrapper around the C record GtkArrowPrivate.
type ArrowPrivate struct {
	native *C.GtkArrowPrivate
}

func ArrowPrivateNewFromC(u unsafe.Pointer) *ArrowPrivate {
	c := (*C.GtkArrowPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ArrowPrivate{native: c}

	return g
}

func (recv *ArrowPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ArrowPrivate with another ArrowPrivate, and returns true if they represent the same GObject.
func (recv *ArrowPrivate) Equals(other *ArrowPrivate) bool {
	return other.ToC() == recv.ToC()
}

// AspectFrameClass is a wrapper around the C record GtkAspectFrameClass.
type AspectFrameClass struct {
	native *C.GtkAspectFrameClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func AspectFrameClassNewFromC(u unsafe.Pointer) *AspectFrameClass {
	c := (*C.GtkAspectFrameClass)(u)
	if c == nil {
		return nil
	}

	g := &AspectFrameClass{native: c}

	return g
}

func (recv *AspectFrameClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AspectFrameClass with another AspectFrameClass, and returns true if they represent the same GObject.
func (recv *AspectFrameClass) Equals(other *AspectFrameClass) bool {
	return other.ToC() == recv.ToC()
}

// AspectFramePrivate is a wrapper around the C record GtkAspectFramePrivate.
type AspectFramePrivate struct {
	native *C.GtkAspectFramePrivate
}

func AspectFramePrivateNewFromC(u unsafe.Pointer) *AspectFramePrivate {
	c := (*C.GtkAspectFramePrivate)(u)
	if c == nil {
		return nil
	}

	g := &AspectFramePrivate{native: c}

	return g
}

func (recv *AspectFramePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AspectFramePrivate with another AspectFramePrivate, and returns true if they represent the same GObject.
func (recv *AspectFramePrivate) Equals(other *AspectFramePrivate) bool {
	return other.ToC() == recv.ToC()
}

// AssistantClass is a wrapper around the C record GtkAssistantClass.
type AssistantClass struct {
	native *C.GtkAssistantClass
	// parent_class : record
	// no type for prepare
	// no type for apply
	// no type for close
	// no type for cancel
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
}

func AssistantClassNewFromC(u unsafe.Pointer) *AssistantClass {
	c := (*C.GtkAssistantClass)(u)
	if c == nil {
		return nil
	}

	g := &AssistantClass{native: c}

	return g
}

func (recv *AssistantClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AssistantClass with another AssistantClass, and returns true if they represent the same GObject.
func (recv *AssistantClass) Equals(other *AssistantClass) bool {
	return other.ToC() == recv.ToC()
}

// AssistantPrivate is a wrapper around the C record GtkAssistantPrivate.
type AssistantPrivate struct {
	native *C.GtkAssistantPrivate
}

func AssistantPrivateNewFromC(u unsafe.Pointer) *AssistantPrivate {
	c := (*C.GtkAssistantPrivate)(u)
	if c == nil {
		return nil
	}

	g := &AssistantPrivate{native: c}

	return g
}

func (recv *AssistantPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this AssistantPrivate with another AssistantPrivate, and returns true if they represent the same GObject.
func (recv *AssistantPrivate) Equals(other *AssistantPrivate) bool {
	return other.ToC() == recv.ToC()
}

// BinClass is a wrapper around the C record GtkBinClass.
type BinClass struct {
	native *C.GtkBinClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func BinClassNewFromC(u unsafe.Pointer) *BinClass {
	c := (*C.GtkBinClass)(u)
	if c == nil {
		return nil
	}

	g := &BinClass{native: c}

	return g
}

func (recv *BinClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BinClass with another BinClass, and returns true if they represent the same GObject.
func (recv *BinClass) Equals(other *BinClass) bool {
	return other.ToC() == recv.ToC()
}

// BinPrivate is a wrapper around the C record GtkBinPrivate.
type BinPrivate struct {
	native *C.GtkBinPrivate
}

func BinPrivateNewFromC(u unsafe.Pointer) *BinPrivate {
	c := (*C.GtkBinPrivate)(u)
	if c == nil {
		return nil
	}

	g := &BinPrivate{native: c}

	return g
}

func (recv *BinPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BinPrivate with another BinPrivate, and returns true if they represent the same GObject.
func (recv *BinPrivate) Equals(other *BinPrivate) bool {
	return other.ToC() == recv.ToC()
}

// BindingArg is a wrapper around the C record GtkBindingArg.
type BindingArg struct {
	native  *C.GtkBindingArg
	ArgType gobject.Type
}

func BindingArgNewFromC(u unsafe.Pointer) *BindingArg {
	c := (*C.GtkBindingArg)(u)
	if c == nil {
		return nil
	}

	g := &BindingArg{
		ArgType: (gobject.Type)(c.arg_type),
		native:  c,
	}

	return g
}

func (recv *BindingArg) ToC() unsafe.Pointer {
	recv.native.arg_type =
		(C.GType)(recv.ArgType)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BindingArg with another BindingArg, and returns true if they represent the same GObject.
func (recv *BindingArg) Equals(other *BindingArg) bool {
	return other.ToC() == recv.ToC()
}

// BindingEntry is a wrapper around the C record GtkBindingEntry.
type BindingEntry struct {
	native    *C.GtkBindingEntry
	Keyval    uint32
	Modifiers gdk.ModifierType
	// binding_set : record
	// Bitfield not supported :  1 destroyed
	// Bitfield not supported :  1 in_emission
	// Bitfield not supported :  1 marks_unbound
	// set_next : record
	// hash_next : record
	// signals : record
}

func BindingEntryNewFromC(u unsafe.Pointer) *BindingEntry {
	c := (*C.GtkBindingEntry)(u)
	if c == nil {
		return nil
	}

	g := &BindingEntry{
		Keyval:    (uint32)(c.keyval),
		Modifiers: (gdk.ModifierType)(c.modifiers),
		native:    c,
	}

	return g
}

func (recv *BindingEntry) ToC() unsafe.Pointer {
	recv.native.keyval =
		(C.guint)(recv.Keyval)
	recv.native.modifiers =
		(C.GdkModifierType)(recv.Modifiers)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BindingEntry with another BindingEntry, and returns true if they represent the same GObject.
func (recv *BindingEntry) Equals(other *BindingEntry) bool {
	return other.ToC() == recv.ToC()
}

// gtk_binding_entry_add_signal : unsupported parameter ... : varargs
// BindingEntryAddSignall is a wrapper around the C function gtk_binding_entry_add_signall.
func BindingEntryAddSignall(bindingSet *BindingSet, keyval uint32, modifiers gdk.ModifierType, signalName string, bindingArgs *glib.SList) {
	c_binding_set := (*C.GtkBindingSet)(C.NULL)
	if bindingSet != nil {
		c_binding_set = (*C.GtkBindingSet)(bindingSet.ToC())
	}

	c_keyval := (C.guint)(keyval)

	c_modifiers := (C.GdkModifierType)(modifiers)

	c_signal_name := C.CString(signalName)
	defer C.free(unsafe.Pointer(c_signal_name))

	c_binding_args := (*C.GSList)(C.NULL)
	if bindingArgs != nil {
		c_binding_args = (*C.GSList)(bindingArgs.ToC())
	}

	C.gtk_binding_entry_add_signall(c_binding_set, c_keyval, c_modifiers, c_signal_name, c_binding_args)

	return
}

// BindingEntryRemove is a wrapper around the C function gtk_binding_entry_remove.
func BindingEntryRemove(bindingSet *BindingSet, keyval uint32, modifiers gdk.ModifierType) {
	c_binding_set := (*C.GtkBindingSet)(C.NULL)
	if bindingSet != nil {
		c_binding_set = (*C.GtkBindingSet)(bindingSet.ToC())
	}

	c_keyval := (C.guint)(keyval)

	c_modifiers := (C.GdkModifierType)(modifiers)

	C.gtk_binding_entry_remove(c_binding_set, c_keyval, c_modifiers)

	return
}

// BindingEntrySkip is a wrapper around the C function gtk_binding_entry_skip.
func BindingEntrySkip(bindingSet *BindingSet, keyval uint32, modifiers gdk.ModifierType) {
	c_binding_set := (*C.GtkBindingSet)(C.NULL)
	if bindingSet != nil {
		c_binding_set = (*C.GtkBindingSet)(bindingSet.ToC())
	}

	c_keyval := (C.guint)(keyval)

	c_modifiers := (C.GdkModifierType)(modifiers)

	C.gtk_binding_entry_skip(c_binding_set, c_keyval, c_modifiers)

	return
}

// BindingSet is a wrapper around the C record GtkBindingSet.
type BindingSet struct {
	native   *C.GtkBindingSet
	SetName  string
	Priority int32
	// widget_path_pspecs : record
	// widget_class_pspecs : record
	// class_branch_pspecs : record
	// entries : record
	// current : record
	// Bitfield not supported :  1 parsed
}

func BindingSetNewFromC(u unsafe.Pointer) *BindingSet {
	c := (*C.GtkBindingSet)(u)
	if c == nil {
		return nil
	}

	g := &BindingSet{
		Priority: (int32)(c.priority),
		SetName:  C.GoString(c.set_name),
		native:   c,
	}

	return g
}

func (recv *BindingSet) ToC() unsafe.Pointer {
	recv.native.set_name =
		C.CString(recv.SetName)
	recv.native.priority =
		(C.gint)(recv.Priority)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BindingSet with another BindingSet, and returns true if they represent the same GObject.
func (recv *BindingSet) Equals(other *BindingSet) bool {
	return other.ToC() == recv.ToC()
}

// BindingSetByClass is a wrapper around the C function gtk_binding_set_by_class.
func BindingSetByClass(objectClass uintptr) *BindingSet {
	c_object_class := (C.gpointer)(objectClass)

	retC := C.gtk_binding_set_by_class(c_object_class)
	retGo := BindingSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// BindingSetFind is a wrapper around the C function gtk_binding_set_find.
func BindingSetFind(setName string) *BindingSet {
	c_set_name := C.CString(setName)
	defer C.free(unsafe.Pointer(c_set_name))

	retC := C.gtk_binding_set_find(c_set_name)
	var retGo (*BindingSet)
	if retC == nil {
		retGo = nil
	} else {
		retGo = BindingSetNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// BindingSetNew is a wrapper around the C function gtk_binding_set_new.
func BindingSetNew(setName string) *BindingSet {
	c_set_name := C.CString(setName)
	defer C.free(unsafe.Pointer(c_set_name))

	retC := C.gtk_binding_set_new(c_set_name)
	retGo := BindingSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Activate is a wrapper around the C function gtk_binding_set_activate.
func (recv *BindingSet) Activate(keyval uint32, modifiers gdk.ModifierType, object *gobject.Object) bool {
	c_keyval := (C.guint)(keyval)

	c_modifiers := (C.GdkModifierType)(modifiers)

	c_object := (*C.GObject)(C.NULL)
	if object != nil {
		c_object = (*C.GObject)(object.ToC())
	}

	retC := C.gtk_binding_set_activate((*C.GtkBindingSet)(recv.native), c_keyval, c_modifiers, c_object)
	retGo := retC == C.TRUE

	return retGo
}

// AddPath is a wrapper around the C function gtk_binding_set_add_path.
func (recv *BindingSet) AddPath(pathType PathType, pathPattern string, priority PathPriorityType) {
	c_path_type := (C.GtkPathType)(pathType)

	c_path_pattern := C.CString(pathPattern)
	defer C.free(unsafe.Pointer(c_path_pattern))

	c_priority := (C.GtkPathPriorityType)(priority)

	C.gtk_binding_set_add_path((*C.GtkBindingSet)(recv.native), c_path_type, c_path_pattern, c_priority)

	return
}

// BindingSignal is a wrapper around the C record GtkBindingSignal.
type BindingSignal struct {
	native *C.GtkBindingSignal
	// next : record
	SignalName string
	NArgs      uint32
	// no type for args
}

func BindingSignalNewFromC(u unsafe.Pointer) *BindingSignal {
	c := (*C.GtkBindingSignal)(u)
	if c == nil {
		return nil
	}

	g := &BindingSignal{
		NArgs:      (uint32)(c.n_args),
		SignalName: C.GoString(c.signal_name),
		native:     c,
	}

	return g
}

func (recv *BindingSignal) ToC() unsafe.Pointer {
	recv.native.signal_name =
		C.CString(recv.SignalName)
	recv.native.n_args =
		(C.guint)(recv.NArgs)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BindingSignal with another BindingSignal, and returns true if they represent the same GObject.
func (recv *BindingSignal) Equals(other *BindingSignal) bool {
	return other.ToC() == recv.ToC()
}

// BooleanCellAccessibleClass is a wrapper around the C record GtkBooleanCellAccessibleClass.
type BooleanCellAccessibleClass struct {
	native *C.GtkBooleanCellAccessibleClass
	// parent_class : record
}

func BooleanCellAccessibleClassNewFromC(u unsafe.Pointer) *BooleanCellAccessibleClass {
	c := (*C.GtkBooleanCellAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &BooleanCellAccessibleClass{native: c}

	return g
}

func (recv *BooleanCellAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BooleanCellAccessibleClass with another BooleanCellAccessibleClass, and returns true if they represent the same GObject.
func (recv *BooleanCellAccessibleClass) Equals(other *BooleanCellAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// BooleanCellAccessiblePrivate is a wrapper around the C record GtkBooleanCellAccessiblePrivate.
type BooleanCellAccessiblePrivate struct {
	native *C.GtkBooleanCellAccessiblePrivate
}

func BooleanCellAccessiblePrivateNewFromC(u unsafe.Pointer) *BooleanCellAccessiblePrivate {
	c := (*C.GtkBooleanCellAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &BooleanCellAccessiblePrivate{native: c}

	return g
}

func (recv *BooleanCellAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BooleanCellAccessiblePrivate with another BooleanCellAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *BooleanCellAccessiblePrivate) Equals(other *BooleanCellAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// Border is a wrapper around the C record GtkBorder.
type Border struct {
	native *C.GtkBorder
	Left   int16
	Right  int16
	Top    int16
	Bottom int16
}

func BorderNewFromC(u unsafe.Pointer) *Border {
	c := (*C.GtkBorder)(u)
	if c == nil {
		return nil
	}

	g := &Border{
		Bottom: (int16)(c.bottom),
		Left:   (int16)(c.left),
		Right:  (int16)(c.right),
		Top:    (int16)(c.top),
		native: c,
	}

	return g
}

func (recv *Border) ToC() unsafe.Pointer {
	recv.native.left =
		(C.gint16)(recv.Left)
	recv.native.right =
		(C.gint16)(recv.Right)
	recv.native.top =
		(C.gint16)(recv.Top)
	recv.native.bottom =
		(C.gint16)(recv.Bottom)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Border with another Border, and returns true if they represent the same GObject.
func (recv *Border) Equals(other *Border) bool {
	return other.ToC() == recv.ToC()
}

// Copy is a wrapper around the C function gtk_border_copy.
func (recv *Border) Copy() *Border {
	retC := C.gtk_border_copy((*C.GtkBorder)(recv.native))
	retGo := BorderNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_border_free.
func (recv *Border) Free() {
	C.gtk_border_free((*C.GtkBorder)(recv.native))

	return
}

// BoxClass is a wrapper around the C record GtkBoxClass.
type BoxClass struct {
	native *C.GtkBoxClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func BoxClassNewFromC(u unsafe.Pointer) *BoxClass {
	c := (*C.GtkBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &BoxClass{native: c}

	return g
}

func (recv *BoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BoxClass with another BoxClass, and returns true if they represent the same GObject.
func (recv *BoxClass) Equals(other *BoxClass) bool {
	return other.ToC() == recv.ToC()
}

// BoxPrivate is a wrapper around the C record GtkBoxPrivate.
type BoxPrivate struct {
	native *C.GtkBoxPrivate
}

func BoxPrivateNewFromC(u unsafe.Pointer) *BoxPrivate {
	c := (*C.GtkBoxPrivate)(u)
	if c == nil {
		return nil
	}

	g := &BoxPrivate{native: c}

	return g
}

func (recv *BoxPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BoxPrivate with another BoxPrivate, and returns true if they represent the same GObject.
func (recv *BoxPrivate) Equals(other *BoxPrivate) bool {
	return other.ToC() == recv.ToC()
}

// BuildableIface is a wrapper around the C record GtkBuildableIface.
type BuildableIface struct {
	native *C.GtkBuildableIface
	// g_iface : record
	// no type for set_name
	// no type for get_name
	// no type for add_child
	// no type for set_buildable_property
	// no type for construct_child
	// no type for custom_tag_start
	// no type for custom_tag_end
	// no type for custom_finished
	// no type for parser_finished
	// no type for get_internal_child
}

func BuildableIfaceNewFromC(u unsafe.Pointer) *BuildableIface {
	c := (*C.GtkBuildableIface)(u)
	if c == nil {
		return nil
	}

	g := &BuildableIface{native: c}

	return g
}

func (recv *BuildableIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BuildableIface with another BuildableIface, and returns true if they represent the same GObject.
func (recv *BuildableIface) Equals(other *BuildableIface) bool {
	return other.ToC() == recv.ToC()
}

// BuilderClass is a wrapper around the C record GtkBuilderClass.
type BuilderClass struct {
	native *C.GtkBuilderClass
	// parent_class : record
	// no type for get_type_from_name
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func BuilderClassNewFromC(u unsafe.Pointer) *BuilderClass {
	c := (*C.GtkBuilderClass)(u)
	if c == nil {
		return nil
	}

	g := &BuilderClass{native: c}

	return g
}

func (recv *BuilderClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BuilderClass with another BuilderClass, and returns true if they represent the same GObject.
func (recv *BuilderClass) Equals(other *BuilderClass) bool {
	return other.ToC() == recv.ToC()
}

// BuilderPrivate is a wrapper around the C record GtkBuilderPrivate.
type BuilderPrivate struct {
	native *C.GtkBuilderPrivate
}

func BuilderPrivateNewFromC(u unsafe.Pointer) *BuilderPrivate {
	c := (*C.GtkBuilderPrivate)(u)
	if c == nil {
		return nil
	}

	g := &BuilderPrivate{native: c}

	return g
}

func (recv *BuilderPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this BuilderPrivate with another BuilderPrivate, and returns true if they represent the same GObject.
func (recv *BuilderPrivate) Equals(other *BuilderPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessibleClass is a wrapper around the C record GtkButtonAccessibleClass.
type ButtonAccessibleClass struct {
	native *C.GtkButtonAccessibleClass
	// parent_class : record
}

func ButtonAccessibleClassNewFromC(u unsafe.Pointer) *ButtonAccessibleClass {
	c := (*C.GtkButtonAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ButtonAccessibleClass{native: c}

	return g
}

func (recv *ButtonAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonAccessibleClass with another ButtonAccessibleClass, and returns true if they represent the same GObject.
func (recv *ButtonAccessibleClass) Equals(other *ButtonAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ButtonAccessiblePrivate is a wrapper around the C record GtkButtonAccessiblePrivate.
type ButtonAccessiblePrivate struct {
	native *C.GtkButtonAccessiblePrivate
}

func ButtonAccessiblePrivateNewFromC(u unsafe.Pointer) *ButtonAccessiblePrivate {
	c := (*C.GtkButtonAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ButtonAccessiblePrivate{native: c}

	return g
}

func (recv *ButtonAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonAccessiblePrivate with another ButtonAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ButtonAccessiblePrivate) Equals(other *ButtonAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ButtonBoxClass is a wrapper around the C record GtkButtonBoxClass.
type ButtonBoxClass struct {
	native *C.GtkButtonBoxClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ButtonBoxClassNewFromC(u unsafe.Pointer) *ButtonBoxClass {
	c := (*C.GtkButtonBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &ButtonBoxClass{native: c}

	return g
}

func (recv *ButtonBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonBoxClass with another ButtonBoxClass, and returns true if they represent the same GObject.
func (recv *ButtonBoxClass) Equals(other *ButtonBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// ButtonBoxPrivate is a wrapper around the C record GtkButtonBoxPrivate.
type ButtonBoxPrivate struct {
	native *C.GtkButtonBoxPrivate
}

func ButtonBoxPrivateNewFromC(u unsafe.Pointer) *ButtonBoxPrivate {
	c := (*C.GtkButtonBoxPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ButtonBoxPrivate{native: c}

	return g
}

func (recv *ButtonBoxPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonBoxPrivate with another ButtonBoxPrivate, and returns true if they represent the same GObject.
func (recv *ButtonBoxPrivate) Equals(other *ButtonBoxPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ButtonClass is a wrapper around the C record GtkButtonClass.
type ButtonClass struct {
	native *C.GtkButtonClass
	// parent_class : record
	// no type for pressed
	// no type for released
	// no type for clicked
	// no type for enter
	// no type for leave
	// no type for activate
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ButtonClassNewFromC(u unsafe.Pointer) *ButtonClass {
	c := (*C.GtkButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &ButtonClass{native: c}

	return g
}

func (recv *ButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonClass with another ButtonClass, and returns true if they represent the same GObject.
func (recv *ButtonClass) Equals(other *ButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// ButtonPrivate is a wrapper around the C record GtkButtonPrivate.
type ButtonPrivate struct {
	native *C.GtkButtonPrivate
}

func ButtonPrivateNewFromC(u unsafe.Pointer) *ButtonPrivate {
	c := (*C.GtkButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ButtonPrivate{native: c}

	return g
}

func (recv *ButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ButtonPrivate with another ButtonPrivate, and returns true if they represent the same GObject.
func (recv *ButtonPrivate) Equals(other *ButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CalendarClass is a wrapper around the C record GtkCalendarClass.
type CalendarClass struct {
	native *C.GtkCalendarClass
	// parent_class : record
	// no type for month_changed
	// no type for day_selected
	// no type for day_selected_double_click
	// no type for prev_month
	// no type for next_month
	// no type for prev_year
	// no type for next_year
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CalendarClassNewFromC(u unsafe.Pointer) *CalendarClass {
	c := (*C.GtkCalendarClass)(u)
	if c == nil {
		return nil
	}

	g := &CalendarClass{native: c}

	return g
}

func (recv *CalendarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CalendarClass with another CalendarClass, and returns true if they represent the same GObject.
func (recv *CalendarClass) Equals(other *CalendarClass) bool {
	return other.ToC() == recv.ToC()
}

// CalendarPrivate is a wrapper around the C record GtkCalendarPrivate.
type CalendarPrivate struct {
	native *C.GtkCalendarPrivate
}

func CalendarPrivateNewFromC(u unsafe.Pointer) *CalendarPrivate {
	c := (*C.GtkCalendarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CalendarPrivate{native: c}

	return g
}

func (recv *CalendarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CalendarPrivate with another CalendarPrivate, and returns true if they represent the same GObject.
func (recv *CalendarPrivate) Equals(other *CalendarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellAccessibleClass is a wrapper around the C record GtkCellAccessibleClass.
type CellAccessibleClass struct {
	native *C.GtkCellAccessibleClass
	// parent_class : record
	// no type for update_cache
}

func CellAccessibleClassNewFromC(u unsafe.Pointer) *CellAccessibleClass {
	c := (*C.GtkCellAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &CellAccessibleClass{native: c}

	return g
}

func (recv *CellAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAccessibleClass with another CellAccessibleClass, and returns true if they represent the same GObject.
func (recv *CellAccessibleClass) Equals(other *CellAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// CellAccessibleParentIface is a wrapper around the C record GtkCellAccessibleParentIface.
type CellAccessibleParentIface struct {
	native *C.GtkCellAccessibleParentIface
	// parent : record
	// no type for get_cell_extents
	// no type for get_cell_area
	// no type for grab_focus
	// no type for get_child_index
	// no type for get_renderer_state
	// no type for expand_collapse
	// no type for activate
	// no type for edit
	// no type for update_relationset
}

func CellAccessibleParentIfaceNewFromC(u unsafe.Pointer) *CellAccessibleParentIface {
	c := (*C.GtkCellAccessibleParentIface)(u)
	if c == nil {
		return nil
	}

	g := &CellAccessibleParentIface{native: c}

	return g
}

func (recv *CellAccessibleParentIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAccessibleParentIface with another CellAccessibleParentIface, and returns true if they represent the same GObject.
func (recv *CellAccessibleParentIface) Equals(other *CellAccessibleParentIface) bool {
	return other.ToC() == recv.ToC()
}

// CellAccessiblePrivate is a wrapper around the C record GtkCellAccessiblePrivate.
type CellAccessiblePrivate struct {
	native *C.GtkCellAccessiblePrivate
}

func CellAccessiblePrivateNewFromC(u unsafe.Pointer) *CellAccessiblePrivate {
	c := (*C.GtkCellAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellAccessiblePrivate{native: c}

	return g
}

func (recv *CellAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAccessiblePrivate with another CellAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *CellAccessiblePrivate) Equals(other *CellAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellAreaBoxClass is a wrapper around the C record GtkCellAreaBoxClass.
type CellAreaBoxClass struct {
	native *C.GtkCellAreaBoxClass
	// Private : parent_class
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellAreaBoxClassNewFromC(u unsafe.Pointer) *CellAreaBoxClass {
	c := (*C.GtkCellAreaBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaBoxClass{native: c}

	return g
}

func (recv *CellAreaBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaBoxClass with another CellAreaBoxClass, and returns true if they represent the same GObject.
func (recv *CellAreaBoxClass) Equals(other *CellAreaBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// CellAreaBoxPrivate is a wrapper around the C record GtkCellAreaBoxPrivate.
type CellAreaBoxPrivate struct {
	native *C.GtkCellAreaBoxPrivate
}

func CellAreaBoxPrivateNewFromC(u unsafe.Pointer) *CellAreaBoxPrivate {
	c := (*C.GtkCellAreaBoxPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaBoxPrivate{native: c}

	return g
}

func (recv *CellAreaBoxPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaBoxPrivate with another CellAreaBoxPrivate, and returns true if they represent the same GObject.
func (recv *CellAreaBoxPrivate) Equals(other *CellAreaBoxPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellAreaClass is a wrapper around the C record GtkCellAreaClass.
type CellAreaClass struct {
	native *C.GtkCellAreaClass
	// Private : parent_class
	// no type for add
	// no type for remove
	// no type for foreach
	// no type for foreach_alloc
	// no type for event
	// no type for render
	// no type for apply_attributes
	// no type for create_context
	// no type for copy_context
	// no type for get_request_mode
	// no type for get_preferred_width
	// no type for get_preferred_height_for_width
	// no type for get_preferred_height
	// no type for get_preferred_width_for_height
	// no type for set_cell_property
	// no type for get_cell_property
	// no type for focus
	// no type for is_activatable
	// no type for activate
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func CellAreaClassNewFromC(u unsafe.Pointer) *CellAreaClass {
	c := (*C.GtkCellAreaClass)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaClass{native: c}

	return g
}

func (recv *CellAreaClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaClass with another CellAreaClass, and returns true if they represent the same GObject.
func (recv *CellAreaClass) Equals(other *CellAreaClass) bool {
	return other.ToC() == recv.ToC()
}

// CellAreaContextClass is a wrapper around the C record GtkCellAreaContextClass.
type CellAreaContextClass struct {
	native *C.GtkCellAreaContextClass
	// Private : parent_class
	// no type for allocate
	// no type for reset
	// no type for get_preferred_height_for_width
	// no type for get_preferred_width_for_height
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
}

func CellAreaContextClassNewFromC(u unsafe.Pointer) *CellAreaContextClass {
	c := (*C.GtkCellAreaContextClass)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaContextClass{native: c}

	return g
}

func (recv *CellAreaContextClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaContextClass with another CellAreaContextClass, and returns true if they represent the same GObject.
func (recv *CellAreaContextClass) Equals(other *CellAreaContextClass) bool {
	return other.ToC() == recv.ToC()
}

// CellAreaContextPrivate is a wrapper around the C record GtkCellAreaContextPrivate.
type CellAreaContextPrivate struct {
	native *C.GtkCellAreaContextPrivate
}

func CellAreaContextPrivateNewFromC(u unsafe.Pointer) *CellAreaContextPrivate {
	c := (*C.GtkCellAreaContextPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaContextPrivate{native: c}

	return g
}

func (recv *CellAreaContextPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaContextPrivate with another CellAreaContextPrivate, and returns true if they represent the same GObject.
func (recv *CellAreaContextPrivate) Equals(other *CellAreaContextPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellAreaPrivate is a wrapper around the C record GtkCellAreaPrivate.
type CellAreaPrivate struct {
	native *C.GtkCellAreaPrivate
}

func CellAreaPrivateNewFromC(u unsafe.Pointer) *CellAreaPrivate {
	c := (*C.GtkCellAreaPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellAreaPrivate{native: c}

	return g
}

func (recv *CellAreaPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellAreaPrivate with another CellAreaPrivate, and returns true if they represent the same GObject.
func (recv *CellAreaPrivate) Equals(other *CellAreaPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellEditableIface is a wrapper around the C record GtkCellEditableIface.
type CellEditableIface struct {
	native *C.GtkCellEditableIface
	// Private : g_iface
	// no type for editing_done
	// no type for remove_widget
	// no type for start_editing
}

func CellEditableIfaceNewFromC(u unsafe.Pointer) *CellEditableIface {
	c := (*C.GtkCellEditableIface)(u)
	if c == nil {
		return nil
	}

	g := &CellEditableIface{native: c}

	return g
}

func (recv *CellEditableIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellEditableIface with another CellEditableIface, and returns true if they represent the same GObject.
func (recv *CellEditableIface) Equals(other *CellEditableIface) bool {
	return other.ToC() == recv.ToC()
}

// CellLayoutIface is a wrapper around the C record GtkCellLayoutIface.
type CellLayoutIface struct {
	native *C.GtkCellLayoutIface
	// Private : g_iface
	// no type for pack_start
	// no type for pack_end
	// no type for clear
	// no type for add_attribute
	// no type for set_cell_data_func
	// no type for clear_attributes
	// no type for reorder
	// no type for get_cells
	// no type for get_area
}

func CellLayoutIfaceNewFromC(u unsafe.Pointer) *CellLayoutIface {
	c := (*C.GtkCellLayoutIface)(u)
	if c == nil {
		return nil
	}

	g := &CellLayoutIface{native: c}

	return g
}

func (recv *CellLayoutIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellLayoutIface with another CellLayoutIface, and returns true if they represent the same GObject.
func (recv *CellLayoutIface) Equals(other *CellLayoutIface) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererAccelClass is a wrapper around the C record GtkCellRendererAccelClass.
type CellRendererAccelClass struct {
	native *C.GtkCellRendererAccelClass
	// parent_class : record
	// no type for accel_edited
	// no type for accel_cleared
	// no type for _gtk_reserved0
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererAccelClassNewFromC(u unsafe.Pointer) *CellRendererAccelClass {
	c := (*C.GtkCellRendererAccelClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererAccelClass{native: c}

	return g
}

func (recv *CellRendererAccelClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererAccelClass with another CellRendererAccelClass, and returns true if they represent the same GObject.
func (recv *CellRendererAccelClass) Equals(other *CellRendererAccelClass) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererAccelPrivate is a wrapper around the C record GtkCellRendererAccelPrivate.
type CellRendererAccelPrivate struct {
	native *C.GtkCellRendererAccelPrivate
}

func CellRendererAccelPrivateNewFromC(u unsafe.Pointer) *CellRendererAccelPrivate {
	c := (*C.GtkCellRendererAccelPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererAccelPrivate{native: c}

	return g
}

func (recv *CellRendererAccelPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererAccelPrivate with another CellRendererAccelPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererAccelPrivate) Equals(other *CellRendererAccelPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererClass is a wrapper around the C record GtkCellRendererClass.
type CellRendererClass struct {
	native *C.GtkCellRendererClass
	// Private : parent_class
	// no type for get_request_mode
	// no type for get_preferred_width
	// no type for get_preferred_height_for_width
	// no type for get_preferred_height
	// no type for get_preferred_width_for_height
	// no type for get_aligned_area
	// no type for get_size
	// no type for render
	// no type for activate
	// no type for start_editing
	// no type for editing_canceled
	// no type for editing_started
	// Private : priv
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererClassNewFromC(u unsafe.Pointer) *CellRendererClass {
	c := (*C.GtkCellRendererClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererClass{native: c}

	return g
}

func (recv *CellRendererClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererClass with another CellRendererClass, and returns true if they represent the same GObject.
func (recv *CellRendererClass) Equals(other *CellRendererClass) bool {
	return other.ToC() == recv.ToC()
}

// SetAccessibleType is a wrapper around the C function gtk_cell_renderer_class_set_accessible_type.
func (recv *CellRendererClass) SetAccessibleType(type_ gobject.Type) {
	c_type := (C.GType)(type_)

	C.gtk_cell_renderer_class_set_accessible_type((*C.GtkCellRendererClass)(recv.native), c_type)

	return
}

// CellRendererClassPrivate is a wrapper around the C record GtkCellRendererClassPrivate.
type CellRendererClassPrivate struct {
	native *C.GtkCellRendererClassPrivate
}

func CellRendererClassPrivateNewFromC(u unsafe.Pointer) *CellRendererClassPrivate {
	c := (*C.GtkCellRendererClassPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererClassPrivate{native: c}

	return g
}

func (recv *CellRendererClassPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererClassPrivate with another CellRendererClassPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererClassPrivate) Equals(other *CellRendererClassPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererComboClass is a wrapper around the C record GtkCellRendererComboClass.
type CellRendererComboClass struct {
	native *C.GtkCellRendererComboClass
	// parent : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererComboClassNewFromC(u unsafe.Pointer) *CellRendererComboClass {
	c := (*C.GtkCellRendererComboClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererComboClass{native: c}

	return g
}

func (recv *CellRendererComboClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererComboClass with another CellRendererComboClass, and returns true if they represent the same GObject.
func (recv *CellRendererComboClass) Equals(other *CellRendererComboClass) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererComboPrivate is a wrapper around the C record GtkCellRendererComboPrivate.
type CellRendererComboPrivate struct {
	native *C.GtkCellRendererComboPrivate
}

func CellRendererComboPrivateNewFromC(u unsafe.Pointer) *CellRendererComboPrivate {
	c := (*C.GtkCellRendererComboPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererComboPrivate{native: c}

	return g
}

func (recv *CellRendererComboPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererComboPrivate with another CellRendererComboPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererComboPrivate) Equals(other *CellRendererComboPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererPixbufClass is a wrapper around the C record GtkCellRendererPixbufClass.
type CellRendererPixbufClass struct {
	native *C.GtkCellRendererPixbufClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererPixbufClassNewFromC(u unsafe.Pointer) *CellRendererPixbufClass {
	c := (*C.GtkCellRendererPixbufClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererPixbufClass{native: c}

	return g
}

func (recv *CellRendererPixbufClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererPixbufClass with another CellRendererPixbufClass, and returns true if they represent the same GObject.
func (recv *CellRendererPixbufClass) Equals(other *CellRendererPixbufClass) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererPixbufPrivate is a wrapper around the C record GtkCellRendererPixbufPrivate.
type CellRendererPixbufPrivate struct {
	native *C.GtkCellRendererPixbufPrivate
}

func CellRendererPixbufPrivateNewFromC(u unsafe.Pointer) *CellRendererPixbufPrivate {
	c := (*C.GtkCellRendererPixbufPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererPixbufPrivate{native: c}

	return g
}

func (recv *CellRendererPixbufPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererPixbufPrivate with another CellRendererPixbufPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererPixbufPrivate) Equals(other *CellRendererPixbufPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererPrivate is a wrapper around the C record GtkCellRendererPrivate.
type CellRendererPrivate struct {
	native *C.GtkCellRendererPrivate
}

func CellRendererPrivateNewFromC(u unsafe.Pointer) *CellRendererPrivate {
	c := (*C.GtkCellRendererPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererPrivate{native: c}

	return g
}

func (recv *CellRendererPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererPrivate with another CellRendererPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererPrivate) Equals(other *CellRendererPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererProgressClass is a wrapper around the C record GtkCellRendererProgressClass.
type CellRendererProgressClass struct {
	native *C.GtkCellRendererProgressClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererProgressClassNewFromC(u unsafe.Pointer) *CellRendererProgressClass {
	c := (*C.GtkCellRendererProgressClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererProgressClass{native: c}

	return g
}

func (recv *CellRendererProgressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererProgressClass with another CellRendererProgressClass, and returns true if they represent the same GObject.
func (recv *CellRendererProgressClass) Equals(other *CellRendererProgressClass) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererProgressPrivate is a wrapper around the C record GtkCellRendererProgressPrivate.
type CellRendererProgressPrivate struct {
	native *C.GtkCellRendererProgressPrivate
}

func CellRendererProgressPrivateNewFromC(u unsafe.Pointer) *CellRendererProgressPrivate {
	c := (*C.GtkCellRendererProgressPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererProgressPrivate{native: c}

	return g
}

func (recv *CellRendererProgressPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererProgressPrivate with another CellRendererProgressPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererProgressPrivate) Equals(other *CellRendererProgressPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererSpinClass is a wrapper around the C record GtkCellRendererSpinClass.
type CellRendererSpinClass struct {
	native *C.GtkCellRendererSpinClass
	// parent : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererSpinClassNewFromC(u unsafe.Pointer) *CellRendererSpinClass {
	c := (*C.GtkCellRendererSpinClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpinClass{native: c}

	return g
}

func (recv *CellRendererSpinClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererSpinClass with another CellRendererSpinClass, and returns true if they represent the same GObject.
func (recv *CellRendererSpinClass) Equals(other *CellRendererSpinClass) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererSpinPrivate is a wrapper around the C record GtkCellRendererSpinPrivate.
type CellRendererSpinPrivate struct {
	native *C.GtkCellRendererSpinPrivate
}

func CellRendererSpinPrivateNewFromC(u unsafe.Pointer) *CellRendererSpinPrivate {
	c := (*C.GtkCellRendererSpinPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpinPrivate{native: c}

	return g
}

func (recv *CellRendererSpinPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererSpinPrivate with another CellRendererSpinPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererSpinPrivate) Equals(other *CellRendererSpinPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererSpinnerClass is a wrapper around the C record GtkCellRendererSpinnerClass.
type CellRendererSpinnerClass struct {
	native *C.GtkCellRendererSpinnerClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererSpinnerClassNewFromC(u unsafe.Pointer) *CellRendererSpinnerClass {
	c := (*C.GtkCellRendererSpinnerClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpinnerClass{native: c}

	return g
}

func (recv *CellRendererSpinnerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererSpinnerClass with another CellRendererSpinnerClass, and returns true if they represent the same GObject.
func (recv *CellRendererSpinnerClass) Equals(other *CellRendererSpinnerClass) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererSpinnerPrivate is a wrapper around the C record GtkCellRendererSpinnerPrivate.
type CellRendererSpinnerPrivate struct {
	native *C.GtkCellRendererSpinnerPrivate
}

func CellRendererSpinnerPrivateNewFromC(u unsafe.Pointer) *CellRendererSpinnerPrivate {
	c := (*C.GtkCellRendererSpinnerPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererSpinnerPrivate{native: c}

	return g
}

func (recv *CellRendererSpinnerPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererSpinnerPrivate with another CellRendererSpinnerPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererSpinnerPrivate) Equals(other *CellRendererSpinnerPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererTextClass is a wrapper around the C record GtkCellRendererTextClass.
type CellRendererTextClass struct {
	native *C.GtkCellRendererTextClass
	// parent_class : record
	// no type for edited
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererTextClassNewFromC(u unsafe.Pointer) *CellRendererTextClass {
	c := (*C.GtkCellRendererTextClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererTextClass{native: c}

	return g
}

func (recv *CellRendererTextClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererTextClass with another CellRendererTextClass, and returns true if they represent the same GObject.
func (recv *CellRendererTextClass) Equals(other *CellRendererTextClass) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererTextPrivate is a wrapper around the C record GtkCellRendererTextPrivate.
type CellRendererTextPrivate struct {
	native *C.GtkCellRendererTextPrivate
}

func CellRendererTextPrivateNewFromC(u unsafe.Pointer) *CellRendererTextPrivate {
	c := (*C.GtkCellRendererTextPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererTextPrivate{native: c}

	return g
}

func (recv *CellRendererTextPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererTextPrivate with another CellRendererTextPrivate, and returns true if they represent the same GObject.
func (recv *CellRendererTextPrivate) Equals(other *CellRendererTextPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererToggleClass is a wrapper around the C record GtkCellRendererToggleClass.
type CellRendererToggleClass struct {
	native *C.GtkCellRendererToggleClass
	// parent_class : record
	// no type for toggled
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellRendererToggleClassNewFromC(u unsafe.Pointer) *CellRendererToggleClass {
	c := (*C.GtkCellRendererToggleClass)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererToggleClass{native: c}

	return g
}

func (recv *CellRendererToggleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererToggleClass with another CellRendererToggleClass, and returns true if they represent the same GObject.
func (recv *CellRendererToggleClass) Equals(other *CellRendererToggleClass) bool {
	return other.ToC() == recv.ToC()
}

// CellRendererTogglePrivate is a wrapper around the C record GtkCellRendererTogglePrivate.
type CellRendererTogglePrivate struct {
	native *C.GtkCellRendererTogglePrivate
}

func CellRendererTogglePrivateNewFromC(u unsafe.Pointer) *CellRendererTogglePrivate {
	c := (*C.GtkCellRendererTogglePrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellRendererTogglePrivate{native: c}

	return g
}

func (recv *CellRendererTogglePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellRendererTogglePrivate with another CellRendererTogglePrivate, and returns true if they represent the same GObject.
func (recv *CellRendererTogglePrivate) Equals(other *CellRendererTogglePrivate) bool {
	return other.ToC() == recv.ToC()
}

// CellViewClass is a wrapper around the C record GtkCellViewClass.
type CellViewClass struct {
	native *C.GtkCellViewClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CellViewClassNewFromC(u unsafe.Pointer) *CellViewClass {
	c := (*C.GtkCellViewClass)(u)
	if c == nil {
		return nil
	}

	g := &CellViewClass{native: c}

	return g
}

func (recv *CellViewClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellViewClass with another CellViewClass, and returns true if they represent the same GObject.
func (recv *CellViewClass) Equals(other *CellViewClass) bool {
	return other.ToC() == recv.ToC()
}

// CellViewPrivate is a wrapper around the C record GtkCellViewPrivate.
type CellViewPrivate struct {
	native *C.GtkCellViewPrivate
}

func CellViewPrivateNewFromC(u unsafe.Pointer) *CellViewPrivate {
	c := (*C.GtkCellViewPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CellViewPrivate{native: c}

	return g
}

func (recv *CellViewPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CellViewPrivate with another CellViewPrivate, and returns true if they represent the same GObject.
func (recv *CellViewPrivate) Equals(other *CellViewPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CheckButtonClass is a wrapper around the C record GtkCheckButtonClass.
type CheckButtonClass struct {
	native *C.GtkCheckButtonClass
	// parent_class : record
	// no type for draw_indicator
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CheckButtonClassNewFromC(u unsafe.Pointer) *CheckButtonClass {
	c := (*C.GtkCheckButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &CheckButtonClass{native: c}

	return g
}

func (recv *CheckButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckButtonClass with another CheckButtonClass, and returns true if they represent the same GObject.
func (recv *CheckButtonClass) Equals(other *CheckButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// CheckMenuItemAccessibleClass is a wrapper around the C record GtkCheckMenuItemAccessibleClass.
type CheckMenuItemAccessibleClass struct {
	native *C.GtkCheckMenuItemAccessibleClass
	// parent_class : record
}

func CheckMenuItemAccessibleClassNewFromC(u unsafe.Pointer) *CheckMenuItemAccessibleClass {
	c := (*C.GtkCheckMenuItemAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItemAccessibleClass{native: c}

	return g
}

func (recv *CheckMenuItemAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckMenuItemAccessibleClass with another CheckMenuItemAccessibleClass, and returns true if they represent the same GObject.
func (recv *CheckMenuItemAccessibleClass) Equals(other *CheckMenuItemAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// CheckMenuItemAccessiblePrivate is a wrapper around the C record GtkCheckMenuItemAccessiblePrivate.
type CheckMenuItemAccessiblePrivate struct {
	native *C.GtkCheckMenuItemAccessiblePrivate
}

func CheckMenuItemAccessiblePrivateNewFromC(u unsafe.Pointer) *CheckMenuItemAccessiblePrivate {
	c := (*C.GtkCheckMenuItemAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItemAccessiblePrivate{native: c}

	return g
}

func (recv *CheckMenuItemAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckMenuItemAccessiblePrivate with another CheckMenuItemAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *CheckMenuItemAccessiblePrivate) Equals(other *CheckMenuItemAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// CheckMenuItemClass is a wrapper around the C record GtkCheckMenuItemClass.
type CheckMenuItemClass struct {
	native *C.GtkCheckMenuItemClass
	// parent_class : record
	// no type for toggled
	// no type for draw_indicator
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CheckMenuItemClassNewFromC(u unsafe.Pointer) *CheckMenuItemClass {
	c := (*C.GtkCheckMenuItemClass)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItemClass{native: c}

	return g
}

func (recv *CheckMenuItemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckMenuItemClass with another CheckMenuItemClass, and returns true if they represent the same GObject.
func (recv *CheckMenuItemClass) Equals(other *CheckMenuItemClass) bool {
	return other.ToC() == recv.ToC()
}

// CheckMenuItemPrivate is a wrapper around the C record GtkCheckMenuItemPrivate.
type CheckMenuItemPrivate struct {
	native *C.GtkCheckMenuItemPrivate
}

func CheckMenuItemPrivateNewFromC(u unsafe.Pointer) *CheckMenuItemPrivate {
	c := (*C.GtkCheckMenuItemPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CheckMenuItemPrivate{native: c}

	return g
}

func (recv *CheckMenuItemPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CheckMenuItemPrivate with another CheckMenuItemPrivate, and returns true if they represent the same GObject.
func (recv *CheckMenuItemPrivate) Equals(other *CheckMenuItemPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ColorButtonClass is a wrapper around the C record GtkColorButtonClass.
type ColorButtonClass struct {
	native *C.GtkColorButtonClass
	// parent_class : record
	// no type for color_set
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ColorButtonClassNewFromC(u unsafe.Pointer) *ColorButtonClass {
	c := (*C.GtkColorButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &ColorButtonClass{native: c}

	return g
}

func (recv *ColorButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorButtonClass with another ColorButtonClass, and returns true if they represent the same GObject.
func (recv *ColorButtonClass) Equals(other *ColorButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// ColorButtonPrivate is a wrapper around the C record GtkColorButtonPrivate.
type ColorButtonPrivate struct {
	native *C.GtkColorButtonPrivate
}

func ColorButtonPrivateNewFromC(u unsafe.Pointer) *ColorButtonPrivate {
	c := (*C.GtkColorButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ColorButtonPrivate{native: c}

	return g
}

func (recv *ColorButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorButtonPrivate with another ColorButtonPrivate, and returns true if they represent the same GObject.
func (recv *ColorButtonPrivate) Equals(other *ColorButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ColorChooserDialogClass is a wrapper around the C record GtkColorChooserDialogClass.
type ColorChooserDialogClass struct {
	native *C.GtkColorChooserDialogClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ColorChooserDialogClassNewFromC(u unsafe.Pointer) *ColorChooserDialogClass {
	c := (*C.GtkColorChooserDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserDialogClass{native: c}

	return g
}

func (recv *ColorChooserDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserDialogClass with another ColorChooserDialogClass, and returns true if they represent the same GObject.
func (recv *ColorChooserDialogClass) Equals(other *ColorChooserDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// ColorChooserDialogPrivate is a wrapper around the C record GtkColorChooserDialogPrivate.
type ColorChooserDialogPrivate struct {
	native *C.GtkColorChooserDialogPrivate
}

func ColorChooserDialogPrivateNewFromC(u unsafe.Pointer) *ColorChooserDialogPrivate {
	c := (*C.GtkColorChooserDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserDialogPrivate{native: c}

	return g
}

func (recv *ColorChooserDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserDialogPrivate with another ColorChooserDialogPrivate, and returns true if they represent the same GObject.
func (recv *ColorChooserDialogPrivate) Equals(other *ColorChooserDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ColorChooserInterface is a wrapper around the C record GtkColorChooserInterface.
type ColorChooserInterface struct {
	native *C.GtkColorChooserInterface
	// base_interface : record
	// no type for get_rgba
	// no type for set_rgba
	// no type for add_palette
	// no type for color_activated
	// no type for padding
}

func ColorChooserInterfaceNewFromC(u unsafe.Pointer) *ColorChooserInterface {
	c := (*C.GtkColorChooserInterface)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserInterface{native: c}

	return g
}

func (recv *ColorChooserInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserInterface with another ColorChooserInterface, and returns true if they represent the same GObject.
func (recv *ColorChooserInterface) Equals(other *ColorChooserInterface) bool {
	return other.ToC() == recv.ToC()
}

// ColorChooserWidgetClass is a wrapper around the C record GtkColorChooserWidgetClass.
type ColorChooserWidgetClass struct {
	native *C.GtkColorChooserWidgetClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func ColorChooserWidgetClassNewFromC(u unsafe.Pointer) *ColorChooserWidgetClass {
	c := (*C.GtkColorChooserWidgetClass)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserWidgetClass{native: c}

	return g
}

func (recv *ColorChooserWidgetClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserWidgetClass with another ColorChooserWidgetClass, and returns true if they represent the same GObject.
func (recv *ColorChooserWidgetClass) Equals(other *ColorChooserWidgetClass) bool {
	return other.ToC() == recv.ToC()
}

// ColorChooserWidgetPrivate is a wrapper around the C record GtkColorChooserWidgetPrivate.
type ColorChooserWidgetPrivate struct {
	native *C.GtkColorChooserWidgetPrivate
}

func ColorChooserWidgetPrivateNewFromC(u unsafe.Pointer) *ColorChooserWidgetPrivate {
	c := (*C.GtkColorChooserWidgetPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ColorChooserWidgetPrivate{native: c}

	return g
}

func (recv *ColorChooserWidgetPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorChooserWidgetPrivate with another ColorChooserWidgetPrivate, and returns true if they represent the same GObject.
func (recv *ColorChooserWidgetPrivate) Equals(other *ColorChooserWidgetPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ColorSelectionClass is a wrapper around the C record GtkColorSelectionClass.
type ColorSelectionClass struct {
	native *C.GtkColorSelectionClass
	// parent_class : record
	// no type for color_changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ColorSelectionClassNewFromC(u unsafe.Pointer) *ColorSelectionClass {
	c := (*C.GtkColorSelectionClass)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelectionClass{native: c}

	return g
}

func (recv *ColorSelectionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorSelectionClass with another ColorSelectionClass, and returns true if they represent the same GObject.
func (recv *ColorSelectionClass) Equals(other *ColorSelectionClass) bool {
	return other.ToC() == recv.ToC()
}

// ColorSelectionDialogClass is a wrapper around the C record GtkColorSelectionDialogClass.
type ColorSelectionDialogClass struct {
	native *C.GtkColorSelectionDialogClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ColorSelectionDialogClassNewFromC(u unsafe.Pointer) *ColorSelectionDialogClass {
	c := (*C.GtkColorSelectionDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelectionDialogClass{native: c}

	return g
}

func (recv *ColorSelectionDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorSelectionDialogClass with another ColorSelectionDialogClass, and returns true if they represent the same GObject.
func (recv *ColorSelectionDialogClass) Equals(other *ColorSelectionDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// ColorSelectionDialogPrivate is a wrapper around the C record GtkColorSelectionDialogPrivate.
type ColorSelectionDialogPrivate struct {
	native *C.GtkColorSelectionDialogPrivate
}

func ColorSelectionDialogPrivateNewFromC(u unsafe.Pointer) *ColorSelectionDialogPrivate {
	c := (*C.GtkColorSelectionDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelectionDialogPrivate{native: c}

	return g
}

func (recv *ColorSelectionDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorSelectionDialogPrivate with another ColorSelectionDialogPrivate, and returns true if they represent the same GObject.
func (recv *ColorSelectionDialogPrivate) Equals(other *ColorSelectionDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ColorSelectionPrivate is a wrapper around the C record GtkColorSelectionPrivate.
type ColorSelectionPrivate struct {
	native *C.GtkColorSelectionPrivate
}

func ColorSelectionPrivateNewFromC(u unsafe.Pointer) *ColorSelectionPrivate {
	c := (*C.GtkColorSelectionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ColorSelectionPrivate{native: c}

	return g
}

func (recv *ColorSelectionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ColorSelectionPrivate with another ColorSelectionPrivate, and returns true if they represent the same GObject.
func (recv *ColorSelectionPrivate) Equals(other *ColorSelectionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ComboBoxAccessibleClass is a wrapper around the C record GtkComboBoxAccessibleClass.
type ComboBoxAccessibleClass struct {
	native *C.GtkComboBoxAccessibleClass
	// parent_class : record
}

func ComboBoxAccessibleClassNewFromC(u unsafe.Pointer) *ComboBoxAccessibleClass {
	c := (*C.GtkComboBoxAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxAccessibleClass{native: c}

	return g
}

func (recv *ComboBoxAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxAccessibleClass with another ComboBoxAccessibleClass, and returns true if they represent the same GObject.
func (recv *ComboBoxAccessibleClass) Equals(other *ComboBoxAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ComboBoxAccessiblePrivate is a wrapper around the C record GtkComboBoxAccessiblePrivate.
type ComboBoxAccessiblePrivate struct {
	native *C.GtkComboBoxAccessiblePrivate
}

func ComboBoxAccessiblePrivateNewFromC(u unsafe.Pointer) *ComboBoxAccessiblePrivate {
	c := (*C.GtkComboBoxAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxAccessiblePrivate{native: c}

	return g
}

func (recv *ComboBoxAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxAccessiblePrivate with another ComboBoxAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ComboBoxAccessiblePrivate) Equals(other *ComboBoxAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ComboBoxClass is a wrapper around the C record GtkComboBoxClass.
type ComboBoxClass struct {
	native *C.GtkComboBoxClass
	// parent_class : record
	// no type for changed
	// no type for format_entry_text
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
}

func ComboBoxClassNewFromC(u unsafe.Pointer) *ComboBoxClass {
	c := (*C.GtkComboBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxClass{native: c}

	return g
}

func (recv *ComboBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxClass with another ComboBoxClass, and returns true if they represent the same GObject.
func (recv *ComboBoxClass) Equals(other *ComboBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// ComboBoxPrivate is a wrapper around the C record GtkComboBoxPrivate.
type ComboBoxPrivate struct {
	native *C.GtkComboBoxPrivate
}

func ComboBoxPrivateNewFromC(u unsafe.Pointer) *ComboBoxPrivate {
	c := (*C.GtkComboBoxPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxPrivate{native: c}

	return g
}

func (recv *ComboBoxPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxPrivate with another ComboBoxPrivate, and returns true if they represent the same GObject.
func (recv *ComboBoxPrivate) Equals(other *ComboBoxPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ComboBoxTextClass is a wrapper around the C record GtkComboBoxTextClass.
type ComboBoxTextClass struct {
	native *C.GtkComboBoxTextClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ComboBoxTextClassNewFromC(u unsafe.Pointer) *ComboBoxTextClass {
	c := (*C.GtkComboBoxTextClass)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxTextClass{native: c}

	return g
}

func (recv *ComboBoxTextClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxTextClass with another ComboBoxTextClass, and returns true if they represent the same GObject.
func (recv *ComboBoxTextClass) Equals(other *ComboBoxTextClass) bool {
	return other.ToC() == recv.ToC()
}

// ComboBoxTextPrivate is a wrapper around the C record GtkComboBoxTextPrivate.
type ComboBoxTextPrivate struct {
	native *C.GtkComboBoxTextPrivate
}

func ComboBoxTextPrivateNewFromC(u unsafe.Pointer) *ComboBoxTextPrivate {
	c := (*C.GtkComboBoxTextPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ComboBoxTextPrivate{native: c}

	return g
}

func (recv *ComboBoxTextPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ComboBoxTextPrivate with another ComboBoxTextPrivate, and returns true if they represent the same GObject.
func (recv *ComboBoxTextPrivate) Equals(other *ComboBoxTextPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessibleClass is a wrapper around the C record GtkContainerAccessibleClass.
type ContainerAccessibleClass struct {
	native *C.GtkContainerAccessibleClass
	// parent_class : record
	// no type for add_gtk
	// no type for remove_gtk
}

func ContainerAccessibleClassNewFromC(u unsafe.Pointer) *ContainerAccessibleClass {
	c := (*C.GtkContainerAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ContainerAccessibleClass{native: c}

	return g
}

func (recv *ContainerAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerAccessibleClass with another ContainerAccessibleClass, and returns true if they represent the same GObject.
func (recv *ContainerAccessibleClass) Equals(other *ContainerAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ContainerAccessiblePrivate is a wrapper around the C record GtkContainerAccessiblePrivate.
type ContainerAccessiblePrivate struct {
	native *C.GtkContainerAccessiblePrivate
}

func ContainerAccessiblePrivateNewFromC(u unsafe.Pointer) *ContainerAccessiblePrivate {
	c := (*C.GtkContainerAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ContainerAccessiblePrivate{native: c}

	return g
}

func (recv *ContainerAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerAccessiblePrivate with another ContainerAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ContainerAccessiblePrivate) Equals(other *ContainerAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ContainerCellAccessibleClass is a wrapper around the C record GtkContainerCellAccessibleClass.
type ContainerCellAccessibleClass struct {
	native *C.GtkContainerCellAccessibleClass
	// parent_class : record
}

func ContainerCellAccessibleClassNewFromC(u unsafe.Pointer) *ContainerCellAccessibleClass {
	c := (*C.GtkContainerCellAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ContainerCellAccessibleClass{native: c}

	return g
}

func (recv *ContainerCellAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerCellAccessibleClass with another ContainerCellAccessibleClass, and returns true if they represent the same GObject.
func (recv *ContainerCellAccessibleClass) Equals(other *ContainerCellAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ContainerCellAccessiblePrivate is a wrapper around the C record GtkContainerCellAccessiblePrivate.
type ContainerCellAccessiblePrivate struct {
	native *C.GtkContainerCellAccessiblePrivate
}

func ContainerCellAccessiblePrivateNewFromC(u unsafe.Pointer) *ContainerCellAccessiblePrivate {
	c := (*C.GtkContainerCellAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ContainerCellAccessiblePrivate{native: c}

	return g
}

func (recv *ContainerCellAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerCellAccessiblePrivate with another ContainerCellAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ContainerCellAccessiblePrivate) Equals(other *ContainerCellAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ContainerClass is a wrapper around the C record GtkContainerClass.
type ContainerClass struct {
	native *C.GtkContainerClass
	// parent_class : record
	// no type for add
	// no type for remove
	// no type for check_resize
	// no type for forall
	// no type for set_focus_child
	// no type for child_type
	// no type for composite_name
	// no type for set_child_property
	// no type for get_child_property
	// no type for get_path_for_child
	// Private : _handle_border_width
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func ContainerClassNewFromC(u unsafe.Pointer) *ContainerClass {
	c := (*C.GtkContainerClass)(u)
	if c == nil {
		return nil
	}

	g := &ContainerClass{native: c}

	return g
}

func (recv *ContainerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerClass with another ContainerClass, and returns true if they represent the same GObject.
func (recv *ContainerClass) Equals(other *ContainerClass) bool {
	return other.ToC() == recv.ToC()
}

// Blacklisted : gtk_container_class_find_child_property

// HandleBorderWidth is a wrapper around the C function gtk_container_class_handle_border_width.
func (recv *ContainerClass) HandleBorderWidth() {
	C.gtk_container_class_handle_border_width((*C.GtkContainerClass)(recv.native))

	return
}

// InstallChildProperty is a wrapper around the C function gtk_container_class_install_child_property.
func (recv *ContainerClass) InstallChildProperty(propertyId uint32, pspec *gobject.ParamSpec) {
	c_property_id := (C.guint)(propertyId)

	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	C.gtk_container_class_install_child_property((*C.GtkContainerClass)(recv.native), c_property_id, c_pspec)

	return
}

// Unsupported : gtk_container_class_list_child_properties : array return type :

// ContainerPrivate is a wrapper around the C record GtkContainerPrivate.
type ContainerPrivate struct {
	native *C.GtkContainerPrivate
}

func ContainerPrivateNewFromC(u unsafe.Pointer) *ContainerPrivate {
	c := (*C.GtkContainerPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ContainerPrivate{native: c}

	return g
}

func (recv *ContainerPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ContainerPrivate with another ContainerPrivate, and returns true if they represent the same GObject.
func (recv *ContainerPrivate) Equals(other *ContainerPrivate) bool {
	return other.ToC() == recv.ToC()
}

// CssProviderClass is a wrapper around the C record GtkCssProviderClass.
type CssProviderClass struct {
	native *C.GtkCssProviderClass
	// parent_class : record
	// no type for parsing_error
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func CssProviderClassNewFromC(u unsafe.Pointer) *CssProviderClass {
	c := (*C.GtkCssProviderClass)(u)
	if c == nil {
		return nil
	}

	g := &CssProviderClass{native: c}

	return g
}

func (recv *CssProviderClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CssProviderClass with another CssProviderClass, and returns true if they represent the same GObject.
func (recv *CssProviderClass) Equals(other *CssProviderClass) bool {
	return other.ToC() == recv.ToC()
}

// CssProviderPrivate is a wrapper around the C record GtkCssProviderPrivate.
type CssProviderPrivate struct {
	native *C.GtkCssProviderPrivate
}

func CssProviderPrivateNewFromC(u unsafe.Pointer) *CssProviderPrivate {
	c := (*C.GtkCssProviderPrivate)(u)
	if c == nil {
		return nil
	}

	g := &CssProviderPrivate{native: c}

	return g
}

func (recv *CssProviderPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this CssProviderPrivate with another CssProviderPrivate, and returns true if they represent the same GObject.
func (recv *CssProviderPrivate) Equals(other *CssProviderPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DialogClass is a wrapper around the C record GtkDialogClass.
type DialogClass struct {
	native *C.GtkDialogClass
	// parent_class : record
	// no type for response
	// no type for close
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func DialogClassNewFromC(u unsafe.Pointer) *DialogClass {
	c := (*C.GtkDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &DialogClass{native: c}

	return g
}

func (recv *DialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DialogClass with another DialogClass, and returns true if they represent the same GObject.
func (recv *DialogClass) Equals(other *DialogClass) bool {
	return other.ToC() == recv.ToC()
}

// DialogPrivate is a wrapper around the C record GtkDialogPrivate.
type DialogPrivate struct {
	native *C.GtkDialogPrivate
}

func DialogPrivateNewFromC(u unsafe.Pointer) *DialogPrivate {
	c := (*C.GtkDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &DialogPrivate{native: c}

	return g
}

func (recv *DialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DialogPrivate with another DialogPrivate, and returns true if they represent the same GObject.
func (recv *DialogPrivate) Equals(other *DialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// DrawingAreaClass is a wrapper around the C record GtkDrawingAreaClass.
type DrawingAreaClass struct {
	native *C.GtkDrawingAreaClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func DrawingAreaClassNewFromC(u unsafe.Pointer) *DrawingAreaClass {
	c := (*C.GtkDrawingAreaClass)(u)
	if c == nil {
		return nil
	}

	g := &DrawingAreaClass{native: c}

	return g
}

func (recv *DrawingAreaClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this DrawingAreaClass with another DrawingAreaClass, and returns true if they represent the same GObject.
func (recv *DrawingAreaClass) Equals(other *DrawingAreaClass) bool {
	return other.ToC() == recv.ToC()
}

// EditableInterface is a wrapper around the C record GtkEditableInterface.
type EditableInterface struct {
	native *C.GtkEditableInterface
	// base_iface : record
	// no type for insert_text
	// no type for delete_text
	// no type for changed
	// no type for do_insert_text
	// no type for do_delete_text
	// no type for get_chars
	// no type for set_selection_bounds
	// no type for get_selection_bounds
	// no type for set_position
	// no type for get_position
}

func EditableInterfaceNewFromC(u unsafe.Pointer) *EditableInterface {
	c := (*C.GtkEditableInterface)(u)
	if c == nil {
		return nil
	}

	g := &EditableInterface{native: c}

	return g
}

func (recv *EditableInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EditableInterface with another EditableInterface, and returns true if they represent the same GObject.
func (recv *EditableInterface) Equals(other *EditableInterface) bool {
	return other.ToC() == recv.ToC()
}

// EntryAccessibleClass is a wrapper around the C record GtkEntryAccessibleClass.
type EntryAccessibleClass struct {
	native *C.GtkEntryAccessibleClass
	// parent_class : record
}

func EntryAccessibleClassNewFromC(u unsafe.Pointer) *EntryAccessibleClass {
	c := (*C.GtkEntryAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &EntryAccessibleClass{native: c}

	return g
}

func (recv *EntryAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryAccessibleClass with another EntryAccessibleClass, and returns true if they represent the same GObject.
func (recv *EntryAccessibleClass) Equals(other *EntryAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// EntryAccessiblePrivate is a wrapper around the C record GtkEntryAccessiblePrivate.
type EntryAccessiblePrivate struct {
	native *C.GtkEntryAccessiblePrivate
}

func EntryAccessiblePrivateNewFromC(u unsafe.Pointer) *EntryAccessiblePrivate {
	c := (*C.GtkEntryAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &EntryAccessiblePrivate{native: c}

	return g
}

func (recv *EntryAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryAccessiblePrivate with another EntryAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *EntryAccessiblePrivate) Equals(other *EntryAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// EntryBufferClass is a wrapper around the C record GtkEntryBufferClass.
type EntryBufferClass struct {
	native *C.GtkEntryBufferClass
	// parent_class : record
	// no type for inserted_text
	// no type for deleted_text
	// no type for get_text
	// no type for get_length
	// no type for insert_text
	// no type for delete_text
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func EntryBufferClassNewFromC(u unsafe.Pointer) *EntryBufferClass {
	c := (*C.GtkEntryBufferClass)(u)
	if c == nil {
		return nil
	}

	g := &EntryBufferClass{native: c}

	return g
}

func (recv *EntryBufferClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryBufferClass with another EntryBufferClass, and returns true if they represent the same GObject.
func (recv *EntryBufferClass) Equals(other *EntryBufferClass) bool {
	return other.ToC() == recv.ToC()
}

// EntryBufferPrivate is a wrapper around the C record GtkEntryBufferPrivate.
type EntryBufferPrivate struct {
	native *C.GtkEntryBufferPrivate
}

func EntryBufferPrivateNewFromC(u unsafe.Pointer) *EntryBufferPrivate {
	c := (*C.GtkEntryBufferPrivate)(u)
	if c == nil {
		return nil
	}

	g := &EntryBufferPrivate{native: c}

	return g
}

func (recv *EntryBufferPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryBufferPrivate with another EntryBufferPrivate, and returns true if they represent the same GObject.
func (recv *EntryBufferPrivate) Equals(other *EntryBufferPrivate) bool {
	return other.ToC() == recv.ToC()
}

// EntryClass is a wrapper around the C record GtkEntryClass.
type EntryClass struct {
	native *C.GtkEntryClass
	// parent_class : record
	// no type for populate_popup
	// no type for activate
	// no type for move_cursor
	// no type for insert_at_cursor
	// no type for delete_from_cursor
	// no type for backspace
	// no type for cut_clipboard
	// no type for copy_clipboard
	// no type for paste_clipboard
	// no type for toggle_overwrite
	// no type for get_text_area_size
	// no type for get_frame_size
	// no type for insert_emoji
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
}

func EntryClassNewFromC(u unsafe.Pointer) *EntryClass {
	c := (*C.GtkEntryClass)(u)
	if c == nil {
		return nil
	}

	g := &EntryClass{native: c}

	return g
}

func (recv *EntryClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryClass with another EntryClass, and returns true if they represent the same GObject.
func (recv *EntryClass) Equals(other *EntryClass) bool {
	return other.ToC() == recv.ToC()
}

// EntryCompletionClass is a wrapper around the C record GtkEntryCompletionClass.
type EntryCompletionClass struct {
	native *C.GtkEntryCompletionClass
	// parent_class : record
	// no type for match_selected
	// no type for action_activated
	// no type for insert_prefix
	// no type for cursor_on_match
	// no type for no_matches
	// no type for _gtk_reserved0
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
}

func EntryCompletionClassNewFromC(u unsafe.Pointer) *EntryCompletionClass {
	c := (*C.GtkEntryCompletionClass)(u)
	if c == nil {
		return nil
	}

	g := &EntryCompletionClass{native: c}

	return g
}

func (recv *EntryCompletionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryCompletionClass with another EntryCompletionClass, and returns true if they represent the same GObject.
func (recv *EntryCompletionClass) Equals(other *EntryCompletionClass) bool {
	return other.ToC() == recv.ToC()
}

// EntryCompletionPrivate is a wrapper around the C record GtkEntryCompletionPrivate.
type EntryCompletionPrivate struct {
	native *C.GtkEntryCompletionPrivate
}

func EntryCompletionPrivateNewFromC(u unsafe.Pointer) *EntryCompletionPrivate {
	c := (*C.GtkEntryCompletionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &EntryCompletionPrivate{native: c}

	return g
}

func (recv *EntryCompletionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryCompletionPrivate with another EntryCompletionPrivate, and returns true if they represent the same GObject.
func (recv *EntryCompletionPrivate) Equals(other *EntryCompletionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// EntryPrivate is a wrapper around the C record GtkEntryPrivate.
type EntryPrivate struct {
	native *C.GtkEntryPrivate
}

func EntryPrivateNewFromC(u unsafe.Pointer) *EntryPrivate {
	c := (*C.GtkEntryPrivate)(u)
	if c == nil {
		return nil
	}

	g := &EntryPrivate{native: c}

	return g
}

func (recv *EntryPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EntryPrivate with another EntryPrivate, and returns true if they represent the same GObject.
func (recv *EntryPrivate) Equals(other *EntryPrivate) bool {
	return other.ToC() == recv.ToC()
}

// EventBoxClass is a wrapper around the C record GtkEventBoxClass.
type EventBoxClass struct {
	native *C.GtkEventBoxClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func EventBoxClassNewFromC(u unsafe.Pointer) *EventBoxClass {
	c := (*C.GtkEventBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &EventBoxClass{native: c}

	return g
}

func (recv *EventBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EventBoxClass with another EventBoxClass, and returns true if they represent the same GObject.
func (recv *EventBoxClass) Equals(other *EventBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// EventBoxPrivate is a wrapper around the C record GtkEventBoxPrivate.
type EventBoxPrivate struct {
	native *C.GtkEventBoxPrivate
}

func EventBoxPrivateNewFromC(u unsafe.Pointer) *EventBoxPrivate {
	c := (*C.GtkEventBoxPrivate)(u)
	if c == nil {
		return nil
	}

	g := &EventBoxPrivate{native: c}

	return g
}

func (recv *EventBoxPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EventBoxPrivate with another EventBoxPrivate, and returns true if they represent the same GObject.
func (recv *EventBoxPrivate) Equals(other *EventBoxPrivate) bool {
	return other.ToC() == recv.ToC()
}

// EventControllerClass is a wrapper around the C record GtkEventControllerClass.
type EventControllerClass struct {
	native *C.GtkEventControllerClass
}

func EventControllerClassNewFromC(u unsafe.Pointer) *EventControllerClass {
	c := (*C.GtkEventControllerClass)(u)
	if c == nil {
		return nil
	}

	g := &EventControllerClass{native: c}

	return g
}

func (recv *EventControllerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this EventControllerClass with another EventControllerClass, and returns true if they represent the same GObject.
func (recv *EventControllerClass) Equals(other *EventControllerClass) bool {
	return other.ToC() == recv.ToC()
}

// ExpanderAccessibleClass is a wrapper around the C record GtkExpanderAccessibleClass.
type ExpanderAccessibleClass struct {
	native *C.GtkExpanderAccessibleClass
	// parent_class : record
}

func ExpanderAccessibleClassNewFromC(u unsafe.Pointer) *ExpanderAccessibleClass {
	c := (*C.GtkExpanderAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ExpanderAccessibleClass{native: c}

	return g
}

func (recv *ExpanderAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ExpanderAccessibleClass with another ExpanderAccessibleClass, and returns true if they represent the same GObject.
func (recv *ExpanderAccessibleClass) Equals(other *ExpanderAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ExpanderAccessiblePrivate is a wrapper around the C record GtkExpanderAccessiblePrivate.
type ExpanderAccessiblePrivate struct {
	native *C.GtkExpanderAccessiblePrivate
}

func ExpanderAccessiblePrivateNewFromC(u unsafe.Pointer) *ExpanderAccessiblePrivate {
	c := (*C.GtkExpanderAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ExpanderAccessiblePrivate{native: c}

	return g
}

func (recv *ExpanderAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ExpanderAccessiblePrivate with another ExpanderAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ExpanderAccessiblePrivate) Equals(other *ExpanderAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ExpanderClass is a wrapper around the C record GtkExpanderClass.
type ExpanderClass struct {
	native *C.GtkExpanderClass
	// parent_class : record
	// no type for activate
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ExpanderClassNewFromC(u unsafe.Pointer) *ExpanderClass {
	c := (*C.GtkExpanderClass)(u)
	if c == nil {
		return nil
	}

	g := &ExpanderClass{native: c}

	return g
}

func (recv *ExpanderClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ExpanderClass with another ExpanderClass, and returns true if they represent the same GObject.
func (recv *ExpanderClass) Equals(other *ExpanderClass) bool {
	return other.ToC() == recv.ToC()
}

// ExpanderPrivate is a wrapper around the C record GtkExpanderPrivate.
type ExpanderPrivate struct {
	native *C.GtkExpanderPrivate
}

func ExpanderPrivateNewFromC(u unsafe.Pointer) *ExpanderPrivate {
	c := (*C.GtkExpanderPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ExpanderPrivate{native: c}

	return g
}

func (recv *ExpanderPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ExpanderPrivate with another ExpanderPrivate, and returns true if they represent the same GObject.
func (recv *ExpanderPrivate) Equals(other *ExpanderPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileChooserButtonClass is a wrapper around the C record GtkFileChooserButtonClass.
type FileChooserButtonClass struct {
	native *C.GtkFileChooserButtonClass
	// parent_class : record
	// no type for file_set
	// Private : __gtk_reserved1
	// Private : __gtk_reserved2
	// Private : __gtk_reserved3
	// Private : __gtk_reserved4
}

func FileChooserButtonClassNewFromC(u unsafe.Pointer) *FileChooserButtonClass {
	c := (*C.GtkFileChooserButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserButtonClass{native: c}

	return g
}

func (recv *FileChooserButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserButtonClass with another FileChooserButtonClass, and returns true if they represent the same GObject.
func (recv *FileChooserButtonClass) Equals(other *FileChooserButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// FileChooserButtonPrivate is a wrapper around the C record GtkFileChooserButtonPrivate.
type FileChooserButtonPrivate struct {
	native *C.GtkFileChooserButtonPrivate
}

func FileChooserButtonPrivateNewFromC(u unsafe.Pointer) *FileChooserButtonPrivate {
	c := (*C.GtkFileChooserButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserButtonPrivate{native: c}

	return g
}

func (recv *FileChooserButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserButtonPrivate with another FileChooserButtonPrivate, and returns true if they represent the same GObject.
func (recv *FileChooserButtonPrivate) Equals(other *FileChooserButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileChooserDialogClass is a wrapper around the C record GtkFileChooserDialogClass.
type FileChooserDialogClass struct {
	native *C.GtkFileChooserDialogClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func FileChooserDialogClassNewFromC(u unsafe.Pointer) *FileChooserDialogClass {
	c := (*C.GtkFileChooserDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserDialogClass{native: c}

	return g
}

func (recv *FileChooserDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserDialogClass with another FileChooserDialogClass, and returns true if they represent the same GObject.
func (recv *FileChooserDialogClass) Equals(other *FileChooserDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// FileChooserDialogPrivate is a wrapper around the C record GtkFileChooserDialogPrivate.
type FileChooserDialogPrivate struct {
	native *C.GtkFileChooserDialogPrivate
}

func FileChooserDialogPrivateNewFromC(u unsafe.Pointer) *FileChooserDialogPrivate {
	c := (*C.GtkFileChooserDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserDialogPrivate{native: c}

	return g
}

func (recv *FileChooserDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserDialogPrivate with another FileChooserDialogPrivate, and returns true if they represent the same GObject.
func (recv *FileChooserDialogPrivate) Equals(other *FileChooserDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileChooserWidgetClass is a wrapper around the C record GtkFileChooserWidgetClass.
type FileChooserWidgetClass struct {
	native *C.GtkFileChooserWidgetClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func FileChooserWidgetClassNewFromC(u unsafe.Pointer) *FileChooserWidgetClass {
	c := (*C.GtkFileChooserWidgetClass)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserWidgetClass{native: c}

	return g
}

func (recv *FileChooserWidgetClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserWidgetClass with another FileChooserWidgetClass, and returns true if they represent the same GObject.
func (recv *FileChooserWidgetClass) Equals(other *FileChooserWidgetClass) bool {
	return other.ToC() == recv.ToC()
}

// FileChooserWidgetPrivate is a wrapper around the C record GtkFileChooserWidgetPrivate.
type FileChooserWidgetPrivate struct {
	native *C.GtkFileChooserWidgetPrivate
}

func FileChooserWidgetPrivateNewFromC(u unsafe.Pointer) *FileChooserWidgetPrivate {
	c := (*C.GtkFileChooserWidgetPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FileChooserWidgetPrivate{native: c}

	return g
}

func (recv *FileChooserWidgetPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileChooserWidgetPrivate with another FileChooserWidgetPrivate, and returns true if they represent the same GObject.
func (recv *FileChooserWidgetPrivate) Equals(other *FileChooserWidgetPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FileFilterInfo is a wrapper around the C record GtkFileFilterInfo.
type FileFilterInfo struct {
	native      *C.GtkFileFilterInfo
	Contains    FileFilterFlags
	Filename    string
	Uri         string
	DisplayName string
	MimeType    string
}

func FileFilterInfoNewFromC(u unsafe.Pointer) *FileFilterInfo {
	c := (*C.GtkFileFilterInfo)(u)
	if c == nil {
		return nil
	}

	g := &FileFilterInfo{
		Contains:    (FileFilterFlags)(c.contains),
		DisplayName: C.GoString(c.display_name),
		Filename:    C.GoString(c.filename),
		MimeType:    C.GoString(c.mime_type),
		Uri:         C.GoString(c.uri),
		native:      c,
	}

	return g
}

func (recv *FileFilterInfo) ToC() unsafe.Pointer {
	recv.native.contains =
		(C.GtkFileFilterFlags)(recv.Contains)
	recv.native.filename =
		C.CString(recv.Filename)
	recv.native.uri =
		C.CString(recv.Uri)
	recv.native.display_name =
		C.CString(recv.DisplayName)
	recv.native.mime_type =
		C.CString(recv.MimeType)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FileFilterInfo with another FileFilterInfo, and returns true if they represent the same GObject.
func (recv *FileFilterInfo) Equals(other *FileFilterInfo) bool {
	return other.ToC() == recv.ToC()
}

// FixedChild is a wrapper around the C record GtkFixedChild.
type FixedChild struct {
	native *C.GtkFixedChild
	// widget : record
	X int32
	Y int32
}

func FixedChildNewFromC(u unsafe.Pointer) *FixedChild {
	c := (*C.GtkFixedChild)(u)
	if c == nil {
		return nil
	}

	g := &FixedChild{
		X:      (int32)(c.x),
		Y:      (int32)(c.y),
		native: c,
	}

	return g
}

func (recv *FixedChild) ToC() unsafe.Pointer {
	recv.native.x =
		(C.gint)(recv.X)
	recv.native.y =
		(C.gint)(recv.Y)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FixedChild with another FixedChild, and returns true if they represent the same GObject.
func (recv *FixedChild) Equals(other *FixedChild) bool {
	return other.ToC() == recv.ToC()
}

// FixedClass is a wrapper around the C record GtkFixedClass.
type FixedClass struct {
	native *C.GtkFixedClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func FixedClassNewFromC(u unsafe.Pointer) *FixedClass {
	c := (*C.GtkFixedClass)(u)
	if c == nil {
		return nil
	}

	g := &FixedClass{native: c}

	return g
}

func (recv *FixedClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FixedClass with another FixedClass, and returns true if they represent the same GObject.
func (recv *FixedClass) Equals(other *FixedClass) bool {
	return other.ToC() == recv.ToC()
}

// FixedPrivate is a wrapper around the C record GtkFixedPrivate.
type FixedPrivate struct {
	native *C.GtkFixedPrivate
}

func FixedPrivateNewFromC(u unsafe.Pointer) *FixedPrivate {
	c := (*C.GtkFixedPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FixedPrivate{native: c}

	return g
}

func (recv *FixedPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FixedPrivate with another FixedPrivate, and returns true if they represent the same GObject.
func (recv *FixedPrivate) Equals(other *FixedPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FlowBoxAccessibleClass is a wrapper around the C record GtkFlowBoxAccessibleClass.
type FlowBoxAccessibleClass struct {
	native *C.GtkFlowBoxAccessibleClass
	// parent_class : record
}

func FlowBoxAccessibleClassNewFromC(u unsafe.Pointer) *FlowBoxAccessibleClass {
	c := (*C.GtkFlowBoxAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxAccessibleClass{native: c}

	return g
}

func (recv *FlowBoxAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxAccessibleClass with another FlowBoxAccessibleClass, and returns true if they represent the same GObject.
func (recv *FlowBoxAccessibleClass) Equals(other *FlowBoxAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// FlowBoxAccessiblePrivate is a wrapper around the C record GtkFlowBoxAccessiblePrivate.
type FlowBoxAccessiblePrivate struct {
	native *C.GtkFlowBoxAccessiblePrivate
}

func FlowBoxAccessiblePrivateNewFromC(u unsafe.Pointer) *FlowBoxAccessiblePrivate {
	c := (*C.GtkFlowBoxAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxAccessiblePrivate{native: c}

	return g
}

func (recv *FlowBoxAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxAccessiblePrivate with another FlowBoxAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *FlowBoxAccessiblePrivate) Equals(other *FlowBoxAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// FlowBoxChildAccessibleClass is a wrapper around the C record GtkFlowBoxChildAccessibleClass.
type FlowBoxChildAccessibleClass struct {
	native *C.GtkFlowBoxChildAccessibleClass
	// parent_class : record
}

func FlowBoxChildAccessibleClassNewFromC(u unsafe.Pointer) *FlowBoxChildAccessibleClass {
	c := (*C.GtkFlowBoxChildAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChildAccessibleClass{native: c}

	return g
}

func (recv *FlowBoxChildAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxChildAccessibleClass with another FlowBoxChildAccessibleClass, and returns true if they represent the same GObject.
func (recv *FlowBoxChildAccessibleClass) Equals(other *FlowBoxChildAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// FlowBoxChildClass is a wrapper around the C record GtkFlowBoxChildClass.
type FlowBoxChildClass struct {
	native *C.GtkFlowBoxChildClass
	// parent_class : record
	// no type for activate
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
}

func FlowBoxChildClassNewFromC(u unsafe.Pointer) *FlowBoxChildClass {
	c := (*C.GtkFlowBoxChildClass)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxChildClass{native: c}

	return g
}

func (recv *FlowBoxChildClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxChildClass with another FlowBoxChildClass, and returns true if they represent the same GObject.
func (recv *FlowBoxChildClass) Equals(other *FlowBoxChildClass) bool {
	return other.ToC() == recv.ToC()
}

// FlowBoxClass is a wrapper around the C record GtkFlowBoxClass.
type FlowBoxClass struct {
	native *C.GtkFlowBoxClass
	// parent_class : record
	// no type for child_activated
	// no type for selected_children_changed
	// no type for activate_cursor_child
	// no type for toggle_cursor_child
	// no type for move_cursor
	// no type for select_all
	// no type for unselect_all
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
}

func FlowBoxClassNewFromC(u unsafe.Pointer) *FlowBoxClass {
	c := (*C.GtkFlowBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &FlowBoxClass{native: c}

	return g
}

func (recv *FlowBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FlowBoxClass with another FlowBoxClass, and returns true if they represent the same GObject.
func (recv *FlowBoxClass) Equals(other *FlowBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// FontButtonClass is a wrapper around the C record GtkFontButtonClass.
type FontButtonClass struct {
	native *C.GtkFontButtonClass
	// parent_class : record
	// no type for font_set
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func FontButtonClassNewFromC(u unsafe.Pointer) *FontButtonClass {
	c := (*C.GtkFontButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &FontButtonClass{native: c}

	return g
}

func (recv *FontButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontButtonClass with another FontButtonClass, and returns true if they represent the same GObject.
func (recv *FontButtonClass) Equals(other *FontButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// FontButtonPrivate is a wrapper around the C record GtkFontButtonPrivate.
type FontButtonPrivate struct {
	native *C.GtkFontButtonPrivate
}

func FontButtonPrivateNewFromC(u unsafe.Pointer) *FontButtonPrivate {
	c := (*C.GtkFontButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FontButtonPrivate{native: c}

	return g
}

func (recv *FontButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontButtonPrivate with another FontButtonPrivate, and returns true if they represent the same GObject.
func (recv *FontButtonPrivate) Equals(other *FontButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FontChooserDialogClass is a wrapper around the C record GtkFontChooserDialogClass.
type FontChooserDialogClass struct {
	native *C.GtkFontChooserDialogClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func FontChooserDialogClassNewFromC(u unsafe.Pointer) *FontChooserDialogClass {
	c := (*C.GtkFontChooserDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserDialogClass{native: c}

	return g
}

func (recv *FontChooserDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserDialogClass with another FontChooserDialogClass, and returns true if they represent the same GObject.
func (recv *FontChooserDialogClass) Equals(other *FontChooserDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// FontChooserDialogPrivate is a wrapper around the C record GtkFontChooserDialogPrivate.
type FontChooserDialogPrivate struct {
	native *C.GtkFontChooserDialogPrivate
}

func FontChooserDialogPrivateNewFromC(u unsafe.Pointer) *FontChooserDialogPrivate {
	c := (*C.GtkFontChooserDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserDialogPrivate{native: c}

	return g
}

func (recv *FontChooserDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserDialogPrivate with another FontChooserDialogPrivate, and returns true if they represent the same GObject.
func (recv *FontChooserDialogPrivate) Equals(other *FontChooserDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FontChooserIface is a wrapper around the C record GtkFontChooserIface.
type FontChooserIface struct {
	native *C.GtkFontChooserIface
	// base_iface : record
	// no type for get_font_family
	// no type for get_font_face
	// no type for get_font_size
	// no type for set_filter_func
	// no type for font_activated
	// no type for set_font_map
	// no type for get_font_map
	// no type for padding
}

func FontChooserIfaceNewFromC(u unsafe.Pointer) *FontChooserIface {
	c := (*C.GtkFontChooserIface)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserIface{native: c}

	return g
}

func (recv *FontChooserIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserIface with another FontChooserIface, and returns true if they represent the same GObject.
func (recv *FontChooserIface) Equals(other *FontChooserIface) bool {
	return other.ToC() == recv.ToC()
}

// FontChooserWidgetClass is a wrapper around the C record GtkFontChooserWidgetClass.
type FontChooserWidgetClass struct {
	native *C.GtkFontChooserWidgetClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func FontChooserWidgetClassNewFromC(u unsafe.Pointer) *FontChooserWidgetClass {
	c := (*C.GtkFontChooserWidgetClass)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserWidgetClass{native: c}

	return g
}

func (recv *FontChooserWidgetClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserWidgetClass with another FontChooserWidgetClass, and returns true if they represent the same GObject.
func (recv *FontChooserWidgetClass) Equals(other *FontChooserWidgetClass) bool {
	return other.ToC() == recv.ToC()
}

// FontChooserWidgetPrivate is a wrapper around the C record GtkFontChooserWidgetPrivate.
type FontChooserWidgetPrivate struct {
	native *C.GtkFontChooserWidgetPrivate
}

func FontChooserWidgetPrivateNewFromC(u unsafe.Pointer) *FontChooserWidgetPrivate {
	c := (*C.GtkFontChooserWidgetPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FontChooserWidgetPrivate{native: c}

	return g
}

func (recv *FontChooserWidgetPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontChooserWidgetPrivate with another FontChooserWidgetPrivate, and returns true if they represent the same GObject.
func (recv *FontChooserWidgetPrivate) Equals(other *FontChooserWidgetPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FontSelectionClass is a wrapper around the C record GtkFontSelectionClass.
type FontSelectionClass struct {
	native *C.GtkFontSelectionClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func FontSelectionClassNewFromC(u unsafe.Pointer) *FontSelectionClass {
	c := (*C.GtkFontSelectionClass)(u)
	if c == nil {
		return nil
	}

	g := &FontSelectionClass{native: c}

	return g
}

func (recv *FontSelectionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontSelectionClass with another FontSelectionClass, and returns true if they represent the same GObject.
func (recv *FontSelectionClass) Equals(other *FontSelectionClass) bool {
	return other.ToC() == recv.ToC()
}

// FontSelectionDialogClass is a wrapper around the C record GtkFontSelectionDialogClass.
type FontSelectionDialogClass struct {
	native *C.GtkFontSelectionDialogClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func FontSelectionDialogClassNewFromC(u unsafe.Pointer) *FontSelectionDialogClass {
	c := (*C.GtkFontSelectionDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &FontSelectionDialogClass{native: c}

	return g
}

func (recv *FontSelectionDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontSelectionDialogClass with another FontSelectionDialogClass, and returns true if they represent the same GObject.
func (recv *FontSelectionDialogClass) Equals(other *FontSelectionDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// FontSelectionDialogPrivate is a wrapper around the C record GtkFontSelectionDialogPrivate.
type FontSelectionDialogPrivate struct {
	native *C.GtkFontSelectionDialogPrivate
}

func FontSelectionDialogPrivateNewFromC(u unsafe.Pointer) *FontSelectionDialogPrivate {
	c := (*C.GtkFontSelectionDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FontSelectionDialogPrivate{native: c}

	return g
}

func (recv *FontSelectionDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontSelectionDialogPrivate with another FontSelectionDialogPrivate, and returns true if they represent the same GObject.
func (recv *FontSelectionDialogPrivate) Equals(other *FontSelectionDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FontSelectionPrivate is a wrapper around the C record GtkFontSelectionPrivate.
type FontSelectionPrivate struct {
	native *C.GtkFontSelectionPrivate
}

func FontSelectionPrivateNewFromC(u unsafe.Pointer) *FontSelectionPrivate {
	c := (*C.GtkFontSelectionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &FontSelectionPrivate{native: c}

	return g
}

func (recv *FontSelectionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FontSelectionPrivate with another FontSelectionPrivate, and returns true if they represent the same GObject.
func (recv *FontSelectionPrivate) Equals(other *FontSelectionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// FrameAccessibleClass is a wrapper around the C record GtkFrameAccessibleClass.
type FrameAccessibleClass struct {
	native *C.GtkFrameAccessibleClass
	// parent_class : record
}

func FrameAccessibleClassNewFromC(u unsafe.Pointer) *FrameAccessibleClass {
	c := (*C.GtkFrameAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &FrameAccessibleClass{native: c}

	return g
}

func (recv *FrameAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FrameAccessibleClass with another FrameAccessibleClass, and returns true if they represent the same GObject.
func (recv *FrameAccessibleClass) Equals(other *FrameAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// FrameAccessiblePrivate is a wrapper around the C record GtkFrameAccessiblePrivate.
type FrameAccessiblePrivate struct {
	native *C.GtkFrameAccessiblePrivate
}

func FrameAccessiblePrivateNewFromC(u unsafe.Pointer) *FrameAccessiblePrivate {
	c := (*C.GtkFrameAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &FrameAccessiblePrivate{native: c}

	return g
}

func (recv *FrameAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FrameAccessiblePrivate with another FrameAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *FrameAccessiblePrivate) Equals(other *FrameAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// FrameClass is a wrapper around the C record GtkFrameClass.
type FrameClass struct {
	native *C.GtkFrameClass
	// parent_class : record
	// no type for compute_child_allocation
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func FrameClassNewFromC(u unsafe.Pointer) *FrameClass {
	c := (*C.GtkFrameClass)(u)
	if c == nil {
		return nil
	}

	g := &FrameClass{native: c}

	return g
}

func (recv *FrameClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FrameClass with another FrameClass, and returns true if they represent the same GObject.
func (recv *FrameClass) Equals(other *FrameClass) bool {
	return other.ToC() == recv.ToC()
}

// FramePrivate is a wrapper around the C record GtkFramePrivate.
type FramePrivate struct {
	native *C.GtkFramePrivate
}

func FramePrivateNewFromC(u unsafe.Pointer) *FramePrivate {
	c := (*C.GtkFramePrivate)(u)
	if c == nil {
		return nil
	}

	g := &FramePrivate{native: c}

	return g
}

func (recv *FramePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this FramePrivate with another FramePrivate, and returns true if they represent the same GObject.
func (recv *FramePrivate) Equals(other *FramePrivate) bool {
	return other.ToC() == recv.ToC()
}

// GestureClass is a wrapper around the C record GtkGestureClass.
type GestureClass struct {
	native *C.GtkGestureClass
}

func GestureClassNewFromC(u unsafe.Pointer) *GestureClass {
	c := (*C.GtkGestureClass)(u)
	if c == nil {
		return nil
	}

	g := &GestureClass{native: c}

	return g
}

func (recv *GestureClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureClass with another GestureClass, and returns true if they represent the same GObject.
func (recv *GestureClass) Equals(other *GestureClass) bool {
	return other.ToC() == recv.ToC()
}

// GestureDragClass is a wrapper around the C record GtkGestureDragClass.
type GestureDragClass struct {
	native *C.GtkGestureDragClass
}

func GestureDragClassNewFromC(u unsafe.Pointer) *GestureDragClass {
	c := (*C.GtkGestureDragClass)(u)
	if c == nil {
		return nil
	}

	g := &GestureDragClass{native: c}

	return g
}

func (recv *GestureDragClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureDragClass with another GestureDragClass, and returns true if they represent the same GObject.
func (recv *GestureDragClass) Equals(other *GestureDragClass) bool {
	return other.ToC() == recv.ToC()
}

// GestureLongPressClass is a wrapper around the C record GtkGestureLongPressClass.
type GestureLongPressClass struct {
	native *C.GtkGestureLongPressClass
}

func GestureLongPressClassNewFromC(u unsafe.Pointer) *GestureLongPressClass {
	c := (*C.GtkGestureLongPressClass)(u)
	if c == nil {
		return nil
	}

	g := &GestureLongPressClass{native: c}

	return g
}

func (recv *GestureLongPressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureLongPressClass with another GestureLongPressClass, and returns true if they represent the same GObject.
func (recv *GestureLongPressClass) Equals(other *GestureLongPressClass) bool {
	return other.ToC() == recv.ToC()
}

// GestureMultiPressClass is a wrapper around the C record GtkGestureMultiPressClass.
type GestureMultiPressClass struct {
	native *C.GtkGestureMultiPressClass
}

func GestureMultiPressClassNewFromC(u unsafe.Pointer) *GestureMultiPressClass {
	c := (*C.GtkGestureMultiPressClass)(u)
	if c == nil {
		return nil
	}

	g := &GestureMultiPressClass{native: c}

	return g
}

func (recv *GestureMultiPressClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureMultiPressClass with another GestureMultiPressClass, and returns true if they represent the same GObject.
func (recv *GestureMultiPressClass) Equals(other *GestureMultiPressClass) bool {
	return other.ToC() == recv.ToC()
}

// GesturePanClass is a wrapper around the C record GtkGesturePanClass.
type GesturePanClass struct {
	native *C.GtkGesturePanClass
}

func GesturePanClassNewFromC(u unsafe.Pointer) *GesturePanClass {
	c := (*C.GtkGesturePanClass)(u)
	if c == nil {
		return nil
	}

	g := &GesturePanClass{native: c}

	return g
}

func (recv *GesturePanClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GesturePanClass with another GesturePanClass, and returns true if they represent the same GObject.
func (recv *GesturePanClass) Equals(other *GesturePanClass) bool {
	return other.ToC() == recv.ToC()
}

// GestureRotateClass is a wrapper around the C record GtkGestureRotateClass.
type GestureRotateClass struct {
	native *C.GtkGestureRotateClass
}

func GestureRotateClassNewFromC(u unsafe.Pointer) *GestureRotateClass {
	c := (*C.GtkGestureRotateClass)(u)
	if c == nil {
		return nil
	}

	g := &GestureRotateClass{native: c}

	return g
}

func (recv *GestureRotateClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureRotateClass with another GestureRotateClass, and returns true if they represent the same GObject.
func (recv *GestureRotateClass) Equals(other *GestureRotateClass) bool {
	return other.ToC() == recv.ToC()
}

// GestureSingleClass is a wrapper around the C record GtkGestureSingleClass.
type GestureSingleClass struct {
	native *C.GtkGestureSingleClass
}

func GestureSingleClassNewFromC(u unsafe.Pointer) *GestureSingleClass {
	c := (*C.GtkGestureSingleClass)(u)
	if c == nil {
		return nil
	}

	g := &GestureSingleClass{native: c}

	return g
}

func (recv *GestureSingleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureSingleClass with another GestureSingleClass, and returns true if they represent the same GObject.
func (recv *GestureSingleClass) Equals(other *GestureSingleClass) bool {
	return other.ToC() == recv.ToC()
}

// GestureSwipeClass is a wrapper around the C record GtkGestureSwipeClass.
type GestureSwipeClass struct {
	native *C.GtkGestureSwipeClass
}

func GestureSwipeClassNewFromC(u unsafe.Pointer) *GestureSwipeClass {
	c := (*C.GtkGestureSwipeClass)(u)
	if c == nil {
		return nil
	}

	g := &GestureSwipeClass{native: c}

	return g
}

func (recv *GestureSwipeClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureSwipeClass with another GestureSwipeClass, and returns true if they represent the same GObject.
func (recv *GestureSwipeClass) Equals(other *GestureSwipeClass) bool {
	return other.ToC() == recv.ToC()
}

// GestureZoomClass is a wrapper around the C record GtkGestureZoomClass.
type GestureZoomClass struct {
	native *C.GtkGestureZoomClass
}

func GestureZoomClassNewFromC(u unsafe.Pointer) *GestureZoomClass {
	c := (*C.GtkGestureZoomClass)(u)
	if c == nil {
		return nil
	}

	g := &GestureZoomClass{native: c}

	return g
}

func (recv *GestureZoomClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GestureZoomClass with another GestureZoomClass, and returns true if they represent the same GObject.
func (recv *GestureZoomClass) Equals(other *GestureZoomClass) bool {
	return other.ToC() == recv.ToC()
}

// Gradient is a wrapper around the C record GtkGradient.
type Gradient struct {
	native *C.GtkGradient
}

func GradientNewFromC(u unsafe.Pointer) *Gradient {
	c := (*C.GtkGradient)(u)
	if c == nil {
		return nil
	}

	g := &Gradient{native: c}

	return g
}

func (recv *Gradient) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Gradient with another Gradient, and returns true if they represent the same GObject.
func (recv *Gradient) Equals(other *Gradient) bool {
	return other.ToC() == recv.ToC()
}

// ResolveForContext is a wrapper around the C function gtk_gradient_resolve_for_context.
func (recv *Gradient) ResolveForContext(context *StyleContext) *cairo.Pattern {
	c_context := (*C.GtkStyleContext)(C.NULL)
	if context != nil {
		c_context = (*C.GtkStyleContext)(context.ToC())
	}

	retC := C.gtk_gradient_resolve_for_context((*C.GtkGradient)(recv.native), c_context)
	retGo := cairo.PatternNewFromC(unsafe.Pointer(retC))

	return retGo
}

// ToString is a wrapper around the C function gtk_gradient_to_string.
func (recv *Gradient) ToString() string {
	retC := C.gtk_gradient_to_string((*C.GtkGradient)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GridClass is a wrapper around the C record GtkGridClass.
type GridClass struct {
	native *C.GtkGridClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func GridClassNewFromC(u unsafe.Pointer) *GridClass {
	c := (*C.GtkGridClass)(u)
	if c == nil {
		return nil
	}

	g := &GridClass{native: c}

	return g
}

func (recv *GridClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GridClass with another GridClass, and returns true if they represent the same GObject.
func (recv *GridClass) Equals(other *GridClass) bool {
	return other.ToC() == recv.ToC()
}

// GridPrivate is a wrapper around the C record GtkGridPrivate.
type GridPrivate struct {
	native *C.GtkGridPrivate
}

func GridPrivateNewFromC(u unsafe.Pointer) *GridPrivate {
	c := (*C.GtkGridPrivate)(u)
	if c == nil {
		return nil
	}

	g := &GridPrivate{native: c}

	return g
}

func (recv *GridPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this GridPrivate with another GridPrivate, and returns true if they represent the same GObject.
func (recv *GridPrivate) Equals(other *GridPrivate) bool {
	return other.ToC() == recv.ToC()
}

// HBoxClass is a wrapper around the C record GtkHBoxClass.
type HBoxClass struct {
	native *C.GtkHBoxClass
	// parent_class : record
}

func HBoxClassNewFromC(u unsafe.Pointer) *HBoxClass {
	c := (*C.GtkHBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &HBoxClass{native: c}

	return g
}

func (recv *HBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HBoxClass with another HBoxClass, and returns true if they represent the same GObject.
func (recv *HBoxClass) Equals(other *HBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// HButtonBoxClass is a wrapper around the C record GtkHButtonBoxClass.
type HButtonBoxClass struct {
	native *C.GtkHButtonBoxClass
	// parent_class : record
}

func HButtonBoxClassNewFromC(u unsafe.Pointer) *HButtonBoxClass {
	c := (*C.GtkHButtonBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &HButtonBoxClass{native: c}

	return g
}

func (recv *HButtonBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HButtonBoxClass with another HButtonBoxClass, and returns true if they represent the same GObject.
func (recv *HButtonBoxClass) Equals(other *HButtonBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// HPanedClass is a wrapper around the C record GtkHPanedClass.
type HPanedClass struct {
	native *C.GtkHPanedClass
	// parent_class : record
}

func HPanedClassNewFromC(u unsafe.Pointer) *HPanedClass {
	c := (*C.GtkHPanedClass)(u)
	if c == nil {
		return nil
	}

	g := &HPanedClass{native: c}

	return g
}

func (recv *HPanedClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HPanedClass with another HPanedClass, and returns true if they represent the same GObject.
func (recv *HPanedClass) Equals(other *HPanedClass) bool {
	return other.ToC() == recv.ToC()
}

// HSVClass is a wrapper around the C record GtkHSVClass.
type HSVClass struct {
	native *C.GtkHSVClass
	// parent_class : record
	// no type for changed
	// no type for move
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func HSVClassNewFromC(u unsafe.Pointer) *HSVClass {
	c := (*C.GtkHSVClass)(u)
	if c == nil {
		return nil
	}

	g := &HSVClass{native: c}

	return g
}

func (recv *HSVClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HSVClass with another HSVClass, and returns true if they represent the same GObject.
func (recv *HSVClass) Equals(other *HSVClass) bool {
	return other.ToC() == recv.ToC()
}

// HSVPrivate is a wrapper around the C record GtkHSVPrivate.
type HSVPrivate struct {
	native *C.GtkHSVPrivate
}

func HSVPrivateNewFromC(u unsafe.Pointer) *HSVPrivate {
	c := (*C.GtkHSVPrivate)(u)
	if c == nil {
		return nil
	}

	g := &HSVPrivate{native: c}

	return g
}

func (recv *HSVPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HSVPrivate with another HSVPrivate, and returns true if they represent the same GObject.
func (recv *HSVPrivate) Equals(other *HSVPrivate) bool {
	return other.ToC() == recv.ToC()
}

// HScaleClass is a wrapper around the C record GtkHScaleClass.
type HScaleClass struct {
	native *C.GtkHScaleClass
	// parent_class : record
}

func HScaleClassNewFromC(u unsafe.Pointer) *HScaleClass {
	c := (*C.GtkHScaleClass)(u)
	if c == nil {
		return nil
	}

	g := &HScaleClass{native: c}

	return g
}

func (recv *HScaleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HScaleClass with another HScaleClass, and returns true if they represent the same GObject.
func (recv *HScaleClass) Equals(other *HScaleClass) bool {
	return other.ToC() == recv.ToC()
}

// HScrollbarClass is a wrapper around the C record GtkHScrollbarClass.
type HScrollbarClass struct {
	native *C.GtkHScrollbarClass
	// parent_class : record
}

func HScrollbarClassNewFromC(u unsafe.Pointer) *HScrollbarClass {
	c := (*C.GtkHScrollbarClass)(u)
	if c == nil {
		return nil
	}

	g := &HScrollbarClass{native: c}

	return g
}

func (recv *HScrollbarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HScrollbarClass with another HScrollbarClass, and returns true if they represent the same GObject.
func (recv *HScrollbarClass) Equals(other *HScrollbarClass) bool {
	return other.ToC() == recv.ToC()
}

// HSeparatorClass is a wrapper around the C record GtkHSeparatorClass.
type HSeparatorClass struct {
	native *C.GtkHSeparatorClass
	// parent_class : record
}

func HSeparatorClassNewFromC(u unsafe.Pointer) *HSeparatorClass {
	c := (*C.GtkHSeparatorClass)(u)
	if c == nil {
		return nil
	}

	g := &HSeparatorClass{native: c}

	return g
}

func (recv *HSeparatorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HSeparatorClass with another HSeparatorClass, and returns true if they represent the same GObject.
func (recv *HSeparatorClass) Equals(other *HSeparatorClass) bool {
	return other.ToC() == recv.ToC()
}

// HandleBoxClass is a wrapper around the C record GtkHandleBoxClass.
type HandleBoxClass struct {
	native *C.GtkHandleBoxClass
	// parent_class : record
	// no type for child_attached
	// no type for child_detached
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func HandleBoxClassNewFromC(u unsafe.Pointer) *HandleBoxClass {
	c := (*C.GtkHandleBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &HandleBoxClass{native: c}

	return g
}

func (recv *HandleBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HandleBoxClass with another HandleBoxClass, and returns true if they represent the same GObject.
func (recv *HandleBoxClass) Equals(other *HandleBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// HandleBoxPrivate is a wrapper around the C record GtkHandleBoxPrivate.
type HandleBoxPrivate struct {
	native *C.GtkHandleBoxPrivate
}

func HandleBoxPrivateNewFromC(u unsafe.Pointer) *HandleBoxPrivate {
	c := (*C.GtkHandleBoxPrivate)(u)
	if c == nil {
		return nil
	}

	g := &HandleBoxPrivate{native: c}

	return g
}

func (recv *HandleBoxPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HandleBoxPrivate with another HandleBoxPrivate, and returns true if they represent the same GObject.
func (recv *HandleBoxPrivate) Equals(other *HandleBoxPrivate) bool {
	return other.ToC() == recv.ToC()
}

// HeaderBarClass is a wrapper around the C record GtkHeaderBarClass.
type HeaderBarClass struct {
	native *C.GtkHeaderBarClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func HeaderBarClassNewFromC(u unsafe.Pointer) *HeaderBarClass {
	c := (*C.GtkHeaderBarClass)(u)
	if c == nil {
		return nil
	}

	g := &HeaderBarClass{native: c}

	return g
}

func (recv *HeaderBarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HeaderBarClass with another HeaderBarClass, and returns true if they represent the same GObject.
func (recv *HeaderBarClass) Equals(other *HeaderBarClass) bool {
	return other.ToC() == recv.ToC()
}

// HeaderBarPrivate is a wrapper around the C record GtkHeaderBarPrivate.
type HeaderBarPrivate struct {
	native *C.GtkHeaderBarPrivate
}

func HeaderBarPrivateNewFromC(u unsafe.Pointer) *HeaderBarPrivate {
	c := (*C.GtkHeaderBarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &HeaderBarPrivate{native: c}

	return g
}

func (recv *HeaderBarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this HeaderBarPrivate with another HeaderBarPrivate, and returns true if they represent the same GObject.
func (recv *HeaderBarPrivate) Equals(other *HeaderBarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// IMContextClass is a wrapper around the C record GtkIMContextClass.
type IMContextClass struct {
	native *C.GtkIMContextClass
	// Private : parent_class
	// no type for preedit_start
	// no type for preedit_end
	// no type for preedit_changed
	// no type for commit
	// no type for retrieve_surrounding
	// no type for delete_surrounding
	// no type for set_client_window
	// no type for get_preedit_string
	// no type for filter_keypress
	// no type for focus_in
	// no type for focus_out
	// no type for reset
	// no type for set_cursor_location
	// no type for set_use_preedit
	// no type for set_surrounding
	// no type for get_surrounding
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
}

func IMContextClassNewFromC(u unsafe.Pointer) *IMContextClass {
	c := (*C.GtkIMContextClass)(u)
	if c == nil {
		return nil
	}

	g := &IMContextClass{native: c}

	return g
}

func (recv *IMContextClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMContextClass with another IMContextClass, and returns true if they represent the same GObject.
func (recv *IMContextClass) Equals(other *IMContextClass) bool {
	return other.ToC() == recv.ToC()
}

// IMContextInfo is a wrapper around the C record GtkIMContextInfo.
type IMContextInfo struct {
	native         *C.GtkIMContextInfo
	ContextId      string
	ContextName    string
	Domain         string
	DomainDirname  string
	DefaultLocales string
}

func IMContextInfoNewFromC(u unsafe.Pointer) *IMContextInfo {
	c := (*C.GtkIMContextInfo)(u)
	if c == nil {
		return nil
	}

	g := &IMContextInfo{
		ContextId:      C.GoString(c.context_id),
		ContextName:    C.GoString(c.context_name),
		DefaultLocales: C.GoString(c.default_locales),
		Domain:         C.GoString(c.domain),
		DomainDirname:  C.GoString(c.domain_dirname),
		native:         c,
	}

	return g
}

func (recv *IMContextInfo) ToC() unsafe.Pointer {
	recv.native.context_id =
		C.CString(recv.ContextId)
	recv.native.context_name =
		C.CString(recv.ContextName)
	recv.native.domain =
		C.CString(recv.Domain)
	recv.native.domain_dirname =
		C.CString(recv.DomainDirname)
	recv.native.default_locales =
		C.CString(recv.DefaultLocales)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMContextInfo with another IMContextInfo, and returns true if they represent the same GObject.
func (recv *IMContextInfo) Equals(other *IMContextInfo) bool {
	return other.ToC() == recv.ToC()
}

// IMContextSimpleClass is a wrapper around the C record GtkIMContextSimpleClass.
type IMContextSimpleClass struct {
	native *C.GtkIMContextSimpleClass
	// parent_class : record
}

func IMContextSimpleClassNewFromC(u unsafe.Pointer) *IMContextSimpleClass {
	c := (*C.GtkIMContextSimpleClass)(u)
	if c == nil {
		return nil
	}

	g := &IMContextSimpleClass{native: c}

	return g
}

func (recv *IMContextSimpleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMContextSimpleClass with another IMContextSimpleClass, and returns true if they represent the same GObject.
func (recv *IMContextSimpleClass) Equals(other *IMContextSimpleClass) bool {
	return other.ToC() == recv.ToC()
}

// IMContextSimplePrivate is a wrapper around the C record GtkIMContextSimplePrivate.
type IMContextSimplePrivate struct {
	native *C.GtkIMContextSimplePrivate
}

func IMContextSimplePrivateNewFromC(u unsafe.Pointer) *IMContextSimplePrivate {
	c := (*C.GtkIMContextSimplePrivate)(u)
	if c == nil {
		return nil
	}

	g := &IMContextSimplePrivate{native: c}

	return g
}

func (recv *IMContextSimplePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMContextSimplePrivate with another IMContextSimplePrivate, and returns true if they represent the same GObject.
func (recv *IMContextSimplePrivate) Equals(other *IMContextSimplePrivate) bool {
	return other.ToC() == recv.ToC()
}

// IMMulticontextClass is a wrapper around the C record GtkIMMulticontextClass.
type IMMulticontextClass struct {
	native *C.GtkIMMulticontextClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func IMMulticontextClassNewFromC(u unsafe.Pointer) *IMMulticontextClass {
	c := (*C.GtkIMMulticontextClass)(u)
	if c == nil {
		return nil
	}

	g := &IMMulticontextClass{native: c}

	return g
}

func (recv *IMMulticontextClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMMulticontextClass with another IMMulticontextClass, and returns true if they represent the same GObject.
func (recv *IMMulticontextClass) Equals(other *IMMulticontextClass) bool {
	return other.ToC() == recv.ToC()
}

// IMMulticontextPrivate is a wrapper around the C record GtkIMMulticontextPrivate.
type IMMulticontextPrivate struct {
	native *C.GtkIMMulticontextPrivate
}

func IMMulticontextPrivateNewFromC(u unsafe.Pointer) *IMMulticontextPrivate {
	c := (*C.GtkIMMulticontextPrivate)(u)
	if c == nil {
		return nil
	}

	g := &IMMulticontextPrivate{native: c}

	return g
}

func (recv *IMMulticontextPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IMMulticontextPrivate with another IMMulticontextPrivate, and returns true if they represent the same GObject.
func (recv *IMMulticontextPrivate) Equals(other *IMMulticontextPrivate) bool {
	return other.ToC() == recv.ToC()
}

// IconFactoryClass is a wrapper around the C record GtkIconFactoryClass.
type IconFactoryClass struct {
	native *C.GtkIconFactoryClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func IconFactoryClassNewFromC(u unsafe.Pointer) *IconFactoryClass {
	c := (*C.GtkIconFactoryClass)(u)
	if c == nil {
		return nil
	}

	g := &IconFactoryClass{native: c}

	return g
}

func (recv *IconFactoryClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconFactoryClass with another IconFactoryClass, and returns true if they represent the same GObject.
func (recv *IconFactoryClass) Equals(other *IconFactoryClass) bool {
	return other.ToC() == recv.ToC()
}

// IconFactoryPrivate is a wrapper around the C record GtkIconFactoryPrivate.
type IconFactoryPrivate struct {
	native *C.GtkIconFactoryPrivate
}

func IconFactoryPrivateNewFromC(u unsafe.Pointer) *IconFactoryPrivate {
	c := (*C.GtkIconFactoryPrivate)(u)
	if c == nil {
		return nil
	}

	g := &IconFactoryPrivate{native: c}

	return g
}

func (recv *IconFactoryPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconFactoryPrivate with another IconFactoryPrivate, and returns true if they represent the same GObject.
func (recv *IconFactoryPrivate) Equals(other *IconFactoryPrivate) bool {
	return other.ToC() == recv.ToC()
}

// IconInfoClass is a wrapper around the C record GtkIconInfoClass.
type IconInfoClass struct {
	native *C.GtkIconInfoClass
}

func IconInfoClassNewFromC(u unsafe.Pointer) *IconInfoClass {
	c := (*C.GtkIconInfoClass)(u)
	if c == nil {
		return nil
	}

	g := &IconInfoClass{native: c}

	return g
}

func (recv *IconInfoClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconInfoClass with another IconInfoClass, and returns true if they represent the same GObject.
func (recv *IconInfoClass) Equals(other *IconInfoClass) bool {
	return other.ToC() == recv.ToC()
}

// IconSet is a wrapper around the C record GtkIconSet.
type IconSet struct {
	native *C.GtkIconSet
}

func IconSetNewFromC(u unsafe.Pointer) *IconSet {
	c := (*C.GtkIconSet)(u)
	if c == nil {
		return nil
	}

	g := &IconSet{native: c}

	return g
}

func (recv *IconSet) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconSet with another IconSet, and returns true if they represent the same GObject.
func (recv *IconSet) Equals(other *IconSet) bool {
	return other.ToC() == recv.ToC()
}

// IconSetNew is a wrapper around the C function gtk_icon_set_new.
func IconSetNew() *IconSet {
	retC := C.gtk_icon_set_new()
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// IconSetNewFromPixbuf is a wrapper around the C function gtk_icon_set_new_from_pixbuf.
func IconSetNewFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *IconSet {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	retC := C.gtk_icon_set_new_from_pixbuf(c_pixbuf)
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AddSource is a wrapper around the C function gtk_icon_set_add_source.
func (recv *IconSet) AddSource(source *IconSource) {
	c_source := (*C.GtkIconSource)(C.NULL)
	if source != nil {
		c_source = (*C.GtkIconSource)(source.ToC())
	}

	C.gtk_icon_set_add_source((*C.GtkIconSet)(recv.native), c_source)

	return
}

// Copy is a wrapper around the C function gtk_icon_set_copy.
func (recv *IconSet) Copy() *IconSet {
	retC := C.gtk_icon_set_copy((*C.GtkIconSet)(recv.native))
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_icon_set_get_sizes : unsupported parameter sizes : output array param sizes

// Ref is a wrapper around the C function gtk_icon_set_ref.
func (recv *IconSet) Ref() *IconSet {
	retC := C.gtk_icon_set_ref((*C.GtkIconSet)(recv.native))
	retGo := IconSetNewFromC(unsafe.Pointer(retC))

	return retGo
}

// RenderIcon is a wrapper around the C function gtk_icon_set_render_icon.
func (recv *IconSet) RenderIcon(style *Style, direction TextDirection, state StateType, size IconSize, widget *Widget, detail string) *gdkpixbuf.Pixbuf {
	c_style := (*C.GtkStyle)(C.NULL)
	if style != nil {
		c_style = (*C.GtkStyle)(style.ToC())
	}

	c_direction := (C.GtkTextDirection)(direction)

	c_state := (C.GtkStateType)(state)

	c_size := (C.GtkIconSize)(size)

	c_widget := (*C.GtkWidget)(C.NULL)
	if widget != nil {
		c_widget = (*C.GtkWidget)(widget.ToC())
	}

	c_detail := C.CString(detail)
	defer C.free(unsafe.Pointer(c_detail))

	retC := C.gtk_icon_set_render_icon((*C.GtkIconSet)(recv.native), c_style, c_direction, c_state, c_size, c_widget, c_detail)
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function gtk_icon_set_unref.
func (recv *IconSet) Unref() {
	C.gtk_icon_set_unref((*C.GtkIconSet)(recv.native))

	return
}

// IconSource is a wrapper around the C record GtkIconSource.
type IconSource struct {
	native *C.GtkIconSource
}

func IconSourceNewFromC(u unsafe.Pointer) *IconSource {
	c := (*C.GtkIconSource)(u)
	if c == nil {
		return nil
	}

	g := &IconSource{native: c}

	return g
}

func (recv *IconSource) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconSource with another IconSource, and returns true if they represent the same GObject.
func (recv *IconSource) Equals(other *IconSource) bool {
	return other.ToC() == recv.ToC()
}

// IconSourceNew is a wrapper around the C function gtk_icon_source_new.
func IconSourceNew() *IconSource {
	retC := C.gtk_icon_source_new()
	retGo := IconSourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Copy is a wrapper around the C function gtk_icon_source_copy.
func (recv *IconSource) Copy() *IconSource {
	retC := C.gtk_icon_source_copy((*C.GtkIconSource)(recv.native))
	retGo := IconSourceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_icon_source_free.
func (recv *IconSource) Free() {
	C.gtk_icon_source_free((*C.GtkIconSource)(recv.native))

	return
}

// GetDirection is a wrapper around the C function gtk_icon_source_get_direction.
func (recv *IconSource) GetDirection() TextDirection {
	retC := C.gtk_icon_source_get_direction((*C.GtkIconSource)(recv.native))
	retGo := (TextDirection)(retC)

	return retGo
}

// GetDirectionWildcarded is a wrapper around the C function gtk_icon_source_get_direction_wildcarded.
func (recv *IconSource) GetDirectionWildcarded() bool {
	retC := C.gtk_icon_source_get_direction_wildcarded((*C.GtkIconSource)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetFilename is a wrapper around the C function gtk_icon_source_get_filename.
func (recv *IconSource) GetFilename() string {
	retC := C.gtk_icon_source_get_filename((*C.GtkIconSource)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetIconName is a wrapper around the C function gtk_icon_source_get_icon_name.
func (recv *IconSource) GetIconName() string {
	retC := C.gtk_icon_source_get_icon_name((*C.GtkIconSource)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPixbuf is a wrapper around the C function gtk_icon_source_get_pixbuf.
func (recv *IconSource) GetPixbuf() *gdkpixbuf.Pixbuf {
	retC := C.gtk_icon_source_get_pixbuf((*C.GtkIconSource)(recv.native))
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSize is a wrapper around the C function gtk_icon_source_get_size.
func (recv *IconSource) GetSize() IconSize {
	retC := C.gtk_icon_source_get_size((*C.GtkIconSource)(recv.native))
	retGo := (IconSize)(retC)

	return retGo
}

// GetSizeWildcarded is a wrapper around the C function gtk_icon_source_get_size_wildcarded.
func (recv *IconSource) GetSizeWildcarded() bool {
	retC := C.gtk_icon_source_get_size_wildcarded((*C.GtkIconSource)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetState is a wrapper around the C function gtk_icon_source_get_state.
func (recv *IconSource) GetState() StateType {
	retC := C.gtk_icon_source_get_state((*C.GtkIconSource)(recv.native))
	retGo := (StateType)(retC)

	return retGo
}

// GetStateWildcarded is a wrapper around the C function gtk_icon_source_get_state_wildcarded.
func (recv *IconSource) GetStateWildcarded() bool {
	retC := C.gtk_icon_source_get_state_wildcarded((*C.GtkIconSource)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetDirection is a wrapper around the C function gtk_icon_source_set_direction.
func (recv *IconSource) SetDirection(direction TextDirection) {
	c_direction := (C.GtkTextDirection)(direction)

	C.gtk_icon_source_set_direction((*C.GtkIconSource)(recv.native), c_direction)

	return
}

// SetDirectionWildcarded is a wrapper around the C function gtk_icon_source_set_direction_wildcarded.
func (recv *IconSource) SetDirectionWildcarded(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_icon_source_set_direction_wildcarded((*C.GtkIconSource)(recv.native), c_setting)

	return
}

// SetFilename is a wrapper around the C function gtk_icon_source_set_filename.
func (recv *IconSource) SetFilename(filename string) {
	c_filename := C.CString(filename)
	defer C.free(unsafe.Pointer(c_filename))

	C.gtk_icon_source_set_filename((*C.GtkIconSource)(recv.native), c_filename)

	return
}

// SetIconName is a wrapper around the C function gtk_icon_source_set_icon_name.
func (recv *IconSource) SetIconName(iconName string) {
	c_icon_name := C.CString(iconName)
	defer C.free(unsafe.Pointer(c_icon_name))

	C.gtk_icon_source_set_icon_name((*C.GtkIconSource)(recv.native), c_icon_name)

	return
}

// SetPixbuf is a wrapper around the C function gtk_icon_source_set_pixbuf.
func (recv *IconSource) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	C.gtk_icon_source_set_pixbuf((*C.GtkIconSource)(recv.native), c_pixbuf)

	return
}

// SetSize is a wrapper around the C function gtk_icon_source_set_size.
func (recv *IconSource) SetSize(size IconSize) {
	c_size := (C.GtkIconSize)(size)

	C.gtk_icon_source_set_size((*C.GtkIconSource)(recv.native), c_size)

	return
}

// SetSizeWildcarded is a wrapper around the C function gtk_icon_source_set_size_wildcarded.
func (recv *IconSource) SetSizeWildcarded(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_icon_source_set_size_wildcarded((*C.GtkIconSource)(recv.native), c_setting)

	return
}

// SetState is a wrapper around the C function gtk_icon_source_set_state.
func (recv *IconSource) SetState(state StateType) {
	c_state := (C.GtkStateType)(state)

	C.gtk_icon_source_set_state((*C.GtkIconSource)(recv.native), c_state)

	return
}

// SetStateWildcarded is a wrapper around the C function gtk_icon_source_set_state_wildcarded.
func (recv *IconSource) SetStateWildcarded(setting bool) {
	c_setting :=
		boolToGboolean(setting)

	C.gtk_icon_source_set_state_wildcarded((*C.GtkIconSource)(recv.native), c_setting)

	return
}

// IconThemeClass is a wrapper around the C record GtkIconThemeClass.
type IconThemeClass struct {
	native *C.GtkIconThemeClass
	// parent_class : record
	// no type for changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func IconThemeClassNewFromC(u unsafe.Pointer) *IconThemeClass {
	c := (*C.GtkIconThemeClass)(u)
	if c == nil {
		return nil
	}

	g := &IconThemeClass{native: c}

	return g
}

func (recv *IconThemeClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconThemeClass with another IconThemeClass, and returns true if they represent the same GObject.
func (recv *IconThemeClass) Equals(other *IconThemeClass) bool {
	return other.ToC() == recv.ToC()
}

// IconThemePrivate is a wrapper around the C record GtkIconThemePrivate.
type IconThemePrivate struct {
	native *C.GtkIconThemePrivate
}

func IconThemePrivateNewFromC(u unsafe.Pointer) *IconThemePrivate {
	c := (*C.GtkIconThemePrivate)(u)
	if c == nil {
		return nil
	}

	g := &IconThemePrivate{native: c}

	return g
}

func (recv *IconThemePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconThemePrivate with another IconThemePrivate, and returns true if they represent the same GObject.
func (recv *IconThemePrivate) Equals(other *IconThemePrivate) bool {
	return other.ToC() == recv.ToC()
}

// IconViewAccessibleClass is a wrapper around the C record GtkIconViewAccessibleClass.
type IconViewAccessibleClass struct {
	native *C.GtkIconViewAccessibleClass
	// parent_class : record
}

func IconViewAccessibleClassNewFromC(u unsafe.Pointer) *IconViewAccessibleClass {
	c := (*C.GtkIconViewAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &IconViewAccessibleClass{native: c}

	return g
}

func (recv *IconViewAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconViewAccessibleClass with another IconViewAccessibleClass, and returns true if they represent the same GObject.
func (recv *IconViewAccessibleClass) Equals(other *IconViewAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// IconViewAccessiblePrivate is a wrapper around the C record GtkIconViewAccessiblePrivate.
type IconViewAccessiblePrivate struct {
	native *C.GtkIconViewAccessiblePrivate
}

func IconViewAccessiblePrivateNewFromC(u unsafe.Pointer) *IconViewAccessiblePrivate {
	c := (*C.GtkIconViewAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &IconViewAccessiblePrivate{native: c}

	return g
}

func (recv *IconViewAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconViewAccessiblePrivate with another IconViewAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *IconViewAccessiblePrivate) Equals(other *IconViewAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// IconViewClass is a wrapper around the C record GtkIconViewClass.
type IconViewClass struct {
	native *C.GtkIconViewClass
	// parent_class : record
	// no type for item_activated
	// no type for selection_changed
	// no type for select_all
	// no type for unselect_all
	// no type for select_cursor_item
	// no type for toggle_cursor_item
	// no type for move_cursor
	// no type for activate_cursor_item
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func IconViewClassNewFromC(u unsafe.Pointer) *IconViewClass {
	c := (*C.GtkIconViewClass)(u)
	if c == nil {
		return nil
	}

	g := &IconViewClass{native: c}

	return g
}

func (recv *IconViewClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconViewClass with another IconViewClass, and returns true if they represent the same GObject.
func (recv *IconViewClass) Equals(other *IconViewClass) bool {
	return other.ToC() == recv.ToC()
}

// IconViewPrivate is a wrapper around the C record GtkIconViewPrivate.
type IconViewPrivate struct {
	native *C.GtkIconViewPrivate
}

func IconViewPrivateNewFromC(u unsafe.Pointer) *IconViewPrivate {
	c := (*C.GtkIconViewPrivate)(u)
	if c == nil {
		return nil
	}

	g := &IconViewPrivate{native: c}

	return g
}

func (recv *IconViewPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this IconViewPrivate with another IconViewPrivate, and returns true if they represent the same GObject.
func (recv *IconViewPrivate) Equals(other *IconViewPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ImageAccessibleClass is a wrapper around the C record GtkImageAccessibleClass.
type ImageAccessibleClass struct {
	native *C.GtkImageAccessibleClass
	// parent_class : record
}

func ImageAccessibleClassNewFromC(u unsafe.Pointer) *ImageAccessibleClass {
	c := (*C.GtkImageAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ImageAccessibleClass{native: c}

	return g
}

func (recv *ImageAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageAccessibleClass with another ImageAccessibleClass, and returns true if they represent the same GObject.
func (recv *ImageAccessibleClass) Equals(other *ImageAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ImageAccessiblePrivate is a wrapper around the C record GtkImageAccessiblePrivate.
type ImageAccessiblePrivate struct {
	native *C.GtkImageAccessiblePrivate
}

func ImageAccessiblePrivateNewFromC(u unsafe.Pointer) *ImageAccessiblePrivate {
	c := (*C.GtkImageAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ImageAccessiblePrivate{native: c}

	return g
}

func (recv *ImageAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageAccessiblePrivate with another ImageAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ImageAccessiblePrivate) Equals(other *ImageAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ImageCellAccessibleClass is a wrapper around the C record GtkImageCellAccessibleClass.
type ImageCellAccessibleClass struct {
	native *C.GtkImageCellAccessibleClass
	// parent_class : record
}

func ImageCellAccessibleClassNewFromC(u unsafe.Pointer) *ImageCellAccessibleClass {
	c := (*C.GtkImageCellAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ImageCellAccessibleClass{native: c}

	return g
}

func (recv *ImageCellAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageCellAccessibleClass with another ImageCellAccessibleClass, and returns true if they represent the same GObject.
func (recv *ImageCellAccessibleClass) Equals(other *ImageCellAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ImageCellAccessiblePrivate is a wrapper around the C record GtkImageCellAccessiblePrivate.
type ImageCellAccessiblePrivate struct {
	native *C.GtkImageCellAccessiblePrivate
}

func ImageCellAccessiblePrivateNewFromC(u unsafe.Pointer) *ImageCellAccessiblePrivate {
	c := (*C.GtkImageCellAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ImageCellAccessiblePrivate{native: c}

	return g
}

func (recv *ImageCellAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageCellAccessiblePrivate with another ImageCellAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ImageCellAccessiblePrivate) Equals(other *ImageCellAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ImageClass is a wrapper around the C record GtkImageClass.
type ImageClass struct {
	native *C.GtkImageClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ImageClassNewFromC(u unsafe.Pointer) *ImageClass {
	c := (*C.GtkImageClass)(u)
	if c == nil {
		return nil
	}

	g := &ImageClass{native: c}

	return g
}

func (recv *ImageClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageClass with another ImageClass, and returns true if they represent the same GObject.
func (recv *ImageClass) Equals(other *ImageClass) bool {
	return other.ToC() == recv.ToC()
}

// ImageMenuItemClass is a wrapper around the C record GtkImageMenuItemClass.
type ImageMenuItemClass struct {
	native *C.GtkImageMenuItemClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ImageMenuItemClassNewFromC(u unsafe.Pointer) *ImageMenuItemClass {
	c := (*C.GtkImageMenuItemClass)(u)
	if c == nil {
		return nil
	}

	g := &ImageMenuItemClass{native: c}

	return g
}

func (recv *ImageMenuItemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageMenuItemClass with another ImageMenuItemClass, and returns true if they represent the same GObject.
func (recv *ImageMenuItemClass) Equals(other *ImageMenuItemClass) bool {
	return other.ToC() == recv.ToC()
}

// ImageMenuItemPrivate is a wrapper around the C record GtkImageMenuItemPrivate.
type ImageMenuItemPrivate struct {
	native *C.GtkImageMenuItemPrivate
}

func ImageMenuItemPrivateNewFromC(u unsafe.Pointer) *ImageMenuItemPrivate {
	c := (*C.GtkImageMenuItemPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ImageMenuItemPrivate{native: c}

	return g
}

func (recv *ImageMenuItemPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImageMenuItemPrivate with another ImageMenuItemPrivate, and returns true if they represent the same GObject.
func (recv *ImageMenuItemPrivate) Equals(other *ImageMenuItemPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ImagePrivate is a wrapper around the C record GtkImagePrivate.
type ImagePrivate struct {
	native *C.GtkImagePrivate
}

func ImagePrivateNewFromC(u unsafe.Pointer) *ImagePrivate {
	c := (*C.GtkImagePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ImagePrivate{native: c}

	return g
}

func (recv *ImagePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ImagePrivate with another ImagePrivate, and returns true if they represent the same GObject.
func (recv *ImagePrivate) Equals(other *ImagePrivate) bool {
	return other.ToC() == recv.ToC()
}

// InfoBarClass is a wrapper around the C record GtkInfoBarClass.
type InfoBarClass struct {
	native *C.GtkInfoBarClass
	// parent_class : record
	// no type for response
	// no type for close
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func InfoBarClassNewFromC(u unsafe.Pointer) *InfoBarClass {
	c := (*C.GtkInfoBarClass)(u)
	if c == nil {
		return nil
	}

	g := &InfoBarClass{native: c}

	return g
}

func (recv *InfoBarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InfoBarClass with another InfoBarClass, and returns true if they represent the same GObject.
func (recv *InfoBarClass) Equals(other *InfoBarClass) bool {
	return other.ToC() == recv.ToC()
}

// InfoBarPrivate is a wrapper around the C record GtkInfoBarPrivate.
type InfoBarPrivate struct {
	native *C.GtkInfoBarPrivate
}

func InfoBarPrivateNewFromC(u unsafe.Pointer) *InfoBarPrivate {
	c := (*C.GtkInfoBarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &InfoBarPrivate{native: c}

	return g
}

func (recv *InfoBarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InfoBarPrivate with another InfoBarPrivate, and returns true if they represent the same GObject.
func (recv *InfoBarPrivate) Equals(other *InfoBarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// InvisibleClass is a wrapper around the C record GtkInvisibleClass.
type InvisibleClass struct {
	native *C.GtkInvisibleClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func InvisibleClassNewFromC(u unsafe.Pointer) *InvisibleClass {
	c := (*C.GtkInvisibleClass)(u)
	if c == nil {
		return nil
	}

	g := &InvisibleClass{native: c}

	return g
}

func (recv *InvisibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InvisibleClass with another InvisibleClass, and returns true if they represent the same GObject.
func (recv *InvisibleClass) Equals(other *InvisibleClass) bool {
	return other.ToC() == recv.ToC()
}

// InvisiblePrivate is a wrapper around the C record GtkInvisiblePrivate.
type InvisiblePrivate struct {
	native *C.GtkInvisiblePrivate
}

func InvisiblePrivateNewFromC(u unsafe.Pointer) *InvisiblePrivate {
	c := (*C.GtkInvisiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &InvisiblePrivate{native: c}

	return g
}

func (recv *InvisiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this InvisiblePrivate with another InvisiblePrivate, and returns true if they represent the same GObject.
func (recv *InvisiblePrivate) Equals(other *InvisiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// LabelAccessibleClass is a wrapper around the C record GtkLabelAccessibleClass.
type LabelAccessibleClass struct {
	native *C.GtkLabelAccessibleClass
	// parent_class : record
}

func LabelAccessibleClassNewFromC(u unsafe.Pointer) *LabelAccessibleClass {
	c := (*C.GtkLabelAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &LabelAccessibleClass{native: c}

	return g
}

func (recv *LabelAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LabelAccessibleClass with another LabelAccessibleClass, and returns true if they represent the same GObject.
func (recv *LabelAccessibleClass) Equals(other *LabelAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// LabelAccessiblePrivate is a wrapper around the C record GtkLabelAccessiblePrivate.
type LabelAccessiblePrivate struct {
	native *C.GtkLabelAccessiblePrivate
}

func LabelAccessiblePrivateNewFromC(u unsafe.Pointer) *LabelAccessiblePrivate {
	c := (*C.GtkLabelAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &LabelAccessiblePrivate{native: c}

	return g
}

func (recv *LabelAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LabelAccessiblePrivate with another LabelAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *LabelAccessiblePrivate) Equals(other *LabelAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// LabelClass is a wrapper around the C record GtkLabelClass.
type LabelClass struct {
	native *C.GtkLabelClass
	// parent_class : record
	// no type for move_cursor
	// no type for copy_clipboard
	// no type for populate_popup
	// no type for activate_link
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func LabelClassNewFromC(u unsafe.Pointer) *LabelClass {
	c := (*C.GtkLabelClass)(u)
	if c == nil {
		return nil
	}

	g := &LabelClass{native: c}

	return g
}

func (recv *LabelClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LabelClass with another LabelClass, and returns true if they represent the same GObject.
func (recv *LabelClass) Equals(other *LabelClass) bool {
	return other.ToC() == recv.ToC()
}

// LabelPrivate is a wrapper around the C record GtkLabelPrivate.
type LabelPrivate struct {
	native *C.GtkLabelPrivate
}

func LabelPrivateNewFromC(u unsafe.Pointer) *LabelPrivate {
	c := (*C.GtkLabelPrivate)(u)
	if c == nil {
		return nil
	}

	g := &LabelPrivate{native: c}

	return g
}

func (recv *LabelPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LabelPrivate with another LabelPrivate, and returns true if they represent the same GObject.
func (recv *LabelPrivate) Equals(other *LabelPrivate) bool {
	return other.ToC() == recv.ToC()
}

// LabelSelectionInfo is a wrapper around the C record GtkLabelSelectionInfo.
type LabelSelectionInfo struct {
	native *C.GtkLabelSelectionInfo
}

func LabelSelectionInfoNewFromC(u unsafe.Pointer) *LabelSelectionInfo {
	c := (*C.GtkLabelSelectionInfo)(u)
	if c == nil {
		return nil
	}

	g := &LabelSelectionInfo{native: c}

	return g
}

func (recv *LabelSelectionInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LabelSelectionInfo with another LabelSelectionInfo, and returns true if they represent the same GObject.
func (recv *LabelSelectionInfo) Equals(other *LabelSelectionInfo) bool {
	return other.ToC() == recv.ToC()
}

// LayoutClass is a wrapper around the C record GtkLayoutClass.
type LayoutClass struct {
	native *C.GtkLayoutClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func LayoutClassNewFromC(u unsafe.Pointer) *LayoutClass {
	c := (*C.GtkLayoutClass)(u)
	if c == nil {
		return nil
	}

	g := &LayoutClass{native: c}

	return g
}

func (recv *LayoutClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LayoutClass with another LayoutClass, and returns true if they represent the same GObject.
func (recv *LayoutClass) Equals(other *LayoutClass) bool {
	return other.ToC() == recv.ToC()
}

// LayoutPrivate is a wrapper around the C record GtkLayoutPrivate.
type LayoutPrivate struct {
	native *C.GtkLayoutPrivate
}

func LayoutPrivateNewFromC(u unsafe.Pointer) *LayoutPrivate {
	c := (*C.GtkLayoutPrivate)(u)
	if c == nil {
		return nil
	}

	g := &LayoutPrivate{native: c}

	return g
}

func (recv *LayoutPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LayoutPrivate with another LayoutPrivate, and returns true if they represent the same GObject.
func (recv *LayoutPrivate) Equals(other *LayoutPrivate) bool {
	return other.ToC() == recv.ToC()
}

// LevelBarAccessibleClass is a wrapper around the C record GtkLevelBarAccessibleClass.
type LevelBarAccessibleClass struct {
	native *C.GtkLevelBarAccessibleClass
	// parent_class : record
}

func LevelBarAccessibleClassNewFromC(u unsafe.Pointer) *LevelBarAccessibleClass {
	c := (*C.GtkLevelBarAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &LevelBarAccessibleClass{native: c}

	return g
}

func (recv *LevelBarAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LevelBarAccessibleClass with another LevelBarAccessibleClass, and returns true if they represent the same GObject.
func (recv *LevelBarAccessibleClass) Equals(other *LevelBarAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// LevelBarAccessiblePrivate is a wrapper around the C record GtkLevelBarAccessiblePrivate.
type LevelBarAccessiblePrivate struct {
	native *C.GtkLevelBarAccessiblePrivate
}

func LevelBarAccessiblePrivateNewFromC(u unsafe.Pointer) *LevelBarAccessiblePrivate {
	c := (*C.GtkLevelBarAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &LevelBarAccessiblePrivate{native: c}

	return g
}

func (recv *LevelBarAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LevelBarAccessiblePrivate with another LevelBarAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *LevelBarAccessiblePrivate) Equals(other *LevelBarAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// LevelBarClass is a wrapper around the C record GtkLevelBarClass.
type LevelBarClass struct {
	native *C.GtkLevelBarClass
	// Private : parent_class
	// no type for offset_changed
	// Private : padding
}

func LevelBarClassNewFromC(u unsafe.Pointer) *LevelBarClass {
	c := (*C.GtkLevelBarClass)(u)
	if c == nil {
		return nil
	}

	g := &LevelBarClass{native: c}

	return g
}

func (recv *LevelBarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LevelBarClass with another LevelBarClass, and returns true if they represent the same GObject.
func (recv *LevelBarClass) Equals(other *LevelBarClass) bool {
	return other.ToC() == recv.ToC()
}

// LevelBarPrivate is a wrapper around the C record GtkLevelBarPrivate.
type LevelBarPrivate struct {
	native *C.GtkLevelBarPrivate
}

func LevelBarPrivateNewFromC(u unsafe.Pointer) *LevelBarPrivate {
	c := (*C.GtkLevelBarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &LevelBarPrivate{native: c}

	return g
}

func (recv *LevelBarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LevelBarPrivate with another LevelBarPrivate, and returns true if they represent the same GObject.
func (recv *LevelBarPrivate) Equals(other *LevelBarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// LinkButtonAccessibleClass is a wrapper around the C record GtkLinkButtonAccessibleClass.
type LinkButtonAccessibleClass struct {
	native *C.GtkLinkButtonAccessibleClass
	// parent_class : record
}

func LinkButtonAccessibleClassNewFromC(u unsafe.Pointer) *LinkButtonAccessibleClass {
	c := (*C.GtkLinkButtonAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &LinkButtonAccessibleClass{native: c}

	return g
}

func (recv *LinkButtonAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LinkButtonAccessibleClass with another LinkButtonAccessibleClass, and returns true if they represent the same GObject.
func (recv *LinkButtonAccessibleClass) Equals(other *LinkButtonAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// LinkButtonAccessiblePrivate is a wrapper around the C record GtkLinkButtonAccessiblePrivate.
type LinkButtonAccessiblePrivate struct {
	native *C.GtkLinkButtonAccessiblePrivate
}

func LinkButtonAccessiblePrivateNewFromC(u unsafe.Pointer) *LinkButtonAccessiblePrivate {
	c := (*C.GtkLinkButtonAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &LinkButtonAccessiblePrivate{native: c}

	return g
}

func (recv *LinkButtonAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LinkButtonAccessiblePrivate with another LinkButtonAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *LinkButtonAccessiblePrivate) Equals(other *LinkButtonAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// LinkButtonClass is a wrapper around the C record GtkLinkButtonClass.
type LinkButtonClass struct {
	native *C.GtkLinkButtonClass
	// Private : parent_class
	// no type for activate_link
	// no type for _gtk_padding1
	// no type for _gtk_padding2
	// no type for _gtk_padding3
	// no type for _gtk_padding4
}

func LinkButtonClassNewFromC(u unsafe.Pointer) *LinkButtonClass {
	c := (*C.GtkLinkButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &LinkButtonClass{native: c}

	return g
}

func (recv *LinkButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LinkButtonClass with another LinkButtonClass, and returns true if they represent the same GObject.
func (recv *LinkButtonClass) Equals(other *LinkButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// LinkButtonPrivate is a wrapper around the C record GtkLinkButtonPrivate.
type LinkButtonPrivate struct {
	native *C.GtkLinkButtonPrivate
}

func LinkButtonPrivateNewFromC(u unsafe.Pointer) *LinkButtonPrivate {
	c := (*C.GtkLinkButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &LinkButtonPrivate{native: c}

	return g
}

func (recv *LinkButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LinkButtonPrivate with another LinkButtonPrivate, and returns true if they represent the same GObject.
func (recv *LinkButtonPrivate) Equals(other *LinkButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ListBoxAccessibleClass is a wrapper around the C record GtkListBoxAccessibleClass.
type ListBoxAccessibleClass struct {
	native *C.GtkListBoxAccessibleClass
	// parent_class : record
}

func ListBoxAccessibleClassNewFromC(u unsafe.Pointer) *ListBoxAccessibleClass {
	c := (*C.GtkListBoxAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxAccessibleClass{native: c}

	return g
}

func (recv *ListBoxAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxAccessibleClass with another ListBoxAccessibleClass, and returns true if they represent the same GObject.
func (recv *ListBoxAccessibleClass) Equals(other *ListBoxAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ListBoxAccessiblePrivate is a wrapper around the C record GtkListBoxAccessiblePrivate.
type ListBoxAccessiblePrivate struct {
	native *C.GtkListBoxAccessiblePrivate
}

func ListBoxAccessiblePrivateNewFromC(u unsafe.Pointer) *ListBoxAccessiblePrivate {
	c := (*C.GtkListBoxAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxAccessiblePrivate{native: c}

	return g
}

func (recv *ListBoxAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxAccessiblePrivate with another ListBoxAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ListBoxAccessiblePrivate) Equals(other *ListBoxAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ListBoxClass is a wrapper around the C record GtkListBoxClass.
type ListBoxClass struct {
	native *C.GtkListBoxClass
	// parent_class : record
	// no type for row_selected
	// no type for row_activated
	// no type for activate_cursor_row
	// no type for toggle_cursor_row
	// no type for move_cursor
	// no type for selected_rows_changed
	// no type for select_all
	// no type for unselect_all
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
}

func ListBoxClassNewFromC(u unsafe.Pointer) *ListBoxClass {
	c := (*C.GtkListBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxClass{native: c}

	return g
}

func (recv *ListBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxClass with another ListBoxClass, and returns true if they represent the same GObject.
func (recv *ListBoxClass) Equals(other *ListBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// ListBoxRowAccessibleClass is a wrapper around the C record GtkListBoxRowAccessibleClass.
type ListBoxRowAccessibleClass struct {
	native *C.GtkListBoxRowAccessibleClass
	// parent_class : record
}

func ListBoxRowAccessibleClassNewFromC(u unsafe.Pointer) *ListBoxRowAccessibleClass {
	c := (*C.GtkListBoxRowAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRowAccessibleClass{native: c}

	return g
}

func (recv *ListBoxRowAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxRowAccessibleClass with another ListBoxRowAccessibleClass, and returns true if they represent the same GObject.
func (recv *ListBoxRowAccessibleClass) Equals(other *ListBoxRowAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ListBoxRowClass is a wrapper around the C record GtkListBoxRowClass.
type ListBoxRowClass struct {
	native *C.GtkListBoxRowClass
	// parent_class : record
	// no type for activate
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
}

func ListBoxRowClassNewFromC(u unsafe.Pointer) *ListBoxRowClass {
	c := (*C.GtkListBoxRowClass)(u)
	if c == nil {
		return nil
	}

	g := &ListBoxRowClass{native: c}

	return g
}

func (recv *ListBoxRowClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListBoxRowClass with another ListBoxRowClass, and returns true if they represent the same GObject.
func (recv *ListBoxRowClass) Equals(other *ListBoxRowClass) bool {
	return other.ToC() == recv.ToC()
}

// ListStoreClass is a wrapper around the C record GtkListStoreClass.
type ListStoreClass struct {
	native *C.GtkListStoreClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ListStoreClassNewFromC(u unsafe.Pointer) *ListStoreClass {
	c := (*C.GtkListStoreClass)(u)
	if c == nil {
		return nil
	}

	g := &ListStoreClass{native: c}

	return g
}

func (recv *ListStoreClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListStoreClass with another ListStoreClass, and returns true if they represent the same GObject.
func (recv *ListStoreClass) Equals(other *ListStoreClass) bool {
	return other.ToC() == recv.ToC()
}

// ListStorePrivate is a wrapper around the C record GtkListStorePrivate.
type ListStorePrivate struct {
	native *C.GtkListStorePrivate
}

func ListStorePrivateNewFromC(u unsafe.Pointer) *ListStorePrivate {
	c := (*C.GtkListStorePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ListStorePrivate{native: c}

	return g
}

func (recv *ListStorePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ListStorePrivate with another ListStorePrivate, and returns true if they represent the same GObject.
func (recv *ListStorePrivate) Equals(other *ListStorePrivate) bool {
	return other.ToC() == recv.ToC()
}

// LockButtonAccessibleClass is a wrapper around the C record GtkLockButtonAccessibleClass.
type LockButtonAccessibleClass struct {
	native *C.GtkLockButtonAccessibleClass
	// parent_class : record
}

func LockButtonAccessibleClassNewFromC(u unsafe.Pointer) *LockButtonAccessibleClass {
	c := (*C.GtkLockButtonAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &LockButtonAccessibleClass{native: c}

	return g
}

func (recv *LockButtonAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LockButtonAccessibleClass with another LockButtonAccessibleClass, and returns true if they represent the same GObject.
func (recv *LockButtonAccessibleClass) Equals(other *LockButtonAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// LockButtonAccessiblePrivate is a wrapper around the C record GtkLockButtonAccessiblePrivate.
type LockButtonAccessiblePrivate struct {
	native *C.GtkLockButtonAccessiblePrivate
}

func LockButtonAccessiblePrivateNewFromC(u unsafe.Pointer) *LockButtonAccessiblePrivate {
	c := (*C.GtkLockButtonAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &LockButtonAccessiblePrivate{native: c}

	return g
}

func (recv *LockButtonAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LockButtonAccessiblePrivate with another LockButtonAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *LockButtonAccessiblePrivate) Equals(other *LockButtonAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// LockButtonClass is a wrapper around the C record GtkLockButtonClass.
type LockButtonClass struct {
	native *C.GtkLockButtonClass
	// parent_class : record
	// no type for reserved0
	// no type for reserved1
	// no type for reserved2
	// no type for reserved3
	// no type for reserved4
	// no type for reserved5
	// no type for reserved6
	// no type for reserved7
}

func LockButtonClassNewFromC(u unsafe.Pointer) *LockButtonClass {
	c := (*C.GtkLockButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &LockButtonClass{native: c}

	return g
}

func (recv *LockButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LockButtonClass with another LockButtonClass, and returns true if they represent the same GObject.
func (recv *LockButtonClass) Equals(other *LockButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// LockButtonPrivate is a wrapper around the C record GtkLockButtonPrivate.
type LockButtonPrivate struct {
	native *C.GtkLockButtonPrivate
}

func LockButtonPrivateNewFromC(u unsafe.Pointer) *LockButtonPrivate {
	c := (*C.GtkLockButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &LockButtonPrivate{native: c}

	return g
}

func (recv *LockButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this LockButtonPrivate with another LockButtonPrivate, and returns true if they represent the same GObject.
func (recv *LockButtonPrivate) Equals(other *LockButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuAccessibleClass is a wrapper around the C record GtkMenuAccessibleClass.
type MenuAccessibleClass struct {
	native *C.GtkMenuAccessibleClass
	// parent_class : record
}

func MenuAccessibleClassNewFromC(u unsafe.Pointer) *MenuAccessibleClass {
	c := (*C.GtkMenuAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuAccessibleClass{native: c}

	return g
}

func (recv *MenuAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuAccessibleClass with another MenuAccessibleClass, and returns true if they represent the same GObject.
func (recv *MenuAccessibleClass) Equals(other *MenuAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuAccessiblePrivate is a wrapper around the C record GtkMenuAccessiblePrivate.
type MenuAccessiblePrivate struct {
	native *C.GtkMenuAccessiblePrivate
}

func MenuAccessiblePrivateNewFromC(u unsafe.Pointer) *MenuAccessiblePrivate {
	c := (*C.GtkMenuAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuAccessiblePrivate{native: c}

	return g
}

func (recv *MenuAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuAccessiblePrivate with another MenuAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *MenuAccessiblePrivate) Equals(other *MenuAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuBarClass is a wrapper around the C record GtkMenuBarClass.
type MenuBarClass struct {
	native *C.GtkMenuBarClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MenuBarClassNewFromC(u unsafe.Pointer) *MenuBarClass {
	c := (*C.GtkMenuBarClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuBarClass{native: c}

	return g
}

func (recv *MenuBarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuBarClass with another MenuBarClass, and returns true if they represent the same GObject.
func (recv *MenuBarClass) Equals(other *MenuBarClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuBarPrivate is a wrapper around the C record GtkMenuBarPrivate.
type MenuBarPrivate struct {
	native *C.GtkMenuBarPrivate
}

func MenuBarPrivateNewFromC(u unsafe.Pointer) *MenuBarPrivate {
	c := (*C.GtkMenuBarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuBarPrivate{native: c}

	return g
}

func (recv *MenuBarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuBarPrivate with another MenuBarPrivate, and returns true if they represent the same GObject.
func (recv *MenuBarPrivate) Equals(other *MenuBarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuButtonAccessibleClass is a wrapper around the C record GtkMenuButtonAccessibleClass.
type MenuButtonAccessibleClass struct {
	native *C.GtkMenuButtonAccessibleClass
	// parent_class : record
}

func MenuButtonAccessibleClassNewFromC(u unsafe.Pointer) *MenuButtonAccessibleClass {
	c := (*C.GtkMenuButtonAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuButtonAccessibleClass{native: c}

	return g
}

func (recv *MenuButtonAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuButtonAccessibleClass with another MenuButtonAccessibleClass, and returns true if they represent the same GObject.
func (recv *MenuButtonAccessibleClass) Equals(other *MenuButtonAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuButtonAccessiblePrivate is a wrapper around the C record GtkMenuButtonAccessiblePrivate.
type MenuButtonAccessiblePrivate struct {
	native *C.GtkMenuButtonAccessiblePrivate
}

func MenuButtonAccessiblePrivateNewFromC(u unsafe.Pointer) *MenuButtonAccessiblePrivate {
	c := (*C.GtkMenuButtonAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuButtonAccessiblePrivate{native: c}

	return g
}

func (recv *MenuButtonAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuButtonAccessiblePrivate with another MenuButtonAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *MenuButtonAccessiblePrivate) Equals(other *MenuButtonAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuButtonClass is a wrapper around the C record GtkMenuButtonClass.
type MenuButtonClass struct {
	native *C.GtkMenuButtonClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MenuButtonClassNewFromC(u unsafe.Pointer) *MenuButtonClass {
	c := (*C.GtkMenuButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuButtonClass{native: c}

	return g
}

func (recv *MenuButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuButtonClass with another MenuButtonClass, and returns true if they represent the same GObject.
func (recv *MenuButtonClass) Equals(other *MenuButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuButtonPrivate is a wrapper around the C record GtkMenuButtonPrivate.
type MenuButtonPrivate struct {
	native *C.GtkMenuButtonPrivate
}

func MenuButtonPrivateNewFromC(u unsafe.Pointer) *MenuButtonPrivate {
	c := (*C.GtkMenuButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuButtonPrivate{native: c}

	return g
}

func (recv *MenuButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuButtonPrivate with another MenuButtonPrivate, and returns true if they represent the same GObject.
func (recv *MenuButtonPrivate) Equals(other *MenuButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuClass is a wrapper around the C record GtkMenuClass.
type MenuClass struct {
	native *C.GtkMenuClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MenuClassNewFromC(u unsafe.Pointer) *MenuClass {
	c := (*C.GtkMenuClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuClass{native: c}

	return g
}

func (recv *MenuClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuClass with another MenuClass, and returns true if they represent the same GObject.
func (recv *MenuClass) Equals(other *MenuClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuItemAccessibleClass is a wrapper around the C record GtkMenuItemAccessibleClass.
type MenuItemAccessibleClass struct {
	native *C.GtkMenuItemAccessibleClass
	// parent_class : record
}

func MenuItemAccessibleClassNewFromC(u unsafe.Pointer) *MenuItemAccessibleClass {
	c := (*C.GtkMenuItemAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuItemAccessibleClass{native: c}

	return g
}

func (recv *MenuItemAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItemAccessibleClass with another MenuItemAccessibleClass, and returns true if they represent the same GObject.
func (recv *MenuItemAccessibleClass) Equals(other *MenuItemAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuItemAccessiblePrivate is a wrapper around the C record GtkMenuItemAccessiblePrivate.
type MenuItemAccessiblePrivate struct {
	native *C.GtkMenuItemAccessiblePrivate
}

func MenuItemAccessiblePrivateNewFromC(u unsafe.Pointer) *MenuItemAccessiblePrivate {
	c := (*C.GtkMenuItemAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuItemAccessiblePrivate{native: c}

	return g
}

func (recv *MenuItemAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItemAccessiblePrivate with another MenuItemAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *MenuItemAccessiblePrivate) Equals(other *MenuItemAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuItemClass is a wrapper around the C record GtkMenuItemClass.
type MenuItemClass struct {
	native *C.GtkMenuItemClass
	// parent_class : record
	// Bitfield not supported :  1 hide_on_activate
	// no type for activate
	// no type for activate_item
	// no type for toggle_size_request
	// no type for toggle_size_allocate
	// no type for set_label
	// no type for get_label
	// no type for _select
	// no type for deselect
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MenuItemClassNewFromC(u unsafe.Pointer) *MenuItemClass {
	c := (*C.GtkMenuItemClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuItemClass{native: c}

	return g
}

func (recv *MenuItemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItemClass with another MenuItemClass, and returns true if they represent the same GObject.
func (recv *MenuItemClass) Equals(other *MenuItemClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuItemPrivate is a wrapper around the C record GtkMenuItemPrivate.
type MenuItemPrivate struct {
	native *C.GtkMenuItemPrivate
}

func MenuItemPrivateNewFromC(u unsafe.Pointer) *MenuItemPrivate {
	c := (*C.GtkMenuItemPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuItemPrivate{native: c}

	return g
}

func (recv *MenuItemPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuItemPrivate with another MenuItemPrivate, and returns true if they represent the same GObject.
func (recv *MenuItemPrivate) Equals(other *MenuItemPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuPrivate is a wrapper around the C record GtkMenuPrivate.
type MenuPrivate struct {
	native *C.GtkMenuPrivate
}

func MenuPrivateNewFromC(u unsafe.Pointer) *MenuPrivate {
	c := (*C.GtkMenuPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuPrivate{native: c}

	return g
}

func (recv *MenuPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuPrivate with another MenuPrivate, and returns true if they represent the same GObject.
func (recv *MenuPrivate) Equals(other *MenuPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuShellAccessibleClass is a wrapper around the C record GtkMenuShellAccessibleClass.
type MenuShellAccessibleClass struct {
	native *C.GtkMenuShellAccessibleClass
	// parent_class : record
}

func MenuShellAccessibleClassNewFromC(u unsafe.Pointer) *MenuShellAccessibleClass {
	c := (*C.GtkMenuShellAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuShellAccessibleClass{native: c}

	return g
}

func (recv *MenuShellAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuShellAccessibleClass with another MenuShellAccessibleClass, and returns true if they represent the same GObject.
func (recv *MenuShellAccessibleClass) Equals(other *MenuShellAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuShellAccessiblePrivate is a wrapper around the C record GtkMenuShellAccessiblePrivate.
type MenuShellAccessiblePrivate struct {
	native *C.GtkMenuShellAccessiblePrivate
}

func MenuShellAccessiblePrivateNewFromC(u unsafe.Pointer) *MenuShellAccessiblePrivate {
	c := (*C.GtkMenuShellAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuShellAccessiblePrivate{native: c}

	return g
}

func (recv *MenuShellAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuShellAccessiblePrivate with another MenuShellAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *MenuShellAccessiblePrivate) Equals(other *MenuShellAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuShellClass is a wrapper around the C record GtkMenuShellClass.
type MenuShellClass struct {
	native *C.GtkMenuShellClass
	// parent_class : record
	// Bitfield not supported :  1 submenu_placement
	// no type for deactivate
	// no type for selection_done
	// no type for move_current
	// no type for activate_current
	// no type for cancel
	// no type for select_item
	// no type for insert
	// no type for get_popup_delay
	// no type for move_selected
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MenuShellClassNewFromC(u unsafe.Pointer) *MenuShellClass {
	c := (*C.GtkMenuShellClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuShellClass{native: c}

	return g
}

func (recv *MenuShellClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuShellClass with another MenuShellClass, and returns true if they represent the same GObject.
func (recv *MenuShellClass) Equals(other *MenuShellClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuShellPrivate is a wrapper around the C record GtkMenuShellPrivate.
type MenuShellPrivate struct {
	native *C.GtkMenuShellPrivate
}

func MenuShellPrivateNewFromC(u unsafe.Pointer) *MenuShellPrivate {
	c := (*C.GtkMenuShellPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuShellPrivate{native: c}

	return g
}

func (recv *MenuShellPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuShellPrivate with another MenuShellPrivate, and returns true if they represent the same GObject.
func (recv *MenuShellPrivate) Equals(other *MenuShellPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MenuToolButtonClass is a wrapper around the C record GtkMenuToolButtonClass.
type MenuToolButtonClass struct {
	native *C.GtkMenuToolButtonClass
	// parent_class : record
	// no type for show_menu
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MenuToolButtonClassNewFromC(u unsafe.Pointer) *MenuToolButtonClass {
	c := (*C.GtkMenuToolButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &MenuToolButtonClass{native: c}

	return g
}

func (recv *MenuToolButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuToolButtonClass with another MenuToolButtonClass, and returns true if they represent the same GObject.
func (recv *MenuToolButtonClass) Equals(other *MenuToolButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// MenuToolButtonPrivate is a wrapper around the C record GtkMenuToolButtonPrivate.
type MenuToolButtonPrivate struct {
	native *C.GtkMenuToolButtonPrivate
}

func MenuToolButtonPrivateNewFromC(u unsafe.Pointer) *MenuToolButtonPrivate {
	c := (*C.GtkMenuToolButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MenuToolButtonPrivate{native: c}

	return g
}

func (recv *MenuToolButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MenuToolButtonPrivate with another MenuToolButtonPrivate, and returns true if they represent the same GObject.
func (recv *MenuToolButtonPrivate) Equals(other *MenuToolButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MessageDialogClass is a wrapper around the C record GtkMessageDialogClass.
type MessageDialogClass struct {
	native *C.GtkMessageDialogClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MessageDialogClassNewFromC(u unsafe.Pointer) *MessageDialogClass {
	c := (*C.GtkMessageDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &MessageDialogClass{native: c}

	return g
}

func (recv *MessageDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MessageDialogClass with another MessageDialogClass, and returns true if they represent the same GObject.
func (recv *MessageDialogClass) Equals(other *MessageDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// MessageDialogPrivate is a wrapper around the C record GtkMessageDialogPrivate.
type MessageDialogPrivate struct {
	native *C.GtkMessageDialogPrivate
}

func MessageDialogPrivateNewFromC(u unsafe.Pointer) *MessageDialogPrivate {
	c := (*C.GtkMessageDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MessageDialogPrivate{native: c}

	return g
}

func (recv *MessageDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MessageDialogPrivate with another MessageDialogPrivate, and returns true if they represent the same GObject.
func (recv *MessageDialogPrivate) Equals(other *MessageDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MiscClass is a wrapper around the C record GtkMiscClass.
type MiscClass struct {
	native *C.GtkMiscClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MiscClassNewFromC(u unsafe.Pointer) *MiscClass {
	c := (*C.GtkMiscClass)(u)
	if c == nil {
		return nil
	}

	g := &MiscClass{native: c}

	return g
}

func (recv *MiscClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MiscClass with another MiscClass, and returns true if they represent the same GObject.
func (recv *MiscClass) Equals(other *MiscClass) bool {
	return other.ToC() == recv.ToC()
}

// MiscPrivate is a wrapper around the C record GtkMiscPrivate.
type MiscPrivate struct {
	native *C.GtkMiscPrivate
}

func MiscPrivateNewFromC(u unsafe.Pointer) *MiscPrivate {
	c := (*C.GtkMiscPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MiscPrivate{native: c}

	return g
}

func (recv *MiscPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MiscPrivate with another MiscPrivate, and returns true if they represent the same GObject.
func (recv *MiscPrivate) Equals(other *MiscPrivate) bool {
	return other.ToC() == recv.ToC()
}

// MountOperationClass is a wrapper around the C record GtkMountOperationClass.
type MountOperationClass struct {
	native *C.GtkMountOperationClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func MountOperationClassNewFromC(u unsafe.Pointer) *MountOperationClass {
	c := (*C.GtkMountOperationClass)(u)
	if c == nil {
		return nil
	}

	g := &MountOperationClass{native: c}

	return g
}

func (recv *MountOperationClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MountOperationClass with another MountOperationClass, and returns true if they represent the same GObject.
func (recv *MountOperationClass) Equals(other *MountOperationClass) bool {
	return other.ToC() == recv.ToC()
}

// MountOperationPrivate is a wrapper around the C record GtkMountOperationPrivate.
type MountOperationPrivate struct {
	native *C.GtkMountOperationPrivate
}

func MountOperationPrivateNewFromC(u unsafe.Pointer) *MountOperationPrivate {
	c := (*C.GtkMountOperationPrivate)(u)
	if c == nil {
		return nil
	}

	g := &MountOperationPrivate{native: c}

	return g
}

func (recv *MountOperationPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this MountOperationPrivate with another MountOperationPrivate, and returns true if they represent the same GObject.
func (recv *MountOperationPrivate) Equals(other *MountOperationPrivate) bool {
	return other.ToC() == recv.ToC()
}

// NotebookAccessibleClass is a wrapper around the C record GtkNotebookAccessibleClass.
type NotebookAccessibleClass struct {
	native *C.GtkNotebookAccessibleClass
	// parent_class : record
}

func NotebookAccessibleClassNewFromC(u unsafe.Pointer) *NotebookAccessibleClass {
	c := (*C.GtkNotebookAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &NotebookAccessibleClass{native: c}

	return g
}

func (recv *NotebookAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookAccessibleClass with another NotebookAccessibleClass, and returns true if they represent the same GObject.
func (recv *NotebookAccessibleClass) Equals(other *NotebookAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// NotebookAccessiblePrivate is a wrapper around the C record GtkNotebookAccessiblePrivate.
type NotebookAccessiblePrivate struct {
	native *C.GtkNotebookAccessiblePrivate
}

func NotebookAccessiblePrivateNewFromC(u unsafe.Pointer) *NotebookAccessiblePrivate {
	c := (*C.GtkNotebookAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &NotebookAccessiblePrivate{native: c}

	return g
}

func (recv *NotebookAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookAccessiblePrivate with another NotebookAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *NotebookAccessiblePrivate) Equals(other *NotebookAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// NotebookClass is a wrapper around the C record GtkNotebookClass.
type NotebookClass struct {
	native *C.GtkNotebookClass
	// parent_class : record
	// no type for switch_page
	// no type for select_page
	// no type for focus_tab
	// no type for change_current_page
	// no type for move_focus_out
	// no type for reorder_tab
	// no type for insert_page
	// no type for create_window
	// no type for page_reordered
	// no type for page_removed
	// no type for page_added
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func NotebookClassNewFromC(u unsafe.Pointer) *NotebookClass {
	c := (*C.GtkNotebookClass)(u)
	if c == nil {
		return nil
	}

	g := &NotebookClass{native: c}

	return g
}

func (recv *NotebookClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookClass with another NotebookClass, and returns true if they represent the same GObject.
func (recv *NotebookClass) Equals(other *NotebookClass) bool {
	return other.ToC() == recv.ToC()
}

// NotebookPageAccessibleClass is a wrapper around the C record GtkNotebookPageAccessibleClass.
type NotebookPageAccessibleClass struct {
	native *C.GtkNotebookPageAccessibleClass
	// parent_class : record
}

func NotebookPageAccessibleClassNewFromC(u unsafe.Pointer) *NotebookPageAccessibleClass {
	c := (*C.GtkNotebookPageAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &NotebookPageAccessibleClass{native: c}

	return g
}

func (recv *NotebookPageAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookPageAccessibleClass with another NotebookPageAccessibleClass, and returns true if they represent the same GObject.
func (recv *NotebookPageAccessibleClass) Equals(other *NotebookPageAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// NotebookPageAccessiblePrivate is a wrapper around the C record GtkNotebookPageAccessiblePrivate.
type NotebookPageAccessiblePrivate struct {
	native *C.GtkNotebookPageAccessiblePrivate
}

func NotebookPageAccessiblePrivateNewFromC(u unsafe.Pointer) *NotebookPageAccessiblePrivate {
	c := (*C.GtkNotebookPageAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &NotebookPageAccessiblePrivate{native: c}

	return g
}

func (recv *NotebookPageAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookPageAccessiblePrivate with another NotebookPageAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *NotebookPageAccessiblePrivate) Equals(other *NotebookPageAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// NotebookPrivate is a wrapper around the C record GtkNotebookPrivate.
type NotebookPrivate struct {
	native *C.GtkNotebookPrivate
}

func NotebookPrivateNewFromC(u unsafe.Pointer) *NotebookPrivate {
	c := (*C.GtkNotebookPrivate)(u)
	if c == nil {
		return nil
	}

	g := &NotebookPrivate{native: c}

	return g
}

func (recv *NotebookPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NotebookPrivate with another NotebookPrivate, and returns true if they represent the same GObject.
func (recv *NotebookPrivate) Equals(other *NotebookPrivate) bool {
	return other.ToC() == recv.ToC()
}

// NumerableIconClass is a wrapper around the C record GtkNumerableIconClass.
type NumerableIconClass struct {
	native *C.GtkNumerableIconClass
	// parent_class : record
	// no type for padding
}

func NumerableIconClassNewFromC(u unsafe.Pointer) *NumerableIconClass {
	c := (*C.GtkNumerableIconClass)(u)
	if c == nil {
		return nil
	}

	g := &NumerableIconClass{native: c}

	return g
}

func (recv *NumerableIconClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NumerableIconClass with another NumerableIconClass, and returns true if they represent the same GObject.
func (recv *NumerableIconClass) Equals(other *NumerableIconClass) bool {
	return other.ToC() == recv.ToC()
}

// NumerableIconPrivate is a wrapper around the C record GtkNumerableIconPrivate.
type NumerableIconPrivate struct {
	native *C.GtkNumerableIconPrivate
}

func NumerableIconPrivateNewFromC(u unsafe.Pointer) *NumerableIconPrivate {
	c := (*C.GtkNumerableIconPrivate)(u)
	if c == nil {
		return nil
	}

	g := &NumerableIconPrivate{native: c}

	return g
}

func (recv *NumerableIconPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this NumerableIconPrivate with another NumerableIconPrivate, and returns true if they represent the same GObject.
func (recv *NumerableIconPrivate) Equals(other *NumerableIconPrivate) bool {
	return other.ToC() == recv.ToC()
}

// OffscreenWindowClass is a wrapper around the C record GtkOffscreenWindowClass.
type OffscreenWindowClass struct {
	native *C.GtkOffscreenWindowClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func OffscreenWindowClassNewFromC(u unsafe.Pointer) *OffscreenWindowClass {
	c := (*C.GtkOffscreenWindowClass)(u)
	if c == nil {
		return nil
	}

	g := &OffscreenWindowClass{native: c}

	return g
}

func (recv *OffscreenWindowClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OffscreenWindowClass with another OffscreenWindowClass, and returns true if they represent the same GObject.
func (recv *OffscreenWindowClass) Equals(other *OffscreenWindowClass) bool {
	return other.ToC() == recv.ToC()
}

// OrientableIface is a wrapper around the C record GtkOrientableIface.
type OrientableIface struct {
	native *C.GtkOrientableIface
	// base_iface : record
}

func OrientableIfaceNewFromC(u unsafe.Pointer) *OrientableIface {
	c := (*C.GtkOrientableIface)(u)
	if c == nil {
		return nil
	}

	g := &OrientableIface{native: c}

	return g
}

func (recv *OrientableIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OrientableIface with another OrientableIface, and returns true if they represent the same GObject.
func (recv *OrientableIface) Equals(other *OrientableIface) bool {
	return other.ToC() == recv.ToC()
}

// OverlayClass is a wrapper around the C record GtkOverlayClass.
type OverlayClass struct {
	native *C.GtkOverlayClass
	// parent_class : record
	// no type for get_child_position
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func OverlayClassNewFromC(u unsafe.Pointer) *OverlayClass {
	c := (*C.GtkOverlayClass)(u)
	if c == nil {
		return nil
	}

	g := &OverlayClass{native: c}

	return g
}

func (recv *OverlayClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OverlayClass with another OverlayClass, and returns true if they represent the same GObject.
func (recv *OverlayClass) Equals(other *OverlayClass) bool {
	return other.ToC() == recv.ToC()
}

// OverlayPrivate is a wrapper around the C record GtkOverlayPrivate.
type OverlayPrivate struct {
	native *C.GtkOverlayPrivate
}

func OverlayPrivateNewFromC(u unsafe.Pointer) *OverlayPrivate {
	c := (*C.GtkOverlayPrivate)(u)
	if c == nil {
		return nil
	}

	g := &OverlayPrivate{native: c}

	return g
}

func (recv *OverlayPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this OverlayPrivate with another OverlayPrivate, and returns true if they represent the same GObject.
func (recv *OverlayPrivate) Equals(other *OverlayPrivate) bool {
	return other.ToC() == recv.ToC()
}

// PageRange is a wrapper around the C record GtkPageRange.
type PageRange struct {
	native *C.GtkPageRange
	Start  int32
	End    int32
}

func PageRangeNewFromC(u unsafe.Pointer) *PageRange {
	c := (*C.GtkPageRange)(u)
	if c == nil {
		return nil
	}

	g := &PageRange{
		End:    (int32)(c.end),
		Start:  (int32)(c.start),
		native: c,
	}

	return g
}

func (recv *PageRange) ToC() unsafe.Pointer {
	recv.native.start =
		(C.gint)(recv.Start)
	recv.native.end =
		(C.gint)(recv.End)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PageRange with another PageRange, and returns true if they represent the same GObject.
func (recv *PageRange) Equals(other *PageRange) bool {
	return other.ToC() == recv.ToC()
}

// PanedAccessibleClass is a wrapper around the C record GtkPanedAccessibleClass.
type PanedAccessibleClass struct {
	native *C.GtkPanedAccessibleClass
	// parent_class : record
}

func PanedAccessibleClassNewFromC(u unsafe.Pointer) *PanedAccessibleClass {
	c := (*C.GtkPanedAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &PanedAccessibleClass{native: c}

	return g
}

func (recv *PanedAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PanedAccessibleClass with another PanedAccessibleClass, and returns true if they represent the same GObject.
func (recv *PanedAccessibleClass) Equals(other *PanedAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// PanedAccessiblePrivate is a wrapper around the C record GtkPanedAccessiblePrivate.
type PanedAccessiblePrivate struct {
	native *C.GtkPanedAccessiblePrivate
}

func PanedAccessiblePrivateNewFromC(u unsafe.Pointer) *PanedAccessiblePrivate {
	c := (*C.GtkPanedAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &PanedAccessiblePrivate{native: c}

	return g
}

func (recv *PanedAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PanedAccessiblePrivate with another PanedAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *PanedAccessiblePrivate) Equals(other *PanedAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// PanedClass is a wrapper around the C record GtkPanedClass.
type PanedClass struct {
	native *C.GtkPanedClass
	// parent_class : record
	// no type for cycle_child_focus
	// no type for toggle_handle_focus
	// no type for move_handle
	// no type for cycle_handle_focus
	// no type for accept_position
	// no type for cancel_position
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func PanedClassNewFromC(u unsafe.Pointer) *PanedClass {
	c := (*C.GtkPanedClass)(u)
	if c == nil {
		return nil
	}

	g := &PanedClass{native: c}

	return g
}

func (recv *PanedClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PanedClass with another PanedClass, and returns true if they represent the same GObject.
func (recv *PanedClass) Equals(other *PanedClass) bool {
	return other.ToC() == recv.ToC()
}

// PanedPrivate is a wrapper around the C record GtkPanedPrivate.
type PanedPrivate struct {
	native *C.GtkPanedPrivate
}

func PanedPrivateNewFromC(u unsafe.Pointer) *PanedPrivate {
	c := (*C.GtkPanedPrivate)(u)
	if c == nil {
		return nil
	}

	g := &PanedPrivate{native: c}

	return g
}

func (recv *PanedPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PanedPrivate with another PanedPrivate, and returns true if they represent the same GObject.
func (recv *PanedPrivate) Equals(other *PanedPrivate) bool {
	return other.ToC() == recv.ToC()
}

// PaperSize is a wrapper around the C record GtkPaperSize.
type PaperSize struct {
	native *C.GtkPaperSize
}

func PaperSizeNewFromC(u unsafe.Pointer) *PaperSize {
	c := (*C.GtkPaperSize)(u)
	if c == nil {
		return nil
	}

	g := &PaperSize{native: c}

	return g
}

func (recv *PaperSize) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PaperSize with another PaperSize, and returns true if they represent the same GObject.
func (recv *PaperSize) Equals(other *PaperSize) bool {
	return other.ToC() == recv.ToC()
}

// PaperSizeNew is a wrapper around the C function gtk_paper_size_new.
func PaperSizeNew(name string) *PaperSize {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	retC := C.gtk_paper_size_new(c_name)
	retGo := PaperSizeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// PaperSizeNewCustom is a wrapper around the C function gtk_paper_size_new_custom.
func PaperSizeNewCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
	c_name := C.CString(name)
	defer C.free(unsafe.Pointer(c_name))

	c_display_name := C.CString(displayName)
	defer C.free(unsafe.Pointer(c_display_name))

	c_width := (C.gdouble)(width)

	c_height := (C.gdouble)(height)

	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_paper_size_new_custom(c_name, c_display_name, c_width, c_height, c_unit)
	retGo := PaperSizeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// PaperSizeNewFromKeyFile is a wrapper around the C function gtk_paper_size_new_from_key_file.
func PaperSizeNewFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PaperSize, error) {
	c_key_file := (*C.GKeyFile)(C.NULL)
	if keyFile != nil {
		c_key_file = (*C.GKeyFile)(keyFile.ToC())
	}

	c_group_name := C.CString(groupName)
	defer C.free(unsafe.Pointer(c_group_name))

	var cThrowableError *C.GError

	retC := C.gtk_paper_size_new_from_key_file(c_key_file, c_group_name, &cThrowableError)
	retGo := PaperSizeNewFromC(unsafe.Pointer(retC))

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// PaperSizeNewFromPpd is a wrapper around the C function gtk_paper_size_new_from_ppd.
func PaperSizeNewFromPpd(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
	c_ppd_name := C.CString(ppdName)
	defer C.free(unsafe.Pointer(c_ppd_name))

	c_ppd_display_name := C.CString(ppdDisplayName)
	defer C.free(unsafe.Pointer(c_ppd_display_name))

	c_width := (C.gdouble)(width)

	c_height := (C.gdouble)(height)

	retC := C.gtk_paper_size_new_from_ppd(c_ppd_name, c_ppd_display_name, c_width, c_height)
	retGo := PaperSizeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// PaperSizeGetDefault is a wrapper around the C function gtk_paper_size_get_default.
func PaperSizeGetDefault() string {
	retC := C.gtk_paper_size_get_default()
	retGo := C.GoString(retC)

	return retGo
}

// PaperSizeGetPaperSizes is a wrapper around the C function gtk_paper_size_get_paper_sizes.
func PaperSizeGetPaperSizes(includeCustom bool) *glib.List {
	c_include_custom :=
		boolToGboolean(includeCustom)

	retC := C.gtk_paper_size_get_paper_sizes(c_include_custom)
	retGo := glib.ListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Copy is a wrapper around the C function gtk_paper_size_copy.
func (recv *PaperSize) Copy() *PaperSize {
	retC := C.gtk_paper_size_copy((*C.GtkPaperSize)(recv.native))
	retGo := PaperSizeNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_paper_size_free.
func (recv *PaperSize) Free() {
	C.gtk_paper_size_free((*C.GtkPaperSize)(recv.native))

	return
}

// GetDefaultBottomMargin is a wrapper around the C function gtk_paper_size_get_default_bottom_margin.
func (recv *PaperSize) GetDefaultBottomMargin(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_paper_size_get_default_bottom_margin((*C.GtkPaperSize)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetDefaultLeftMargin is a wrapper around the C function gtk_paper_size_get_default_left_margin.
func (recv *PaperSize) GetDefaultLeftMargin(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_paper_size_get_default_left_margin((*C.GtkPaperSize)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetDefaultRightMargin is a wrapper around the C function gtk_paper_size_get_default_right_margin.
func (recv *PaperSize) GetDefaultRightMargin(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_paper_size_get_default_right_margin((*C.GtkPaperSize)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetDefaultTopMargin is a wrapper around the C function gtk_paper_size_get_default_top_margin.
func (recv *PaperSize) GetDefaultTopMargin(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_paper_size_get_default_top_margin((*C.GtkPaperSize)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetDisplayName is a wrapper around the C function gtk_paper_size_get_display_name.
func (recv *PaperSize) GetDisplayName() string {
	retC := C.gtk_paper_size_get_display_name((*C.GtkPaperSize)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetHeight is a wrapper around the C function gtk_paper_size_get_height.
func (recv *PaperSize) GetHeight(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_paper_size_get_height((*C.GtkPaperSize)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// GetName is a wrapper around the C function gtk_paper_size_get_name.
func (recv *PaperSize) GetName() string {
	retC := C.gtk_paper_size_get_name((*C.GtkPaperSize)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetPpdName is a wrapper around the C function gtk_paper_size_get_ppd_name.
func (recv *PaperSize) GetPpdName() string {
	retC := C.gtk_paper_size_get_ppd_name((*C.GtkPaperSize)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetWidth is a wrapper around the C function gtk_paper_size_get_width.
func (recv *PaperSize) GetWidth(unit Unit) float64 {
	c_unit := (C.GtkUnit)(unit)

	retC := C.gtk_paper_size_get_width((*C.GtkPaperSize)(recv.native), c_unit)
	retGo := (float64)(retC)

	return retGo
}

// IsCustom is a wrapper around the C function gtk_paper_size_is_custom.
func (recv *PaperSize) IsCustom() bool {
	retC := C.gtk_paper_size_is_custom((*C.GtkPaperSize)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsEqual is a wrapper around the C function gtk_paper_size_is_equal.
func (recv *PaperSize) IsEqual(size2 *PaperSize) bool {
	c_size2 := (*C.GtkPaperSize)(C.NULL)
	if size2 != nil {
		c_size2 = (*C.GtkPaperSize)(size2.ToC())
	}

	retC := C.gtk_paper_size_is_equal((*C.GtkPaperSize)(recv.native), c_size2)
	retGo := retC == C.TRUE

	return retGo
}

// IsIpp is a wrapper around the C function gtk_paper_size_is_ipp.
func (recv *PaperSize) IsIpp() bool {
	retC := C.gtk_paper_size_is_ipp((*C.GtkPaperSize)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SetSize is a wrapper around the C function gtk_paper_size_set_size.
func (recv *PaperSize) SetSize(width float64, height float64, unit Unit) {
	c_width := (C.gdouble)(width)

	c_height := (C.gdouble)(height)

	c_unit := (C.GtkUnit)(unit)

	C.gtk_paper_size_set_size((*C.GtkPaperSize)(recv.native), c_width, c_height, c_unit)

	return
}

// ToKeyFile is a wrapper around the C function gtk_paper_size_to_key_file.
func (recv *PaperSize) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	c_key_file := (*C.GKeyFile)(C.NULL)
	if keyFile != nil {
		c_key_file = (*C.GKeyFile)(keyFile.ToC())
	}

	c_group_name := C.CString(groupName)
	defer C.free(unsafe.Pointer(c_group_name))

	C.gtk_paper_size_to_key_file((*C.GtkPaperSize)(recv.native), c_key_file, c_group_name)

	return
}

// PlacesSidebarClass is a wrapper around the C record GtkPlacesSidebarClass.
type PlacesSidebarClass struct {
	native *C.GtkPlacesSidebarClass
}

func PlacesSidebarClassNewFromC(u unsafe.Pointer) *PlacesSidebarClass {
	c := (*C.GtkPlacesSidebarClass)(u)
	if c == nil {
		return nil
	}

	g := &PlacesSidebarClass{native: c}

	return g
}

func (recv *PlacesSidebarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PlacesSidebarClass with another PlacesSidebarClass, and returns true if they represent the same GObject.
func (recv *PlacesSidebarClass) Equals(other *PlacesSidebarClass) bool {
	return other.ToC() == recv.ToC()
}

// PlugClass is a wrapper around the C record GtkPlugClass.
type PlugClass struct {
	native *C.GtkPlugClass
	// parent_class : record
	// no type for embedded
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func PlugClassNewFromC(u unsafe.Pointer) *PlugClass {
	c := (*C.GtkPlugClass)(u)
	if c == nil {
		return nil
	}

	g := &PlugClass{native: c}

	return g
}

func (recv *PlugClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PlugClass with another PlugClass, and returns true if they represent the same GObject.
func (recv *PlugClass) Equals(other *PlugClass) bool {
	return other.ToC() == recv.ToC()
}

// PlugPrivate is a wrapper around the C record GtkPlugPrivate.
type PlugPrivate struct {
	native *C.GtkPlugPrivate
}

func PlugPrivateNewFromC(u unsafe.Pointer) *PlugPrivate {
	c := (*C.GtkPlugPrivate)(u)
	if c == nil {
		return nil
	}

	g := &PlugPrivate{native: c}

	return g
}

func (recv *PlugPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PlugPrivate with another PlugPrivate, and returns true if they represent the same GObject.
func (recv *PlugPrivate) Equals(other *PlugPrivate) bool {
	return other.ToC() == recv.ToC()
}

// PopoverAccessibleClass is a wrapper around the C record GtkPopoverAccessibleClass.
type PopoverAccessibleClass struct {
	native *C.GtkPopoverAccessibleClass
	// parent_class : record
}

func PopoverAccessibleClassNewFromC(u unsafe.Pointer) *PopoverAccessibleClass {
	c := (*C.GtkPopoverAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &PopoverAccessibleClass{native: c}

	return g
}

func (recv *PopoverAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PopoverAccessibleClass with another PopoverAccessibleClass, and returns true if they represent the same GObject.
func (recv *PopoverAccessibleClass) Equals(other *PopoverAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// PopoverClass is a wrapper around the C record GtkPopoverClass.
type PopoverClass struct {
	native *C.GtkPopoverClass
	// parent_class : record
	// no type for closed
	// Private : reserved
}

func PopoverClassNewFromC(u unsafe.Pointer) *PopoverClass {
	c := (*C.GtkPopoverClass)(u)
	if c == nil {
		return nil
	}

	g := &PopoverClass{native: c}

	return g
}

func (recv *PopoverClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PopoverClass with another PopoverClass, and returns true if they represent the same GObject.
func (recv *PopoverClass) Equals(other *PopoverClass) bool {
	return other.ToC() == recv.ToC()
}

// PopoverMenuClass is a wrapper around the C record GtkPopoverMenuClass.
type PopoverMenuClass struct {
	native *C.GtkPopoverMenuClass
	// parent_class : record
	// Private : reserved
}

func PopoverMenuClassNewFromC(u unsafe.Pointer) *PopoverMenuClass {
	c := (*C.GtkPopoverMenuClass)(u)
	if c == nil {
		return nil
	}

	g := &PopoverMenuClass{native: c}

	return g
}

func (recv *PopoverMenuClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PopoverMenuClass with another PopoverMenuClass, and returns true if they represent the same GObject.
func (recv *PopoverMenuClass) Equals(other *PopoverMenuClass) bool {
	return other.ToC() == recv.ToC()
}

// PopoverPrivate is a wrapper around the C record GtkPopoverPrivate.
type PopoverPrivate struct {
	native *C.GtkPopoverPrivate
}

func PopoverPrivateNewFromC(u unsafe.Pointer) *PopoverPrivate {
	c := (*C.GtkPopoverPrivate)(u)
	if c == nil {
		return nil
	}

	g := &PopoverPrivate{native: c}

	return g
}

func (recv *PopoverPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PopoverPrivate with another PopoverPrivate, and returns true if they represent the same GObject.
func (recv *PopoverPrivate) Equals(other *PopoverPrivate) bool {
	return other.ToC() == recv.ToC()
}

// PrintOperationClass is a wrapper around the C record GtkPrintOperationClass.
type PrintOperationClass struct {
	native *C.GtkPrintOperationClass
	// parent_class : record
	// no type for done
	// no type for begin_print
	// no type for paginate
	// no type for request_page_setup
	// no type for draw_page
	// no type for end_print
	// no type for status_changed
	// no type for create_custom_widget
	// no type for custom_widget_apply
	// no type for preview
	// no type for update_custom_widget
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func PrintOperationClassNewFromC(u unsafe.Pointer) *PrintOperationClass {
	c := (*C.GtkPrintOperationClass)(u)
	if c == nil {
		return nil
	}

	g := &PrintOperationClass{native: c}

	return g
}

func (recv *PrintOperationClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintOperationClass with another PrintOperationClass, and returns true if they represent the same GObject.
func (recv *PrintOperationClass) Equals(other *PrintOperationClass) bool {
	return other.ToC() == recv.ToC()
}

// PrintOperationPreviewIface is a wrapper around the C record GtkPrintOperationPreviewIface.
type PrintOperationPreviewIface struct {
	native *C.GtkPrintOperationPreviewIface
	// g_iface : record
	// no type for ready
	// no type for got_page_size
	// no type for render_page
	// no type for is_selected
	// no type for end_preview
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func PrintOperationPreviewIfaceNewFromC(u unsafe.Pointer) *PrintOperationPreviewIface {
	c := (*C.GtkPrintOperationPreviewIface)(u)
	if c == nil {
		return nil
	}

	g := &PrintOperationPreviewIface{native: c}

	return g
}

func (recv *PrintOperationPreviewIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintOperationPreviewIface with another PrintOperationPreviewIface, and returns true if they represent the same GObject.
func (recv *PrintOperationPreviewIface) Equals(other *PrintOperationPreviewIface) bool {
	return other.ToC() == recv.ToC()
}

// PrintOperationPrivate is a wrapper around the C record GtkPrintOperationPrivate.
type PrintOperationPrivate struct {
	native *C.GtkPrintOperationPrivate
}

func PrintOperationPrivateNewFromC(u unsafe.Pointer) *PrintOperationPrivate {
	c := (*C.GtkPrintOperationPrivate)(u)
	if c == nil {
		return nil
	}

	g := &PrintOperationPrivate{native: c}

	return g
}

func (recv *PrintOperationPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this PrintOperationPrivate with another PrintOperationPrivate, and returns true if they represent the same GObject.
func (recv *PrintOperationPrivate) Equals(other *PrintOperationPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ProgressBarAccessibleClass is a wrapper around the C record GtkProgressBarAccessibleClass.
type ProgressBarAccessibleClass struct {
	native *C.GtkProgressBarAccessibleClass
	// parent_class : record
}

func ProgressBarAccessibleClassNewFromC(u unsafe.Pointer) *ProgressBarAccessibleClass {
	c := (*C.GtkProgressBarAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBarAccessibleClass{native: c}

	return g
}

func (recv *ProgressBarAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProgressBarAccessibleClass with another ProgressBarAccessibleClass, and returns true if they represent the same GObject.
func (recv *ProgressBarAccessibleClass) Equals(other *ProgressBarAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ProgressBarAccessiblePrivate is a wrapper around the C record GtkProgressBarAccessiblePrivate.
type ProgressBarAccessiblePrivate struct {
	native *C.GtkProgressBarAccessiblePrivate
}

func ProgressBarAccessiblePrivateNewFromC(u unsafe.Pointer) *ProgressBarAccessiblePrivate {
	c := (*C.GtkProgressBarAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBarAccessiblePrivate{native: c}

	return g
}

func (recv *ProgressBarAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProgressBarAccessiblePrivate with another ProgressBarAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ProgressBarAccessiblePrivate) Equals(other *ProgressBarAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ProgressBarClass is a wrapper around the C record GtkProgressBarClass.
type ProgressBarClass struct {
	native *C.GtkProgressBarClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ProgressBarClassNewFromC(u unsafe.Pointer) *ProgressBarClass {
	c := (*C.GtkProgressBarClass)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBarClass{native: c}

	return g
}

func (recv *ProgressBarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProgressBarClass with another ProgressBarClass, and returns true if they represent the same GObject.
func (recv *ProgressBarClass) Equals(other *ProgressBarClass) bool {
	return other.ToC() == recv.ToC()
}

// ProgressBarPrivate is a wrapper around the C record GtkProgressBarPrivate.
type ProgressBarPrivate struct {
	native *C.GtkProgressBarPrivate
}

func ProgressBarPrivateNewFromC(u unsafe.Pointer) *ProgressBarPrivate {
	c := (*C.GtkProgressBarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ProgressBarPrivate{native: c}

	return g
}

func (recv *ProgressBarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ProgressBarPrivate with another ProgressBarPrivate, and returns true if they represent the same GObject.
func (recv *ProgressBarPrivate) Equals(other *ProgressBarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RadioActionClass is a wrapper around the C record GtkRadioActionClass.
type RadioActionClass struct {
	native *C.GtkRadioActionClass
	// parent_class : record
	// no type for changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func RadioActionClassNewFromC(u unsafe.Pointer) *RadioActionClass {
	c := (*C.GtkRadioActionClass)(u)
	if c == nil {
		return nil
	}

	g := &RadioActionClass{native: c}

	return g
}

func (recv *RadioActionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioActionClass with another RadioActionClass, and returns true if they represent the same GObject.
func (recv *RadioActionClass) Equals(other *RadioActionClass) bool {
	return other.ToC() == recv.ToC()
}

// RadioActionEntry is a wrapper around the C record GtkRadioActionEntry.
type RadioActionEntry struct {
	native      *C.GtkRadioActionEntry
	Name        string
	StockId     string
	Label       string
	Accelerator string
	Tooltip     string
	Value       int32
}

func RadioActionEntryNewFromC(u unsafe.Pointer) *RadioActionEntry {
	c := (*C.GtkRadioActionEntry)(u)
	if c == nil {
		return nil
	}

	g := &RadioActionEntry{
		Accelerator: C.GoString(c.accelerator),
		Label:       C.GoString(c.label),
		Name:        C.GoString(c.name),
		StockId:     C.GoString(c.stock_id),
		Tooltip:     C.GoString(c.tooltip),
		Value:       (int32)(c.value),
		native:      c,
	}

	return g
}

func (recv *RadioActionEntry) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native.stock_id =
		C.CString(recv.StockId)
	recv.native.label =
		C.CString(recv.Label)
	recv.native.accelerator =
		C.CString(recv.Accelerator)
	recv.native.tooltip =
		C.CString(recv.Tooltip)
	recv.native.value =
		(C.gint)(recv.Value)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioActionEntry with another RadioActionEntry, and returns true if they represent the same GObject.
func (recv *RadioActionEntry) Equals(other *RadioActionEntry) bool {
	return other.ToC() == recv.ToC()
}

// RadioActionPrivate is a wrapper around the C record GtkRadioActionPrivate.
type RadioActionPrivate struct {
	native *C.GtkRadioActionPrivate
}

func RadioActionPrivateNewFromC(u unsafe.Pointer) *RadioActionPrivate {
	c := (*C.GtkRadioActionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &RadioActionPrivate{native: c}

	return g
}

func (recv *RadioActionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioActionPrivate with another RadioActionPrivate, and returns true if they represent the same GObject.
func (recv *RadioActionPrivate) Equals(other *RadioActionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RadioButtonAccessibleClass is a wrapper around the C record GtkRadioButtonAccessibleClass.
type RadioButtonAccessibleClass struct {
	native *C.GtkRadioButtonAccessibleClass
	// parent_class : record
}

func RadioButtonAccessibleClassNewFromC(u unsafe.Pointer) *RadioButtonAccessibleClass {
	c := (*C.GtkRadioButtonAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &RadioButtonAccessibleClass{native: c}

	return g
}

func (recv *RadioButtonAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioButtonAccessibleClass with another RadioButtonAccessibleClass, and returns true if they represent the same GObject.
func (recv *RadioButtonAccessibleClass) Equals(other *RadioButtonAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// RadioButtonAccessiblePrivate is a wrapper around the C record GtkRadioButtonAccessiblePrivate.
type RadioButtonAccessiblePrivate struct {
	native *C.GtkRadioButtonAccessiblePrivate
}

func RadioButtonAccessiblePrivateNewFromC(u unsafe.Pointer) *RadioButtonAccessiblePrivate {
	c := (*C.GtkRadioButtonAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &RadioButtonAccessiblePrivate{native: c}

	return g
}

func (recv *RadioButtonAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioButtonAccessiblePrivate with another RadioButtonAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *RadioButtonAccessiblePrivate) Equals(other *RadioButtonAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// RadioButtonClass is a wrapper around the C record GtkRadioButtonClass.
type RadioButtonClass struct {
	native *C.GtkRadioButtonClass
	// parent_class : record
	// no type for group_changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func RadioButtonClassNewFromC(u unsafe.Pointer) *RadioButtonClass {
	c := (*C.GtkRadioButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &RadioButtonClass{native: c}

	return g
}

func (recv *RadioButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioButtonClass with another RadioButtonClass, and returns true if they represent the same GObject.
func (recv *RadioButtonClass) Equals(other *RadioButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// RadioButtonPrivate is a wrapper around the C record GtkRadioButtonPrivate.
type RadioButtonPrivate struct {
	native *C.GtkRadioButtonPrivate
}

func RadioButtonPrivateNewFromC(u unsafe.Pointer) *RadioButtonPrivate {
	c := (*C.GtkRadioButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &RadioButtonPrivate{native: c}

	return g
}

func (recv *RadioButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioButtonPrivate with another RadioButtonPrivate, and returns true if they represent the same GObject.
func (recv *RadioButtonPrivate) Equals(other *RadioButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RadioMenuItemAccessibleClass is a wrapper around the C record GtkRadioMenuItemAccessibleClass.
type RadioMenuItemAccessibleClass struct {
	native *C.GtkRadioMenuItemAccessibleClass
	// parent_class : record
}

func RadioMenuItemAccessibleClassNewFromC(u unsafe.Pointer) *RadioMenuItemAccessibleClass {
	c := (*C.GtkRadioMenuItemAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItemAccessibleClass{native: c}

	return g
}

func (recv *RadioMenuItemAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioMenuItemAccessibleClass with another RadioMenuItemAccessibleClass, and returns true if they represent the same GObject.
func (recv *RadioMenuItemAccessibleClass) Equals(other *RadioMenuItemAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// RadioMenuItemAccessiblePrivate is a wrapper around the C record GtkRadioMenuItemAccessiblePrivate.
type RadioMenuItemAccessiblePrivate struct {
	native *C.GtkRadioMenuItemAccessiblePrivate
}

func RadioMenuItemAccessiblePrivateNewFromC(u unsafe.Pointer) *RadioMenuItemAccessiblePrivate {
	c := (*C.GtkRadioMenuItemAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItemAccessiblePrivate{native: c}

	return g
}

func (recv *RadioMenuItemAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioMenuItemAccessiblePrivate with another RadioMenuItemAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *RadioMenuItemAccessiblePrivate) Equals(other *RadioMenuItemAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// RadioMenuItemClass is a wrapper around the C record GtkRadioMenuItemClass.
type RadioMenuItemClass struct {
	native *C.GtkRadioMenuItemClass
	// parent_class : record
	// no type for group_changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func RadioMenuItemClassNewFromC(u unsafe.Pointer) *RadioMenuItemClass {
	c := (*C.GtkRadioMenuItemClass)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItemClass{native: c}

	return g
}

func (recv *RadioMenuItemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioMenuItemClass with another RadioMenuItemClass, and returns true if they represent the same GObject.
func (recv *RadioMenuItemClass) Equals(other *RadioMenuItemClass) bool {
	return other.ToC() == recv.ToC()
}

// RadioMenuItemPrivate is a wrapper around the C record GtkRadioMenuItemPrivate.
type RadioMenuItemPrivate struct {
	native *C.GtkRadioMenuItemPrivate
}

func RadioMenuItemPrivateNewFromC(u unsafe.Pointer) *RadioMenuItemPrivate {
	c := (*C.GtkRadioMenuItemPrivate)(u)
	if c == nil {
		return nil
	}

	g := &RadioMenuItemPrivate{native: c}

	return g
}

func (recv *RadioMenuItemPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioMenuItemPrivate with another RadioMenuItemPrivate, and returns true if they represent the same GObject.
func (recv *RadioMenuItemPrivate) Equals(other *RadioMenuItemPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RadioToolButtonClass is a wrapper around the C record GtkRadioToolButtonClass.
type RadioToolButtonClass struct {
	native *C.GtkRadioToolButtonClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func RadioToolButtonClassNewFromC(u unsafe.Pointer) *RadioToolButtonClass {
	c := (*C.GtkRadioToolButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &RadioToolButtonClass{native: c}

	return g
}

func (recv *RadioToolButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RadioToolButtonClass with another RadioToolButtonClass, and returns true if they represent the same GObject.
func (recv *RadioToolButtonClass) Equals(other *RadioToolButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// RangeAccessibleClass is a wrapper around the C record GtkRangeAccessibleClass.
type RangeAccessibleClass struct {
	native *C.GtkRangeAccessibleClass
	// parent_class : record
}

func RangeAccessibleClassNewFromC(u unsafe.Pointer) *RangeAccessibleClass {
	c := (*C.GtkRangeAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &RangeAccessibleClass{native: c}

	return g
}

func (recv *RangeAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RangeAccessibleClass with another RangeAccessibleClass, and returns true if they represent the same GObject.
func (recv *RangeAccessibleClass) Equals(other *RangeAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// RangeAccessiblePrivate is a wrapper around the C record GtkRangeAccessiblePrivate.
type RangeAccessiblePrivate struct {
	native *C.GtkRangeAccessiblePrivate
}

func RangeAccessiblePrivateNewFromC(u unsafe.Pointer) *RangeAccessiblePrivate {
	c := (*C.GtkRangeAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &RangeAccessiblePrivate{native: c}

	return g
}

func (recv *RangeAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RangeAccessiblePrivate with another RangeAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *RangeAccessiblePrivate) Equals(other *RangeAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// RangeClass is a wrapper around the C record GtkRangeClass.
type RangeClass struct {
	native *C.GtkRangeClass
	// parent_class : record
	SliderDetail  string
	StepperDetail string
	// no type for value_changed
	// no type for adjust_bounds
	// no type for move_slider
	// no type for get_range_border
	// no type for change_value
	// no type for get_range_size_request
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
}

func RangeClassNewFromC(u unsafe.Pointer) *RangeClass {
	c := (*C.GtkRangeClass)(u)
	if c == nil {
		return nil
	}

	g := &RangeClass{
		SliderDetail:  C.GoString(c.slider_detail),
		StepperDetail: C.GoString(c.stepper_detail),
		native:        c,
	}

	return g
}

func (recv *RangeClass) ToC() unsafe.Pointer {
	recv.native.slider_detail =
		C.CString(recv.SliderDetail)
	recv.native.stepper_detail =
		C.CString(recv.StepperDetail)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RangeClass with another RangeClass, and returns true if they represent the same GObject.
func (recv *RangeClass) Equals(other *RangeClass) bool {
	return other.ToC() == recv.ToC()
}

// RangePrivate is a wrapper around the C record GtkRangePrivate.
type RangePrivate struct {
	native *C.GtkRangePrivate
}

func RangePrivateNewFromC(u unsafe.Pointer) *RangePrivate {
	c := (*C.GtkRangePrivate)(u)
	if c == nil {
		return nil
	}

	g := &RangePrivate{native: c}

	return g
}

func (recv *RangePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RangePrivate with another RangePrivate, and returns true if they represent the same GObject.
func (recv *RangePrivate) Equals(other *RangePrivate) bool {
	return other.ToC() == recv.ToC()
}

// RcContext is a wrapper around the C record GtkRcContext.
type RcContext struct {
	native *C.GtkRcContext
}

func RcContextNewFromC(u unsafe.Pointer) *RcContext {
	c := (*C.GtkRcContext)(u)
	if c == nil {
		return nil
	}

	g := &RcContext{native: c}

	return g
}

func (recv *RcContext) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RcContext with another RcContext, and returns true if they represent the same GObject.
func (recv *RcContext) Equals(other *RcContext) bool {
	return other.ToC() == recv.ToC()
}

// RcProperty is a wrapper around the C record GtkRcProperty.
type RcProperty struct {
	native       *C.GtkRcProperty
	TypeName     glib.Quark
	PropertyName glib.Quark
	Origin       string
	// value : record
}

func RcPropertyNewFromC(u unsafe.Pointer) *RcProperty {
	c := (*C.GtkRcProperty)(u)
	if c == nil {
		return nil
	}

	g := &RcProperty{
		Origin:       C.GoString(c.origin),
		PropertyName: (glib.Quark)(c.property_name),
		TypeName:     (glib.Quark)(c.type_name),
		native:       c,
	}

	return g
}

func (recv *RcProperty) ToC() unsafe.Pointer {
	recv.native.type_name =
		(C.GQuark)(recv.TypeName)
	recv.native.property_name =
		(C.GQuark)(recv.PropertyName)
	recv.native.origin =
		C.CString(recv.Origin)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RcProperty with another RcProperty, and returns true if they represent the same GObject.
func (recv *RcProperty) Equals(other *RcProperty) bool {
	return other.ToC() == recv.ToC()
}

// RcPropertyParseBorder is a wrapper around the C function gtk_rc_property_parse_border.
func RcPropertyParseBorder(pspec *gobject.ParamSpec, gstring *glib.String, propertyValue *gobject.Value) bool {
	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	c_gstring := (*C.GString)(C.NULL)
	if gstring != nil {
		c_gstring = (*C.GString)(gstring.ToC())
	}

	c_property_value := (*C.GValue)(C.NULL)
	if propertyValue != nil {
		c_property_value = (*C.GValue)(propertyValue.ToC())
	}

	retC := C.gtk_rc_property_parse_border(c_pspec, c_gstring, c_property_value)
	retGo := retC == C.TRUE

	return retGo
}

// RcPropertyParseColor is a wrapper around the C function gtk_rc_property_parse_color.
func RcPropertyParseColor(pspec *gobject.ParamSpec, gstring *glib.String, propertyValue *gobject.Value) bool {
	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	c_gstring := (*C.GString)(C.NULL)
	if gstring != nil {
		c_gstring = (*C.GString)(gstring.ToC())
	}

	c_property_value := (*C.GValue)(C.NULL)
	if propertyValue != nil {
		c_property_value = (*C.GValue)(propertyValue.ToC())
	}

	retC := C.gtk_rc_property_parse_color(c_pspec, c_gstring, c_property_value)
	retGo := retC == C.TRUE

	return retGo
}

// RcPropertyParseEnum is a wrapper around the C function gtk_rc_property_parse_enum.
func RcPropertyParseEnum(pspec *gobject.ParamSpec, gstring *glib.String, propertyValue *gobject.Value) bool {
	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	c_gstring := (*C.GString)(C.NULL)
	if gstring != nil {
		c_gstring = (*C.GString)(gstring.ToC())
	}

	c_property_value := (*C.GValue)(C.NULL)
	if propertyValue != nil {
		c_property_value = (*C.GValue)(propertyValue.ToC())
	}

	retC := C.gtk_rc_property_parse_enum(c_pspec, c_gstring, c_property_value)
	retGo := retC == C.TRUE

	return retGo
}

// RcPropertyParseFlags is a wrapper around the C function gtk_rc_property_parse_flags.
func RcPropertyParseFlags(pspec *gobject.ParamSpec, gstring *glib.String, propertyValue *gobject.Value) bool {
	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	c_gstring := (*C.GString)(C.NULL)
	if gstring != nil {
		c_gstring = (*C.GString)(gstring.ToC())
	}

	c_property_value := (*C.GValue)(C.NULL)
	if propertyValue != nil {
		c_property_value = (*C.GValue)(propertyValue.ToC())
	}

	retC := C.gtk_rc_property_parse_flags(c_pspec, c_gstring, c_property_value)
	retGo := retC == C.TRUE

	return retGo
}

// RcPropertyParseRequisition is a wrapper around the C function gtk_rc_property_parse_requisition.
func RcPropertyParseRequisition(pspec *gobject.ParamSpec, gstring *glib.String, propertyValue *gobject.Value) bool {
	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	c_gstring := (*C.GString)(C.NULL)
	if gstring != nil {
		c_gstring = (*C.GString)(gstring.ToC())
	}

	c_property_value := (*C.GValue)(C.NULL)
	if propertyValue != nil {
		c_property_value = (*C.GValue)(propertyValue.ToC())
	}

	retC := C.gtk_rc_property_parse_requisition(c_pspec, c_gstring, c_property_value)
	retGo := retC == C.TRUE

	return retGo
}

// RcStyleClass is a wrapper around the C record GtkRcStyleClass.
type RcStyleClass struct {
	native *C.GtkRcStyleClass
	// parent_class : record
	// no type for create_rc_style
	// no type for parse
	// no type for merge
	// no type for create_style
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func RcStyleClassNewFromC(u unsafe.Pointer) *RcStyleClass {
	c := (*C.GtkRcStyleClass)(u)
	if c == nil {
		return nil
	}

	g := &RcStyleClass{native: c}

	return g
}

func (recv *RcStyleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RcStyleClass with another RcStyleClass, and returns true if they represent the same GObject.
func (recv *RcStyleClass) Equals(other *RcStyleClass) bool {
	return other.ToC() == recv.ToC()
}

// RecentActionClass is a wrapper around the C record GtkRecentActionClass.
type RecentActionClass struct {
	native *C.GtkRecentActionClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func RecentActionClassNewFromC(u unsafe.Pointer) *RecentActionClass {
	c := (*C.GtkRecentActionClass)(u)
	if c == nil {
		return nil
	}

	g := &RecentActionClass{native: c}

	return g
}

func (recv *RecentActionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentActionClass with another RecentActionClass, and returns true if they represent the same GObject.
func (recv *RecentActionClass) Equals(other *RecentActionClass) bool {
	return other.ToC() == recv.ToC()
}

// RecentActionPrivate is a wrapper around the C record GtkRecentActionPrivate.
type RecentActionPrivate struct {
	native *C.GtkRecentActionPrivate
}

func RecentActionPrivateNewFromC(u unsafe.Pointer) *RecentActionPrivate {
	c := (*C.GtkRecentActionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &RecentActionPrivate{native: c}

	return g
}

func (recv *RecentActionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentActionPrivate with another RecentActionPrivate, and returns true if they represent the same GObject.
func (recv *RecentActionPrivate) Equals(other *RecentActionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RecentChooserDialogClass is a wrapper around the C record GtkRecentChooserDialogClass.
type RecentChooserDialogClass struct {
	native *C.GtkRecentChooserDialogClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func RecentChooserDialogClassNewFromC(u unsafe.Pointer) *RecentChooserDialogClass {
	c := (*C.GtkRecentChooserDialogClass)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserDialogClass{native: c}

	return g
}

func (recv *RecentChooserDialogClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserDialogClass with another RecentChooserDialogClass, and returns true if they represent the same GObject.
func (recv *RecentChooserDialogClass) Equals(other *RecentChooserDialogClass) bool {
	return other.ToC() == recv.ToC()
}

// RecentChooserDialogPrivate is a wrapper around the C record GtkRecentChooserDialogPrivate.
type RecentChooserDialogPrivate struct {
	native *C.GtkRecentChooserDialogPrivate
}

func RecentChooserDialogPrivateNewFromC(u unsafe.Pointer) *RecentChooserDialogPrivate {
	c := (*C.GtkRecentChooserDialogPrivate)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserDialogPrivate{native: c}

	return g
}

func (recv *RecentChooserDialogPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserDialogPrivate with another RecentChooserDialogPrivate, and returns true if they represent the same GObject.
func (recv *RecentChooserDialogPrivate) Equals(other *RecentChooserDialogPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RecentChooserIface is a wrapper around the C record GtkRecentChooserIface.
type RecentChooserIface struct {
	native *C.GtkRecentChooserIface
	// Private : base_iface
	// no type for set_current_uri
	// no type for get_current_uri
	// no type for select_uri
	// no type for unselect_uri
	// no type for select_all
	// no type for unselect_all
	// no type for get_items
	// no type for get_recent_manager
	// no type for add_filter
	// no type for remove_filter
	// no type for list_filters
	// no type for set_sort_func
	// no type for item_activated
	// no type for selection_changed
}

func RecentChooserIfaceNewFromC(u unsafe.Pointer) *RecentChooserIface {
	c := (*C.GtkRecentChooserIface)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserIface{native: c}

	return g
}

func (recv *RecentChooserIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserIface with another RecentChooserIface, and returns true if they represent the same GObject.
func (recv *RecentChooserIface) Equals(other *RecentChooserIface) bool {
	return other.ToC() == recv.ToC()
}

// RecentChooserMenuClass is a wrapper around the C record GtkRecentChooserMenuClass.
type RecentChooserMenuClass struct {
	native *C.GtkRecentChooserMenuClass
	// parent_class : record
	// no type for gtk_recent1
	// no type for gtk_recent2
	// no type for gtk_recent3
	// no type for gtk_recent4
}

func RecentChooserMenuClassNewFromC(u unsafe.Pointer) *RecentChooserMenuClass {
	c := (*C.GtkRecentChooserMenuClass)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserMenuClass{native: c}

	return g
}

func (recv *RecentChooserMenuClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserMenuClass with another RecentChooserMenuClass, and returns true if they represent the same GObject.
func (recv *RecentChooserMenuClass) Equals(other *RecentChooserMenuClass) bool {
	return other.ToC() == recv.ToC()
}

// RecentChooserMenuPrivate is a wrapper around the C record GtkRecentChooserMenuPrivate.
type RecentChooserMenuPrivate struct {
	native *C.GtkRecentChooserMenuPrivate
}

func RecentChooserMenuPrivateNewFromC(u unsafe.Pointer) *RecentChooserMenuPrivate {
	c := (*C.GtkRecentChooserMenuPrivate)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserMenuPrivate{native: c}

	return g
}

func (recv *RecentChooserMenuPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserMenuPrivate with another RecentChooserMenuPrivate, and returns true if they represent the same GObject.
func (recv *RecentChooserMenuPrivate) Equals(other *RecentChooserMenuPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RecentChooserWidgetClass is a wrapper around the C record GtkRecentChooserWidgetClass.
type RecentChooserWidgetClass struct {
	native *C.GtkRecentChooserWidgetClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func RecentChooserWidgetClassNewFromC(u unsafe.Pointer) *RecentChooserWidgetClass {
	c := (*C.GtkRecentChooserWidgetClass)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserWidgetClass{native: c}

	return g
}

func (recv *RecentChooserWidgetClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserWidgetClass with another RecentChooserWidgetClass, and returns true if they represent the same GObject.
func (recv *RecentChooserWidgetClass) Equals(other *RecentChooserWidgetClass) bool {
	return other.ToC() == recv.ToC()
}

// RecentChooserWidgetPrivate is a wrapper around the C record GtkRecentChooserWidgetPrivate.
type RecentChooserWidgetPrivate struct {
	native *C.GtkRecentChooserWidgetPrivate
}

func RecentChooserWidgetPrivateNewFromC(u unsafe.Pointer) *RecentChooserWidgetPrivate {
	c := (*C.GtkRecentChooserWidgetPrivate)(u)
	if c == nil {
		return nil
	}

	g := &RecentChooserWidgetPrivate{native: c}

	return g
}

func (recv *RecentChooserWidgetPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentChooserWidgetPrivate with another RecentChooserWidgetPrivate, and returns true if they represent the same GObject.
func (recv *RecentChooserWidgetPrivate) Equals(other *RecentChooserWidgetPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RecentData is a wrapper around the C record GtkRecentData.
type RecentData struct {
	native      *C.GtkRecentData
	DisplayName string
	Description string
	MimeType    string
	AppName     string
	AppExec     string
	// no type for groups
	IsPrivate bool
}

func RecentDataNewFromC(u unsafe.Pointer) *RecentData {
	c := (*C.GtkRecentData)(u)
	if c == nil {
		return nil
	}

	g := &RecentData{
		AppExec:     C.GoString(c.app_exec),
		AppName:     C.GoString(c.app_name),
		Description: C.GoString(c.description),
		DisplayName: C.GoString(c.display_name),
		IsPrivate:   c.is_private == C.TRUE,
		MimeType:    C.GoString(c.mime_type),
		native:      c,
	}

	return g
}

func (recv *RecentData) ToC() unsafe.Pointer {
	recv.native.display_name =
		C.CString(recv.DisplayName)
	recv.native.description =
		C.CString(recv.Description)
	recv.native.mime_type =
		C.CString(recv.MimeType)
	recv.native.app_name =
		C.CString(recv.AppName)
	recv.native.app_exec =
		C.CString(recv.AppExec)
	recv.native.is_private =
		boolToGboolean(recv.IsPrivate)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentData with another RecentData, and returns true if they represent the same GObject.
func (recv *RecentData) Equals(other *RecentData) bool {
	return other.ToC() == recv.ToC()
}

// RecentFilterInfo is a wrapper around the C record GtkRecentFilterInfo.
type RecentFilterInfo struct {
	native      *C.GtkRecentFilterInfo
	Contains    RecentFilterFlags
	Uri         string
	DisplayName string
	MimeType    string
	// no type for applications
	// no type for groups
	Age int32
}

func RecentFilterInfoNewFromC(u unsafe.Pointer) *RecentFilterInfo {
	c := (*C.GtkRecentFilterInfo)(u)
	if c == nil {
		return nil
	}

	g := &RecentFilterInfo{
		Age:         (int32)(c.age),
		Contains:    (RecentFilterFlags)(c.contains),
		DisplayName: C.GoString(c.display_name),
		MimeType:    C.GoString(c.mime_type),
		Uri:         C.GoString(c.uri),
		native:      c,
	}

	return g
}

func (recv *RecentFilterInfo) ToC() unsafe.Pointer {
	recv.native.contains =
		(C.GtkRecentFilterFlags)(recv.Contains)
	recv.native.uri =
		C.CString(recv.Uri)
	recv.native.display_name =
		C.CString(recv.DisplayName)
	recv.native.mime_type =
		C.CString(recv.MimeType)
	recv.native.age =
		(C.gint)(recv.Age)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentFilterInfo with another RecentFilterInfo, and returns true if they represent the same GObject.
func (recv *RecentFilterInfo) Equals(other *RecentFilterInfo) bool {
	return other.ToC() == recv.ToC()
}

// RecentInfo is a wrapper around the C record GtkRecentInfo.
type RecentInfo struct {
	native *C.GtkRecentInfo
}

func RecentInfoNewFromC(u unsafe.Pointer) *RecentInfo {
	c := (*C.GtkRecentInfo)(u)
	if c == nil {
		return nil
	}

	g := &RecentInfo{native: c}

	return g
}

func (recv *RecentInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentInfo with another RecentInfo, and returns true if they represent the same GObject.
func (recv *RecentInfo) Equals(other *RecentInfo) bool {
	return other.ToC() == recv.ToC()
}

// CreateAppInfo is a wrapper around the C function gtk_recent_info_create_app_info.
func (recv *RecentInfo) CreateAppInfo(appName string) (*gio.AppInfo, error) {
	c_app_name := C.CString(appName)
	defer C.free(unsafe.Pointer(c_app_name))

	var cThrowableError *C.GError

	retC := C.gtk_recent_info_create_app_info((*C.GtkRecentInfo)(recv.native), c_app_name, &cThrowableError)
	var retGo (*gio.AppInfo)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gio.AppInfoNewFromC(unsafe.Pointer(retC))
	}

	var goError error = nil
	if cThrowableError != nil {
		goThrowableError := glib.ErrorNewFromC(unsafe.Pointer(cThrowableError))
		goError = goThrowableError

		C.g_error_free(cThrowableError)
	}

	return retGo, goError
}

// Exists is a wrapper around the C function gtk_recent_info_exists.
func (recv *RecentInfo) Exists() bool {
	retC := C.gtk_recent_info_exists((*C.GtkRecentInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetAdded is a wrapper around the C function gtk_recent_info_get_added.
func (recv *RecentInfo) GetAdded() int64 {
	retC := C.gtk_recent_info_get_added((*C.GtkRecentInfo)(recv.native))
	retGo := (int64)(retC)

	return retGo
}

// GetAge is a wrapper around the C function gtk_recent_info_get_age.
func (recv *RecentInfo) GetAge() int32 {
	retC := C.gtk_recent_info_get_age((*C.GtkRecentInfo)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetApplicationInfo is a wrapper around the C function gtk_recent_info_get_application_info.
func (recv *RecentInfo) GetApplicationInfo(appName string) (bool, string, uint32, int64) {
	c_app_name := C.CString(appName)
	defer C.free(unsafe.Pointer(c_app_name))

	var c_app_exec *C.gchar

	var c_count C.guint

	var c_time_ C.time_t

	retC := C.gtk_recent_info_get_application_info((*C.GtkRecentInfo)(recv.native), c_app_name, &c_app_exec, &c_count, &c_time_)
	retGo := retC == C.TRUE

	appExec := C.GoString(c_app_exec)

	count := (uint32)(c_count)

	time := (int64)(c_time_)

	return retGo, appExec, count, time
}

// GetApplications is a wrapper around the C function gtk_recent_info_get_applications.
func (recv *RecentInfo) GetApplications() ([]string, uint64) {
	var c_length C.gsize

	retC := C.gtk_recent_info_get_applications((*C.GtkRecentInfo)(recv.native), &c_length)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	length := (uint64)(c_length)

	return retGo, length
}

// GetDescription is a wrapper around the C function gtk_recent_info_get_description.
func (recv *RecentInfo) GetDescription() string {
	retC := C.gtk_recent_info_get_description((*C.GtkRecentInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetDisplayName is a wrapper around the C function gtk_recent_info_get_display_name.
func (recv *RecentInfo) GetDisplayName() string {
	retC := C.gtk_recent_info_get_display_name((*C.GtkRecentInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetGroups is a wrapper around the C function gtk_recent_info_get_groups.
func (recv *RecentInfo) GetGroups() ([]string, uint64) {
	var c_length C.gsize

	retC := C.gtk_recent_info_get_groups((*C.GtkRecentInfo)(recv.native), &c_length)
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	length := (uint64)(c_length)

	return retGo, length
}

// GetIcon is a wrapper around the C function gtk_recent_info_get_icon.
func (recv *RecentInfo) GetIcon(size int32) *gdkpixbuf.Pixbuf {
	c_size := (C.gint)(size)

	retC := C.gtk_recent_info_get_icon((*C.GtkRecentInfo)(recv.native), c_size)
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// GetMimeType is a wrapper around the C function gtk_recent_info_get_mime_type.
func (recv *RecentInfo) GetMimeType() string {
	retC := C.gtk_recent_info_get_mime_type((*C.GtkRecentInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetModified is a wrapper around the C function gtk_recent_info_get_modified.
func (recv *RecentInfo) GetModified() int64 {
	retC := C.gtk_recent_info_get_modified((*C.GtkRecentInfo)(recv.native))
	retGo := (int64)(retC)

	return retGo
}

// GetPrivateHint is a wrapper around the C function gtk_recent_info_get_private_hint.
func (recv *RecentInfo) GetPrivateHint() bool {
	retC := C.gtk_recent_info_get_private_hint((*C.GtkRecentInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// GetShortName is a wrapper around the C function gtk_recent_info_get_short_name.
func (recv *RecentInfo) GetShortName() string {
	retC := C.gtk_recent_info_get_short_name((*C.GtkRecentInfo)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetUri is a wrapper around the C function gtk_recent_info_get_uri.
func (recv *RecentInfo) GetUri() string {
	retC := C.gtk_recent_info_get_uri((*C.GtkRecentInfo)(recv.native))
	retGo := C.GoString(retC)

	return retGo
}

// GetUriDisplay is a wrapper around the C function gtk_recent_info_get_uri_display.
func (recv *RecentInfo) GetUriDisplay() string {
	retC := C.gtk_recent_info_get_uri_display((*C.GtkRecentInfo)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetVisited is a wrapper around the C function gtk_recent_info_get_visited.
func (recv *RecentInfo) GetVisited() int64 {
	retC := C.gtk_recent_info_get_visited((*C.GtkRecentInfo)(recv.native))
	retGo := (int64)(retC)

	return retGo
}

// HasApplication is a wrapper around the C function gtk_recent_info_has_application.
func (recv *RecentInfo) HasApplication(appName string) bool {
	c_app_name := C.CString(appName)
	defer C.free(unsafe.Pointer(c_app_name))

	retC := C.gtk_recent_info_has_application((*C.GtkRecentInfo)(recv.native), c_app_name)
	retGo := retC == C.TRUE

	return retGo
}

// HasGroup is a wrapper around the C function gtk_recent_info_has_group.
func (recv *RecentInfo) HasGroup(groupName string) bool {
	c_group_name := C.CString(groupName)
	defer C.free(unsafe.Pointer(c_group_name))

	retC := C.gtk_recent_info_has_group((*C.GtkRecentInfo)(recv.native), c_group_name)
	retGo := retC == C.TRUE

	return retGo
}

// IsLocal is a wrapper around the C function gtk_recent_info_is_local.
func (recv *RecentInfo) IsLocal() bool {
	retC := C.gtk_recent_info_is_local((*C.GtkRecentInfo)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// LastApplication is a wrapper around the C function gtk_recent_info_last_application.
func (recv *RecentInfo) LastApplication() string {
	retC := C.gtk_recent_info_last_application((*C.GtkRecentInfo)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Match is a wrapper around the C function gtk_recent_info_match.
func (recv *RecentInfo) Match(infoB *RecentInfo) bool {
	c_info_b := (*C.GtkRecentInfo)(C.NULL)
	if infoB != nil {
		c_info_b = (*C.GtkRecentInfo)(infoB.ToC())
	}

	retC := C.gtk_recent_info_match((*C.GtkRecentInfo)(recv.native), c_info_b)
	retGo := retC == C.TRUE

	return retGo
}

// Ref is a wrapper around the C function gtk_recent_info_ref.
func (recv *RecentInfo) Ref() *RecentInfo {
	retC := C.gtk_recent_info_ref((*C.GtkRecentInfo)(recv.native))
	retGo := RecentInfoNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function gtk_recent_info_unref.
func (recv *RecentInfo) Unref() {
	C.gtk_recent_info_unref((*C.GtkRecentInfo)(recv.native))

	return
}

// RecentManagerClass is a wrapper around the C record GtkRecentManagerClass.
type RecentManagerClass struct {
	native *C.GtkRecentManagerClass
	// Private : parent_class
	// no type for changed
	// no type for _gtk_recent1
	// no type for _gtk_recent2
	// no type for _gtk_recent3
	// no type for _gtk_recent4
}

func RecentManagerClassNewFromC(u unsafe.Pointer) *RecentManagerClass {
	c := (*C.GtkRecentManagerClass)(u)
	if c == nil {
		return nil
	}

	g := &RecentManagerClass{native: c}

	return g
}

func (recv *RecentManagerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentManagerClass with another RecentManagerClass, and returns true if they represent the same GObject.
func (recv *RecentManagerClass) Equals(other *RecentManagerClass) bool {
	return other.ToC() == recv.ToC()
}

// RecentManagerPrivate is a wrapper around the C record GtkRecentManagerPrivate.
type RecentManagerPrivate struct {
	native *C.GtkRecentManagerPrivate
}

func RecentManagerPrivateNewFromC(u unsafe.Pointer) *RecentManagerPrivate {
	c := (*C.GtkRecentManagerPrivate)(u)
	if c == nil {
		return nil
	}

	g := &RecentManagerPrivate{native: c}

	return g
}

func (recv *RecentManagerPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RecentManagerPrivate with another RecentManagerPrivate, and returns true if they represent the same GObject.
func (recv *RecentManagerPrivate) Equals(other *RecentManagerPrivate) bool {
	return other.ToC() == recv.ToC()
}

// RendererCellAccessibleClass is a wrapper around the C record GtkRendererCellAccessibleClass.
type RendererCellAccessibleClass struct {
	native *C.GtkRendererCellAccessibleClass
	// parent_class : record
}

func RendererCellAccessibleClassNewFromC(u unsafe.Pointer) *RendererCellAccessibleClass {
	c := (*C.GtkRendererCellAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &RendererCellAccessibleClass{native: c}

	return g
}

func (recv *RendererCellAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RendererCellAccessibleClass with another RendererCellAccessibleClass, and returns true if they represent the same GObject.
func (recv *RendererCellAccessibleClass) Equals(other *RendererCellAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// RendererCellAccessiblePrivate is a wrapper around the C record GtkRendererCellAccessiblePrivate.
type RendererCellAccessiblePrivate struct {
	native *C.GtkRendererCellAccessiblePrivate
}

func RendererCellAccessiblePrivateNewFromC(u unsafe.Pointer) *RendererCellAccessiblePrivate {
	c := (*C.GtkRendererCellAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &RendererCellAccessiblePrivate{native: c}

	return g
}

func (recv *RendererCellAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RendererCellAccessiblePrivate with another RendererCellAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *RendererCellAccessiblePrivate) Equals(other *RendererCellAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// RequestedSize is a wrapper around the C record GtkRequestedSize.
type RequestedSize struct {
	native      *C.GtkRequestedSize
	Data        uintptr
	MinimumSize int32
	NaturalSize int32
}

func RequestedSizeNewFromC(u unsafe.Pointer) *RequestedSize {
	c := (*C.GtkRequestedSize)(u)
	if c == nil {
		return nil
	}

	g := &RequestedSize{
		Data:        (uintptr)(c.data),
		MinimumSize: (int32)(c.minimum_size),
		NaturalSize: (int32)(c.natural_size),
		native:      c,
	}

	return g
}

func (recv *RequestedSize) ToC() unsafe.Pointer {
	recv.native.data =
		(C.gpointer)(recv.Data)
	recv.native.minimum_size =
		(C.gint)(recv.MinimumSize)
	recv.native.natural_size =
		(C.gint)(recv.NaturalSize)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RequestedSize with another RequestedSize, and returns true if they represent the same GObject.
func (recv *RequestedSize) Equals(other *RequestedSize) bool {
	return other.ToC() == recv.ToC()
}

// Requisition is a wrapper around the C record GtkRequisition.
type Requisition struct {
	native *C.GtkRequisition
	Width  int32
	Height int32
}

func RequisitionNewFromC(u unsafe.Pointer) *Requisition {
	c := (*C.GtkRequisition)(u)
	if c == nil {
		return nil
	}

	g := &Requisition{
		Height: (int32)(c.height),
		Width:  (int32)(c.width),
		native: c,
	}

	return g
}

func (recv *Requisition) ToC() unsafe.Pointer {
	recv.native.width =
		(C.gint)(recv.Width)
	recv.native.height =
		(C.gint)(recv.Height)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this Requisition with another Requisition, and returns true if they represent the same GObject.
func (recv *Requisition) Equals(other *Requisition) bool {
	return other.ToC() == recv.ToC()
}

// Copy is a wrapper around the C function gtk_requisition_copy.
func (recv *Requisition) Copy() *Requisition {
	retC := C.gtk_requisition_copy((*C.GtkRequisition)(recv.native))
	retGo := RequisitionNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_requisition_free.
func (recv *Requisition) Free() {
	C.gtk_requisition_free((*C.GtkRequisition)(recv.native))

	return
}

// RevealerClass is a wrapper around the C record GtkRevealerClass.
type RevealerClass struct {
	native *C.GtkRevealerClass
	// parent_class : record
}

func RevealerClassNewFromC(u unsafe.Pointer) *RevealerClass {
	c := (*C.GtkRevealerClass)(u)
	if c == nil {
		return nil
	}

	g := &RevealerClass{native: c}

	return g
}

func (recv *RevealerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this RevealerClass with another RevealerClass, and returns true if they represent the same GObject.
func (recv *RevealerClass) Equals(other *RevealerClass) bool {
	return other.ToC() == recv.ToC()
}

// ScaleAccessibleClass is a wrapper around the C record GtkScaleAccessibleClass.
type ScaleAccessibleClass struct {
	native *C.GtkScaleAccessibleClass
	// parent_class : record
}

func ScaleAccessibleClassNewFromC(u unsafe.Pointer) *ScaleAccessibleClass {
	c := (*C.GtkScaleAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ScaleAccessibleClass{native: c}

	return g
}

func (recv *ScaleAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleAccessibleClass with another ScaleAccessibleClass, and returns true if they represent the same GObject.
func (recv *ScaleAccessibleClass) Equals(other *ScaleAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ScaleAccessiblePrivate is a wrapper around the C record GtkScaleAccessiblePrivate.
type ScaleAccessiblePrivate struct {
	native *C.GtkScaleAccessiblePrivate
}

func ScaleAccessiblePrivateNewFromC(u unsafe.Pointer) *ScaleAccessiblePrivate {
	c := (*C.GtkScaleAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ScaleAccessiblePrivate{native: c}

	return g
}

func (recv *ScaleAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleAccessiblePrivate with another ScaleAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ScaleAccessiblePrivate) Equals(other *ScaleAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ScaleButtonAccessibleClass is a wrapper around the C record GtkScaleButtonAccessibleClass.
type ScaleButtonAccessibleClass struct {
	native *C.GtkScaleButtonAccessibleClass
	// parent_class : record
}

func ScaleButtonAccessibleClassNewFromC(u unsafe.Pointer) *ScaleButtonAccessibleClass {
	c := (*C.GtkScaleButtonAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButtonAccessibleClass{native: c}

	return g
}

func (recv *ScaleButtonAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleButtonAccessibleClass with another ScaleButtonAccessibleClass, and returns true if they represent the same GObject.
func (recv *ScaleButtonAccessibleClass) Equals(other *ScaleButtonAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ScaleButtonAccessiblePrivate is a wrapper around the C record GtkScaleButtonAccessiblePrivate.
type ScaleButtonAccessiblePrivate struct {
	native *C.GtkScaleButtonAccessiblePrivate
}

func ScaleButtonAccessiblePrivateNewFromC(u unsafe.Pointer) *ScaleButtonAccessiblePrivate {
	c := (*C.GtkScaleButtonAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButtonAccessiblePrivate{native: c}

	return g
}

func (recv *ScaleButtonAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleButtonAccessiblePrivate with another ScaleButtonAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ScaleButtonAccessiblePrivate) Equals(other *ScaleButtonAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ScaleButtonClass is a wrapper around the C record GtkScaleButtonClass.
type ScaleButtonClass struct {
	native *C.GtkScaleButtonClass
	// parent_class : record
	// no type for value_changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ScaleButtonClassNewFromC(u unsafe.Pointer) *ScaleButtonClass {
	c := (*C.GtkScaleButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButtonClass{native: c}

	return g
}

func (recv *ScaleButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleButtonClass with another ScaleButtonClass, and returns true if they represent the same GObject.
func (recv *ScaleButtonClass) Equals(other *ScaleButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// ScaleButtonPrivate is a wrapper around the C record GtkScaleButtonPrivate.
type ScaleButtonPrivate struct {
	native *C.GtkScaleButtonPrivate
}

func ScaleButtonPrivateNewFromC(u unsafe.Pointer) *ScaleButtonPrivate {
	c := (*C.GtkScaleButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ScaleButtonPrivate{native: c}

	return g
}

func (recv *ScaleButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleButtonPrivate with another ScaleButtonPrivate, and returns true if they represent the same GObject.
func (recv *ScaleButtonPrivate) Equals(other *ScaleButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ScaleClass is a wrapper around the C record GtkScaleClass.
type ScaleClass struct {
	native *C.GtkScaleClass
	// parent_class : record
	// no type for format_value
	// no type for draw_value
	// no type for get_layout_offsets
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ScaleClassNewFromC(u unsafe.Pointer) *ScaleClass {
	c := (*C.GtkScaleClass)(u)
	if c == nil {
		return nil
	}

	g := &ScaleClass{native: c}

	return g
}

func (recv *ScaleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScaleClass with another ScaleClass, and returns true if they represent the same GObject.
func (recv *ScaleClass) Equals(other *ScaleClass) bool {
	return other.ToC() == recv.ToC()
}

// ScalePrivate is a wrapper around the C record GtkScalePrivate.
type ScalePrivate struct {
	native *C.GtkScalePrivate
}

func ScalePrivateNewFromC(u unsafe.Pointer) *ScalePrivate {
	c := (*C.GtkScalePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ScalePrivate{native: c}

	return g
}

func (recv *ScalePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScalePrivate with another ScalePrivate, and returns true if they represent the same GObject.
func (recv *ScalePrivate) Equals(other *ScalePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ScrollableInterface is a wrapper around the C record GtkScrollableInterface.
type ScrollableInterface struct {
	native *C.GtkScrollableInterface
	// base_iface : record
	// no type for get_border
}

func ScrollableInterfaceNewFromC(u unsafe.Pointer) *ScrollableInterface {
	c := (*C.GtkScrollableInterface)(u)
	if c == nil {
		return nil
	}

	g := &ScrollableInterface{native: c}

	return g
}

func (recv *ScrollableInterface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrollableInterface with another ScrollableInterface, and returns true if they represent the same GObject.
func (recv *ScrollableInterface) Equals(other *ScrollableInterface) bool {
	return other.ToC() == recv.ToC()
}

// ScrollbarClass is a wrapper around the C record GtkScrollbarClass.
type ScrollbarClass struct {
	native *C.GtkScrollbarClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ScrollbarClassNewFromC(u unsafe.Pointer) *ScrollbarClass {
	c := (*C.GtkScrollbarClass)(u)
	if c == nil {
		return nil
	}

	g := &ScrollbarClass{native: c}

	return g
}

func (recv *ScrollbarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrollbarClass with another ScrollbarClass, and returns true if they represent the same GObject.
func (recv *ScrollbarClass) Equals(other *ScrollbarClass) bool {
	return other.ToC() == recv.ToC()
}

// ScrolledWindowAccessibleClass is a wrapper around the C record GtkScrolledWindowAccessibleClass.
type ScrolledWindowAccessibleClass struct {
	native *C.GtkScrolledWindowAccessibleClass
	// parent_class : record
}

func ScrolledWindowAccessibleClassNewFromC(u unsafe.Pointer) *ScrolledWindowAccessibleClass {
	c := (*C.GtkScrolledWindowAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindowAccessibleClass{native: c}

	return g
}

func (recv *ScrolledWindowAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrolledWindowAccessibleClass with another ScrolledWindowAccessibleClass, and returns true if they represent the same GObject.
func (recv *ScrolledWindowAccessibleClass) Equals(other *ScrolledWindowAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ScrolledWindowAccessiblePrivate is a wrapper around the C record GtkScrolledWindowAccessiblePrivate.
type ScrolledWindowAccessiblePrivate struct {
	native *C.GtkScrolledWindowAccessiblePrivate
}

func ScrolledWindowAccessiblePrivateNewFromC(u unsafe.Pointer) *ScrolledWindowAccessiblePrivate {
	c := (*C.GtkScrolledWindowAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindowAccessiblePrivate{native: c}

	return g
}

func (recv *ScrolledWindowAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrolledWindowAccessiblePrivate with another ScrolledWindowAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ScrolledWindowAccessiblePrivate) Equals(other *ScrolledWindowAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ScrolledWindowClass is a wrapper around the C record GtkScrolledWindowClass.
type ScrolledWindowClass struct {
	native *C.GtkScrolledWindowClass
	// parent_class : record
	ScrollbarSpacing int32
	// no type for scroll_child
	// no type for move_focus_out
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ScrolledWindowClassNewFromC(u unsafe.Pointer) *ScrolledWindowClass {
	c := (*C.GtkScrolledWindowClass)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindowClass{
		ScrollbarSpacing: (int32)(c.scrollbar_spacing),
		native:           c,
	}

	return g
}

func (recv *ScrolledWindowClass) ToC() unsafe.Pointer {
	recv.native.scrollbar_spacing =
		(C.gint)(recv.ScrollbarSpacing)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrolledWindowClass with another ScrolledWindowClass, and returns true if they represent the same GObject.
func (recv *ScrolledWindowClass) Equals(other *ScrolledWindowClass) bool {
	return other.ToC() == recv.ToC()
}

// ScrolledWindowPrivate is a wrapper around the C record GtkScrolledWindowPrivate.
type ScrolledWindowPrivate struct {
	native *C.GtkScrolledWindowPrivate
}

func ScrolledWindowPrivateNewFromC(u unsafe.Pointer) *ScrolledWindowPrivate {
	c := (*C.GtkScrolledWindowPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ScrolledWindowPrivate{native: c}

	return g
}

func (recv *ScrolledWindowPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ScrolledWindowPrivate with another ScrolledWindowPrivate, and returns true if they represent the same GObject.
func (recv *ScrolledWindowPrivate) Equals(other *ScrolledWindowPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SearchBarClass is a wrapper around the C record GtkSearchBarClass.
type SearchBarClass struct {
	native *C.GtkSearchBarClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SearchBarClassNewFromC(u unsafe.Pointer) *SearchBarClass {
	c := (*C.GtkSearchBarClass)(u)
	if c == nil {
		return nil
	}

	g := &SearchBarClass{native: c}

	return g
}

func (recv *SearchBarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SearchBarClass with another SearchBarClass, and returns true if they represent the same GObject.
func (recv *SearchBarClass) Equals(other *SearchBarClass) bool {
	return other.ToC() == recv.ToC()
}

// SearchEntryClass is a wrapper around the C record GtkSearchEntryClass.
type SearchEntryClass struct {
	native *C.GtkSearchEntryClass
	// parent_class : record
	// no type for search_changed
	// no type for next_match
	// no type for previous_match
	// no type for stop_search
}

func SearchEntryClassNewFromC(u unsafe.Pointer) *SearchEntryClass {
	c := (*C.GtkSearchEntryClass)(u)
	if c == nil {
		return nil
	}

	g := &SearchEntryClass{native: c}

	return g
}

func (recv *SearchEntryClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SearchEntryClass with another SearchEntryClass, and returns true if they represent the same GObject.
func (recv *SearchEntryClass) Equals(other *SearchEntryClass) bool {
	return other.ToC() == recv.ToC()
}

// SelectionData is a wrapper around the C record GtkSelectionData.
type SelectionData struct {
	native *C.GtkSelectionData
}

func SelectionDataNewFromC(u unsafe.Pointer) *SelectionData {
	c := (*C.GtkSelectionData)(u)
	if c == nil {
		return nil
	}

	g := &SelectionData{native: c}

	return g
}

func (recv *SelectionData) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SelectionData with another SelectionData, and returns true if they represent the same GObject.
func (recv *SelectionData) Equals(other *SelectionData) bool {
	return other.ToC() == recv.ToC()
}

// Copy is a wrapper around the C function gtk_selection_data_copy.
func (recv *SelectionData) Copy() *SelectionData {
	retC := C.gtk_selection_data_copy((*C.GtkSelectionData)(recv.native))
	retGo := SelectionDataNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_selection_data_free.
func (recv *SelectionData) Free() {
	C.gtk_selection_data_free((*C.GtkSelectionData)(recv.native))

	return
}

// GetPixbuf is a wrapper around the C function gtk_selection_data_get_pixbuf.
func (recv *SelectionData) GetPixbuf() *gdkpixbuf.Pixbuf {
	retC := C.gtk_selection_data_get_pixbuf((*C.GtkSelectionData)(recv.native))
	var retGo (*gdkpixbuf.Pixbuf)
	if retC == nil {
		retGo = nil
	} else {
		retGo = gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Unsupported : gtk_selection_data_get_targets : unsupported parameter targets : output array param targets

// Blacklisted : gtk_selection_data_get_text

// GetUris is a wrapper around the C function gtk_selection_data_get_uris.
func (recv *SelectionData) GetUris() []string {
	retC := C.gtk_selection_data_get_uris((*C.GtkSelectionData)(recv.native))
	retGo := []string{}
	for p := retC; *p != nil; p = (**C.char)(C.gpointer((uintptr(C.gpointer(p)) + uintptr(C.sizeof_gpointer)))) {
		s := C.GoString(*p)
		retGo = append(retGo, s)
	}
	defer C.g_strfreev(retC)

	return retGo
}

// Set is a wrapper around the C function gtk_selection_data_set.
func (recv *SelectionData) Set(type_ *gdk.Atom, format int32, data []uint8) {
	c_type := (C.GdkAtom)(C.NULL)
	if type_ != nil {
		c_type = (C.GdkAtom)(type_.ToC())
	}

	c_format := (C.gint)(format)

	c_data_array := make([]C.guchar, len(data)+1, len(data)+1)
	for i, item := range data {
		c := (C.guchar)(item)
		c_data_array[i] = c
	}
	c_data_array[len(data)] = 0
	c_data_arrayPtr := &c_data_array[0]
	c_data := (*C.guchar)(unsafe.Pointer(c_data_arrayPtr))

	c_length := (C.gint)(len(data))

	C.gtk_selection_data_set((*C.GtkSelectionData)(recv.native), c_type, c_format, c_data, c_length)

	return
}

// SetPixbuf is a wrapper around the C function gtk_selection_data_set_pixbuf.
func (recv *SelectionData) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) bool {
	c_pixbuf := (*C.GdkPixbuf)(C.NULL)
	if pixbuf != nil {
		c_pixbuf = (*C.GdkPixbuf)(pixbuf.ToC())
	}

	retC := C.gtk_selection_data_set_pixbuf((*C.GtkSelectionData)(recv.native), c_pixbuf)
	retGo := retC == C.TRUE

	return retGo
}

// SetText is a wrapper around the C function gtk_selection_data_set_text.
func (recv *SelectionData) SetText(str string, len int32) bool {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	c_len := (C.gint)(len)

	retC := C.gtk_selection_data_set_text((*C.GtkSelectionData)(recv.native), c_str, c_len)
	retGo := retC == C.TRUE

	return retGo
}

// SetUris is a wrapper around the C function gtk_selection_data_set_uris.
func (recv *SelectionData) SetUris(uris []string) bool {
	c_uris_array := make([]*C.gchar, len(uris)+1, len(uris)+1)
	for i, item := range uris {
		c := C.CString(item)
		defer C.free(unsafe.Pointer(c))
		c_uris_array[i] = c
	}
	c_uris_array[len(uris)] = nil
	c_uris_arrayPtr := &c_uris_array[0]
	c_uris := (**C.gchar)(unsafe.Pointer(c_uris_arrayPtr))

	retC := C.gtk_selection_data_set_uris((*C.GtkSelectionData)(recv.native), c_uris)
	retGo := retC == C.TRUE

	return retGo
}

// TargetsIncludeImage is a wrapper around the C function gtk_selection_data_targets_include_image.
func (recv *SelectionData) TargetsIncludeImage(writable bool) bool {
	c_writable :=
		boolToGboolean(writable)

	retC := C.gtk_selection_data_targets_include_image((*C.GtkSelectionData)(recv.native), c_writable)
	retGo := retC == C.TRUE

	return retGo
}

// TargetsIncludeRichText is a wrapper around the C function gtk_selection_data_targets_include_rich_text.
func (recv *SelectionData) TargetsIncludeRichText(buffer *TextBuffer) bool {
	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	retC := C.gtk_selection_data_targets_include_rich_text((*C.GtkSelectionData)(recv.native), c_buffer)
	retGo := retC == C.TRUE

	return retGo
}

// TargetsIncludeText is a wrapper around the C function gtk_selection_data_targets_include_text.
func (recv *SelectionData) TargetsIncludeText() bool {
	retC := C.gtk_selection_data_targets_include_text((*C.GtkSelectionData)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// TargetsIncludeUri is a wrapper around the C function gtk_selection_data_targets_include_uri.
func (recv *SelectionData) TargetsIncludeUri() bool {
	retC := C.gtk_selection_data_targets_include_uri((*C.GtkSelectionData)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// SeparatorClass is a wrapper around the C record GtkSeparatorClass.
type SeparatorClass struct {
	native *C.GtkSeparatorClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SeparatorClassNewFromC(u unsafe.Pointer) *SeparatorClass {
	c := (*C.GtkSeparatorClass)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorClass{native: c}

	return g
}

func (recv *SeparatorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorClass with another SeparatorClass, and returns true if they represent the same GObject.
func (recv *SeparatorClass) Equals(other *SeparatorClass) bool {
	return other.ToC() == recv.ToC()
}

// SeparatorMenuItemClass is a wrapper around the C record GtkSeparatorMenuItemClass.
type SeparatorMenuItemClass struct {
	native *C.GtkSeparatorMenuItemClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SeparatorMenuItemClassNewFromC(u unsafe.Pointer) *SeparatorMenuItemClass {
	c := (*C.GtkSeparatorMenuItemClass)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorMenuItemClass{native: c}

	return g
}

func (recv *SeparatorMenuItemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorMenuItemClass with another SeparatorMenuItemClass, and returns true if they represent the same GObject.
func (recv *SeparatorMenuItemClass) Equals(other *SeparatorMenuItemClass) bool {
	return other.ToC() == recv.ToC()
}

// SeparatorPrivate is a wrapper around the C record GtkSeparatorPrivate.
type SeparatorPrivate struct {
	native *C.GtkSeparatorPrivate
}

func SeparatorPrivateNewFromC(u unsafe.Pointer) *SeparatorPrivate {
	c := (*C.GtkSeparatorPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorPrivate{native: c}

	return g
}

func (recv *SeparatorPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorPrivate with another SeparatorPrivate, and returns true if they represent the same GObject.
func (recv *SeparatorPrivate) Equals(other *SeparatorPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SeparatorToolItemClass is a wrapper around the C record GtkSeparatorToolItemClass.
type SeparatorToolItemClass struct {
	native *C.GtkSeparatorToolItemClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SeparatorToolItemClassNewFromC(u unsafe.Pointer) *SeparatorToolItemClass {
	c := (*C.GtkSeparatorToolItemClass)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorToolItemClass{native: c}

	return g
}

func (recv *SeparatorToolItemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorToolItemClass with another SeparatorToolItemClass, and returns true if they represent the same GObject.
func (recv *SeparatorToolItemClass) Equals(other *SeparatorToolItemClass) bool {
	return other.ToC() == recv.ToC()
}

// SeparatorToolItemPrivate is a wrapper around the C record GtkSeparatorToolItemPrivate.
type SeparatorToolItemPrivate struct {
	native *C.GtkSeparatorToolItemPrivate
}

func SeparatorToolItemPrivateNewFromC(u unsafe.Pointer) *SeparatorToolItemPrivate {
	c := (*C.GtkSeparatorToolItemPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SeparatorToolItemPrivate{native: c}

	return g
}

func (recv *SeparatorToolItemPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SeparatorToolItemPrivate with another SeparatorToolItemPrivate, and returns true if they represent the same GObject.
func (recv *SeparatorToolItemPrivate) Equals(other *SeparatorToolItemPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SettingsClass is a wrapper around the C record GtkSettingsClass.
type SettingsClass struct {
	native *C.GtkSettingsClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SettingsClassNewFromC(u unsafe.Pointer) *SettingsClass {
	c := (*C.GtkSettingsClass)(u)
	if c == nil {
		return nil
	}

	g := &SettingsClass{native: c}

	return g
}

func (recv *SettingsClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsClass with another SettingsClass, and returns true if they represent the same GObject.
func (recv *SettingsClass) Equals(other *SettingsClass) bool {
	return other.ToC() == recv.ToC()
}

// SettingsPrivate is a wrapper around the C record GtkSettingsPrivate.
type SettingsPrivate struct {
	native *C.GtkSettingsPrivate
}

func SettingsPrivateNewFromC(u unsafe.Pointer) *SettingsPrivate {
	c := (*C.GtkSettingsPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SettingsPrivate{native: c}

	return g
}

func (recv *SettingsPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsPrivate with another SettingsPrivate, and returns true if they represent the same GObject.
func (recv *SettingsPrivate) Equals(other *SettingsPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SettingsValue is a wrapper around the C record GtkSettingsValue.
type SettingsValue struct {
	native *C.GtkSettingsValue
	Origin string
	// value : record
}

func SettingsValueNewFromC(u unsafe.Pointer) *SettingsValue {
	c := (*C.GtkSettingsValue)(u)
	if c == nil {
		return nil
	}

	g := &SettingsValue{
		Origin: C.GoString(c.origin),
		native: c,
	}

	return g
}

func (recv *SettingsValue) ToC() unsafe.Pointer {
	recv.native.origin =
		C.CString(recv.Origin)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SettingsValue with another SettingsValue, and returns true if they represent the same GObject.
func (recv *SettingsValue) Equals(other *SettingsValue) bool {
	return other.ToC() == recv.ToC()
}

// SizeGroupClass is a wrapper around the C record GtkSizeGroupClass.
type SizeGroupClass struct {
	native *C.GtkSizeGroupClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SizeGroupClassNewFromC(u unsafe.Pointer) *SizeGroupClass {
	c := (*C.GtkSizeGroupClass)(u)
	if c == nil {
		return nil
	}

	g := &SizeGroupClass{native: c}

	return g
}

func (recv *SizeGroupClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SizeGroupClass with another SizeGroupClass, and returns true if they represent the same GObject.
func (recv *SizeGroupClass) Equals(other *SizeGroupClass) bool {
	return other.ToC() == recv.ToC()
}

// SizeGroupPrivate is a wrapper around the C record GtkSizeGroupPrivate.
type SizeGroupPrivate struct {
	native *C.GtkSizeGroupPrivate
}

func SizeGroupPrivateNewFromC(u unsafe.Pointer) *SizeGroupPrivate {
	c := (*C.GtkSizeGroupPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SizeGroupPrivate{native: c}

	return g
}

func (recv *SizeGroupPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SizeGroupPrivate with another SizeGroupPrivate, and returns true if they represent the same GObject.
func (recv *SizeGroupPrivate) Equals(other *SizeGroupPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SocketClass is a wrapper around the C record GtkSocketClass.
type SocketClass struct {
	native *C.GtkSocketClass
	// parent_class : record
	// no type for plug_added
	// no type for plug_removed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SocketClassNewFromC(u unsafe.Pointer) *SocketClass {
	c := (*C.GtkSocketClass)(u)
	if c == nil {
		return nil
	}

	g := &SocketClass{native: c}

	return g
}

func (recv *SocketClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketClass with another SocketClass, and returns true if they represent the same GObject.
func (recv *SocketClass) Equals(other *SocketClass) bool {
	return other.ToC() == recv.ToC()
}

// SocketPrivate is a wrapper around the C record GtkSocketPrivate.
type SocketPrivate struct {
	native *C.GtkSocketPrivate
}

func SocketPrivateNewFromC(u unsafe.Pointer) *SocketPrivate {
	c := (*C.GtkSocketPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SocketPrivate{native: c}

	return g
}

func (recv *SocketPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SocketPrivate with another SocketPrivate, and returns true if they represent the same GObject.
func (recv *SocketPrivate) Equals(other *SocketPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SpinButtonAccessibleClass is a wrapper around the C record GtkSpinButtonAccessibleClass.
type SpinButtonAccessibleClass struct {
	native *C.GtkSpinButtonAccessibleClass
	// parent_class : record
}

func SpinButtonAccessibleClassNewFromC(u unsafe.Pointer) *SpinButtonAccessibleClass {
	c := (*C.GtkSpinButtonAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &SpinButtonAccessibleClass{native: c}

	return g
}

func (recv *SpinButtonAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinButtonAccessibleClass with another SpinButtonAccessibleClass, and returns true if they represent the same GObject.
func (recv *SpinButtonAccessibleClass) Equals(other *SpinButtonAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// SpinButtonAccessiblePrivate is a wrapper around the C record GtkSpinButtonAccessiblePrivate.
type SpinButtonAccessiblePrivate struct {
	native *C.GtkSpinButtonAccessiblePrivate
}

func SpinButtonAccessiblePrivateNewFromC(u unsafe.Pointer) *SpinButtonAccessiblePrivate {
	c := (*C.GtkSpinButtonAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &SpinButtonAccessiblePrivate{native: c}

	return g
}

func (recv *SpinButtonAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinButtonAccessiblePrivate with another SpinButtonAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *SpinButtonAccessiblePrivate) Equals(other *SpinButtonAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// SpinButtonClass is a wrapper around the C record GtkSpinButtonClass.
type SpinButtonClass struct {
	native *C.GtkSpinButtonClass
	// parent_class : record
	// no type for input
	// no type for output
	// no type for value_changed
	// no type for change_value
	// no type for wrapped
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SpinButtonClassNewFromC(u unsafe.Pointer) *SpinButtonClass {
	c := (*C.GtkSpinButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &SpinButtonClass{native: c}

	return g
}

func (recv *SpinButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinButtonClass with another SpinButtonClass, and returns true if they represent the same GObject.
func (recv *SpinButtonClass) Equals(other *SpinButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// SpinButtonPrivate is a wrapper around the C record GtkSpinButtonPrivate.
type SpinButtonPrivate struct {
	native *C.GtkSpinButtonPrivate
}

func SpinButtonPrivateNewFromC(u unsafe.Pointer) *SpinButtonPrivate {
	c := (*C.GtkSpinButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SpinButtonPrivate{native: c}

	return g
}

func (recv *SpinButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinButtonPrivate with another SpinButtonPrivate, and returns true if they represent the same GObject.
func (recv *SpinButtonPrivate) Equals(other *SpinButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SpinnerAccessibleClass is a wrapper around the C record GtkSpinnerAccessibleClass.
type SpinnerAccessibleClass struct {
	native *C.GtkSpinnerAccessibleClass
	// parent_class : record
}

func SpinnerAccessibleClassNewFromC(u unsafe.Pointer) *SpinnerAccessibleClass {
	c := (*C.GtkSpinnerAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &SpinnerAccessibleClass{native: c}

	return g
}

func (recv *SpinnerAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinnerAccessibleClass with another SpinnerAccessibleClass, and returns true if they represent the same GObject.
func (recv *SpinnerAccessibleClass) Equals(other *SpinnerAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// SpinnerAccessiblePrivate is a wrapper around the C record GtkSpinnerAccessiblePrivate.
type SpinnerAccessiblePrivate struct {
	native *C.GtkSpinnerAccessiblePrivate
}

func SpinnerAccessiblePrivateNewFromC(u unsafe.Pointer) *SpinnerAccessiblePrivate {
	c := (*C.GtkSpinnerAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &SpinnerAccessiblePrivate{native: c}

	return g
}

func (recv *SpinnerAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinnerAccessiblePrivate with another SpinnerAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *SpinnerAccessiblePrivate) Equals(other *SpinnerAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// SpinnerClass is a wrapper around the C record GtkSpinnerClass.
type SpinnerClass struct {
	native *C.GtkSpinnerClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func SpinnerClassNewFromC(u unsafe.Pointer) *SpinnerClass {
	c := (*C.GtkSpinnerClass)(u)
	if c == nil {
		return nil
	}

	g := &SpinnerClass{native: c}

	return g
}

func (recv *SpinnerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinnerClass with another SpinnerClass, and returns true if they represent the same GObject.
func (recv *SpinnerClass) Equals(other *SpinnerClass) bool {
	return other.ToC() == recv.ToC()
}

// SpinnerPrivate is a wrapper around the C record GtkSpinnerPrivate.
type SpinnerPrivate struct {
	native *C.GtkSpinnerPrivate
}

func SpinnerPrivateNewFromC(u unsafe.Pointer) *SpinnerPrivate {
	c := (*C.GtkSpinnerPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SpinnerPrivate{native: c}

	return g
}

func (recv *SpinnerPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SpinnerPrivate with another SpinnerPrivate, and returns true if they represent the same GObject.
func (recv *SpinnerPrivate) Equals(other *SpinnerPrivate) bool {
	return other.ToC() == recv.ToC()
}

// Blacklisted : GtkStackAccessibleClass

// StackClass is a wrapper around the C record GtkStackClass.
type StackClass struct {
	native *C.GtkStackClass
	// parent_class : record
}

func StackClassNewFromC(u unsafe.Pointer) *StackClass {
	c := (*C.GtkStackClass)(u)
	if c == nil {
		return nil
	}

	g := &StackClass{native: c}

	return g
}

func (recv *StackClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StackClass with another StackClass, and returns true if they represent the same GObject.
func (recv *StackClass) Equals(other *StackClass) bool {
	return other.ToC() == recv.ToC()
}

// StackSidebarClass is a wrapper around the C record GtkStackSidebarClass.
type StackSidebarClass struct {
	native *C.GtkStackSidebarClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func StackSidebarClassNewFromC(u unsafe.Pointer) *StackSidebarClass {
	c := (*C.GtkStackSidebarClass)(u)
	if c == nil {
		return nil
	}

	g := &StackSidebarClass{native: c}

	return g
}

func (recv *StackSidebarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StackSidebarClass with another StackSidebarClass, and returns true if they represent the same GObject.
func (recv *StackSidebarClass) Equals(other *StackSidebarClass) bool {
	return other.ToC() == recv.ToC()
}

// StackSidebarPrivate is a wrapper around the C record GtkStackSidebarPrivate.
type StackSidebarPrivate struct {
	native *C.GtkStackSidebarPrivate
}

func StackSidebarPrivateNewFromC(u unsafe.Pointer) *StackSidebarPrivate {
	c := (*C.GtkStackSidebarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &StackSidebarPrivate{native: c}

	return g
}

func (recv *StackSidebarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StackSidebarPrivate with another StackSidebarPrivate, and returns true if they represent the same GObject.
func (recv *StackSidebarPrivate) Equals(other *StackSidebarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// StackSwitcherClass is a wrapper around the C record GtkStackSwitcherClass.
type StackSwitcherClass struct {
	native *C.GtkStackSwitcherClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func StackSwitcherClassNewFromC(u unsafe.Pointer) *StackSwitcherClass {
	c := (*C.GtkStackSwitcherClass)(u)
	if c == nil {
		return nil
	}

	g := &StackSwitcherClass{native: c}

	return g
}

func (recv *StackSwitcherClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StackSwitcherClass with another StackSwitcherClass, and returns true if they represent the same GObject.
func (recv *StackSwitcherClass) Equals(other *StackSwitcherClass) bool {
	return other.ToC() == recv.ToC()
}

// StatusIconClass is a wrapper around the C record GtkStatusIconClass.
type StatusIconClass struct {
	native *C.GtkStatusIconClass
	// parent_class : record
	// no type for activate
	// no type for popup_menu
	// no type for size_changed
	// no type for button_press_event
	// no type for button_release_event
	// no type for scroll_event
	// no type for query_tooltip
	// __gtk_reserved1 : void* with indirection level of 1
	// __gtk_reserved2 : void* with indirection level of 1
	// __gtk_reserved3 : void* with indirection level of 1
	// __gtk_reserved4 : void* with indirection level of 1
}

func StatusIconClassNewFromC(u unsafe.Pointer) *StatusIconClass {
	c := (*C.GtkStatusIconClass)(u)
	if c == nil {
		return nil
	}

	g := &StatusIconClass{native: c}

	return g
}

func (recv *StatusIconClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusIconClass with another StatusIconClass, and returns true if they represent the same GObject.
func (recv *StatusIconClass) Equals(other *StatusIconClass) bool {
	return other.ToC() == recv.ToC()
}

// StatusIconPrivate is a wrapper around the C record GtkStatusIconPrivate.
type StatusIconPrivate struct {
	native *C.GtkStatusIconPrivate
}

func StatusIconPrivateNewFromC(u unsafe.Pointer) *StatusIconPrivate {
	c := (*C.GtkStatusIconPrivate)(u)
	if c == nil {
		return nil
	}

	g := &StatusIconPrivate{native: c}

	return g
}

func (recv *StatusIconPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusIconPrivate with another StatusIconPrivate, and returns true if they represent the same GObject.
func (recv *StatusIconPrivate) Equals(other *StatusIconPrivate) bool {
	return other.ToC() == recv.ToC()
}

// StatusbarAccessibleClass is a wrapper around the C record GtkStatusbarAccessibleClass.
type StatusbarAccessibleClass struct {
	native *C.GtkStatusbarAccessibleClass
	// parent_class : record
}

func StatusbarAccessibleClassNewFromC(u unsafe.Pointer) *StatusbarAccessibleClass {
	c := (*C.GtkStatusbarAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &StatusbarAccessibleClass{native: c}

	return g
}

func (recv *StatusbarAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusbarAccessibleClass with another StatusbarAccessibleClass, and returns true if they represent the same GObject.
func (recv *StatusbarAccessibleClass) Equals(other *StatusbarAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// StatusbarAccessiblePrivate is a wrapper around the C record GtkStatusbarAccessiblePrivate.
type StatusbarAccessiblePrivate struct {
	native *C.GtkStatusbarAccessiblePrivate
}

func StatusbarAccessiblePrivateNewFromC(u unsafe.Pointer) *StatusbarAccessiblePrivate {
	c := (*C.GtkStatusbarAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &StatusbarAccessiblePrivate{native: c}

	return g
}

func (recv *StatusbarAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusbarAccessiblePrivate with another StatusbarAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *StatusbarAccessiblePrivate) Equals(other *StatusbarAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// StatusbarClass is a wrapper around the C record GtkStatusbarClass.
type StatusbarClass struct {
	native *C.GtkStatusbarClass
	// parent_class : record
	Reserved uintptr
	// no type for text_pushed
	// no type for text_popped
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func StatusbarClassNewFromC(u unsafe.Pointer) *StatusbarClass {
	c := (*C.GtkStatusbarClass)(u)
	if c == nil {
		return nil
	}

	g := &StatusbarClass{
		Reserved: (uintptr)(c.reserved),
		native:   c,
	}

	return g
}

func (recv *StatusbarClass) ToC() unsafe.Pointer {
	recv.native.reserved =
		(C.gpointer)(recv.Reserved)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusbarClass with another StatusbarClass, and returns true if they represent the same GObject.
func (recv *StatusbarClass) Equals(other *StatusbarClass) bool {
	return other.ToC() == recv.ToC()
}

// StatusbarPrivate is a wrapper around the C record GtkStatusbarPrivate.
type StatusbarPrivate struct {
	native *C.GtkStatusbarPrivate
}

func StatusbarPrivateNewFromC(u unsafe.Pointer) *StatusbarPrivate {
	c := (*C.GtkStatusbarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &StatusbarPrivate{native: c}

	return g
}

func (recv *StatusbarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StatusbarPrivate with another StatusbarPrivate, and returns true if they represent the same GObject.
func (recv *StatusbarPrivate) Equals(other *StatusbarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// StockItem is a wrapper around the C record GtkStockItem.
type StockItem struct {
	native            *C.GtkStockItem
	StockId           string
	Label             string
	Modifier          gdk.ModifierType
	Keyval            uint32
	TranslationDomain string
}

func StockItemNewFromC(u unsafe.Pointer) *StockItem {
	c := (*C.GtkStockItem)(u)
	if c == nil {
		return nil
	}

	g := &StockItem{
		Keyval:            (uint32)(c.keyval),
		Label:             C.GoString(c.label),
		Modifier:          (gdk.ModifierType)(c.modifier),
		StockId:           C.GoString(c.stock_id),
		TranslationDomain: C.GoString(c.translation_domain),
		native:            c,
	}

	return g
}

func (recv *StockItem) ToC() unsafe.Pointer {
	recv.native.stock_id =
		C.CString(recv.StockId)
	recv.native.label =
		C.CString(recv.Label)
	recv.native.modifier =
		(C.GdkModifierType)(recv.Modifier)
	recv.native.keyval =
		(C.guint)(recv.Keyval)
	recv.native.translation_domain =
		C.CString(recv.TranslationDomain)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StockItem with another StockItem, and returns true if they represent the same GObject.
func (recv *StockItem) Equals(other *StockItem) bool {
	return other.ToC() == recv.ToC()
}

// Copy is a wrapper around the C function gtk_stock_item_copy.
func (recv *StockItem) Copy() *StockItem {
	retC := C.gtk_stock_item_copy((*C.GtkStockItem)(recv.native))
	retGo := StockItemNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_stock_item_free.
func (recv *StockItem) Free() {
	C.gtk_stock_item_free((*C.GtkStockItem)(recv.native))

	return
}

// StyleClass is a wrapper around the C record GtkStyleClass.
type StyleClass struct {
	native *C.GtkStyleClass
	// parent_class : record
	// no type for realize
	// no type for unrealize
	// no type for copy
	// no type for clone
	// no type for init_from_rc
	// no type for set_background
	// no type for render_icon
	// no type for draw_hline
	// no type for draw_vline
	// no type for draw_shadow
	// no type for draw_arrow
	// no type for draw_diamond
	// no type for draw_box
	// no type for draw_flat_box
	// no type for draw_check
	// no type for draw_option
	// no type for draw_tab
	// no type for draw_shadow_gap
	// no type for draw_box_gap
	// no type for draw_extension
	// no type for draw_focus
	// no type for draw_slider
	// no type for draw_handle
	// no type for draw_expander
	// no type for draw_layout
	// no type for draw_resize_grip
	// no type for draw_spinner
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
	// no type for _gtk_reserved9
	// no type for _gtk_reserved10
	// no type for _gtk_reserved11
}

func StyleClassNewFromC(u unsafe.Pointer) *StyleClass {
	c := (*C.GtkStyleClass)(u)
	if c == nil {
		return nil
	}

	g := &StyleClass{native: c}

	return g
}

func (recv *StyleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleClass with another StyleClass, and returns true if they represent the same GObject.
func (recv *StyleClass) Equals(other *StyleClass) bool {
	return other.ToC() == recv.ToC()
}

// StyleContextClass is a wrapper around the C record GtkStyleContextClass.
type StyleContextClass struct {
	native *C.GtkStyleContextClass
	// parent_class : record
	// no type for changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func StyleContextClassNewFromC(u unsafe.Pointer) *StyleContextClass {
	c := (*C.GtkStyleContextClass)(u)
	if c == nil {
		return nil
	}

	g := &StyleContextClass{native: c}

	return g
}

func (recv *StyleContextClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleContextClass with another StyleContextClass, and returns true if they represent the same GObject.
func (recv *StyleContextClass) Equals(other *StyleContextClass) bool {
	return other.ToC() == recv.ToC()
}

// StyleContextPrivate is a wrapper around the C record GtkStyleContextPrivate.
type StyleContextPrivate struct {
	native *C.GtkStyleContextPrivate
}

func StyleContextPrivateNewFromC(u unsafe.Pointer) *StyleContextPrivate {
	c := (*C.GtkStyleContextPrivate)(u)
	if c == nil {
		return nil
	}

	g := &StyleContextPrivate{native: c}

	return g
}

func (recv *StyleContextPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleContextPrivate with another StyleContextPrivate, and returns true if they represent the same GObject.
func (recv *StyleContextPrivate) Equals(other *StyleContextPrivate) bool {
	return other.ToC() == recv.ToC()
}

// StylePropertiesClass is a wrapper around the C record GtkStylePropertiesClass.
type StylePropertiesClass struct {
	native *C.GtkStylePropertiesClass
	// Private : parent_class
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func StylePropertiesClassNewFromC(u unsafe.Pointer) *StylePropertiesClass {
	c := (*C.GtkStylePropertiesClass)(u)
	if c == nil {
		return nil
	}

	g := &StylePropertiesClass{native: c}

	return g
}

func (recv *StylePropertiesClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StylePropertiesClass with another StylePropertiesClass, and returns true if they represent the same GObject.
func (recv *StylePropertiesClass) Equals(other *StylePropertiesClass) bool {
	return other.ToC() == recv.ToC()
}

// StylePropertiesPrivate is a wrapper around the C record GtkStylePropertiesPrivate.
type StylePropertiesPrivate struct {
	native *C.GtkStylePropertiesPrivate
}

func StylePropertiesPrivateNewFromC(u unsafe.Pointer) *StylePropertiesPrivate {
	c := (*C.GtkStylePropertiesPrivate)(u)
	if c == nil {
		return nil
	}

	g := &StylePropertiesPrivate{native: c}

	return g
}

func (recv *StylePropertiesPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StylePropertiesPrivate with another StylePropertiesPrivate, and returns true if they represent the same GObject.
func (recv *StylePropertiesPrivate) Equals(other *StylePropertiesPrivate) bool {
	return other.ToC() == recv.ToC()
}

// StyleProviderIface is a wrapper around the C record GtkStyleProviderIface.
type StyleProviderIface struct {
	native *C.GtkStyleProviderIface
	// Private : g_iface
	// no type for get_style
	// no type for get_style_property
	// no type for get_icon_factory
}

func StyleProviderIfaceNewFromC(u unsafe.Pointer) *StyleProviderIface {
	c := (*C.GtkStyleProviderIface)(u)
	if c == nil {
		return nil
	}

	g := &StyleProviderIface{native: c}

	return g
}

func (recv *StyleProviderIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this StyleProviderIface with another StyleProviderIface, and returns true if they represent the same GObject.
func (recv *StyleProviderIface) Equals(other *StyleProviderIface) bool {
	return other.ToC() == recv.ToC()
}

// SwitchAccessibleClass is a wrapper around the C record GtkSwitchAccessibleClass.
type SwitchAccessibleClass struct {
	native *C.GtkSwitchAccessibleClass
	// parent_class : record
}

func SwitchAccessibleClassNewFromC(u unsafe.Pointer) *SwitchAccessibleClass {
	c := (*C.GtkSwitchAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &SwitchAccessibleClass{native: c}

	return g
}

func (recv *SwitchAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SwitchAccessibleClass with another SwitchAccessibleClass, and returns true if they represent the same GObject.
func (recv *SwitchAccessibleClass) Equals(other *SwitchAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// SwitchAccessiblePrivate is a wrapper around the C record GtkSwitchAccessiblePrivate.
type SwitchAccessiblePrivate struct {
	native *C.GtkSwitchAccessiblePrivate
}

func SwitchAccessiblePrivateNewFromC(u unsafe.Pointer) *SwitchAccessiblePrivate {
	c := (*C.GtkSwitchAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &SwitchAccessiblePrivate{native: c}

	return g
}

func (recv *SwitchAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SwitchAccessiblePrivate with another SwitchAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *SwitchAccessiblePrivate) Equals(other *SwitchAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// SwitchClass is a wrapper around the C record GtkSwitchClass.
type SwitchClass struct {
	native *C.GtkSwitchClass
	// parent_class : record
	// no type for activate
	// no type for state_set
	// no type for _switch_padding_1
	// no type for _switch_padding_2
	// no type for _switch_padding_3
	// no type for _switch_padding_4
	// no type for _switch_padding_5
}

func SwitchClassNewFromC(u unsafe.Pointer) *SwitchClass {
	c := (*C.GtkSwitchClass)(u)
	if c == nil {
		return nil
	}

	g := &SwitchClass{native: c}

	return g
}

func (recv *SwitchClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SwitchClass with another SwitchClass, and returns true if they represent the same GObject.
func (recv *SwitchClass) Equals(other *SwitchClass) bool {
	return other.ToC() == recv.ToC()
}

// SwitchPrivate is a wrapper around the C record GtkSwitchPrivate.
type SwitchPrivate struct {
	native *C.GtkSwitchPrivate
}

func SwitchPrivateNewFromC(u unsafe.Pointer) *SwitchPrivate {
	c := (*C.GtkSwitchPrivate)(u)
	if c == nil {
		return nil
	}

	g := &SwitchPrivate{native: c}

	return g
}

func (recv *SwitchPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SwitchPrivate with another SwitchPrivate, and returns true if they represent the same GObject.
func (recv *SwitchPrivate) Equals(other *SwitchPrivate) bool {
	return other.ToC() == recv.ToC()
}

// SymbolicColor is a wrapper around the C record GtkSymbolicColor.
type SymbolicColor struct {
	native *C.GtkSymbolicColor
}

func SymbolicColorNewFromC(u unsafe.Pointer) *SymbolicColor {
	c := (*C.GtkSymbolicColor)(u)
	if c == nil {
		return nil
	}

	g := &SymbolicColor{native: c}

	return g
}

func (recv *SymbolicColor) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this SymbolicColor with another SymbolicColor, and returns true if they represent the same GObject.
func (recv *SymbolicColor) Equals(other *SymbolicColor) bool {
	return other.ToC() == recv.ToC()
}

// ToString is a wrapper around the C function gtk_symbolic_color_to_string.
func (recv *SymbolicColor) ToString() string {
	retC := C.gtk_symbolic_color_to_string((*C.GtkSymbolicColor)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// TableChild is a wrapper around the C record GtkTableChild.
type TableChild struct {
	native *C.GtkTableChild
	// widget : record
	LeftAttach   uint16
	RightAttach  uint16
	TopAttach    uint16
	BottomAttach uint16
	Xpadding     uint16
	Ypadding     uint16
	// Bitfield not supported :  1 xexpand
	// Bitfield not supported :  1 yexpand
	// Bitfield not supported :  1 xshrink
	// Bitfield not supported :  1 yshrink
	// Bitfield not supported :  1 xfill
	// Bitfield not supported :  1 yfill
}

func TableChildNewFromC(u unsafe.Pointer) *TableChild {
	c := (*C.GtkTableChild)(u)
	if c == nil {
		return nil
	}

	g := &TableChild{
		BottomAttach: (uint16)(c.bottom_attach),
		LeftAttach:   (uint16)(c.left_attach),
		RightAttach:  (uint16)(c.right_attach),
		TopAttach:    (uint16)(c.top_attach),
		Xpadding:     (uint16)(c.xpadding),
		Ypadding:     (uint16)(c.ypadding),
		native:       c,
	}

	return g
}

func (recv *TableChild) ToC() unsafe.Pointer {
	recv.native.left_attach =
		(C.guint16)(recv.LeftAttach)
	recv.native.right_attach =
		(C.guint16)(recv.RightAttach)
	recv.native.top_attach =
		(C.guint16)(recv.TopAttach)
	recv.native.bottom_attach =
		(C.guint16)(recv.BottomAttach)
	recv.native.xpadding =
		(C.guint16)(recv.Xpadding)
	recv.native.ypadding =
		(C.guint16)(recv.Ypadding)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TableChild with another TableChild, and returns true if they represent the same GObject.
func (recv *TableChild) Equals(other *TableChild) bool {
	return other.ToC() == recv.ToC()
}

// TableClass is a wrapper around the C record GtkTableClass.
type TableClass struct {
	native *C.GtkTableClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TableClassNewFromC(u unsafe.Pointer) *TableClass {
	c := (*C.GtkTableClass)(u)
	if c == nil {
		return nil
	}

	g := &TableClass{native: c}

	return g
}

func (recv *TableClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TableClass with another TableClass, and returns true if they represent the same GObject.
func (recv *TableClass) Equals(other *TableClass) bool {
	return other.ToC() == recv.ToC()
}

// TablePrivate is a wrapper around the C record GtkTablePrivate.
type TablePrivate struct {
	native *C.GtkTablePrivate
}

func TablePrivateNewFromC(u unsafe.Pointer) *TablePrivate {
	c := (*C.GtkTablePrivate)(u)
	if c == nil {
		return nil
	}

	g := &TablePrivate{native: c}

	return g
}

func (recv *TablePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TablePrivate with another TablePrivate, and returns true if they represent the same GObject.
func (recv *TablePrivate) Equals(other *TablePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TableRowCol is a wrapper around the C record GtkTableRowCol.
type TableRowCol struct {
	native      *C.GtkTableRowCol
	Requisition uint16
	Allocation  uint16
	Spacing     uint16
	// Bitfield not supported :  1 need_expand
	// Bitfield not supported :  1 need_shrink
	// Bitfield not supported :  1 expand
	// Bitfield not supported :  1 shrink
	// Bitfield not supported :  1 empty
}

func TableRowColNewFromC(u unsafe.Pointer) *TableRowCol {
	c := (*C.GtkTableRowCol)(u)
	if c == nil {
		return nil
	}

	g := &TableRowCol{
		Allocation:  (uint16)(c.allocation),
		Requisition: (uint16)(c.requisition),
		Spacing:     (uint16)(c.spacing),
		native:      c,
	}

	return g
}

func (recv *TableRowCol) ToC() unsafe.Pointer {
	recv.native.requisition =
		(C.guint16)(recv.Requisition)
	recv.native.allocation =
		(C.guint16)(recv.Allocation)
	recv.native.spacing =
		(C.guint16)(recv.Spacing)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TableRowCol with another TableRowCol, and returns true if they represent the same GObject.
func (recv *TableRowCol) Equals(other *TableRowCol) bool {
	return other.ToC() == recv.ToC()
}

// TargetEntry is a wrapper around the C record GtkTargetEntry.
type TargetEntry struct {
	native *C.GtkTargetEntry
	Target string
	Flags  uint32
	Info   uint32
}

func TargetEntryNewFromC(u unsafe.Pointer) *TargetEntry {
	c := (*C.GtkTargetEntry)(u)
	if c == nil {
		return nil
	}

	g := &TargetEntry{
		Flags:  (uint32)(c.flags),
		Info:   (uint32)(c.info),
		Target: C.GoString(c.target),
		native: c,
	}

	return g
}

func (recv *TargetEntry) ToC() unsafe.Pointer {
	recv.native.target =
		C.CString(recv.Target)
	recv.native.flags =
		(C.guint)(recv.Flags)
	recv.native.info =
		(C.guint)(recv.Info)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TargetEntry with another TargetEntry, and returns true if they represent the same GObject.
func (recv *TargetEntry) Equals(other *TargetEntry) bool {
	return other.ToC() == recv.ToC()
}

// TargetEntryNew is a wrapper around the C function gtk_target_entry_new.
func TargetEntryNew(target string, flags uint32, info uint32) *TargetEntry {
	c_target := C.CString(target)
	defer C.free(unsafe.Pointer(c_target))

	c_flags := (C.guint)(flags)

	c_info := (C.guint)(info)

	retC := C.gtk_target_entry_new(c_target, c_flags, c_info)
	retGo := TargetEntryNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Copy is a wrapper around the C function gtk_target_entry_copy.
func (recv *TargetEntry) Copy() *TargetEntry {
	retC := C.gtk_target_entry_copy((*C.GtkTargetEntry)(recv.native))
	retGo := TargetEntryNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_target_entry_free.
func (recv *TargetEntry) Free() {
	C.gtk_target_entry_free((*C.GtkTargetEntry)(recv.native))

	return
}

// TargetList is a wrapper around the C record GtkTargetList.
type TargetList struct {
	native *C.GtkTargetList
}

func TargetListNewFromC(u unsafe.Pointer) *TargetList {
	c := (*C.GtkTargetList)(u)
	if c == nil {
		return nil
	}

	g := &TargetList{native: c}

	return g
}

func (recv *TargetList) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TargetList with another TargetList, and returns true if they represent the same GObject.
func (recv *TargetList) Equals(other *TargetList) bool {
	return other.ToC() == recv.ToC()
}

// Unsupported : gtk_target_list_new : unsupported parameter targets :

// Add is a wrapper around the C function gtk_target_list_add.
func (recv *TargetList) Add(target *gdk.Atom, flags uint32, info uint32) {
	c_target := (C.GdkAtom)(C.NULL)
	if target != nil {
		c_target = (C.GdkAtom)(target.ToC())
	}

	c_flags := (C.guint)(flags)

	c_info := (C.guint)(info)

	C.gtk_target_list_add((*C.GtkTargetList)(recv.native), c_target, c_flags, c_info)

	return
}

// AddImageTargets is a wrapper around the C function gtk_target_list_add_image_targets.
func (recv *TargetList) AddImageTargets(info uint32, writable bool) {
	c_info := (C.guint)(info)

	c_writable :=
		boolToGboolean(writable)

	C.gtk_target_list_add_image_targets((*C.GtkTargetList)(recv.native), c_info, c_writable)

	return
}

// AddRichTextTargets is a wrapper around the C function gtk_target_list_add_rich_text_targets.
func (recv *TargetList) AddRichTextTargets(info uint32, deserializable bool, buffer *TextBuffer) {
	c_info := (C.guint)(info)

	c_deserializable :=
		boolToGboolean(deserializable)

	c_buffer := (*C.GtkTextBuffer)(C.NULL)
	if buffer != nil {
		c_buffer = (*C.GtkTextBuffer)(buffer.ToC())
	}

	C.gtk_target_list_add_rich_text_targets((*C.GtkTargetList)(recv.native), c_info, c_deserializable, c_buffer)

	return
}

// Unsupported : gtk_target_list_add_table : unsupported parameter targets :

// AddTextTargets is a wrapper around the C function gtk_target_list_add_text_targets.
func (recv *TargetList) AddTextTargets(info uint32) {
	c_info := (C.guint)(info)

	C.gtk_target_list_add_text_targets((*C.GtkTargetList)(recv.native), c_info)

	return
}

// AddUriTargets is a wrapper around the C function gtk_target_list_add_uri_targets.
func (recv *TargetList) AddUriTargets(info uint32) {
	c_info := (C.guint)(info)

	C.gtk_target_list_add_uri_targets((*C.GtkTargetList)(recv.native), c_info)

	return
}

// Find is a wrapper around the C function gtk_target_list_find.
func (recv *TargetList) Find(target *gdk.Atom) (bool, uint32) {
	c_target := (C.GdkAtom)(C.NULL)
	if target != nil {
		c_target = (C.GdkAtom)(target.ToC())
	}

	var c_info C.guint

	retC := C.gtk_target_list_find((*C.GtkTargetList)(recv.native), c_target, &c_info)
	retGo := retC == C.TRUE

	info := (uint32)(c_info)

	return retGo, info
}

// Ref is a wrapper around the C function gtk_target_list_ref.
func (recv *TargetList) Ref() *TargetList {
	retC := C.gtk_target_list_ref((*C.GtkTargetList)(recv.native))
	retGo := TargetListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Remove is a wrapper around the C function gtk_target_list_remove.
func (recv *TargetList) Remove(target *gdk.Atom) {
	c_target := (C.GdkAtom)(C.NULL)
	if target != nil {
		c_target = (C.GdkAtom)(target.ToC())
	}

	C.gtk_target_list_remove((*C.GtkTargetList)(recv.native), c_target)

	return
}

// Unref is a wrapper around the C function gtk_target_list_unref.
func (recv *TargetList) Unref() {
	C.gtk_target_list_unref((*C.GtkTargetList)(recv.native))

	return
}

// TargetPair is a wrapper around the C record GtkTargetPair.
type TargetPair struct {
	native *C.GtkTargetPair
	// target : record
	Flags uint32
	Info  uint32
}

func TargetPairNewFromC(u unsafe.Pointer) *TargetPair {
	c := (*C.GtkTargetPair)(u)
	if c == nil {
		return nil
	}

	g := &TargetPair{
		Flags:  (uint32)(c.flags),
		Info:   (uint32)(c.info),
		native: c,
	}

	return g
}

func (recv *TargetPair) ToC() unsafe.Pointer {
	recv.native.flags =
		(C.guint)(recv.Flags)
	recv.native.info =
		(C.guint)(recv.Info)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TargetPair with another TargetPair, and returns true if they represent the same GObject.
func (recv *TargetPair) Equals(other *TargetPair) bool {
	return other.ToC() == recv.ToC()
}

// TearoffMenuItemClass is a wrapper around the C record GtkTearoffMenuItemClass.
type TearoffMenuItemClass struct {
	native *C.GtkTearoffMenuItemClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TearoffMenuItemClassNewFromC(u unsafe.Pointer) *TearoffMenuItemClass {
	c := (*C.GtkTearoffMenuItemClass)(u)
	if c == nil {
		return nil
	}

	g := &TearoffMenuItemClass{native: c}

	return g
}

func (recv *TearoffMenuItemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TearoffMenuItemClass with another TearoffMenuItemClass, and returns true if they represent the same GObject.
func (recv *TearoffMenuItemClass) Equals(other *TearoffMenuItemClass) bool {
	return other.ToC() == recv.ToC()
}

// TearoffMenuItemPrivate is a wrapper around the C record GtkTearoffMenuItemPrivate.
type TearoffMenuItemPrivate struct {
	native *C.GtkTearoffMenuItemPrivate
}

func TearoffMenuItemPrivateNewFromC(u unsafe.Pointer) *TearoffMenuItemPrivate {
	c := (*C.GtkTearoffMenuItemPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TearoffMenuItemPrivate{native: c}

	return g
}

func (recv *TearoffMenuItemPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TearoffMenuItemPrivate with another TearoffMenuItemPrivate, and returns true if they represent the same GObject.
func (recv *TearoffMenuItemPrivate) Equals(other *TearoffMenuItemPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TextAppearance is a wrapper around the C record GtkTextAppearance.
type TextAppearance struct {
	native *C.GtkTextAppearance
	// bg_color : record
	// fg_color : record
	Rise int32
	// Bitfield not supported :  4 underline
	// Bitfield not supported :  1 strikethrough
	// Bitfield not supported :  1 draw_bg
	// Bitfield not supported :  1 inside_selection
	// Bitfield not supported :  1 is_text
}

func TextAppearanceNewFromC(u unsafe.Pointer) *TextAppearance {
	c := (*C.GtkTextAppearance)(u)
	if c == nil {
		return nil
	}

	g := &TextAppearance{
		Rise:   (int32)(c.rise),
		native: c,
	}

	return g
}

func (recv *TextAppearance) ToC() unsafe.Pointer {
	recv.native.rise =
		(C.gint)(recv.Rise)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextAppearance with another TextAppearance, and returns true if they represent the same GObject.
func (recv *TextAppearance) Equals(other *TextAppearance) bool {
	return other.ToC() == recv.ToC()
}

// TextAttributes is a wrapper around the C record GtkTextAttributes.
type TextAttributes struct {
	native *C.GtkTextAttributes
	// Private : refcount
	// appearance : record
	Justification Justification
	Direction     TextDirection
	// font : record
	FontScale        float64
	LeftMargin       int32
	RightMargin      int32
	Indent           int32
	PixelsAboveLines int32
	PixelsBelowLines int32
	PixelsInsideWrap int32
	// tabs : record
	WrapMode WrapMode
	// language : record
	// Private : pg_bg_color
	// Bitfield not supported :  1 invisible
	// Bitfield not supported :  1 bg_full_height
	// Bitfield not supported :  1 editable
	// Bitfield not supported :  1 no_fallback
	// Private : pg_bg_rgba
	LetterSpacing int32
}

func TextAttributesNewFromC(u unsafe.Pointer) *TextAttributes {
	c := (*C.GtkTextAttributes)(u)
	if c == nil {
		return nil
	}

	g := &TextAttributes{
		Direction:        (TextDirection)(c.direction),
		FontScale:        (float64)(c.font_scale),
		Indent:           (int32)(c.indent),
		Justification:    (Justification)(c.justification),
		LeftMargin:       (int32)(c.left_margin),
		LetterSpacing:    (int32)(c.letter_spacing),
		PixelsAboveLines: (int32)(c.pixels_above_lines),
		PixelsBelowLines: (int32)(c.pixels_below_lines),
		PixelsInsideWrap: (int32)(c.pixels_inside_wrap),
		RightMargin:      (int32)(c.right_margin),
		WrapMode:         (WrapMode)(c.wrap_mode),
		native:           c,
	}

	return g
}

func (recv *TextAttributes) ToC() unsafe.Pointer {
	recv.native.justification =
		(C.GtkJustification)(recv.Justification)
	recv.native.direction =
		(C.GtkTextDirection)(recv.Direction)
	recv.native.font_scale =
		(C.gdouble)(recv.FontScale)
	recv.native.left_margin =
		(C.gint)(recv.LeftMargin)
	recv.native.right_margin =
		(C.gint)(recv.RightMargin)
	recv.native.indent =
		(C.gint)(recv.Indent)
	recv.native.pixels_above_lines =
		(C.gint)(recv.PixelsAboveLines)
	recv.native.pixels_below_lines =
		(C.gint)(recv.PixelsBelowLines)
	recv.native.pixels_inside_wrap =
		(C.gint)(recv.PixelsInsideWrap)
	recv.native.wrap_mode =
		(C.GtkWrapMode)(recv.WrapMode)
	recv.native.letter_spacing =
		(C.gint)(recv.LetterSpacing)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextAttributes with another TextAttributes, and returns true if they represent the same GObject.
func (recv *TextAttributes) Equals(other *TextAttributes) bool {
	return other.ToC() == recv.ToC()
}

// TextAttributesNew is a wrapper around the C function gtk_text_attributes_new.
func TextAttributesNew() *TextAttributes {
	retC := C.gtk_text_attributes_new()
	retGo := TextAttributesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Copy is a wrapper around the C function gtk_text_attributes_copy.
func (recv *TextAttributes) Copy() *TextAttributes {
	retC := C.gtk_text_attributes_copy((*C.GtkTextAttributes)(recv.native))
	retGo := TextAttributesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// CopyValues is a wrapper around the C function gtk_text_attributes_copy_values.
func (recv *TextAttributes) CopyValues(dest *TextAttributes) {
	c_dest := (*C.GtkTextAttributes)(C.NULL)
	if dest != nil {
		c_dest = (*C.GtkTextAttributes)(dest.ToC())
	}

	C.gtk_text_attributes_copy_values((*C.GtkTextAttributes)(recv.native), c_dest)

	return
}

// Ref is a wrapper around the C function gtk_text_attributes_ref.
func (recv *TextAttributes) Ref() *TextAttributes {
	retC := C.gtk_text_attributes_ref((*C.GtkTextAttributes)(recv.native))
	retGo := TextAttributesNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unref is a wrapper around the C function gtk_text_attributes_unref.
func (recv *TextAttributes) Unref() {
	C.gtk_text_attributes_unref((*C.GtkTextAttributes)(recv.native))

	return
}

// TextBTree is a wrapper around the C record GtkTextBTree.
type TextBTree struct {
	native *C.GtkTextBTree
}

func TextBTreeNewFromC(u unsafe.Pointer) *TextBTree {
	c := (*C.GtkTextBTree)(u)
	if c == nil {
		return nil
	}

	g := &TextBTree{native: c}

	return g
}

func (recv *TextBTree) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextBTree with another TextBTree, and returns true if they represent the same GObject.
func (recv *TextBTree) Equals(other *TextBTree) bool {
	return other.ToC() == recv.ToC()
}

// TextBufferClass is a wrapper around the C record GtkTextBufferClass.
type TextBufferClass struct {
	native *C.GtkTextBufferClass
	// parent_class : record
	// no type for insert_text
	// no type for insert_pixbuf
	// no type for insert_child_anchor
	// no type for delete_range
	// no type for changed
	// no type for modified_changed
	// no type for mark_set
	// no type for mark_deleted
	// no type for apply_tag
	// no type for remove_tag
	// no type for begin_user_action
	// no type for end_user_action
	// no type for paste_done
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TextBufferClassNewFromC(u unsafe.Pointer) *TextBufferClass {
	c := (*C.GtkTextBufferClass)(u)
	if c == nil {
		return nil
	}

	g := &TextBufferClass{native: c}

	return g
}

func (recv *TextBufferClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextBufferClass with another TextBufferClass, and returns true if they represent the same GObject.
func (recv *TextBufferClass) Equals(other *TextBufferClass) bool {
	return other.ToC() == recv.ToC()
}

// TextBufferPrivate is a wrapper around the C record GtkTextBufferPrivate.
type TextBufferPrivate struct {
	native *C.GtkTextBufferPrivate
}

func TextBufferPrivateNewFromC(u unsafe.Pointer) *TextBufferPrivate {
	c := (*C.GtkTextBufferPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TextBufferPrivate{native: c}

	return g
}

func (recv *TextBufferPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextBufferPrivate with another TextBufferPrivate, and returns true if they represent the same GObject.
func (recv *TextBufferPrivate) Equals(other *TextBufferPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TextCellAccessibleClass is a wrapper around the C record GtkTextCellAccessibleClass.
type TextCellAccessibleClass struct {
	native *C.GtkTextCellAccessibleClass
	// parent_class : record
}

func TextCellAccessibleClassNewFromC(u unsafe.Pointer) *TextCellAccessibleClass {
	c := (*C.GtkTextCellAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &TextCellAccessibleClass{native: c}

	return g
}

func (recv *TextCellAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextCellAccessibleClass with another TextCellAccessibleClass, and returns true if they represent the same GObject.
func (recv *TextCellAccessibleClass) Equals(other *TextCellAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// TextCellAccessiblePrivate is a wrapper around the C record GtkTextCellAccessiblePrivate.
type TextCellAccessiblePrivate struct {
	native *C.GtkTextCellAccessiblePrivate
}

func TextCellAccessiblePrivateNewFromC(u unsafe.Pointer) *TextCellAccessiblePrivate {
	c := (*C.GtkTextCellAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &TextCellAccessiblePrivate{native: c}

	return g
}

func (recv *TextCellAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextCellAccessiblePrivate with another TextCellAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *TextCellAccessiblePrivate) Equals(other *TextCellAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TextChildAnchorClass is a wrapper around the C record GtkTextChildAnchorClass.
type TextChildAnchorClass struct {
	native *C.GtkTextChildAnchorClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TextChildAnchorClassNewFromC(u unsafe.Pointer) *TextChildAnchorClass {
	c := (*C.GtkTextChildAnchorClass)(u)
	if c == nil {
		return nil
	}

	g := &TextChildAnchorClass{native: c}

	return g
}

func (recv *TextChildAnchorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextChildAnchorClass with another TextChildAnchorClass, and returns true if they represent the same GObject.
func (recv *TextChildAnchorClass) Equals(other *TextChildAnchorClass) bool {
	return other.ToC() == recv.ToC()
}

// TextIter is a wrapper around the C record GtkTextIter.
type TextIter struct {
	native *C.GtkTextIter
	// Private : dummy1
	// Private : dummy2
	// Private : dummy3
	// Private : dummy4
	// Private : dummy5
	// Private : dummy6
	// Private : dummy7
	// Private : dummy8
	// Private : dummy9
	// Private : dummy10
	// Private : dummy11
	// Private : dummy12
	// Private : dummy13
	// Private : dummy14
}

func TextIterNewFromC(u unsafe.Pointer) *TextIter {
	c := (*C.GtkTextIter)(u)
	if c == nil {
		return nil
	}

	g := &TextIter{native: c}

	return g
}

func (recv *TextIter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextIter with another TextIter, and returns true if they represent the same GObject.
func (recv *TextIter) Equals(other *TextIter) bool {
	return other.ToC() == recv.ToC()
}

// BackwardChar is a wrapper around the C function gtk_text_iter_backward_char.
func (recv *TextIter) BackwardChar() bool {
	retC := C.gtk_text_iter_backward_char((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// BackwardChars is a wrapper around the C function gtk_text_iter_backward_chars.
func (recv *TextIter) BackwardChars(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_backward_chars((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// BackwardCursorPosition is a wrapper around the C function gtk_text_iter_backward_cursor_position.
func (recv *TextIter) BackwardCursorPosition() bool {
	retC := C.gtk_text_iter_backward_cursor_position((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// BackwardCursorPositions is a wrapper around the C function gtk_text_iter_backward_cursor_positions.
func (recv *TextIter) BackwardCursorPositions(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_backward_cursor_positions((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_text_iter_backward_find_char : unsupported parameter pred : no type generator for TextCharPredicate (GtkTextCharPredicate) for param pred

// BackwardLine is a wrapper around the C function gtk_text_iter_backward_line.
func (recv *TextIter) BackwardLine() bool {
	retC := C.gtk_text_iter_backward_line((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// BackwardLines is a wrapper around the C function gtk_text_iter_backward_lines.
func (recv *TextIter) BackwardLines(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_backward_lines((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// BackwardSearch is a wrapper around the C function gtk_text_iter_backward_search.
func (recv *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (bool, *TextIter, *TextIter) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	c_flags := (C.GtkTextSearchFlags)(flags)

	var c_match_start C.GtkTextIter

	var c_match_end C.GtkTextIter

	c_limit := (*C.GtkTextIter)(C.NULL)
	if limit != nil {
		c_limit = (*C.GtkTextIter)(limit.ToC())
	}

	retC := C.gtk_text_iter_backward_search((*C.GtkTextIter)(recv.native), c_str, c_flags, &c_match_start, &c_match_end, c_limit)
	retGo := retC == C.TRUE

	matchStart := TextIterNewFromC(unsafe.Pointer(&c_match_start))

	matchEnd := TextIterNewFromC(unsafe.Pointer(&c_match_end))

	return retGo, matchStart, matchEnd
}

// BackwardSentenceStart is a wrapper around the C function gtk_text_iter_backward_sentence_start.
func (recv *TextIter) BackwardSentenceStart() bool {
	retC := C.gtk_text_iter_backward_sentence_start((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// BackwardSentenceStarts is a wrapper around the C function gtk_text_iter_backward_sentence_starts.
func (recv *TextIter) BackwardSentenceStarts(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_backward_sentence_starts((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// BackwardToTagToggle is a wrapper around the C function gtk_text_iter_backward_to_tag_toggle.
func (recv *TextIter) BackwardToTagToggle(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_iter_backward_to_tag_toggle((*C.GtkTextIter)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// BackwardVisibleCursorPosition is a wrapper around the C function gtk_text_iter_backward_visible_cursor_position.
func (recv *TextIter) BackwardVisibleCursorPosition() bool {
	retC := C.gtk_text_iter_backward_visible_cursor_position((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// BackwardVisibleCursorPositions is a wrapper around the C function gtk_text_iter_backward_visible_cursor_positions.
func (recv *TextIter) BackwardVisibleCursorPositions(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_backward_visible_cursor_positions((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// BackwardVisibleLine is a wrapper around the C function gtk_text_iter_backward_visible_line.
func (recv *TextIter) BackwardVisibleLine() bool {
	retC := C.gtk_text_iter_backward_visible_line((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// BackwardVisibleLines is a wrapper around the C function gtk_text_iter_backward_visible_lines.
func (recv *TextIter) BackwardVisibleLines(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_backward_visible_lines((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// BackwardVisibleWordStart is a wrapper around the C function gtk_text_iter_backward_visible_word_start.
func (recv *TextIter) BackwardVisibleWordStart() bool {
	retC := C.gtk_text_iter_backward_visible_word_start((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// BackwardVisibleWordStarts is a wrapper around the C function gtk_text_iter_backward_visible_word_starts.
func (recv *TextIter) BackwardVisibleWordStarts(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_backward_visible_word_starts((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// BackwardWordStart is a wrapper around the C function gtk_text_iter_backward_word_start.
func (recv *TextIter) BackwardWordStart() bool {
	retC := C.gtk_text_iter_backward_word_start((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// BackwardWordStarts is a wrapper around the C function gtk_text_iter_backward_word_starts.
func (recv *TextIter) BackwardWordStarts(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_backward_word_starts((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// BeginsTag is a wrapper around the C function gtk_text_iter_begins_tag.
func (recv *TextIter) BeginsTag(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_iter_begins_tag((*C.GtkTextIter)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// CanInsert is a wrapper around the C function gtk_text_iter_can_insert.
func (recv *TextIter) CanInsert(defaultEditability bool) bool {
	c_default_editability :=
		boolToGboolean(defaultEditability)

	retC := C.gtk_text_iter_can_insert((*C.GtkTextIter)(recv.native), c_default_editability)
	retGo := retC == C.TRUE

	return retGo
}

// Compare is a wrapper around the C function gtk_text_iter_compare.
func (recv *TextIter) Compare(rhs *TextIter) int32 {
	c_rhs := (*C.GtkTextIter)(C.NULL)
	if rhs != nil {
		c_rhs = (*C.GtkTextIter)(rhs.ToC())
	}

	retC := C.gtk_text_iter_compare((*C.GtkTextIter)(recv.native), c_rhs)
	retGo := (int32)(retC)

	return retGo
}

// Copy is a wrapper around the C function gtk_text_iter_copy.
func (recv *TextIter) Copy() *TextIter {
	retC := C.gtk_text_iter_copy((*C.GtkTextIter)(recv.native))
	retGo := TextIterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Editable is a wrapper around the C function gtk_text_iter_editable.
func (recv *TextIter) Editable(defaultSetting bool) bool {
	c_default_setting :=
		boolToGboolean(defaultSetting)

	retC := C.gtk_text_iter_editable((*C.GtkTextIter)(recv.native), c_default_setting)
	retGo := retC == C.TRUE

	return retGo
}

// EndsLine is a wrapper around the C function gtk_text_iter_ends_line.
func (recv *TextIter) EndsLine() bool {
	retC := C.gtk_text_iter_ends_line((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// EndsSentence is a wrapper around the C function gtk_text_iter_ends_sentence.
func (recv *TextIter) EndsSentence() bool {
	retC := C.gtk_text_iter_ends_sentence((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// EndsTag is a wrapper around the C function gtk_text_iter_ends_tag.
func (recv *TextIter) EndsTag(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_iter_ends_tag((*C.GtkTextIter)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// EndsWord is a wrapper around the C function gtk_text_iter_ends_word.
func (recv *TextIter) EndsWord() bool {
	retC := C.gtk_text_iter_ends_word((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Equal is a wrapper around the C function gtk_text_iter_equal.
func (recv *TextIter) Equal(rhs *TextIter) bool {
	c_rhs := (*C.GtkTextIter)(C.NULL)
	if rhs != nil {
		c_rhs = (*C.GtkTextIter)(rhs.ToC())
	}

	retC := C.gtk_text_iter_equal((*C.GtkTextIter)(recv.native), c_rhs)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardChar is a wrapper around the C function gtk_text_iter_forward_char.
func (recv *TextIter) ForwardChar() bool {
	retC := C.gtk_text_iter_forward_char((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardChars is a wrapper around the C function gtk_text_iter_forward_chars.
func (recv *TextIter) ForwardChars(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_forward_chars((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardCursorPosition is a wrapper around the C function gtk_text_iter_forward_cursor_position.
func (recv *TextIter) ForwardCursorPosition() bool {
	retC := C.gtk_text_iter_forward_cursor_position((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardCursorPositions is a wrapper around the C function gtk_text_iter_forward_cursor_positions.
func (recv *TextIter) ForwardCursorPositions(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_forward_cursor_positions((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// Unsupported : gtk_text_iter_forward_find_char : unsupported parameter pred : no type generator for TextCharPredicate (GtkTextCharPredicate) for param pred

// ForwardLine is a wrapper around the C function gtk_text_iter_forward_line.
func (recv *TextIter) ForwardLine() bool {
	retC := C.gtk_text_iter_forward_line((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardLines is a wrapper around the C function gtk_text_iter_forward_lines.
func (recv *TextIter) ForwardLines(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_forward_lines((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardSearch is a wrapper around the C function gtk_text_iter_forward_search.
func (recv *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (bool, *TextIter, *TextIter) {
	c_str := C.CString(str)
	defer C.free(unsafe.Pointer(c_str))

	c_flags := (C.GtkTextSearchFlags)(flags)

	var c_match_start C.GtkTextIter

	var c_match_end C.GtkTextIter

	c_limit := (*C.GtkTextIter)(C.NULL)
	if limit != nil {
		c_limit = (*C.GtkTextIter)(limit.ToC())
	}

	retC := C.gtk_text_iter_forward_search((*C.GtkTextIter)(recv.native), c_str, c_flags, &c_match_start, &c_match_end, c_limit)
	retGo := retC == C.TRUE

	matchStart := TextIterNewFromC(unsafe.Pointer(&c_match_start))

	matchEnd := TextIterNewFromC(unsafe.Pointer(&c_match_end))

	return retGo, matchStart, matchEnd
}

// ForwardSentenceEnd is a wrapper around the C function gtk_text_iter_forward_sentence_end.
func (recv *TextIter) ForwardSentenceEnd() bool {
	retC := C.gtk_text_iter_forward_sentence_end((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardSentenceEnds is a wrapper around the C function gtk_text_iter_forward_sentence_ends.
func (recv *TextIter) ForwardSentenceEnds(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_forward_sentence_ends((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardToEnd is a wrapper around the C function gtk_text_iter_forward_to_end.
func (recv *TextIter) ForwardToEnd() {
	C.gtk_text_iter_forward_to_end((*C.GtkTextIter)(recv.native))

	return
}

// ForwardToLineEnd is a wrapper around the C function gtk_text_iter_forward_to_line_end.
func (recv *TextIter) ForwardToLineEnd() bool {
	retC := C.gtk_text_iter_forward_to_line_end((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardToTagToggle is a wrapper around the C function gtk_text_iter_forward_to_tag_toggle.
func (recv *TextIter) ForwardToTagToggle(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_iter_forward_to_tag_toggle((*C.GtkTextIter)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardVisibleCursorPosition is a wrapper around the C function gtk_text_iter_forward_visible_cursor_position.
func (recv *TextIter) ForwardVisibleCursorPosition() bool {
	retC := C.gtk_text_iter_forward_visible_cursor_position((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardVisibleCursorPositions is a wrapper around the C function gtk_text_iter_forward_visible_cursor_positions.
func (recv *TextIter) ForwardVisibleCursorPositions(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_forward_visible_cursor_positions((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardVisibleLine is a wrapper around the C function gtk_text_iter_forward_visible_line.
func (recv *TextIter) ForwardVisibleLine() bool {
	retC := C.gtk_text_iter_forward_visible_line((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardVisibleLines is a wrapper around the C function gtk_text_iter_forward_visible_lines.
func (recv *TextIter) ForwardVisibleLines(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_forward_visible_lines((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardVisibleWordEnd is a wrapper around the C function gtk_text_iter_forward_visible_word_end.
func (recv *TextIter) ForwardVisibleWordEnd() bool {
	retC := C.gtk_text_iter_forward_visible_word_end((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardVisibleWordEnds is a wrapper around the C function gtk_text_iter_forward_visible_word_ends.
func (recv *TextIter) ForwardVisibleWordEnds(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_forward_visible_word_ends((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// ForwardWordEnd is a wrapper around the C function gtk_text_iter_forward_word_end.
func (recv *TextIter) ForwardWordEnd() bool {
	retC := C.gtk_text_iter_forward_word_end((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ForwardWordEnds is a wrapper around the C function gtk_text_iter_forward_word_ends.
func (recv *TextIter) ForwardWordEnds(count int32) bool {
	c_count := (C.gint)(count)

	retC := C.gtk_text_iter_forward_word_ends((*C.GtkTextIter)(recv.native), c_count)
	retGo := retC == C.TRUE

	return retGo
}

// Free is a wrapper around the C function gtk_text_iter_free.
func (recv *TextIter) Free() {
	C.gtk_text_iter_free((*C.GtkTextIter)(recv.native))

	return
}

// GetAttributes is a wrapper around the C function gtk_text_iter_get_attributes.
func (recv *TextIter) GetAttributes() (bool, *TextAttributes) {
	var c_values C.GtkTextAttributes

	retC := C.gtk_text_iter_get_attributes((*C.GtkTextIter)(recv.native), &c_values)
	retGo := retC == C.TRUE

	values := TextAttributesNewFromC(unsafe.Pointer(&c_values))

	return retGo, values
}

// GetBuffer is a wrapper around the C function gtk_text_iter_get_buffer.
func (recv *TextIter) GetBuffer() *TextBuffer {
	retC := C.gtk_text_iter_get_buffer((*C.GtkTextIter)(recv.native))
	retGo := TextBufferNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetBytesInLine is a wrapper around the C function gtk_text_iter_get_bytes_in_line.
func (recv *TextIter) GetBytesInLine() int32 {
	retC := C.gtk_text_iter_get_bytes_in_line((*C.GtkTextIter)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetChar is a wrapper around the C function gtk_text_iter_get_char.
func (recv *TextIter) GetChar() rune {
	retC := C.gtk_text_iter_get_char((*C.GtkTextIter)(recv.native))
	retGo := (rune)(retC)

	return retGo
}

// GetCharsInLine is a wrapper around the C function gtk_text_iter_get_chars_in_line.
func (recv *TextIter) GetCharsInLine() int32 {
	retC := C.gtk_text_iter_get_chars_in_line((*C.GtkTextIter)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetChildAnchor is a wrapper around the C function gtk_text_iter_get_child_anchor.
func (recv *TextIter) GetChildAnchor() *TextChildAnchor {
	retC := C.gtk_text_iter_get_child_anchor((*C.GtkTextIter)(recv.native))
	retGo := TextChildAnchorNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLanguage is a wrapper around the C function gtk_text_iter_get_language.
func (recv *TextIter) GetLanguage() *pango.Language {
	retC := C.gtk_text_iter_get_language((*C.GtkTextIter)(recv.native))
	retGo := pango.LanguageNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetLine is a wrapper around the C function gtk_text_iter_get_line.
func (recv *TextIter) GetLine() int32 {
	retC := C.gtk_text_iter_get_line((*C.GtkTextIter)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetLineIndex is a wrapper around the C function gtk_text_iter_get_line_index.
func (recv *TextIter) GetLineIndex() int32 {
	retC := C.gtk_text_iter_get_line_index((*C.GtkTextIter)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetLineOffset is a wrapper around the C function gtk_text_iter_get_line_offset.
func (recv *TextIter) GetLineOffset() int32 {
	retC := C.gtk_text_iter_get_line_offset((*C.GtkTextIter)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetMarks is a wrapper around the C function gtk_text_iter_get_marks.
func (recv *TextIter) GetMarks() *glib.SList {
	retC := C.gtk_text_iter_get_marks((*C.GtkTextIter)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetOffset is a wrapper around the C function gtk_text_iter_get_offset.
func (recv *TextIter) GetOffset() int32 {
	retC := C.gtk_text_iter_get_offset((*C.GtkTextIter)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetPixbuf is a wrapper around the C function gtk_text_iter_get_pixbuf.
func (recv *TextIter) GetPixbuf() *gdkpixbuf.Pixbuf {
	retC := C.gtk_text_iter_get_pixbuf((*C.GtkTextIter)(recv.native))
	retGo := gdkpixbuf.PixbufNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetSlice is a wrapper around the C function gtk_text_iter_get_slice.
func (recv *TextIter) GetSlice(end *TextIter) string {
	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	retC := C.gtk_text_iter_get_slice((*C.GtkTextIter)(recv.native), c_end)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetTags is a wrapper around the C function gtk_text_iter_get_tags.
func (recv *TextIter) GetTags() *glib.SList {
	retC := C.gtk_text_iter_get_tags((*C.GtkTextIter)(recv.native))
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetText is a wrapper around the C function gtk_text_iter_get_text.
func (recv *TextIter) GetText(end *TextIter) string {
	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	retC := C.gtk_text_iter_get_text((*C.GtkTextIter)(recv.native), c_end)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetToggledTags is a wrapper around the C function gtk_text_iter_get_toggled_tags.
func (recv *TextIter) GetToggledTags(toggledOn bool) *glib.SList {
	c_toggled_on :=
		boolToGboolean(toggledOn)

	retC := C.gtk_text_iter_get_toggled_tags((*C.GtkTextIter)(recv.native), c_toggled_on)
	retGo := glib.SListNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetVisibleLineIndex is a wrapper around the C function gtk_text_iter_get_visible_line_index.
func (recv *TextIter) GetVisibleLineIndex() int32 {
	retC := C.gtk_text_iter_get_visible_line_index((*C.GtkTextIter)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetVisibleLineOffset is a wrapper around the C function gtk_text_iter_get_visible_line_offset.
func (recv *TextIter) GetVisibleLineOffset() int32 {
	retC := C.gtk_text_iter_get_visible_line_offset((*C.GtkTextIter)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// GetVisibleSlice is a wrapper around the C function gtk_text_iter_get_visible_slice.
func (recv *TextIter) GetVisibleSlice(end *TextIter) string {
	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	retC := C.gtk_text_iter_get_visible_slice((*C.GtkTextIter)(recv.native), c_end)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// GetVisibleText is a wrapper around the C function gtk_text_iter_get_visible_text.
func (recv *TextIter) GetVisibleText(end *TextIter) string {
	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	retC := C.gtk_text_iter_get_visible_text((*C.GtkTextIter)(recv.native), c_end)
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// HasTag is a wrapper around the C function gtk_text_iter_has_tag.
func (recv *TextIter) HasTag(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_iter_has_tag((*C.GtkTextIter)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// InRange is a wrapper around the C function gtk_text_iter_in_range.
func (recv *TextIter) InRange(start *TextIter, end *TextIter) bool {
	c_start := (*C.GtkTextIter)(C.NULL)
	if start != nil {
		c_start = (*C.GtkTextIter)(start.ToC())
	}

	c_end := (*C.GtkTextIter)(C.NULL)
	if end != nil {
		c_end = (*C.GtkTextIter)(end.ToC())
	}

	retC := C.gtk_text_iter_in_range((*C.GtkTextIter)(recv.native), c_start, c_end)
	retGo := retC == C.TRUE

	return retGo
}

// InsideSentence is a wrapper around the C function gtk_text_iter_inside_sentence.
func (recv *TextIter) InsideSentence() bool {
	retC := C.gtk_text_iter_inside_sentence((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// InsideWord is a wrapper around the C function gtk_text_iter_inside_word.
func (recv *TextIter) InsideWord() bool {
	retC := C.gtk_text_iter_inside_word((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsCursorPosition is a wrapper around the C function gtk_text_iter_is_cursor_position.
func (recv *TextIter) IsCursorPosition() bool {
	retC := C.gtk_text_iter_is_cursor_position((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsEnd is a wrapper around the C function gtk_text_iter_is_end.
func (recv *TextIter) IsEnd() bool {
	retC := C.gtk_text_iter_is_end((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// IsStart is a wrapper around the C function gtk_text_iter_is_start.
func (recv *TextIter) IsStart() bool {
	retC := C.gtk_text_iter_is_start((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// Order is a wrapper around the C function gtk_text_iter_order.
func (recv *TextIter) Order(second *TextIter) {
	c_second := (*C.GtkTextIter)(C.NULL)
	if second != nil {
		c_second = (*C.GtkTextIter)(second.ToC())
	}

	C.gtk_text_iter_order((*C.GtkTextIter)(recv.native), c_second)

	return
}

// SetLine is a wrapper around the C function gtk_text_iter_set_line.
func (recv *TextIter) SetLine(lineNumber int32) {
	c_line_number := (C.gint)(lineNumber)

	C.gtk_text_iter_set_line((*C.GtkTextIter)(recv.native), c_line_number)

	return
}

// SetLineIndex is a wrapper around the C function gtk_text_iter_set_line_index.
func (recv *TextIter) SetLineIndex(byteOnLine int32) {
	c_byte_on_line := (C.gint)(byteOnLine)

	C.gtk_text_iter_set_line_index((*C.GtkTextIter)(recv.native), c_byte_on_line)

	return
}

// SetLineOffset is a wrapper around the C function gtk_text_iter_set_line_offset.
func (recv *TextIter) SetLineOffset(charOnLine int32) {
	c_char_on_line := (C.gint)(charOnLine)

	C.gtk_text_iter_set_line_offset((*C.GtkTextIter)(recv.native), c_char_on_line)

	return
}

// SetOffset is a wrapper around the C function gtk_text_iter_set_offset.
func (recv *TextIter) SetOffset(charOffset int32) {
	c_char_offset := (C.gint)(charOffset)

	C.gtk_text_iter_set_offset((*C.GtkTextIter)(recv.native), c_char_offset)

	return
}

// SetVisibleLineIndex is a wrapper around the C function gtk_text_iter_set_visible_line_index.
func (recv *TextIter) SetVisibleLineIndex(byteOnLine int32) {
	c_byte_on_line := (C.gint)(byteOnLine)

	C.gtk_text_iter_set_visible_line_index((*C.GtkTextIter)(recv.native), c_byte_on_line)

	return
}

// SetVisibleLineOffset is a wrapper around the C function gtk_text_iter_set_visible_line_offset.
func (recv *TextIter) SetVisibleLineOffset(charOnLine int32) {
	c_char_on_line := (C.gint)(charOnLine)

	C.gtk_text_iter_set_visible_line_offset((*C.GtkTextIter)(recv.native), c_char_on_line)

	return
}

// StartsLine is a wrapper around the C function gtk_text_iter_starts_line.
func (recv *TextIter) StartsLine() bool {
	retC := C.gtk_text_iter_starts_line((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// StartsSentence is a wrapper around the C function gtk_text_iter_starts_sentence.
func (recv *TextIter) StartsSentence() bool {
	retC := C.gtk_text_iter_starts_sentence((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// StartsWord is a wrapper around the C function gtk_text_iter_starts_word.
func (recv *TextIter) StartsWord() bool {
	retC := C.gtk_text_iter_starts_word((*C.GtkTextIter)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// TogglesTag is a wrapper around the C function gtk_text_iter_toggles_tag.
func (recv *TextIter) TogglesTag(tag *TextTag) bool {
	c_tag := (*C.GtkTextTag)(C.NULL)
	if tag != nil {
		c_tag = (*C.GtkTextTag)(tag.ToC())
	}

	retC := C.gtk_text_iter_toggles_tag((*C.GtkTextIter)(recv.native), c_tag)
	retGo := retC == C.TRUE

	return retGo
}

// TextMarkClass is a wrapper around the C record GtkTextMarkClass.
type TextMarkClass struct {
	native *C.GtkTextMarkClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TextMarkClassNewFromC(u unsafe.Pointer) *TextMarkClass {
	c := (*C.GtkTextMarkClass)(u)
	if c == nil {
		return nil
	}

	g := &TextMarkClass{native: c}

	return g
}

func (recv *TextMarkClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextMarkClass with another TextMarkClass, and returns true if they represent the same GObject.
func (recv *TextMarkClass) Equals(other *TextMarkClass) bool {
	return other.ToC() == recv.ToC()
}

// TextTagClass is a wrapper around the C record GtkTextTagClass.
type TextTagClass struct {
	native *C.GtkTextTagClass
	// parent_class : record
	// no type for event
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TextTagClassNewFromC(u unsafe.Pointer) *TextTagClass {
	c := (*C.GtkTextTagClass)(u)
	if c == nil {
		return nil
	}

	g := &TextTagClass{native: c}

	return g
}

func (recv *TextTagClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextTagClass with another TextTagClass, and returns true if they represent the same GObject.
func (recv *TextTagClass) Equals(other *TextTagClass) bool {
	return other.ToC() == recv.ToC()
}

// TextTagPrivate is a wrapper around the C record GtkTextTagPrivate.
type TextTagPrivate struct {
	native *C.GtkTextTagPrivate
}

func TextTagPrivateNewFromC(u unsafe.Pointer) *TextTagPrivate {
	c := (*C.GtkTextTagPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TextTagPrivate{native: c}

	return g
}

func (recv *TextTagPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextTagPrivate with another TextTagPrivate, and returns true if they represent the same GObject.
func (recv *TextTagPrivate) Equals(other *TextTagPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TextTagTableClass is a wrapper around the C record GtkTextTagTableClass.
type TextTagTableClass struct {
	native *C.GtkTextTagTableClass
	// parent_class : record
	// no type for tag_changed
	// no type for tag_added
	// no type for tag_removed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TextTagTableClassNewFromC(u unsafe.Pointer) *TextTagTableClass {
	c := (*C.GtkTextTagTableClass)(u)
	if c == nil {
		return nil
	}

	g := &TextTagTableClass{native: c}

	return g
}

func (recv *TextTagTableClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextTagTableClass with another TextTagTableClass, and returns true if they represent the same GObject.
func (recv *TextTagTableClass) Equals(other *TextTagTableClass) bool {
	return other.ToC() == recv.ToC()
}

// TextTagTablePrivate is a wrapper around the C record GtkTextTagTablePrivate.
type TextTagTablePrivate struct {
	native *C.GtkTextTagTablePrivate
}

func TextTagTablePrivateNewFromC(u unsafe.Pointer) *TextTagTablePrivate {
	c := (*C.GtkTextTagTablePrivate)(u)
	if c == nil {
		return nil
	}

	g := &TextTagTablePrivate{native: c}

	return g
}

func (recv *TextTagTablePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextTagTablePrivate with another TextTagTablePrivate, and returns true if they represent the same GObject.
func (recv *TextTagTablePrivate) Equals(other *TextTagTablePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TextViewAccessibleClass is a wrapper around the C record GtkTextViewAccessibleClass.
type TextViewAccessibleClass struct {
	native *C.GtkTextViewAccessibleClass
	// parent_class : record
}

func TextViewAccessibleClassNewFromC(u unsafe.Pointer) *TextViewAccessibleClass {
	c := (*C.GtkTextViewAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &TextViewAccessibleClass{native: c}

	return g
}

func (recv *TextViewAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextViewAccessibleClass with another TextViewAccessibleClass, and returns true if they represent the same GObject.
func (recv *TextViewAccessibleClass) Equals(other *TextViewAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// TextViewAccessiblePrivate is a wrapper around the C record GtkTextViewAccessiblePrivate.
type TextViewAccessiblePrivate struct {
	native *C.GtkTextViewAccessiblePrivate
}

func TextViewAccessiblePrivateNewFromC(u unsafe.Pointer) *TextViewAccessiblePrivate {
	c := (*C.GtkTextViewAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &TextViewAccessiblePrivate{native: c}

	return g
}

func (recv *TextViewAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextViewAccessiblePrivate with another TextViewAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *TextViewAccessiblePrivate) Equals(other *TextViewAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TextViewClass is a wrapper around the C record GtkTextViewClass.
type TextViewClass struct {
	native *C.GtkTextViewClass
	// parent_class : record
	// no type for populate_popup
	// no type for move_cursor
	// no type for set_anchor
	// no type for insert_at_cursor
	// no type for delete_from_cursor
	// no type for backspace
	// no type for cut_clipboard
	// no type for copy_clipboard
	// no type for paste_clipboard
	// no type for toggle_overwrite
	// no type for create_buffer
	// no type for draw_layer
	// no type for extend_selection
	// no type for insert_emoji
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TextViewClassNewFromC(u unsafe.Pointer) *TextViewClass {
	c := (*C.GtkTextViewClass)(u)
	if c == nil {
		return nil
	}

	g := &TextViewClass{native: c}

	return g
}

func (recv *TextViewClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextViewClass with another TextViewClass, and returns true if they represent the same GObject.
func (recv *TextViewClass) Equals(other *TextViewClass) bool {
	return other.ToC() == recv.ToC()
}

// TextViewPrivate is a wrapper around the C record GtkTextViewPrivate.
type TextViewPrivate struct {
	native *C.GtkTextViewPrivate
}

func TextViewPrivateNewFromC(u unsafe.Pointer) *TextViewPrivate {
	c := (*C.GtkTextViewPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TextViewPrivate{native: c}

	return g
}

func (recv *TextViewPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TextViewPrivate with another TextViewPrivate, and returns true if they represent the same GObject.
func (recv *TextViewPrivate) Equals(other *TextViewPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ThemeEngine is a wrapper around the C record GtkThemeEngine.
type ThemeEngine struct {
	native *C.GtkThemeEngine
}

func ThemeEngineNewFromC(u unsafe.Pointer) *ThemeEngine {
	c := (*C.GtkThemeEngine)(u)
	if c == nil {
		return nil
	}

	g := &ThemeEngine{native: c}

	return g
}

func (recv *ThemeEngine) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThemeEngine with another ThemeEngine, and returns true if they represent the same GObject.
func (recv *ThemeEngine) Equals(other *ThemeEngine) bool {
	return other.ToC() == recv.ToC()
}

// ThemingEngineClass is a wrapper around the C record GtkThemingEngineClass.
type ThemingEngineClass struct {
	native *C.GtkThemingEngineClass
	// parent_class : record
	// no type for render_line
	// no type for render_background
	// no type for render_frame
	// no type for render_frame_gap
	// no type for render_extension
	// no type for render_check
	// no type for render_option
	// no type for render_arrow
	// no type for render_expander
	// no type for render_focus
	// no type for render_layout
	// no type for render_slider
	// no type for render_handle
	// no type for render_activity
	// no type for render_icon_pixbuf
	// no type for render_icon
	// no type for render_icon_surface
	// Private : padding
}

func ThemingEngineClassNewFromC(u unsafe.Pointer) *ThemingEngineClass {
	c := (*C.GtkThemingEngineClass)(u)
	if c == nil {
		return nil
	}

	g := &ThemingEngineClass{native: c}

	return g
}

func (recv *ThemingEngineClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThemingEngineClass with another ThemingEngineClass, and returns true if they represent the same GObject.
func (recv *ThemingEngineClass) Equals(other *ThemingEngineClass) bool {
	return other.ToC() == recv.ToC()
}

// ThemingEnginePrivate is a wrapper around the C record GtkThemingEnginePrivate.
type ThemingEnginePrivate struct {
	native *C.GtkThemingEnginePrivate
}

func ThemingEnginePrivateNewFromC(u unsafe.Pointer) *ThemingEnginePrivate {
	c := (*C.GtkThemingEnginePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ThemingEnginePrivate{native: c}

	return g
}

func (recv *ThemingEnginePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ThemingEnginePrivate with another ThemingEnginePrivate, and returns true if they represent the same GObject.
func (recv *ThemingEnginePrivate) Equals(other *ThemingEnginePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToggleActionClass is a wrapper around the C record GtkToggleActionClass.
type ToggleActionClass struct {
	native *C.GtkToggleActionClass
	// parent_class : record
	// no type for toggled
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ToggleActionClassNewFromC(u unsafe.Pointer) *ToggleActionClass {
	c := (*C.GtkToggleActionClass)(u)
	if c == nil {
		return nil
	}

	g := &ToggleActionClass{native: c}

	return g
}

func (recv *ToggleActionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleActionClass with another ToggleActionClass, and returns true if they represent the same GObject.
func (recv *ToggleActionClass) Equals(other *ToggleActionClass) bool {
	return other.ToC() == recv.ToC()
}

// ToggleActionEntry is a wrapper around the C record GtkToggleActionEntry.
type ToggleActionEntry struct {
	native      *C.GtkToggleActionEntry
	Name        string
	StockId     string
	Label       string
	Accelerator string
	Tooltip     string
	// callback : no type generator for GObject.Callback, GCallback
	IsActive bool
}

func ToggleActionEntryNewFromC(u unsafe.Pointer) *ToggleActionEntry {
	c := (*C.GtkToggleActionEntry)(u)
	if c == nil {
		return nil
	}

	g := &ToggleActionEntry{
		Accelerator: C.GoString(c.accelerator),
		IsActive:    c.is_active == C.TRUE,
		Label:       C.GoString(c.label),
		Name:        C.GoString(c.name),
		StockId:     C.GoString(c.stock_id),
		Tooltip:     C.GoString(c.tooltip),
		native:      c,
	}

	return g
}

func (recv *ToggleActionEntry) ToC() unsafe.Pointer {
	recv.native.name =
		C.CString(recv.Name)
	recv.native.stock_id =
		C.CString(recv.StockId)
	recv.native.label =
		C.CString(recv.Label)
	recv.native.accelerator =
		C.CString(recv.Accelerator)
	recv.native.tooltip =
		C.CString(recv.Tooltip)
	recv.native.is_active =
		boolToGboolean(recv.IsActive)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleActionEntry with another ToggleActionEntry, and returns true if they represent the same GObject.
func (recv *ToggleActionEntry) Equals(other *ToggleActionEntry) bool {
	return other.ToC() == recv.ToC()
}

// ToggleActionPrivate is a wrapper around the C record GtkToggleActionPrivate.
type ToggleActionPrivate struct {
	native *C.GtkToggleActionPrivate
}

func ToggleActionPrivateNewFromC(u unsafe.Pointer) *ToggleActionPrivate {
	c := (*C.GtkToggleActionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToggleActionPrivate{native: c}

	return g
}

func (recv *ToggleActionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleActionPrivate with another ToggleActionPrivate, and returns true if they represent the same GObject.
func (recv *ToggleActionPrivate) Equals(other *ToggleActionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButtonAccessibleClass is a wrapper around the C record GtkToggleButtonAccessibleClass.
type ToggleButtonAccessibleClass struct {
	native *C.GtkToggleButtonAccessibleClass
	// parent_class : record
}

func ToggleButtonAccessibleClassNewFromC(u unsafe.Pointer) *ToggleButtonAccessibleClass {
	c := (*C.GtkToggleButtonAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButtonAccessibleClass{native: c}

	return g
}

func (recv *ToggleButtonAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleButtonAccessibleClass with another ToggleButtonAccessibleClass, and returns true if they represent the same GObject.
func (recv *ToggleButtonAccessibleClass) Equals(other *ToggleButtonAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButtonAccessiblePrivate is a wrapper around the C record GtkToggleButtonAccessiblePrivate.
type ToggleButtonAccessiblePrivate struct {
	native *C.GtkToggleButtonAccessiblePrivate
}

func ToggleButtonAccessiblePrivateNewFromC(u unsafe.Pointer) *ToggleButtonAccessiblePrivate {
	c := (*C.GtkToggleButtonAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButtonAccessiblePrivate{native: c}

	return g
}

func (recv *ToggleButtonAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleButtonAccessiblePrivate with another ToggleButtonAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ToggleButtonAccessiblePrivate) Equals(other *ToggleButtonAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButtonClass is a wrapper around the C record GtkToggleButtonClass.
type ToggleButtonClass struct {
	native *C.GtkToggleButtonClass
	// parent_class : record
	// no type for toggled
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ToggleButtonClassNewFromC(u unsafe.Pointer) *ToggleButtonClass {
	c := (*C.GtkToggleButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButtonClass{native: c}

	return g
}

func (recv *ToggleButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleButtonClass with another ToggleButtonClass, and returns true if they represent the same GObject.
func (recv *ToggleButtonClass) Equals(other *ToggleButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// ToggleButtonPrivate is a wrapper around the C record GtkToggleButtonPrivate.
type ToggleButtonPrivate struct {
	native *C.GtkToggleButtonPrivate
}

func ToggleButtonPrivateNewFromC(u unsafe.Pointer) *ToggleButtonPrivate {
	c := (*C.GtkToggleButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToggleButtonPrivate{native: c}

	return g
}

func (recv *ToggleButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleButtonPrivate with another ToggleButtonPrivate, and returns true if they represent the same GObject.
func (recv *ToggleButtonPrivate) Equals(other *ToggleButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToggleToolButtonClass is a wrapper around the C record GtkToggleToolButtonClass.
type ToggleToolButtonClass struct {
	native *C.GtkToggleToolButtonClass
	// parent_class : record
	// no type for toggled
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ToggleToolButtonClassNewFromC(u unsafe.Pointer) *ToggleToolButtonClass {
	c := (*C.GtkToggleToolButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &ToggleToolButtonClass{native: c}

	return g
}

func (recv *ToggleToolButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleToolButtonClass with another ToggleToolButtonClass, and returns true if they represent the same GObject.
func (recv *ToggleToolButtonClass) Equals(other *ToggleToolButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// ToggleToolButtonPrivate is a wrapper around the C record GtkToggleToolButtonPrivate.
type ToggleToolButtonPrivate struct {
	native *C.GtkToggleToolButtonPrivate
}

func ToggleToolButtonPrivateNewFromC(u unsafe.Pointer) *ToggleToolButtonPrivate {
	c := (*C.GtkToggleToolButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToggleToolButtonPrivate{native: c}

	return g
}

func (recv *ToggleToolButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToggleToolButtonPrivate with another ToggleToolButtonPrivate, and returns true if they represent the same GObject.
func (recv *ToggleToolButtonPrivate) Equals(other *ToggleToolButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToolButtonClass is a wrapper around the C record GtkToolButtonClass.
type ToolButtonClass struct {
	native *C.GtkToolButtonClass
	// parent_class : record
	ButtonType gobject.Type
	// no type for clicked
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ToolButtonClassNewFromC(u unsafe.Pointer) *ToolButtonClass {
	c := (*C.GtkToolButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &ToolButtonClass{
		ButtonType: (gobject.Type)(c.button_type),
		native:     c,
	}

	return g
}

func (recv *ToolButtonClass) ToC() unsafe.Pointer {
	recv.native.button_type =
		(C.GType)(recv.ButtonType)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolButtonClass with another ToolButtonClass, and returns true if they represent the same GObject.
func (recv *ToolButtonClass) Equals(other *ToolButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// ToolButtonPrivate is a wrapper around the C record GtkToolButtonPrivate.
type ToolButtonPrivate struct {
	native *C.GtkToolButtonPrivate
}

func ToolButtonPrivateNewFromC(u unsafe.Pointer) *ToolButtonPrivate {
	c := (*C.GtkToolButtonPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToolButtonPrivate{native: c}

	return g
}

func (recv *ToolButtonPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolButtonPrivate with another ToolButtonPrivate, and returns true if they represent the same GObject.
func (recv *ToolButtonPrivate) Equals(other *ToolButtonPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToolItemClass is a wrapper around the C record GtkToolItemClass.
type ToolItemClass struct {
	native *C.GtkToolItemClass
	// parent_class : record
	// no type for create_menu_proxy
	// no type for toolbar_reconfigured
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ToolItemClassNewFromC(u unsafe.Pointer) *ToolItemClass {
	c := (*C.GtkToolItemClass)(u)
	if c == nil {
		return nil
	}

	g := &ToolItemClass{native: c}

	return g
}

func (recv *ToolItemClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolItemClass with another ToolItemClass, and returns true if they represent the same GObject.
func (recv *ToolItemClass) Equals(other *ToolItemClass) bool {
	return other.ToC() == recv.ToC()
}

// ToolItemGroupClass is a wrapper around the C record GtkToolItemGroupClass.
type ToolItemGroupClass struct {
	native *C.GtkToolItemGroupClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ToolItemGroupClassNewFromC(u unsafe.Pointer) *ToolItemGroupClass {
	c := (*C.GtkToolItemGroupClass)(u)
	if c == nil {
		return nil
	}

	g := &ToolItemGroupClass{native: c}

	return g
}

func (recv *ToolItemGroupClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolItemGroupClass with another ToolItemGroupClass, and returns true if they represent the same GObject.
func (recv *ToolItemGroupClass) Equals(other *ToolItemGroupClass) bool {
	return other.ToC() == recv.ToC()
}

// ToolItemGroupPrivate is a wrapper around the C record GtkToolItemGroupPrivate.
type ToolItemGroupPrivate struct {
	native *C.GtkToolItemGroupPrivate
}

func ToolItemGroupPrivateNewFromC(u unsafe.Pointer) *ToolItemGroupPrivate {
	c := (*C.GtkToolItemGroupPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToolItemGroupPrivate{native: c}

	return g
}

func (recv *ToolItemGroupPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolItemGroupPrivate with another ToolItemGroupPrivate, and returns true if they represent the same GObject.
func (recv *ToolItemGroupPrivate) Equals(other *ToolItemGroupPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToolItemPrivate is a wrapper around the C record GtkToolItemPrivate.
type ToolItemPrivate struct {
	native *C.GtkToolItemPrivate
}

func ToolItemPrivateNewFromC(u unsafe.Pointer) *ToolItemPrivate {
	c := (*C.GtkToolItemPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToolItemPrivate{native: c}

	return g
}

func (recv *ToolItemPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolItemPrivate with another ToolItemPrivate, and returns true if they represent the same GObject.
func (recv *ToolItemPrivate) Equals(other *ToolItemPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToolPaletteClass is a wrapper around the C record GtkToolPaletteClass.
type ToolPaletteClass struct {
	native *C.GtkToolPaletteClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ToolPaletteClassNewFromC(u unsafe.Pointer) *ToolPaletteClass {
	c := (*C.GtkToolPaletteClass)(u)
	if c == nil {
		return nil
	}

	g := &ToolPaletteClass{native: c}

	return g
}

func (recv *ToolPaletteClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolPaletteClass with another ToolPaletteClass, and returns true if they represent the same GObject.
func (recv *ToolPaletteClass) Equals(other *ToolPaletteClass) bool {
	return other.ToC() == recv.ToC()
}

// ToolPalettePrivate is a wrapper around the C record GtkToolPalettePrivate.
type ToolPalettePrivate struct {
	native *C.GtkToolPalettePrivate
}

func ToolPalettePrivateNewFromC(u unsafe.Pointer) *ToolPalettePrivate {
	c := (*C.GtkToolPalettePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToolPalettePrivate{native: c}

	return g
}

func (recv *ToolPalettePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolPalettePrivate with another ToolPalettePrivate, and returns true if they represent the same GObject.
func (recv *ToolPalettePrivate) Equals(other *ToolPalettePrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToolShellIface is a wrapper around the C record GtkToolShellIface.
type ToolShellIface struct {
	native *C.GtkToolShellIface
	// Private : g_iface
	// no type for get_icon_size
	// no type for get_orientation
	// no type for get_style
	// no type for get_relief_style
	// no type for rebuild_menu
	// no type for get_text_orientation
	// no type for get_text_alignment
	// no type for get_ellipsize_mode
	// no type for get_text_size_group
}

func ToolShellIfaceNewFromC(u unsafe.Pointer) *ToolShellIface {
	c := (*C.GtkToolShellIface)(u)
	if c == nil {
		return nil
	}

	g := &ToolShellIface{native: c}

	return g
}

func (recv *ToolShellIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolShellIface with another ToolShellIface, and returns true if they represent the same GObject.
func (recv *ToolShellIface) Equals(other *ToolShellIface) bool {
	return other.ToC() == recv.ToC()
}

// ToolbarClass is a wrapper around the C record GtkToolbarClass.
type ToolbarClass struct {
	native *C.GtkToolbarClass
	// parent_class : record
	// no type for orientation_changed
	// no type for style_changed
	// no type for popup_context_menu
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ToolbarClassNewFromC(u unsafe.Pointer) *ToolbarClass {
	c := (*C.GtkToolbarClass)(u)
	if c == nil {
		return nil
	}

	g := &ToolbarClass{native: c}

	return g
}

func (recv *ToolbarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolbarClass with another ToolbarClass, and returns true if they represent the same GObject.
func (recv *ToolbarClass) Equals(other *ToolbarClass) bool {
	return other.ToC() == recv.ToC()
}

// ToolbarPrivate is a wrapper around the C record GtkToolbarPrivate.
type ToolbarPrivate struct {
	native *C.GtkToolbarPrivate
}

func ToolbarPrivateNewFromC(u unsafe.Pointer) *ToolbarPrivate {
	c := (*C.GtkToolbarPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToolbarPrivate{native: c}

	return g
}

func (recv *ToolbarPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToolbarPrivate with another ToolbarPrivate, and returns true if they represent the same GObject.
func (recv *ToolbarPrivate) Equals(other *ToolbarPrivate) bool {
	return other.ToC() == recv.ToC()
}

// ToplevelAccessibleClass is a wrapper around the C record GtkToplevelAccessibleClass.
type ToplevelAccessibleClass struct {
	native *C.GtkToplevelAccessibleClass
	// parent_class : record
}

func ToplevelAccessibleClassNewFromC(u unsafe.Pointer) *ToplevelAccessibleClass {
	c := (*C.GtkToplevelAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &ToplevelAccessibleClass{native: c}

	return g
}

func (recv *ToplevelAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToplevelAccessibleClass with another ToplevelAccessibleClass, and returns true if they represent the same GObject.
func (recv *ToplevelAccessibleClass) Equals(other *ToplevelAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// ToplevelAccessiblePrivate is a wrapper around the C record GtkToplevelAccessiblePrivate.
type ToplevelAccessiblePrivate struct {
	native *C.GtkToplevelAccessiblePrivate
}

func ToplevelAccessiblePrivateNewFromC(u unsafe.Pointer) *ToplevelAccessiblePrivate {
	c := (*C.GtkToplevelAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &ToplevelAccessiblePrivate{native: c}

	return g
}

func (recv *ToplevelAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ToplevelAccessiblePrivate with another ToplevelAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *ToplevelAccessiblePrivate) Equals(other *ToplevelAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TreeDragDestIface is a wrapper around the C record GtkTreeDragDestIface.
type TreeDragDestIface struct {
	native *C.GtkTreeDragDestIface
	// Private : g_iface
	// no type for drag_data_received
	// no type for row_drop_possible
}

func TreeDragDestIfaceNewFromC(u unsafe.Pointer) *TreeDragDestIface {
	c := (*C.GtkTreeDragDestIface)(u)
	if c == nil {
		return nil
	}

	g := &TreeDragDestIface{native: c}

	return g
}

func (recv *TreeDragDestIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeDragDestIface with another TreeDragDestIface, and returns true if they represent the same GObject.
func (recv *TreeDragDestIface) Equals(other *TreeDragDestIface) bool {
	return other.ToC() == recv.ToC()
}

// TreeDragSourceIface is a wrapper around the C record GtkTreeDragSourceIface.
type TreeDragSourceIface struct {
	native *C.GtkTreeDragSourceIface
	// Private : g_iface
	// no type for row_draggable
	// no type for drag_data_get
	// no type for drag_data_delete
}

func TreeDragSourceIfaceNewFromC(u unsafe.Pointer) *TreeDragSourceIface {
	c := (*C.GtkTreeDragSourceIface)(u)
	if c == nil {
		return nil
	}

	g := &TreeDragSourceIface{native: c}

	return g
}

func (recv *TreeDragSourceIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeDragSourceIface with another TreeDragSourceIface, and returns true if they represent the same GObject.
func (recv *TreeDragSourceIface) Equals(other *TreeDragSourceIface) bool {
	return other.ToC() == recv.ToC()
}

// TreeIter is a wrapper around the C record GtkTreeIter.
type TreeIter struct {
	native *C.GtkTreeIter
	// Private : stamp
	// Private : user_data
	// Private : user_data2
	// Private : user_data3
}

func TreeIterNewFromC(u unsafe.Pointer) *TreeIter {
	c := (*C.GtkTreeIter)(u)
	if c == nil {
		return nil
	}

	g := &TreeIter{native: c}

	return g
}

func (recv *TreeIter) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeIter with another TreeIter, and returns true if they represent the same GObject.
func (recv *TreeIter) Equals(other *TreeIter) bool {
	return other.ToC() == recv.ToC()
}

// Copy is a wrapper around the C function gtk_tree_iter_copy.
func (recv *TreeIter) Copy() *TreeIter {
	retC := C.gtk_tree_iter_copy((*C.GtkTreeIter)(recv.native))
	retGo := TreeIterNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_tree_iter_free.
func (recv *TreeIter) Free() {
	C.gtk_tree_iter_free((*C.GtkTreeIter)(recv.native))

	return
}

// TreeModelFilterClass is a wrapper around the C record GtkTreeModelFilterClass.
type TreeModelFilterClass struct {
	native *C.GtkTreeModelFilterClass
	// parent_class : record
	// no type for visible
	// no type for modify
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TreeModelFilterClassNewFromC(u unsafe.Pointer) *TreeModelFilterClass {
	c := (*C.GtkTreeModelFilterClass)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelFilterClass{native: c}

	return g
}

func (recv *TreeModelFilterClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelFilterClass with another TreeModelFilterClass, and returns true if they represent the same GObject.
func (recv *TreeModelFilterClass) Equals(other *TreeModelFilterClass) bool {
	return other.ToC() == recv.ToC()
}

// TreeModelFilterPrivate is a wrapper around the C record GtkTreeModelFilterPrivate.
type TreeModelFilterPrivate struct {
	native *C.GtkTreeModelFilterPrivate
}

func TreeModelFilterPrivateNewFromC(u unsafe.Pointer) *TreeModelFilterPrivate {
	c := (*C.GtkTreeModelFilterPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelFilterPrivate{native: c}

	return g
}

func (recv *TreeModelFilterPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelFilterPrivate with another TreeModelFilterPrivate, and returns true if they represent the same GObject.
func (recv *TreeModelFilterPrivate) Equals(other *TreeModelFilterPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TreeModelIface is a wrapper around the C record GtkTreeModelIface.
type TreeModelIface struct {
	native *C.GtkTreeModelIface
	// Private : g_iface
	// no type for row_changed
	// no type for row_inserted
	// no type for row_has_child_toggled
	// no type for row_deleted
	// no type for rows_reordered
	// no type for get_flags
	// no type for get_n_columns
	// no type for get_column_type
	// no type for get_iter
	// no type for get_path
	// no type for get_value
	// no type for iter_next
	// no type for iter_previous
	// no type for iter_children
	// no type for iter_has_child
	// no type for iter_n_children
	// no type for iter_nth_child
	// no type for iter_parent
	// no type for ref_node
	// no type for unref_node
}

func TreeModelIfaceNewFromC(u unsafe.Pointer) *TreeModelIface {
	c := (*C.GtkTreeModelIface)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelIface{native: c}

	return g
}

func (recv *TreeModelIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelIface with another TreeModelIface, and returns true if they represent the same GObject.
func (recv *TreeModelIface) Equals(other *TreeModelIface) bool {
	return other.ToC() == recv.ToC()
}

// TreeModelSortClass is a wrapper around the C record GtkTreeModelSortClass.
type TreeModelSortClass struct {
	native *C.GtkTreeModelSortClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TreeModelSortClassNewFromC(u unsafe.Pointer) *TreeModelSortClass {
	c := (*C.GtkTreeModelSortClass)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelSortClass{native: c}

	return g
}

func (recv *TreeModelSortClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelSortClass with another TreeModelSortClass, and returns true if they represent the same GObject.
func (recv *TreeModelSortClass) Equals(other *TreeModelSortClass) bool {
	return other.ToC() == recv.ToC()
}

// TreeModelSortPrivate is a wrapper around the C record GtkTreeModelSortPrivate.
type TreeModelSortPrivate struct {
	native *C.GtkTreeModelSortPrivate
}

func TreeModelSortPrivateNewFromC(u unsafe.Pointer) *TreeModelSortPrivate {
	c := (*C.GtkTreeModelSortPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TreeModelSortPrivate{native: c}

	return g
}

func (recv *TreeModelSortPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeModelSortPrivate with another TreeModelSortPrivate, and returns true if they represent the same GObject.
func (recv *TreeModelSortPrivate) Equals(other *TreeModelSortPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TreePath is a wrapper around the C record GtkTreePath.
type TreePath struct {
	native *C.GtkTreePath
}

func TreePathNewFromC(u unsafe.Pointer) *TreePath {
	c := (*C.GtkTreePath)(u)
	if c == nil {
		return nil
	}

	g := &TreePath{native: c}

	return g
}

func (recv *TreePath) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreePath with another TreePath, and returns true if they represent the same GObject.
func (recv *TreePath) Equals(other *TreePath) bool {
	return other.ToC() == recv.ToC()
}

// TreePathNew is a wrapper around the C function gtk_tree_path_new.
func TreePathNew() *TreePath {
	retC := C.gtk_tree_path_new()
	retGo := TreePathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TreePathNewFirst is a wrapper around the C function gtk_tree_path_new_first.
func TreePathNewFirst() *TreePath {
	retC := C.gtk_tree_path_new_first()
	retGo := TreePathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Unsupported : gtk_tree_path_new_from_indices : unsupported parameter ... : varargs

// TreePathNewFromString is a wrapper around the C function gtk_tree_path_new_from_string.
func TreePathNewFromString(path string) *TreePath {
	c_path := C.CString(path)
	defer C.free(unsafe.Pointer(c_path))

	retC := C.gtk_tree_path_new_from_string(c_path)
	retGo := TreePathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// AppendIndex is a wrapper around the C function gtk_tree_path_append_index.
func (recv *TreePath) AppendIndex(index int32) {
	c_index_ := (C.gint)(index)

	C.gtk_tree_path_append_index((*C.GtkTreePath)(recv.native), c_index_)

	return
}

// Compare is a wrapper around the C function gtk_tree_path_compare.
func (recv *TreePath) Compare(b *TreePath) int32 {
	c_b := (*C.GtkTreePath)(C.NULL)
	if b != nil {
		c_b = (*C.GtkTreePath)(b.ToC())
	}

	retC := C.gtk_tree_path_compare((*C.GtkTreePath)(recv.native), c_b)
	retGo := (int32)(retC)

	return retGo
}

// Copy is a wrapper around the C function gtk_tree_path_copy.
func (recv *TreePath) Copy() *TreePath {
	retC := C.gtk_tree_path_copy((*C.GtkTreePath)(recv.native))
	retGo := TreePathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Down is a wrapper around the C function gtk_tree_path_down.
func (recv *TreePath) Down() {
	C.gtk_tree_path_down((*C.GtkTreePath)(recv.native))

	return
}

// Free is a wrapper around the C function gtk_tree_path_free.
func (recv *TreePath) Free() {
	C.gtk_tree_path_free((*C.GtkTreePath)(recv.native))

	return
}

// GetDepth is a wrapper around the C function gtk_tree_path_get_depth.
func (recv *TreePath) GetDepth() int32 {
	retC := C.gtk_tree_path_get_depth((*C.GtkTreePath)(recv.native))
	retGo := (int32)(retC)

	return retGo
}

// Blacklisted : gtk_tree_path_get_indices

// IsAncestor is a wrapper around the C function gtk_tree_path_is_ancestor.
func (recv *TreePath) IsAncestor(descendant *TreePath) bool {
	c_descendant := (*C.GtkTreePath)(C.NULL)
	if descendant != nil {
		c_descendant = (*C.GtkTreePath)(descendant.ToC())
	}

	retC := C.gtk_tree_path_is_ancestor((*C.GtkTreePath)(recv.native), c_descendant)
	retGo := retC == C.TRUE

	return retGo
}

// IsDescendant is a wrapper around the C function gtk_tree_path_is_descendant.
func (recv *TreePath) IsDescendant(ancestor *TreePath) bool {
	c_ancestor := (*C.GtkTreePath)(C.NULL)
	if ancestor != nil {
		c_ancestor = (*C.GtkTreePath)(ancestor.ToC())
	}

	retC := C.gtk_tree_path_is_descendant((*C.GtkTreePath)(recv.native), c_ancestor)
	retGo := retC == C.TRUE

	return retGo
}

// Next is a wrapper around the C function gtk_tree_path_next.
func (recv *TreePath) Next() {
	C.gtk_tree_path_next((*C.GtkTreePath)(recv.native))

	return
}

// PrependIndex is a wrapper around the C function gtk_tree_path_prepend_index.
func (recv *TreePath) PrependIndex(index int32) {
	c_index_ := (C.gint)(index)

	C.gtk_tree_path_prepend_index((*C.GtkTreePath)(recv.native), c_index_)

	return
}

// Prev is a wrapper around the C function gtk_tree_path_prev.
func (recv *TreePath) Prev() bool {
	retC := C.gtk_tree_path_prev((*C.GtkTreePath)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// ToString is a wrapper around the C function gtk_tree_path_to_string.
func (recv *TreePath) ToString() string {
	retC := C.gtk_tree_path_to_string((*C.GtkTreePath)(recv.native))
	retGo := C.GoString(retC)
	defer C.free(unsafe.Pointer(retC))

	return retGo
}

// Up is a wrapper around the C function gtk_tree_path_up.
func (recv *TreePath) Up() bool {
	retC := C.gtk_tree_path_up((*C.GtkTreePath)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// TreeRowReference is a wrapper around the C record GtkTreeRowReference.
type TreeRowReference struct {
	native *C.GtkTreeRowReference
}

func TreeRowReferenceNewFromC(u unsafe.Pointer) *TreeRowReference {
	c := (*C.GtkTreeRowReference)(u)
	if c == nil {
		return nil
	}

	g := &TreeRowReference{native: c}

	return g
}

func (recv *TreeRowReference) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeRowReference with another TreeRowReference, and returns true if they represent the same GObject.
func (recv *TreeRowReference) Equals(other *TreeRowReference) bool {
	return other.ToC() == recv.ToC()
}

// TreeRowReferenceNew is a wrapper around the C function gtk_tree_row_reference_new.
func TreeRowReferenceNew(model *TreeModel, path *TreePath) *TreeRowReference {
	c_model := (*C.GtkTreeModel)(model.ToC())

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_row_reference_new(c_model, c_path)
	retGo := TreeRowReferenceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TreeRowReferenceNewProxy is a wrapper around the C function gtk_tree_row_reference_new_proxy.
func TreeRowReferenceNewProxy(proxy *gobject.Object, model *TreeModel, path *TreePath) *TreeRowReference {
	c_proxy := (*C.GObject)(C.NULL)
	if proxy != nil {
		c_proxy = (*C.GObject)(proxy.ToC())
	}

	c_model := (*C.GtkTreeModel)(model.ToC())

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	retC := C.gtk_tree_row_reference_new_proxy(c_proxy, c_model, c_path)
	retGo := TreeRowReferenceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// TreeRowReferenceDeleted is a wrapper around the C function gtk_tree_row_reference_deleted.
func TreeRowReferenceDeleted(proxy *gobject.Object, path *TreePath) {
	c_proxy := (*C.GObject)(C.NULL)
	if proxy != nil {
		c_proxy = (*C.GObject)(proxy.ToC())
	}

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_row_reference_deleted(c_proxy, c_path)

	return
}

// TreeRowReferenceInserted is a wrapper around the C function gtk_tree_row_reference_inserted.
func TreeRowReferenceInserted(proxy *gobject.Object, path *TreePath) {
	c_proxy := (*C.GObject)(C.NULL)
	if proxy != nil {
		c_proxy = (*C.GObject)(proxy.ToC())
	}

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	C.gtk_tree_row_reference_inserted(c_proxy, c_path)

	return
}

// TreeRowReferenceReordered is a wrapper around the C function gtk_tree_row_reference_reordered.
func TreeRowReferenceReordered(proxy *gobject.Object, path *TreePath, iter *TreeIter, newOrder []int32) {
	c_proxy := (*C.GObject)(C.NULL)
	if proxy != nil {
		c_proxy = (*C.GObject)(proxy.ToC())
	}

	c_path := (*C.GtkTreePath)(C.NULL)
	if path != nil {
		c_path = (*C.GtkTreePath)(path.ToC())
	}

	c_iter := (*C.GtkTreeIter)(C.NULL)
	if iter != nil {
		c_iter = (*C.GtkTreeIter)(iter.ToC())
	}

	c_new_order_array := make([]C.gint, len(newOrder)+1, len(newOrder)+1)
	for i, item := range newOrder {
		c := (C.gint)(item)
		c_new_order_array[i] = c
	}
	c_new_order_array[len(newOrder)] = 0
	c_new_order_arrayPtr := &c_new_order_array[0]
	c_new_order := (*C.gint)(unsafe.Pointer(c_new_order_arrayPtr))

	C.gtk_tree_row_reference_reordered(c_proxy, c_path, c_iter, c_new_order)

	return
}

// Copy is a wrapper around the C function gtk_tree_row_reference_copy.
func (recv *TreeRowReference) Copy() *TreeRowReference {
	retC := C.gtk_tree_row_reference_copy((*C.GtkTreeRowReference)(recv.native))
	retGo := TreeRowReferenceNewFromC(unsafe.Pointer(retC))

	return retGo
}

// Free is a wrapper around the C function gtk_tree_row_reference_free.
func (recv *TreeRowReference) Free() {
	C.gtk_tree_row_reference_free((*C.GtkTreeRowReference)(recv.native))

	return
}

// GetModel is a wrapper around the C function gtk_tree_row_reference_get_model.
func (recv *TreeRowReference) GetModel() *TreeModel {
	retC := C.gtk_tree_row_reference_get_model((*C.GtkTreeRowReference)(recv.native))
	retGo := TreeModelNewFromC(unsafe.Pointer(retC))

	return retGo
}

// GetPath is a wrapper around the C function gtk_tree_row_reference_get_path.
func (recv *TreeRowReference) GetPath() *TreePath {
	retC := C.gtk_tree_row_reference_get_path((*C.GtkTreeRowReference)(recv.native))
	var retGo (*TreePath)
	if retC == nil {
		retGo = nil
	} else {
		retGo = TreePathNewFromC(unsafe.Pointer(retC))
	}

	return retGo
}

// Valid is a wrapper around the C function gtk_tree_row_reference_valid.
func (recv *TreeRowReference) Valid() bool {
	retC := C.gtk_tree_row_reference_valid((*C.GtkTreeRowReference)(recv.native))
	retGo := retC == C.TRUE

	return retGo
}

// TreeSelectionClass is a wrapper around the C record GtkTreeSelectionClass.
type TreeSelectionClass struct {
	native *C.GtkTreeSelectionClass
	// parent_class : record
	// no type for changed
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TreeSelectionClassNewFromC(u unsafe.Pointer) *TreeSelectionClass {
	c := (*C.GtkTreeSelectionClass)(u)
	if c == nil {
		return nil
	}

	g := &TreeSelectionClass{native: c}

	return g
}

func (recv *TreeSelectionClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeSelectionClass with another TreeSelectionClass, and returns true if they represent the same GObject.
func (recv *TreeSelectionClass) Equals(other *TreeSelectionClass) bool {
	return other.ToC() == recv.ToC()
}

// TreeSelectionPrivate is a wrapper around the C record GtkTreeSelectionPrivate.
type TreeSelectionPrivate struct {
	native *C.GtkTreeSelectionPrivate
}

func TreeSelectionPrivateNewFromC(u unsafe.Pointer) *TreeSelectionPrivate {
	c := (*C.GtkTreeSelectionPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TreeSelectionPrivate{native: c}

	return g
}

func (recv *TreeSelectionPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeSelectionPrivate with another TreeSelectionPrivate, and returns true if they represent the same GObject.
func (recv *TreeSelectionPrivate) Equals(other *TreeSelectionPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TreeSortableIface is a wrapper around the C record GtkTreeSortableIface.
type TreeSortableIface struct {
	native *C.GtkTreeSortableIface
	// Private : g_iface
	// no type for sort_column_changed
	// no type for get_sort_column_id
	// no type for set_sort_column_id
	// no type for set_sort_func
	// no type for set_default_sort_func
	// no type for has_default_sort_func
}

func TreeSortableIfaceNewFromC(u unsafe.Pointer) *TreeSortableIface {
	c := (*C.GtkTreeSortableIface)(u)
	if c == nil {
		return nil
	}

	g := &TreeSortableIface{native: c}

	return g
}

func (recv *TreeSortableIface) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeSortableIface with another TreeSortableIface, and returns true if they represent the same GObject.
func (recv *TreeSortableIface) Equals(other *TreeSortableIface) bool {
	return other.ToC() == recv.ToC()
}

// TreeStoreClass is a wrapper around the C record GtkTreeStoreClass.
type TreeStoreClass struct {
	native *C.GtkTreeStoreClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TreeStoreClassNewFromC(u unsafe.Pointer) *TreeStoreClass {
	c := (*C.GtkTreeStoreClass)(u)
	if c == nil {
		return nil
	}

	g := &TreeStoreClass{native: c}

	return g
}

func (recv *TreeStoreClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeStoreClass with another TreeStoreClass, and returns true if they represent the same GObject.
func (recv *TreeStoreClass) Equals(other *TreeStoreClass) bool {
	return other.ToC() == recv.ToC()
}

// TreeStorePrivate is a wrapper around the C record GtkTreeStorePrivate.
type TreeStorePrivate struct {
	native *C.GtkTreeStorePrivate
}

func TreeStorePrivateNewFromC(u unsafe.Pointer) *TreeStorePrivate {
	c := (*C.GtkTreeStorePrivate)(u)
	if c == nil {
		return nil
	}

	g := &TreeStorePrivate{native: c}

	return g
}

func (recv *TreeStorePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeStorePrivate with another TreeStorePrivate, and returns true if they represent the same GObject.
func (recv *TreeStorePrivate) Equals(other *TreeStorePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TreeViewAccessibleClass is a wrapper around the C record GtkTreeViewAccessibleClass.
type TreeViewAccessibleClass struct {
	native *C.GtkTreeViewAccessibleClass
	// parent_class : record
}

func TreeViewAccessibleClassNewFromC(u unsafe.Pointer) *TreeViewAccessibleClass {
	c := (*C.GtkTreeViewAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewAccessibleClass{native: c}

	return g
}

func (recv *TreeViewAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewAccessibleClass with another TreeViewAccessibleClass, and returns true if they represent the same GObject.
func (recv *TreeViewAccessibleClass) Equals(other *TreeViewAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// TreeViewAccessiblePrivate is a wrapper around the C record GtkTreeViewAccessiblePrivate.
type TreeViewAccessiblePrivate struct {
	native *C.GtkTreeViewAccessiblePrivate
}

func TreeViewAccessiblePrivateNewFromC(u unsafe.Pointer) *TreeViewAccessiblePrivate {
	c := (*C.GtkTreeViewAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewAccessiblePrivate{native: c}

	return g
}

func (recv *TreeViewAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewAccessiblePrivate with another TreeViewAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *TreeViewAccessiblePrivate) Equals(other *TreeViewAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// TreeViewClass is a wrapper around the C record GtkTreeViewClass.
type TreeViewClass struct {
	native *C.GtkTreeViewClass
	// parent_class : record
	// no type for row_activated
	// no type for test_expand_row
	// no type for test_collapse_row
	// no type for row_expanded
	// no type for row_collapsed
	// no type for columns_changed
	// no type for cursor_changed
	// no type for move_cursor
	// no type for select_all
	// no type for unselect_all
	// no type for select_cursor_row
	// no type for toggle_cursor_row
	// no type for expand_collapse_cursor_row
	// no type for select_cursor_parent
	// no type for start_interactive_search
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
	// no type for _gtk_reserved5
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
	// no type for _gtk_reserved8
}

func TreeViewClassNewFromC(u unsafe.Pointer) *TreeViewClass {
	c := (*C.GtkTreeViewClass)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewClass{native: c}

	return g
}

func (recv *TreeViewClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewClass with another TreeViewClass, and returns true if they represent the same GObject.
func (recv *TreeViewClass) Equals(other *TreeViewClass) bool {
	return other.ToC() == recv.ToC()
}

// TreeViewColumnClass is a wrapper around the C record GtkTreeViewColumnClass.
type TreeViewColumnClass struct {
	native *C.GtkTreeViewColumnClass
	// parent_class : record
	// no type for clicked
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func TreeViewColumnClassNewFromC(u unsafe.Pointer) *TreeViewColumnClass {
	c := (*C.GtkTreeViewColumnClass)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewColumnClass{native: c}

	return g
}

func (recv *TreeViewColumnClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewColumnClass with another TreeViewColumnClass, and returns true if they represent the same GObject.
func (recv *TreeViewColumnClass) Equals(other *TreeViewColumnClass) bool {
	return other.ToC() == recv.ToC()
}

// TreeViewColumnPrivate is a wrapper around the C record GtkTreeViewColumnPrivate.
type TreeViewColumnPrivate struct {
	native *C.GtkTreeViewColumnPrivate
}

func TreeViewColumnPrivateNewFromC(u unsafe.Pointer) *TreeViewColumnPrivate {
	c := (*C.GtkTreeViewColumnPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewColumnPrivate{native: c}

	return g
}

func (recv *TreeViewColumnPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewColumnPrivate with another TreeViewColumnPrivate, and returns true if they represent the same GObject.
func (recv *TreeViewColumnPrivate) Equals(other *TreeViewColumnPrivate) bool {
	return other.ToC() == recv.ToC()
}

// TreeViewPrivate is a wrapper around the C record GtkTreeViewPrivate.
type TreeViewPrivate struct {
	native *C.GtkTreeViewPrivate
}

func TreeViewPrivateNewFromC(u unsafe.Pointer) *TreeViewPrivate {
	c := (*C.GtkTreeViewPrivate)(u)
	if c == nil {
		return nil
	}

	g := &TreeViewPrivate{native: c}

	return g
}

func (recv *TreeViewPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this TreeViewPrivate with another TreeViewPrivate, and returns true if they represent the same GObject.
func (recv *TreeViewPrivate) Equals(other *TreeViewPrivate) bool {
	return other.ToC() == recv.ToC()
}

// UIManagerClass is a wrapper around the C record GtkUIManagerClass.
type UIManagerClass struct {
	native *C.GtkUIManagerClass
	// parent_class : record
	// no type for add_widget
	// no type for actions_changed
	// no type for connect_proxy
	// no type for disconnect_proxy
	// no type for pre_activate
	// no type for post_activate
	// no type for get_widget
	// no type for get_action
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func UIManagerClassNewFromC(u unsafe.Pointer) *UIManagerClass {
	c := (*C.GtkUIManagerClass)(u)
	if c == nil {
		return nil
	}

	g := &UIManagerClass{native: c}

	return g
}

func (recv *UIManagerClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UIManagerClass with another UIManagerClass, and returns true if they represent the same GObject.
func (recv *UIManagerClass) Equals(other *UIManagerClass) bool {
	return other.ToC() == recv.ToC()
}

// UIManagerPrivate is a wrapper around the C record GtkUIManagerPrivate.
type UIManagerPrivate struct {
	native *C.GtkUIManagerPrivate
}

func UIManagerPrivateNewFromC(u unsafe.Pointer) *UIManagerPrivate {
	c := (*C.GtkUIManagerPrivate)(u)
	if c == nil {
		return nil
	}

	g := &UIManagerPrivate{native: c}

	return g
}

func (recv *UIManagerPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this UIManagerPrivate with another UIManagerPrivate, and returns true if they represent the same GObject.
func (recv *UIManagerPrivate) Equals(other *UIManagerPrivate) bool {
	return other.ToC() == recv.ToC()
}

// VBoxClass is a wrapper around the C record GtkVBoxClass.
type VBoxClass struct {
	native *C.GtkVBoxClass
	// parent_class : record
}

func VBoxClassNewFromC(u unsafe.Pointer) *VBoxClass {
	c := (*C.GtkVBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &VBoxClass{native: c}

	return g
}

func (recv *VBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VBoxClass with another VBoxClass, and returns true if they represent the same GObject.
func (recv *VBoxClass) Equals(other *VBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// VButtonBoxClass is a wrapper around the C record GtkVButtonBoxClass.
type VButtonBoxClass struct {
	native *C.GtkVButtonBoxClass
	// parent_class : record
}

func VButtonBoxClassNewFromC(u unsafe.Pointer) *VButtonBoxClass {
	c := (*C.GtkVButtonBoxClass)(u)
	if c == nil {
		return nil
	}

	g := &VButtonBoxClass{native: c}

	return g
}

func (recv *VButtonBoxClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VButtonBoxClass with another VButtonBoxClass, and returns true if they represent the same GObject.
func (recv *VButtonBoxClass) Equals(other *VButtonBoxClass) bool {
	return other.ToC() == recv.ToC()
}

// VPanedClass is a wrapper around the C record GtkVPanedClass.
type VPanedClass struct {
	native *C.GtkVPanedClass
	// parent_class : record
}

func VPanedClassNewFromC(u unsafe.Pointer) *VPanedClass {
	c := (*C.GtkVPanedClass)(u)
	if c == nil {
		return nil
	}

	g := &VPanedClass{native: c}

	return g
}

func (recv *VPanedClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VPanedClass with another VPanedClass, and returns true if they represent the same GObject.
func (recv *VPanedClass) Equals(other *VPanedClass) bool {
	return other.ToC() == recv.ToC()
}

// VScaleClass is a wrapper around the C record GtkVScaleClass.
type VScaleClass struct {
	native *C.GtkVScaleClass
	// parent_class : record
}

func VScaleClassNewFromC(u unsafe.Pointer) *VScaleClass {
	c := (*C.GtkVScaleClass)(u)
	if c == nil {
		return nil
	}

	g := &VScaleClass{native: c}

	return g
}

func (recv *VScaleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VScaleClass with another VScaleClass, and returns true if they represent the same GObject.
func (recv *VScaleClass) Equals(other *VScaleClass) bool {
	return other.ToC() == recv.ToC()
}

// VScrollbarClass is a wrapper around the C record GtkVScrollbarClass.
type VScrollbarClass struct {
	native *C.GtkVScrollbarClass
	// parent_class : record
}

func VScrollbarClassNewFromC(u unsafe.Pointer) *VScrollbarClass {
	c := (*C.GtkVScrollbarClass)(u)
	if c == nil {
		return nil
	}

	g := &VScrollbarClass{native: c}

	return g
}

func (recv *VScrollbarClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VScrollbarClass with another VScrollbarClass, and returns true if they represent the same GObject.
func (recv *VScrollbarClass) Equals(other *VScrollbarClass) bool {
	return other.ToC() == recv.ToC()
}

// VSeparatorClass is a wrapper around the C record GtkVSeparatorClass.
type VSeparatorClass struct {
	native *C.GtkVSeparatorClass
	// parent_class : record
}

func VSeparatorClassNewFromC(u unsafe.Pointer) *VSeparatorClass {
	c := (*C.GtkVSeparatorClass)(u)
	if c == nil {
		return nil
	}

	g := &VSeparatorClass{native: c}

	return g
}

func (recv *VSeparatorClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VSeparatorClass with another VSeparatorClass, and returns true if they represent the same GObject.
func (recv *VSeparatorClass) Equals(other *VSeparatorClass) bool {
	return other.ToC() == recv.ToC()
}

// ViewportClass is a wrapper around the C record GtkViewportClass.
type ViewportClass struct {
	native *C.GtkViewportClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func ViewportClassNewFromC(u unsafe.Pointer) *ViewportClass {
	c := (*C.GtkViewportClass)(u)
	if c == nil {
		return nil
	}

	g := &ViewportClass{native: c}

	return g
}

func (recv *ViewportClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ViewportClass with another ViewportClass, and returns true if they represent the same GObject.
func (recv *ViewportClass) Equals(other *ViewportClass) bool {
	return other.ToC() == recv.ToC()
}

// ViewportPrivate is a wrapper around the C record GtkViewportPrivate.
type ViewportPrivate struct {
	native *C.GtkViewportPrivate
}

func ViewportPrivateNewFromC(u unsafe.Pointer) *ViewportPrivate {
	c := (*C.GtkViewportPrivate)(u)
	if c == nil {
		return nil
	}

	g := &ViewportPrivate{native: c}

	return g
}

func (recv *ViewportPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this ViewportPrivate with another ViewportPrivate, and returns true if they represent the same GObject.
func (recv *ViewportPrivate) Equals(other *ViewportPrivate) bool {
	return other.ToC() == recv.ToC()
}

// VolumeButtonClass is a wrapper around the C record GtkVolumeButtonClass.
type VolumeButtonClass struct {
	native *C.GtkVolumeButtonClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func VolumeButtonClassNewFromC(u unsafe.Pointer) *VolumeButtonClass {
	c := (*C.GtkVolumeButtonClass)(u)
	if c == nil {
		return nil
	}

	g := &VolumeButtonClass{native: c}

	return g
}

func (recv *VolumeButtonClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this VolumeButtonClass with another VolumeButtonClass, and returns true if they represent the same GObject.
func (recv *VolumeButtonClass) Equals(other *VolumeButtonClass) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessibleClass is a wrapper around the C record GtkWidgetAccessibleClass.
type WidgetAccessibleClass struct {
	native *C.GtkWidgetAccessibleClass
	// parent_class : record
	// no type for notify_gtk
}

func WidgetAccessibleClassNewFromC(u unsafe.Pointer) *WidgetAccessibleClass {
	c := (*C.GtkWidgetAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &WidgetAccessibleClass{native: c}

	return g
}

func (recv *WidgetAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WidgetAccessibleClass with another WidgetAccessibleClass, and returns true if they represent the same GObject.
func (recv *WidgetAccessibleClass) Equals(other *WidgetAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// WidgetAccessiblePrivate is a wrapper around the C record GtkWidgetAccessiblePrivate.
type WidgetAccessiblePrivate struct {
	native *C.GtkWidgetAccessiblePrivate
}

func WidgetAccessiblePrivateNewFromC(u unsafe.Pointer) *WidgetAccessiblePrivate {
	c := (*C.GtkWidgetAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &WidgetAccessiblePrivate{native: c}

	return g
}

func (recv *WidgetAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WidgetAccessiblePrivate with another WidgetAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *WidgetAccessiblePrivate) Equals(other *WidgetAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// WidgetClass is a wrapper around the C record GtkWidgetClass.
type WidgetClass struct {
	native *C.GtkWidgetClass
	// parent_class : record
	ActivateSignal uint32
	// no type for dispatch_child_properties_changed
	// no type for destroy
	// no type for show
	// no type for show_all
	// no type for hide
	// no type for map
	// no type for unmap
	// no type for realize
	// no type for unrealize
	// no type for size_allocate
	// no type for state_changed
	// no type for state_flags_changed
	// no type for parent_set
	// no type for hierarchy_changed
	// no type for style_set
	// no type for direction_changed
	// no type for grab_notify
	// no type for child_notify
	// no type for draw
	// no type for get_request_mode
	// no type for get_preferred_height
	// no type for get_preferred_width_for_height
	// no type for get_preferred_width
	// no type for get_preferred_height_for_width
	// no type for mnemonic_activate
	// no type for grab_focus
	// no type for focus
	// no type for move_focus
	// no type for keynav_failed
	// no type for event
	// no type for button_press_event
	// no type for button_release_event
	// no type for scroll_event
	// no type for motion_notify_event
	// no type for delete_event
	// no type for destroy_event
	// no type for key_press_event
	// no type for key_release_event
	// no type for enter_notify_event
	// no type for leave_notify_event
	// no type for configure_event
	// no type for focus_in_event
	// no type for focus_out_event
	// no type for map_event
	// no type for unmap_event
	// no type for property_notify_event
	// no type for selection_clear_event
	// no type for selection_request_event
	// no type for selection_notify_event
	// no type for proximity_in_event
	// no type for proximity_out_event
	// no type for visibility_notify_event
	// no type for window_state_event
	// no type for damage_event
	// no type for grab_broken_event
	// no type for selection_get
	// no type for selection_received
	// no type for drag_begin
	// no type for drag_end
	// no type for drag_data_get
	// no type for drag_data_delete
	// no type for drag_leave
	// no type for drag_motion
	// no type for drag_drop
	// no type for drag_data_received
	// no type for drag_failed
	// no type for popup_menu
	// no type for show_help
	// no type for get_accessible
	// no type for screen_changed
	// no type for can_activate_accel
	// no type for composited_changed
	// no type for query_tooltip
	// no type for compute_expand
	// no type for adjust_size_request
	// no type for adjust_size_allocation
	// no type for style_updated
	// no type for touch_event
	// no type for get_preferred_height_and_baseline_for_width
	// no type for adjust_baseline_request
	// no type for adjust_baseline_allocation
	// no type for queue_draw_region
	// Private : priv
	// no type for _gtk_reserved6
	// no type for _gtk_reserved7
}

func WidgetClassNewFromC(u unsafe.Pointer) *WidgetClass {
	c := (*C.GtkWidgetClass)(u)
	if c == nil {
		return nil
	}

	g := &WidgetClass{
		ActivateSignal: (uint32)(c.activate_signal),
		native:         c,
	}

	return g
}

func (recv *WidgetClass) ToC() unsafe.Pointer {
	recv.native.activate_signal =
		(C.guint)(recv.ActivateSignal)

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WidgetClass with another WidgetClass, and returns true if they represent the same GObject.
func (recv *WidgetClass) Equals(other *WidgetClass) bool {
	return other.ToC() == recv.ToC()
}

// FindStyleProperty is a wrapper around the C function gtk_widget_class_find_style_property.
func (recv *WidgetClass) FindStyleProperty(propertyName string) *gobject.ParamSpec {
	c_property_name := C.CString(propertyName)
	defer C.free(unsafe.Pointer(c_property_name))

	retC := C.gtk_widget_class_find_style_property((*C.GtkWidgetClass)(recv.native), c_property_name)
	retGo := gobject.ParamSpecNewFromC(unsafe.Pointer(retC))

	return retGo
}

// InstallStyleProperty is a wrapper around the C function gtk_widget_class_install_style_property.
func (recv *WidgetClass) InstallStyleProperty(pspec *gobject.ParamSpec) {
	c_pspec := (*C.GParamSpec)(C.NULL)
	if pspec != nil {
		c_pspec = (*C.GParamSpec)(pspec.ToC())
	}

	C.gtk_widget_class_install_style_property((*C.GtkWidgetClass)(recv.native), c_pspec)

	return
}

// Unsupported : gtk_widget_class_install_style_property_parser : unsupported parameter parser : no type generator for RcPropertyParser (GtkRcPropertyParser) for param parser

// Unsupported : gtk_widget_class_list_style_properties : array return type :

// WidgetClassPrivate is a wrapper around the C record GtkWidgetClassPrivate.
type WidgetClassPrivate struct {
	native *C.GtkWidgetClassPrivate
}

func WidgetClassPrivateNewFromC(u unsafe.Pointer) *WidgetClassPrivate {
	c := (*C.GtkWidgetClassPrivate)(u)
	if c == nil {
		return nil
	}

	g := &WidgetClassPrivate{native: c}

	return g
}

func (recv *WidgetClassPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WidgetClassPrivate with another WidgetClassPrivate, and returns true if they represent the same GObject.
func (recv *WidgetClassPrivate) Equals(other *WidgetClassPrivate) bool {
	return other.ToC() == recv.ToC()
}

// WidgetPath is a wrapper around the C record GtkWidgetPath.
type WidgetPath struct {
	native *C.GtkWidgetPath
}

func WidgetPathNewFromC(u unsafe.Pointer) *WidgetPath {
	c := (*C.GtkWidgetPath)(u)
	if c == nil {
		return nil
	}

	g := &WidgetPath{native: c}

	return g
}

func (recv *WidgetPath) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WidgetPath with another WidgetPath, and returns true if they represent the same GObject.
func (recv *WidgetPath) Equals(other *WidgetPath) bool {
	return other.ToC() == recv.ToC()
}

// IterGetName is a wrapper around the C function gtk_widget_path_iter_get_name.
func (recv *WidgetPath) IterGetName(pos int32) string {
	c_pos := (C.gint)(pos)

	retC := C.gtk_widget_path_iter_get_name((*C.GtkWidgetPath)(recv.native), c_pos)
	retGo := C.GoString(retC)

	return retGo
}

// IterGetSiblingIndex is a wrapper around the C function gtk_widget_path_iter_get_sibling_index.
func (recv *WidgetPath) IterGetSiblingIndex(pos int32) uint32 {
	c_pos := (C.gint)(pos)

	retC := C.gtk_widget_path_iter_get_sibling_index((*C.GtkWidgetPath)(recv.native), c_pos)
	retGo := (uint32)(retC)

	return retGo
}

// IterGetSiblings is a wrapper around the C function gtk_widget_path_iter_get_siblings.
func (recv *WidgetPath) IterGetSiblings(pos int32) *WidgetPath {
	c_pos := (C.gint)(pos)

	retC := C.gtk_widget_path_iter_get_siblings((*C.GtkWidgetPath)(recv.native), c_pos)
	retGo := WidgetPathNewFromC(unsafe.Pointer(retC))

	return retGo
}

// WidgetPrivate is a wrapper around the C record GtkWidgetPrivate.
type WidgetPrivate struct {
	native *C.GtkWidgetPrivate
}

func WidgetPrivateNewFromC(u unsafe.Pointer) *WidgetPrivate {
	c := (*C.GtkWidgetPrivate)(u)
	if c == nil {
		return nil
	}

	g := &WidgetPrivate{native: c}

	return g
}

func (recv *WidgetPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WidgetPrivate with another WidgetPrivate, and returns true if they represent the same GObject.
func (recv *WidgetPrivate) Equals(other *WidgetPrivate) bool {
	return other.ToC() == recv.ToC()
}

// WindowAccessibleClass is a wrapper around the C record GtkWindowAccessibleClass.
type WindowAccessibleClass struct {
	native *C.GtkWindowAccessibleClass
	// parent_class : record
}

func WindowAccessibleClassNewFromC(u unsafe.Pointer) *WindowAccessibleClass {
	c := (*C.GtkWindowAccessibleClass)(u)
	if c == nil {
		return nil
	}

	g := &WindowAccessibleClass{native: c}

	return g
}

func (recv *WindowAccessibleClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowAccessibleClass with another WindowAccessibleClass, and returns true if they represent the same GObject.
func (recv *WindowAccessibleClass) Equals(other *WindowAccessibleClass) bool {
	return other.ToC() == recv.ToC()
}

// WindowAccessiblePrivate is a wrapper around the C record GtkWindowAccessiblePrivate.
type WindowAccessiblePrivate struct {
	native *C.GtkWindowAccessiblePrivate
}

func WindowAccessiblePrivateNewFromC(u unsafe.Pointer) *WindowAccessiblePrivate {
	c := (*C.GtkWindowAccessiblePrivate)(u)
	if c == nil {
		return nil
	}

	g := &WindowAccessiblePrivate{native: c}

	return g
}

func (recv *WindowAccessiblePrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowAccessiblePrivate with another WindowAccessiblePrivate, and returns true if they represent the same GObject.
func (recv *WindowAccessiblePrivate) Equals(other *WindowAccessiblePrivate) bool {
	return other.ToC() == recv.ToC()
}

// WindowClass is a wrapper around the C record GtkWindowClass.
type WindowClass struct {
	native *C.GtkWindowClass
	// parent_class : record
	// no type for set_focus
	// no type for activate_focus
	// no type for activate_default
	// no type for keys_changed
	// no type for enable_debugging
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
}

func WindowClassNewFromC(u unsafe.Pointer) *WindowClass {
	c := (*C.GtkWindowClass)(u)
	if c == nil {
		return nil
	}

	g := &WindowClass{native: c}

	return g
}

func (recv *WindowClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowClass with another WindowClass, and returns true if they represent the same GObject.
func (recv *WindowClass) Equals(other *WindowClass) bool {
	return other.ToC() == recv.ToC()
}

// WindowGeometryInfo is a wrapper around the C record GtkWindowGeometryInfo.
type WindowGeometryInfo struct {
	native *C.GtkWindowGeometryInfo
}

func WindowGeometryInfoNewFromC(u unsafe.Pointer) *WindowGeometryInfo {
	c := (*C.GtkWindowGeometryInfo)(u)
	if c == nil {
		return nil
	}

	g := &WindowGeometryInfo{native: c}

	return g
}

func (recv *WindowGeometryInfo) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowGeometryInfo with another WindowGeometryInfo, and returns true if they represent the same GObject.
func (recv *WindowGeometryInfo) Equals(other *WindowGeometryInfo) bool {
	return other.ToC() == recv.ToC()
}

// WindowGroupClass is a wrapper around the C record GtkWindowGroupClass.
type WindowGroupClass struct {
	native *C.GtkWindowGroupClass
	// parent_class : record
	// no type for _gtk_reserved1
	// no type for _gtk_reserved2
	// no type for _gtk_reserved3
	// no type for _gtk_reserved4
}

func WindowGroupClassNewFromC(u unsafe.Pointer) *WindowGroupClass {
	c := (*C.GtkWindowGroupClass)(u)
	if c == nil {
		return nil
	}

	g := &WindowGroupClass{native: c}

	return g
}

func (recv *WindowGroupClass) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowGroupClass with another WindowGroupClass, and returns true if they represent the same GObject.
func (recv *WindowGroupClass) Equals(other *WindowGroupClass) bool {
	return other.ToC() == recv.ToC()
}

// WindowGroupPrivate is a wrapper around the C record GtkWindowGroupPrivate.
type WindowGroupPrivate struct {
	native *C.GtkWindowGroupPrivate
}

func WindowGroupPrivateNewFromC(u unsafe.Pointer) *WindowGroupPrivate {
	c := (*C.GtkWindowGroupPrivate)(u)
	if c == nil {
		return nil
	}

	g := &WindowGroupPrivate{native: c}

	return g
}

func (recv *WindowGroupPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowGroupPrivate with another WindowGroupPrivate, and returns true if they represent the same GObject.
func (recv *WindowGroupPrivate) Equals(other *WindowGroupPrivate) bool {
	return other.ToC() == recv.ToC()
}

// WindowPrivate is a wrapper around the C record GtkWindowPrivate.
type WindowPrivate struct {
	native *C.GtkWindowPrivate
}

func WindowPrivateNewFromC(u unsafe.Pointer) *WindowPrivate {
	c := (*C.GtkWindowPrivate)(u)
	if c == nil {
		return nil
	}

	g := &WindowPrivate{native: c}

	return g
}

func (recv *WindowPrivate) ToC() unsafe.Pointer {

	return (unsafe.Pointer)(recv.native)
}

// Equals compares this WindowPrivate with another WindowPrivate, and returns true if they represent the same GObject.
func (recv *WindowPrivate) Equals(other *WindowPrivate) bool {
	return other.ToC() == recv.ToC()
}
